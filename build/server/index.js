var __defProp = Object.defineProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var __privateWrapper = (obj, member, setter, getter) => ({
  set _(value) {
    __privateSet(obj, member, value, setter);
  },
  get _() {
    return __privateGet(obj, member, getter);
  }
});
var _listener, _listeners, _cancelled, _allowInsecure, _gzip, _headers, _method, _timeout, _url, _body, _bodyType, _creds, _preflight, _process, _retry, _signal, _throttle, _getUrlFunc, _FetchRequest_instances, send_fn, _statusCode, _statusMessage, _headers2, _body2, _request, _error, _format, _val, _tens, _FixedNumber_instances, checkFormat_fn, checkValue_fn, add_fn, sub_fn, mul_fn, div_fn, _names, _data, _dataLength, _Writer_instances, writeData_fn, _data2, _offset, _bytesRead, _parent, _maxInflation, _Reader_instances, incrementBytesRead_fn, peekBytes_fn, _r2, _s2, _v, _networkV, _privateKey, _options, _type, _to, _data3, _nonce, _gasLimit, _gasPrice, _maxPriorityFeePerGas, _maxFeePerGas, _value, _chainId, _sig, _accessList, _maxFeePerBlobGas, _blobVersionedHashes, _kzg, _blobs, _Transaction_instances, getSerialized_fn, _types, _fullTypes, _encoderCache, _TypedDataEncoder_instances, getEncoder_fn, _offset2, _tokens, _TokenString_instances, subTokenString_fn, _ParamType_instances, walkAsync_fn, _AbiCoder_instances, getCoder_fn, _errors, _events, _functions, _abiCoder, _Interface_instances, getFunction_fn, getEvent_fn, _transactions, _logs, _startBlock, _iface, _iface2, _filter, _a2, _supports2544, _resolver, _EnsResolver_instances, fetch_fn, _EnsResolver_static, getResolver_fn, _url2, _processFunc, _name, _chainId2, _plugins, _provider, _poller, _interval, _blockNumber, _PollingBlockSubscriber_instances, poll_fn, _provider2, _poll, _running, _tag, _lastBlock, _filter2, _hash, _provider3, _filter3, _poller2, _running2, _blockNumber2, _PollingEventSubscriber_instances, poll_fn2, _subs, _plugins2, _pausedState, _destroyed, _networkPromise, _anyNetwork, _performCache, _lastBlockNumber, _nextTimer, _timers, _disableCcipRead, _options2, _AbstractProvider_instances, perform_fn, call_fn, checkNetwork_fn, getAccountValue_fn, getBlock_fn, hasSub_fn, getSub_fn, _provider4, _filterIdPromise, _poller3, _running3, _network, _hault, _FilterIdSubscriber_instances, poll_fn3, teardown_fn, _event, _options3, _nextId, _payloads, _drainTimer, _notReady, _network2, _pendingDetectNetwork, _JsonRpcApiProvider_instances, scheduleDrain_fn, _pollingInterval, _connect, _request2, _b, _c, _d2, _e2, _f, _g, _h, _i2, _j, _k, _l2, _m2, _n2, _o2;
import { jsx, jsxs, Fragment as Fragment$1 } from "react/jsx-runtime";
import { PassThrough } from "node:stream";
import { createReadableStreamFromReadable, redirect } from "@remix-run/node";
import { RemixServer, Link, Outlet, Meta, Links, ScrollRestoration, Scripts, useNavigate, useSearchParams, useParams, useLocation } from "@remix-run/react";
import * as isbotModule from "isbot";
import { renderToPipeableStream } from "react-dom/server";
import * as ze__default from "react";
import ze__default__default, { createContext, useContext, useState, useEffect, useCallback, useRef, useMemo, useLayoutEffect, useId, forwardRef, Fragment as Fragment$2, memo, useImperativeHandle, useReducer, cloneElement, isValidElement } from "react";
import useSWR, { mutate as mutate$1, useSWRConfig, unstable_serialize as unstable_serialize$1 } from "swr";
import useSWRMutation from "swr/mutation";
import useConstant from "use-constant";
import Na from "eventemitter3";
import { PublicKey, Connection, clusterApiUrl, Transaction as Transaction$1, TransactionInstruction, SystemProgram, ComputeBudgetProgram, TransactionMessage, VersionedTransaction } from "@solana/web3.js";
import { keccak_256 } from "@noble/hashes/sha3";
import require$$0 from "buffer-polyfill";
import require$$1 from "process";
import a from "decimal.js-light";
import "dayjs";
import __cjsInterop1__$2 from "lodash";
import useSWRInfinite, { unstable_serialize } from "swr/infinite";
import * as amplitude from "@amplitude/analytics-browser";
import { pathOr, prop, omit, propOr, isNil, mergeDeepRight, path, pick, compose, head, lensIndex, over, min } from "ramda";
import { create } from "zustand";
import { immer } from "zustand/middleware/immer";
import useSWRSubscription from "swr/subscription";
import { useDebouncedCallback, useThrottledCallback } from "use-debounce";
import { produce } from "immer";
import * as P$4 from "@noble/ed25519";
import __cjsInterop1__ from "bs58";
import { bytesToHex, hexToBytes } from "ethereum-cryptography/utils";
import { keccak256 as keccak256$1 } from "ethereum-cryptography/keccak";
import __cjsInterop1__$1 from "@coral-xyz/anchor";
import { getAssociatedTokenAddressSync, getAccount } from "@solana/spl-token";
import { addressToBytes32 } from "@layerzerolabs/lz-v2-utilities";
import { OAPP_SEED, PEER_SEED, ENFORCED_OPTIONS_SEED, MESSAGE_LIB_SEED, SEND_LIBRARY_CONFIG_SEED, ENDPOINT_SEED, NONCE_SEED, EVENT_SEED, ULN_SEED, SEND_CONFIG_SEED, EXECUTOR_CONFIG_SEED, PRICE_FEED_SEED, DVN_CONFIG_SEED } from "@layerzerolabs/lz-solana-sdk-v2";
import { WalletAdapterNetwork, WalletNotReadyError, WalletReadyState } from "@solana/wallet-adapter-base";
import { getParsedEthersError } from "@enzoferey/ethers-error-parser";
import { ens_normalize } from "@adraffy/ens-normalize";
import http from "http";
import https from "https";
import { gunzipSync } from "zlib";
import "randombytes";
import require$$1$1 from "create-hash";
import "create-hmac";
import "browserify-sign/algos.js";
import require$$4 from "pbkdf2";
import require$$5 from "browserify-cipher";
import require$$6 from "diffie-hellman";
import require$$7 from "browserify-sign";
import "create-ecdh";
import require$$9 from "public-encrypt";
import require$$10 from "randomfill";
import { secp256k1 } from "@noble/curves/secp256k1";
import { qrcode } from "@akamfoad/qr";
import { WalletProvider, useWallet } from "@solana/wallet-adapter-react";
import { WalletModalProvider, useWalletModal } from "@solana/wallet-adapter-react-ui";
import { createTV, tv, cnBase, cn as cn$2 } from "tailwind-variants";
import { Slot } from "@radix-ui/react-slot";
import { format, isValid, subDays, differenceInDays, getYear, getMonth, getDate, set, addDays, setHours, startOfSecond, startOfMinute, startOfHour, startOfDay, startOfMonth, startOfYear, startOfWeek } from "date-fns";
import * as fe$4 from "@radix-ui/react-avatar";
import uc from "ethereum-blockies-base64";
import * as P$5 from "@radix-ui/react-select";
import { SelectItem, SelectItemText, ItemIndicator } from "@radix-ui/react-select";
import * as q$4 from "@radix-ui/react-popover";
import * as J$3 from "@radix-ui/react-scroll-area";
import * as X$3 from "@radix-ui/react-tooltip";
import * as Ho$4 from "@radix-ui/react-checkbox";
import * as Go$2 from "@radix-ui/react-switch";
import { useReactTable, getFilteredRowModel, getSortedRowModel, getExpandedRowModel, getCoreRowModel, getPaginationRowModel, createColumnHelper, flexRender } from "@tanstack/react-table";
import { enUS, zhCN } from "date-fns/locale";
import { ErrorBoundary } from "react-error-boundary";
import { DayPicker } from "react-day-picker";
import * as E$5 from "@radix-ui/react-dialog";
import * as ie$2 from "@radix-ui/react-tabs";
import * as ae$4 from "@radix-ui/react-hover-card";
import * as ke$6 from "@radix-ui/react-slider";
import toast$2, { Toaster, ToastBar, toast as toast$1 } from "react-hot-toast";
import * as D$3 from "@radix-ui/react-dropdown-menu";
import injectedModule from "@web3-onboard/injected-wallets";
import { init, useConnectWallet, useSetChain } from "@web3-onboard/react";
import binanceModule from "@binance/w3w-blocknative-connector";
import { SolanaMobileWalletAdapter, createDefaultAuthorizationResultCache, createDefaultAddressSelector } from "@solana-mobile/wallet-adapter-mobile";
import { PhantomWalletAdapter } from "@solana/wallet-adapter-wallets";
import { createInstance } from "i18next";
import { I18nContext, useTranslation, Trans } from "react-i18next";
import G$8 from "i18next-browser-languagedetector";
import "@web3-onboard/walletconnect";
import { UTCDateMini } from "@date-fns/utc";
import _a from "jsqr";
import { ResponsiveContainer, BarChart, Tooltip, CartesianGrid, ReferenceLine, Bar, Cell, YAxis, XAxis, LineChart, Line, Cross } from "recharts";
import nt$2 from "embla-carousel-react";
import _extends from "@babel/runtime/helpers/extends";
import _objectWithoutPropertiesLoose from "@babel/runtime/helpers/objectWithoutPropertiesLoose";
const ABORT_DELAY = 5e3;
function handleRequest(request2, responseStatusCode, responseHeaders, remixContext, loadContext) {
  let prohibitOutOfOrderStreaming = isBotRequest(request2.headers.get("user-agent")) || remixContext.isSpaMode;
  return prohibitOutOfOrderStreaming ? handleBotRequest(
    request2,
    responseStatusCode,
    responseHeaders,
    remixContext
  ) : handleBrowserRequest(
    request2,
    responseStatusCode,
    responseHeaders,
    remixContext
  );
}
function isBotRequest(userAgent) {
  if (!userAgent) {
    return false;
  }
  if ("isbot" in isbotModule && typeof isbotModule.isbot === "function") {
    return isbotModule.isbot(userAgent);
  }
  if ("default" in isbotModule && typeof isbotModule.default === "function") {
    return isbotModule.default(userAgent);
  }
  return false;
}
function handleBotRequest(request2, responseStatusCode, responseHeaders, remixContext) {
  return new Promise((resolve, reject) => {
    let shellRendered = false;
    const { pipe, abort } = renderToPipeableStream(
      /* @__PURE__ */ jsx(
        RemixServer,
        {
          context: remixContext,
          url: request2.url,
          abortDelay: ABORT_DELAY
        }
      ),
      {
        onAllReady() {
          shellRendered = true;
          const body = new PassThrough();
          const stream = createReadableStreamFromReadable(body);
          responseHeaders.set("Content-Type", "text/html");
          resolve(
            new Response(stream, {
              headers: responseHeaders,
              status: responseStatusCode
            })
          );
          pipe(body);
        },
        onShellError(error) {
          reject(error);
        },
        onError(error) {
          responseStatusCode = 500;
          if (shellRendered) {
            console.error(error);
          }
        }
      }
    );
    setTimeout(abort, ABORT_DELAY);
  });
}
function handleBrowserRequest(request2, responseStatusCode, responseHeaders, remixContext) {
  return new Promise((resolve, reject) => {
    let shellRendered = false;
    const { pipe, abort } = renderToPipeableStream(
      /* @__PURE__ */ jsx(
        RemixServer,
        {
          context: remixContext,
          url: request2.url,
          abortDelay: ABORT_DELAY
        }
      ),
      {
        onShellReady() {
          shellRendered = true;
          const body = new PassThrough();
          const stream = createReadableStreamFromReadable(body);
          responseHeaders.set("Content-Type", "text/html");
          resolve(
            new Response(stream, {
              headers: responseHeaders,
              status: responseStatusCode
            })
          );
          pipe(body);
        },
        onShellError(error) {
          reject(error);
        },
        onError(error) {
          responseStatusCode = 500;
          if (shellRendered) {
            console.error(error);
          }
        }
      }
    );
    setTimeout(abort, ABORT_DELAY);
  });
}
const entryServer = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: handleRequest
}, Symbol.toStringTag, { value: "Module" }));
var __defProp$2 = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a2, b2) => {
  for (var prop2 in b2 || (b2 = {}))
    if (__hasOwnProp.call(b2, prop2))
      __defNormalProp2(a2, prop2, b2[prop2]);
  if (__getOwnPropSymbols)
    for (var prop2 of __getOwnPropSymbols(b2)) {
      if (__propIsEnum.call(b2, prop2))
        __defNormalProp2(a2, prop2, b2[prop2]);
    }
  return a2;
};
var __spreadProps = (a2, b2) => __defProps(a2, __getOwnPropDescs(b2));
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e2) {
        reject(e2);
      }
    };
    var step = (x2) => x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
if (typeof window !== "undefined") {
  window.__ORDERLY_VERSION__ = window.__ORDERLY_VERSION__ || {};
  window.__ORDERLY_VERSION__["@orderly.network/net"] = "2.2.0";
}
var ApiError$1 = class ApiError extends Error {
  constructor(message, code) {
    super(message);
    this.code = code;
    this.name = "ApiError";
  }
};
function request(url, options) {
  return __async(this, null, function* () {
    if (!url.startsWith("http")) {
      throw new Error("url must start with http(s)");
    }
    const response = yield fetch(url, __spreadProps(__spreadValues({}, options), {
      // mode: "cors",
      // credentials: "include",
      headers: _createHeaders(options.headers, options.method)
    }));
    if (response.ok) {
      const res = yield response.json();
      return res;
    } else {
      try {
        const errorMsg = yield response.json();
        if (response.status === 400) {
          throw new ApiError$1(
            errorMsg.message || errorMsg.code || response.statusText,
            errorMsg.code
          );
        }
        throw new Error(errorMsg.message || errorMsg.code || response.statusText);
      } catch (e2) {
        throw e2;
      }
    }
  });
}
function _createHeaders(headers = {}, method) {
  const _headers3 = new Headers(headers);
  if (!_headers3.has("Content-Type")) {
    if (method !== "DELETE") {
      _headers3.append("Content-Type", "application/json;charset=utf-8");
    } else {
      _headers3.append("Content-Type", "application/x-www-form-urlencoded");
    }
  }
  return _headers3;
}
function get(url, options, formatter) {
  return __async(this, null, function* () {
    const res = yield request(url, __spreadValues({
      method: "GET"
    }, options));
    if (res.success) {
      if (typeof formatter === "function") {
        return formatter(res.data);
      }
      if (Array.isArray(res.data["rows"])) {
        return res.data["rows"];
      }
      return res.data;
    }
    throw new Error(res.message);
  });
}
function mutate(url, init2) {
  return __async(this, null, function* () {
    const res = yield request(url, init2);
    return res;
  });
}
var BaseHandler = class {
  handle(message, webSocket) {
    throw new Error("Method not implemented.");
  }
};
var PingHandler = class extends BaseHandler {
  handle(_2, webSocket) {
    webSocket.send(JSON.stringify({ event: "pong", ts: Date.now() }));
  }
};
var messageHandlers = /* @__PURE__ */ new Map([
  ["ping", new PingHandler()]
]);
var defaultMessageFormatter = (message) => message.data;
var COMMON_ID = "OqdphuyCtYWxwzhxyLLjOWNdFP7sQt8RPWzmb5xY";
var TIME_OUT = 1e3 * 60 * 2;
var CONNECT_LIMIT = 5;
var WS = class {
  constructor(options) {
    this.options = options;
    this._eventContainer = /* @__PURE__ */ new Map();
    this.publicIsReconnecting = false;
    this.privateIsReconnecting = false;
    this.reconnectInterval = 1e3;
    this.authenticated = false;
    this._pendingPrivateSubscribe = [];
    this._pendingPublicSubscribe = [];
    this._eventHandlers = /* @__PURE__ */ new Map();
    this._eventPrivateHandlers = /* @__PURE__ */ new Map();
    this._publicRetryCount = 0;
    this._privateRetryCount = 0;
    this.send = (message) => {
      if (typeof message !== "string") {
        message = JSON.stringify(message);
      }
      if (typeof message === "undefined")
        return;
      if (this._publicSocket.readyState === WebSocket.OPEN) {
        this._publicSocket.send(message);
      } else {
        console.warn("WebSocket connection is not open. Cannot send message.");
      }
    };
    this.createPublicSC(options);
    if (!!options.accountId) {
      this.createPrivateSC(options);
    }
    this.bindEvents();
  }
  bindEvents() {
    var _a3, _b2;
    if (typeof document !== "undefined") {
      (_a3 = document.addEventListener) == null ? void 0 : _a3.call(
        document,
        "visibilitychange",
        this.onVisibilityChange.bind(this)
      );
    }
    if (typeof window !== "undefined") {
      (_b2 = window.addEventListener) == null ? void 0 : _b2.call(window, "online", this.onNetworkStatusChange.bind(this));
    }
  }
  onVisibilityChange() {
    if (document.visibilityState === "visible") {
      this.checkSocketStatus();
    }
  }
  onNetworkStatusChange() {
    if (navigator.onLine) {
      this.checkSocketStatus();
    }
  }
  /**
   * Determine the current connection status,
   * 1. If it is disconnected, reconnect
   * 2. If no message is received for too long, disconnect and reconnect actively
   * 3. When returning from the background and the network status changes, the following process is followed
   */
  checkSocketStatus() {
    var _a3, _b2;
    const now = Date.now();
    if (document.visibilityState !== "visible")
      return;
    if (!navigator.onLine)
      return;
    if (!this.publicIsReconnecting) {
      if (this._publicSocket.readyState === WebSocket.CLOSED) {
        this.reconnectPublic();
      } else {
        if (now - this._publicHeartbeatTime > TIME_OUT) {
          this._publicSocket.close();
        }
      }
    }
    if (!this.privateIsReconnecting) {
      if (((_a3 = this.privateSocket) == null ? void 0 : _a3.readyState) === WebSocket.CLOSED) {
        this.reconnectPrivate();
      } else {
        if (this._privateHeartbeatTime && now - this._privateHeartbeatTime > TIME_OUT) {
          (_b2 = this.privateSocket) == null ? void 0 : _b2.close();
        }
      }
    }
  }
  openPrivate(accountId) {
    var _a3;
    if (((_a3 = this.privateSocket) == null ? void 0 : _a3.readyState) === WebSocket.OPEN) {
      return;
    }
    this.createPrivateSC(__spreadProps(__spreadValues({}, this.options), {
      accountId
    }));
  }
  closePrivate(code, reason) {
    var _a3, _b2;
    if (((_a3 = this.privateSocket) == null ? void 0 : _a3.readyState) !== WebSocket.OPEN) {
      return;
    }
    this.authenticated = false;
    this._pendingPrivateSubscribe = [];
    this._eventPrivateHandlers.clear();
    (_b2 = this.privateSocket) == null ? void 0 : _b2.close(code, reason);
  }
  createPublicSC(options) {
    if (this._publicSocket && this._publicSocket.readyState === WebSocket.OPEN)
      return;
    this._publicSocket = new WebSocket(
      `${this.options.publicUrl}/ws/stream/${COMMON_ID}`
    );
    this._publicSocket.onopen = this.onOpen.bind(this);
    this._publicSocket.addEventListener(
      "message",
      this.onPublicMessage.bind(this)
    );
    this._publicSocket.addEventListener("close", this.onPublicClose.bind(this));
    this._publicSocket.addEventListener("error", this.onPublicError.bind(this));
  }
  createPrivateSC(options) {
    if (this.privateSocket && this.privateSocket.readyState === WebSocket.OPEN)
      return;
    this.options = options;
    this.privateSocket = new WebSocket(
      `${this.options.privateUrl}/v2/ws/private/stream/${options.accountId}`
    );
    this.privateSocket.onopen = this.onPrivateOpen.bind(this);
    this.privateSocket.onmessage = this.onPrivateMessage.bind(this);
    this.privateSocket.onclose = this.onPrivateClose.bind(this);
    this.privateSocket.onerror = this.onPrivateError.bind(this);
  }
  onOpen(event) {
    if (this._pendingPublicSubscribe.length > 0) {
      this._pendingPublicSubscribe.forEach(([params, cb, isOnce]) => {
        this.subscribe(params, cb, isOnce);
      });
      this._pendingPublicSubscribe = [];
    }
    this.publicIsReconnecting = false;
    this._publicRetryCount = 0;
    this.emit("status:change", { type: "open", isPrivate: false });
  }
  onPrivateOpen(event) {
    this.authenticate(this.options.accountId);
    this.privateIsReconnecting = false;
    this._privateRetryCount = 0;
    this.emit("status:change", { type: "open", isPrivate: true });
  }
  onMessage(event, socket, handlerMap) {
    try {
      const message = JSON.parse(event.data);
      const commoneHandler = messageHandlers.get(message.event);
      if (message.event === "auth" && message.success) {
        this.authenticated = true;
        this.handlePendingPrivateTopic();
        return;
      }
      if (commoneHandler) {
        commoneHandler.handle(message, socket);
      } else {
        const topicKey = this.getTopicKeyFromMessage(message);
        const eventhandler = handlerMap.get(topicKey);
        if (eventhandler == null ? void 0 : eventhandler.callback) {
          eventhandler.callback.forEach((cb) => {
            const data = cb.formatter ? cb.formatter(message) : defaultMessageFormatter(message);
            if (data) {
              cb.onMessage(data);
            }
          });
        }
        this._eventContainer.forEach((_2, key) => {
          const reg = new RegExp(key);
          if (reg.test(topicKey)) {
            this.emit(key, message);
          }
        });
      }
    } catch (e2) {
    }
  }
  onPublicMessage(event) {
    this.onMessage(event, this._publicSocket, this._eventHandlers);
    this._publicHeartbeatTime = Date.now();
  }
  onPrivateMessage(event) {
    this.onMessage(event, this.privateSocket, this._eventPrivateHandlers);
    this._privateHeartbeatTime = Date.now();
  }
  handlePendingPrivateTopic() {
    if (this._pendingPrivateSubscribe.length > 0) {
      this._pendingPrivateSubscribe.forEach(([params, cb]) => {
        this.privateSubscribe(params, cb);
      });
      this._pendingPrivateSubscribe = [];
    }
  }
  onPublicClose(event) {
    this._eventHandlers.forEach((value, key) => {
      value.callback.forEach((cb) => {
        this._pendingPublicSubscribe.push([value.params, cb, value.isOnce]);
      });
      this._eventHandlers.delete(key);
    });
    this.emit("status:change", {
      type: "close",
      isPrivate: false
    });
    setTimeout(() => this.checkSocketStatus(), 0);
  }
  onPrivateClose(event) {
    if (event.code === 1e3)
      return;
    if (this.privateIsReconnecting)
      return;
    this._eventPrivateHandlers.forEach((value, key) => {
      value.callback.forEach((cb) => {
        this._pendingPrivateSubscribe.push([value.params, cb, value.isOnce]);
      });
      this._eventPrivateHandlers.delete(key);
    });
    this.authenticated = false;
    this.emit("status:change", {
      type: "close",
      isPrivate: true,
      event
    });
    setTimeout(() => this.checkSocketStatus(), 0);
  }
  onPublicError(event) {
    console.error("public WebSocket error:", event);
    this.publicIsReconnecting = false;
    if (this._publicSocket.readyState === WebSocket.OPEN) {
      this._publicSocket.close();
    } else {
      if (this._publicRetryCount > CONNECT_LIMIT)
        return;
      setTimeout(() => {
        this.reconnectPublic();
        this._publicRetryCount++;
      }, this._publicRetryCount * 1e3);
    }
    this.errorBoardscast(event, this._eventHandlers);
    this.emit("status:change", {
      type: "error",
      isPrivate: false
    });
  }
  onPrivateError(event) {
    var _a3;
    console.error("Private WebSocket error:", event);
    this.privateIsReconnecting = false;
    if (((_a3 = this.privateSocket) == null ? void 0 : _a3.readyState) === WebSocket.OPEN) {
      this.privateSocket.close();
    } else {
      if (this._privateRetryCount > CONNECT_LIMIT)
        return;
      setTimeout(() => {
        this.reconnectPrivate();
        this._privateRetryCount++;
      }, this._privateRetryCount * 1e3);
    }
    this.errorBoardscast(event, this._eventPrivateHandlers);
    this.emit("status:change", { type: "error", isPrivate: true });
  }
  errorBoardscast(error, eventHandlers) {
    eventHandlers.forEach((value) => {
      value.callback.forEach((cb) => {
        var _a3;
        (_a3 = cb.onError) == null ? void 0 : _a3.call(cb, error);
      });
    });
  }
  close() {
    var _a3;
    this._publicSocket.close();
    (_a3 = this.privateSocket) == null ? void 0 : _a3.close();
  }
  set accountId(accountId) {
  }
  authenticate(accountId) {
    return __async(this, null, function* () {
      var _a3, _b2;
      if (this.authenticated)
        return;
      if (!this.privateSocket) {
        console.error("private ws not connected");
        return;
      }
      if (this.privateSocket.readyState !== WebSocket.OPEN) {
        return;
      }
      const message = yield (_b2 = (_a3 = this.options).onSigntureRequest) == null ? void 0 : _b2.call(_a3, accountId);
      this.privateSocket.send(
        JSON.stringify({
          id: "auth",
          event: "auth",
          params: {
            orderly_key: message.publicKey,
            sign: message.signature,
            timestamp: message.timestamp
          }
        })
      );
    });
  }
  privateSubscribe(params, callback) {
    var _a3;
    const [subscribeMessage, onUnsubscribe] = this.generateMessage(
      params,
      callback.onUnsubscribe
    );
    if (((_a3 = this.privateSocket) == null ? void 0 : _a3.readyState) !== WebSocket.OPEN) {
      this._pendingPrivateSubscribe.push([params, callback]);
      return () => {
        this.unsubscribePrivate(subscribeMessage);
      };
    }
    const topic = subscribeMessage.topic || subscribeMessage.event;
    const handler = this._eventPrivateHandlers.get(topic);
    const callbacks = __spreadProps(__spreadValues({}, callback), {
      onUnsubscribe
    });
    if (!handler) {
      this._eventPrivateHandlers.set(topic, {
        params,
        callback: [callbacks]
      });
      this.privateSocket.send(JSON.stringify(subscribeMessage));
    } else {
      handler.callback.push(callbacks);
    }
    return () => {
      this.unsubscribePrivate(subscribeMessage);
    };
  }
  subscribe(params, callback, once, id2) {
    const [subscribeMessage, onUnsubscribe] = this.generateMessage(
      params,
      callback.onUnsubscribe,
      callback.onMessage
    );
    if (this._publicSocket.readyState !== WebSocket.OPEN) {
      this._pendingPublicSubscribe.push([params, callback, once, id2]);
      if (!once) {
        return () => {
          this.unsubscribePublic(subscribeMessage);
        };
      }
      return;
    }
    let topic = this.getTopicKeyFromParams(subscribeMessage);
    const handler = this._eventHandlers.get(topic);
    const callbacks = __spreadProps(__spreadValues({}, callback), {
      onUnsubscribe
    });
    if (!handler) {
      this._eventHandlers.set(topic, {
        params,
        isOnce: once,
        callback: [callbacks]
      });
      this._publicSocket.send(JSON.stringify(subscribeMessage));
    } else {
      if (once) {
        handler.callback = [callbacks];
        this._publicSocket.send(JSON.stringify(subscribeMessage));
      } else {
        handler.callback.push(callbacks);
      }
    }
    if (!once) {
      return () => {
        this.unsubscribePublic(subscribeMessage);
      };
    }
  }
  getTopicKeyFromParams(params) {
    let topic;
    if (params.topic) {
      topic = params.topic;
    } else {
      params.event;
      topic = params.event;
      if (params.id) {
        topic += `_${params.id}`;
      }
    }
    return topic;
  }
  getTopicKeyFromMessage(message) {
    let topic;
    if (message.topic) {
      topic = message.topic;
    } else {
      if (message.event) {
        topic = `${message.event}`;
        if (message.id) {
          topic += `_${message.id}`;
        }
      }
    }
    return topic;
  }
  // sendPublicMessage(){
  //   if(this.publicSocket.readyState !== )
  // }
  onceSubscribe(params, callback) {
    this.subscribe(params, callback, true);
  }
  unsubscribe(parmas, webSocket, handlerMap) {
    const topic = parmas.topic || parmas.event;
    const handler = handlerMap.get(topic);
    if (!!handler && Array.isArray(handler == null ? void 0 : handler.callback)) {
      if (handler.callback.length === 1) {
        const unsubscribeMessage = handler.callback[0].onUnsubscribe(topic);
        webSocket.send(JSON.stringify(unsubscribeMessage));
        handlerMap.delete(topic);
      } else {
        const index = handler.callback.findIndex(
          (cb) => cb.onMessage === parmas.onMessage
        );
        if (index === -1)
          return;
        handler.callback.splice(index, 1);
      }
    }
  }
  unsubscribePrivate(parmas) {
    this.unsubscribe(parmas, this.privateSocket, this._eventPrivateHandlers);
  }
  unsubscribePublic(parmas) {
    this.unsubscribe(parmas, this._publicSocket, this._eventHandlers);
  }
  generateMessage(params, onUnsubscribe, onMessage) {
    let subscribeMessage;
    if (typeof params === "string") {
      subscribeMessage = { event: "subscribe", topic: params };
    } else {
      subscribeMessage = params;
    }
    if (typeof onUnsubscribe !== "function") {
      if (typeof params === "string") {
        onUnsubscribe = () => ({ event: "unsubscribe", topic: params });
      } else {
        onUnsubscribe = () => ({ event: "unsubscribe", topic: params.topic });
      }
    }
    return [__spreadProps(__spreadValues({}, subscribeMessage), { onMessage }), onUnsubscribe];
  }
  reconnectPublic() {
    if (this.publicIsReconnecting)
      return;
    this.publicIsReconnecting = true;
    if (typeof window === "undefined")
      return;
    window.setTimeout(() => {
      this.createPublicSC(this.options);
      this.emit("status:change", {
        type: "reconnecting",
        isPrivate: false,
        count: this._publicRetryCount
      });
    }, this.reconnectInterval);
  }
  reconnectPrivate() {
    if (!this.options.accountId)
      return;
    if (this.privateIsReconnecting)
      return;
    this.privateIsReconnecting = true;
    if (typeof window === "undefined")
      return;
    window.setTimeout(() => {
      this.createPrivateSC(this.options);
      this.emit("status:change", {
        type: "reconnecting",
        isPrivate: true,
        count: this._privateRetryCount
      });
    }, this.reconnectInterval);
  }
  // get publicSocket(): WebSocket {
  //   return this._publicSocket;
  // }
  get client() {
    return {
      public: this._publicSocket,
      private: this.privateSocket
    };
  }
  on(eventName, callback) {
    var _a3;
    if (this._eventContainer.has(eventName)) {
      (_a3 = this._eventContainer.get(eventName)) == null ? void 0 : _a3.add(callback);
    }
    this._eventContainer.set(eventName, /* @__PURE__ */ new Set([callback]));
  }
  off(eventName, callback) {
    var _a3;
    if (this._eventContainer.has(eventName)) {
      (_a3 = this._eventContainer.get(eventName)) == null ? void 0 : _a3.delete(callback);
    }
  }
  emit(eventName, message) {
    var _a3;
    if (this._eventContainer.has(eventName)) {
      (_a3 = this._eventContainer.get(eventName)) == null ? void 0 : _a3.forEach((cb) => cb(message));
    }
  }
};
if (typeof window !== "undefined") {
  window.__ORDERLY_VERSION__ = window.__ORDERLY_VERSION__ || {};
  window.__ORDERLY_VERSION__["@orderly.network/types"] = "2.2.0";
}
var AccountStatusEnum = /* @__PURE__ */ ((AccountStatusEnum2) => {
  AccountStatusEnum2[AccountStatusEnum2["EnableTradingWithoutConnected"] = -1] = "EnableTradingWithoutConnected";
  AccountStatusEnum2[AccountStatusEnum2["NotConnected"] = 0] = "NotConnected";
  AccountStatusEnum2[AccountStatusEnum2["Connected"] = 1] = "Connected";
  AccountStatusEnum2[AccountStatusEnum2["NotSignedIn"] = 2] = "NotSignedIn";
  AccountStatusEnum2[AccountStatusEnum2["SignedIn"] = 3] = "SignedIn";
  AccountStatusEnum2[AccountStatusEnum2["DisabledTrading"] = 4] = "DisabledTrading";
  AccountStatusEnum2[AccountStatusEnum2["EnableTrading"] = 5] = "EnableTrading";
  return AccountStatusEnum2;
})(AccountStatusEnum || {});
var ARBITRUM_TESTNET_CHAINID = 421614;
var SOLANA_TESTNET_CHAINID = 901901901;
var STORY_TESTNET_CHAINID = 1516;
var MONAD_TESTNET_CHAINID = 10143;
var ABSTRACT_TESTNET_CHAINID = 11124;
var ABSTRACT_MAINNET_CHAINID = 2741;
var ABSTRACT_CHAIN_ID_MAP = /* @__PURE__ */ new Set([
  ABSTRACT_TESTNET_CHAINID,
  ABSTRACT_MAINNET_CHAINID
]);
var ARBITRUM_MAINNET_CHAINID = 42161;
var MEDIA_TABLET = "(max-width: 768px)";
var DEPOSIT_FEE_RATE = 1.05;
var MaxUint256 = BigInt(
  "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
);
var nativeTokenAddress = "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE";
var isNativeTokenChecker = (address) => address === nativeTokenAddress;
var ArbitrumSepoliaChainInfo = {
  name: "Arbitrum Sepolia",
  public_rpc_url: "https://arbitrum-sepolia.gateway.tenderly.co",
  chain_id: "421614",
  currency_symbol: "ETH",
  currency_decimal: 18,
  explorer_base_url: "https://sepolia.arbiscan.io",
  vault_address: "0x0EaC556c0C2321BA25b9DC01e4e3c95aD5CDCd2f"
};
var SolanaDevnetChainInfo = {
  chain_id: "901901901",
  currency_decimal: 9,
  currency_symbol: "SOL",
  explorer_base_url: "https://explorer.solana.com/?cluster=devnet",
  name: "Solana-Devnet",
  public_rpc_url: "https://api.devnet.solana.com",
  vault_address: "9shwxWDUNhtwkHocsUAmrNAQfBH2DHh4njdAEdHZZkF2"
};
var SolanaDevnetTokenInfo = {
  chain_id: "901901901",
  contract_address: "4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU",
  decimals: 6,
  withdrawal_fee: 1,
  cross_chain_withdrawal_fee: 5,
  display_name: "USDC"
};
var ArbitrumSepoliaTokenInfo = {
  chain_id: "421614",
  contract_address: "0x75faf114eafb1BDbe2F0316DF893fd58CE46AA4d",
  decimals: 6,
  withdrawal_fee: 1,
  cross_chain_withdrawal_fee: 2,
  display_name: "USDC"
};
var TesntTokenFallback = (testnetTokens) => [
  {
    token: "USDC",
    token_hash: "0xd6aca1be9729c13d677335161321649cccae6a591554772516700f986f942eaa",
    decimals: 6,
    minimum_withdraw_amount: 1e-6,
    chain_details: testnetTokens
  }
];
var AnnouncementType = /* @__PURE__ */ ((AnnouncementType2) => {
  AnnouncementType2["Listing"] = "LISTING";
  AnnouncementType2["Maintenance"] = "MAINTENANCE";
  AnnouncementType2["Delisting"] = "DELISTING";
  return AnnouncementType2;
})(AnnouncementType || {});
var OrderType = /* @__PURE__ */ ((OrderType2) => {
  OrderType2["LIMIT"] = "LIMIT";
  OrderType2["MARKET"] = "MARKET";
  OrderType2["IOC"] = "IOC";
  OrderType2["FOK"] = "FOK";
  OrderType2["POST_ONLY"] = "POST_ONLY";
  OrderType2["ASK"] = "ASK";
  OrderType2["BID"] = "BID";
  OrderType2["STOP_LIMIT"] = "STOP_LIMIT";
  OrderType2["STOP_MARKET"] = "STOP_MARKET";
  OrderType2["CLOSE_POSITION"] = "CLOSE_POSITION";
  return OrderType2;
})(OrderType || {});
var BBOOrderType = /* @__PURE__ */ ((BBOOrderType2) => {
  BBOOrderType2["COUNTERPARTY1"] = "counterparty1";
  BBOOrderType2["COUNTERPARTY5"] = "counterparty5";
  BBOOrderType2["QUEUE1"] = "queue1";
  BBOOrderType2["QUEUE5"] = "queue5";
  return BBOOrderType2;
})(BBOOrderType || {});
var OrderLevel = /* @__PURE__ */ ((OrderLevel2) => {
  OrderLevel2[OrderLevel2["ONE"] = 0] = "ONE";
  OrderLevel2[OrderLevel2["TWO"] = 1] = "TWO";
  OrderLevel2[OrderLevel2["THREE"] = 2] = "THREE";
  OrderLevel2[OrderLevel2["FOUR"] = 3] = "FOUR";
  OrderLevel2[OrderLevel2["FIVE"] = 4] = "FIVE";
  return OrderLevel2;
})(OrderLevel || {});
var AlgoOrderRootType = /* @__PURE__ */ ((AlgoOrderRootType2) => {
  AlgoOrderRootType2["TP_SL"] = "TP_SL";
  AlgoOrderRootType2["POSITIONAL_TP_SL"] = "POSITIONAL_TP_SL";
  AlgoOrderRootType2["STOP"] = "STOP";
  AlgoOrderRootType2["BRACKET"] = "BRACKET";
  return AlgoOrderRootType2;
})(AlgoOrderRootType || {});
var TriggerPriceType = /* @__PURE__ */ ((TriggerPriceType2) => {
  TriggerPriceType2["MARK_PRICE"] = "MARK_PRICE";
  return TriggerPriceType2;
})(TriggerPriceType || {});
var AlgoOrderType = /* @__PURE__ */ ((AlgoOrderType2) => {
  AlgoOrderType2["TAKE_PROFIT"] = "TAKE_PROFIT";
  AlgoOrderType2["STOP_LOSS"] = "STOP_LOSS";
  return AlgoOrderType2;
})(AlgoOrderType || {});
var OrderSide = /* @__PURE__ */ ((OrderSide2) => {
  OrderSide2["BUY"] = "BUY";
  OrderSide2["SELL"] = "SELL";
  return OrderSide2;
})(OrderSide || {});
var OrderStatus = /* @__PURE__ */ ((OrderStatus2) => {
  OrderStatus2["OPEN"] = "OPEN";
  OrderStatus2["NEW"] = "NEW";
  OrderStatus2["FILLED"] = "FILLED";
  OrderStatus2["PARTIAL_FILLED"] = "PARTIAL_FILLED";
  OrderStatus2["CANCELLED"] = "CANCELLED";
  OrderStatus2["REPLACED"] = "REPLACED";
  OrderStatus2["COMPLETED"] = "COMPLETED";
  OrderStatus2["INCOMPLETE"] = "INCOMPLETE";
  OrderStatus2["REJECTED"] = "REJECTED";
  return OrderStatus2;
})(OrderStatus || {});
var ChainNamespace = /* @__PURE__ */ ((ChainNamespace2) => {
  ChainNamespace2["evm"] = "EVM";
  ChainNamespace2["solana"] = "SOL";
  return ChainNamespace2;
})(ChainNamespace || {});
var SolanaChains$1 = /* @__PURE__ */ new Set([901901901, 900900900]);
var TrackerEventName = /* @__PURE__ */ ((TrackerEventName2) => {
  TrackerEventName2["trackIdentifyUserId"] = "track_identify_user_id";
  TrackerEventName2["trackIdentify"] = "track_identify";
  TrackerEventName2["trackCustomEvent"] = "track_custom_event";
  TrackerEventName2["withdrawSuccess"] = "withdraw_request_success";
  TrackerEventName2["withdrawFailed"] = "withdraw_request_failure";
  TrackerEventName2["depositSuccess"] = "deposit_request_success";
  TrackerEventName2["depositFailed"] = "deposit_request_failure";
  TrackerEventName2["signinSuccess"] = "sign_message_success";
  TrackerEventName2["placeOrderSuccess"] = "place_order_success";
  TrackerEventName2["walletConnect"] = "connect_wallet_success";
  TrackerEventName2["clickLinkDeviceButton"] = "click_link_device_button";
  TrackerEventName2["signLinkDeviceMessageSuccess"] = "sign_link_device_message_success";
  TrackerEventName2["linkDeviceModalClickConfirm"] = "link_device_modal_click_confirm";
  TrackerEventName2["socialLoginSuccess"] = "social_login_success";
  TrackerEventName2["clickSwitchNetwork"] = "click_switch_network";
  TrackerEventName2["clickSwitchWallet"] = "click_switch_wallet";
  TrackerEventName2["switchNetworkSuccess"] = "switch_network_success";
  TrackerEventName2["clickExportPrivateKey"] = "click_export_private_key";
  TrackerEventName2["switchLanguage"] = "switch_language";
  TrackerEventName2["leaderboardCampaignClickTradeNow"] = "leaderboard_campaign_click_trade_now";
  TrackerEventName2["leaderboardCampaignClickLearnMore"] = "leaderboard_campaign_click_learn_more";
  return TrackerEventName2;
})(TrackerEventName || {});
var LedgerWalletKey = "orderly:ledger-wallet";
var ChainKey = "order:chain";
var ApiError2 = class extends Error {
  constructor(message, code) {
    super(message);
    this.code = code;
    this.name = "ApiError";
  }
};
var SDKError = class extends Error {
  constructor(message) {
    super(`[ORDERLY SDK ERROR]:${message}`);
    this.name = "SDKError";
  }
};
var definedTypes = {
  EIP712Domain: [
    { name: "name", type: "string" },
    { name: "version", type: "string" },
    { name: "chainId", type: "uint256" },
    { name: "verifyingContract", type: "address" }
  ],
  Registration: [
    { name: "brokerId", type: "string" },
    { name: "chainId", type: "uint256" },
    { name: "timestamp", type: "uint64" },
    { name: "registrationNonce", type: "uint256" }
  ],
  Withdraw: [
    { name: "brokerId", type: "string" },
    { name: "chainId", type: "uint256" },
    { name: "receiver", type: "address" },
    { name: "token", type: "string" },
    { name: "amount", type: "uint256" },
    { name: "withdrawNonce", type: "uint64" },
    { name: "timestamp", type: "uint64" }
  ],
  AddOrderlyKey: [
    { name: "brokerId", type: "string" },
    { name: "chainId", type: "uint256" },
    { name: "orderlyKey", type: "string" },
    { name: "scope", type: "string" },
    { name: "timestamp", type: "uint64" },
    { name: "expiration", type: "uint64" }
  ],
  SettlePnl: [
    { name: "brokerId", type: "string" },
    { name: "chainId", type: "uint256" },
    { name: "settleNonce", type: "uint64" },
    { name: "timestamp", type: "uint64" }
  ]
};
var AssetHistoryStatusEnum = /* @__PURE__ */ ((AssetHistoryStatusEnum2) => {
  AssetHistoryStatusEnum2["NEW"] = "NEW";
  AssetHistoryStatusEnum2["CONFIRM"] = "CONFIRM";
  AssetHistoryStatusEnum2["PROCESSING"] = "PROCESSING";
  AssetHistoryStatusEnum2["COMPLETED"] = "COMPLETED";
  AssetHistoryStatusEnum2["FAILED"] = "FAILED";
  AssetHistoryStatusEnum2["PENDING_REBALANCE"] = "PENDING_REBALANCE";
  return AssetHistoryStatusEnum2;
})(AssetHistoryStatusEnum || {});
const version = "6.13.5";
function checkType(value, type, name) {
  const types = type.split("|").map((t) => t.trim());
  for (let i = 0; i < types.length; i++) {
    switch (type) {
      case "any":
        return;
      case "bigint":
      case "boolean":
      case "number":
      case "string":
        if (typeof value === type) {
          return;
        }
    }
  }
  const error = new Error(`invalid value for type ${type}`);
  error.code = "INVALID_ARGUMENT";
  error.argument = `value.${name}`;
  error.value = value;
  throw error;
}
async function resolveProperties(value) {
  const keys = Object.keys(value);
  const results = await Promise.all(keys.map((k2) => Promise.resolve(value[k2])));
  return results.reduce((accum, v3, index) => {
    accum[keys[index]] = v3;
    return accum;
  }, {});
}
function defineProperties(target, values, types) {
  for (let key in values) {
    let value = values[key];
    const type = types ? types[key] : null;
    if (type) {
      checkType(value, type, key);
    }
    Object.defineProperty(target, key, { enumerable: true, value, writable: false });
  }
}
function stringify(value) {
  if (value == null) {
    return "null";
  }
  if (Array.isArray(value)) {
    return "[ " + value.map(stringify).join(", ") + " ]";
  }
  if (value instanceof Uint8Array) {
    const HEX = "0123456789abcdef";
    let result = "0x";
    for (let i = 0; i < value.length; i++) {
      result += HEX[value[i] >> 4];
      result += HEX[value[i] & 15];
    }
    return result;
  }
  if (typeof value === "object" && typeof value.toJSON === "function") {
    return stringify(value.toJSON());
  }
  switch (typeof value) {
    case "boolean":
    case "symbol":
      return value.toString();
    case "bigint":
      return BigInt(value).toString();
    case "number":
      return value.toString();
    case "string":
      return JSON.stringify(value);
    case "object": {
      const keys = Object.keys(value);
      keys.sort();
      return "{ " + keys.map((k2) => `${stringify(k2)}: ${stringify(value[k2])}`).join(", ") + " }";
    }
  }
  return `[ COULD NOT SERIALIZE ]`;
}
function isError(error, code) {
  return error && error.code === code;
}
function isCallException(error) {
  return isError(error, "CALL_EXCEPTION");
}
function makeError(message, code, info) {
  let shortMessage = message;
  {
    const details = [];
    if (info) {
      if ("message" in info || "code" in info || "name" in info) {
        throw new Error(`value will overwrite populated values: ${stringify(info)}`);
      }
      for (const key in info) {
        if (key === "shortMessage") {
          continue;
        }
        const value = info[key];
        details.push(key + "=" + stringify(value));
      }
    }
    details.push(`code=${code}`);
    details.push(`version=${version}`);
    if (details.length) {
      message += " (" + details.join(", ") + ")";
    }
  }
  let error;
  switch (code) {
    case "INVALID_ARGUMENT":
      error = new TypeError(message);
      break;
    case "NUMERIC_FAULT":
    case "BUFFER_OVERRUN":
      error = new RangeError(message);
      break;
    default:
      error = new Error(message);
  }
  defineProperties(error, { code });
  if (info) {
    Object.assign(error, info);
  }
  if (error.shortMessage == null) {
    defineProperties(error, { shortMessage });
  }
  return error;
}
function assert(check, message, code, info) {
  if (!check) {
    throw makeError(message, code, info);
  }
}
function assertArgument(check, message, name, value) {
  assert(check, message, "INVALID_ARGUMENT", { argument: name, value });
}
function assertArgumentCount(count, expectedCount, message) {
  if (message == null) {
    message = "";
  }
  if (message) {
    message = ": " + message;
  }
  assert(count >= expectedCount, "missing argument" + message, "MISSING_ARGUMENT", {
    count,
    expectedCount
  });
  assert(count <= expectedCount, "too many arguments" + message, "UNEXPECTED_ARGUMENT", {
    count,
    expectedCount
  });
}
["NFD", "NFC", "NFKD", "NFKC"].reduce((accum, form) => {
  try {
    if ("test".normalize(form) !== "test") {
      throw new Error("bad");
    }
    ;
    if (form === "NFD") {
      const check = String.fromCharCode(233).normalize("NFD");
      const expected = String.fromCharCode(101, 769);
      if (check !== expected) {
        throw new Error("broken");
      }
    }
    accum.push(form);
  } catch (error) {
  }
  return accum;
}, []);
function assertPrivate(givenGuard, guard, className) {
  if (className == null) {
    className = "";
  }
  if (givenGuard !== guard) {
    let method = className, operation = "new";
    if (className) {
      method += ".";
      operation += " " + className;
    }
    assert(false, `private constructor; use ${method}from* methods`, "UNSUPPORTED_OPERATION", {
      operation
    });
  }
}
function _getBytes(value, name, copy2) {
  if (value instanceof Uint8Array) {
    if (copy2) {
      return new Uint8Array(value);
    }
    return value;
  }
  if (typeof value === "string" && value.match(/^0x(?:[0-9a-f][0-9a-f])*$/i)) {
    const result = new Uint8Array((value.length - 2) / 2);
    let offset = 2;
    for (let i = 0; i < result.length; i++) {
      result[i] = parseInt(value.substring(offset, offset + 2), 16);
      offset += 2;
    }
    return result;
  }
  assertArgument(false, "invalid BytesLike value", name || "value", value);
}
function getBytes(value, name) {
  return _getBytes(value, name, false);
}
function getBytesCopy(value, name) {
  return _getBytes(value, name, true);
}
function isHexString(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (typeof length === "number" && value.length !== 2 + 2 * length) {
    return false;
  }
  if (length === true && value.length % 2 !== 0) {
    return false;
  }
  return true;
}
function isBytesLike(value) {
  return isHexString(value, true) || value instanceof Uint8Array;
}
const HexCharacters = "0123456789abcdef";
function hexlify(data) {
  const bytes = getBytes(data);
  let result = "0x";
  for (let i = 0; i < bytes.length; i++) {
    const v3 = bytes[i];
    result += HexCharacters[(v3 & 240) >> 4] + HexCharacters[v3 & 15];
  }
  return result;
}
function concat(datas) {
  return "0x" + datas.map((d2) => hexlify(d2).substring(2)).join("");
}
function dataLength(data) {
  if (isHexString(data, true)) {
    return (data.length - 2) / 2;
  }
  return getBytes(data).length;
}
function dataSlice(data, start, end) {
  const bytes = getBytes(data);
  if (end != null && end > bytes.length) {
    assert(false, "cannot slice beyond data bounds", "BUFFER_OVERRUN", {
      buffer: bytes,
      length: bytes.length,
      offset: end
    });
  }
  return hexlify(bytes.slice(start == null ? 0 : start, end == null ? bytes.length : end));
}
function zeroPad(data, length, left) {
  const bytes = getBytes(data);
  assert(length >= bytes.length, "padding exceeds data length", "BUFFER_OVERRUN", {
    buffer: new Uint8Array(bytes),
    length,
    offset: length + 1
  });
  const result = new Uint8Array(length);
  result.fill(0);
  if (left) {
    result.set(bytes, length - bytes.length);
  } else {
    result.set(bytes, 0);
  }
  return hexlify(result);
}
function zeroPadValue(data, length) {
  return zeroPad(data, length, true);
}
function zeroPadBytes(data, length) {
  return zeroPad(data, length, false);
}
const BN_0$9 = BigInt(0);
const BN_1$4 = BigInt(1);
const maxValue = 9007199254740991;
function fromTwos(_value2, _width) {
  const value = getUint(_value2, "value");
  const width = BigInt(getNumber(_width, "width"));
  assert(value >> width === BN_0$9, "overflow", "NUMERIC_FAULT", {
    operation: "fromTwos",
    fault: "overflow",
    value: _value2
  });
  if (value >> width - BN_1$4) {
    const mask2 = (BN_1$4 << width) - BN_1$4;
    return -((~value & mask2) + BN_1$4);
  }
  return value;
}
function toTwos(_value2, _width) {
  let value = getBigInt(_value2, "value");
  const width = BigInt(getNumber(_width, "width"));
  const limit = BN_1$4 << width - BN_1$4;
  if (value < BN_0$9) {
    value = -value;
    assert(value <= limit, "too low", "NUMERIC_FAULT", {
      operation: "toTwos",
      fault: "overflow",
      value: _value2
    });
    const mask2 = (BN_1$4 << width) - BN_1$4;
    return (~value & mask2) + BN_1$4;
  } else {
    assert(value < limit, "too high", "NUMERIC_FAULT", {
      operation: "toTwos",
      fault: "overflow",
      value: _value2
    });
  }
  return value;
}
function mask(_value2, _bits) {
  const value = getUint(_value2, "value");
  const bits = BigInt(getNumber(_bits, "bits"));
  return value & (BN_1$4 << bits) - BN_1$4;
}
function getBigInt(value, name) {
  switch (typeof value) {
    case "bigint":
      return value;
    case "number":
      assertArgument(Number.isInteger(value), "underflow", name || "value", value);
      assertArgument(value >= -9007199254740991 && value <= maxValue, "overflow", name || "value", value);
      return BigInt(value);
    case "string":
      try {
        if (value === "") {
          throw new Error("empty string");
        }
        if (value[0] === "-" && value[1] !== "-") {
          return -BigInt(value.substring(1));
        }
        return BigInt(value);
      } catch (e2) {
        assertArgument(false, `invalid BigNumberish string: ${e2.message}`, name || "value", value);
      }
  }
  assertArgument(false, "invalid BigNumberish value", name || "value", value);
}
function getUint(value, name) {
  const result = getBigInt(value, name);
  assert(result >= BN_0$9, "unsigned value cannot be negative", "NUMERIC_FAULT", {
    fault: "overflow",
    operation: "getUint",
    value
  });
  return result;
}
const Nibbles = "0123456789abcdef";
function toBigInt(value) {
  if (value instanceof Uint8Array) {
    let result = "0x0";
    for (const v3 of value) {
      result += Nibbles[v3 >> 4];
      result += Nibbles[v3 & 15];
    }
    return BigInt(result);
  }
  return getBigInt(value);
}
function getNumber(value, name) {
  switch (typeof value) {
    case "bigint":
      assertArgument(value >= -9007199254740991 && value <= maxValue, "overflow", name || "value", value);
      return Number(value);
    case "number":
      assertArgument(Number.isInteger(value), "underflow", name || "value", value);
      assertArgument(value >= -9007199254740991 && value <= maxValue, "overflow", name || "value", value);
      return value;
    case "string":
      try {
        if (value === "") {
          throw new Error("empty string");
        }
        return getNumber(BigInt(value), name);
      } catch (e2) {
        assertArgument(false, `invalid numeric string: ${e2.message}`, name || "value", value);
      }
  }
  assertArgument(false, "invalid numeric value", name || "value", value);
}
function toNumber(value) {
  return getNumber(toBigInt(value));
}
function toBeHex(_value2, _width) {
  const value = getUint(_value2, "value");
  let result = value.toString(16);
  if (_width == null) {
    if (result.length % 2) {
      result = "0" + result;
    }
  } else {
    const width = getNumber(_width, "width");
    assert(width * 2 >= result.length, `value exceeds width (${width} bytes)`, "NUMERIC_FAULT", {
      operation: "toBeHex",
      fault: "overflow",
      value: _value2
    });
    while (result.length < width * 2) {
      result = "0" + result;
    }
  }
  return "0x" + result;
}
function toBeArray(_value2) {
  const value = getUint(_value2, "value");
  if (value === BN_0$9) {
    return new Uint8Array([]);
  }
  let hex = value.toString(16);
  if (hex.length % 2) {
    hex = "0" + hex;
  }
  const result = new Uint8Array(hex.length / 2);
  for (let i = 0; i < result.length; i++) {
    const offset = i * 2;
    result[i] = parseInt(hex.substring(offset, offset + 2), 16);
  }
  return result;
}
function toQuantity(value) {
  let result = hexlify(isBytesLike(value) ? value : toBeArray(value)).substring(2);
  while (result.startsWith("0")) {
    result = result.substring(1);
  }
  if (result === "") {
    result = "0";
  }
  return "0x" + result;
}
const Alphabet = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
BigInt(0);
const BN_58 = BigInt(58);
function encodeBase58(_value2) {
  const bytes = getBytes(_value2);
  let value = toBigInt(bytes);
  let result = "";
  while (value) {
    result = Alphabet[Number(value % BN_58)] + result;
    value /= BN_58;
  }
  for (let i = 0; i < bytes.length; i++) {
    if (bytes[i]) {
      break;
    }
    result = Alphabet[0] + result;
  }
  return result;
}
var dist = {};
(function(exports) {
  Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
  const t = require$$0, r3 = require$$1, o2 = (e2) => e2 && e2.__esModule ? e2 : { default: e2 }, l2 = o2(r3), u2 = globalThis || void 0 || self;
  Object.defineProperty(exports, "Buffer", { enumerable: true, get: () => t.Buffer });
  Object.defineProperty(exports, "process", { enumerable: true, get: () => l2.default });
  exports.global = u2;
})(dist);
function decodeBase64(value) {
  return getBytesCopy(dist.Buffer.from(value, "base64"));
}
function encodeBase64(data) {
  return dist.Buffer.from(getBytes(data)).toString("base64");
}
class EventPayload {
  /**
   *  Create a new **EventPayload** for %%emitter%% with
   *  the %%listener%% and for %%filter%%.
   */
  constructor(emitter, listener, filter) {
    /**
     *  The event filter.
     */
    __publicField(this, "filter");
    /**
     *  The **EventEmitterable**.
     */
    __publicField(this, "emitter");
    __privateAdd(this, _listener);
    __privateSet(this, _listener, listener);
    defineProperties(this, { emitter, filter });
  }
  /**
   *  Unregister the triggered listener for future events.
   */
  async removeListener() {
    if (__privateGet(this, _listener) == null) {
      return;
    }
    await this.emitter.off(this.filter, __privateGet(this, _listener));
  }
}
_listener = new WeakMap();
function errorFunc(reason, offset, bytes, output, badCodepoint) {
  assertArgument(false, `invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes);
}
function ignoreFunc(reason, offset, bytes, output, badCodepoint) {
  if (reason === "BAD_PREFIX" || reason === "UNEXPECTED_CONTINUE") {
    let i = 0;
    for (let o2 = offset + 1; o2 < bytes.length; o2++) {
      if (bytes[o2] >> 6 !== 2) {
        break;
      }
      i++;
    }
    return i;
  }
  if (reason === "OVERRUN") {
    return bytes.length - offset - 1;
  }
  return 0;
}
function replaceFunc(reason, offset, bytes, output, badCodepoint) {
  if (reason === "OVERLONG") {
    assertArgument(typeof badCodepoint === "number", "invalid bad code point for replacement", "badCodepoint", badCodepoint);
    output.push(badCodepoint);
    return 0;
  }
  output.push(65533);
  return ignoreFunc(reason, offset, bytes);
}
const Utf8ErrorFuncs = Object.freeze({
  error: errorFunc,
  ignore: ignoreFunc,
  replace: replaceFunc
});
function getUtf8CodePoints(_bytes, onError) {
  if (onError == null) {
    onError = Utf8ErrorFuncs.error;
  }
  const bytes = getBytes(_bytes, "bytes");
  const result = [];
  let i = 0;
  while (i < bytes.length) {
    const c = bytes[i++];
    if (c >> 7 === 0) {
      result.push(c);
      continue;
    }
    let extraLength = null;
    let overlongMask = null;
    if ((c & 224) === 192) {
      extraLength = 1;
      overlongMask = 127;
    } else if ((c & 240) === 224) {
      extraLength = 2;
      overlongMask = 2047;
    } else if ((c & 248) === 240) {
      extraLength = 3;
      overlongMask = 65535;
    } else {
      if ((c & 192) === 128) {
        i += onError("UNEXPECTED_CONTINUE", i - 1, bytes, result);
      } else {
        i += onError("BAD_PREFIX", i - 1, bytes, result);
      }
      continue;
    }
    if (i - 1 + extraLength >= bytes.length) {
      i += onError("OVERRUN", i - 1, bytes, result);
      continue;
    }
    let res = c & (1 << 8 - extraLength - 1) - 1;
    for (let j2 = 0; j2 < extraLength; j2++) {
      let nextChar = bytes[i];
      if ((nextChar & 192) != 128) {
        i += onError("MISSING_CONTINUE", i, bytes, result);
        res = null;
        break;
      }
      res = res << 6 | nextChar & 63;
      i++;
    }
    if (res === null) {
      continue;
    }
    if (res > 1114111) {
      i += onError("OUT_OF_RANGE", i - 1 - extraLength, bytes, result, res);
      continue;
    }
    if (res >= 55296 && res <= 57343) {
      i += onError("UTF16_SURROGATE", i - 1 - extraLength, bytes, result, res);
      continue;
    }
    if (res <= overlongMask) {
      i += onError("OVERLONG", i - 1 - extraLength, bytes, result, res);
      continue;
    }
    result.push(res);
  }
  return result;
}
function toUtf8Bytes(str, form) {
  assertArgument(typeof str === "string", "invalid string value", "str", str);
  let result = [];
  for (let i = 0; i < str.length; i++) {
    const c = str.charCodeAt(i);
    if (c < 128) {
      result.push(c);
    } else if (c < 2048) {
      result.push(c >> 6 | 192);
      result.push(c & 63 | 128);
    } else if ((c & 64512) == 55296) {
      i++;
      const c2 = str.charCodeAt(i);
      assertArgument(i < str.length && (c2 & 64512) === 56320, "invalid surrogate pair", "str", str);
      const pair = 65536 + ((c & 1023) << 10) + (c2 & 1023);
      result.push(pair >> 18 | 240);
      result.push(pair >> 12 & 63 | 128);
      result.push(pair >> 6 & 63 | 128);
      result.push(pair & 63 | 128);
    } else {
      result.push(c >> 12 | 224);
      result.push(c >> 6 & 63 | 128);
      result.push(c & 63 | 128);
    }
  }
  return new Uint8Array(result);
}
function _toUtf8String(codePoints) {
  return codePoints.map((codePoint) => {
    if (codePoint <= 65535) {
      return String.fromCharCode(codePoint);
    }
    codePoint -= 65536;
    return String.fromCharCode((codePoint >> 10 & 1023) + 55296, (codePoint & 1023) + 56320);
  }).join("");
}
function toUtf8String(bytes, onError) {
  return _toUtf8String(getUtf8CodePoints(bytes, onError));
}
function createGetUrl(options) {
  async function getUrl(req, signal) {
    assert(signal == null || !signal.cancelled, "request cancelled before sending", "CANCELLED");
    const protocol = req.url.split(":")[0].toLowerCase();
    assert(protocol === "http" || protocol === "https", `unsupported protocol ${protocol}`, "UNSUPPORTED_OPERATION", {
      info: { protocol },
      operation: "request"
    });
    assert(protocol === "https" || !req.credentials || req.allowInsecureAuthentication, "insecure authorized connections unsupported", "UNSUPPORTED_OPERATION", {
      operation: "request"
    });
    const method = req.method;
    const headers = Object.assign({}, req.headers);
    const reqOptions = { method, headers };
    if (options) {
      if (options.agent) {
        reqOptions.agent = options.agent;
      }
    }
    let abort = null;
    try {
      abort = new AbortController();
      reqOptions.abort = abort.signal;
    } catch (e2) {
      console.log(e2);
    }
    const request2 = (protocol === "http" ? http : https).request(req.url, reqOptions);
    request2.setTimeout(req.timeout);
    const body = req.body;
    if (body) {
      request2.write(dist.Buffer.from(body));
    }
    request2.end();
    return new Promise((resolve, reject) => {
      if (signal) {
        signal.addListener(() => {
          if (abort) {
            abort.abort();
          }
          reject(makeError("request cancelled", "CANCELLED"));
        });
      }
      request2.on("timeout", () => {
        reject(makeError("request timeout", "TIMEOUT"));
      });
      request2.once("response", (resp) => {
        const statusCode = resp.statusCode || 0;
        const statusMessage = resp.statusMessage || "";
        const headers2 = Object.keys(resp.headers || {}).reduce((accum, name) => {
          let value = resp.headers[name] || "";
          if (Array.isArray(value)) {
            value = value.join(", ");
          }
          accum[name] = value;
          return accum;
        }, {});
        let body2 = null;
        resp.on("data", (chunk) => {
          if (signal) {
            try {
              signal.checkSignal();
            } catch (error) {
              return reject(error);
            }
          }
          if (body2 == null) {
            body2 = chunk;
          } else {
            const newBody = new Uint8Array(body2.length + chunk.length);
            newBody.set(body2, 0);
            newBody.set(chunk, body2.length);
            body2 = newBody;
          }
        });
        resp.on("end", () => {
          if (headers2["content-encoding"] === "gzip" && body2) {
            body2 = getBytes(gunzipSync(body2));
          }
          resolve({ statusCode, statusMessage, headers: headers2, body: body2 });
        });
        resp.on("error", (error) => {
          error.response = { statusCode, statusMessage, headers: headers2, body: body2 };
          reject(error);
        });
      });
      request2.on("error", (error) => {
        reject(error);
      });
    });
  }
  return getUrl;
}
const MAX_ATTEMPTS = 12;
const SLOT_INTERVAL = 250;
let defaultGetUrlFunc = createGetUrl();
const reData = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i");
const reIpfs = new RegExp("^ipfs://(ipfs/)?(.*)$", "i");
let locked$1 = false;
async function dataGatewayFunc(url, signal) {
  try {
    const match = url.match(reData);
    if (!match) {
      throw new Error("invalid data");
    }
    return new FetchResponse(200, "OK", {
      "content-type": match[1] || "text/plain"
    }, match[2] ? decodeBase64(match[3]) : unpercent(match[3]));
  } catch (error) {
    return new FetchResponse(599, "BAD REQUEST (invalid data: URI)", {}, null, new FetchRequest(url));
  }
}
function getIpfsGatewayFunc(baseUrl) {
  async function gatewayIpfs(url, signal) {
    try {
      const match = url.match(reIpfs);
      if (!match) {
        throw new Error("invalid link");
      }
      return new FetchRequest(`${baseUrl}${match[2]}`);
    } catch (error) {
      return new FetchResponse(599, "BAD REQUEST (invalid IPFS URI)", {}, null, new FetchRequest(url));
    }
  }
  return gatewayIpfs;
}
const Gateways = {
  "data": dataGatewayFunc,
  "ipfs": getIpfsGatewayFunc("https://gateway.ipfs.io/ipfs/")
};
const fetchSignals = /* @__PURE__ */ new WeakMap();
class FetchCancelSignal {
  constructor(request2) {
    __privateAdd(this, _listeners);
    __privateAdd(this, _cancelled);
    __privateSet(this, _listeners, []);
    __privateSet(this, _cancelled, false);
    fetchSignals.set(request2, () => {
      if (__privateGet(this, _cancelled)) {
        return;
      }
      __privateSet(this, _cancelled, true);
      for (const listener of __privateGet(this, _listeners)) {
        setTimeout(() => {
          listener();
        }, 0);
      }
      __privateSet(this, _listeners, []);
    });
  }
  addListener(listener) {
    assert(!__privateGet(this, _cancelled), "singal already cancelled", "UNSUPPORTED_OPERATION", {
      operation: "fetchCancelSignal.addCancelListener"
    });
    __privateGet(this, _listeners).push(listener);
  }
  get cancelled() {
    return __privateGet(this, _cancelled);
  }
  checkSignal() {
    assert(!this.cancelled, "cancelled", "CANCELLED", {});
  }
}
_listeners = new WeakMap();
_cancelled = new WeakMap();
function checkSignal(signal) {
  if (signal == null) {
    throw new Error("missing signal; should not happen");
  }
  signal.checkSignal();
  return signal;
}
const _FetchRequest = class _FetchRequest {
  /**
   *  Create a new FetchRequest instance with default values.
   *
   *  Once created, each property may be set before issuing a
   *  ``.send()`` to make the request.
   */
  constructor(url) {
    __privateAdd(this, _FetchRequest_instances);
    __privateAdd(this, _allowInsecure);
    __privateAdd(this, _gzip);
    __privateAdd(this, _headers);
    __privateAdd(this, _method);
    __privateAdd(this, _timeout);
    __privateAdd(this, _url);
    __privateAdd(this, _body);
    __privateAdd(this, _bodyType);
    __privateAdd(this, _creds);
    // Hooks
    __privateAdd(this, _preflight);
    __privateAdd(this, _process);
    __privateAdd(this, _retry);
    __privateAdd(this, _signal);
    __privateAdd(this, _throttle);
    __privateAdd(this, _getUrlFunc);
    __privateSet(this, _url, String(url));
    __privateSet(this, _allowInsecure, false);
    __privateSet(this, _gzip, true);
    __privateSet(this, _headers, {});
    __privateSet(this, _method, "");
    __privateSet(this, _timeout, 3e5);
    __privateSet(this, _throttle, {
      slotInterval: SLOT_INTERVAL,
      maxAttempts: MAX_ATTEMPTS
    });
    __privateSet(this, _getUrlFunc, null);
  }
  /**
   *  The fetch URL to request.
   */
  get url() {
    return __privateGet(this, _url);
  }
  set url(url) {
    __privateSet(this, _url, String(url));
  }
  /**
   *  The fetch body, if any, to send as the request body. //(default: null)//
   *
   *  When setting a body, the intrinsic ``Content-Type`` is automatically
   *  set and will be used if **not overridden** by setting a custom
   *  header.
   *
   *  If %%body%% is null, the body is cleared (along with the
   *  intrinsic ``Content-Type``).
   *
   *  If %%body%% is a string, the intrinsic ``Content-Type`` is set to
   *  ``text/plain``.
   *
   *  If %%body%% is a Uint8Array, the intrinsic ``Content-Type`` is set to
   *  ``application/octet-stream``.
   *
   *  If %%body%% is any other object, the intrinsic ``Content-Type`` is
   *  set to ``application/json``.
   */
  get body() {
    if (__privateGet(this, _body) == null) {
      return null;
    }
    return new Uint8Array(__privateGet(this, _body));
  }
  set body(body) {
    if (body == null) {
      __privateSet(this, _body, void 0);
      __privateSet(this, _bodyType, void 0);
    } else if (typeof body === "string") {
      __privateSet(this, _body, toUtf8Bytes(body));
      __privateSet(this, _bodyType, "text/plain");
    } else if (body instanceof Uint8Array) {
      __privateSet(this, _body, body);
      __privateSet(this, _bodyType, "application/octet-stream");
    } else if (typeof body === "object") {
      __privateSet(this, _body, toUtf8Bytes(JSON.stringify(body)));
      __privateSet(this, _bodyType, "application/json");
    } else {
      throw new Error("invalid body");
    }
  }
  /**
   *  Returns true if the request has a body.
   */
  hasBody() {
    return __privateGet(this, _body) != null;
  }
  /**
   *  The HTTP method to use when requesting the URI. If no method
   *  has been explicitly set, then ``GET`` is used if the body is
   *  null and ``POST`` otherwise.
   */
  get method() {
    if (__privateGet(this, _method)) {
      return __privateGet(this, _method);
    }
    if (this.hasBody()) {
      return "POST";
    }
    return "GET";
  }
  set method(method) {
    if (method == null) {
      method = "";
    }
    __privateSet(this, _method, String(method).toUpperCase());
  }
  /**
   *  The headers that will be used when requesting the URI. All
   *  keys are lower-case.
   *
   *  This object is a copy, so any changes will **NOT** be reflected
   *  in the ``FetchRequest``.
   *
   *  To set a header entry, use the ``setHeader`` method.
   */
  get headers() {
    const headers = Object.assign({}, __privateGet(this, _headers));
    if (__privateGet(this, _creds)) {
      headers["authorization"] = `Basic ${encodeBase64(toUtf8Bytes(__privateGet(this, _creds)))}`;
    }
    if (this.allowGzip) {
      headers["accept-encoding"] = "gzip";
    }
    if (headers["content-type"] == null && __privateGet(this, _bodyType)) {
      headers["content-type"] = __privateGet(this, _bodyType);
    }
    if (this.body) {
      headers["content-length"] = String(this.body.length);
    }
    return headers;
  }
  /**
   *  Get the header for %%key%%, ignoring case.
   */
  getHeader(key) {
    return this.headers[key.toLowerCase()];
  }
  /**
   *  Set the header for %%key%% to %%value%%. All values are coerced
   *  to a string.
   */
  setHeader(key, value) {
    __privateGet(this, _headers)[String(key).toLowerCase()] = String(value);
  }
  /**
   *  Clear all headers, resetting all intrinsic headers.
   */
  clearHeaders() {
    __privateSet(this, _headers, {});
  }
  [Symbol.iterator]() {
    const headers = this.headers;
    const keys = Object.keys(headers);
    let index = 0;
    return {
      next: () => {
        if (index < keys.length) {
          const key = keys[index++];
          return {
            value: [key, headers[key]],
            done: false
          };
        }
        return { value: void 0, done: true };
      }
    };
  }
  /**
   *  The value that will be sent for the ``Authorization`` header.
   *
   *  To set the credentials, use the ``setCredentials`` method.
   */
  get credentials() {
    return __privateGet(this, _creds) || null;
  }
  /**
   *  Sets an ``Authorization`` for %%username%% with %%password%%.
   */
  setCredentials(username, password) {
    assertArgument(!username.match(/:/), "invalid basic authentication username", "username", "[REDACTED]");
    __privateSet(this, _creds, `${username}:${password}`);
  }
  /**
   *  Enable and request gzip-encoded responses. The response will
   *  automatically be decompressed. //(default: true)//
   */
  get allowGzip() {
    return __privateGet(this, _gzip);
  }
  set allowGzip(value) {
    __privateSet(this, _gzip, !!value);
  }
  /**
   *  Allow ``Authentication`` credentials to be sent over insecure
   *  channels. //(default: false)//
   */
  get allowInsecureAuthentication() {
    return !!__privateGet(this, _allowInsecure);
  }
  set allowInsecureAuthentication(value) {
    __privateSet(this, _allowInsecure, !!value);
  }
  /**
   *  The timeout (in milliseconds) to wait for a complete response.
   *  //(default: 5 minutes)//
   */
  get timeout() {
    return __privateGet(this, _timeout);
  }
  set timeout(timeout) {
    assertArgument(timeout >= 0, "timeout must be non-zero", "timeout", timeout);
    __privateSet(this, _timeout, timeout);
  }
  /**
   *  This function is called prior to each request, for example
   *  during a redirection or retry in case of server throttling.
   *
   *  This offers an opportunity to populate headers or update
   *  content before sending a request.
   */
  get preflightFunc() {
    return __privateGet(this, _preflight) || null;
  }
  set preflightFunc(preflight) {
    __privateSet(this, _preflight, preflight);
  }
  /**
   *  This function is called after each response, offering an
   *  opportunity to provide client-level throttling or updating
   *  response data.
   *
   *  Any error thrown in this causes the ``send()`` to throw.
   *
   *  To schedule a retry attempt (assuming the maximum retry limit
   *  has not been reached), use [[response.throwThrottleError]].
   */
  get processFunc() {
    return __privateGet(this, _process) || null;
  }
  set processFunc(process) {
    __privateSet(this, _process, process);
  }
  /**
   *  This function is called on each retry attempt.
   */
  get retryFunc() {
    return __privateGet(this, _retry) || null;
  }
  set retryFunc(retry) {
    __privateSet(this, _retry, retry);
  }
  /**
   *  This function is called to fetch content from HTTP and
   *  HTTPS URLs and is platform specific (e.g. nodejs vs
   *  browsers).
   *
   *  This is by default the currently registered global getUrl
   *  function, which can be changed using [[registerGetUrl]].
   *  If this has been set, setting is to ``null`` will cause
   *  this FetchRequest (and any future clones) to revert back to
   *  using the currently registered global getUrl function.
   *
   *  Setting this is generally not necessary, but may be useful
   *  for developers that wish to intercept requests or to
   *  configurege a proxy or other agent.
   */
  get getUrlFunc() {
    return __privateGet(this, _getUrlFunc) || defaultGetUrlFunc;
  }
  set getUrlFunc(value) {
    __privateSet(this, _getUrlFunc, value);
  }
  toString() {
    return `<FetchRequest method=${JSON.stringify(this.method)} url=${JSON.stringify(this.url)} headers=${JSON.stringify(this.headers)} body=${__privateGet(this, _body) ? hexlify(__privateGet(this, _body)) : "null"}>`;
  }
  /**
   *  Update the throttle parameters used to determine maximum
   *  attempts and exponential-backoff properties.
   */
  setThrottleParams(params) {
    if (params.slotInterval != null) {
      __privateGet(this, _throttle).slotInterval = params.slotInterval;
    }
    if (params.maxAttempts != null) {
      __privateGet(this, _throttle).maxAttempts = params.maxAttempts;
    }
  }
  /**
   *  Resolves to the response by sending the request.
   */
  send() {
    assert(__privateGet(this, _signal) == null, "request already sent", "UNSUPPORTED_OPERATION", { operation: "fetchRequest.send" });
    __privateSet(this, _signal, new FetchCancelSignal(this));
    return __privateMethod(this, _FetchRequest_instances, send_fn).call(this, 0, getTime$1() + this.timeout, 0, this, new FetchResponse(0, "", {}, null, this));
  }
  /**
   *  Cancels the inflight response, causing a ``CANCELLED``
   *  error to be rejected from the [[send]].
   */
  cancel() {
    assert(__privateGet(this, _signal) != null, "request has not been sent", "UNSUPPORTED_OPERATION", { operation: "fetchRequest.cancel" });
    const signal = fetchSignals.get(this);
    if (!signal) {
      throw new Error("missing signal; should not happen");
    }
    signal();
  }
  /**
   *  Returns a new [[FetchRequest]] that represents the redirection
   *  to %%location%%.
   */
  redirect(location) {
    const current = this.url.split(":")[0].toLowerCase();
    const target = location.split(":")[0].toLowerCase();
    assert(this.method === "GET" && (current !== "https" || target !== "http") && location.match(/^https?:/), `unsupported redirect`, "UNSUPPORTED_OPERATION", {
      operation: `redirect(${this.method} ${JSON.stringify(this.url)} => ${JSON.stringify(location)})`
    });
    const req = new _FetchRequest(location);
    req.method = "GET";
    req.allowGzip = this.allowGzip;
    req.timeout = this.timeout;
    __privateSet(req, _headers, Object.assign({}, __privateGet(this, _headers)));
    if (__privateGet(this, _body)) {
      __privateSet(req, _body, new Uint8Array(__privateGet(this, _body)));
    }
    __privateSet(req, _bodyType, __privateGet(this, _bodyType));
    return req;
  }
  /**
   *  Create a new copy of this request.
   */
  clone() {
    const clone = new _FetchRequest(this.url);
    __privateSet(clone, _method, __privateGet(this, _method));
    if (__privateGet(this, _body)) {
      __privateSet(clone, _body, __privateGet(this, _body));
    }
    __privateSet(clone, _bodyType, __privateGet(this, _bodyType));
    __privateSet(clone, _headers, Object.assign({}, __privateGet(this, _headers)));
    __privateSet(clone, _creds, __privateGet(this, _creds));
    if (this.allowGzip) {
      clone.allowGzip = true;
    }
    clone.timeout = this.timeout;
    if (this.allowInsecureAuthentication) {
      clone.allowInsecureAuthentication = true;
    }
    __privateSet(clone, _preflight, __privateGet(this, _preflight));
    __privateSet(clone, _process, __privateGet(this, _process));
    __privateSet(clone, _retry, __privateGet(this, _retry));
    __privateSet(clone, _throttle, Object.assign({}, __privateGet(this, _throttle)));
    __privateSet(clone, _getUrlFunc, __privateGet(this, _getUrlFunc));
    return clone;
  }
  /**
   *  Locks all static configuration for gateways and FetchGetUrlFunc
   *  registration.
   */
  static lockConfig() {
    locked$1 = true;
  }
  /**
   *  Get the current Gateway function for %%scheme%%.
   */
  static getGateway(scheme) {
    return Gateways[scheme.toLowerCase()] || null;
  }
  /**
   *  Use the %%func%% when fetching URIs using %%scheme%%.
   *
   *  This method affects all requests globally.
   *
   *  If [[lockConfig]] has been called, no change is made and this
   *  throws.
   */
  static registerGateway(scheme, func) {
    scheme = scheme.toLowerCase();
    if (scheme === "http" || scheme === "https") {
      throw new Error(`cannot intercept ${scheme}; use registerGetUrl`);
    }
    if (locked$1) {
      throw new Error("gateways locked");
    }
    Gateways[scheme] = func;
  }
  /**
   *  Use %%getUrl%% when fetching URIs over HTTP and HTTPS requests.
   *
   *  This method affects all requests globally.
   *
   *  If [[lockConfig]] has been called, no change is made and this
   *  throws.
   */
  static registerGetUrl(getUrl) {
    if (locked$1) {
      throw new Error("gateways locked");
    }
    defaultGetUrlFunc = getUrl;
  }
  /**
   *  Creates a getUrl function that fetches content from HTTP and
   *  HTTPS URLs.
   *
   *  The available %%options%% are dependent on the platform
   *  implementation of the default getUrl function.
   *
   *  This is not generally something that is needed, but is useful
   *  when trying to customize simple behaviour when fetching HTTP
   *  content.
   */
  static createGetUrlFunc(options) {
    return createGetUrl(options);
  }
  /**
   *  Creates a function that can "fetch" data URIs.
   *
   *  Note that this is automatically done internally to support
   *  data URIs, so it is not necessary to register it.
   *
   *  This is not generally something that is needed, but may
   *  be useful in a wrapper to perfom custom data URI functionality.
   */
  static createDataGateway() {
    return dataGatewayFunc;
  }
  /**
   *  Creates a function that will fetch IPFS (unvalidated) from
   *  a custom gateway baseUrl.
   *
   *  The default IPFS gateway used internally is
   *  ``"https:/\/gateway.ipfs.io/ipfs/"``.
   */
  static createIpfsGatewayFunc(baseUrl) {
    return getIpfsGatewayFunc(baseUrl);
  }
};
_allowInsecure = new WeakMap();
_gzip = new WeakMap();
_headers = new WeakMap();
_method = new WeakMap();
_timeout = new WeakMap();
_url = new WeakMap();
_body = new WeakMap();
_bodyType = new WeakMap();
_creds = new WeakMap();
_preflight = new WeakMap();
_process = new WeakMap();
_retry = new WeakMap();
_signal = new WeakMap();
_throttle = new WeakMap();
_getUrlFunc = new WeakMap();
_FetchRequest_instances = new WeakSet();
send_fn = async function(attempt, expires, delay, _request3, _response) {
  var _a3, _b2, _c2;
  if (attempt >= __privateGet(this, _throttle).maxAttempts) {
    return _response.makeServerError("exceeded maximum retry limit");
  }
  assert(getTime$1() <= expires, "timeout", "TIMEOUT", {
    operation: "request.send",
    reason: "timeout",
    request: _request3
  });
  if (delay > 0) {
    await wait(delay);
  }
  let req = this.clone();
  const scheme = (req.url.split(":")[0] || "").toLowerCase();
  if (scheme in Gateways) {
    const result = await Gateways[scheme](req.url, checkSignal(__privateGet(_request3, _signal)));
    if (result instanceof FetchResponse) {
      let response2 = result;
      if (this.processFunc) {
        checkSignal(__privateGet(_request3, _signal));
        try {
          response2 = await this.processFunc(req, response2);
        } catch (error) {
          if (error.throttle == null || typeof error.stall !== "number") {
            response2.makeServerError("error in post-processing function", error).assertOk();
          }
        }
      }
      return response2;
    }
    req = result;
  }
  if (this.preflightFunc) {
    req = await this.preflightFunc(req);
  }
  const resp = await this.getUrlFunc(req, checkSignal(__privateGet(_request3, _signal)));
  let response = new FetchResponse(resp.statusCode, resp.statusMessage, resp.headers, resp.body, _request3);
  if (response.statusCode === 301 || response.statusCode === 302) {
    try {
      const location = response.headers.location || "";
      return __privateMethod(_a3 = req.redirect(location), _FetchRequest_instances, send_fn).call(_a3, attempt + 1, expires, 0, _request3, response);
    } catch (error) {
    }
    return response;
  } else if (response.statusCode === 429) {
    if (this.retryFunc == null || await this.retryFunc(req, response, attempt)) {
      const retryAfter = response.headers["retry-after"];
      let delay2 = __privateGet(this, _throttle).slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));
      if (typeof retryAfter === "string" && retryAfter.match(/^[1-9][0-9]*$/)) {
        delay2 = parseInt(retryAfter);
      }
      return __privateMethod(_b2 = req.clone(), _FetchRequest_instances, send_fn).call(_b2, attempt + 1, expires, delay2, _request3, response);
    }
  }
  if (this.processFunc) {
    checkSignal(__privateGet(_request3, _signal));
    try {
      response = await this.processFunc(req, response);
    } catch (error) {
      if (error.throttle == null || typeof error.stall !== "number") {
        response.makeServerError("error in post-processing function", error).assertOk();
      }
      let delay2 = __privateGet(this, _throttle).slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));
      if (error.stall >= 0) {
        delay2 = error.stall;
      }
      return __privateMethod(_c2 = req.clone(), _FetchRequest_instances, send_fn).call(_c2, attempt + 1, expires, delay2, _request3, response);
    }
  }
  return response;
};
let FetchRequest = _FetchRequest;
const _FetchResponse = class _FetchResponse {
  constructor(statusCode, statusMessage, headers, body, request2) {
    __privateAdd(this, _statusCode);
    __privateAdd(this, _statusMessage);
    __privateAdd(this, _headers2);
    __privateAdd(this, _body2);
    __privateAdd(this, _request);
    __privateAdd(this, _error);
    __privateSet(this, _statusCode, statusCode);
    __privateSet(this, _statusMessage, statusMessage);
    __privateSet(this, _headers2, Object.keys(headers).reduce((accum, k2) => {
      accum[k2.toLowerCase()] = String(headers[k2]);
      return accum;
    }, {}));
    __privateSet(this, _body2, body == null ? null : new Uint8Array(body));
    __privateSet(this, _request, request2 || null);
    __privateSet(this, _error, { message: "" });
  }
  toString() {
    return `<FetchResponse status=${this.statusCode} body=${__privateGet(this, _body2) ? hexlify(__privateGet(this, _body2)) : "null"}>`;
  }
  /**
   *  The response status code.
   */
  get statusCode() {
    return __privateGet(this, _statusCode);
  }
  /**
   *  The response status message.
   */
  get statusMessage() {
    return __privateGet(this, _statusMessage);
  }
  /**
   *  The response headers. All keys are lower-case.
   */
  get headers() {
    return Object.assign({}, __privateGet(this, _headers2));
  }
  /**
   *  The response body, or ``null`` if there was no body.
   */
  get body() {
    return __privateGet(this, _body2) == null ? null : new Uint8Array(__privateGet(this, _body2));
  }
  /**
   *  The response body as a UTF-8 encoded string, or the empty
   *  string (i.e. ``""``) if there was no body.
   *
   *  An error is thrown if the body is invalid UTF-8 data.
   */
  get bodyText() {
    try {
      return __privateGet(this, _body2) == null ? "" : toUtf8String(__privateGet(this, _body2));
    } catch (error) {
      assert(false, "response body is not valid UTF-8 data", "UNSUPPORTED_OPERATION", {
        operation: "bodyText",
        info: { response: this }
      });
    }
  }
  /**
   *  The response body, decoded as JSON.
   *
   *  An error is thrown if the body is invalid JSON-encoded data
   *  or if there was no body.
   */
  get bodyJson() {
    try {
      return JSON.parse(this.bodyText);
    } catch (error) {
      assert(false, "response body is not valid JSON", "UNSUPPORTED_OPERATION", {
        operation: "bodyJson",
        info: { response: this }
      });
    }
  }
  [Symbol.iterator]() {
    const headers = this.headers;
    const keys = Object.keys(headers);
    let index = 0;
    return {
      next: () => {
        if (index < keys.length) {
          const key = keys[index++];
          return {
            value: [key, headers[key]],
            done: false
          };
        }
        return { value: void 0, done: true };
      }
    };
  }
  /**
   *  Return a Response with matching headers and body, but with
   *  an error status code (i.e. 599) and %%message%% with an
   *  optional %%error%%.
   */
  makeServerError(message, error) {
    let statusMessage;
    if (!message) {
      message = `${this.statusCode} ${this.statusMessage}`;
      statusMessage = `CLIENT ESCALATED SERVER ERROR (${message})`;
    } else {
      statusMessage = `CLIENT ESCALATED SERVER ERROR (${this.statusCode} ${this.statusMessage}; ${message})`;
    }
    const response = new _FetchResponse(599, statusMessage, this.headers, this.body, __privateGet(this, _request) || void 0);
    __privateSet(response, _error, { message, error });
    return response;
  }
  /**
   *  If called within a [request.processFunc](FetchRequest-processFunc)
   *  call, causes the request to retry as if throttled for %%stall%%
   *  milliseconds.
   */
  throwThrottleError(message, stall2) {
    if (stall2 == null) {
      stall2 = -1;
    } else {
      assertArgument(Number.isInteger(stall2) && stall2 >= 0, "invalid stall timeout", "stall", stall2);
    }
    const error = new Error(message || "throttling requests");
    defineProperties(error, { stall: stall2, throttle: true });
    throw error;
  }
  /**
   *  Get the header value for %%key%%, ignoring case.
   */
  getHeader(key) {
    return this.headers[key.toLowerCase()];
  }
  /**
   *  Returns true if the response has a body.
   */
  hasBody() {
    return __privateGet(this, _body2) != null;
  }
  /**
   *  The request made for this response.
   */
  get request() {
    return __privateGet(this, _request);
  }
  /**
   *  Returns true if this response was a success statusCode.
   */
  ok() {
    return __privateGet(this, _error).message === "" && this.statusCode >= 200 && this.statusCode < 300;
  }
  /**
   *  Throws a ``SERVER_ERROR`` if this response is not ok.
   */
  assertOk() {
    if (this.ok()) {
      return;
    }
    let { message, error } = __privateGet(this, _error);
    if (message === "") {
      message = `server response ${this.statusCode} ${this.statusMessage}`;
    }
    let requestUrl = null;
    if (this.request) {
      requestUrl = this.request.url;
    }
    let responseBody = null;
    try {
      if (__privateGet(this, _body2)) {
        responseBody = toUtf8String(__privateGet(this, _body2));
      }
    } catch (e2) {
    }
    assert(false, message, "SERVER_ERROR", {
      request: this.request || "unknown request",
      response: this,
      error,
      info: {
        requestUrl,
        responseBody,
        responseStatus: `${this.statusCode} ${this.statusMessage}`
      }
    });
  }
};
_statusCode = new WeakMap();
_statusMessage = new WeakMap();
_headers2 = new WeakMap();
_body2 = new WeakMap();
_request = new WeakMap();
_error = new WeakMap();
let FetchResponse = _FetchResponse;
function getTime$1() {
  return (/* @__PURE__ */ new Date()).getTime();
}
function unpercent(value) {
  return toUtf8Bytes(value.replace(/%([0-9a-f][0-9a-f])/gi, (all, code) => {
    return String.fromCharCode(parseInt(code, 16));
  }));
}
function wait(delay) {
  return new Promise((resolve) => setTimeout(resolve, delay));
}
const BN_N1 = BigInt(-1);
const BN_0$8 = BigInt(0);
const BN_1$3 = BigInt(1);
const BN_5 = BigInt(5);
const _guard$3 = {};
let Zeros$1 = "0000";
while (Zeros$1.length < 80) {
  Zeros$1 += Zeros$1;
}
function getTens(decimals) {
  let result = Zeros$1;
  while (result.length < decimals) {
    result += result;
  }
  return BigInt("1" + result.substring(0, decimals));
}
function checkValue(val, format2, safeOp) {
  const width = BigInt(format2.width);
  if (format2.signed) {
    const limit = BN_1$3 << width - BN_1$3;
    assert(safeOp == null || val >= -limit && val < limit, "overflow", "NUMERIC_FAULT", {
      operation: safeOp,
      fault: "overflow",
      value: val
    });
    if (val > BN_0$8) {
      val = fromTwos(mask(val, width), width);
    } else {
      val = -fromTwos(mask(-val, width), width);
    }
  } else {
    const limit = BN_1$3 << width;
    assert(safeOp == null || val >= 0 && val < limit, "overflow", "NUMERIC_FAULT", {
      operation: safeOp,
      fault: "overflow",
      value: val
    });
    val = (val % limit + limit) % limit & limit - BN_1$3;
  }
  return val;
}
function getFormat(value) {
  if (typeof value === "number") {
    value = `fixed128x${value}`;
  }
  let signed = true;
  let width = 128;
  let decimals = 18;
  if (typeof value === "string") {
    if (value === "fixed") ;
    else if (value === "ufixed") {
      signed = false;
    } else {
      const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
      assertArgument(match, "invalid fixed format", "format", value);
      signed = match[1] !== "u";
      width = parseInt(match[2]);
      decimals = parseInt(match[3]);
    }
  } else if (value) {
    const v3 = value;
    const check = (key, type, defaultValue) => {
      if (v3[key] == null) {
        return defaultValue;
      }
      assertArgument(typeof v3[key] === type, "invalid fixed format (" + key + " not " + type + ")", "format." + key, v3[key]);
      return v3[key];
    };
    signed = check("signed", "boolean", signed);
    width = check("width", "number", width);
    decimals = check("decimals", "number", decimals);
  }
  assertArgument(width % 8 === 0, "invalid FixedNumber width (not byte aligned)", "format.width", width);
  assertArgument(decimals <= 80, "invalid FixedNumber decimals (too large)", "format.decimals", decimals);
  const name = (signed ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
  return { signed, width, decimals, name };
}
function toString(val, decimals) {
  let negative = "";
  if (val < BN_0$8) {
    negative = "-";
    val *= BN_N1;
  }
  let str = val.toString();
  if (decimals === 0) {
    return negative + str;
  }
  while (str.length <= decimals) {
    str = Zeros$1 + str;
  }
  const index = str.length - decimals;
  str = str.substring(0, index) + "." + str.substring(index);
  while (str[0] === "0" && str[1] !== ".") {
    str = str.substring(1);
  }
  while (str[str.length - 1] === "0" && str[str.length - 2] !== ".") {
    str = str.substring(0, str.length - 1);
  }
  return negative + str;
}
const _FixedNumber = class _FixedNumber {
  // Use this when changing this file to get some typing info,
  // but then switch to any to mask the internal type
  //constructor(guard: any, value: bigint, format: _FixedFormat) {
  /**
   *  @private
   */
  constructor(guard, value, format2) {
    __privateAdd(this, _FixedNumber_instances);
    /**
     *  The specific fixed-point arithmetic field for this value.
     */
    __publicField(this, "format");
    __privateAdd(this, _format);
    // The actual value (accounting for decimals)
    __privateAdd(this, _val);
    // A base-10 value to multiple values by to maintain the magnitude
    __privateAdd(this, _tens);
    /**
     *  This is a property so console.log shows a human-meaningful value.
     *
     *  @private
     */
    __publicField(this, "_value");
    assertPrivate(guard, _guard$3, "FixedNumber");
    __privateSet(this, _val, value);
    __privateSet(this, _format, format2);
    const _value2 = toString(value, format2.decimals);
    defineProperties(this, { format: format2.name, _value: _value2 });
    __privateSet(this, _tens, getTens(format2.decimals));
  }
  /**
   *  If true, negative values are permitted, otherwise only
   *  positive values and zero are allowed.
   */
  get signed() {
    return __privateGet(this, _format).signed;
  }
  /**
   *  The number of bits available to store the value.
   */
  get width() {
    return __privateGet(this, _format).width;
  }
  /**
   *  The number of decimal places in the fixed-point arithment field.
   */
  get decimals() {
    return __privateGet(this, _format).decimals;
  }
  /**
   *  The value as an integer, based on the smallest unit the
   *  [[decimals]] allow.
   */
  get value() {
    return __privateGet(this, _val);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% added
   *  to %%other%%, ignoring overflow.
   */
  addUnsafe(other) {
    return __privateMethod(this, _FixedNumber_instances, add_fn).call(this, other);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% added
   *  to %%other%%. A [[NumericFaultError]] is thrown if overflow
   *  occurs.
   */
  add(other) {
    return __privateMethod(this, _FixedNumber_instances, add_fn).call(this, other, "add");
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted
   *  from %%this%%, ignoring overflow.
   */
  subUnsafe(other) {
    return __privateMethod(this, _FixedNumber_instances, sub_fn).call(this, other);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted
   *  from %%this%%. A [[NumericFaultError]] is thrown if overflow
   *  occurs.
   */
  sub(other) {
    return __privateMethod(this, _FixedNumber_instances, sub_fn).call(this, other, "sub");
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied
   *  by %%other%%, ignoring overflow and underflow (precision loss).
   */
  mulUnsafe(other) {
    return __privateMethod(this, _FixedNumber_instances, mul_fn).call(this, other);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied
   *  by %%other%%. A [[NumericFaultError]] is thrown if overflow
   *  occurs.
   */
  mul(other) {
    return __privateMethod(this, _FixedNumber_instances, mul_fn).call(this, other, "mul");
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied
   *  by %%other%%. A [[NumericFaultError]] is thrown if overflow
   *  occurs or if underflow (precision loss) occurs.
   */
  mulSignal(other) {
    __privateMethod(this, _FixedNumber_instances, checkFormat_fn).call(this, other);
    const value = __privateGet(this, _val) * __privateGet(other, _val);
    assert(value % __privateGet(this, _tens) === BN_0$8, "precision lost during signalling mul", "NUMERIC_FAULT", {
      operation: "mulSignal",
      fault: "underflow",
      value: this
    });
    return __privateMethod(this, _FixedNumber_instances, checkValue_fn).call(this, value / __privateGet(this, _tens), "mulSignal");
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% divided
   *  by %%other%%, ignoring underflow (precision loss). A
   *  [[NumericFaultError]] is thrown if overflow occurs.
   */
  divUnsafe(other) {
    return __privateMethod(this, _FixedNumber_instances, div_fn).call(this, other);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% divided
   *  by %%other%%, ignoring underflow (precision loss). A
   *  [[NumericFaultError]] is thrown if overflow occurs.
   */
  div(other) {
    return __privateMethod(this, _FixedNumber_instances, div_fn).call(this, other, "div");
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% divided
   *  by %%other%%. A [[NumericFaultError]] is thrown if underflow
   *  (precision loss) occurs.
   */
  divSignal(other) {
    assert(__privateGet(other, _val) !== BN_0$8, "division by zero", "NUMERIC_FAULT", {
      operation: "div",
      fault: "divide-by-zero",
      value: this
    });
    __privateMethod(this, _FixedNumber_instances, checkFormat_fn).call(this, other);
    const value = __privateGet(this, _val) * __privateGet(this, _tens);
    assert(value % __privateGet(other, _val) === BN_0$8, "precision lost during signalling div", "NUMERIC_FAULT", {
      operation: "divSignal",
      fault: "underflow",
      value: this
    });
    return __privateMethod(this, _FixedNumber_instances, checkValue_fn).call(this, value / __privateGet(other, _val), "divSignal");
  }
  /**
   *  Returns a comparison result between %%this%% and %%other%%.
   *
   *  This is suitable for use in sorting, where ``-1`` implies %%this%%
   *  is smaller, ``1`` implies %%this%% is larger and ``0`` implies
   *  both are equal.
   */
  cmp(other) {
    let a2 = this.value, b2 = other.value;
    const delta = this.decimals - other.decimals;
    if (delta > 0) {
      b2 *= getTens(delta);
    } else if (delta < 0) {
      a2 *= getTens(-delta);
    }
    if (a2 < b2) {
      return -1;
    }
    if (a2 > b2) {
      return 1;
    }
    return 0;
  }
  /**
   *  Returns true if %%other%% is equal to %%this%%.
   */
  eq(other) {
    return this.cmp(other) === 0;
  }
  /**
   *  Returns true if %%other%% is less than to %%this%%.
   */
  lt(other) {
    return this.cmp(other) < 0;
  }
  /**
   *  Returns true if %%other%% is less than or equal to %%this%%.
   */
  lte(other) {
    return this.cmp(other) <= 0;
  }
  /**
   *  Returns true if %%other%% is greater than to %%this%%.
   */
  gt(other) {
    return this.cmp(other) > 0;
  }
  /**
   *  Returns true if %%other%% is greater than or equal to %%this%%.
   */
  gte(other) {
    return this.cmp(other) >= 0;
  }
  /**
   *  Returns a new [[FixedNumber]] which is the largest **integer**
   *  that is less than or equal to %%this%%.
   *
   *  The decimal component of the result will always be ``0``.
   */
  floor() {
    let val = __privateGet(this, _val);
    if (__privateGet(this, _val) < BN_0$8) {
      val -= __privateGet(this, _tens) - BN_1$3;
    }
    val = __privateGet(this, _val) / __privateGet(this, _tens) * __privateGet(this, _tens);
    return __privateMethod(this, _FixedNumber_instances, checkValue_fn).call(this, val, "floor");
  }
  /**
   *  Returns a new [[FixedNumber]] which is the smallest **integer**
   *  that is greater than or equal to %%this%%.
   *
   *  The decimal component of the result will always be ``0``.
   */
  ceiling() {
    let val = __privateGet(this, _val);
    if (__privateGet(this, _val) > BN_0$8) {
      val += __privateGet(this, _tens) - BN_1$3;
    }
    val = __privateGet(this, _val) / __privateGet(this, _tens) * __privateGet(this, _tens);
    return __privateMethod(this, _FixedNumber_instances, checkValue_fn).call(this, val, "ceiling");
  }
  /**
   *  Returns a new [[FixedNumber]] with the decimal component
   *  rounded up on ties at %%decimals%% places.
   */
  round(decimals) {
    if (decimals == null) {
      decimals = 0;
    }
    if (decimals >= this.decimals) {
      return this;
    }
    const delta = this.decimals - decimals;
    const bump = BN_5 * getTens(delta - 1);
    let value = this.value + bump;
    const tens = getTens(delta);
    value = value / tens * tens;
    checkValue(value, __privateGet(this, _format), "round");
    return new _FixedNumber(_guard$3, value, __privateGet(this, _format));
  }
  /**
   *  Returns true if %%this%% is equal to ``0``.
   */
  isZero() {
    return __privateGet(this, _val) === BN_0$8;
  }
  /**
   *  Returns true if %%this%% is less than ``0``.
   */
  isNegative() {
    return __privateGet(this, _val) < BN_0$8;
  }
  /**
   *  Returns the string representation of %%this%%.
   */
  toString() {
    return this._value;
  }
  /**
   *  Returns a float approximation.
   *
   *  Due to IEEE 754 precission (or lack thereof), this function
   *  can only return an approximation and most values will contain
   *  rounding errors.
   */
  toUnsafeFloat() {
    return parseFloat(this.toString());
  }
  /**
   *  Return a new [[FixedNumber]] with the same value but has had
   *  its field set to %%format%%.
   *
   *  This will throw if the value cannot fit into %%format%%.
   */
  toFormat(format2) {
    return _FixedNumber.fromString(this.toString(), format2);
  }
  /**
   *  Creates a new [[FixedNumber]] for %%value%% divided by
   *  %%decimal%% places with %%format%%.
   *
   *  This will throw a [[NumericFaultError]] if %%value%% (once adjusted
   *  for %%decimals%%) cannot fit in %%format%%, either due to overflow
   *  or underflow (precision loss).
   */
  static fromValue(_value2, _decimals, _format2) {
    const decimals = _decimals == null ? 0 : getNumber(_decimals);
    const format2 = getFormat(_format2);
    let value = getBigInt(_value2, "value");
    const delta = decimals - format2.decimals;
    if (delta > 0) {
      const tens = getTens(delta);
      assert(value % tens === BN_0$8, "value loses precision for format", "NUMERIC_FAULT", {
        operation: "fromValue",
        fault: "underflow",
        value: _value2
      });
      value /= tens;
    } else if (delta < 0) {
      value *= getTens(-delta);
    }
    checkValue(value, format2, "fromValue");
    return new _FixedNumber(_guard$3, value, format2);
  }
  /**
   *  Creates a new [[FixedNumber]] for %%value%% with %%format%%.
   *
   *  This will throw a [[NumericFaultError]] if %%value%% cannot fit
   *  in %%format%%, either due to overflow or underflow (precision loss).
   */
  static fromString(_value2, _format2) {
    const match = _value2.match(/^(-?)([0-9]*)\.?([0-9]*)$/);
    assertArgument(match && match[2].length + match[3].length > 0, "invalid FixedNumber string value", "value", _value2);
    const format2 = getFormat(_format2);
    let whole = match[2] || "0", decimal = match[3] || "";
    while (decimal.length < format2.decimals) {
      decimal += Zeros$1;
    }
    assert(decimal.substring(format2.decimals).match(/^0*$/), "too many decimals for format", "NUMERIC_FAULT", {
      operation: "fromString",
      fault: "underflow",
      value: _value2
    });
    decimal = decimal.substring(0, format2.decimals);
    const value = BigInt(match[1] + whole + decimal);
    checkValue(value, format2, "fromString");
    return new _FixedNumber(_guard$3, value, format2);
  }
  /**
   *  Creates a new [[FixedNumber]] with the big-endian representation
   *  %%value%% with %%format%%.
   *
   *  This will throw a [[NumericFaultError]] if %%value%% cannot fit
   *  in %%format%% due to overflow.
   */
  static fromBytes(_value2, _format2) {
    let value = toBigInt(getBytes(_value2, "value"));
    const format2 = getFormat(_format2);
    if (format2.signed) {
      value = fromTwos(value, format2.width);
    }
    checkValue(value, format2, "fromBytes");
    return new _FixedNumber(_guard$3, value, format2);
  }
};
_format = new WeakMap();
_val = new WeakMap();
_tens = new WeakMap();
_FixedNumber_instances = new WeakSet();
checkFormat_fn = function(other) {
  assertArgument(this.format === other.format, "incompatible format; use fixedNumber.toFormat", "other", other);
};
checkValue_fn = function(val, safeOp) {
  val = checkValue(val, __privateGet(this, _format), safeOp);
  return new _FixedNumber(_guard$3, val, __privateGet(this, _format));
};
add_fn = function(o2, safeOp) {
  __privateMethod(this, _FixedNumber_instances, checkFormat_fn).call(this, o2);
  return __privateMethod(this, _FixedNumber_instances, checkValue_fn).call(this, __privateGet(this, _val) + __privateGet(o2, _val), safeOp);
};
sub_fn = function(o2, safeOp) {
  __privateMethod(this, _FixedNumber_instances, checkFormat_fn).call(this, o2);
  return __privateMethod(this, _FixedNumber_instances, checkValue_fn).call(this, __privateGet(this, _val) - __privateGet(o2, _val), safeOp);
};
mul_fn = function(o2, safeOp) {
  __privateMethod(this, _FixedNumber_instances, checkFormat_fn).call(this, o2);
  return __privateMethod(this, _FixedNumber_instances, checkValue_fn).call(this, __privateGet(this, _val) * __privateGet(o2, _val) / __privateGet(this, _tens), safeOp);
};
div_fn = function(o2, safeOp) {
  assert(__privateGet(o2, _val) !== BN_0$8, "division by zero", "NUMERIC_FAULT", {
    operation: "div",
    fault: "divide-by-zero",
    value: this
  });
  __privateMethod(this, _FixedNumber_instances, checkFormat_fn).call(this, o2);
  return __privateMethod(this, _FixedNumber_instances, checkValue_fn).call(this, __privateGet(this, _val) * __privateGet(this, _tens) / __privateGet(o2, _val), safeOp);
};
let FixedNumber = _FixedNumber;
function hexlifyByte(value) {
  let result = value.toString(16);
  while (result.length < 2) {
    result = "0" + result;
  }
  return "0x" + result;
}
function unarrayifyInteger(data, offset, length) {
  let result = 0;
  for (let i = 0; i < length; i++) {
    result = result * 256 + data[offset + i];
  }
  return result;
}
function _decodeChildren(data, offset, childOffset, length) {
  const result = [];
  while (childOffset < offset + 1 + length) {
    const decoded = _decode(data, childOffset);
    result.push(decoded.result);
    childOffset += decoded.consumed;
    assert(childOffset <= offset + 1 + length, "child data too short", "BUFFER_OVERRUN", {
      buffer: data,
      length,
      offset
    });
  }
  return { consumed: 1 + length, result };
}
function _decode(data, offset) {
  assert(data.length !== 0, "data too short", "BUFFER_OVERRUN", {
    buffer: data,
    length: 0,
    offset: 1
  });
  const checkOffset = (offset2) => {
    assert(offset2 <= data.length, "data short segment too short", "BUFFER_OVERRUN", {
      buffer: data,
      length: data.length,
      offset: offset2
    });
  };
  if (data[offset] >= 248) {
    const lengthLength = data[offset] - 247;
    checkOffset(offset + 1 + lengthLength);
    const length = unarrayifyInteger(data, offset + 1, lengthLength);
    checkOffset(offset + 1 + lengthLength + length);
    return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);
  } else if (data[offset] >= 192) {
    const length = data[offset] - 192;
    checkOffset(offset + 1 + length);
    return _decodeChildren(data, offset, offset + 1, length);
  } else if (data[offset] >= 184) {
    const lengthLength = data[offset] - 183;
    checkOffset(offset + 1 + lengthLength);
    const length = unarrayifyInteger(data, offset + 1, lengthLength);
    checkOffset(offset + 1 + lengthLength + length);
    const result = hexlify(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));
    return { consumed: 1 + lengthLength + length, result };
  } else if (data[offset] >= 128) {
    const length = data[offset] - 128;
    checkOffset(offset + 1 + length);
    const result = hexlify(data.slice(offset + 1, offset + 1 + length));
    return { consumed: 1 + length, result };
  }
  return { consumed: 1, result: hexlifyByte(data[offset]) };
}
function decodeRlp(_data4) {
  const data = getBytes(_data4, "data");
  const decoded = _decode(data, 0);
  assertArgument(decoded.consumed === data.length, "unexpected junk after rlp payload", "data", _data4);
  return decoded.result;
}
function arrayifyInteger(value) {
  const result = [];
  while (value) {
    result.unshift(value & 255);
    value >>= 8;
  }
  return result;
}
function _encode(object2) {
  if (Array.isArray(object2)) {
    let payload = [];
    object2.forEach(function(child) {
      payload = payload.concat(_encode(child));
    });
    if (payload.length <= 55) {
      payload.unshift(192 + payload.length);
      return payload;
    }
    const length2 = arrayifyInteger(payload.length);
    length2.unshift(247 + length2.length);
    return length2.concat(payload);
  }
  const data = Array.prototype.slice.call(getBytes(object2, "object"));
  if (data.length === 1 && data[0] <= 127) {
    return data;
  } else if (data.length <= 55) {
    data.unshift(128 + data.length);
    return data;
  }
  const length = arrayifyInteger(data.length);
  length.unshift(183 + length.length);
  return length.concat(data);
}
const nibbles = "0123456789abcdef";
function encodeRlp(object2) {
  let result = "0x";
  for (const v3 of _encode(object2)) {
    result += nibbles[v3 >> 4];
    result += nibbles[v3 & 15];
  }
  return result;
}
const names = [
  "wei",
  "kwei",
  "mwei",
  "gwei",
  "szabo",
  "finney",
  "ether"
];
function formatUnits(value, unit) {
  let decimals = 18;
  if (typeof unit === "string") {
    const index = names.indexOf(unit);
    assertArgument(index >= 0, "invalid unit", "unit", unit);
    decimals = 3 * index;
  } else if (unit != null) {
    decimals = getNumber(unit, "unit");
  }
  return FixedNumber.fromValue(value, decimals, { decimals, width: 512 }).toString();
}
function parseUnits$1(value, unit) {
  assertArgument(typeof value === "string", "value must be a string", "value", value);
  let decimals = 18;
  if (typeof unit === "string") {
    const index = names.indexOf(unit);
    assertArgument(index >= 0, "invalid unit", "unit", unit);
    decimals = 3 * index;
  } else if (unit != null) {
    decimals = getNumber(unit, "unit");
  }
  return FixedNumber.fromString(value, { decimals, width: 512 }).value;
}
const WordSize = 32;
const Padding = new Uint8Array(WordSize);
const passProperties$1 = ["then"];
const _guard$2 = {};
const resultNames = /* @__PURE__ */ new WeakMap();
function getNames(result) {
  return resultNames.get(result);
}
function setNames(result, names2) {
  resultNames.set(result, names2);
}
function throwError(name, error) {
  const wrapped = new Error(`deferred error during ABI decoding triggered accessing ${name}`);
  wrapped.error = error;
  throw wrapped;
}
function toObject(names2, items, deep) {
  if (names2.indexOf(null) >= 0) {
    return items.map((item, index) => {
      if (item instanceof Result) {
        return toObject(getNames(item), item, deep);
      }
      return item;
    });
  }
  return names2.reduce((accum, name, index) => {
    let item = items.getValue(name);
    if (!(name in accum)) {
      if (deep && item instanceof Result) {
        item = toObject(getNames(item), item, deep);
      }
      accum[name] = item;
    }
    return accum;
  }, {});
}
const _Result = class _Result extends Array {
  /**
   *  @private
   */
  constructor(...args) {
    const guard = args[0];
    let items = args[1];
    let names2 = (args[2] || []).slice();
    let wrap = true;
    if (guard !== _guard$2) {
      items = args;
      names2 = [];
      wrap = false;
    }
    super(items.length);
    // No longer used; but cannot be removed as it will remove the
    // #private field from the .d.ts which may break backwards
    // compatibility
    __privateAdd(this, _names);
    items.forEach((item, index) => {
      this[index] = item;
    });
    const nameCounts = names2.reduce((accum, name) => {
      if (typeof name === "string") {
        accum.set(name, (accum.get(name) || 0) + 1);
      }
      return accum;
    }, /* @__PURE__ */ new Map());
    setNames(this, Object.freeze(items.map((item, index) => {
      const name = names2[index];
      if (name != null && nameCounts.get(name) === 1) {
        return name;
      }
      return null;
    })));
    __privateSet(this, _names, []);
    if (__privateGet(this, _names) == null) {
      void __privateGet(this, _names);
    }
    if (!wrap) {
      return;
    }
    Object.freeze(this);
    const proxy = new Proxy(this, {
      get: (target, prop2, receiver) => {
        if (typeof prop2 === "string") {
          if (prop2.match(/^[0-9]+$/)) {
            const index = getNumber(prop2, "%index");
            if (index < 0 || index >= this.length) {
              throw new RangeError("out of result range");
            }
            const item = target[index];
            if (item instanceof Error) {
              throwError(`index ${index}`, item);
            }
            return item;
          }
          if (passProperties$1.indexOf(prop2) >= 0) {
            return Reflect.get(target, prop2, receiver);
          }
          const value = target[prop2];
          if (value instanceof Function) {
            return function(...args2) {
              return value.apply(this === receiver ? target : this, args2);
            };
          } else if (!(prop2 in target)) {
            return target.getValue.apply(this === receiver ? target : this, [prop2]);
          }
        }
        return Reflect.get(target, prop2, receiver);
      }
    });
    setNames(proxy, getNames(this));
    return proxy;
  }
  /**
   *  Returns the Result as a normal Array. If %%deep%%, any children
   *  which are Result objects are also converted to a normal Array.
   *
   *  This will throw if there are any outstanding deferred
   *  errors.
   */
  toArray(deep) {
    const result = [];
    this.forEach((item, index) => {
      if (item instanceof Error) {
        throwError(`index ${index}`, item);
      }
      if (deep && item instanceof _Result) {
        item = item.toArray(deep);
      }
      result.push(item);
    });
    return result;
  }
  /**
   *  Returns the Result as an Object with each name-value pair. If
   *  %%deep%%, any children which are Result objects are also
   *  converted to an Object.
   *
   *  This will throw if any value is unnamed, or if there are
   *  any outstanding deferred errors.
   */
  toObject(deep) {
    const names2 = getNames(this);
    return names2.reduce((accum, name, index) => {
      assert(name != null, `value at index ${index} unnamed`, "UNSUPPORTED_OPERATION", {
        operation: "toObject()"
      });
      return toObject(names2, this, deep);
    }, {});
  }
  /**
   *  @_ignore
   */
  slice(start, end) {
    if (start == null) {
      start = 0;
    }
    if (start < 0) {
      start += this.length;
      if (start < 0) {
        start = 0;
      }
    }
    if (end == null) {
      end = this.length;
    }
    if (end < 0) {
      end += this.length;
      if (end < 0) {
        end = 0;
      }
    }
    if (end > this.length) {
      end = this.length;
    }
    const _names2 = getNames(this);
    const result = [], names2 = [];
    for (let i = start; i < end; i++) {
      result.push(this[i]);
      names2.push(_names2[i]);
    }
    return new _Result(_guard$2, result, names2);
  }
  /**
   *  @_ignore
   */
  filter(callback, thisArg) {
    const _names2 = getNames(this);
    const result = [], names2 = [];
    for (let i = 0; i < this.length; i++) {
      const item = this[i];
      if (item instanceof Error) {
        throwError(`index ${i}`, item);
      }
      if (callback.call(thisArg, item, i, this)) {
        result.push(item);
        names2.push(_names2[i]);
      }
    }
    return new _Result(_guard$2, result, names2);
  }
  /**
   *  @_ignore
   */
  map(callback, thisArg) {
    const result = [];
    for (let i = 0; i < this.length; i++) {
      const item = this[i];
      if (item instanceof Error) {
        throwError(`index ${i}`, item);
      }
      result.push(callback.call(thisArg, item, i, this));
    }
    return result;
  }
  /**
   *  Returns the value for %%name%%.
   *
   *  Since it is possible to have a key whose name conflicts with
   *  a method on a [[Result]] or its superclass Array, or any
   *  JavaScript keyword, this ensures all named values are still
   *  accessible by name.
   */
  getValue(name) {
    const index = getNames(this).indexOf(name);
    if (index === -1) {
      return void 0;
    }
    const value = this[index];
    if (value instanceof Error) {
      throwError(`property ${JSON.stringify(name)}`, value.error);
    }
    return value;
  }
  /**
   *  Creates a new [[Result]] for %%items%% with each entry
   *  also accessible by its corresponding name in %%keys%%.
   */
  static fromItems(items, keys) {
    return new _Result(_guard$2, items, keys);
  }
};
_names = new WeakMap();
let Result = _Result;
function getValue$1(value) {
  let bytes = toBeArray(value);
  assert(bytes.length <= WordSize, "value out-of-bounds", "BUFFER_OVERRUN", { buffer: bytes, length: WordSize, offset: bytes.length });
  if (bytes.length !== WordSize) {
    bytes = getBytesCopy(concat([Padding.slice(bytes.length % WordSize), bytes]));
  }
  return bytes;
}
class Coder {
  constructor(name, type, localName, dynamic) {
    // The coder name:
    //   - address, uint256, tuple, array, etc.
    __publicField(this, "name");
    // The fully expanded type, including composite types:
    //   - address, uint256, tuple(address,bytes), uint256[3][4][],  etc.
    __publicField(this, "type");
    // The localName bound in the signature, in this example it is "baz":
    //   - tuple(address foo, uint bar) baz
    __publicField(this, "localName");
    // Whether this type is dynamic:
    //  - Dynamic: bytes, string, address[], tuple(boolean[]), etc.
    //  - Not Dynamic: address, uint256, boolean[3], tuple(address, uint8)
    __publicField(this, "dynamic");
    defineProperties(this, { name, type, localName, dynamic }, {
      name: "string",
      type: "string",
      localName: "string",
      dynamic: "boolean"
    });
  }
  _throwError(message, value) {
    assertArgument(false, message, this.localName, value);
  }
}
class Writer {
  constructor() {
    __privateAdd(this, _Writer_instances);
    // An array of WordSize lengthed objects to concatenation
    __privateAdd(this, _data);
    __privateAdd(this, _dataLength);
    __privateSet(this, _data, []);
    __privateSet(this, _dataLength, 0);
  }
  get data() {
    return concat(__privateGet(this, _data));
  }
  get length() {
    return __privateGet(this, _dataLength);
  }
  appendWriter(writer) {
    return __privateMethod(this, _Writer_instances, writeData_fn).call(this, getBytesCopy(writer.data));
  }
  // Arrayish item; pad on the right to *nearest* WordSize
  writeBytes(value) {
    let bytes = getBytesCopy(value);
    const paddingOffset = bytes.length % WordSize;
    if (paddingOffset) {
      bytes = getBytesCopy(concat([bytes, Padding.slice(paddingOffset)]));
    }
    return __privateMethod(this, _Writer_instances, writeData_fn).call(this, bytes);
  }
  // Numeric item; pad on the left *to* WordSize
  writeValue(value) {
    return __privateMethod(this, _Writer_instances, writeData_fn).call(this, getValue$1(value));
  }
  // Inserts a numeric place-holder, returning a callback that can
  // be used to asjust the value later
  writeUpdatableValue() {
    const offset = __privateGet(this, _data).length;
    __privateGet(this, _data).push(Padding);
    __privateSet(this, _dataLength, __privateGet(this, _dataLength) + WordSize);
    return (value) => {
      __privateGet(this, _data)[offset] = getValue$1(value);
    };
  }
}
_data = new WeakMap();
_dataLength = new WeakMap();
_Writer_instances = new WeakSet();
writeData_fn = function(data) {
  __privateGet(this, _data).push(data);
  __privateSet(this, _dataLength, __privateGet(this, _dataLength) + data.length);
  return data.length;
};
const _Reader = class _Reader {
  constructor(data, allowLoose, maxInflation) {
    __privateAdd(this, _Reader_instances);
    // Allows incomplete unpadded data to be read; otherwise an error
    // is raised if attempting to overrun the buffer. This is required
    // to deal with an old Solidity bug, in which event data for
    // external (not public thoguh) was tightly packed.
    __publicField(this, "allowLoose");
    __privateAdd(this, _data2);
    __privateAdd(this, _offset);
    __privateAdd(this, _bytesRead);
    __privateAdd(this, _parent);
    __privateAdd(this, _maxInflation);
    defineProperties(this, { allowLoose: !!allowLoose });
    __privateSet(this, _data2, getBytesCopy(data));
    __privateSet(this, _bytesRead, 0);
    __privateSet(this, _parent, null);
    __privateSet(this, _maxInflation, maxInflation != null ? maxInflation : 1024);
    __privateSet(this, _offset, 0);
  }
  get data() {
    return hexlify(__privateGet(this, _data2));
  }
  get dataLength() {
    return __privateGet(this, _data2).length;
  }
  get consumed() {
    return __privateGet(this, _offset);
  }
  get bytes() {
    return new Uint8Array(__privateGet(this, _data2));
  }
  // Create a sub-reader with the same underlying data, but offset
  subReader(offset) {
    const reader = new _Reader(__privateGet(this, _data2).slice(__privateGet(this, _offset) + offset), this.allowLoose, __privateGet(this, _maxInflation));
    __privateSet(reader, _parent, this);
    return reader;
  }
  // Read bytes
  readBytes(length, loose) {
    let bytes = __privateMethod(this, _Reader_instances, peekBytes_fn).call(this, 0, length, !!loose);
    __privateMethod(this, _Reader_instances, incrementBytesRead_fn).call(this, length);
    __privateSet(this, _offset, __privateGet(this, _offset) + bytes.length);
    return bytes.slice(0, length);
  }
  // Read a numeric values
  readValue() {
    return toBigInt(this.readBytes(WordSize));
  }
  readIndex() {
    return toNumber(this.readBytes(WordSize));
  }
};
_data2 = new WeakMap();
_offset = new WeakMap();
_bytesRead = new WeakMap();
_parent = new WeakMap();
_maxInflation = new WeakMap();
_Reader_instances = new WeakSet();
incrementBytesRead_fn = function(count) {
  var _a3;
  if (__privateGet(this, _parent)) {
    return __privateMethod(_a3 = __privateGet(this, _parent), _Reader_instances, incrementBytesRead_fn).call(_a3, count);
  }
  __privateSet(this, _bytesRead, __privateGet(this, _bytesRead) + count);
  assert(__privateGet(this, _maxInflation) < 1 || __privateGet(this, _bytesRead) <= __privateGet(this, _maxInflation) * this.dataLength, `compressed ABI data exceeds inflation ratio of ${__privateGet(this, _maxInflation)} ( see: https://github.com/ethers-io/ethers.js/issues/4537 )`, "BUFFER_OVERRUN", {
    buffer: getBytesCopy(__privateGet(this, _data2)),
    offset: __privateGet(this, _offset),
    length: count,
    info: {
      bytesRead: __privateGet(this, _bytesRead),
      dataLength: this.dataLength
    }
  });
};
peekBytes_fn = function(offset, length, loose) {
  let alignedLength = Math.ceil(length / WordSize) * WordSize;
  if (__privateGet(this, _offset) + alignedLength > __privateGet(this, _data2).length) {
    if (this.allowLoose && loose && __privateGet(this, _offset) + length <= __privateGet(this, _data2).length) {
      alignedLength = length;
    } else {
      assert(false, "data out-of-bounds", "BUFFER_OVERRUN", {
        buffer: getBytesCopy(__privateGet(this, _data2)),
        length: __privateGet(this, _data2).length,
        offset: __privateGet(this, _offset) + alignedLength
      });
    }
  }
  return __privateGet(this, _data2).slice(__privateGet(this, _offset), __privateGet(this, _offset) + alignedLength);
};
let Reader = _Reader;
var createHash = require$$1$1;
var p$3 = require$$4;
p$3.pbkdf2;
p$3.pbkdf2Sync;
var aes = require$$5;
aes.Cipher;
aes.createCipher;
aes.Cipheriv;
aes.createCipheriv;
aes.Decipher;
aes.createDecipher;
aes.Decipheriv;
aes.createDecipheriv;
aes.getCiphers;
aes.listCiphers;
var dh = require$$6;
dh.DiffieHellmanGroup;
dh.createDiffieHellmanGroup;
dh.getDiffieHellman;
dh.createDiffieHellman;
dh.DiffieHellman;
var sign = require$$7;
sign.createSign;
sign.Sign;
sign.createVerify;
sign.Verify;
var publicEncrypt = require$$9;
publicEncrypt.publicEncrypt;
publicEncrypt.privateEncrypt;
publicEncrypt.publicDecrypt;
publicEncrypt.privateDecrypt;
var rf = require$$10;
rf.randomFill;
rf.randomFillSync;
let locked = false;
const _keccak256 = function(data) {
  return keccak_256(data);
};
let __keccak256 = _keccak256;
function keccak256(_data4) {
  const data = getBytes(_data4, "data");
  return hexlify(__keccak256(data));
}
keccak256._ = _keccak256;
keccak256.lock = function() {
  locked = true;
};
keccak256.register = function(func) {
  if (locked) {
    throw new TypeError("keccak256 is locked");
  }
  __keccak256 = func;
};
Object.freeze(keccak256);
const _sha256 = function(data) {
  return createHash("sha256").update(data).digest();
};
let __sha256 = _sha256;
let locked256 = false;
function sha256(_data4) {
  const data = getBytes(_data4, "data");
  return hexlify(__sha256(data));
}
sha256._ = _sha256;
sha256.lock = function() {
  locked256 = true;
};
sha256.register = function(func) {
  if (locked256) {
    throw new Error("sha256 is locked");
  }
  __sha256 = func;
};
Object.freeze(sha256);
Object.freeze(sha256);
const ZeroAddress = "0x0000000000000000000000000000000000000000";
const ZeroHash = "0x0000000000000000000000000000000000000000000000000000000000000000";
const BN_0$7 = BigInt(0);
const BN_1$2 = BigInt(1);
const BN_2$2 = BigInt(2);
const BN_27$1 = BigInt(27);
const BN_28$1 = BigInt(28);
const BN_35$1 = BigInt(35);
const _guard$1 = {};
function toUint256(value) {
  return zeroPadValue(toBeArray(value), 32);
}
const _Signature = class _Signature {
  /**
   *  @private
   */
  constructor(guard, r3, s2, v3) {
    __privateAdd(this, _r2);
    __privateAdd(this, _s2);
    __privateAdd(this, _v);
    __privateAdd(this, _networkV);
    assertPrivate(guard, _guard$1, "Signature");
    __privateSet(this, _r2, r3);
    __privateSet(this, _s2, s2);
    __privateSet(this, _v, v3);
    __privateSet(this, _networkV, null);
  }
  /**
   *  The ``r`` value for a signautre.
   *
   *  This represents the ``x`` coordinate of a "reference" or
   *  challenge point, from which the ``y`` can be computed.
   */
  get r() {
    return __privateGet(this, _r2);
  }
  set r(value) {
    assertArgument(dataLength(value) === 32, "invalid r", "value", value);
    __privateSet(this, _r2, hexlify(value));
  }
  /**
   *  The ``s`` value for a signature.
   */
  get s() {
    return __privateGet(this, _s2);
  }
  set s(_value2) {
    assertArgument(dataLength(_value2) === 32, "invalid s", "value", _value2);
    const value = hexlify(_value2);
    assertArgument(parseInt(value.substring(0, 3)) < 8, "non-canonical s", "value", value);
    __privateSet(this, _s2, value);
  }
  /**
   *  The ``v`` value for a signature.
   *
   *  Since a given ``x`` value for ``r`` has two possible values for
   *  its correspondin ``y``, the ``v`` indicates which of the two ``y``
   *  values to use.
   *
   *  It is normalized to the values ``27`` or ``28`` for legacy
   *  purposes.
   */
  get v() {
    return __privateGet(this, _v);
  }
  set v(value) {
    const v3 = getNumber(value, "value");
    assertArgument(v3 === 27 || v3 === 28, "invalid v", "v", value);
    __privateSet(this, _v, v3);
  }
  /**
   *  The EIP-155 ``v`` for legacy transactions. For non-legacy
   *  transactions, this value is ``null``.
   */
  get networkV() {
    return __privateGet(this, _networkV);
  }
  /**
   *  The chain ID for EIP-155 legacy transactions. For non-legacy
   *  transactions, this value is ``null``.
   */
  get legacyChainId() {
    const v3 = this.networkV;
    if (v3 == null) {
      return null;
    }
    return _Signature.getChainId(v3);
  }
  /**
   *  The ``yParity`` for the signature.
   *
   *  See ``v`` for more details on how this value is used.
   */
  get yParity() {
    return this.v === 27 ? 0 : 1;
  }
  /**
   *  The [[link-eip-2098]] compact representation of the ``yParity``
   *  and ``s`` compacted into a single ``bytes32``.
   */
  get yParityAndS() {
    const yParityAndS = getBytes(this.s);
    if (this.yParity) {
      yParityAndS[0] |= 128;
    }
    return hexlify(yParityAndS);
  }
  /**
   *  The [[link-eip-2098]] compact representation.
   */
  get compactSerialized() {
    return concat([this.r, this.yParityAndS]);
  }
  /**
   *  The serialized representation.
   */
  get serialized() {
    return concat([this.r, this.s, this.yParity ? "0x1c" : "0x1b"]);
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `Signature { r: "${this.r}", s: "${this.s}", yParity: ${this.yParity}, networkV: ${this.networkV} }`;
  }
  /**
   *  Returns a new identical [[Signature]].
   */
  clone() {
    const clone = new _Signature(_guard$1, this.r, this.s, this.v);
    if (this.networkV) {
      __privateSet(clone, _networkV, this.networkV);
    }
    return clone;
  }
  /**
   *  Returns a representation that is compatible with ``JSON.stringify``.
   */
  toJSON() {
    const networkV = this.networkV;
    return {
      _type: "signature",
      networkV: networkV != null ? networkV.toString() : null,
      r: this.r,
      s: this.s,
      v: this.v
    };
  }
  /**
   *  Compute the chain ID from the ``v`` in a legacy EIP-155 transactions.
   *
   *  @example:
   *    Signature.getChainId(45)
   *    //_result:
   *
   *    Signature.getChainId(46)
   *    //_result:
   */
  static getChainId(v3) {
    const bv = getBigInt(v3, "v");
    if (bv == BN_27$1 || bv == BN_28$1) {
      return BN_0$7;
    }
    assertArgument(bv >= BN_35$1, "invalid EIP-155 v", "v", v3);
    return (bv - BN_35$1) / BN_2$2;
  }
  /**
   *  Compute the ``v`` for a chain ID for a legacy EIP-155 transactions.
   *
   *  Legacy transactions which use [[link-eip-155]] hijack the ``v``
   *  property to include the chain ID.
   *
   *  @example:
   *    Signature.getChainIdV(5, 27)
   *    //_result:
   *
   *    Signature.getChainIdV(5, 28)
   *    //_result:
   *
   */
  static getChainIdV(chainId, v3) {
    return getBigInt(chainId) * BN_2$2 + BigInt(35 + v3 - 27);
  }
  /**
   *  Compute the normalized legacy transaction ``v`` from a ``yParirty``,
   *  a legacy transaction ``v`` or a legacy [[link-eip-155]] transaction.
   *
   *  @example:
   *    // The values 0 and 1 imply v is actually yParity
   *    Signature.getNormalizedV(0)
   *    //_result:
   *
   *    // Legacy non-EIP-1559 transaction (i.e. 27 or 28)
   *    Signature.getNormalizedV(27)
   *    //_result:
   *
   *    // Legacy EIP-155 transaction (i.e. >= 35)
   *    Signature.getNormalizedV(46)
   *    //_result:
   *
   *    // Invalid values throw
   *    Signature.getNormalizedV(5)
   *    //_error:
   */
  static getNormalizedV(v3) {
    const bv = getBigInt(v3);
    if (bv === BN_0$7 || bv === BN_27$1) {
      return 27;
    }
    if (bv === BN_1$2 || bv === BN_28$1) {
      return 28;
    }
    assertArgument(bv >= BN_35$1, "invalid v", "v", v3);
    return bv & BN_1$2 ? 27 : 28;
  }
  /**
   *  Creates a new [[Signature]].
   *
   *  If no %%sig%% is provided, a new [[Signature]] is created
   *  with default values.
   *
   *  If %%sig%% is a string, it is parsed.
   */
  static from(sig) {
    function assertError(check, message) {
      assertArgument(check, message, "signature", sig);
    }
    if (sig == null) {
      return new _Signature(_guard$1, ZeroHash, ZeroHash, 27);
    }
    if (typeof sig === "string") {
      const bytes = getBytes(sig, "signature");
      if (bytes.length === 64) {
        const r4 = hexlify(bytes.slice(0, 32));
        const s3 = bytes.slice(32, 64);
        const v4 = s3[0] & 128 ? 28 : 27;
        s3[0] &= 127;
        return new _Signature(_guard$1, r4, hexlify(s3), v4);
      }
      if (bytes.length === 65) {
        const r4 = hexlify(bytes.slice(0, 32));
        const s3 = bytes.slice(32, 64);
        assertError((s3[0] & 128) === 0, "non-canonical s");
        const v4 = _Signature.getNormalizedV(bytes[64]);
        return new _Signature(_guard$1, r4, hexlify(s3), v4);
      }
      assertError(false, "invalid raw signature length");
    }
    if (sig instanceof _Signature) {
      return sig.clone();
    }
    const _r3 = sig.r;
    assertError(_r3 != null, "missing r");
    const r3 = toUint256(_r3);
    const s2 = function(s3, yParityAndS) {
      if (s3 != null) {
        return toUint256(s3);
      }
      if (yParityAndS != null) {
        assertError(isHexString(yParityAndS, 32), "invalid yParityAndS");
        const bytes = getBytes(yParityAndS);
        bytes[0] &= 127;
        return hexlify(bytes);
      }
      assertError(false, "missing s");
    }(sig.s, sig.yParityAndS);
    assertError((getBytes(s2)[0] & 128) == 0, "non-canonical s");
    const { networkV, v: v3 } = function(_v2, yParityAndS, yParity) {
      if (_v2 != null) {
        const v4 = getBigInt(_v2);
        return {
          networkV: v4 >= BN_35$1 ? v4 : void 0,
          v: _Signature.getNormalizedV(v4)
        };
      }
      if (yParityAndS != null) {
        assertError(isHexString(yParityAndS, 32), "invalid yParityAndS");
        return { v: getBytes(yParityAndS)[0] & 128 ? 28 : 27 };
      }
      if (yParity != null) {
        switch (getNumber(yParity, "sig.yParity")) {
          case 0:
            return { v: 27 };
          case 1:
            return { v: 28 };
        }
        assertError(false, "invalid yParity");
      }
      assertError(false, "missing v");
    }(sig.v, sig.yParityAndS, sig.yParity);
    const result = new _Signature(_guard$1, r3, s2, v3);
    if (networkV) {
      __privateSet(result, _networkV, networkV);
    }
    assertError(sig.yParity == null || getNumber(sig.yParity, "sig.yParity") === result.yParity, "yParity mismatch");
    assertError(sig.yParityAndS == null || sig.yParityAndS === result.yParityAndS, "yParityAndS mismatch");
    return result;
  }
};
_r2 = new WeakMap();
_s2 = new WeakMap();
_v = new WeakMap();
_networkV = new WeakMap();
let Signature = _Signature;
const _SigningKey = class _SigningKey {
  /**
   *  Creates a new **SigningKey** for %%privateKey%%.
   */
  constructor(privateKey) {
    __privateAdd(this, _privateKey);
    assertArgument(dataLength(privateKey) === 32, "invalid private key", "privateKey", "[REDACTED]");
    __privateSet(this, _privateKey, hexlify(privateKey));
  }
  /**
   *  The private key.
   */
  get privateKey() {
    return __privateGet(this, _privateKey);
  }
  /**
   *  The uncompressed public key.
   *
   * This will always begin with the prefix ``0x04`` and be 132
   * characters long (the ``0x`` prefix and 130 hexadecimal nibbles).
   */
  get publicKey() {
    return _SigningKey.computePublicKey(__privateGet(this, _privateKey));
  }
  /**
   *  The compressed public key.
   *
   *  This will always begin with either the prefix ``0x02`` or ``0x03``
   *  and be 68 characters long (the ``0x`` prefix and 33 hexadecimal
   *  nibbles)
   */
  get compressedPublicKey() {
    return _SigningKey.computePublicKey(__privateGet(this, _privateKey), true);
  }
  /**
   *  Return the signature of the signed %%digest%%.
   */
  sign(digest) {
    assertArgument(dataLength(digest) === 32, "invalid digest length", "digest", digest);
    const sig = secp256k1.sign(getBytesCopy(digest), getBytesCopy(__privateGet(this, _privateKey)), {
      lowS: true
    });
    return Signature.from({
      r: toBeHex(sig.r, 32),
      s: toBeHex(sig.s, 32),
      v: sig.recovery ? 28 : 27
    });
  }
  /**
   *  Returns the [[link-wiki-ecdh]] shared secret between this
   *  private key and the %%other%% key.
   *
   *  The %%other%% key may be any type of key, a raw public key,
   *  a compressed/uncompressed pubic key or aprivate key.
   *
   *  Best practice is usually to use a cryptographic hash on the
   *  returned value before using it as a symetric secret.
   *
   *  @example:
   *    sign1 = new SigningKey(id("some-secret-1"))
   *    sign2 = new SigningKey(id("some-secret-2"))
   *
   *    // Notice that privA.computeSharedSecret(pubB)...
   *    sign1.computeSharedSecret(sign2.publicKey)
   *    //_result:
   *
   *    // ...is equal to privB.computeSharedSecret(pubA).
   *    sign2.computeSharedSecret(sign1.publicKey)
   *    //_result:
   */
  computeSharedSecret(other) {
    const pubKey = _SigningKey.computePublicKey(other);
    return hexlify(secp256k1.getSharedSecret(getBytesCopy(__privateGet(this, _privateKey)), getBytes(pubKey), false));
  }
  /**
   *  Compute the public key for %%key%%, optionally %%compressed%%.
   *
   *  The %%key%% may be any type of key, a raw public key, a
   *  compressed/uncompressed public key or private key.
   *
   *  @example:
   *    sign = new SigningKey(id("some-secret"));
   *
   *    // Compute the uncompressed public key for a private key
   *    SigningKey.computePublicKey(sign.privateKey)
   *    //_result:
   *
   *    // Compute the compressed public key for a private key
   *    SigningKey.computePublicKey(sign.privateKey, true)
   *    //_result:
   *
   *    // Compute the uncompressed public key
   *    SigningKey.computePublicKey(sign.publicKey, false);
   *    //_result:
   *
   *    // Compute the Compressed a public key
   *    SigningKey.computePublicKey(sign.publicKey, true);
   *    //_result:
   */
  static computePublicKey(key, compressed) {
    let bytes = getBytes(key, "key");
    if (bytes.length === 32) {
      const pubKey = secp256k1.getPublicKey(bytes, !!compressed);
      return hexlify(pubKey);
    }
    if (bytes.length === 64) {
      const pub = new Uint8Array(65);
      pub[0] = 4;
      pub.set(bytes, 1);
      bytes = pub;
    }
    const point = secp256k1.ProjectivePoint.fromHex(bytes);
    return hexlify(point.toRawBytes(compressed));
  }
  /**
   *  Returns the public key for the private key which produced the
   *  %%signature%% for the given %%digest%%.
   *
   *  @example:
   *    key = new SigningKey(id("some-secret"))
   *    digest = id("hello world")
   *    sig = key.sign(digest)
   *
   *    // Notice the signer public key...
   *    key.publicKey
   *    //_result:
   *
   *    // ...is equal to the recovered public key
   *    SigningKey.recoverPublicKey(digest, sig)
   *    //_result:
   *
   */
  static recoverPublicKey(digest, signature) {
    assertArgument(dataLength(digest) === 32, "invalid digest length", "digest", digest);
    const sig = Signature.from(signature);
    let secpSig = secp256k1.Signature.fromCompact(getBytesCopy(concat([sig.r, sig.s])));
    secpSig = secpSig.addRecoveryBit(sig.yParity);
    const pubKey = secpSig.recoverPublicKey(getBytesCopy(digest));
    assertArgument(pubKey != null, "invalid signautre for digest", "signature", signature);
    return "0x" + pubKey.toHex(false);
  }
  /**
   *  Returns the point resulting from adding the ellipic curve points
   *  %%p0%% and %%p1%%.
   *
   *  This is not a common function most developers should require, but
   *  can be useful for certain privacy-specific techniques.
   *
   *  For example, it is used by [[HDNodeWallet]] to compute child
   *  addresses from parent public keys and chain codes.
   */
  static addPoints(p02, p1, compressed) {
    const pub0 = secp256k1.ProjectivePoint.fromHex(_SigningKey.computePublicKey(p02).substring(2));
    const pub1 = secp256k1.ProjectivePoint.fromHex(_SigningKey.computePublicKey(p1).substring(2));
    return "0x" + pub0.add(pub1).toHex(!!compressed);
  }
};
_privateKey = new WeakMap();
let SigningKey = _SigningKey;
const BN_0$6 = BigInt(0);
const BN_36 = BigInt(36);
function getChecksumAddress(address) {
  address = address.toLowerCase();
  const chars = address.substring(2).split("");
  const expanded = new Uint8Array(40);
  for (let i = 0; i < 40; i++) {
    expanded[i] = chars[i].charCodeAt(0);
  }
  const hashed = getBytes(keccak256(expanded));
  for (let i = 0; i < 40; i += 2) {
    if (hashed[i >> 1] >> 4 >= 8) {
      chars[i] = chars[i].toUpperCase();
    }
    if ((hashed[i >> 1] & 15) >= 8) {
      chars[i + 1] = chars[i + 1].toUpperCase();
    }
  }
  return "0x" + chars.join("");
}
const ibanLookup = {};
for (let i = 0; i < 10; i++) {
  ibanLookup[String(i)] = String(i);
}
for (let i = 0; i < 26; i++) {
  ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);
}
const safeDigits = 15;
function ibanChecksum(address) {
  address = address.toUpperCase();
  address = address.substring(4) + address.substring(0, 2) + "00";
  let expanded = address.split("").map((c) => {
    return ibanLookup[c];
  }).join("");
  while (expanded.length >= safeDigits) {
    let block = expanded.substring(0, safeDigits);
    expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
  }
  let checksum = String(98 - parseInt(expanded, 10) % 97);
  while (checksum.length < 2) {
    checksum = "0" + checksum;
  }
  return checksum;
}
const Base36 = function() {
  const result = {};
  for (let i = 0; i < 36; i++) {
    const key = "0123456789abcdefghijklmnopqrstuvwxyz"[i];
    result[key] = BigInt(i);
  }
  return result;
}();
function fromBase36(value) {
  value = value.toLowerCase();
  let result = BN_0$6;
  for (let i = 0; i < value.length; i++) {
    result = result * BN_36 + Base36[value[i]];
  }
  return result;
}
function getAddress(address) {
  assertArgument(typeof address === "string", "invalid address", "address", address);
  if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    if (!address.startsWith("0x")) {
      address = "0x" + address;
    }
    const result = getChecksumAddress(address);
    assertArgument(!address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || result === address, "bad address checksum", "address", address);
    return result;
  }
  if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    assertArgument(address.substring(2, 4) === ibanChecksum(address), "bad icap checksum", "address", address);
    let result = fromBase36(address.substring(4)).toString(16);
    while (result.length < 40) {
      result = "0" + result;
    }
    return getChecksumAddress("0x" + result);
  }
  assertArgument(false, "invalid address", "address", address);
}
function getCreateAddress(tx) {
  const from = getAddress(tx.from);
  const nonce = getBigInt(tx.nonce, "tx.nonce");
  let nonceHex = nonce.toString(16);
  if (nonceHex === "0") {
    nonceHex = "0x";
  } else if (nonceHex.length % 2) {
    nonceHex = "0x0" + nonceHex;
  } else {
    nonceHex = "0x" + nonceHex;
  }
  return getAddress(dataSlice(keccak256(encodeRlp([from, nonceHex])), 12));
}
function isAddressable(value) {
  return value && typeof value.getAddress === "function";
}
async function checkAddress(target, promise) {
  const result = await promise;
  if (result == null || result === "0x0000000000000000000000000000000000000000") {
    assert(typeof target !== "string", "unconfigured name", "UNCONFIGURED_NAME", { value: target });
    assertArgument(false, "invalid AddressLike value; did not resolve to a value address", "target", target);
  }
  return getAddress(result);
}
function resolveAddress(target, resolver) {
  if (typeof target === "string") {
    if (target.match(/^0x[0-9a-f]{40}$/i)) {
      return getAddress(target);
    }
    assert(resolver != null, "ENS resolution requires a provider", "UNSUPPORTED_OPERATION", { operation: "resolveName" });
    return checkAddress(target, resolver.resolveName(target));
  } else if (isAddressable(target)) {
    return checkAddress(target, target.getAddress());
  } else if (target && typeof target.then === "function") {
    return checkAddress(target, target);
  }
  assertArgument(false, "unsupported addressable value", "target", target);
}
const _gaurd = {};
function n(value, width) {
  let signed = false;
  if (width < 0) {
    signed = true;
    width *= -1;
  }
  return new Typed(_gaurd, `${signed ? "" : "u"}int${width}`, value, { signed, width });
}
function b$4(value, size) {
  return new Typed(_gaurd, `bytes${size ? size : ""}`, value, { size });
}
const _typedSymbol = Symbol.for("_ethers_typed");
const _Typed = class _Typed {
  /**
   *  @_ignore:
   */
  constructor(gaurd, type, value, options) {
    /**
     *  The type, as a Solidity-compatible type.
     */
    __publicField(this, "type");
    /**
     *  The actual value.
     */
    __publicField(this, "value");
    __privateAdd(this, _options);
    /**
     *  @_ignore:
     */
    __publicField(this, "_typedSymbol");
    if (options == null) {
      options = null;
    }
    assertPrivate(_gaurd, gaurd, "Typed");
    defineProperties(this, { _typedSymbol, type, value });
    __privateSet(this, _options, options);
    this.format();
  }
  /**
   *  Format the type as a Human-Readable type.
   */
  format() {
    if (this.type === "array") {
      throw new Error("");
    } else if (this.type === "dynamicArray") {
      throw new Error("");
    } else if (this.type === "tuple") {
      return `tuple(${this.value.map((v3) => v3.format()).join(",")})`;
    }
    return this.type;
  }
  /**
   *  The default value returned by this type.
   */
  defaultValue() {
    return 0;
  }
  /**
   *  The minimum value for numeric types.
   */
  minValue() {
    return 0;
  }
  /**
   *  The maximum value for numeric types.
   */
  maxValue() {
    return 0;
  }
  /**
   *  Returns ``true`` and provides a type guard is this is a [[TypedBigInt]].
   */
  isBigInt() {
    return !!this.type.match(/^u?int[0-9]+$/);
  }
  /**
   *  Returns ``true`` and provides a type guard is this is a [[TypedData]].
   */
  isData() {
    return this.type.startsWith("bytes");
  }
  /**
   *  Returns ``true`` and provides a type guard is this is a [[TypedString]].
   */
  isString() {
    return this.type === "string";
  }
  /**
   *  Returns the tuple name, if this is a tuple. Throws otherwise.
   */
  get tupleName() {
    if (this.type !== "tuple") {
      throw TypeError("not a tuple");
    }
    return __privateGet(this, _options);
  }
  // Returns the length of this type as an array
  // - `null` indicates the length is unforced, it could be dynamic
  // - `-1` indicates the length is dynamic
  // - any other value indicates it is a static array and is its length
  /**
   *  Returns the length of the array type or ``-1`` if it is dynamic.
   *
   *  Throws if the type is not an array.
   */
  get arrayLength() {
    if (this.type !== "array") {
      throw TypeError("not an array");
    }
    if (__privateGet(this, _options) === true) {
      return -1;
    }
    if (__privateGet(this, _options) === false) {
      return this.value.length;
    }
    return null;
  }
  /**
   *  Returns a new **Typed** of %%type%% with the %%value%%.
   */
  static from(type, value) {
    return new _Typed(_gaurd, type, value);
  }
  /**
   *  Return a new ``uint8`` type for %%v%%.
   */
  static uint8(v3) {
    return n(v3, 8);
  }
  /**
   *  Return a new ``uint16`` type for %%v%%.
   */
  static uint16(v3) {
    return n(v3, 16);
  }
  /**
   *  Return a new ``uint24`` type for %%v%%.
   */
  static uint24(v3) {
    return n(v3, 24);
  }
  /**
   *  Return a new ``uint32`` type for %%v%%.
   */
  static uint32(v3) {
    return n(v3, 32);
  }
  /**
   *  Return a new ``uint40`` type for %%v%%.
   */
  static uint40(v3) {
    return n(v3, 40);
  }
  /**
   *  Return a new ``uint48`` type for %%v%%.
   */
  static uint48(v3) {
    return n(v3, 48);
  }
  /**
   *  Return a new ``uint56`` type for %%v%%.
   */
  static uint56(v3) {
    return n(v3, 56);
  }
  /**
   *  Return a new ``uint64`` type for %%v%%.
   */
  static uint64(v3) {
    return n(v3, 64);
  }
  /**
   *  Return a new ``uint72`` type for %%v%%.
   */
  static uint72(v3) {
    return n(v3, 72);
  }
  /**
   *  Return a new ``uint80`` type for %%v%%.
   */
  static uint80(v3) {
    return n(v3, 80);
  }
  /**
   *  Return a new ``uint88`` type for %%v%%.
   */
  static uint88(v3) {
    return n(v3, 88);
  }
  /**
   *  Return a new ``uint96`` type for %%v%%.
   */
  static uint96(v3) {
    return n(v3, 96);
  }
  /**
   *  Return a new ``uint104`` type for %%v%%.
   */
  static uint104(v3) {
    return n(v3, 104);
  }
  /**
   *  Return a new ``uint112`` type for %%v%%.
   */
  static uint112(v3) {
    return n(v3, 112);
  }
  /**
   *  Return a new ``uint120`` type for %%v%%.
   */
  static uint120(v3) {
    return n(v3, 120);
  }
  /**
   *  Return a new ``uint128`` type for %%v%%.
   */
  static uint128(v3) {
    return n(v3, 128);
  }
  /**
   *  Return a new ``uint136`` type for %%v%%.
   */
  static uint136(v3) {
    return n(v3, 136);
  }
  /**
   *  Return a new ``uint144`` type for %%v%%.
   */
  static uint144(v3) {
    return n(v3, 144);
  }
  /**
   *  Return a new ``uint152`` type for %%v%%.
   */
  static uint152(v3) {
    return n(v3, 152);
  }
  /**
   *  Return a new ``uint160`` type for %%v%%.
   */
  static uint160(v3) {
    return n(v3, 160);
  }
  /**
   *  Return a new ``uint168`` type for %%v%%.
   */
  static uint168(v3) {
    return n(v3, 168);
  }
  /**
   *  Return a new ``uint176`` type for %%v%%.
   */
  static uint176(v3) {
    return n(v3, 176);
  }
  /**
   *  Return a new ``uint184`` type for %%v%%.
   */
  static uint184(v3) {
    return n(v3, 184);
  }
  /**
   *  Return a new ``uint192`` type for %%v%%.
   */
  static uint192(v3) {
    return n(v3, 192);
  }
  /**
   *  Return a new ``uint200`` type for %%v%%.
   */
  static uint200(v3) {
    return n(v3, 200);
  }
  /**
   *  Return a new ``uint208`` type for %%v%%.
   */
  static uint208(v3) {
    return n(v3, 208);
  }
  /**
   *  Return a new ``uint216`` type for %%v%%.
   */
  static uint216(v3) {
    return n(v3, 216);
  }
  /**
   *  Return a new ``uint224`` type for %%v%%.
   */
  static uint224(v3) {
    return n(v3, 224);
  }
  /**
   *  Return a new ``uint232`` type for %%v%%.
   */
  static uint232(v3) {
    return n(v3, 232);
  }
  /**
   *  Return a new ``uint240`` type for %%v%%.
   */
  static uint240(v3) {
    return n(v3, 240);
  }
  /**
   *  Return a new ``uint248`` type for %%v%%.
   */
  static uint248(v3) {
    return n(v3, 248);
  }
  /**
   *  Return a new ``uint256`` type for %%v%%.
   */
  static uint256(v3) {
    return n(v3, 256);
  }
  /**
   *  Return a new ``uint256`` type for %%v%%.
   */
  static uint(v3) {
    return n(v3, 256);
  }
  /**
   *  Return a new ``int8`` type for %%v%%.
   */
  static int8(v3) {
    return n(v3, -8);
  }
  /**
   *  Return a new ``int16`` type for %%v%%.
   */
  static int16(v3) {
    return n(v3, -16);
  }
  /**
   *  Return a new ``int24`` type for %%v%%.
   */
  static int24(v3) {
    return n(v3, -24);
  }
  /**
   *  Return a new ``int32`` type for %%v%%.
   */
  static int32(v3) {
    return n(v3, -32);
  }
  /**
   *  Return a new ``int40`` type for %%v%%.
   */
  static int40(v3) {
    return n(v3, -40);
  }
  /**
   *  Return a new ``int48`` type for %%v%%.
   */
  static int48(v3) {
    return n(v3, -48);
  }
  /**
   *  Return a new ``int56`` type for %%v%%.
   */
  static int56(v3) {
    return n(v3, -56);
  }
  /**
   *  Return a new ``int64`` type for %%v%%.
   */
  static int64(v3) {
    return n(v3, -64);
  }
  /**
   *  Return a new ``int72`` type for %%v%%.
   */
  static int72(v3) {
    return n(v3, -72);
  }
  /**
   *  Return a new ``int80`` type for %%v%%.
   */
  static int80(v3) {
    return n(v3, -80);
  }
  /**
   *  Return a new ``int88`` type for %%v%%.
   */
  static int88(v3) {
    return n(v3, -88);
  }
  /**
   *  Return a new ``int96`` type for %%v%%.
   */
  static int96(v3) {
    return n(v3, -96);
  }
  /**
   *  Return a new ``int104`` type for %%v%%.
   */
  static int104(v3) {
    return n(v3, -104);
  }
  /**
   *  Return a new ``int112`` type for %%v%%.
   */
  static int112(v3) {
    return n(v3, -112);
  }
  /**
   *  Return a new ``int120`` type for %%v%%.
   */
  static int120(v3) {
    return n(v3, -120);
  }
  /**
   *  Return a new ``int128`` type for %%v%%.
   */
  static int128(v3) {
    return n(v3, -128);
  }
  /**
   *  Return a new ``int136`` type for %%v%%.
   */
  static int136(v3) {
    return n(v3, -136);
  }
  /**
   *  Return a new ``int144`` type for %%v%%.
   */
  static int144(v3) {
    return n(v3, -144);
  }
  /**
   *  Return a new ``int52`` type for %%v%%.
   */
  static int152(v3) {
    return n(v3, -152);
  }
  /**
   *  Return a new ``int160`` type for %%v%%.
   */
  static int160(v3) {
    return n(v3, -160);
  }
  /**
   *  Return a new ``int168`` type for %%v%%.
   */
  static int168(v3) {
    return n(v3, -168);
  }
  /**
   *  Return a new ``int176`` type for %%v%%.
   */
  static int176(v3) {
    return n(v3, -176);
  }
  /**
   *  Return a new ``int184`` type for %%v%%.
   */
  static int184(v3) {
    return n(v3, -184);
  }
  /**
   *  Return a new ``int92`` type for %%v%%.
   */
  static int192(v3) {
    return n(v3, -192);
  }
  /**
   *  Return a new ``int200`` type for %%v%%.
   */
  static int200(v3) {
    return n(v3, -200);
  }
  /**
   *  Return a new ``int208`` type for %%v%%.
   */
  static int208(v3) {
    return n(v3, -208);
  }
  /**
   *  Return a new ``int216`` type for %%v%%.
   */
  static int216(v3) {
    return n(v3, -216);
  }
  /**
   *  Return a new ``int224`` type for %%v%%.
   */
  static int224(v3) {
    return n(v3, -224);
  }
  /**
   *  Return a new ``int232`` type for %%v%%.
   */
  static int232(v3) {
    return n(v3, -232);
  }
  /**
   *  Return a new ``int240`` type for %%v%%.
   */
  static int240(v3) {
    return n(v3, -240);
  }
  /**
   *  Return a new ``int248`` type for %%v%%.
   */
  static int248(v3) {
    return n(v3, -248);
  }
  /**
   *  Return a new ``int256`` type for %%v%%.
   */
  static int256(v3) {
    return n(v3, -256);
  }
  /**
   *  Return a new ``int256`` type for %%v%%.
   */
  static int(v3) {
    return n(v3, -256);
  }
  /**
   *  Return a new ``bytes1`` type for %%v%%.
   */
  static bytes1(v3) {
    return b$4(v3, 1);
  }
  /**
   *  Return a new ``bytes2`` type for %%v%%.
   */
  static bytes2(v3) {
    return b$4(v3, 2);
  }
  /**
   *  Return a new ``bytes3`` type for %%v%%.
   */
  static bytes3(v3) {
    return b$4(v3, 3);
  }
  /**
   *  Return a new ``bytes4`` type for %%v%%.
   */
  static bytes4(v3) {
    return b$4(v3, 4);
  }
  /**
   *  Return a new ``bytes5`` type for %%v%%.
   */
  static bytes5(v3) {
    return b$4(v3, 5);
  }
  /**
   *  Return a new ``bytes6`` type for %%v%%.
   */
  static bytes6(v3) {
    return b$4(v3, 6);
  }
  /**
   *  Return a new ``bytes7`` type for %%v%%.
   */
  static bytes7(v3) {
    return b$4(v3, 7);
  }
  /**
   *  Return a new ``bytes8`` type for %%v%%.
   */
  static bytes8(v3) {
    return b$4(v3, 8);
  }
  /**
   *  Return a new ``bytes9`` type for %%v%%.
   */
  static bytes9(v3) {
    return b$4(v3, 9);
  }
  /**
   *  Return a new ``bytes10`` type for %%v%%.
   */
  static bytes10(v3) {
    return b$4(v3, 10);
  }
  /**
   *  Return a new ``bytes11`` type for %%v%%.
   */
  static bytes11(v3) {
    return b$4(v3, 11);
  }
  /**
   *  Return a new ``bytes12`` type for %%v%%.
   */
  static bytes12(v3) {
    return b$4(v3, 12);
  }
  /**
   *  Return a new ``bytes13`` type for %%v%%.
   */
  static bytes13(v3) {
    return b$4(v3, 13);
  }
  /**
   *  Return a new ``bytes14`` type for %%v%%.
   */
  static bytes14(v3) {
    return b$4(v3, 14);
  }
  /**
   *  Return a new ``bytes15`` type for %%v%%.
   */
  static bytes15(v3) {
    return b$4(v3, 15);
  }
  /**
   *  Return a new ``bytes16`` type for %%v%%.
   */
  static bytes16(v3) {
    return b$4(v3, 16);
  }
  /**
   *  Return a new ``bytes17`` type for %%v%%.
   */
  static bytes17(v3) {
    return b$4(v3, 17);
  }
  /**
   *  Return a new ``bytes18`` type for %%v%%.
   */
  static bytes18(v3) {
    return b$4(v3, 18);
  }
  /**
   *  Return a new ``bytes19`` type for %%v%%.
   */
  static bytes19(v3) {
    return b$4(v3, 19);
  }
  /**
   *  Return a new ``bytes20`` type for %%v%%.
   */
  static bytes20(v3) {
    return b$4(v3, 20);
  }
  /**
   *  Return a new ``bytes21`` type for %%v%%.
   */
  static bytes21(v3) {
    return b$4(v3, 21);
  }
  /**
   *  Return a new ``bytes22`` type for %%v%%.
   */
  static bytes22(v3) {
    return b$4(v3, 22);
  }
  /**
   *  Return a new ``bytes23`` type for %%v%%.
   */
  static bytes23(v3) {
    return b$4(v3, 23);
  }
  /**
   *  Return a new ``bytes24`` type for %%v%%.
   */
  static bytes24(v3) {
    return b$4(v3, 24);
  }
  /**
   *  Return a new ``bytes25`` type for %%v%%.
   */
  static bytes25(v3) {
    return b$4(v3, 25);
  }
  /**
   *  Return a new ``bytes26`` type for %%v%%.
   */
  static bytes26(v3) {
    return b$4(v3, 26);
  }
  /**
   *  Return a new ``bytes27`` type for %%v%%.
   */
  static bytes27(v3) {
    return b$4(v3, 27);
  }
  /**
   *  Return a new ``bytes28`` type for %%v%%.
   */
  static bytes28(v3) {
    return b$4(v3, 28);
  }
  /**
   *  Return a new ``bytes29`` type for %%v%%.
   */
  static bytes29(v3) {
    return b$4(v3, 29);
  }
  /**
   *  Return a new ``bytes30`` type for %%v%%.
   */
  static bytes30(v3) {
    return b$4(v3, 30);
  }
  /**
   *  Return a new ``bytes31`` type for %%v%%.
   */
  static bytes31(v3) {
    return b$4(v3, 31);
  }
  /**
   *  Return a new ``bytes32`` type for %%v%%.
   */
  static bytes32(v3) {
    return b$4(v3, 32);
  }
  /**
   *  Return a new ``address`` type for %%v%%.
   */
  static address(v3) {
    return new _Typed(_gaurd, "address", v3);
  }
  /**
   *  Return a new ``bool`` type for %%v%%.
   */
  static bool(v3) {
    return new _Typed(_gaurd, "bool", !!v3);
  }
  /**
   *  Return a new ``bytes`` type for %%v%%.
   */
  static bytes(v3) {
    return new _Typed(_gaurd, "bytes", v3);
  }
  /**
   *  Return a new ``string`` type for %%v%%.
   */
  static string(v3) {
    return new _Typed(_gaurd, "string", v3);
  }
  /**
   *  Return a new ``array`` type for %%v%%, allowing %%dynamic%% length.
   */
  static array(v3, dynamic) {
    throw new Error("not implemented yet");
  }
  /**
   *  Return a new ``tuple`` type for %%v%%, with the optional %%name%%.
   */
  static tuple(v3, name) {
    throw new Error("not implemented yet");
  }
  /**
   *  Return a new ``uint8`` type for %%v%%.
   */
  static overrides(v3) {
    return new _Typed(_gaurd, "overrides", Object.assign({}, v3));
  }
  /**
   *  Returns true only if %%value%% is a [[Typed]] instance.
   */
  static isTyped(value) {
    return value && typeof value === "object" && "_typedSymbol" in value && value._typedSymbol === _typedSymbol;
  }
  /**
   *  If the value is a [[Typed]] instance, validates the underlying value
   *  and returns it, otherwise returns value directly.
   *
   *  This is useful for functions that with to accept either a [[Typed]]
   *  object or values.
   */
  static dereference(value, type) {
    if (_Typed.isTyped(value)) {
      if (value.type !== type) {
        throw new Error(`invalid type: expecetd ${type}, got ${value.type}`);
      }
      return value.value;
    }
    return value;
  }
};
_options = new WeakMap();
let Typed = _Typed;
class AddressCoder extends Coder {
  constructor(localName) {
    super("address", "address", localName, false);
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000";
  }
  encode(writer, _value2) {
    let value = Typed.dereference(_value2, "string");
    try {
      value = getAddress(value);
    } catch (error) {
      return this._throwError(error.message, _value2);
    }
    return writer.writeValue(value);
  }
  decode(reader) {
    return getAddress(toBeHex(reader.readValue(), 20));
  }
}
class AnonymousCoder extends Coder {
  constructor(coder) {
    super(coder.name, coder.type, "_", coder.dynamic);
    __publicField(this, "coder");
    this.coder = coder;
  }
  defaultValue() {
    return this.coder.defaultValue();
  }
  encode(writer, value) {
    return this.coder.encode(writer, value);
  }
  decode(reader) {
    return this.coder.decode(reader);
  }
}
function pack(writer, coders, values) {
  let arrayValues = [];
  if (Array.isArray(values)) {
    arrayValues = values;
  } else if (values && typeof values === "object") {
    let unique = {};
    arrayValues = coders.map((coder) => {
      const name = coder.localName;
      assert(name, "cannot encode object for signature with missing names", "INVALID_ARGUMENT", { argument: "values", info: { coder }, value: values });
      assert(!unique[name], "cannot encode object for signature with duplicate names", "INVALID_ARGUMENT", { argument: "values", info: { coder }, value: values });
      unique[name] = true;
      return values[name];
    });
  } else {
    assertArgument(false, "invalid tuple value", "tuple", values);
  }
  assertArgument(coders.length === arrayValues.length, "types/value length mismatch", "tuple", values);
  let staticWriter = new Writer();
  let dynamicWriter = new Writer();
  let updateFuncs = [];
  coders.forEach((coder, index) => {
    let value = arrayValues[index];
    if (coder.dynamic) {
      let dynamicOffset = dynamicWriter.length;
      coder.encode(dynamicWriter, value);
      let updateFunc = staticWriter.writeUpdatableValue();
      updateFuncs.push((baseOffset) => {
        updateFunc(baseOffset + dynamicOffset);
      });
    } else {
      coder.encode(staticWriter, value);
    }
  });
  updateFuncs.forEach((func) => {
    func(staticWriter.length);
  });
  let length = writer.appendWriter(staticWriter);
  length += writer.appendWriter(dynamicWriter);
  return length;
}
function unpack(reader, coders) {
  let values = [];
  let keys = [];
  let baseReader = reader.subReader(0);
  coders.forEach((coder) => {
    let value = null;
    if (coder.dynamic) {
      let offset = reader.readIndex();
      let offsetReader = baseReader.subReader(offset);
      try {
        value = coder.decode(offsetReader);
      } catch (error) {
        if (isError(error, "BUFFER_OVERRUN")) {
          throw error;
        }
        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    } else {
      try {
        value = coder.decode(reader);
      } catch (error) {
        if (isError(error, "BUFFER_OVERRUN")) {
          throw error;
        }
        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    }
    if (value == void 0) {
      throw new Error("investigate");
    }
    values.push(value);
    keys.push(coder.localName || null);
  });
  return Result.fromItems(values, keys);
}
class ArrayCoder extends Coder {
  constructor(coder, length, localName) {
    const type = coder.type + "[" + (length >= 0 ? length : "") + "]";
    const dynamic = length === -1 || coder.dynamic;
    super("array", type, localName, dynamic);
    __publicField(this, "coder");
    __publicField(this, "length");
    defineProperties(this, { coder, length });
  }
  defaultValue() {
    const defaultChild = this.coder.defaultValue();
    const result = [];
    for (let i = 0; i < this.length; i++) {
      result.push(defaultChild);
    }
    return result;
  }
  encode(writer, _value2) {
    const value = Typed.dereference(_value2, "array");
    if (!Array.isArray(value)) {
      this._throwError("expected array value", value);
    }
    let count = this.length;
    if (count === -1) {
      count = value.length;
      writer.writeValue(value.length);
    }
    assertArgumentCount(value.length, count, "coder array" + (this.localName ? " " + this.localName : ""));
    let coders = [];
    for (let i = 0; i < value.length; i++) {
      coders.push(this.coder);
    }
    return pack(writer, coders, value);
  }
  decode(reader) {
    let count = this.length;
    if (count === -1) {
      count = reader.readIndex();
      assert(count * WordSize <= reader.dataLength, "insufficient data length", "BUFFER_OVERRUN", { buffer: reader.bytes, offset: count * WordSize, length: reader.dataLength });
    }
    let coders = [];
    for (let i = 0; i < count; i++) {
      coders.push(new AnonymousCoder(this.coder));
    }
    return unpack(reader, coders);
  }
}
class BooleanCoder extends Coder {
  constructor(localName) {
    super("bool", "bool", localName, false);
  }
  defaultValue() {
    return false;
  }
  encode(writer, _value2) {
    const value = Typed.dereference(_value2, "bool");
    return writer.writeValue(value ? 1 : 0);
  }
  decode(reader) {
    return !!reader.readValue();
  }
}
class DynamicBytesCoder extends Coder {
  constructor(type, localName) {
    super(type, type, localName, true);
  }
  defaultValue() {
    return "0x";
  }
  encode(writer, value) {
    value = getBytesCopy(value);
    let length = writer.writeValue(value.length);
    length += writer.writeBytes(value);
    return length;
  }
  decode(reader) {
    return reader.readBytes(reader.readIndex(), true);
  }
}
class BytesCoder extends DynamicBytesCoder {
  constructor(localName) {
    super("bytes", localName);
  }
  decode(reader) {
    return hexlify(super.decode(reader));
  }
}
class FixedBytesCoder extends Coder {
  constructor(size, localName) {
    let name = "bytes" + String(size);
    super(name, name, localName, false);
    __publicField(this, "size");
    defineProperties(this, { size }, { size: "number" });
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
  }
  encode(writer, _value2) {
    let data = getBytesCopy(Typed.dereference(_value2, this.type));
    if (data.length !== this.size) {
      this._throwError("incorrect data length", _value2);
    }
    return writer.writeBytes(data);
  }
  decode(reader) {
    return hexlify(reader.readBytes(this.size));
  }
}
const Empty = new Uint8Array([]);
class NullCoder extends Coder {
  constructor(localName) {
    super("null", "", localName, false);
  }
  defaultValue() {
    return null;
  }
  encode(writer, value) {
    if (value != null) {
      this._throwError("not null", value);
    }
    return writer.writeBytes(Empty);
  }
  decode(reader) {
    reader.readBytes(0);
    return null;
  }
}
const BN_0$5 = BigInt(0);
const BN_1$1 = BigInt(1);
const BN_MAX_UINT256$1 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
class NumberCoder extends Coder {
  constructor(size, signed, localName) {
    const name = (signed ? "int" : "uint") + size * 8;
    super(name, name, localName, false);
    __publicField(this, "size");
    __publicField(this, "signed");
    defineProperties(this, { size, signed }, { size: "number", signed: "boolean" });
  }
  defaultValue() {
    return 0;
  }
  encode(writer, _value2) {
    let value = getBigInt(Typed.dereference(_value2, this.type));
    let maxUintValue = mask(BN_MAX_UINT256$1, WordSize * 8);
    if (this.signed) {
      let bounds = mask(maxUintValue, this.size * 8 - 1);
      if (value > bounds || value < -(bounds + BN_1$1)) {
        this._throwError("value out-of-bounds", _value2);
      }
      value = toTwos(value, 8 * WordSize);
    } else if (value < BN_0$5 || value > mask(maxUintValue, this.size * 8)) {
      this._throwError("value out-of-bounds", _value2);
    }
    return writer.writeValue(value);
  }
  decode(reader) {
    let value = mask(reader.readValue(), this.size * 8);
    if (this.signed) {
      value = fromTwos(value, this.size * 8);
    }
    return value;
  }
}
class StringCoder extends DynamicBytesCoder {
  constructor(localName) {
    super("string", localName);
  }
  defaultValue() {
    return "";
  }
  encode(writer, _value2) {
    return super.encode(writer, toUtf8Bytes(Typed.dereference(_value2, "string")));
  }
  decode(reader) {
    return toUtf8String(super.decode(reader));
  }
}
class TupleCoder extends Coder {
  constructor(coders, localName) {
    let dynamic = false;
    const types = [];
    coders.forEach((coder) => {
      if (coder.dynamic) {
        dynamic = true;
      }
      types.push(coder.type);
    });
    const type = "tuple(" + types.join(",") + ")";
    super("tuple", type, localName, dynamic);
    __publicField(this, "coders");
    defineProperties(this, { coders: Object.freeze(coders.slice()) });
  }
  defaultValue() {
    const values = [];
    this.coders.forEach((coder) => {
      values.push(coder.defaultValue());
    });
    const uniqueNames = this.coders.reduce((accum, coder) => {
      const name = coder.localName;
      if (name) {
        if (!accum[name]) {
          accum[name] = 0;
        }
        accum[name]++;
      }
      return accum;
    }, {});
    this.coders.forEach((coder, index) => {
      let name = coder.localName;
      if (!name || uniqueNames[name] !== 1) {
        return;
      }
      if (name === "length") {
        name = "_length";
      }
      if (values[name] != null) {
        return;
      }
      values[name] = values[index];
    });
    return Object.freeze(values);
  }
  encode(writer, _value2) {
    const value = Typed.dereference(_value2, "tuple");
    return pack(writer, this.coders, value);
  }
  decode(reader) {
    return unpack(reader, this.coders);
  }
}
function id(value) {
  return keccak256(toUtf8Bytes(value));
}
const Zeros = new Uint8Array(32);
Zeros.fill(0);
function checkComponent(comp) {
  assertArgument(comp.length !== 0, "invalid ENS name; empty component", "comp", comp);
  return comp;
}
function ensNameSplit(name) {
  const bytes = toUtf8Bytes(ensNormalize(name));
  const comps = [];
  if (name.length === 0) {
    return comps;
  }
  let last = 0;
  for (let i = 0; i < bytes.length; i++) {
    const d2 = bytes[i];
    if (d2 === 46) {
      comps.push(checkComponent(bytes.slice(last, i)));
      last = i + 1;
    }
  }
  assertArgument(last < bytes.length, "invalid ENS name; empty component", "name", name);
  comps.push(checkComponent(bytes.slice(last)));
  return comps;
}
function ensNormalize(name) {
  try {
    if (name.length === 0) {
      throw new Error("empty label");
    }
    return ens_normalize(name);
  } catch (error) {
    assertArgument(false, `invalid ENS name (${error.message})`, "name", name);
  }
}
function namehash(name) {
  assertArgument(typeof name === "string", "invalid ENS name; not a string", "name", name);
  assertArgument(name.length, `invalid ENS name (empty label)`, "name", name);
  let result = Zeros;
  const comps = ensNameSplit(name);
  while (comps.length) {
    result = keccak256(concat([result, keccak256(comps.pop())]));
  }
  return hexlify(result);
}
function dnsEncode(name, _maxLength) {
  const length = _maxLength;
  assertArgument(length <= 255, "DNS encoded label cannot exceed 255", "length", length);
  return hexlify(concat(ensNameSplit(name).map((comp) => {
    assertArgument(comp.length <= length, `label ${JSON.stringify(name)} exceeds ${length} bytes`, "name", name);
    const bytes = new Uint8Array(comp.length + 1);
    bytes.set(comp, 1);
    bytes[0] = bytes.length - 1;
    return bytes;
  }))) + "00";
}
function accessSetify(addr, storageKeys) {
  return {
    address: getAddress(addr),
    storageKeys: storageKeys.map((storageKey, index) => {
      assertArgument(isHexString(storageKey, 32), "invalid slot", `storageKeys[${index}]`, storageKey);
      return storageKey.toLowerCase();
    })
  };
}
function accessListify(value) {
  if (Array.isArray(value)) {
    return value.map((set2, index) => {
      if (Array.isArray(set2)) {
        assertArgument(set2.length === 2, "invalid slot set", `value[${index}]`, set2);
        return accessSetify(set2[0], set2[1]);
      }
      assertArgument(set2 != null && typeof set2 === "object", "invalid address-slot set", "value", value);
      return accessSetify(set2.address, set2.storageKeys);
    });
  }
  assertArgument(value != null && typeof value === "object", "invalid access list", "value", value);
  const result = Object.keys(value).map((addr) => {
    const storageKeys = value[addr].reduce((accum, storageKey) => {
      accum[storageKey] = true;
      return accum;
    }, {});
    return accessSetify(addr, Object.keys(storageKeys).sort());
  });
  result.sort((a2, b2) => a2.address.localeCompare(b2.address));
  return result;
}
function computeAddress(key) {
  let pubkey;
  if (typeof key === "string") {
    pubkey = SigningKey.computePublicKey(key, false);
  } else {
    pubkey = key.publicKey;
  }
  return getAddress(keccak256("0x" + pubkey.substring(4)).substring(26));
}
function recoverAddress(digest, signature) {
  return computeAddress(SigningKey.recoverPublicKey(digest, signature));
}
const BN_0$4 = BigInt(0);
const BN_2$1 = BigInt(2);
const BN_27 = BigInt(27);
const BN_28 = BigInt(28);
const BN_35 = BigInt(35);
const BN_MAX_UINT = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
const BLOB_SIZE = 4096 * 32;
function getVersionedHash(version2, hash) {
  let versioned = version2.toString(16);
  while (versioned.length < 2) {
    versioned = "0" + versioned;
  }
  versioned += sha256(hash).substring(4);
  return "0x" + versioned;
}
function handleAddress(value) {
  if (value === "0x") {
    return null;
  }
  return getAddress(value);
}
function handleAccessList(value, param) {
  try {
    return accessListify(value);
  } catch (error) {
    assertArgument(false, error.message, param, value);
  }
}
function handleNumber(_value2, param) {
  if (_value2 === "0x") {
    return 0;
  }
  return getNumber(_value2, param);
}
function handleUint(_value2, param) {
  if (_value2 === "0x") {
    return BN_0$4;
  }
  const value = getBigInt(_value2, param);
  assertArgument(value <= BN_MAX_UINT, "value exceeds uint size", param, value);
  return value;
}
function formatNumber$1(_value2, name) {
  const value = getBigInt(_value2, "value");
  const result = toBeArray(value);
  assertArgument(result.length <= 32, `value too large`, `tx.${name}`, value);
  return result;
}
function formatAccessList(value) {
  return accessListify(value).map((set2) => [set2.address, set2.storageKeys]);
}
function formatHashes(value, param) {
  assertArgument(Array.isArray(value), `invalid ${param}`, "value", value);
  for (let i = 0; i < value.length; i++) {
    assertArgument(isHexString(value[i], 32), "invalid ${ param } hash", `value[${i}]`, value[i]);
  }
  return value;
}
function _parseLegacy(data) {
  const fields = decodeRlp(data);
  assertArgument(Array.isArray(fields) && (fields.length === 9 || fields.length === 6), "invalid field count for legacy transaction", "data", data);
  const tx = {
    type: 0,
    nonce: handleNumber(fields[0], "nonce"),
    gasPrice: handleUint(fields[1], "gasPrice"),
    gasLimit: handleUint(fields[2], "gasLimit"),
    to: handleAddress(fields[3]),
    value: handleUint(fields[4], "value"),
    data: hexlify(fields[5]),
    chainId: BN_0$4
  };
  if (fields.length === 6) {
    return tx;
  }
  const v3 = handleUint(fields[6], "v");
  const r3 = handleUint(fields[7], "r");
  const s2 = handleUint(fields[8], "s");
  if (r3 === BN_0$4 && s2 === BN_0$4) {
    tx.chainId = v3;
  } else {
    let chainId = (v3 - BN_35) / BN_2$1;
    if (chainId < BN_0$4) {
      chainId = BN_0$4;
    }
    tx.chainId = chainId;
    assertArgument(chainId !== BN_0$4 || (v3 === BN_27 || v3 === BN_28), "non-canonical legacy v", "v", fields[6]);
    tx.signature = Signature.from({
      r: zeroPadValue(fields[7], 32),
      s: zeroPadValue(fields[8], 32),
      v: v3
    });
  }
  return tx;
}
function _serializeLegacy(tx, sig) {
  const fields = [
    formatNumber$1(tx.nonce, "nonce"),
    formatNumber$1(tx.gasPrice || 0, "gasPrice"),
    formatNumber$1(tx.gasLimit, "gasLimit"),
    tx.to || "0x",
    formatNumber$1(tx.value, "value"),
    tx.data
  ];
  let chainId = BN_0$4;
  if (tx.chainId != BN_0$4) {
    chainId = getBigInt(tx.chainId, "tx.chainId");
    assertArgument(!sig || sig.networkV == null || sig.legacyChainId === chainId, "tx.chainId/sig.v mismatch", "sig", sig);
  } else if (tx.signature) {
    const legacy = tx.signature.legacyChainId;
    if (legacy != null) {
      chainId = legacy;
    }
  }
  if (!sig) {
    if (chainId !== BN_0$4) {
      fields.push(toBeArray(chainId));
      fields.push("0x");
      fields.push("0x");
    }
    return encodeRlp(fields);
  }
  let v3 = BigInt(27 + sig.yParity);
  if (chainId !== BN_0$4) {
    v3 = Signature.getChainIdV(chainId, sig.v);
  } else if (BigInt(sig.v) !== v3) {
    assertArgument(false, "tx.chainId/sig.v mismatch", "sig", sig);
  }
  fields.push(toBeArray(v3));
  fields.push(toBeArray(sig.r));
  fields.push(toBeArray(sig.s));
  return encodeRlp(fields);
}
function _parseEipSignature(tx, fields) {
  let yParity;
  try {
    yParity = handleNumber(fields[0], "yParity");
    if (yParity !== 0 && yParity !== 1) {
      throw new Error("bad yParity");
    }
  } catch (error) {
    assertArgument(false, "invalid yParity", "yParity", fields[0]);
  }
  const r3 = zeroPadValue(fields[1], 32);
  const s2 = zeroPadValue(fields[2], 32);
  const signature = Signature.from({ r: r3, s: s2, yParity });
  tx.signature = signature;
}
function _parseEip1559(data) {
  const fields = decodeRlp(getBytes(data).slice(1));
  assertArgument(Array.isArray(fields) && (fields.length === 9 || fields.length === 12), "invalid field count for transaction type: 2", "data", hexlify(data));
  const tx = {
    type: 2,
    chainId: handleUint(fields[0], "chainId"),
    nonce: handleNumber(fields[1], "nonce"),
    maxPriorityFeePerGas: handleUint(fields[2], "maxPriorityFeePerGas"),
    maxFeePerGas: handleUint(fields[3], "maxFeePerGas"),
    gasPrice: null,
    gasLimit: handleUint(fields[4], "gasLimit"),
    to: handleAddress(fields[5]),
    value: handleUint(fields[6], "value"),
    data: hexlify(fields[7]),
    accessList: handleAccessList(fields[8], "accessList")
  };
  if (fields.length === 9) {
    return tx;
  }
  _parseEipSignature(tx, fields.slice(9));
  return tx;
}
function _serializeEip1559(tx, sig) {
  const fields = [
    formatNumber$1(tx.chainId, "chainId"),
    formatNumber$1(tx.nonce, "nonce"),
    formatNumber$1(tx.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    formatNumber$1(tx.maxFeePerGas || 0, "maxFeePerGas"),
    formatNumber$1(tx.gasLimit, "gasLimit"),
    tx.to || "0x",
    formatNumber$1(tx.value, "value"),
    tx.data,
    formatAccessList(tx.accessList || [])
  ];
  if (sig) {
    fields.push(formatNumber$1(sig.yParity, "yParity"));
    fields.push(toBeArray(sig.r));
    fields.push(toBeArray(sig.s));
  }
  return concat(["0x02", encodeRlp(fields)]);
}
function _parseEip2930(data) {
  const fields = decodeRlp(getBytes(data).slice(1));
  assertArgument(Array.isArray(fields) && (fields.length === 8 || fields.length === 11), "invalid field count for transaction type: 1", "data", hexlify(data));
  const tx = {
    type: 1,
    chainId: handleUint(fields[0], "chainId"),
    nonce: handleNumber(fields[1], "nonce"),
    gasPrice: handleUint(fields[2], "gasPrice"),
    gasLimit: handleUint(fields[3], "gasLimit"),
    to: handleAddress(fields[4]),
    value: handleUint(fields[5], "value"),
    data: hexlify(fields[6]),
    accessList: handleAccessList(fields[7], "accessList")
  };
  if (fields.length === 8) {
    return tx;
  }
  _parseEipSignature(tx, fields.slice(8));
  return tx;
}
function _serializeEip2930(tx, sig) {
  const fields = [
    formatNumber$1(tx.chainId, "chainId"),
    formatNumber$1(tx.nonce, "nonce"),
    formatNumber$1(tx.gasPrice || 0, "gasPrice"),
    formatNumber$1(tx.gasLimit, "gasLimit"),
    tx.to || "0x",
    formatNumber$1(tx.value, "value"),
    tx.data,
    formatAccessList(tx.accessList || [])
  ];
  if (sig) {
    fields.push(formatNumber$1(sig.yParity, "recoveryParam"));
    fields.push(toBeArray(sig.r));
    fields.push(toBeArray(sig.s));
  }
  return concat(["0x01", encodeRlp(fields)]);
}
function _parseEip4844(data) {
  let fields = decodeRlp(getBytes(data).slice(1));
  let typeName = "3";
  let blobs = null;
  if (fields.length === 4 && Array.isArray(fields[0])) {
    typeName = "3 (network format)";
    const fBlobs = fields[1], fCommits = fields[2], fProofs = fields[3];
    assertArgument(Array.isArray(fBlobs), "invalid network format: blobs not an array", "fields[1]", fBlobs);
    assertArgument(Array.isArray(fCommits), "invalid network format: commitments not an array", "fields[2]", fCommits);
    assertArgument(Array.isArray(fProofs), "invalid network format: proofs not an array", "fields[3]", fProofs);
    assertArgument(fBlobs.length === fCommits.length, "invalid network format: blobs/commitments length mismatch", "fields", fields);
    assertArgument(fBlobs.length === fProofs.length, "invalid network format: blobs/proofs length mismatch", "fields", fields);
    blobs = [];
    for (let i = 0; i < fields[1].length; i++) {
      blobs.push({
        data: fBlobs[i],
        commitment: fCommits[i],
        proof: fProofs[i]
      });
    }
    fields = fields[0];
  }
  assertArgument(Array.isArray(fields) && (fields.length === 11 || fields.length === 14), `invalid field count for transaction type: ${typeName}`, "data", hexlify(data));
  const tx = {
    type: 3,
    chainId: handleUint(fields[0], "chainId"),
    nonce: handleNumber(fields[1], "nonce"),
    maxPriorityFeePerGas: handleUint(fields[2], "maxPriorityFeePerGas"),
    maxFeePerGas: handleUint(fields[3], "maxFeePerGas"),
    gasPrice: null,
    gasLimit: handleUint(fields[4], "gasLimit"),
    to: handleAddress(fields[5]),
    value: handleUint(fields[6], "value"),
    data: hexlify(fields[7]),
    accessList: handleAccessList(fields[8], "accessList"),
    maxFeePerBlobGas: handleUint(fields[9], "maxFeePerBlobGas"),
    blobVersionedHashes: fields[10]
  };
  if (blobs) {
    tx.blobs = blobs;
  }
  assertArgument(tx.to != null, `invalid address for transaction type: ${typeName}`, "data", data);
  assertArgument(Array.isArray(tx.blobVersionedHashes), "invalid blobVersionedHashes: must be an array", "data", data);
  for (let i = 0; i < tx.blobVersionedHashes.length; i++) {
    assertArgument(isHexString(tx.blobVersionedHashes[i], 32), `invalid blobVersionedHash at index ${i}: must be length 32`, "data", data);
  }
  if (fields.length === 11) {
    return tx;
  }
  _parseEipSignature(tx, fields.slice(11));
  return tx;
}
function _serializeEip4844(tx, sig, blobs) {
  const fields = [
    formatNumber$1(tx.chainId, "chainId"),
    formatNumber$1(tx.nonce, "nonce"),
    formatNumber$1(tx.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    formatNumber$1(tx.maxFeePerGas || 0, "maxFeePerGas"),
    formatNumber$1(tx.gasLimit, "gasLimit"),
    tx.to || ZeroAddress,
    formatNumber$1(tx.value, "value"),
    tx.data,
    formatAccessList(tx.accessList || []),
    formatNumber$1(tx.maxFeePerBlobGas || 0, "maxFeePerBlobGas"),
    formatHashes(tx.blobVersionedHashes || [], "blobVersionedHashes")
  ];
  if (sig) {
    fields.push(formatNumber$1(sig.yParity, "yParity"));
    fields.push(toBeArray(sig.r));
    fields.push(toBeArray(sig.s));
    if (blobs) {
      return concat([
        "0x03",
        encodeRlp([
          fields,
          blobs.map((b2) => b2.data),
          blobs.map((b2) => b2.commitment),
          blobs.map((b2) => b2.proof)
        ])
      ]);
    }
  }
  return concat(["0x03", encodeRlp(fields)]);
}
const _Transaction = class _Transaction {
  /**
   *  Creates a new Transaction with default values.
   */
  constructor() {
    __privateAdd(this, _Transaction_instances);
    __privateAdd(this, _type);
    __privateAdd(this, _to);
    __privateAdd(this, _data3);
    __privateAdd(this, _nonce);
    __privateAdd(this, _gasLimit);
    __privateAdd(this, _gasPrice);
    __privateAdd(this, _maxPriorityFeePerGas);
    __privateAdd(this, _maxFeePerGas);
    __privateAdd(this, _value);
    __privateAdd(this, _chainId);
    __privateAdd(this, _sig);
    __privateAdd(this, _accessList);
    __privateAdd(this, _maxFeePerBlobGas);
    __privateAdd(this, _blobVersionedHashes);
    __privateAdd(this, _kzg);
    __privateAdd(this, _blobs);
    __privateSet(this, _type, null);
    __privateSet(this, _to, null);
    __privateSet(this, _nonce, 0);
    __privateSet(this, _gasLimit, BN_0$4);
    __privateSet(this, _gasPrice, null);
    __privateSet(this, _maxPriorityFeePerGas, null);
    __privateSet(this, _maxFeePerGas, null);
    __privateSet(this, _data3, "0x");
    __privateSet(this, _value, BN_0$4);
    __privateSet(this, _chainId, BN_0$4);
    __privateSet(this, _sig, null);
    __privateSet(this, _accessList, null);
    __privateSet(this, _maxFeePerBlobGas, null);
    __privateSet(this, _blobVersionedHashes, null);
    __privateSet(this, _blobs, null);
    __privateSet(this, _kzg, null);
  }
  /**
   *  The transaction type.
   *
   *  If null, the type will be automatically inferred based on
   *  explicit properties.
   */
  get type() {
    return __privateGet(this, _type);
  }
  set type(value) {
    switch (value) {
      case null:
        __privateSet(this, _type, null);
        break;
      case 0:
      case "legacy":
        __privateSet(this, _type, 0);
        break;
      case 1:
      case "berlin":
      case "eip-2930":
        __privateSet(this, _type, 1);
        break;
      case 2:
      case "london":
      case "eip-1559":
        __privateSet(this, _type, 2);
        break;
      case 3:
      case "cancun":
      case "eip-4844":
        __privateSet(this, _type, 3);
        break;
      default:
        assertArgument(false, "unsupported transaction type", "type", value);
    }
  }
  /**
   *  The name of the transaction type.
   */
  get typeName() {
    switch (this.type) {
      case 0:
        return "legacy";
      case 1:
        return "eip-2930";
      case 2:
        return "eip-1559";
      case 3:
        return "eip-4844";
    }
    return null;
  }
  /**
   *  The ``to`` address for the transaction or ``null`` if the
   *  transaction is an ``init`` transaction.
   */
  get to() {
    const value = __privateGet(this, _to);
    if (value == null && this.type === 3) {
      return ZeroAddress;
    }
    return value;
  }
  set to(value) {
    __privateSet(this, _to, value == null ? null : getAddress(value));
  }
  /**
   *  The transaction nonce.
   */
  get nonce() {
    return __privateGet(this, _nonce);
  }
  set nonce(value) {
    __privateSet(this, _nonce, getNumber(value, "value"));
  }
  /**
   *  The gas limit.
   */
  get gasLimit() {
    return __privateGet(this, _gasLimit);
  }
  set gasLimit(value) {
    __privateSet(this, _gasLimit, getBigInt(value));
  }
  /**
   *  The gas price.
   *
   *  On legacy networks this defines the fee that will be paid. On
   *  EIP-1559 networks, this should be ``null``.
   */
  get gasPrice() {
    const value = __privateGet(this, _gasPrice);
    if (value == null && (this.type === 0 || this.type === 1)) {
      return BN_0$4;
    }
    return value;
  }
  set gasPrice(value) {
    __privateSet(this, _gasPrice, value == null ? null : getBigInt(value, "gasPrice"));
  }
  /**
   *  The maximum priority fee per unit of gas to pay. On legacy
   *  networks this should be ``null``.
   */
  get maxPriorityFeePerGas() {
    const value = __privateGet(this, _maxPriorityFeePerGas);
    if (value == null) {
      if (this.type === 2 || this.type === 3) {
        return BN_0$4;
      }
      return null;
    }
    return value;
  }
  set maxPriorityFeePerGas(value) {
    __privateSet(this, _maxPriorityFeePerGas, value == null ? null : getBigInt(value, "maxPriorityFeePerGas"));
  }
  /**
   *  The maximum total fee per unit of gas to pay. On legacy
   *  networks this should be ``null``.
   */
  get maxFeePerGas() {
    const value = __privateGet(this, _maxFeePerGas);
    if (value == null) {
      if (this.type === 2 || this.type === 3) {
        return BN_0$4;
      }
      return null;
    }
    return value;
  }
  set maxFeePerGas(value) {
    __privateSet(this, _maxFeePerGas, value == null ? null : getBigInt(value, "maxFeePerGas"));
  }
  /**
   *  The transaction data. For ``init`` transactions this is the
   *  deployment code.
   */
  get data() {
    return __privateGet(this, _data3);
  }
  set data(value) {
    __privateSet(this, _data3, hexlify(value));
  }
  /**
   *  The amount of ether (in wei) to send in this transactions.
   */
  get value() {
    return __privateGet(this, _value);
  }
  set value(value) {
    __privateSet(this, _value, getBigInt(value, "value"));
  }
  /**
   *  The chain ID this transaction is valid on.
   */
  get chainId() {
    return __privateGet(this, _chainId);
  }
  set chainId(value) {
    __privateSet(this, _chainId, getBigInt(value));
  }
  /**
   *  If signed, the signature for this transaction.
   */
  get signature() {
    return __privateGet(this, _sig) || null;
  }
  set signature(value) {
    __privateSet(this, _sig, value == null ? null : Signature.from(value));
  }
  /**
   *  The access list.
   *
   *  An access list permits discounted (but pre-paid) access to
   *  bytecode and state variable access within contract execution.
   */
  get accessList() {
    const value = __privateGet(this, _accessList) || null;
    if (value == null) {
      if (this.type === 1 || this.type === 2 || this.type === 3) {
        return [];
      }
      return null;
    }
    return value;
  }
  set accessList(value) {
    __privateSet(this, _accessList, value == null ? null : accessListify(value));
  }
  /**
   *  The max fee per blob gas for Cancun transactions.
   */
  get maxFeePerBlobGas() {
    const value = __privateGet(this, _maxFeePerBlobGas);
    if (value == null && this.type === 3) {
      return BN_0$4;
    }
    return value;
  }
  set maxFeePerBlobGas(value) {
    __privateSet(this, _maxFeePerBlobGas, value == null ? null : getBigInt(value, "maxFeePerBlobGas"));
  }
  /**
   *  The BLOb versioned hashes for Cancun transactions.
   */
  get blobVersionedHashes() {
    let value = __privateGet(this, _blobVersionedHashes);
    if (value == null && this.type === 3) {
      return [];
    }
    return value;
  }
  set blobVersionedHashes(value) {
    if (value != null) {
      assertArgument(Array.isArray(value), "blobVersionedHashes must be an Array", "value", value);
      value = value.slice();
      for (let i = 0; i < value.length; i++) {
        assertArgument(isHexString(value[i], 32), "invalid blobVersionedHash", `value[${i}]`, value[i]);
      }
    }
    __privateSet(this, _blobVersionedHashes, value);
  }
  /**
   *  The BLObs for the Transaction, if any.
   *
   *  If ``blobs`` is non-``null``, then the [[seriailized]]
   *  will return the network formatted sidecar, otherwise it
   *  will return the standard [[link-eip-2718]] payload. The
   *  [[unsignedSerialized]] is unaffected regardless.
   *
   *  When setting ``blobs``, either fully valid [[Blob]] objects
   *  may be specified (i.e. correctly padded, with correct
   *  committments and proofs) or a raw [[BytesLike]] may
   *  be provided.
   *
   *  If raw [[BytesLike]] are provided, the [[kzg]] property **must**
   *  be already set. The blob will be correctly padded and the
   *  [[KzgLibrary]] will be used to compute the committment and
   *  proof for the blob.
   *
   *  A BLOb is a sequence of field elements, each of which must
   *  be within the BLS field modulo, so some additional processing
   *  may be required to encode arbitrary data to ensure each 32 byte
   *  field is within the valid range.
   *
   *  Setting this automatically populates [[blobVersionedHashes]],
   *  overwriting any existing values. Setting this to ``null``
   *  does **not** remove the [[blobVersionedHashes]], leaving them
   *  present.
   */
  get blobs() {
    if (__privateGet(this, _blobs) == null) {
      return null;
    }
    return __privateGet(this, _blobs).map((b2) => Object.assign({}, b2));
  }
  set blobs(_blobs2) {
    if (_blobs2 == null) {
      __privateSet(this, _blobs, null);
      return;
    }
    const blobs = [];
    const versionedHashes = [];
    for (let i = 0; i < _blobs2.length; i++) {
      const blob = _blobs2[i];
      if (isBytesLike(blob)) {
        assert(__privateGet(this, _kzg), "adding a raw blob requires a KZG library", "UNSUPPORTED_OPERATION", {
          operation: "set blobs()"
        });
        let data = getBytes(blob);
        assertArgument(data.length <= BLOB_SIZE, "blob is too large", `blobs[${i}]`, blob);
        if (data.length !== BLOB_SIZE) {
          const padded = new Uint8Array(BLOB_SIZE);
          padded.set(data);
          data = padded;
        }
        const commit = __privateGet(this, _kzg).blobToKzgCommitment(data);
        const proof = hexlify(__privateGet(this, _kzg).computeBlobKzgProof(data, commit));
        blobs.push({
          data: hexlify(data),
          commitment: hexlify(commit),
          proof
        });
        versionedHashes.push(getVersionedHash(1, commit));
      } else {
        const commit = hexlify(blob.commitment);
        blobs.push({
          data: hexlify(blob.data),
          commitment: commit,
          proof: hexlify(blob.proof)
        });
        versionedHashes.push(getVersionedHash(1, commit));
      }
    }
    __privateSet(this, _blobs, blobs);
    __privateSet(this, _blobVersionedHashes, versionedHashes);
  }
  get kzg() {
    return __privateGet(this, _kzg);
  }
  set kzg(kzg) {
    __privateSet(this, _kzg, kzg);
  }
  /**
   *  The transaction hash, if signed. Otherwise, ``null``.
   */
  get hash() {
    if (this.signature == null) {
      return null;
    }
    return keccak256(__privateMethod(this, _Transaction_instances, getSerialized_fn).call(this, true, false));
  }
  /**
   *  The pre-image hash of this transaction.
   *
   *  This is the digest that a [[Signer]] must sign to authorize
   *  this transaction.
   */
  get unsignedHash() {
    return keccak256(this.unsignedSerialized);
  }
  /**
   *  The sending address, if signed. Otherwise, ``null``.
   */
  get from() {
    if (this.signature == null) {
      return null;
    }
    return recoverAddress(this.unsignedHash, this.signature);
  }
  /**
   *  The public key of the sender, if signed. Otherwise, ``null``.
   */
  get fromPublicKey() {
    if (this.signature == null) {
      return null;
    }
    return SigningKey.recoverPublicKey(this.unsignedHash, this.signature);
  }
  /**
   *  Returns true if signed.
   *
   *  This provides a Type Guard that properties requiring a signed
   *  transaction are non-null.
   */
  isSigned() {
    return this.signature != null;
  }
  /**
   *  The serialized transaction.
   *
   *  This throws if the transaction is unsigned. For the pre-image,
   *  use [[unsignedSerialized]].
   */
  get serialized() {
    return __privateMethod(this, _Transaction_instances, getSerialized_fn).call(this, true, true);
  }
  /**
   *  The transaction pre-image.
   *
   *  The hash of this is the digest which needs to be signed to
   *  authorize this transaction.
   */
  get unsignedSerialized() {
    return __privateMethod(this, _Transaction_instances, getSerialized_fn).call(this, false, false);
  }
  /**
   *  Return the most "likely" type; currently the highest
   *  supported transaction type.
   */
  inferType() {
    const types = this.inferTypes();
    if (types.indexOf(2) >= 0) {
      return 2;
    }
    return types.pop();
  }
  /**
   *  Validates the explicit properties and returns a list of compatible
   *  transaction types.
   */
  inferTypes() {
    const hasGasPrice = this.gasPrice != null;
    const hasFee = this.maxFeePerGas != null || this.maxPriorityFeePerGas != null;
    const hasAccessList = this.accessList != null;
    const hasBlob = __privateGet(this, _maxFeePerBlobGas) != null || __privateGet(this, _blobVersionedHashes);
    if (this.maxFeePerGas != null && this.maxPriorityFeePerGas != null) {
      assert(this.maxFeePerGas >= this.maxPriorityFeePerGas, "priorityFee cannot be more than maxFee", "BAD_DATA", { value: this });
    }
    assert(!hasFee || this.type !== 0 && this.type !== 1, "transaction type cannot have maxFeePerGas or maxPriorityFeePerGas", "BAD_DATA", { value: this });
    assert(this.type !== 0 || !hasAccessList, "legacy transaction cannot have accessList", "BAD_DATA", { value: this });
    const types = [];
    if (this.type != null) {
      types.push(this.type);
    } else {
      if (hasFee) {
        types.push(2);
      } else if (hasGasPrice) {
        types.push(1);
        if (!hasAccessList) {
          types.push(0);
        }
      } else if (hasAccessList) {
        types.push(1);
        types.push(2);
      } else if (hasBlob && this.to) {
        types.push(3);
      } else {
        types.push(0);
        types.push(1);
        types.push(2);
        types.push(3);
      }
    }
    types.sort();
    return types;
  }
  /**
   *  Returns true if this transaction is a legacy transaction (i.e.
   *  ``type === 0``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isLegacy() {
    return this.type === 0;
  }
  /**
   *  Returns true if this transaction is berlin hardform transaction (i.e.
   *  ``type === 1``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isBerlin() {
    return this.type === 1;
  }
  /**
   *  Returns true if this transaction is london hardform transaction (i.e.
   *  ``type === 2``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isLondon() {
    return this.type === 2;
  }
  /**
   *  Returns true if this transaction is an [[link-eip-4844]] BLOB
   *  transaction.
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isCancun() {
    return this.type === 3;
  }
  /**
   *  Create a copy of this transaciton.
   */
  clone() {
    return _Transaction.from(this);
  }
  /**
   *  Return a JSON-friendly object.
   */
  toJSON() {
    const s2 = (v3) => {
      if (v3 == null) {
        return null;
      }
      return v3.toString();
    };
    return {
      type: this.type,
      to: this.to,
      //            from: this.from,
      data: this.data,
      nonce: this.nonce,
      gasLimit: s2(this.gasLimit),
      gasPrice: s2(this.gasPrice),
      maxPriorityFeePerGas: s2(this.maxPriorityFeePerGas),
      maxFeePerGas: s2(this.maxFeePerGas),
      value: s2(this.value),
      chainId: s2(this.chainId),
      sig: this.signature ? this.signature.toJSON() : null,
      accessList: this.accessList
    };
  }
  /**
   *  Create a **Transaction** from a serialized transaction or a
   *  Transaction-like object.
   */
  static from(tx) {
    if (tx == null) {
      return new _Transaction();
    }
    if (typeof tx === "string") {
      const payload = getBytes(tx);
      if (payload[0] >= 127) {
        return _Transaction.from(_parseLegacy(payload));
      }
      switch (payload[0]) {
        case 1:
          return _Transaction.from(_parseEip2930(payload));
        case 2:
          return _Transaction.from(_parseEip1559(payload));
        case 3:
          return _Transaction.from(_parseEip4844(payload));
      }
      assert(false, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: "from" });
    }
    const result = new _Transaction();
    if (tx.type != null) {
      result.type = tx.type;
    }
    if (tx.to != null) {
      result.to = tx.to;
    }
    if (tx.nonce != null) {
      result.nonce = tx.nonce;
    }
    if (tx.gasLimit != null) {
      result.gasLimit = tx.gasLimit;
    }
    if (tx.gasPrice != null) {
      result.gasPrice = tx.gasPrice;
    }
    if (tx.maxPriorityFeePerGas != null) {
      result.maxPriorityFeePerGas = tx.maxPriorityFeePerGas;
    }
    if (tx.maxFeePerGas != null) {
      result.maxFeePerGas = tx.maxFeePerGas;
    }
    if (tx.maxFeePerBlobGas != null) {
      result.maxFeePerBlobGas = tx.maxFeePerBlobGas;
    }
    if (tx.data != null) {
      result.data = tx.data;
    }
    if (tx.value != null) {
      result.value = tx.value;
    }
    if (tx.chainId != null) {
      result.chainId = tx.chainId;
    }
    if (tx.signature != null) {
      result.signature = Signature.from(tx.signature);
    }
    if (tx.accessList != null) {
      result.accessList = tx.accessList;
    }
    if (tx.blobVersionedHashes != null) {
      result.blobVersionedHashes = tx.blobVersionedHashes;
    }
    if (tx.kzg != null) {
      result.kzg = tx.kzg;
    }
    if (tx.blobs != null) {
      result.blobs = tx.blobs;
    }
    if (tx.hash != null) {
      assertArgument(result.isSigned(), "unsigned transaction cannot define '.hash'", "tx", tx);
      assertArgument(result.hash === tx.hash, "hash mismatch", "tx", tx);
    }
    if (tx.from != null) {
      assertArgument(result.isSigned(), "unsigned transaction cannot define '.from'", "tx", tx);
      assertArgument(result.from.toLowerCase() === (tx.from || "").toLowerCase(), "from mismatch", "tx", tx);
    }
    return result;
  }
};
_type = new WeakMap();
_to = new WeakMap();
_data3 = new WeakMap();
_nonce = new WeakMap();
_gasLimit = new WeakMap();
_gasPrice = new WeakMap();
_maxPriorityFeePerGas = new WeakMap();
_maxFeePerGas = new WeakMap();
_value = new WeakMap();
_chainId = new WeakMap();
_sig = new WeakMap();
_accessList = new WeakMap();
_maxFeePerBlobGas = new WeakMap();
_blobVersionedHashes = new WeakMap();
_kzg = new WeakMap();
_blobs = new WeakMap();
_Transaction_instances = new WeakSet();
getSerialized_fn = function(signed, sidecar) {
  assert(!signed || this.signature != null, "cannot serialize unsigned transaction; maybe you meant .unsignedSerialized", "UNSUPPORTED_OPERATION", { operation: ".serialized" });
  const sig = signed ? this.signature : null;
  switch (this.inferType()) {
    case 0:
      return _serializeLegacy(this, sig);
    case 1:
      return _serializeEip2930(this, sig);
    case 2:
      return _serializeEip1559(this, sig);
    case 3:
      return _serializeEip4844(this, sig, sidecar ? this.blobs : null);
  }
  assert(false, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: ".serialized" });
};
let Transaction = _Transaction;
const regexBytes = new RegExp("^bytes([0-9]+)$");
const regexNumber = new RegExp("^(u?int)([0-9]*)$");
const regexArray = new RegExp("^(.*)\\[([0-9]*)\\]$");
function _pack(type, value, isArray) {
  switch (type) {
    case "address":
      if (isArray) {
        return getBytes(zeroPadValue(value, 32));
      }
      return getBytes(getAddress(value));
    case "string":
      return toUtf8Bytes(value);
    case "bytes":
      return getBytes(value);
    case "bool":
      value = !!value ? "0x01" : "0x00";
      if (isArray) {
        return getBytes(zeroPadValue(value, 32));
      }
      return getBytes(value);
  }
  let match = type.match(regexNumber);
  if (match) {
    let signed = match[1] === "int";
    let size = parseInt(match[2] || "256");
    assertArgument((!match[2] || match[2] === String(size)) && size % 8 === 0 && size !== 0 && size <= 256, "invalid number type", "type", type);
    if (isArray) {
      size = 256;
    }
    if (signed) {
      value = toTwos(value, size);
    }
    return getBytes(zeroPadValue(toBeArray(value), size / 8));
  }
  match = type.match(regexBytes);
  if (match) {
    const size = parseInt(match[1]);
    assertArgument(String(size) === match[1] && size !== 0 && size <= 32, "invalid bytes type", "type", type);
    assertArgument(dataLength(value) === size, `invalid value for ${type}`, "value", value);
    if (isArray) {
      return getBytes(zeroPadBytes(value, 32));
    }
    return value;
  }
  match = type.match(regexArray);
  if (match && Array.isArray(value)) {
    const baseType = match[1];
    const count = parseInt(match[2] || String(value.length));
    assertArgument(count === value.length, `invalid array length for ${type}`, "value", value);
    const result = [];
    value.forEach(function(value2) {
      result.push(_pack(baseType, value2, true));
    });
    return getBytes(concat(result));
  }
  assertArgument(false, "invalid type", "type", type);
}
function solidityPacked(types, values) {
  assertArgument(types.length === values.length, "wrong number of values; expected ${ types.length }", "values", values);
  const tight = [];
  types.forEach(function(type, index) {
    tight.push(_pack(type, values[index]));
  });
  return hexlify(concat(tight));
}
function solidityPackedKeccak256(types, values) {
  return keccak256(solidityPacked(types, values));
}
const padding = new Uint8Array(32);
padding.fill(0);
const BN__1 = BigInt(-1);
const BN_0$3 = BigInt(0);
const BN_1 = BigInt(1);
const BN_MAX_UINT256 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function hexPadRight(value) {
  const bytes = getBytes(value);
  const padOffset = bytes.length % 32;
  if (padOffset) {
    return concat([bytes, padding.slice(padOffset)]);
  }
  return hexlify(bytes);
}
const hexTrue = toBeHex(BN_1, 32);
const hexFalse = toBeHex(BN_0$3, 32);
const domainFieldTypes = {
  name: "string",
  version: "string",
  chainId: "uint256",
  verifyingContract: "address",
  salt: "bytes32"
};
const domainFieldNames = [
  "name",
  "version",
  "chainId",
  "verifyingContract",
  "salt"
];
function checkString(key) {
  return function(value) {
    assertArgument(typeof value === "string", `invalid domain value for ${JSON.stringify(key)}`, `domain.${key}`, value);
    return value;
  };
}
const domainChecks = {
  name: checkString("name"),
  version: checkString("version"),
  chainId: function(_value2) {
    const value = getBigInt(_value2, "domain.chainId");
    assertArgument(value >= 0, "invalid chain ID", "domain.chainId", _value2);
    if (Number.isSafeInteger(value)) {
      return Number(value);
    }
    return toQuantity(value);
  },
  verifyingContract: function(value) {
    try {
      return getAddress(value).toLowerCase();
    } catch (error) {
    }
    assertArgument(false, `invalid domain value "verifyingContract"`, "domain.verifyingContract", value);
  },
  salt: function(value) {
    const bytes = getBytes(value, "domain.salt");
    assertArgument(bytes.length === 32, `invalid domain value "salt"`, "domain.salt", value);
    return hexlify(bytes);
  }
};
function getBaseEncoder(type) {
  {
    const match = type.match(/^(u?)int(\d+)$/);
    if (match) {
      const signed = match[1] === "";
      const width = parseInt(match[2]);
      assertArgument(width % 8 === 0 && width !== 0 && width <= 256 && match[2] === String(width), "invalid numeric width", "type", type);
      const boundsUpper = mask(BN_MAX_UINT256, signed ? width - 1 : width);
      const boundsLower = signed ? (boundsUpper + BN_1) * BN__1 : BN_0$3;
      return function(_value2) {
        const value = getBigInt(_value2, "value");
        assertArgument(value >= boundsLower && value <= boundsUpper, `value out-of-bounds for ${type}`, "value", value);
        return toBeHex(signed ? toTwos(value, 256) : value, 32);
      };
    }
  }
  {
    const match = type.match(/^bytes(\d+)$/);
    if (match) {
      const width = parseInt(match[1]);
      assertArgument(width !== 0 && width <= 32 && match[1] === String(width), "invalid bytes width", "type", type);
      return function(value) {
        const bytes = getBytes(value);
        assertArgument(bytes.length === width, `invalid length for ${type}`, "value", value);
        return hexPadRight(value);
      };
    }
  }
  switch (type) {
    case "address":
      return function(value) {
        return zeroPadValue(getAddress(value), 32);
      };
    case "bool":
      return function(value) {
        return !value ? hexFalse : hexTrue;
      };
    case "bytes":
      return function(value) {
        return keccak256(value);
      };
    case "string":
      return function(value) {
        return id(value);
      };
  }
  return null;
}
function encodeType(name, fields) {
  return `${name}(${fields.map(({ name: name2, type }) => type + " " + name2).join(",")})`;
}
function splitArray(type) {
  const match = type.match(/^([^\x5b]*)((\x5b\d*\x5d)*)(\x5b(\d*)\x5d)$/);
  if (match) {
    return {
      base: match[1],
      index: match[2] + match[4],
      array: {
        base: match[1],
        prefix: match[1] + match[2],
        count: match[5] ? parseInt(match[5]) : -1
      }
    };
  }
  return { base: type };
}
const _TypedDataEncoder = class _TypedDataEncoder {
  /**
   *  Create a new **TypedDataEncoder** for %%types%%.
   *
   *  This performs all necessary checking that types are valid and
   *  do not violate the [[link-eip-712]] structural constraints as
   *  well as computes the [[primaryType]].
   */
  constructor(_types2) {
    __privateAdd(this, _TypedDataEncoder_instances);
    /**
     *  The primary type for the structured [[types]].
     *
     *  This is derived automatically from the [[types]], since no
     *  recursion is possible, once the DAG for the types is consturcted
     *  internally, the primary type must be the only remaining type with
     *  no parent nodes.
     */
    __publicField(this, "primaryType");
    __privateAdd(this, _types);
    __privateAdd(this, _fullTypes);
    __privateAdd(this, _encoderCache);
    __privateSet(this, _fullTypes, /* @__PURE__ */ new Map());
    __privateSet(this, _encoderCache, /* @__PURE__ */ new Map());
    const links = /* @__PURE__ */ new Map();
    const parents = /* @__PURE__ */ new Map();
    const subtypes = /* @__PURE__ */ new Map();
    const types = {};
    Object.keys(_types2).forEach((type) => {
      types[type] = _types2[type].map(({ name, type: type2 }) => {
        let { base, index } = splitArray(type2);
        if (base === "int" && !_types2["int"]) {
          base = "int256";
        }
        if (base === "uint" && !_types2["uint"]) {
          base = "uint256";
        }
        return { name, type: base + (index || "") };
      });
      links.set(type, /* @__PURE__ */ new Set());
      parents.set(type, []);
      subtypes.set(type, /* @__PURE__ */ new Set());
    });
    __privateSet(this, _types, JSON.stringify(types));
    for (const name in types) {
      const uniqueNames = /* @__PURE__ */ new Set();
      for (const field of types[name]) {
        assertArgument(!uniqueNames.has(field.name), `duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name)}`, "types", _types2);
        uniqueNames.add(field.name);
        const baseType = splitArray(field.type).base;
        assertArgument(baseType !== name, `circular type reference to ${JSON.stringify(baseType)}`, "types", _types2);
        const encoder = getBaseEncoder(baseType);
        if (encoder) {
          continue;
        }
        assertArgument(parents.has(baseType), `unknown type ${JSON.stringify(baseType)}`, "types", _types2);
        parents.get(baseType).push(name);
        links.get(name).add(baseType);
      }
    }
    const primaryTypes = Array.from(parents.keys()).filter((n4) => parents.get(n4).length === 0);
    assertArgument(primaryTypes.length !== 0, "missing primary type", "types", _types2);
    assertArgument(primaryTypes.length === 1, `ambiguous primary types or unused types: ${primaryTypes.map((t) => JSON.stringify(t)).join(", ")}`, "types", _types2);
    defineProperties(this, { primaryType: primaryTypes[0] });
    function checkCircular(type, found) {
      assertArgument(!found.has(type), `circular type reference to ${JSON.stringify(type)}`, "types", _types2);
      found.add(type);
      for (const child of links.get(type)) {
        if (!parents.has(child)) {
          continue;
        }
        checkCircular(child, found);
        for (const subtype of found) {
          subtypes.get(subtype).add(child);
        }
      }
      found.delete(type);
    }
    checkCircular(this.primaryType, /* @__PURE__ */ new Set());
    for (const [name, set2] of subtypes) {
      const st2 = Array.from(set2);
      st2.sort();
      __privateGet(this, _fullTypes).set(name, encodeType(name, types[name]) + st2.map((t) => encodeType(t, types[t])).join(""));
    }
  }
  /**
   *  The types.
   */
  get types() {
    return JSON.parse(__privateGet(this, _types));
  }
  /**
   *  Returnthe encoder for the specific %%type%%.
   */
  getEncoder(type) {
    let encoder = __privateGet(this, _encoderCache).get(type);
    if (!encoder) {
      encoder = __privateMethod(this, _TypedDataEncoder_instances, getEncoder_fn).call(this, type);
      __privateGet(this, _encoderCache).set(type, encoder);
    }
    return encoder;
  }
  /**
   *  Return the full type for %%name%%.
   */
  encodeType(name) {
    const result = __privateGet(this, _fullTypes).get(name);
    assertArgument(result, `unknown type: ${JSON.stringify(name)}`, "name", name);
    return result;
  }
  /**
   *  Return the encoded %%value%% for the %%type%%.
   */
  encodeData(type, value) {
    return this.getEncoder(type)(value);
  }
  /**
   *  Returns the hash of %%value%% for the type of %%name%%.
   */
  hashStruct(name, value) {
    return keccak256(this.encodeData(name, value));
  }
  /**
   *  Return the fulled encoded %%value%% for the [[types]].
   */
  encode(value) {
    return this.encodeData(this.primaryType, value);
  }
  /**
   *  Return the hash of the fully encoded %%value%% for the [[types]].
   */
  hash(value) {
    return this.hashStruct(this.primaryType, value);
  }
  /**
   *  @_ignore:
   */
  _visit(type, value, callback) {
    {
      const encoder = getBaseEncoder(type);
      if (encoder) {
        return callback(type, value);
      }
    }
    const array = splitArray(type).array;
    if (array) {
      assertArgument(array.count === -1 || array.count === value.length, `array length mismatch; expected length ${array.count}`, "value", value);
      return value.map((v3) => this._visit(array.prefix, v3, callback));
    }
    const fields = this.types[type];
    if (fields) {
      return fields.reduce((accum, { name, type: type2 }) => {
        accum[name] = this._visit(type2, value[name], callback);
        return accum;
      }, {});
    }
    assertArgument(false, `unknown type: ${type}`, "type", type);
  }
  /**
   *  Call %%calback%% for each value in %%value%%, passing the type and
   *  component within %%value%%.
   *
   *  This is useful for replacing addresses or other transformation that
   *  may be desired on each component, based on its type.
   */
  visit(value, callback) {
    return this._visit(this.primaryType, value, callback);
  }
  /**
   *  Create a new **TypedDataEncoder** for %%types%%.
   */
  static from(types) {
    return new _TypedDataEncoder(types);
  }
  /**
   *  Return the primary type for %%types%%.
   */
  static getPrimaryType(types) {
    return _TypedDataEncoder.from(types).primaryType;
  }
  /**
   *  Return the hashed struct for %%value%% using %%types%% and %%name%%.
   */
  static hashStruct(name, types, value) {
    return _TypedDataEncoder.from(types).hashStruct(name, value);
  }
  /**
   *  Return the domain hash for %%domain%%.
   */
  static hashDomain(domain) {
    const domainFields = [];
    for (const name in domain) {
      if (domain[name] == null) {
        continue;
      }
      const type = domainFieldTypes[name];
      assertArgument(type, `invalid typed-data domain key: ${JSON.stringify(name)}`, "domain", domain);
      domainFields.push({ name, type });
    }
    domainFields.sort((a2, b2) => {
      return domainFieldNames.indexOf(a2.name) - domainFieldNames.indexOf(b2.name);
    });
    return _TypedDataEncoder.hashStruct("EIP712Domain", { EIP712Domain: domainFields }, domain);
  }
  /**
   *  Return the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.
   */
  static encode(domain, types, value) {
    return concat([
      "0x1901",
      _TypedDataEncoder.hashDomain(domain),
      _TypedDataEncoder.from(types).hash(value)
    ]);
  }
  /**
   *  Return the hash of the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.
   */
  static hash(domain, types, value) {
    return keccak256(_TypedDataEncoder.encode(domain, types, value));
  }
  // Replaces all address types with ENS names with their looked up address
  /**
   * Resolves to the value from resolving all addresses in %%value%% for
   * %%types%% and the %%domain%%.
   */
  static async resolveNames(domain, types, value, resolveName) {
    domain = Object.assign({}, domain);
    for (const key in domain) {
      if (domain[key] == null) {
        delete domain[key];
      }
    }
    const ensCache = {};
    if (domain.verifyingContract && !isHexString(domain.verifyingContract, 20)) {
      ensCache[domain.verifyingContract] = "0x";
    }
    const encoder = _TypedDataEncoder.from(types);
    encoder.visit(value, (type, value2) => {
      if (type === "address" && !isHexString(value2, 20)) {
        ensCache[value2] = "0x";
      }
      return value2;
    });
    for (const name in ensCache) {
      ensCache[name] = await resolveName(name);
    }
    if (domain.verifyingContract && ensCache[domain.verifyingContract]) {
      domain.verifyingContract = ensCache[domain.verifyingContract];
    }
    value = encoder.visit(value, (type, value2) => {
      if (type === "address" && ensCache[value2]) {
        return ensCache[value2];
      }
      return value2;
    });
    return { domain, value };
  }
  /**
   *  Returns the JSON-encoded payload expected by nodes which implement
   *  the JSON-RPC [[link-eip-712]] method.
   */
  static getPayload(domain, types, value) {
    _TypedDataEncoder.hashDomain(domain);
    const domainValues = {};
    const domainTypes = [];
    domainFieldNames.forEach((name) => {
      const value2 = domain[name];
      if (value2 == null) {
        return;
      }
      domainValues[name] = domainChecks[name](value2);
      domainTypes.push({ name, type: domainFieldTypes[name] });
    });
    const encoder = _TypedDataEncoder.from(types);
    types = encoder.types;
    const typesWithDomain = Object.assign({}, types);
    assertArgument(typesWithDomain.EIP712Domain == null, "types must not contain EIP712Domain type", "types.EIP712Domain", types);
    typesWithDomain.EIP712Domain = domainTypes;
    encoder.encode(value);
    return {
      types: typesWithDomain,
      domain: domainValues,
      primaryType: encoder.primaryType,
      message: encoder.visit(value, (type, value2) => {
        if (type.match(/^bytes(\d*)/)) {
          return hexlify(getBytes(value2));
        }
        if (type.match(/^u?int/)) {
          return getBigInt(value2).toString();
        }
        switch (type) {
          case "address":
            return value2.toLowerCase();
          case "bool":
            return !!value2;
          case "string":
            assertArgument(typeof value2 === "string", "invalid string", "value", value2);
            return value2;
        }
        assertArgument(false, "unsupported type", "type", type);
      })
    };
  }
};
_types = new WeakMap();
_fullTypes = new WeakMap();
_encoderCache = new WeakMap();
_TypedDataEncoder_instances = new WeakSet();
getEncoder_fn = function(type) {
  {
    const encoder = getBaseEncoder(type);
    if (encoder) {
      return encoder;
    }
  }
  const array = splitArray(type).array;
  if (array) {
    const subtype = array.prefix;
    const subEncoder = this.getEncoder(subtype);
    return (value) => {
      assertArgument(array.count === -1 || array.count === value.length, `array length mismatch; expected length ${array.count}`, "value", value);
      let result = value.map(subEncoder);
      if (__privateGet(this, _fullTypes).has(subtype)) {
        result = result.map(keccak256);
      }
      return keccak256(concat(result));
    };
  }
  const fields = this.types[type];
  if (fields) {
    const encodedType = id(__privateGet(this, _fullTypes).get(type));
    return (value) => {
      const values = fields.map(({ name, type: type2 }) => {
        const result = this.getEncoder(type2)(value[name]);
        if (__privateGet(this, _fullTypes).has(type2)) {
          return keccak256(result);
        }
        return result;
      });
      values.unshift(encodedType);
      return concat(values);
    };
  }
  assertArgument(false, `unknown type: ${type}`, "type", type);
};
let TypedDataEncoder = _TypedDataEncoder;
function setify(items) {
  const result = /* @__PURE__ */ new Set();
  items.forEach((k2) => result.add(k2));
  return Object.freeze(result);
}
const _kwVisibDeploy = "external public payable override";
const KwVisibDeploy = setify(_kwVisibDeploy.split(" "));
const _kwVisib = "constant external internal payable private public pure view override";
const KwVisib = setify(_kwVisib.split(" "));
const _kwTypes = "constructor error event fallback function receive struct";
const KwTypes = setify(_kwTypes.split(" "));
const _kwModifiers = "calldata memory storage payable indexed";
const KwModifiers = setify(_kwModifiers.split(" "));
const _kwOther = "tuple returns";
const _keywords = [_kwTypes, _kwModifiers, _kwOther, _kwVisib].join(" ");
const Keywords = setify(_keywords.split(" "));
const SimpleTokens = {
  "(": "OPEN_PAREN",
  ")": "CLOSE_PAREN",
  "[": "OPEN_BRACKET",
  "]": "CLOSE_BRACKET",
  ",": "COMMA",
  "@": "AT"
};
const regexWhitespacePrefix = new RegExp("^(\\s*)");
const regexNumberPrefix = new RegExp("^([0-9]+)");
const regexIdPrefix = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)");
const regexId = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)$");
const regexType = new RegExp("^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$");
const _TokenString = class _TokenString {
  constructor(tokens) {
    __privateAdd(this, _TokenString_instances);
    __privateAdd(this, _offset2);
    __privateAdd(this, _tokens);
    __privateSet(this, _offset2, 0);
    __privateSet(this, _tokens, tokens.slice());
  }
  get offset() {
    return __privateGet(this, _offset2);
  }
  get length() {
    return __privateGet(this, _tokens).length - __privateGet(this, _offset2);
  }
  clone() {
    return new _TokenString(__privateGet(this, _tokens));
  }
  reset() {
    __privateSet(this, _offset2, 0);
  }
  // Pops and returns the value of the next token, if it is a keyword in allowed; throws if out of tokens
  popKeyword(allowed) {
    const top = this.peek();
    if (top.type !== "KEYWORD" || !allowed.has(top.text)) {
      throw new Error(`expected keyword ${top.text}`);
    }
    return this.pop().text;
  }
  // Pops and returns the value of the next token if it is `type`; throws if out of tokens
  popType(type) {
    if (this.peek().type !== type) {
      const top = this.peek();
      throw new Error(`expected ${type}; got ${top.type} ${JSON.stringify(top.text)}`);
    }
    return this.pop().text;
  }
  // Pops and returns a "(" TOKENS ")"
  popParen() {
    const top = this.peek();
    if (top.type !== "OPEN_PAREN") {
      throw new Error("bad start");
    }
    const result = __privateMethod(this, _TokenString_instances, subTokenString_fn).call(this, __privateGet(this, _offset2) + 1, top.match + 1);
    __privateSet(this, _offset2, top.match + 1);
    return result;
  }
  // Pops and returns the items within "(" ITEM1 "," ITEM2 "," ... ")"
  popParams() {
    const top = this.peek();
    if (top.type !== "OPEN_PAREN") {
      throw new Error("bad start");
    }
    const result = [];
    while (__privateGet(this, _offset2) < top.match - 1) {
      const link = this.peek().linkNext;
      result.push(__privateMethod(this, _TokenString_instances, subTokenString_fn).call(this, __privateGet(this, _offset2) + 1, link));
      __privateSet(this, _offset2, link);
    }
    __privateSet(this, _offset2, top.match + 1);
    return result;
  }
  // Returns the top Token, throwing if out of tokens
  peek() {
    if (__privateGet(this, _offset2) >= __privateGet(this, _tokens).length) {
      throw new Error("out-of-bounds");
    }
    return __privateGet(this, _tokens)[__privateGet(this, _offset2)];
  }
  // Returns the next value, if it is a keyword in `allowed`
  peekKeyword(allowed) {
    const top = this.peekType("KEYWORD");
    return top != null && allowed.has(top) ? top : null;
  }
  // Returns the value of the next token if it is `type`
  peekType(type) {
    if (this.length === 0) {
      return null;
    }
    const top = this.peek();
    return top.type === type ? top.text : null;
  }
  // Returns the next token; throws if out of tokens
  pop() {
    const result = this.peek();
    __privateWrapper(this, _offset2)._++;
    return result;
  }
  toString() {
    const tokens = [];
    for (let i = __privateGet(this, _offset2); i < __privateGet(this, _tokens).length; i++) {
      const token = __privateGet(this, _tokens)[i];
      tokens.push(`${token.type}:${token.text}`);
    }
    return `<TokenString ${tokens.join(" ")}>`;
  }
};
_offset2 = new WeakMap();
_tokens = new WeakMap();
_TokenString_instances = new WeakSet();
subTokenString_fn = function(from = 0, to2 = 0) {
  return new _TokenString(__privateGet(this, _tokens).slice(from, to2).map((t) => {
    return Object.freeze(Object.assign({}, t, {
      match: t.match - from,
      linkBack: t.linkBack - from,
      linkNext: t.linkNext - from
    }));
  }));
};
let TokenString = _TokenString;
function lex(text) {
  const tokens = [];
  const throwError2 = (message) => {
    const token = offset < text.length ? JSON.stringify(text[offset]) : "$EOI";
    throw new Error(`invalid token ${token} at ${offset}: ${message}`);
  };
  let brackets = [];
  let commas = [];
  let offset = 0;
  while (offset < text.length) {
    let cur = text.substring(offset);
    let match = cur.match(regexWhitespacePrefix);
    if (match) {
      offset += match[1].length;
      cur = text.substring(offset);
    }
    const token = { depth: brackets.length, linkBack: -1, linkNext: -1, match: -1, type: "", text: "", offset, value: -1 };
    tokens.push(token);
    let type = SimpleTokens[cur[0]] || "";
    if (type) {
      token.type = type;
      token.text = cur[0];
      offset++;
      if (type === "OPEN_PAREN") {
        brackets.push(tokens.length - 1);
        commas.push(tokens.length - 1);
      } else if (type == "CLOSE_PAREN") {
        if (brackets.length === 0) {
          throwError2("no matching open bracket");
        }
        token.match = brackets.pop();
        tokens[token.match].match = tokens.length - 1;
        token.depth--;
        token.linkBack = commas.pop();
        tokens[token.linkBack].linkNext = tokens.length - 1;
      } else if (type === "COMMA") {
        token.linkBack = commas.pop();
        tokens[token.linkBack].linkNext = tokens.length - 1;
        commas.push(tokens.length - 1);
      } else if (type === "OPEN_BRACKET") {
        token.type = "BRACKET";
      } else if (type === "CLOSE_BRACKET") {
        let suffix = tokens.pop().text;
        if (tokens.length > 0 && tokens[tokens.length - 1].type === "NUMBER") {
          const value = tokens.pop().text;
          suffix = value + suffix;
          tokens[tokens.length - 1].value = getNumber(value);
        }
        if (tokens.length === 0 || tokens[tokens.length - 1].type !== "BRACKET") {
          throw new Error("missing opening bracket");
        }
        tokens[tokens.length - 1].text += suffix;
      }
      continue;
    }
    match = cur.match(regexIdPrefix);
    if (match) {
      token.text = match[1];
      offset += token.text.length;
      if (Keywords.has(token.text)) {
        token.type = "KEYWORD";
        continue;
      }
      if (token.text.match(regexType)) {
        token.type = "TYPE";
        continue;
      }
      token.type = "ID";
      continue;
    }
    match = cur.match(regexNumberPrefix);
    if (match) {
      token.text = match[1];
      token.type = "NUMBER";
      offset += token.text.length;
      continue;
    }
    throw new Error(`unexpected token ${JSON.stringify(cur[0])} at position ${offset}`);
  }
  return new TokenString(tokens.map((t) => Object.freeze(t)));
}
function allowSingle(set2, allowed) {
  let included = [];
  for (const key in allowed.keys()) {
    if (set2.has(key)) {
      included.push(key);
    }
  }
  if (included.length > 1) {
    throw new Error(`conflicting types: ${included.join(", ")}`);
  }
}
function consumeName(type, tokens) {
  if (tokens.peekKeyword(KwTypes)) {
    const keyword = tokens.pop().text;
    if (keyword !== type) {
      throw new Error(`expected ${type}, got ${keyword}`);
    }
  }
  return tokens.popType("ID");
}
function consumeKeywords(tokens, allowed) {
  const keywords = /* @__PURE__ */ new Set();
  while (true) {
    const keyword = tokens.peekType("KEYWORD");
    if (keyword == null || allowed && !allowed.has(keyword)) {
      break;
    }
    tokens.pop();
    if (keywords.has(keyword)) {
      throw new Error(`duplicate keywords: ${JSON.stringify(keyword)}`);
    }
    keywords.add(keyword);
  }
  return Object.freeze(keywords);
}
function consumeMutability(tokens) {
  let modifiers = consumeKeywords(tokens, KwVisib);
  allowSingle(modifiers, setify("constant payable nonpayable".split(" ")));
  allowSingle(modifiers, setify("pure view payable nonpayable".split(" ")));
  if (modifiers.has("view")) {
    return "view";
  }
  if (modifiers.has("pure")) {
    return "pure";
  }
  if (modifiers.has("payable")) {
    return "payable";
  }
  if (modifiers.has("nonpayable")) {
    return "nonpayable";
  }
  if (modifiers.has("constant")) {
    return "view";
  }
  return "nonpayable";
}
function consumeParams(tokens, allowIndexed) {
  return tokens.popParams().map((t) => ParamType.from(t, allowIndexed));
}
function consumeGas(tokens) {
  if (tokens.peekType("AT")) {
    tokens.pop();
    if (tokens.peekType("NUMBER")) {
      return getBigInt(tokens.pop().text);
    }
    throw new Error("invalid gas");
  }
  return null;
}
function consumeEoi(tokens) {
  if (tokens.length) {
    throw new Error(`unexpected tokens at offset ${tokens.offset}: ${tokens.toString()}`);
  }
}
const regexArrayType = new RegExp(/^(.*)\[([0-9]*)\]$/);
function verifyBasicType(type) {
  const match = type.match(regexType);
  assertArgument(match, "invalid type", "type", type);
  if (type === "uint") {
    return "uint256";
  }
  if (type === "int") {
    return "int256";
  }
  if (match[2]) {
    const length = parseInt(match[2]);
    assertArgument(length !== 0 && length <= 32, "invalid bytes length", "type", type);
  } else if (match[3]) {
    const size = parseInt(match[3]);
    assertArgument(size !== 0 && size <= 256 && size % 8 === 0, "invalid numeric width", "type", type);
  }
  return type;
}
const _guard = {};
const internal$1 = Symbol.for("_ethers_internal");
const ParamTypeInternal = "_ParamTypeInternal";
const ErrorFragmentInternal = "_ErrorInternal";
const EventFragmentInternal = "_EventInternal";
const ConstructorFragmentInternal = "_ConstructorInternal";
const FallbackFragmentInternal = "_FallbackInternal";
const FunctionFragmentInternal = "_FunctionInternal";
const StructFragmentInternal = "_StructInternal";
const _ParamType = class _ParamType {
  /**
   *  @private
   */
  constructor(guard, name, type, baseType, indexed, components, arrayLength, arrayChildren) {
    __privateAdd(this, _ParamType_instances);
    /**
     *  The local name of the parameter (or ``""`` if unbound)
     */
    __publicField(this, "name");
    /**
     *  The fully qualified type (e.g. ``"address"``, ``"tuple(address)"``,
     *  ``"uint256[3][]"``)
     */
    __publicField(this, "type");
    /**
     *  The base type (e.g. ``"address"``, ``"tuple"``, ``"array"``)
     */
    __publicField(this, "baseType");
    /**
     *  True if the parameters is indexed.
     *
     *  For non-indexable types this is ``null``.
     */
    __publicField(this, "indexed");
    /**
     *  The components for the tuple.
     *
     *  For non-tuple types this is ``null``.
     */
    __publicField(this, "components");
    /**
     *  The array length, or ``-1`` for dynamic-lengthed arrays.
     *
     *  For non-array types this is ``null``.
     */
    __publicField(this, "arrayLength");
    /**
     *  The type of each child in the array.
     *
     *  For non-array types this is ``null``.
     */
    __publicField(this, "arrayChildren");
    assertPrivate(guard, _guard, "ParamType");
    Object.defineProperty(this, internal$1, { value: ParamTypeInternal });
    if (components) {
      components = Object.freeze(components.slice());
    }
    if (baseType === "array") {
      if (arrayLength == null || arrayChildren == null) {
        throw new Error("");
      }
    } else if (arrayLength != null || arrayChildren != null) {
      throw new Error("");
    }
    if (baseType === "tuple") {
      if (components == null) {
        throw new Error("");
      }
    } else if (components != null) {
      throw new Error("");
    }
    defineProperties(this, {
      name,
      type,
      baseType,
      indexed,
      components,
      arrayLength,
      arrayChildren
    });
  }
  /**
   *  Return a string representation of this type.
   *
   *  For example,
   *
   *  ``sighash" => "(uint256,address)"``
   *
   *  ``"minimal" => "tuple(uint256,address) indexed"``
   *
   *  ``"full" => "tuple(uint256 foo, address bar) indexed baz"``
   */
  format(format2) {
    if (format2 == null) {
      format2 = "sighash";
    }
    if (format2 === "json") {
      const name = this.name || "";
      if (this.isArray()) {
        const result3 = JSON.parse(this.arrayChildren.format("json"));
        result3.name = name;
        result3.type += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`;
        return JSON.stringify(result3);
      }
      const result2 = {
        type: this.baseType === "tuple" ? "tuple" : this.type,
        name
      };
      if (typeof this.indexed === "boolean") {
        result2.indexed = this.indexed;
      }
      if (this.isTuple()) {
        result2.components = this.components.map((c) => JSON.parse(c.format(format2)));
      }
      return JSON.stringify(result2);
    }
    let result = "";
    if (this.isArray()) {
      result += this.arrayChildren.format(format2);
      result += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`;
    } else {
      if (this.isTuple()) {
        result += "(" + this.components.map((comp) => comp.format(format2)).join(format2 === "full" ? ", " : ",") + ")";
      } else {
        result += this.type;
      }
    }
    if (format2 !== "sighash") {
      if (this.indexed === true) {
        result += " indexed";
      }
      if (format2 === "full" && this.name) {
        result += " " + this.name;
      }
    }
    return result;
  }
  /**
   *  Returns true if %%this%% is an Array type.
   *
   *  This provides a type gaurd ensuring that [[arrayChildren]]
   *  and [[arrayLength]] are non-null.
   */
  isArray() {
    return this.baseType === "array";
  }
  /**
   *  Returns true if %%this%% is a Tuple type.
   *
   *  This provides a type gaurd ensuring that [[components]]
   *  is non-null.
   */
  isTuple() {
    return this.baseType === "tuple";
  }
  /**
   *  Returns true if %%this%% is an Indexable type.
   *
   *  This provides a type gaurd ensuring that [[indexed]]
   *  is non-null.
   */
  isIndexable() {
    return this.indexed != null;
  }
  /**
   *  Walks the **ParamType** with %%value%%, calling %%process%%
   *  on each type, destructing the %%value%% recursively.
   */
  walk(value, process) {
    if (this.isArray()) {
      if (!Array.isArray(value)) {
        throw new Error("invalid array value");
      }
      if (this.arrayLength !== -1 && value.length !== this.arrayLength) {
        throw new Error("array is wrong length");
      }
      const _this = this;
      return value.map((v3) => _this.arrayChildren.walk(v3, process));
    }
    if (this.isTuple()) {
      if (!Array.isArray(value)) {
        throw new Error("invalid tuple value");
      }
      if (value.length !== this.components.length) {
        throw new Error("array is wrong length");
      }
      const _this = this;
      return value.map((v3, i) => _this.components[i].walk(v3, process));
    }
    return process(this.type, value);
  }
  /**
   *  Walks the **ParamType** with %%value%%, asynchronously calling
   *  %%process%% on each type, destructing the %%value%% recursively.
   *
   *  This can be used to resolve ENS names by walking and resolving each
   *  ``"address"`` type.
   */
  async walkAsync(value, process) {
    const promises = [];
    const result = [value];
    __privateMethod(this, _ParamType_instances, walkAsync_fn).call(this, promises, value, process, (value2) => {
      result[0] = value2;
    });
    if (promises.length) {
      await Promise.all(promises);
    }
    return result[0];
  }
  /**
   *  Creates a new **ParamType** for %%obj%%.
   *
   *  If %%allowIndexed%% then the ``indexed`` keyword is permitted,
   *  otherwise the ``indexed`` keyword will throw an error.
   */
  static from(obj, allowIndexed) {
    if (_ParamType.isParamType(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return _ParamType.from(lex(obj), allowIndexed);
      } catch (error) {
        assertArgument(false, "invalid param type", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      let type2 = "", baseType = "";
      let comps = null;
      if (consumeKeywords(obj, setify(["tuple"])).has("tuple") || obj.peekType("OPEN_PAREN")) {
        baseType = "tuple";
        comps = obj.popParams().map((t) => _ParamType.from(t));
        type2 = `tuple(${comps.map((c) => c.format()).join(",")})`;
      } else {
        type2 = verifyBasicType(obj.popType("TYPE"));
        baseType = type2;
      }
      let arrayChildren = null;
      let arrayLength = null;
      while (obj.length && obj.peekType("BRACKET")) {
        const bracket = obj.pop();
        arrayChildren = new _ParamType(_guard, "", type2, baseType, null, comps, arrayLength, arrayChildren);
        arrayLength = bracket.value;
        type2 += bracket.text;
        baseType = "array";
        comps = null;
      }
      let indexed2 = null;
      const keywords = consumeKeywords(obj, KwModifiers);
      if (keywords.has("indexed")) {
        if (!allowIndexed) {
          throw new Error("");
        }
        indexed2 = true;
      }
      const name2 = obj.peekType("ID") ? obj.pop().text : "";
      if (obj.length) {
        throw new Error("leftover tokens");
      }
      return new _ParamType(_guard, name2, type2, baseType, indexed2, comps, arrayLength, arrayChildren);
    }
    const name = obj.name;
    assertArgument(!name || typeof name === "string" && name.match(regexId), "invalid name", "obj.name", name);
    let indexed = obj.indexed;
    if (indexed != null) {
      assertArgument(allowIndexed, "parameter cannot be indexed", "obj.indexed", obj.indexed);
      indexed = !!indexed;
    }
    let type = obj.type;
    let arrayMatch = type.match(regexArrayType);
    if (arrayMatch) {
      const arrayLength = parseInt(arrayMatch[2] || "-1");
      const arrayChildren = _ParamType.from({
        type: arrayMatch[1],
        components: obj.components
      });
      return new _ParamType(_guard, name || "", type, "array", indexed, null, arrayLength, arrayChildren);
    }
    if (type === "tuple" || type.startsWith(
      "tuple("
      /* fix: ) */
    ) || type.startsWith(
      "("
      /* fix: ) */
    )) {
      const comps = obj.components != null ? obj.components.map((c) => _ParamType.from(c)) : null;
      const tuple = new _ParamType(_guard, name || "", type, "tuple", indexed, comps, null, null);
      return tuple;
    }
    type = verifyBasicType(obj.type);
    return new _ParamType(_guard, name || "", type, type, indexed, null, null, null);
  }
  /**
   *  Returns true if %%value%% is a **ParamType**.
   */
  static isParamType(value) {
    return value && value[internal$1] === ParamTypeInternal;
  }
};
_ParamType_instances = new WeakSet();
walkAsync_fn = function(promises, value, process, setValue) {
  if (this.isArray()) {
    if (!Array.isArray(value)) {
      throw new Error("invalid array value");
    }
    if (this.arrayLength !== -1 && value.length !== this.arrayLength) {
      throw new Error("array is wrong length");
    }
    const childType = this.arrayChildren;
    const result2 = value.slice();
    result2.forEach((value2, index) => {
      var _a3;
      __privateMethod(_a3 = childType, _ParamType_instances, walkAsync_fn).call(_a3, promises, value2, process, (value3) => {
        result2[index] = value3;
      });
    });
    setValue(result2);
    return;
  }
  if (this.isTuple()) {
    const components = this.components;
    let result2;
    if (Array.isArray(value)) {
      result2 = value.slice();
    } else {
      if (value == null || typeof value !== "object") {
        throw new Error("invalid tuple value");
      }
      result2 = components.map((param) => {
        if (!param.name) {
          throw new Error("cannot use object value with unnamed components");
        }
        if (!(param.name in value)) {
          throw new Error(`missing value for component ${param.name}`);
        }
        return value[param.name];
      });
    }
    if (result2.length !== this.components.length) {
      throw new Error("array is wrong length");
    }
    result2.forEach((value2, index) => {
      var _a3;
      __privateMethod(_a3 = components[index], _ParamType_instances, walkAsync_fn).call(_a3, promises, value2, process, (value3) => {
        result2[index] = value3;
      });
    });
    setValue(result2);
    return;
  }
  const result = process(this.type, value);
  if (result.then) {
    promises.push(async function() {
      setValue(await result);
    }());
  } else {
    setValue(result);
  }
};
let ParamType = _ParamType;
class Fragment {
  /**
   *  @private
   */
  constructor(guard, type, inputs) {
    /**
     *  The type of the fragment.
     */
    __publicField(this, "type");
    /**
     *  The inputs for the fragment.
     */
    __publicField(this, "inputs");
    assertPrivate(guard, _guard, "Fragment");
    inputs = Object.freeze(inputs.slice());
    defineProperties(this, { type, inputs });
  }
  /**
   *  Creates a new **Fragment** for %%obj%%, wich can be any supported
   *  ABI frgament type.
   */
  static from(obj) {
    if (typeof obj === "string") {
      try {
        Fragment.from(JSON.parse(obj));
      } catch (e2) {
      }
      return Fragment.from(lex(obj));
    }
    if (obj instanceof TokenString) {
      const type = obj.peekKeyword(KwTypes);
      switch (type) {
        case "constructor":
          return ConstructorFragment.from(obj);
        case "error":
          return ErrorFragment.from(obj);
        case "event":
          return EventFragment.from(obj);
        case "fallback":
        case "receive":
          return FallbackFragment.from(obj);
        case "function":
          return FunctionFragment.from(obj);
        case "struct":
          return StructFragment.from(obj);
      }
    } else if (typeof obj === "object") {
      switch (obj.type) {
        case "constructor":
          return ConstructorFragment.from(obj);
        case "error":
          return ErrorFragment.from(obj);
        case "event":
          return EventFragment.from(obj);
        case "fallback":
        case "receive":
          return FallbackFragment.from(obj);
        case "function":
          return FunctionFragment.from(obj);
        case "struct":
          return StructFragment.from(obj);
      }
      assert(false, `unsupported type: ${obj.type}`, "UNSUPPORTED_OPERATION", {
        operation: "Fragment.from"
      });
    }
    assertArgument(false, "unsupported frgament object", "obj", obj);
  }
  /**
   *  Returns true if %%value%% is a [[ConstructorFragment]].
   */
  static isConstructor(value) {
    return ConstructorFragment.isFragment(value);
  }
  /**
   *  Returns true if %%value%% is an [[ErrorFragment]].
   */
  static isError(value) {
    return ErrorFragment.isFragment(value);
  }
  /**
   *  Returns true if %%value%% is an [[EventFragment]].
   */
  static isEvent(value) {
    return EventFragment.isFragment(value);
  }
  /**
   *  Returns true if %%value%% is a [[FunctionFragment]].
   */
  static isFunction(value) {
    return FunctionFragment.isFragment(value);
  }
  /**
   *  Returns true if %%value%% is a [[StructFragment]].
   */
  static isStruct(value) {
    return StructFragment.isFragment(value);
  }
}
class NamedFragment extends Fragment {
  /**
   *  @private
   */
  constructor(guard, type, name, inputs) {
    super(guard, type, inputs);
    /**
     *  The name of the fragment.
     */
    __publicField(this, "name");
    assertArgument(typeof name === "string" && name.match(regexId), "invalid identifier", "name", name);
    inputs = Object.freeze(inputs.slice());
    defineProperties(this, { name });
  }
}
function joinParams(format2, params) {
  return "(" + params.map((p2) => p2.format(format2)).join(format2 === "full" ? ", " : ",") + ")";
}
class ErrorFragment extends NamedFragment {
  /**
   *  @private
   */
  constructor(guard, name, inputs) {
    super(guard, "error", name, inputs);
    Object.defineProperty(this, internal$1, { value: ErrorFragmentInternal });
  }
  /**
   *  The Custom Error selector.
   */
  get selector() {
    return id(this.format("sighash")).substring(0, 10);
  }
  /**
   *  Returns a string representation of this fragment as %%format%%.
   */
  format(format2) {
    if (format2 == null) {
      format2 = "sighash";
    }
    if (format2 === "json") {
      return JSON.stringify({
        type: "error",
        name: this.name,
        inputs: this.inputs.map((input) => JSON.parse(input.format(format2)))
      });
    }
    const result = [];
    if (format2 !== "sighash") {
      result.push("error");
    }
    result.push(this.name + joinParams(format2, this.inputs));
    return result.join(" ");
  }
  /**
   *  Returns a new **ErrorFragment** for %%obj%%.
   */
  static from(obj) {
    if (ErrorFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      return ErrorFragment.from(lex(obj));
    } else if (obj instanceof TokenString) {
      const name = consumeName("error", obj);
      const inputs = consumeParams(obj);
      consumeEoi(obj);
      return new ErrorFragment(_guard, name, inputs);
    }
    return new ErrorFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is an
   *  **ErrorFragment**.
   */
  static isFragment(value) {
    return value && value[internal$1] === ErrorFragmentInternal;
  }
}
class EventFragment extends NamedFragment {
  /**
   *  @private
   */
  constructor(guard, name, inputs, anonymous) {
    super(guard, "event", name, inputs);
    /**
     *  Whether this event is anonymous.
     */
    __publicField(this, "anonymous");
    Object.defineProperty(this, internal$1, { value: EventFragmentInternal });
    defineProperties(this, { anonymous });
  }
  /**
   *  The Event topic hash.
   */
  get topicHash() {
    return id(this.format("sighash"));
  }
  /**
   *  Returns a string representation of this event as %%format%%.
   */
  format(format2) {
    if (format2 == null) {
      format2 = "sighash";
    }
    if (format2 === "json") {
      return JSON.stringify({
        type: "event",
        anonymous: this.anonymous,
        name: this.name,
        inputs: this.inputs.map((i) => JSON.parse(i.format(format2)))
      });
    }
    const result = [];
    if (format2 !== "sighash") {
      result.push("event");
    }
    result.push(this.name + joinParams(format2, this.inputs));
    if (format2 !== "sighash" && this.anonymous) {
      result.push("anonymous");
    }
    return result.join(" ");
  }
  /**
   *  Return the topic hash for an event with %%name%% and %%params%%.
   */
  static getTopicHash(name, params) {
    params = (params || []).map((p2) => ParamType.from(p2));
    const fragment = new EventFragment(_guard, name, params, false);
    return fragment.topicHash;
  }
  /**
   *  Returns a new **EventFragment** for %%obj%%.
   */
  static from(obj) {
    if (EventFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return EventFragment.from(lex(obj));
      } catch (error) {
        assertArgument(false, "invalid event fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      const name = consumeName("event", obj);
      const inputs = consumeParams(obj, true);
      const anonymous = !!consumeKeywords(obj, setify(["anonymous"])).has("anonymous");
      consumeEoi(obj);
      return new EventFragment(_guard, name, inputs, anonymous);
    }
    return new EventFragment(_guard, obj.name, obj.inputs ? obj.inputs.map((p2) => ParamType.from(p2, true)) : [], !!obj.anonymous);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is an
   *  **EventFragment**.
   */
  static isFragment(value) {
    return value && value[internal$1] === EventFragmentInternal;
  }
}
class ConstructorFragment extends Fragment {
  /**
   *  @private
   */
  constructor(guard, type, inputs, payable, gas) {
    super(guard, type, inputs);
    /**
     *  Whether the constructor can receive an endowment.
     */
    __publicField(this, "payable");
    /**
     *  The recommended gas limit for deployment or ``null``.
     */
    __publicField(this, "gas");
    Object.defineProperty(this, internal$1, { value: ConstructorFragmentInternal });
    defineProperties(this, { payable, gas });
  }
  /**
   *  Returns a string representation of this constructor as %%format%%.
   */
  format(format2) {
    assert(format2 != null && format2 !== "sighash", "cannot format a constructor for sighash", "UNSUPPORTED_OPERATION", { operation: "format(sighash)" });
    if (format2 === "json") {
      return JSON.stringify({
        type: "constructor",
        stateMutability: this.payable ? "payable" : "undefined",
        payable: this.payable,
        gas: this.gas != null ? this.gas : void 0,
        inputs: this.inputs.map((i) => JSON.parse(i.format(format2)))
      });
    }
    const result = [`constructor${joinParams(format2, this.inputs)}`];
    if (this.payable) {
      result.push("payable");
    }
    if (this.gas != null) {
      result.push(`@${this.gas.toString()}`);
    }
    return result.join(" ");
  }
  /**
   *  Returns a new **ConstructorFragment** for %%obj%%.
   */
  static from(obj) {
    if (ConstructorFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return ConstructorFragment.from(lex(obj));
      } catch (error) {
        assertArgument(false, "invalid constuctor fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      consumeKeywords(obj, setify(["constructor"]));
      const inputs = consumeParams(obj);
      const payable = !!consumeKeywords(obj, KwVisibDeploy).has("payable");
      const gas = consumeGas(obj);
      consumeEoi(obj);
      return new ConstructorFragment(_guard, "constructor", inputs, payable, gas);
    }
    return new ConstructorFragment(_guard, "constructor", obj.inputs ? obj.inputs.map(ParamType.from) : [], !!obj.payable, obj.gas != null ? obj.gas : null);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **ConstructorFragment**.
   */
  static isFragment(value) {
    return value && value[internal$1] === ConstructorFragmentInternal;
  }
}
class FallbackFragment extends Fragment {
  constructor(guard, inputs, payable) {
    super(guard, "fallback", inputs);
    /**
     *  If the function can be sent value during invocation.
     */
    __publicField(this, "payable");
    Object.defineProperty(this, internal$1, { value: FallbackFragmentInternal });
    defineProperties(this, { payable });
  }
  /**
   *  Returns a string representation of this fallback as %%format%%.
   */
  format(format2) {
    const type = this.inputs.length === 0 ? "receive" : "fallback";
    if (format2 === "json") {
      const stateMutability = this.payable ? "payable" : "nonpayable";
      return JSON.stringify({ type, stateMutability });
    }
    return `${type}()${this.payable ? " payable" : ""}`;
  }
  /**
   *  Returns a new **FallbackFragment** for %%obj%%.
   */
  static from(obj) {
    if (FallbackFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return FallbackFragment.from(lex(obj));
      } catch (error) {
        assertArgument(false, "invalid fallback fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      const errorObj = obj.toString();
      const topIsValid = obj.peekKeyword(setify(["fallback", "receive"]));
      assertArgument(topIsValid, "type must be fallback or receive", "obj", errorObj);
      const type = obj.popKeyword(setify(["fallback", "receive"]));
      if (type === "receive") {
        const inputs2 = consumeParams(obj);
        assertArgument(inputs2.length === 0, `receive cannot have arguments`, "obj.inputs", inputs2);
        consumeKeywords(obj, setify(["payable"]));
        consumeEoi(obj);
        return new FallbackFragment(_guard, [], true);
      }
      let inputs = consumeParams(obj);
      if (inputs.length) {
        assertArgument(inputs.length === 1 && inputs[0].type === "bytes", "invalid fallback inputs", "obj.inputs", inputs.map((i) => i.format("minimal")).join(", "));
      } else {
        inputs = [ParamType.from("bytes")];
      }
      const mutability = consumeMutability(obj);
      assertArgument(mutability === "nonpayable" || mutability === "payable", "fallback cannot be constants", "obj.stateMutability", mutability);
      if (consumeKeywords(obj, setify(["returns"])).has("returns")) {
        const outputs = consumeParams(obj);
        assertArgument(outputs.length === 1 && outputs[0].type === "bytes", "invalid fallback outputs", "obj.outputs", outputs.map((i) => i.format("minimal")).join(", "));
      }
      consumeEoi(obj);
      return new FallbackFragment(_guard, inputs, mutability === "payable");
    }
    if (obj.type === "receive") {
      return new FallbackFragment(_guard, [], true);
    }
    if (obj.type === "fallback") {
      const inputs = [ParamType.from("bytes")];
      const payable = obj.stateMutability === "payable";
      return new FallbackFragment(_guard, inputs, payable);
    }
    assertArgument(false, "invalid fallback description", "obj", obj);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **FallbackFragment**.
   */
  static isFragment(value) {
    return value && value[internal$1] === FallbackFragmentInternal;
  }
}
class FunctionFragment extends NamedFragment {
  /**
   *  @private
   */
  constructor(guard, name, stateMutability, inputs, outputs, gas) {
    super(guard, "function", name, inputs);
    /**
     *  If the function is constant (e.g. ``pure`` or ``view`` functions).
     */
    __publicField(this, "constant");
    /**
     *  The returned types for the result of calling this function.
     */
    __publicField(this, "outputs");
    /**
     *  The state mutability (e.g. ``payable``, ``nonpayable``, ``view``
     *  or ``pure``)
     */
    __publicField(this, "stateMutability");
    /**
     *  If the function can be sent value during invocation.
     */
    __publicField(this, "payable");
    /**
     *  The recommended gas limit to send when calling this function.
     */
    __publicField(this, "gas");
    Object.defineProperty(this, internal$1, { value: FunctionFragmentInternal });
    outputs = Object.freeze(outputs.slice());
    const constant = stateMutability === "view" || stateMutability === "pure";
    const payable = stateMutability === "payable";
    defineProperties(this, { constant, gas, outputs, payable, stateMutability });
  }
  /**
   *  The Function selector.
   */
  get selector() {
    return id(this.format("sighash")).substring(0, 10);
  }
  /**
   *  Returns a string representation of this function as %%format%%.
   */
  format(format2) {
    if (format2 == null) {
      format2 = "sighash";
    }
    if (format2 === "json") {
      return JSON.stringify({
        type: "function",
        name: this.name,
        constant: this.constant,
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas != null ? this.gas : void 0,
        inputs: this.inputs.map((i) => JSON.parse(i.format(format2))),
        outputs: this.outputs.map((o2) => JSON.parse(o2.format(format2)))
      });
    }
    const result = [];
    if (format2 !== "sighash") {
      result.push("function");
    }
    result.push(this.name + joinParams(format2, this.inputs));
    if (format2 !== "sighash") {
      if (this.stateMutability !== "nonpayable") {
        result.push(this.stateMutability);
      }
      if (this.outputs && this.outputs.length) {
        result.push("returns");
        result.push(joinParams(format2, this.outputs));
      }
      if (this.gas != null) {
        result.push(`@${this.gas.toString()}`);
      }
    }
    return result.join(" ");
  }
  /**
   *  Return the selector for a function with %%name%% and %%params%%.
   */
  static getSelector(name, params) {
    params = (params || []).map((p2) => ParamType.from(p2));
    const fragment = new FunctionFragment(_guard, name, "view", params, [], null);
    return fragment.selector;
  }
  /**
   *  Returns a new **FunctionFragment** for %%obj%%.
   */
  static from(obj) {
    if (FunctionFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return FunctionFragment.from(lex(obj));
      } catch (error) {
        assertArgument(false, "invalid function fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      const name = consumeName("function", obj);
      const inputs = consumeParams(obj);
      const mutability = consumeMutability(obj);
      let outputs = [];
      if (consumeKeywords(obj, setify(["returns"])).has("returns")) {
        outputs = consumeParams(obj);
      }
      const gas = consumeGas(obj);
      consumeEoi(obj);
      return new FunctionFragment(_guard, name, mutability, inputs, outputs, gas);
    }
    let stateMutability = obj.stateMutability;
    if (stateMutability == null) {
      stateMutability = "payable";
      if (typeof obj.constant === "boolean") {
        stateMutability = "view";
        if (!obj.constant) {
          stateMutability = "payable";
          if (typeof obj.payable === "boolean" && !obj.payable) {
            stateMutability = "nonpayable";
          }
        }
      } else if (typeof obj.payable === "boolean" && !obj.payable) {
        stateMutability = "nonpayable";
      }
    }
    return new FunctionFragment(_guard, obj.name, stateMutability, obj.inputs ? obj.inputs.map(ParamType.from) : [], obj.outputs ? obj.outputs.map(ParamType.from) : [], obj.gas != null ? obj.gas : null);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **FunctionFragment**.
   */
  static isFragment(value) {
    return value && value[internal$1] === FunctionFragmentInternal;
  }
}
class StructFragment extends NamedFragment {
  /**
   *  @private
   */
  constructor(guard, name, inputs) {
    super(guard, "struct", name, inputs);
    Object.defineProperty(this, internal$1, { value: StructFragmentInternal });
  }
  /**
   *  Returns a string representation of this struct as %%format%%.
   */
  format() {
    throw new Error("@TODO");
  }
  /**
   *  Returns a new **StructFragment** for %%obj%%.
   */
  static from(obj) {
    if (typeof obj === "string") {
      try {
        return StructFragment.from(lex(obj));
      } catch (error) {
        assertArgument(false, "invalid struct fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      const name = consumeName("struct", obj);
      const inputs = consumeParams(obj);
      consumeEoi(obj);
      return new StructFragment(_guard, name, inputs);
    }
    return new StructFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);
  }
  // @TODO: fix this return type
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **StructFragment**.
   */
  static isFragment(value) {
    return value && value[internal$1] === StructFragmentInternal;
  }
}
const PanicReasons$1 = /* @__PURE__ */ new Map();
PanicReasons$1.set(0, "GENERIC_PANIC");
PanicReasons$1.set(1, "ASSERT_FALSE");
PanicReasons$1.set(17, "OVERFLOW");
PanicReasons$1.set(18, "DIVIDE_BY_ZERO");
PanicReasons$1.set(33, "ENUM_RANGE_ERROR");
PanicReasons$1.set(34, "BAD_STORAGE_DATA");
PanicReasons$1.set(49, "STACK_UNDERFLOW");
PanicReasons$1.set(50, "ARRAY_RANGE_ERROR");
PanicReasons$1.set(65, "OUT_OF_MEMORY");
PanicReasons$1.set(81, "UNINITIALIZED_FUNCTION_CALL");
const paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
const paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
let defaultCoder = null;
let defaultMaxInflation = 1024;
function getBuiltinCallException(action, tx, data, abiCoder) {
  let message = "missing revert data";
  let reason = null;
  const invocation = null;
  let revert = null;
  if (data) {
    message = "execution reverted";
    const bytes = getBytes(data);
    data = hexlify(data);
    if (bytes.length === 0) {
      message += " (no data present; likely require(false) occurred";
      reason = "require(false)";
    } else if (bytes.length % 32 !== 4) {
      message += " (could not decode reason; invalid data length)";
    } else if (hexlify(bytes.slice(0, 4)) === "0x08c379a0") {
      try {
        reason = abiCoder.decode(["string"], bytes.slice(4))[0];
        revert = {
          signature: "Error(string)",
          name: "Error",
          args: [reason]
        };
        message += `: ${JSON.stringify(reason)}`;
      } catch (error) {
        message += " (could not decode reason; invalid string data)";
      }
    } else if (hexlify(bytes.slice(0, 4)) === "0x4e487b71") {
      try {
        const code = Number(abiCoder.decode(["uint256"], bytes.slice(4))[0]);
        revert = {
          signature: "Panic(uint256)",
          name: "Panic",
          args: [code]
        };
        reason = `Panic due to ${PanicReasons$1.get(code) || "UNKNOWN"}(${code})`;
        message += `: ${reason}`;
      } catch (error) {
        message += " (could not decode panic code)";
      }
    } else {
      message += " (unknown custom error)";
    }
  }
  const transaction = {
    to: tx.to ? getAddress(tx.to) : null,
    data: tx.data || "0x"
  };
  if (tx.from) {
    transaction.from = getAddress(tx.from);
  }
  return makeError(message, "CALL_EXCEPTION", {
    action,
    data,
    reason,
    transaction,
    invocation,
    revert
  });
}
const _AbiCoder = class _AbiCoder {
  constructor() {
    __privateAdd(this, _AbiCoder_instances);
  }
  /**
   *  Get the default values for the given %%types%%.
   *
   *  For example, a ``uint`` is by default ``0`` and ``bool``
   *  is by default ``false``.
   */
  getDefaultValue(types) {
    const coders = types.map((type) => __privateMethod(this, _AbiCoder_instances, getCoder_fn).call(this, ParamType.from(type)));
    const coder = new TupleCoder(coders, "_");
    return coder.defaultValue();
  }
  /**
   *  Encode the %%values%% as the %%types%% into ABI data.
   *
   *  @returns DataHexstring
   */
  encode(types, values) {
    assertArgumentCount(values.length, types.length, "types/values length mismatch");
    const coders = types.map((type) => __privateMethod(this, _AbiCoder_instances, getCoder_fn).call(this, ParamType.from(type)));
    const coder = new TupleCoder(coders, "_");
    const writer = new Writer();
    coder.encode(writer, values);
    return writer.data;
  }
  /**
   *  Decode the ABI %%data%% as the %%types%% into values.
   *
   *  If %%loose%% decoding is enabled, then strict padding is
   *  not enforced. Some older versions of Solidity incorrectly
   *  padded event data emitted from ``external`` functions.
   */
  decode(types, data, loose) {
    const coders = types.map((type) => __privateMethod(this, _AbiCoder_instances, getCoder_fn).call(this, ParamType.from(type)));
    const coder = new TupleCoder(coders, "_");
    return coder.decode(new Reader(data, loose, defaultMaxInflation));
  }
  static _setDefaultMaxInflation(value) {
    assertArgument(typeof value === "number" && Number.isInteger(value), "invalid defaultMaxInflation factor", "value", value);
    defaultMaxInflation = value;
  }
  /**
   *  Returns the shared singleton instance of a default [[AbiCoder]].
   *
   *  On the first call, the instance is created internally.
   */
  static defaultAbiCoder() {
    if (defaultCoder == null) {
      defaultCoder = new _AbiCoder();
    }
    return defaultCoder;
  }
  /**
   *  Returns an ethers-compatible [[CallExceptionError]] Error for the given
   *  result %%data%% for the [[CallExceptionAction]] %%action%% against
   *  the Transaction %%tx%%.
   */
  static getBuiltinCallException(action, tx, data) {
    return getBuiltinCallException(action, tx, data, _AbiCoder.defaultAbiCoder());
  }
};
_AbiCoder_instances = new WeakSet();
getCoder_fn = function(param) {
  if (param.isArray()) {
    return new ArrayCoder(__privateMethod(this, _AbiCoder_instances, getCoder_fn).call(this, param.arrayChildren), param.arrayLength, param.name);
  }
  if (param.isTuple()) {
    return new TupleCoder(param.components.map((c) => __privateMethod(this, _AbiCoder_instances, getCoder_fn).call(this, c)), param.name);
  }
  switch (param.baseType) {
    case "address":
      return new AddressCoder(param.name);
    case "bool":
      return new BooleanCoder(param.name);
    case "string":
      return new StringCoder(param.name);
    case "bytes":
      return new BytesCoder(param.name);
    case "":
      return new NullCoder(param.name);
  }
  let match = param.type.match(paramTypeNumber);
  if (match) {
    let size = parseInt(match[2] || "256");
    assertArgument(size !== 0 && size <= 256 && size % 8 === 0, "invalid " + match[1] + " bit length", "param", param);
    return new NumberCoder(size / 8, match[1] === "int", param.name);
  }
  match = param.type.match(paramTypeBytes);
  if (match) {
    let size = parseInt(match[1]);
    assertArgument(size !== 0 && size <= 32, "invalid bytes length", "param", param);
    return new FixedBytesCoder(size, param.name);
  }
  assertArgument(false, "invalid type", "type", param.type);
};
let AbiCoder = _AbiCoder;
class LogDescription {
  /**
   *  @_ignore:
   */
  constructor(fragment, topic, args) {
    /**
     *  The matching fragment for the ``topic0``.
     */
    __publicField(this, "fragment");
    /**
     *  The name of the Event.
     */
    __publicField(this, "name");
    /**
     *  The full Event signature.
     */
    __publicField(this, "signature");
    /**
     *  The topic hash for the Event.
     */
    __publicField(this, "topic");
    /**
     *  The arguments passed into the Event with ``emit``.
     */
    __publicField(this, "args");
    const name = fragment.name, signature = fragment.format();
    defineProperties(this, {
      fragment,
      name,
      signature,
      topic,
      args
    });
  }
}
class TransactionDescription {
  /**
   *  @_ignore:
   */
  constructor(fragment, selector, args, value) {
    /**
     *  The matching fragment from the transaction ``data``.
     */
    __publicField(this, "fragment");
    /**
     *  The name of the Function from the transaction ``data``.
     */
    __publicField(this, "name");
    /**
     *  The arguments passed to the Function from the transaction ``data``.
     */
    __publicField(this, "args");
    /**
     *  The full Function signature from the transaction ``data``.
     */
    __publicField(this, "signature");
    /**
     *  The selector for the Function from the transaction ``data``.
     */
    __publicField(this, "selector");
    /**
     *  The ``value`` (in wei) from the transaction.
     */
    __publicField(this, "value");
    const name = fragment.name, signature = fragment.format();
    defineProperties(this, {
      fragment,
      name,
      args,
      signature,
      selector,
      value
    });
  }
}
class ErrorDescription {
  /**
   *  @_ignore:
   */
  constructor(fragment, selector, args) {
    /**
     *  The matching fragment.
     */
    __publicField(this, "fragment");
    /**
     *  The name of the Error.
     */
    __publicField(this, "name");
    /**
     *  The arguments passed to the Error with ``revert``.
     */
    __publicField(this, "args");
    /**
     *  The full Error signature.
     */
    __publicField(this, "signature");
    /**
     *  The selector for the Error.
     */
    __publicField(this, "selector");
    const name = fragment.name, signature = fragment.format();
    defineProperties(this, {
      fragment,
      name,
      args,
      signature,
      selector
    });
  }
}
class Indexed {
  /**
   *  @_ignore:
   */
  constructor(hash) {
    /**
     *  The ``keccak256`` of the value logged.
     */
    __publicField(this, "hash");
    /**
     *  @_ignore:
     */
    __publicField(this, "_isIndexed");
    defineProperties(this, { hash, _isIndexed: true });
  }
  /**
   *  Returns ``true`` if %%value%% is an **Indexed**.
   *
   *  This provides a Type Guard for property access.
   */
  static isIndexed(value) {
    return !!(value && value._isIndexed);
  }
}
const PanicReasons = {
  "0": "generic panic",
  "1": "assert(false)",
  "17": "arithmetic overflow",
  "18": "division or modulo by zero",
  "33": "enum overflow",
  "34": "invalid encoded storage byte array accessed",
  "49": "out-of-bounds array access; popping on an empty array",
  "50": "out-of-bounds access of an array or bytesN",
  "65": "out of memory",
  "81": "uninitialized function"
};
const BuiltinErrors = {
  "0x08c379a0": {
    signature: "Error(string)",
    name: "Error",
    inputs: ["string"],
    reason: (message) => {
      return `reverted with reason string ${JSON.stringify(message)}`;
    }
  },
  "0x4e487b71": {
    signature: "Panic(uint256)",
    name: "Panic",
    inputs: ["uint256"],
    reason: (code) => {
      let reason = "unknown panic code";
      if (code >= 0 && code <= 255 && PanicReasons[code.toString()]) {
        reason = PanicReasons[code.toString()];
      }
      return `reverted with panic code 0x${code.toString(16)} (${reason})`;
    }
  }
};
const _Interface = class _Interface {
  /**
   *  Create a new Interface for the %%fragments%%.
   */
  constructor(fragments) {
    __privateAdd(this, _Interface_instances);
    /**
     *  All the Contract ABI members (i.e. methods, events, errors, etc).
     */
    __publicField(this, "fragments");
    /**
     *  The Contract constructor.
     */
    __publicField(this, "deploy");
    /**
     *  The Fallback method, if any.
     */
    __publicField(this, "fallback");
    /**
     *  If receiving ether is supported.
     */
    __publicField(this, "receive");
    __privateAdd(this, _errors);
    __privateAdd(this, _events);
    __privateAdd(this, _functions);
    //    #structs: Map<string, StructFragment>;
    __privateAdd(this, _abiCoder);
    let abi = [];
    if (typeof fragments === "string") {
      abi = JSON.parse(fragments);
    } else {
      abi = fragments;
    }
    __privateSet(this, _functions, /* @__PURE__ */ new Map());
    __privateSet(this, _errors, /* @__PURE__ */ new Map());
    __privateSet(this, _events, /* @__PURE__ */ new Map());
    const frags = [];
    for (const a2 of abi) {
      try {
        frags.push(Fragment.from(a2));
      } catch (error) {
        console.log(`[Warning] Invalid Fragment ${JSON.stringify(a2)}:`, error.message);
      }
    }
    defineProperties(this, {
      fragments: Object.freeze(frags)
    });
    let fallback = null;
    let receive = false;
    __privateSet(this, _abiCoder, this.getAbiCoder());
    this.fragments.forEach((fragment, index) => {
      let bucket;
      switch (fragment.type) {
        case "constructor":
          if (this.deploy) {
            console.log("duplicate definition - constructor");
            return;
          }
          defineProperties(this, { deploy: fragment });
          return;
        case "fallback":
          if (fragment.inputs.length === 0) {
            receive = true;
          } else {
            assertArgument(!fallback || fragment.payable !== fallback.payable, "conflicting fallback fragments", `fragments[${index}]`, fragment);
            fallback = fragment;
            receive = fallback.payable;
          }
          return;
        case "function":
          bucket = __privateGet(this, _functions);
          break;
        case "event":
          bucket = __privateGet(this, _events);
          break;
        case "error":
          bucket = __privateGet(this, _errors);
          break;
        default:
          return;
      }
      const signature = fragment.format();
      if (bucket.has(signature)) {
        return;
      }
      bucket.set(signature, fragment);
    });
    if (!this.deploy) {
      defineProperties(this, {
        deploy: ConstructorFragment.from("constructor()")
      });
    }
    defineProperties(this, { fallback, receive });
  }
  /**
   *  Returns the entire Human-Readable ABI, as an array of
   *  signatures, optionally as %%minimal%% strings, which
   *  removes parameter names and unneceesary spaces.
   */
  format(minimal) {
    const format2 = minimal ? "minimal" : "full";
    const abi = this.fragments.map((f2) => f2.format(format2));
    return abi;
  }
  /**
   *  Return the JSON-encoded ABI. This is the format Solidiy
   *  returns.
   */
  formatJson() {
    const abi = this.fragments.map((f2) => f2.format("json"));
    return JSON.stringify(abi.map((j2) => JSON.parse(j2)));
  }
  /**
   *  The ABI coder that will be used to encode and decode binary
   *  data.
   */
  getAbiCoder() {
    return AbiCoder.defaultAbiCoder();
  }
  /**
   *  Get the function name for %%key%%, which may be a function selector,
   *  function name or function signature that belongs to the ABI.
   */
  getFunctionName(key) {
    const fragment = __privateMethod(this, _Interface_instances, getFunction_fn).call(this, key, null, false);
    assertArgument(fragment, "no matching function", "key", key);
    return fragment.name;
  }
  /**
   *  Returns true if %%key%% (a function selector, function name or
   *  function signature) is present in the ABI.
   *
   *  In the case of a function name, the name may be ambiguous, so
   *  accessing the [[FunctionFragment]] may require refinement.
   */
  hasFunction(key) {
    return !!__privateMethod(this, _Interface_instances, getFunction_fn).call(this, key, null, false);
  }
  /**
   *  Get the [[FunctionFragment]] for %%key%%, which may be a function
   *  selector, function name or function signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple functions match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single function in
   *  the ABI, this will throw.
   */
  getFunction(key, values) {
    return __privateMethod(this, _Interface_instances, getFunction_fn).call(this, key, values || null, true);
  }
  /**
   *  Iterate over all functions, calling %%callback%%, sorted by their name.
   */
  forEachFunction(callback) {
    const names2 = Array.from(__privateGet(this, _functions).keys());
    names2.sort((a2, b2) => a2.localeCompare(b2));
    for (let i = 0; i < names2.length; i++) {
      const name = names2[i];
      callback(__privateGet(this, _functions).get(name), i);
    }
  }
  /**
   *  Get the event name for %%key%%, which may be a topic hash,
   *  event name or event signature that belongs to the ABI.
   */
  getEventName(key) {
    const fragment = __privateMethod(this, _Interface_instances, getEvent_fn).call(this, key, null, false);
    assertArgument(fragment, "no matching event", "key", key);
    return fragment.name;
  }
  /**
   *  Returns true if %%key%% (an event topic hash, event name or
   *  event signature) is present in the ABI.
   *
   *  In the case of an event name, the name may be ambiguous, so
   *  accessing the [[EventFragment]] may require refinement.
   */
  hasEvent(key) {
    return !!__privateMethod(this, _Interface_instances, getEvent_fn).call(this, key, null, false);
  }
  /**
   *  Get the [[EventFragment]] for %%key%%, which may be a topic hash,
   *  event name or event signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple events match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single event in
   *  the ABI, this will throw.
   */
  getEvent(key, values) {
    return __privateMethod(this, _Interface_instances, getEvent_fn).call(this, key, values || null, true);
  }
  /**
   *  Iterate over all events, calling %%callback%%, sorted by their name.
   */
  forEachEvent(callback) {
    const names2 = Array.from(__privateGet(this, _events).keys());
    names2.sort((a2, b2) => a2.localeCompare(b2));
    for (let i = 0; i < names2.length; i++) {
      const name = names2[i];
      callback(__privateGet(this, _events).get(name), i);
    }
  }
  /**
   *  Get the [[ErrorFragment]] for %%key%%, which may be an error
   *  selector, error name or error signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple errors match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single error in
   *  the ABI, this will throw.
   */
  getError(key, values) {
    if (isHexString(key)) {
      const selector = key.toLowerCase();
      if (BuiltinErrors[selector]) {
        return ErrorFragment.from(BuiltinErrors[selector].signature);
      }
      for (const fragment of __privateGet(this, _errors).values()) {
        if (selector === fragment.selector) {
          return fragment;
        }
      }
      return null;
    }
    if (key.indexOf("(") === -1) {
      const matching = [];
      for (const [name, fragment] of __privateGet(this, _errors)) {
        if (name.split(
          "("
          /* fix:) */
        )[0] === key) {
          matching.push(fragment);
        }
      }
      if (matching.length === 0) {
        if (key === "Error") {
          return ErrorFragment.from("error Error(string)");
        }
        if (key === "Panic") {
          return ErrorFragment.from("error Panic(uint256)");
        }
        return null;
      } else if (matching.length > 1) {
        const matchStr = matching.map((m2) => JSON.stringify(m2.format())).join(", ");
        assertArgument(false, `ambiguous error description (i.e. ${matchStr})`, "name", key);
      }
      return matching[0];
    }
    key = ErrorFragment.from(key).format();
    if (key === "Error(string)") {
      return ErrorFragment.from("error Error(string)");
    }
    if (key === "Panic(uint256)") {
      return ErrorFragment.from("error Panic(uint256)");
    }
    const result = __privateGet(this, _errors).get(key);
    if (result) {
      return result;
    }
    return null;
  }
  /**
   *  Iterate over all errors, calling %%callback%%, sorted by their name.
   */
  forEachError(callback) {
    const names2 = Array.from(__privateGet(this, _errors).keys());
    names2.sort((a2, b2) => a2.localeCompare(b2));
    for (let i = 0; i < names2.length; i++) {
      const name = names2[i];
      callback(__privateGet(this, _errors).get(name), i);
    }
  }
  // Get the 4-byte selector used by Solidity to identify a function
  /*
  getSelector(fragment: ErrorFragment | FunctionFragment): string {
      if (typeof(fragment) === "string") {
          const matches: Array<Fragment> = [ ];
  
          try { matches.push(this.getFunction(fragment)); } catch (error) { }
          try { matches.push(this.getError(<string>fragment)); } catch (_) { }
  
          if (matches.length === 0) {
              logger.throwArgumentError("unknown fragment", "key", fragment);
          } else if (matches.length > 1) {
              logger.throwArgumentError("ambiguous fragment matches function and error", "key", fragment);
          }
  
          fragment = matches[0];
      }
  
      return dataSlice(id(fragment.format()), 0, 4);
  }
      */
  // Get the 32-byte topic hash used by Solidity to identify an event
  /*
  getEventTopic(fragment: EventFragment): string {
      //if (typeof(fragment) === "string") { fragment = this.getEvent(eventFragment); }
      return id(fragment.format());
  }
  */
  _decodeParams(params, data) {
    return __privateGet(this, _abiCoder).decode(params, data);
  }
  _encodeParams(params, values) {
    return __privateGet(this, _abiCoder).encode(params, values);
  }
  /**
   *  Encodes a ``tx.data`` object for deploying the Contract with
   *  the %%values%% as the constructor arguments.
   */
  encodeDeploy(values) {
    return this._encodeParams(this.deploy.inputs, values || []);
  }
  /**
   *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the
   *  specified error (see [[getError]] for valid values for
   *  %%key%%).
   *
   *  Most developers should prefer the [[parseCallResult]] method instead,
   *  which will automatically detect a ``CALL_EXCEPTION`` and throw the
   *  corresponding error.
   */
  decodeErrorResult(fragment, data) {
    if (typeof fragment === "string") {
      const f2 = this.getError(fragment);
      assertArgument(f2, "unknown error", "fragment", fragment);
      fragment = f2;
    }
    assertArgument(dataSlice(data, 0, 4) === fragment.selector, `data signature does not match error ${fragment.name}.`, "data", data);
    return this._decodeParams(fragment.inputs, dataSlice(data, 4));
  }
  /**
   *  Encodes the transaction revert data for a call result that
   *  reverted from the the Contract with the sepcified %%error%%
   *  (see [[getError]] for valid values for %%fragment%%) with the %%values%%.
   *
   *  This is generally not used by most developers, unless trying to mock
   *  a result from a Contract.
   */
  encodeErrorResult(fragment, values) {
    if (typeof fragment === "string") {
      const f2 = this.getError(fragment);
      assertArgument(f2, "unknown error", "fragment", fragment);
      fragment = f2;
    }
    return concat([
      fragment.selector,
      this._encodeParams(fragment.inputs, values || [])
    ]);
  }
  /**
   *  Decodes the %%data%% from a transaction ``tx.data`` for
   *  the function specified (see [[getFunction]] for valid values
   *  for %%fragment%%).
   *
   *  Most developers should prefer the [[parseTransaction]] method
   *  instead, which will automatically detect the fragment.
   */
  decodeFunctionData(fragment, data) {
    if (typeof fragment === "string") {
      const f2 = this.getFunction(fragment);
      assertArgument(f2, "unknown function", "fragment", fragment);
      fragment = f2;
    }
    assertArgument(dataSlice(data, 0, 4) === fragment.selector, `data signature does not match function ${fragment.name}.`, "data", data);
    return this._decodeParams(fragment.inputs, dataSlice(data, 4));
  }
  /**
   *  Encodes the ``tx.data`` for a transaction that calls the function
   *  specified (see [[getFunction]] for valid values for %%fragment%%) with
   *  the %%values%%.
   */
  encodeFunctionData(fragment, values) {
    if (typeof fragment === "string") {
      const f2 = this.getFunction(fragment);
      assertArgument(f2, "unknown function", "fragment", fragment);
      fragment = f2;
    }
    return concat([
      fragment.selector,
      this._encodeParams(fragment.inputs, values || [])
    ]);
  }
  /**
   *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the
   *  specified function (see [[getFunction]] for valid values for
   *  %%key%%).
   *
   *  Most developers should prefer the [[parseCallResult]] method instead,
   *  which will automatically detect a ``CALL_EXCEPTION`` and throw the
   *  corresponding error.
   */
  decodeFunctionResult(fragment, data) {
    if (typeof fragment === "string") {
      const f2 = this.getFunction(fragment);
      assertArgument(f2, "unknown function", "fragment", fragment);
      fragment = f2;
    }
    let message = "invalid length for result data";
    const bytes = getBytesCopy(data);
    if (bytes.length % 32 === 0) {
      try {
        return __privateGet(this, _abiCoder).decode(fragment.outputs, bytes);
      } catch (error) {
        message = "could not decode result data";
      }
    }
    assert(false, message, "BAD_DATA", {
      value: hexlify(bytes),
      info: { method: fragment.name, signature: fragment.format() }
    });
  }
  makeError(_data4, tx) {
    const data = getBytes(_data4, "data");
    const error = AbiCoder.getBuiltinCallException("call", tx, data);
    const customPrefix = "execution reverted (unknown custom error)";
    if (error.message.startsWith(customPrefix)) {
      const selector = hexlify(data.slice(0, 4));
      const ef = this.getError(selector);
      if (ef) {
        try {
          const args = __privateGet(this, _abiCoder).decode(ef.inputs, data.slice(4));
          error.revert = {
            name: ef.name,
            signature: ef.format(),
            args
          };
          error.reason = error.revert.signature;
          error.message = `execution reverted: ${error.reason}`;
        } catch (e2) {
          error.message = `execution reverted (coult not decode custom error)`;
        }
      }
    }
    const parsed = this.parseTransaction(tx);
    if (parsed) {
      error.invocation = {
        method: parsed.name,
        signature: parsed.signature,
        args: parsed.args
      };
    }
    return error;
  }
  /**
   *  Encodes the result data (e.g. from an ``eth_call``) for the
   *  specified function (see [[getFunction]] for valid values
   *  for %%fragment%%) with %%values%%.
   *
   *  This is generally not used by most developers, unless trying to mock
   *  a result from a Contract.
   */
  encodeFunctionResult(fragment, values) {
    if (typeof fragment === "string") {
      const f2 = this.getFunction(fragment);
      assertArgument(f2, "unknown function", "fragment", fragment);
      fragment = f2;
    }
    return hexlify(__privateGet(this, _abiCoder).encode(fragment.outputs, values || []));
  }
  /*
      spelunk(inputs: Array<ParamType>, values: ReadonlyArray<any>, processfunc: (type: string, value: any) => Promise<any>): Promise<Array<any>> {
          const promises: Array<Promise<>> = [ ];
          const process = function(type: ParamType, value: any): any {
              if (type.baseType === "array") {
                  return descend(type.child
              }
              if (type. === "address") {
              }
          };
  
          const descend = function (inputs: Array<ParamType>, values: ReadonlyArray<any>) {
              if (inputs.length !== values.length) { throw new Error("length mismatch"); }
              
          };
  
          const result: Array<any> = [ ];
          values.forEach((value, index) => {
              if (value == null) {
                  topics.push(null);
              } else if (param.baseType === "array" || param.baseType === "tuple") {
                  logger.throwArgumentError("filtering with tuples or arrays not supported", ("contract." + param.name), value);
              } else if (Array.isArray(value)) {
                  topics.push(value.map((value) => encodeTopic(param, value)));
              } else {
                  topics.push(encodeTopic(param, value));
              }
          });
      }
  */
  // Create the filter for the event with search criteria (e.g. for eth_filterLog)
  encodeFilterTopics(fragment, values) {
    if (typeof fragment === "string") {
      const f2 = this.getEvent(fragment);
      assertArgument(f2, "unknown event", "eventFragment", fragment);
      fragment = f2;
    }
    assert(values.length <= fragment.inputs.length, `too many arguments for ${fragment.format()}`, "UNEXPECTED_ARGUMENT", { count: values.length, expectedCount: fragment.inputs.length });
    const topics = [];
    if (!fragment.anonymous) {
      topics.push(fragment.topicHash);
    }
    const encodeTopic = (param, value) => {
      if (param.type === "string") {
        return id(value);
      } else if (param.type === "bytes") {
        return keccak256(hexlify(value));
      }
      if (param.type === "bool" && typeof value === "boolean") {
        value = value ? "0x01" : "0x00";
      } else if (param.type.match(/^u?int/)) {
        value = toBeHex(value);
      } else if (param.type.match(/^bytes/)) {
        value = zeroPadBytes(value, 32);
      } else if (param.type === "address") {
        __privateGet(this, _abiCoder).encode(["address"], [value]);
      }
      return zeroPadValue(hexlify(value), 32);
    };
    values.forEach((value, index) => {
      const param = fragment.inputs[index];
      if (!param.indexed) {
        assertArgument(value == null, "cannot filter non-indexed parameters; must be null", "contract." + param.name, value);
        return;
      }
      if (value == null) {
        topics.push(null);
      } else if (param.baseType === "array" || param.baseType === "tuple") {
        assertArgument(false, "filtering with tuples or arrays not supported", "contract." + param.name, value);
      } else if (Array.isArray(value)) {
        topics.push(value.map((value2) => encodeTopic(param, value2)));
      } else {
        topics.push(encodeTopic(param, value));
      }
    });
    while (topics.length && topics[topics.length - 1] === null) {
      topics.pop();
    }
    return topics;
  }
  encodeEventLog(fragment, values) {
    if (typeof fragment === "string") {
      const f2 = this.getEvent(fragment);
      assertArgument(f2, "unknown event", "eventFragment", fragment);
      fragment = f2;
    }
    const topics = [];
    const dataTypes = [];
    const dataValues = [];
    if (!fragment.anonymous) {
      topics.push(fragment.topicHash);
    }
    assertArgument(values.length === fragment.inputs.length, "event arguments/values mismatch", "values", values);
    fragment.inputs.forEach((param, index) => {
      const value = values[index];
      if (param.indexed) {
        if (param.type === "string") {
          topics.push(id(value));
        } else if (param.type === "bytes") {
          topics.push(keccak256(value));
        } else if (param.baseType === "tuple" || param.baseType === "array") {
          throw new Error("not implemented");
        } else {
          topics.push(__privateGet(this, _abiCoder).encode([param.type], [value]));
        }
      } else {
        dataTypes.push(param);
        dataValues.push(value);
      }
    });
    return {
      data: __privateGet(this, _abiCoder).encode(dataTypes, dataValues),
      topics
    };
  }
  // Decode a filter for the event and the search criteria
  decodeEventLog(fragment, data, topics) {
    if (typeof fragment === "string") {
      const f2 = this.getEvent(fragment);
      assertArgument(f2, "unknown event", "eventFragment", fragment);
      fragment = f2;
    }
    if (topics != null && !fragment.anonymous) {
      const eventTopic = fragment.topicHash;
      assertArgument(isHexString(topics[0], 32) && topics[0].toLowerCase() === eventTopic, "fragment/topic mismatch", "topics[0]", topics[0]);
      topics = topics.slice(1);
    }
    const indexed = [];
    const nonIndexed = [];
    const dynamic = [];
    fragment.inputs.forEach((param, index) => {
      if (param.indexed) {
        if (param.type === "string" || param.type === "bytes" || param.baseType === "tuple" || param.baseType === "array") {
          indexed.push(ParamType.from({ type: "bytes32", name: param.name }));
          dynamic.push(true);
        } else {
          indexed.push(param);
          dynamic.push(false);
        }
      } else {
        nonIndexed.push(param);
        dynamic.push(false);
      }
    });
    const resultIndexed = topics != null ? __privateGet(this, _abiCoder).decode(indexed, concat(topics)) : null;
    const resultNonIndexed = __privateGet(this, _abiCoder).decode(nonIndexed, data, true);
    const values = [];
    const keys = [];
    let nonIndexedIndex = 0, indexedIndex = 0;
    fragment.inputs.forEach((param, index) => {
      let value = null;
      if (param.indexed) {
        if (resultIndexed == null) {
          value = new Indexed(null);
        } else if (dynamic[index]) {
          value = new Indexed(resultIndexed[indexedIndex++]);
        } else {
          try {
            value = resultIndexed[indexedIndex++];
          } catch (error) {
            value = error;
          }
        }
      } else {
        try {
          value = resultNonIndexed[nonIndexedIndex++];
        } catch (error) {
          value = error;
        }
      }
      values.push(value);
      keys.push(param.name || null);
    });
    return Result.fromItems(values, keys);
  }
  /**
   *  Parses a transaction, finding the matching function and extracts
   *  the parameter values along with other useful function details.
   *
   *  If the matching function cannot be found, return null.
   */
  parseTransaction(tx) {
    const data = getBytes(tx.data, "tx.data");
    const value = getBigInt(tx.value != null ? tx.value : 0, "tx.value");
    const fragment = this.getFunction(hexlify(data.slice(0, 4)));
    if (!fragment) {
      return null;
    }
    const args = __privateGet(this, _abiCoder).decode(fragment.inputs, data.slice(4));
    return new TransactionDescription(fragment, fragment.selector, args, value);
  }
  parseCallResult(data) {
    throw new Error("@TODO");
  }
  /**
   *  Parses a receipt log, finding the matching event and extracts
   *  the parameter values along with other useful event details.
   *
   *  If the matching event cannot be found, returns null.
   */
  parseLog(log) {
    const fragment = this.getEvent(log.topics[0]);
    if (!fragment || fragment.anonymous) {
      return null;
    }
    return new LogDescription(fragment, fragment.topicHash, this.decodeEventLog(fragment, log.data, log.topics));
  }
  /**
   *  Parses a revert data, finding the matching error and extracts
   *  the parameter values along with other useful error details.
   *
   *  If the matching error cannot be found, returns null.
   */
  parseError(data) {
    const hexData = hexlify(data);
    const fragment = this.getError(dataSlice(hexData, 0, 4));
    if (!fragment) {
      return null;
    }
    const args = __privateGet(this, _abiCoder).decode(fragment.inputs, dataSlice(hexData, 4));
    return new ErrorDescription(fragment, fragment.selector, args);
  }
  /**
   *  Creates a new [[Interface]] from the ABI %%value%%.
   *
   *  The %%value%% may be provided as an existing [[Interface]] object,
   *  a JSON-encoded ABI or any Human-Readable ABI format.
   */
  static from(value) {
    if (value instanceof _Interface) {
      return value;
    }
    if (typeof value === "string") {
      return new _Interface(JSON.parse(value));
    }
    if (typeof value.formatJson === "function") {
      return new _Interface(value.formatJson());
    }
    if (typeof value.format === "function") {
      return new _Interface(value.format("json"));
    }
    return new _Interface(value);
  }
};
_errors = new WeakMap();
_events = new WeakMap();
_functions = new WeakMap();
_abiCoder = new WeakMap();
_Interface_instances = new WeakSet();
// Find a function definition by any means necessary (unless it is ambiguous)
getFunction_fn = function(key, values, forceUnique) {
  if (isHexString(key)) {
    const selector = key.toLowerCase();
    for (const fragment of __privateGet(this, _functions).values()) {
      if (selector === fragment.selector) {
        return fragment;
      }
    }
    return null;
  }
  if (key.indexOf("(") === -1) {
    const matching = [];
    for (const [name, fragment] of __privateGet(this, _functions)) {
      if (name.split(
        "("
        /* fix:) */
      )[0] === key) {
        matching.push(fragment);
      }
    }
    if (values) {
      const lastValue = values.length > 0 ? values[values.length - 1] : null;
      let valueLength = values.length;
      let allowOptions = true;
      if (Typed.isTyped(lastValue) && lastValue.type === "overrides") {
        allowOptions = false;
        valueLength--;
      }
      for (let i = matching.length - 1; i >= 0; i--) {
        const inputs = matching[i].inputs.length;
        if (inputs !== valueLength && (!allowOptions || inputs !== valueLength - 1)) {
          matching.splice(i, 1);
        }
      }
      for (let i = matching.length - 1; i >= 0; i--) {
        const inputs = matching[i].inputs;
        for (let j2 = 0; j2 < values.length; j2++) {
          if (!Typed.isTyped(values[j2])) {
            continue;
          }
          if (j2 >= inputs.length) {
            if (values[j2].type === "overrides") {
              continue;
            }
            matching.splice(i, 1);
            break;
          }
          if (values[j2].type !== inputs[j2].baseType) {
            matching.splice(i, 1);
            break;
          }
        }
      }
    }
    if (matching.length === 1 && values && values.length !== matching[0].inputs.length) {
      const lastArg = values[values.length - 1];
      if (lastArg == null || Array.isArray(lastArg) || typeof lastArg !== "object") {
        matching.splice(0, 1);
      }
    }
    if (matching.length === 0) {
      return null;
    }
    if (matching.length > 1 && forceUnique) {
      const matchStr = matching.map((m2) => JSON.stringify(m2.format())).join(", ");
      assertArgument(false, `ambiguous function description (i.e. matches ${matchStr})`, "key", key);
    }
    return matching[0];
  }
  const result = __privateGet(this, _functions).get(FunctionFragment.from(key).format());
  if (result) {
    return result;
  }
  return null;
};
// Find an event definition by any means necessary (unless it is ambiguous)
getEvent_fn = function(key, values, forceUnique) {
  if (isHexString(key)) {
    const eventTopic = key.toLowerCase();
    for (const fragment of __privateGet(this, _events).values()) {
      if (eventTopic === fragment.topicHash) {
        return fragment;
      }
    }
    return null;
  }
  if (key.indexOf("(") === -1) {
    const matching = [];
    for (const [name, fragment] of __privateGet(this, _events)) {
      if (name.split(
        "("
        /* fix:) */
      )[0] === key) {
        matching.push(fragment);
      }
    }
    if (values) {
      for (let i = matching.length - 1; i >= 0; i--) {
        if (matching[i].inputs.length < values.length) {
          matching.splice(i, 1);
        }
      }
      for (let i = matching.length - 1; i >= 0; i--) {
        const inputs = matching[i].inputs;
        for (let j2 = 0; j2 < values.length; j2++) {
          if (!Typed.isTyped(values[j2])) {
            continue;
          }
          if (values[j2].type !== inputs[j2].baseType) {
            matching.splice(i, 1);
            break;
          }
        }
      }
    }
    if (matching.length === 0) {
      return null;
    }
    if (matching.length > 1 && forceUnique) {
      const matchStr = matching.map((m2) => JSON.stringify(m2.format())).join(", ");
      assertArgument(false, `ambiguous event description (i.e. matches ${matchStr})`, "key", key);
    }
    return matching[0];
  }
  const result = __privateGet(this, _events).get(EventFragment.from(key).format());
  if (result) {
    return result;
  }
  return null;
};
let Interface = _Interface;
const BN_0$2 = BigInt(0);
function getValue(value) {
  if (value == null) {
    return null;
  }
  return value;
}
function toJson(value) {
  if (value == null) {
    return null;
  }
  return value.toString();
}
class FeeData {
  /**
   *  Creates a new FeeData for %%gasPrice%%, %%maxFeePerGas%% and
   *  %%maxPriorityFeePerGas%%.
   */
  constructor(gasPrice, maxFeePerGas, maxPriorityFeePerGas) {
    /**
     *  The gas price for legacy networks.
     */
    __publicField(this, "gasPrice");
    /**
     *  The maximum fee to pay per gas.
     *
     *  The base fee per gas is defined by the network and based on
     *  congestion, increasing the cost during times of heavy load
     *  and lowering when less busy.
     *
     *  The actual fee per gas will be the base fee for the block
     *  and the priority fee, up to the max fee per gas.
     *
     *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))
     */
    __publicField(this, "maxFeePerGas");
    /**
     *  The additional amout to pay per gas to encourage a validator
     *  to include the transaction.
     *
     *  The purpose of this is to compensate the validator for the
     *  adjusted risk for including a given transaction.
     *
     *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))
     */
    __publicField(this, "maxPriorityFeePerGas");
    defineProperties(this, {
      gasPrice: getValue(gasPrice),
      maxFeePerGas: getValue(maxFeePerGas),
      maxPriorityFeePerGas: getValue(maxPriorityFeePerGas)
    });
  }
  /**
   *  Returns a JSON-friendly value.
   */
  toJSON() {
    const { gasPrice, maxFeePerGas, maxPriorityFeePerGas } = this;
    return {
      _type: "FeeData",
      gasPrice: toJson(gasPrice),
      maxFeePerGas: toJson(maxFeePerGas),
      maxPriorityFeePerGas: toJson(maxPriorityFeePerGas)
    };
  }
}
function copyRequest(req) {
  const result = {};
  if (req.to) {
    result.to = req.to;
  }
  if (req.from) {
    result.from = req.from;
  }
  if (req.data) {
    result.data = hexlify(req.data);
  }
  const bigIntKeys = "chainId,gasLimit,gasPrice,maxFeePerBlobGas,maxFeePerGas,maxPriorityFeePerGas,value".split(/,/);
  for (const key of bigIntKeys) {
    if (!(key in req) || req[key] == null) {
      continue;
    }
    result[key] = getBigInt(req[key], `request.${key}`);
  }
  const numberKeys = "type,nonce".split(/,/);
  for (const key of numberKeys) {
    if (!(key in req) || req[key] == null) {
      continue;
    }
    result[key] = getNumber(req[key], `request.${key}`);
  }
  if (req.accessList) {
    result.accessList = accessListify(req.accessList);
  }
  if ("blockTag" in req) {
    result.blockTag = req.blockTag;
  }
  if ("enableCcipRead" in req) {
    result.enableCcipRead = !!req.enableCcipRead;
  }
  if ("customData" in req) {
    result.customData = req.customData;
  }
  if ("blobVersionedHashes" in req && req.blobVersionedHashes) {
    result.blobVersionedHashes = req.blobVersionedHashes.slice();
  }
  if ("kzg" in req) {
    result.kzg = req.kzg;
  }
  if ("blobs" in req && req.blobs) {
    result.blobs = req.blobs.map((b2) => {
      if (isBytesLike(b2)) {
        return hexlify(b2);
      }
      return Object.assign({}, b2);
    });
  }
  return result;
}
class Block {
  /**
   *  Create a new **Block** object.
   *
   *  This should generally not be necessary as the unless implementing a
   *  low-level library.
   */
  constructor(block, provider) {
    /**
     *  The provider connected to the block used to fetch additional details
     *  if necessary.
     */
    __publicField(this, "provider");
    /**
     *  The block number, sometimes called the block height. This is a
     *  sequential number that is one higher than the parent block.
     */
    __publicField(this, "number");
    /**
     *  The block hash.
     *
     *  This hash includes all properties, so can be safely used to identify
     *  an exact set of block properties.
     */
    __publicField(this, "hash");
    /**
     *  The timestamp for this block, which is the number of seconds since
     *  epoch that this block was included.
     */
    __publicField(this, "timestamp");
    /**
     *  The block hash of the parent block.
     */
    __publicField(this, "parentHash");
    /**
     *  The hash tree root of the parent beacon block for the given
     *  execution block. See [[link-eip-4788]].
     */
    __publicField(this, "parentBeaconBlockRoot");
    /**
     *  The nonce.
     *
     *  On legacy networks, this is the random number inserted which
     *  permitted the difficulty target to be reached.
     */
    __publicField(this, "nonce");
    /**
     *  The difficulty target.
     *
     *  On legacy networks, this is the proof-of-work target required
     *  for a block to meet the protocol rules to be included.
     *
     *  On modern networks, this is a random number arrived at using
     *  randao.  @TODO: Find links?
     */
    __publicField(this, "difficulty");
    /**
     *  The total gas limit for this block.
     */
    __publicField(this, "gasLimit");
    /**
     *  The total gas used in this block.
     */
    __publicField(this, "gasUsed");
    /**
     *  The root hash for the global state after applying changes
     *  in this block.
     */
    __publicField(this, "stateRoot");
    /**
     *  The hash of the transaction receipts trie.
     */
    __publicField(this, "receiptsRoot");
    /**
     *  The total amount of blob gas consumed by the transactions
     *  within the block. See [[link-eip-4844]].
     */
    __publicField(this, "blobGasUsed");
    /**
     *  The running total of blob gas consumed in excess of the
     *  target, prior to the block. See [[link-eip-4844]].
     */
    __publicField(this, "excessBlobGas");
    /**
     *  The miner coinbase address, wihch receives any subsidies for
     *  including this block.
     */
    __publicField(this, "miner");
    /**
     *  The latest RANDAO mix of the post beacon state of
     *  the previous block.
     */
    __publicField(this, "prevRandao");
    /**
     *  Any extra data the validator wished to include.
     */
    __publicField(this, "extraData");
    /**
     *  The base fee per gas that all transactions in this block were
     *  charged.
     *
     *  This adjusts after each block, depending on how congested the network
     *  is.
     */
    __publicField(this, "baseFeePerGas");
    __privateAdd(this, _transactions);
    __privateSet(this, _transactions, block.transactions.map((tx) => {
      if (typeof tx !== "string") {
        return new TransactionResponse(tx, provider);
      }
      return tx;
    }));
    defineProperties(this, {
      provider,
      hash: getValue(block.hash),
      number: block.number,
      timestamp: block.timestamp,
      parentHash: block.parentHash,
      parentBeaconBlockRoot: block.parentBeaconBlockRoot,
      nonce: block.nonce,
      difficulty: block.difficulty,
      gasLimit: block.gasLimit,
      gasUsed: block.gasUsed,
      blobGasUsed: block.blobGasUsed,
      excessBlobGas: block.excessBlobGas,
      miner: block.miner,
      prevRandao: getValue(block.prevRandao),
      extraData: block.extraData,
      baseFeePerGas: getValue(block.baseFeePerGas),
      stateRoot: block.stateRoot,
      receiptsRoot: block.receiptsRoot
    });
  }
  /**
   *  Returns the list of transaction hashes, in the order
   *  they were executed within the block.
   */
  get transactions() {
    return __privateGet(this, _transactions).map((tx) => {
      if (typeof tx === "string") {
        return tx;
      }
      return tx.hash;
    });
  }
  /**
   *  Returns the complete transactions, in the order they
   *  were executed within the block.
   *
   *  This is only available for blocks which prefetched
   *  transactions, by passing ``true`` to %%prefetchTxs%%
   *  into [[Provider-getBlock]].
   */
  get prefetchedTransactions() {
    const txs = __privateGet(this, _transactions).slice();
    if (txs.length === 0) {
      return [];
    }
    assert(typeof txs[0] === "object", "transactions were not prefetched with block request", "UNSUPPORTED_OPERATION", {
      operation: "transactionResponses()"
    });
    return txs;
  }
  /**
   *  Returns a JSON-friendly value.
   */
  toJSON() {
    const { baseFeePerGas, difficulty, extraData, gasLimit, gasUsed, hash, miner, prevRandao, nonce, number, parentHash, parentBeaconBlockRoot, stateRoot, receiptsRoot, timestamp, transactions } = this;
    return {
      _type: "Block",
      baseFeePerGas: toJson(baseFeePerGas),
      difficulty: toJson(difficulty),
      extraData,
      gasLimit: toJson(gasLimit),
      gasUsed: toJson(gasUsed),
      blobGasUsed: toJson(this.blobGasUsed),
      excessBlobGas: toJson(this.excessBlobGas),
      hash,
      miner,
      prevRandao,
      nonce,
      number,
      parentHash,
      timestamp,
      parentBeaconBlockRoot,
      stateRoot,
      receiptsRoot,
      transactions
    };
  }
  [Symbol.iterator]() {
    let index = 0;
    const txs = this.transactions;
    return {
      next: () => {
        if (index < this.length) {
          return {
            value: txs[index++],
            done: false
          };
        }
        return { value: void 0, done: true };
      }
    };
  }
  /**
   *  The number of transactions in this block.
   */
  get length() {
    return __privateGet(this, _transactions).length;
  }
  /**
   *  The [[link-js-date]] this block was included at.
   */
  get date() {
    if (this.timestamp == null) {
      return null;
    }
    return new Date(this.timestamp * 1e3);
  }
  /**
   *  Get the transaction at %%indexe%% within this block.
   */
  async getTransaction(indexOrHash) {
    let tx = void 0;
    if (typeof indexOrHash === "number") {
      tx = __privateGet(this, _transactions)[indexOrHash];
    } else {
      const hash = indexOrHash.toLowerCase();
      for (const v3 of __privateGet(this, _transactions)) {
        if (typeof v3 === "string") {
          if (v3 !== hash) {
            continue;
          }
          tx = v3;
          break;
        } else {
          if (v3.hash !== hash) {
            continue;
          }
          tx = v3;
          break;
        }
      }
    }
    if (tx == null) {
      throw new Error("no such tx");
    }
    if (typeof tx === "string") {
      return await this.provider.getTransaction(tx);
    } else {
      return tx;
    }
  }
  /**
   *  If a **Block** was fetched with a request to include the transactions
   *  this will allow synchronous access to those transactions.
   *
   *  If the transactions were not prefetched, this will throw.
   */
  getPrefetchedTransaction(indexOrHash) {
    const txs = this.prefetchedTransactions;
    if (typeof indexOrHash === "number") {
      return txs[indexOrHash];
    }
    indexOrHash = indexOrHash.toLowerCase();
    for (const tx of txs) {
      if (tx.hash === indexOrHash) {
        return tx;
      }
    }
    assertArgument(false, "no matching transaction", "indexOrHash", indexOrHash);
  }
  /**
   *  Returns true if this block been mined. This provides a type guard
   *  for all properties on a [[MinedBlock]].
   */
  isMined() {
    return !!this.hash;
  }
  /**
   *  Returns true if this block is an [[link-eip-2930]] block.
   */
  isLondon() {
    return !!this.baseFeePerGas;
  }
  /**
   *  @_ignore:
   */
  orphanedEvent() {
    if (!this.isMined()) {
      throw new Error("");
    }
    return createOrphanedBlockFilter(this);
  }
}
_transactions = new WeakMap();
class Log {
  /**
   *  @_ignore:
   */
  constructor(log, provider) {
    /**
     *  The provider connected to the log used to fetch additional details
     *  if necessary.
     */
    __publicField(this, "provider");
    /**
     *  The transaction hash of the transaction this log occurred in. Use the
     *  [[Log-getTransaction]] to get the [[TransactionResponse]].
     */
    __publicField(this, "transactionHash");
    /**
     *  The block hash of the block this log occurred in. Use the
     *  [[Log-getBlock]] to get the [[Block]].
     */
    __publicField(this, "blockHash");
    /**
     *  The block number of the block this log occurred in. It is preferred
     *  to use the [[Block-hash]] when fetching the related [[Block]],
     *  since in the case of an orphaned block, the block at that height may
     *  have changed.
     */
    __publicField(this, "blockNumber");
    /**
     *  If the **Log** represents a block that was removed due to an orphaned
     *  block, this will be true.
     *
     *  This can only happen within an orphan event listener.
     */
    __publicField(this, "removed");
    /**
     *  The address of the contract that emitted this log.
     */
    __publicField(this, "address");
    /**
     *  The data included in this log when it was emitted.
     */
    __publicField(this, "data");
    /**
     *  The indexed topics included in this log when it was emitted.
     *
     *  All topics are included in the bloom filters, so they can be
     *  efficiently filtered using the [[Provider-getLogs]] method.
     */
    __publicField(this, "topics");
    /**
     *  The index within the block this log occurred at. This is generally
     *  not useful to developers, but can be used with the various roots
     *  to proof inclusion within a block.
     */
    __publicField(this, "index");
    /**
     *  The index within the transaction of this log.
     */
    __publicField(this, "transactionIndex");
    this.provider = provider;
    const topics = Object.freeze(log.topics.slice());
    defineProperties(this, {
      transactionHash: log.transactionHash,
      blockHash: log.blockHash,
      blockNumber: log.blockNumber,
      removed: log.removed,
      address: log.address,
      data: log.data,
      topics,
      index: log.index,
      transactionIndex: log.transactionIndex
    });
  }
  /**
   *  Returns a JSON-compatible object.
   */
  toJSON() {
    const { address, blockHash, blockNumber, data, index, removed, topics, transactionHash, transactionIndex } = this;
    return {
      _type: "log",
      address,
      blockHash,
      blockNumber,
      data,
      index,
      removed,
      topics,
      transactionHash,
      transactionIndex
    };
  }
  /**
   *  Returns the block that this log occurred in.
   */
  async getBlock() {
    const block = await this.provider.getBlock(this.blockHash);
    assert(!!block, "failed to find transaction", "UNKNOWN_ERROR", {});
    return block;
  }
  /**
   *  Returns the transaction that this log occurred in.
   */
  async getTransaction() {
    const tx = await this.provider.getTransaction(this.transactionHash);
    assert(!!tx, "failed to find transaction", "UNKNOWN_ERROR", {});
    return tx;
  }
  /**
   *  Returns the transaction receipt fot the transaction that this
   *  log occurred in.
   */
  async getTransactionReceipt() {
    const receipt = await this.provider.getTransactionReceipt(this.transactionHash);
    assert(!!receipt, "failed to find transaction receipt", "UNKNOWN_ERROR", {});
    return receipt;
  }
  /**
   *  @_ignore:
   */
  removedEvent() {
    return createRemovedLogFilter(this);
  }
}
class TransactionReceipt {
  /**
   *  @_ignore:
   */
  constructor(tx, provider) {
    /**
     *  The provider connected to the log used to fetch additional details
     *  if necessary.
     */
    __publicField(this, "provider");
    /**
     *  The address the transaction was sent to.
     */
    __publicField(this, "to");
    /**
     *  The sender of the transaction.
     */
    __publicField(this, "from");
    /**
     *  The address of the contract if the transaction was directly
     *  responsible for deploying one.
     *
     *  This is non-null **only** if the ``to`` is empty and the ``data``
     *  was successfully executed as initcode.
     */
    __publicField(this, "contractAddress");
    /**
     *  The transaction hash.
     */
    __publicField(this, "hash");
    /**
     *  The index of this transaction within the block transactions.
     */
    __publicField(this, "index");
    /**
     *  The block hash of the [[Block]] this transaction was included in.
     */
    __publicField(this, "blockHash");
    /**
     *  The block number of the [[Block]] this transaction was included in.
     */
    __publicField(this, "blockNumber");
    /**
     *  The bloom filter bytes that represent all logs that occurred within
     *  this transaction. This is generally not useful for most developers,
     *  but can be used to validate the included logs.
     */
    __publicField(this, "logsBloom");
    /**
     *  The actual amount of gas used by this transaction.
     *
     *  When creating a transaction, the amount of gas that will be used can
     *  only be approximated, but the sender must pay the gas fee for the
     *  entire gas limit. After the transaction, the difference is refunded.
     */
    __publicField(this, "gasUsed");
    /**
     *  The gas used for BLObs. See [[link-eip-4844]].
     */
    __publicField(this, "blobGasUsed");
    /**
     *  The amount of gas used by all transactions within the block for this
     *  and all transactions with a lower ``index``.
     *
     *  This is generally not useful for developers but can be used to
     *  validate certain aspects of execution.
     */
    __publicField(this, "cumulativeGasUsed");
    /**
     *  The actual gas price used during execution.
     *
     *  Due to the complexity of [[link-eip-1559]] this value can only
     *  be caluclated after the transaction has been mined, snce the base
     *  fee is protocol-enforced.
     */
    __publicField(this, "gasPrice");
    /**
     *  The price paid per BLOB in gas. See [[link-eip-4844]].
     */
    __publicField(this, "blobGasPrice");
    /**
     *  The [[link-eip-2718]] transaction type.
     */
    __publicField(this, "type");
    //readonly byzantium!: boolean;
    /**
     *  The status of this transaction, indicating success (i.e. ``1``) or
     *  a revert (i.e. ``0``).
     *
     *  This is available in post-byzantium blocks, but some backends may
     *  backfill this value.
     */
    __publicField(this, "status");
    /**
     *  The root hash of this transaction.
     *
     *  This is no present and was only included in pre-byzantium blocks, but
     *  could be used to validate certain parts of the receipt.
     */
    __publicField(this, "root");
    __privateAdd(this, _logs);
    __privateSet(this, _logs, Object.freeze(tx.logs.map((log) => {
      return new Log(log, provider);
    })));
    let gasPrice = BN_0$2;
    if (tx.effectiveGasPrice != null) {
      gasPrice = tx.effectiveGasPrice;
    } else if (tx.gasPrice != null) {
      gasPrice = tx.gasPrice;
    }
    defineProperties(this, {
      provider,
      to: tx.to,
      from: tx.from,
      contractAddress: tx.contractAddress,
      hash: tx.hash,
      index: tx.index,
      blockHash: tx.blockHash,
      blockNumber: tx.blockNumber,
      logsBloom: tx.logsBloom,
      gasUsed: tx.gasUsed,
      cumulativeGasUsed: tx.cumulativeGasUsed,
      blobGasUsed: tx.blobGasUsed,
      gasPrice,
      blobGasPrice: tx.blobGasPrice,
      type: tx.type,
      //byzantium: tx.byzantium,
      status: tx.status,
      root: tx.root
    });
  }
  /**
   *  The logs for this transaction.
   */
  get logs() {
    return __privateGet(this, _logs);
  }
  /**
   *  Returns a JSON-compatible representation.
   */
  toJSON() {
    const {
      to: to2,
      from,
      contractAddress,
      hash,
      index,
      blockHash,
      blockNumber,
      logsBloom,
      logs,
      //byzantium, 
      status,
      root
    } = this;
    return {
      _type: "TransactionReceipt",
      blockHash,
      blockNumber,
      //byzantium, 
      contractAddress,
      cumulativeGasUsed: toJson(this.cumulativeGasUsed),
      from,
      gasPrice: toJson(this.gasPrice),
      blobGasUsed: toJson(this.blobGasUsed),
      blobGasPrice: toJson(this.blobGasPrice),
      gasUsed: toJson(this.gasUsed),
      hash,
      index,
      logs,
      logsBloom,
      root,
      status,
      to: to2
    };
  }
  /**
   *  @_ignore:
   */
  get length() {
    return this.logs.length;
  }
  [Symbol.iterator]() {
    let index = 0;
    return {
      next: () => {
        if (index < this.length) {
          return { value: this.logs[index++], done: false };
        }
        return { value: void 0, done: true };
      }
    };
  }
  /**
   *  The total fee for this transaction, in wei.
   */
  get fee() {
    return this.gasUsed * this.gasPrice;
  }
  /**
   *  Resolves to the block this transaction occurred in.
   */
  async getBlock() {
    const block = await this.provider.getBlock(this.blockHash);
    if (block == null) {
      throw new Error("TODO");
    }
    return block;
  }
  /**
   *  Resolves to the transaction this transaction occurred in.
   */
  async getTransaction() {
    const tx = await this.provider.getTransaction(this.hash);
    if (tx == null) {
      throw new Error("TODO");
    }
    return tx;
  }
  /**
   *  Resolves to the return value of the execution of this transaction.
   *
   *  Support for this feature is limited, as it requires an archive node
   *  with the ``debug_`` or ``trace_`` API enabled.
   */
  async getResult() {
    return await this.provider.getTransactionResult(this.hash);
  }
  /**
   *  Resolves to the number of confirmations this transaction has.
   */
  async confirmations() {
    return await this.provider.getBlockNumber() - this.blockNumber + 1;
  }
  /**
   *  @_ignore:
   */
  removedEvent() {
    return createRemovedTransactionFilter(this);
  }
  /**
   *  @_ignore:
   */
  reorderedEvent(other) {
    assert(!other || other.isMined(), "unmined 'other' transction cannot be orphaned", "UNSUPPORTED_OPERATION", { operation: "reorderedEvent(other)" });
    return createReorderedTransactionFilter(this, other);
  }
}
_logs = new WeakMap();
const _TransactionResponse = class _TransactionResponse {
  /**
   *  @_ignore:
   */
  constructor(tx, provider) {
    /**
     *  The provider this is connected to, which will influence how its
     *  methods will resolve its async inspection methods.
     */
    __publicField(this, "provider");
    /**
     *  The block number of the block that this transaction was included in.
     *
     *  This is ``null`` for pending transactions.
     */
    __publicField(this, "blockNumber");
    /**
     *  The blockHash of the block that this transaction was included in.
     *
     *  This is ``null`` for pending transactions.
     */
    __publicField(this, "blockHash");
    /**
     *  The index within the block that this transaction resides at.
     */
    __publicField(this, "index");
    /**
     *  The transaction hash.
     */
    __publicField(this, "hash");
    /**
     *  The [[link-eip-2718]] transaction envelope type. This is
     *  ``0`` for legacy transactions types.
     */
    __publicField(this, "type");
    /**
     *  The receiver of this transaction.
     *
     *  If ``null``, then the transaction is an initcode transaction.
     *  This means the result of executing the [[data]] will be deployed
     *  as a new contract on chain (assuming it does not revert) and the
     *  address may be computed using [[getCreateAddress]].
     */
    __publicField(this, "to");
    /**
     *  The sender of this transaction. It is implicitly computed
     *  from the transaction pre-image hash (as the digest) and the
     *  [[signature]] using ecrecover.
     */
    __publicField(this, "from");
    /**
     *  The nonce, which is used to prevent replay attacks and offer
     *  a method to ensure transactions from a given sender are explicitly
     *  ordered.
     *
     *  When sending a transaction, this must be equal to the number of
     *  transactions ever sent by [[from]].
     */
    __publicField(this, "nonce");
    /**
     *  The maximum units of gas this transaction can consume. If execution
     *  exceeds this, the entries transaction is reverted and the sender
     *  is charged for the full amount, despite not state changes being made.
     */
    __publicField(this, "gasLimit");
    /**
     *  The gas price can have various values, depending on the network.
     *
     *  In modern networks, for transactions that are included this is
     *  the //effective gas price// (the fee per gas that was actually
     *  charged), while for transactions that have not been included yet
     *  is the [[maxFeePerGas]].
     *
     *  For legacy transactions, or transactions on legacy networks, this
     *  is the fee that will be charged per unit of gas the transaction
     *  consumes.
     */
    __publicField(this, "gasPrice");
    /**
     *  The maximum priority fee (per unit of gas) to allow a
     *  validator to charge the sender. This is inclusive of the
     *  [[maxFeeFeePerGas]].
     */
    __publicField(this, "maxPriorityFeePerGas");
    /**
     *  The maximum fee (per unit of gas) to allow this transaction
     *  to charge the sender.
     */
    __publicField(this, "maxFeePerGas");
    /**
     *  The [[link-eip-4844]] max fee per BLOb gas.
     */
    __publicField(this, "maxFeePerBlobGas");
    /**
     *  The data.
     */
    __publicField(this, "data");
    /**
     *  The value, in wei. Use [[formatEther]] to format this value
     *  as ether.
     */
    __publicField(this, "value");
    /**
     *  The chain ID.
     */
    __publicField(this, "chainId");
    /**
     *  The signature.
     */
    __publicField(this, "signature");
    /**
     *  The [[link-eip-2930]] access list for transaction types that
     *  support it, otherwise ``null``.
     */
    __publicField(this, "accessList");
    /**
     *  The [[link-eip-4844]] BLOb versioned hashes.
     */
    __publicField(this, "blobVersionedHashes");
    __privateAdd(this, _startBlock);
    this.provider = provider;
    this.blockNumber = tx.blockNumber != null ? tx.blockNumber : null;
    this.blockHash = tx.blockHash != null ? tx.blockHash : null;
    this.hash = tx.hash;
    this.index = tx.index;
    this.type = tx.type;
    this.from = tx.from;
    this.to = tx.to || null;
    this.gasLimit = tx.gasLimit;
    this.nonce = tx.nonce;
    this.data = tx.data;
    this.value = tx.value;
    this.gasPrice = tx.gasPrice;
    this.maxPriorityFeePerGas = tx.maxPriorityFeePerGas != null ? tx.maxPriorityFeePerGas : null;
    this.maxFeePerGas = tx.maxFeePerGas != null ? tx.maxFeePerGas : null;
    this.maxFeePerBlobGas = tx.maxFeePerBlobGas != null ? tx.maxFeePerBlobGas : null;
    this.chainId = tx.chainId;
    this.signature = tx.signature;
    this.accessList = tx.accessList != null ? tx.accessList : null;
    this.blobVersionedHashes = tx.blobVersionedHashes != null ? tx.blobVersionedHashes : null;
    __privateSet(this, _startBlock, -1);
  }
  /**
   *  Returns a JSON-compatible representation of this transaction.
   */
  toJSON() {
    const { blockNumber, blockHash, index, hash, type, to: to2, from, nonce, data, signature, accessList, blobVersionedHashes } = this;
    return {
      _type: "TransactionResponse",
      accessList,
      blockNumber,
      blockHash,
      blobVersionedHashes,
      chainId: toJson(this.chainId),
      data,
      from,
      gasLimit: toJson(this.gasLimit),
      gasPrice: toJson(this.gasPrice),
      hash,
      maxFeePerGas: toJson(this.maxFeePerGas),
      maxPriorityFeePerGas: toJson(this.maxPriorityFeePerGas),
      maxFeePerBlobGas: toJson(this.maxFeePerBlobGas),
      nonce,
      signature,
      to: to2,
      index,
      type,
      value: toJson(this.value)
    };
  }
  /**
   *  Resolves to the Block that this transaction was included in.
   *
   *  This will return null if the transaction has not been included yet.
   */
  async getBlock() {
    let blockNumber = this.blockNumber;
    if (blockNumber == null) {
      const tx = await this.getTransaction();
      if (tx) {
        blockNumber = tx.blockNumber;
      }
    }
    if (blockNumber == null) {
      return null;
    }
    const block = this.provider.getBlock(blockNumber);
    if (block == null) {
      throw new Error("TODO");
    }
    return block;
  }
  /**
   *  Resolves to this transaction being re-requested from the
   *  provider. This can be used if you have an unmined transaction
   *  and wish to get an up-to-date populated instance.
   */
  async getTransaction() {
    return this.provider.getTransaction(this.hash);
  }
  /**
   *  Resolve to the number of confirmations this transaction has.
   */
  async confirmations() {
    if (this.blockNumber == null) {
      const { tx, blockNumber: blockNumber2 } = await resolveProperties({
        tx: this.getTransaction(),
        blockNumber: this.provider.getBlockNumber()
      });
      if (tx == null || tx.blockNumber == null) {
        return 0;
      }
      return blockNumber2 - tx.blockNumber + 1;
    }
    const blockNumber = await this.provider.getBlockNumber();
    return blockNumber - this.blockNumber + 1;
  }
  /**
   *  Resolves once this transaction has been mined and has
   *  %%confirms%% blocks including it (default: ``1``) with an
   *  optional %%timeout%%.
   *
   *  This can resolve to ``null`` only if %%confirms%% is ``0``
   *  and the transaction has not been mined, otherwise this will
   *  wait until enough confirmations have completed.
   */
  async wait(_confirms, _timeout2) {
    const confirms = _confirms == null ? 1 : _confirms;
    const timeout = _timeout2 == null ? 0 : _timeout2;
    let startBlock = __privateGet(this, _startBlock);
    let nextScan = -1;
    let stopScanning = startBlock === -1 ? true : false;
    const checkReplacement = async () => {
      if (stopScanning) {
        return null;
      }
      const { blockNumber, nonce } = await resolveProperties({
        blockNumber: this.provider.getBlockNumber(),
        nonce: this.provider.getTransactionCount(this.from)
      });
      if (nonce < this.nonce) {
        startBlock = blockNumber;
        return;
      }
      if (stopScanning) {
        return null;
      }
      const mined = await this.getTransaction();
      if (mined && mined.blockNumber != null) {
        return;
      }
      if (nextScan === -1) {
        nextScan = startBlock - 3;
        if (nextScan < __privateGet(this, _startBlock)) {
          nextScan = __privateGet(this, _startBlock);
        }
      }
      while (nextScan <= blockNumber) {
        if (stopScanning) {
          return null;
        }
        const block = await this.provider.getBlock(nextScan, true);
        if (block == null) {
          return;
        }
        for (const hash of block) {
          if (hash === this.hash) {
            return;
          }
        }
        for (let i = 0; i < block.length; i++) {
          const tx = await block.getTransaction(i);
          if (tx.from === this.from && tx.nonce === this.nonce) {
            if (stopScanning) {
              return null;
            }
            const receipt2 = await this.provider.getTransactionReceipt(tx.hash);
            if (receipt2 == null) {
              return;
            }
            if (blockNumber - receipt2.blockNumber + 1 < confirms) {
              return;
            }
            let reason = "replaced";
            if (tx.data === this.data && tx.to === this.to && tx.value === this.value) {
              reason = "repriced";
            } else if (tx.data === "0x" && tx.from === tx.to && tx.value === BN_0$2) {
              reason = "cancelled";
            }
            assert(false, "transaction was replaced", "TRANSACTION_REPLACED", {
              cancelled: reason === "replaced" || reason === "cancelled",
              reason,
              replacement: tx.replaceableTransaction(startBlock),
              hash: tx.hash,
              receipt: receipt2
            });
          }
        }
        nextScan++;
      }
      return;
    };
    const checkReceipt = (receipt2) => {
      if (receipt2 == null || receipt2.status !== 0) {
        return receipt2;
      }
      assert(false, "transaction execution reverted", "CALL_EXCEPTION", {
        action: "sendTransaction",
        data: null,
        reason: null,
        invocation: null,
        revert: null,
        transaction: {
          to: receipt2.to,
          from: receipt2.from,
          data: ""
          // @TODO: in v7, split out sendTransaction properties
        },
        receipt: receipt2
      });
    };
    const receipt = await this.provider.getTransactionReceipt(this.hash);
    if (confirms === 0) {
      return checkReceipt(receipt);
    }
    if (receipt) {
      if (await receipt.confirmations() >= confirms) {
        return checkReceipt(receipt);
      }
    } else {
      await checkReplacement();
      if (confirms === 0) {
        return null;
      }
    }
    const waiter = new Promise((resolve, reject) => {
      const cancellers = [];
      const cancel = () => {
        cancellers.forEach((c) => c());
      };
      cancellers.push(() => {
        stopScanning = true;
      });
      if (timeout > 0) {
        const timer = setTimeout(() => {
          cancel();
          reject(makeError("wait for transaction timeout", "TIMEOUT"));
        }, timeout);
        cancellers.push(() => {
          clearTimeout(timer);
        });
      }
      const txListener = async (receipt2) => {
        if (await receipt2.confirmations() >= confirms) {
          cancel();
          try {
            resolve(checkReceipt(receipt2));
          } catch (error) {
            reject(error);
          }
        }
      };
      cancellers.push(() => {
        this.provider.off(this.hash, txListener);
      });
      this.provider.on(this.hash, txListener);
      if (startBlock >= 0) {
        const replaceListener = async () => {
          try {
            await checkReplacement();
          } catch (error) {
            if (isError(error, "TRANSACTION_REPLACED")) {
              cancel();
              reject(error);
              return;
            }
          }
          if (!stopScanning) {
            this.provider.once("block", replaceListener);
          }
        };
        cancellers.push(() => {
          this.provider.off("block", replaceListener);
        });
        this.provider.once("block", replaceListener);
      }
    });
    return await waiter;
  }
  /**
   *  Returns ``true`` if this transaction has been included.
   *
   *  This is effective only as of the time the TransactionResponse
   *  was instantiated. To get up-to-date information, use
   *  [[getTransaction]].
   *
   *  This provides a Type Guard that this transaction will have
   *  non-null property values for properties that are null for
   *  unmined transactions.
   */
  isMined() {
    return this.blockHash != null;
  }
  /**
   *  Returns true if the transaction is a legacy (i.e. ``type == 0``)
   *  transaction.
   *
   *  This provides a Type Guard that this transaction will have
   *  the ``null``-ness for hardfork-specific properties set correctly.
   */
  isLegacy() {
    return this.type === 0;
  }
  /**
   *  Returns true if the transaction is a Berlin (i.e. ``type == 1``)
   *  transaction. See [[link-eip-2070]].
   *
   *  This provides a Type Guard that this transaction will have
   *  the ``null``-ness for hardfork-specific properties set correctly.
   */
  isBerlin() {
    return this.type === 1;
  }
  /**
   *  Returns true if the transaction is a London (i.e. ``type == 2``)
   *  transaction. See [[link-eip-1559]].
   *
   *  This provides a Type Guard that this transaction will have
   *  the ``null``-ness for hardfork-specific properties set correctly.
   */
  isLondon() {
    return this.type === 2;
  }
  /**
   *  Returns true if hte transaction is a Cancun (i.e. ``type == 3``)
   *  transaction. See [[link-eip-4844]].
   */
  isCancun() {
    return this.type === 3;
  }
  /**
   *  Returns a filter which can be used to listen for orphan events
   *  that evict this transaction.
   */
  removedEvent() {
    assert(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" });
    return createRemovedTransactionFilter(this);
  }
  /**
   *  Returns a filter which can be used to listen for orphan events
   *  that re-order this event against %%other%%.
   */
  reorderedEvent(other) {
    assert(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" });
    assert(!other || other.isMined(), "unmined 'other' transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" });
    return createReorderedTransactionFilter(this, other);
  }
  /**
   *  Returns a new TransactionResponse instance which has the ability to
   *  detect (and throw an error) if the transaction is replaced, which
   *  will begin scanning at %%startBlock%%.
   *
   *  This should generally not be used by developers and is intended
   *  primarily for internal use. Setting an incorrect %%startBlock%% can
   *  have devastating performance consequences if used incorrectly.
   */
  replaceableTransaction(startBlock) {
    assertArgument(Number.isInteger(startBlock) && startBlock >= 0, "invalid startBlock", "startBlock", startBlock);
    const tx = new _TransactionResponse(this, this.provider);
    __privateSet(tx, _startBlock, startBlock);
    return tx;
  }
};
_startBlock = new WeakMap();
let TransactionResponse = _TransactionResponse;
function createOrphanedBlockFilter(block) {
  return { orphan: "drop-block", hash: block.hash, number: block.number };
}
function createReorderedTransactionFilter(tx, other) {
  return { orphan: "reorder-transaction", tx, other };
}
function createRemovedTransactionFilter(tx) {
  return { orphan: "drop-transaction", tx };
}
function createRemovedLogFilter(log) {
  return { orphan: "drop-log", log: {
    transactionHash: log.transactionHash,
    blockHash: log.blockHash,
    blockNumber: log.blockNumber,
    address: log.address,
    data: log.data,
    topics: Object.freeze(log.topics.slice()),
    index: log.index
  } };
}
class EventLog extends Log {
  /**
   * @_ignore:
   */
  constructor(log, iface, fragment) {
    super(log, log.provider);
    /**
     *  The Contract Interface.
     */
    __publicField(this, "interface");
    /**
     *  The matching event.
     */
    __publicField(this, "fragment");
    /**
     *  The parsed arguments passed to the event by ``emit``.
     */
    __publicField(this, "args");
    const args = iface.decodeEventLog(fragment, log.data, log.topics);
    defineProperties(this, { args, fragment, interface: iface });
  }
  /**
   *  The name of the event.
   */
  get eventName() {
    return this.fragment.name;
  }
  /**
   *  The signature of the event.
   */
  get eventSignature() {
    return this.fragment.format();
  }
}
class UndecodedEventLog extends Log {
  /**
   * @_ignore:
   */
  constructor(log, error) {
    super(log, log.provider);
    /**
     *  The error encounted when trying to decode the log.
     */
    __publicField(this, "error");
    defineProperties(this, { error });
  }
}
class ContractTransactionReceipt extends TransactionReceipt {
  /**
   *  @_ignore:
   */
  constructor(iface, provider, tx) {
    super(tx, provider);
    __privateAdd(this, _iface);
    __privateSet(this, _iface, iface);
  }
  /**
   *  The parsed logs for any [[Log]] which has a matching event in the
   *  Contract ABI.
   */
  get logs() {
    return super.logs.map((log) => {
      const fragment = log.topics.length ? __privateGet(this, _iface).getEvent(log.topics[0]) : null;
      if (fragment) {
        try {
          return new EventLog(log, __privateGet(this, _iface), fragment);
        } catch (error) {
          return new UndecodedEventLog(log, error);
        }
      }
      return log;
    });
  }
}
_iface = new WeakMap();
class ContractTransactionResponse extends TransactionResponse {
  /**
   *  @_ignore:
   */
  constructor(iface, provider, tx) {
    super(tx, provider);
    __privateAdd(this, _iface2);
    __privateSet(this, _iface2, iface);
  }
  /**
   *  Resolves once this transaction has been mined and has
   *  %%confirms%% blocks including it (default: ``1``) with an
   *  optional %%timeout%%.
   *
   *  This can resolve to ``null`` only if %%confirms%% is ``0``
   *  and the transaction has not been mined, otherwise this will
   *  wait until enough confirmations have completed.
   */
  async wait(confirms, timeout) {
    const receipt = await super.wait(confirms, timeout);
    if (receipt == null) {
      return null;
    }
    return new ContractTransactionReceipt(__privateGet(this, _iface2), this.provider, receipt);
  }
}
_iface2 = new WeakMap();
class ContractUnknownEventPayload extends EventPayload {
  /**
   *  @_event:
   */
  constructor(contract, listener, filter, log) {
    super(contract, listener, filter);
    /**
     *  The log with no matching events.
     */
    __publicField(this, "log");
    defineProperties(this, { log });
  }
  /**
   *  Resolves to the block the event occured in.
   */
  async getBlock() {
    return await this.log.getBlock();
  }
  /**
   *  Resolves to the transaction the event occured in.
   */
  async getTransaction() {
    return await this.log.getTransaction();
  }
  /**
   *  Resolves to the transaction receipt the event occured in.
   */
  async getTransactionReceipt() {
    return await this.log.getTransactionReceipt();
  }
}
class ContractEventPayload extends ContractUnknownEventPayload {
  /**
   *  @_ignore:
   */
  constructor(contract, listener, filter, fragment, _log) {
    super(contract, listener, filter, new EventLog(_log, contract.interface, fragment));
    const args = contract.interface.decodeEventLog(fragment, this.log.data, this.log.topics);
    defineProperties(this, { args, fragment });
  }
  /**
   *  The event name.
   */
  get eventName() {
    return this.fragment.name;
  }
  /**
   *  The event signature.
   */
  get eventSignature() {
    return this.fragment.format();
  }
}
const BN_0$1 = BigInt(0);
function canCall(value) {
  return value && typeof value.call === "function";
}
function canEstimate(value) {
  return value && typeof value.estimateGas === "function";
}
function canResolve(value) {
  return value && typeof value.resolveName === "function";
}
function canSend(value) {
  return value && typeof value.sendTransaction === "function";
}
function getResolver(value) {
  if (value != null) {
    if (canResolve(value)) {
      return value;
    }
    if (value.provider) {
      return value.provider;
    }
  }
  return void 0;
}
class PreparedTopicFilter {
  constructor(contract, fragment, args) {
    __privateAdd(this, _filter);
    __publicField(this, "fragment");
    defineProperties(this, { fragment });
    if (fragment.inputs.length < args.length) {
      throw new Error("too many arguments");
    }
    const runner = getRunner(contract.runner, "resolveName");
    const resolver = canResolve(runner) ? runner : null;
    __privateSet(this, _filter, async function() {
      const resolvedArgs = await Promise.all(fragment.inputs.map((param, index) => {
        const arg = args[index];
        if (arg == null) {
          return null;
        }
        return param.walkAsync(args[index], (type, value) => {
          if (type === "address") {
            if (Array.isArray(value)) {
              return Promise.all(value.map((v3) => resolveAddress(v3, resolver)));
            }
            return resolveAddress(value, resolver);
          }
          return value;
        });
      }));
      return contract.interface.encodeFilterTopics(fragment, resolvedArgs);
    }());
  }
  getTopicFilter() {
    return __privateGet(this, _filter);
  }
}
_filter = new WeakMap();
function getRunner(value, feature) {
  if (value == null) {
    return null;
  }
  if (typeof value[feature] === "function") {
    return value;
  }
  if (value.provider && typeof value.provider[feature] === "function") {
    return value.provider;
  }
  return null;
}
function getProvider(value) {
  if (value == null) {
    return null;
  }
  return value.provider || null;
}
async function copyOverrides(arg, allowed) {
  const _overrides = Typed.dereference(arg, "overrides");
  assertArgument(typeof _overrides === "object", "invalid overrides parameter", "overrides", arg);
  const overrides = copyRequest(_overrides);
  assertArgument(overrides.to == null || (allowed || []).indexOf("to") >= 0, "cannot override to", "overrides.to", overrides.to);
  assertArgument(overrides.data == null || (allowed || []).indexOf("data") >= 0, "cannot override data", "overrides.data", overrides.data);
  if (overrides.from) {
    overrides.from = overrides.from;
  }
  return overrides;
}
async function resolveArgs(_runner, inputs, args) {
  const runner = getRunner(_runner, "resolveName");
  const resolver = canResolve(runner) ? runner : null;
  return await Promise.all(inputs.map((param, index) => {
    return param.walkAsync(args[index], (type, value) => {
      value = Typed.dereference(value, type);
      if (type === "address") {
        return resolveAddress(value, resolver);
      }
      return value;
    });
  }));
}
function buildWrappedFallback(contract) {
  const populateTransaction = async function(overrides) {
    const tx = await copyOverrides(overrides, ["data"]);
    tx.to = await contract.getAddress();
    if (tx.from) {
      tx.from = await resolveAddress(tx.from, getResolver(contract.runner));
    }
    const iface = contract.interface;
    const noValue = getBigInt(tx.value || BN_0$1, "overrides.value") === BN_0$1;
    const noData = (tx.data || "0x") === "0x";
    if (iface.fallback && !iface.fallback.payable && iface.receive && !noData && !noValue) {
      assertArgument(false, "cannot send data to receive or send value to non-payable fallback", "overrides", overrides);
    }
    assertArgument(iface.fallback || noData, "cannot send data to receive-only contract", "overrides.data", tx.data);
    const payable = iface.receive || iface.fallback && iface.fallback.payable;
    assertArgument(payable || noValue, "cannot send value to non-payable fallback", "overrides.value", tx.value);
    assertArgument(iface.fallback || noData, "cannot send data to receive-only contract", "overrides.data", tx.data);
    return tx;
  };
  const staticCall = async function(overrides) {
    const runner = getRunner(contract.runner, "call");
    assert(canCall(runner), "contract runner does not support calling", "UNSUPPORTED_OPERATION", { operation: "call" });
    const tx = await populateTransaction(overrides);
    try {
      return await runner.call(tx);
    } catch (error) {
      if (isCallException(error) && error.data) {
        throw contract.interface.makeError(error.data, tx);
      }
      throw error;
    }
  };
  const send = async function(overrides) {
    const runner = contract.runner;
    assert(canSend(runner), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", { operation: "sendTransaction" });
    const tx = await runner.sendTransaction(await populateTransaction(overrides));
    const provider = getProvider(contract.runner);
    return new ContractTransactionResponse(contract.interface, provider, tx);
  };
  const estimateGas = async function(overrides) {
    const runner = getRunner(contract.runner, "estimateGas");
    assert(canEstimate(runner), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", { operation: "estimateGas" });
    return await runner.estimateGas(await populateTransaction(overrides));
  };
  const method = async (overrides) => {
    return await send(overrides);
  };
  defineProperties(method, {
    _contract: contract,
    estimateGas,
    populateTransaction,
    send,
    staticCall
  });
  return method;
}
function buildWrappedMethod(contract, key) {
  const getFragment = function(...args) {
    const fragment = contract.interface.getFunction(key, args);
    assert(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
      operation: "fragment",
      info: { key, args }
    });
    return fragment;
  };
  const populateTransaction = async function(...args) {
    const fragment = getFragment(...args);
    let overrides = {};
    if (fragment.inputs.length + 1 === args.length) {
      overrides = await copyOverrides(args.pop());
      if (overrides.from) {
        overrides.from = await resolveAddress(overrides.from, getResolver(contract.runner));
      }
    }
    if (fragment.inputs.length !== args.length) {
      throw new Error("internal error: fragment inputs doesn't match arguments; should not happen");
    }
    const resolvedArgs = await resolveArgs(contract.runner, fragment.inputs, args);
    return Object.assign({}, overrides, await resolveProperties({
      to: contract.getAddress(),
      data: contract.interface.encodeFunctionData(fragment, resolvedArgs)
    }));
  };
  const staticCall = async function(...args) {
    const result = await staticCallResult(...args);
    if (result.length === 1) {
      return result[0];
    }
    return result;
  };
  const send = async function(...args) {
    const runner = contract.runner;
    assert(canSend(runner), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", { operation: "sendTransaction" });
    const tx = await runner.sendTransaction(await populateTransaction(...args));
    const provider = getProvider(contract.runner);
    return new ContractTransactionResponse(contract.interface, provider, tx);
  };
  const estimateGas = async function(...args) {
    const runner = getRunner(contract.runner, "estimateGas");
    assert(canEstimate(runner), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", { operation: "estimateGas" });
    return await runner.estimateGas(await populateTransaction(...args));
  };
  const staticCallResult = async function(...args) {
    const runner = getRunner(contract.runner, "call");
    assert(canCall(runner), "contract runner does not support calling", "UNSUPPORTED_OPERATION", { operation: "call" });
    const tx = await populateTransaction(...args);
    let result = "0x";
    try {
      result = await runner.call(tx);
    } catch (error) {
      if (isCallException(error) && error.data) {
        throw contract.interface.makeError(error.data, tx);
      }
      throw error;
    }
    const fragment = getFragment(...args);
    return contract.interface.decodeFunctionResult(fragment, result);
  };
  const method = async (...args) => {
    const fragment = getFragment(...args);
    if (fragment.constant) {
      return await staticCall(...args);
    }
    return await send(...args);
  };
  defineProperties(method, {
    name: contract.interface.getFunctionName(key),
    _contract: contract,
    _key: key,
    getFragment,
    estimateGas,
    populateTransaction,
    send,
    staticCall,
    staticCallResult
  });
  Object.defineProperty(method, "fragment", {
    configurable: false,
    enumerable: true,
    get: () => {
      const fragment = contract.interface.getFunction(key);
      assert(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
        operation: "fragment",
        info: { key }
      });
      return fragment;
    }
  });
  return method;
}
function buildWrappedEvent(contract, key) {
  const getFragment = function(...args) {
    const fragment = contract.interface.getEvent(key, args);
    assert(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
      operation: "fragment",
      info: { key, args }
    });
    return fragment;
  };
  const method = function(...args) {
    return new PreparedTopicFilter(contract, getFragment(...args), args);
  };
  defineProperties(method, {
    name: contract.interface.getEventName(key),
    _contract: contract,
    _key: key,
    getFragment
  });
  Object.defineProperty(method, "fragment", {
    configurable: false,
    enumerable: true,
    get: () => {
      const fragment = contract.interface.getEvent(key);
      assert(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
        operation: "fragment",
        info: { key }
      });
      return fragment;
    }
  });
  return method;
}
const internal = Symbol.for("_ethersInternal_contract");
const internalValues = /* @__PURE__ */ new WeakMap();
function setInternal(contract, values) {
  internalValues.set(contract[internal], values);
}
function getInternal(contract) {
  return internalValues.get(contract[internal]);
}
function isDeferred(value) {
  return value && typeof value === "object" && "getTopicFilter" in value && typeof value.getTopicFilter === "function" && value.fragment;
}
async function getSubInfo(contract, event) {
  let topics;
  let fragment = null;
  if (Array.isArray(event)) {
    const topicHashify = function(name) {
      if (isHexString(name, 32)) {
        return name;
      }
      const fragment2 = contract.interface.getEvent(name);
      assertArgument(fragment2, "unknown fragment", "name", name);
      return fragment2.topicHash;
    };
    topics = event.map((e2) => {
      if (e2 == null) {
        return null;
      }
      if (Array.isArray(e2)) {
        return e2.map(topicHashify);
      }
      return topicHashify(e2);
    });
  } else if (event === "*") {
    topics = [null];
  } else if (typeof event === "string") {
    if (isHexString(event, 32)) {
      topics = [event];
    } else {
      fragment = contract.interface.getEvent(event);
      assertArgument(fragment, "unknown fragment", "event", event);
      topics = [fragment.topicHash];
    }
  } else if (isDeferred(event)) {
    topics = await event.getTopicFilter();
  } else if ("fragment" in event) {
    fragment = event.fragment;
    topics = [fragment.topicHash];
  } else {
    assertArgument(false, "unknown event name", "event", event);
  }
  topics = topics.map((t) => {
    if (t == null) {
      return null;
    }
    if (Array.isArray(t)) {
      const items = Array.from(new Set(t.map((t2) => t2.toLowerCase())).values());
      if (items.length === 1) {
        return items[0];
      }
      items.sort();
      return items;
    }
    return t.toLowerCase();
  });
  const tag = topics.map((t) => {
    if (t == null) {
      return "null";
    }
    if (Array.isArray(t)) {
      return t.join("|");
    }
    return t;
  }).join("&");
  return { fragment, tag, topics };
}
async function hasSub(contract, event) {
  const { subs } = getInternal(contract);
  return subs.get((await getSubInfo(contract, event)).tag) || null;
}
async function getSub(contract, operation, event) {
  const provider = getProvider(contract.runner);
  assert(provider, "contract runner does not support subscribing", "UNSUPPORTED_OPERATION", { operation });
  const { fragment, tag, topics } = await getSubInfo(contract, event);
  const { addr, subs } = getInternal(contract);
  let sub = subs.get(tag);
  if (!sub) {
    const address = addr ? addr : contract;
    const filter = { address, topics };
    const listener = (log) => {
      let foundFragment = fragment;
      if (foundFragment == null) {
        try {
          foundFragment = contract.interface.getEvent(log.topics[0]);
        } catch (error) {
        }
      }
      if (foundFragment) {
        const _foundFragment = foundFragment;
        const args = fragment ? contract.interface.decodeEventLog(fragment, log.data, log.topics) : [];
        emit(contract, event, args, (listener2) => {
          return new ContractEventPayload(contract, listener2, event, _foundFragment, log);
        });
      } else {
        emit(contract, event, [], (listener2) => {
          return new ContractUnknownEventPayload(contract, listener2, event, log);
        });
      }
    };
    let starting = [];
    const start = () => {
      if (starting.length) {
        return;
      }
      starting.push(provider.on(filter, listener));
    };
    const stop = async () => {
      if (starting.length == 0) {
        return;
      }
      let started = starting;
      starting = [];
      await Promise.all(started);
      provider.off(filter, listener);
    };
    sub = { tag, listeners: [], start, stop };
    subs.set(tag, sub);
  }
  return sub;
}
let lastEmit = Promise.resolve();
async function _emit(contract, event, args, payloadFunc) {
  await lastEmit;
  const sub = await hasSub(contract, event);
  if (!sub) {
    return false;
  }
  const count = sub.listeners.length;
  sub.listeners = sub.listeners.filter(({ listener, once }) => {
    const passArgs = Array.from(args);
    if (payloadFunc) {
      passArgs.push(payloadFunc(once ? null : listener));
    }
    try {
      listener.call(contract, ...passArgs);
    } catch (error) {
    }
    return !once;
  });
  if (sub.listeners.length === 0) {
    sub.stop();
    getInternal(contract).subs.delete(sub.tag);
  }
  return count > 0;
}
async function emit(contract, event, args, payloadFunc) {
  try {
    await lastEmit;
  } catch (error) {
  }
  const resultPromise = _emit(contract, event, args, payloadFunc);
  lastEmit = resultPromise;
  return await resultPromise;
}
const passProperties = ["then"];
_a2 = internal;
const _BaseContract = class _BaseContract {
  /**
   *  Creates a new contract connected to %%target%% with the %%abi%% and
   *  optionally connected to a %%runner%% to perform operations on behalf
   *  of.
   */
  constructor(target, abi, runner, _deployTx) {
    /**
     *  The target to connect to.
     *
     *  This can be an address, ENS name or any [[Addressable]], such as
     *  another contract. To get the resovled address, use the ``getAddress``
     *  method.
     */
    __publicField(this, "target");
    /**
     *  The contract Interface.
     */
    __publicField(this, "interface");
    /**
     *  The connected runner. This is generally a [[Provider]] or a
     *  [[Signer]], which dictates what operations are supported.
     *
     *  For example, a **Contract** connected to a [[Provider]] may
     *  only execute read-only operations.
     */
    __publicField(this, "runner");
    /**
     *  All the Events available on this contract.
     */
    __publicField(this, "filters");
    /**
     *  @_ignore:
     */
    __publicField(this, _a2);
    /**
     *  The fallback or receive function if any.
     */
    __publicField(this, "fallback");
    assertArgument(typeof target === "string" || isAddressable(target), "invalid value for Contract target", "target", target);
    if (runner == null) {
      runner = null;
    }
    const iface = Interface.from(abi);
    defineProperties(this, { target, runner, interface: iface });
    Object.defineProperty(this, internal, { value: {} });
    let addrPromise;
    let addr = null;
    let deployTx = null;
    if (_deployTx) {
      const provider = getProvider(runner);
      deployTx = new ContractTransactionResponse(this.interface, provider, _deployTx);
    }
    let subs = /* @__PURE__ */ new Map();
    if (typeof target === "string") {
      if (isHexString(target)) {
        addr = target;
        addrPromise = Promise.resolve(target);
      } else {
        const resolver = getRunner(runner, "resolveName");
        if (!canResolve(resolver)) {
          throw makeError("contract runner does not support name resolution", "UNSUPPORTED_OPERATION", {
            operation: "resolveName"
          });
        }
        addrPromise = resolver.resolveName(target).then((addr2) => {
          if (addr2 == null) {
            throw makeError("an ENS name used for a contract target must be correctly configured", "UNCONFIGURED_NAME", {
              value: target
            });
          }
          getInternal(this).addr = addr2;
          return addr2;
        });
      }
    } else {
      addrPromise = target.getAddress().then((addr2) => {
        if (addr2 == null) {
          throw new Error("TODO");
        }
        getInternal(this).addr = addr2;
        return addr2;
      });
    }
    setInternal(this, { addrPromise, addr, deployTx, subs });
    const filters = new Proxy({}, {
      get: (target2, prop2, receiver) => {
        if (typeof prop2 === "symbol" || passProperties.indexOf(prop2) >= 0) {
          return Reflect.get(target2, prop2, receiver);
        }
        try {
          return this.getEvent(prop2);
        } catch (error) {
          if (!isError(error, "INVALID_ARGUMENT") || error.argument !== "key") {
            throw error;
          }
        }
        return void 0;
      },
      has: (target2, prop2) => {
        if (passProperties.indexOf(prop2) >= 0) {
          return Reflect.has(target2, prop2);
        }
        return Reflect.has(target2, prop2) || this.interface.hasEvent(String(prop2));
      }
    });
    defineProperties(this, { filters });
    defineProperties(this, {
      fallback: iface.receive || iface.fallback ? buildWrappedFallback(this) : null
    });
    return new Proxy(this, {
      get: (target2, prop2, receiver) => {
        if (typeof prop2 === "symbol" || prop2 in target2 || passProperties.indexOf(prop2) >= 0) {
          return Reflect.get(target2, prop2, receiver);
        }
        try {
          return target2.getFunction(prop2);
        } catch (error) {
          if (!isError(error, "INVALID_ARGUMENT") || error.argument !== "key") {
            throw error;
          }
        }
        return void 0;
      },
      has: (target2, prop2) => {
        if (typeof prop2 === "symbol" || prop2 in target2 || passProperties.indexOf(prop2) >= 0) {
          return Reflect.has(target2, prop2);
        }
        return target2.interface.hasFunction(prop2);
      }
    });
  }
  /**
   *  Return a new Contract instance with the same target and ABI, but
   *  a different %%runner%%.
   */
  connect(runner) {
    return new _BaseContract(this.target, this.interface, runner);
  }
  /**
   *  Return a new Contract instance with the same ABI and runner, but
   *  a different %%target%%.
   */
  attach(target) {
    return new _BaseContract(target, this.interface, this.runner);
  }
  /**
   *  Return the resolved address of this Contract.
   */
  async getAddress() {
    return await getInternal(this).addrPromise;
  }
  /**
   *  Return the deployed bytecode or null if no bytecode is found.
   */
  async getDeployedCode() {
    const provider = getProvider(this.runner);
    assert(provider, "runner does not support .provider", "UNSUPPORTED_OPERATION", { operation: "getDeployedCode" });
    const code = await provider.getCode(await this.getAddress());
    if (code === "0x") {
      return null;
    }
    return code;
  }
  /**
   *  Resolve to this Contract once the bytecode has been deployed, or
   *  resolve immediately if already deployed.
   */
  async waitForDeployment() {
    const deployTx = this.deploymentTransaction();
    if (deployTx) {
      await deployTx.wait();
      return this;
    }
    const code = await this.getDeployedCode();
    if (code != null) {
      return this;
    }
    const provider = getProvider(this.runner);
    assert(provider != null, "contract runner does not support .provider", "UNSUPPORTED_OPERATION", { operation: "waitForDeployment" });
    return new Promise((resolve, reject) => {
      const checkCode = async () => {
        try {
          const code2 = await this.getDeployedCode();
          if (code2 != null) {
            return resolve(this);
          }
          provider.once("block", checkCode);
        } catch (error) {
          reject(error);
        }
      };
      checkCode();
    });
  }
  /**
   *  Return the transaction used to deploy this contract.
   *
   *  This is only available if this instance was returned from a
   *  [[ContractFactory]].
   */
  deploymentTransaction() {
    return getInternal(this).deployTx;
  }
  /**
   *  Return the function for a given name. This is useful when a contract
   *  method name conflicts with a JavaScript name such as ``prototype`` or
   *  when using a Contract programatically.
   */
  getFunction(key) {
    if (typeof key !== "string") {
      key = key.format();
    }
    const func = buildWrappedMethod(this, key);
    return func;
  }
  /**
   *  Return the event for a given name. This is useful when a contract
   *  event name conflicts with a JavaScript name such as ``prototype`` or
   *  when using a Contract programatically.
   */
  getEvent(key) {
    if (typeof key !== "string") {
      key = key.format();
    }
    return buildWrappedEvent(this, key);
  }
  /**
   *  @_ignore:
   */
  async queryTransaction(hash) {
    throw new Error("@TODO");
  }
  /*
      // @TODO: this is a non-backwards compatible change, but will be added
      //        in v7 and in a potential SmartContract class in an upcoming
      //        v6 release
      async getTransactionReceipt(hash: string): Promise<null | ContractTransactionReceipt> {
          const provider = getProvider(this.runner);
          assert(provider, "contract runner does not have a provider",
              "UNSUPPORTED_OPERATION", { operation: "queryTransaction" });
  
          const receipt = await provider.getTransactionReceipt(hash);
          if (receipt == null) { return null; }
  
          return new ContractTransactionReceipt(this.interface, provider, receipt);
      }
      */
  /**
   *  Provide historic access to event data for %%event%% in the range
   *  %%fromBlock%% (default: ``0``) to %%toBlock%% (default: ``"latest"``)
   *  inclusive.
   */
  async queryFilter(event, fromBlock, toBlock) {
    if (fromBlock == null) {
      fromBlock = 0;
    }
    if (toBlock == null) {
      toBlock = "latest";
    }
    const { addr, addrPromise } = getInternal(this);
    const address = addr ? addr : await addrPromise;
    const { fragment, topics } = await getSubInfo(this, event);
    const filter = { address, topics, fromBlock, toBlock };
    const provider = getProvider(this.runner);
    assert(provider, "contract runner does not have a provider", "UNSUPPORTED_OPERATION", { operation: "queryFilter" });
    return (await provider.getLogs(filter)).map((log) => {
      let foundFragment = fragment;
      if (foundFragment == null) {
        try {
          foundFragment = this.interface.getEvent(log.topics[0]);
        } catch (error) {
        }
      }
      if (foundFragment) {
        try {
          return new EventLog(log, this.interface, foundFragment);
        } catch (error) {
          return new UndecodedEventLog(log, error);
        }
      }
      return new Log(log, provider);
    });
  }
  /**
   *  Add an event %%listener%% for the %%event%%.
   */
  async on(event, listener) {
    const sub = await getSub(this, "on", event);
    sub.listeners.push({ listener, once: false });
    sub.start();
    return this;
  }
  /**
   *  Add an event %%listener%% for the %%event%%, but remove the listener
   *  after it is fired once.
   */
  async once(event, listener) {
    const sub = await getSub(this, "once", event);
    sub.listeners.push({ listener, once: true });
    sub.start();
    return this;
  }
  /**
   *  Emit an %%event%% calling all listeners with %%args%%.
   *
   *  Resolves to ``true`` if any listeners were called.
   */
  async emit(event, ...args) {
    return await emit(this, event, args, null);
  }
  /**
   *  Resolves to the number of listeners of %%event%% or the total number
   *  of listeners if unspecified.
   */
  async listenerCount(event) {
    if (event) {
      const sub = await hasSub(this, event);
      if (!sub) {
        return 0;
      }
      return sub.listeners.length;
    }
    const { subs } = getInternal(this);
    let total = 0;
    for (const { listeners } of subs.values()) {
      total += listeners.length;
    }
    return total;
  }
  /**
   *  Resolves to the listeners subscribed to %%event%% or all listeners
   *  if unspecified.
   */
  async listeners(event) {
    if (event) {
      const sub = await hasSub(this, event);
      if (!sub) {
        return [];
      }
      return sub.listeners.map(({ listener }) => listener);
    }
    const { subs } = getInternal(this);
    let result = [];
    for (const { listeners } of subs.values()) {
      result = result.concat(listeners.map(({ listener }) => listener));
    }
    return result;
  }
  /**
   *  Remove the %%listener%% from the listeners for %%event%% or remove
   *  all listeners if unspecified.
   */
  async off(event, listener) {
    const sub = await hasSub(this, event);
    if (!sub) {
      return this;
    }
    if (listener) {
      const index = sub.listeners.map(({ listener: listener2 }) => listener2).indexOf(listener);
      if (index >= 0) {
        sub.listeners.splice(index, 1);
      }
    }
    if (listener == null || sub.listeners.length === 0) {
      sub.stop();
      getInternal(this).subs.delete(sub.tag);
    }
    return this;
  }
  /**
   *  Remove all the listeners for %%event%% or remove all listeners if
   *  unspecified.
   */
  async removeAllListeners(event) {
    if (event) {
      const sub = await hasSub(this, event);
      if (!sub) {
        return this;
      }
      sub.stop();
      getInternal(this).subs.delete(sub.tag);
    } else {
      const { subs } = getInternal(this);
      for (const { tag, stop } of subs.values()) {
        stop();
        subs.delete(tag);
      }
    }
    return this;
  }
  /**
   *  Alias for [on].
   */
  async addListener(event, listener) {
    return await this.on(event, listener);
  }
  /**
   *  Alias for [off].
   */
  async removeListener(event, listener) {
    return await this.off(event, listener);
  }
  /**
   *  Create a new Class for the %%abi%%.
   */
  static buildClass(abi) {
    class CustomContract extends _BaseContract {
      constructor(address, runner = null) {
        super(address, abi, runner);
      }
    }
    return CustomContract;
  }
  /**
   *  Create a new BaseContract with a specified Interface.
   */
  static from(target, abi, runner) {
    if (runner == null) {
      runner = null;
    }
    const contract = new this(target, abi, runner);
    return contract;
  }
};
let BaseContract = _BaseContract;
function _ContractBase() {
  return BaseContract;
}
class Contract extends _ContractBase() {
}
function getIpfsLink(link) {
  if (link.match(/^ipfs:\/\/ipfs\//i)) {
    link = link.substring(12);
  } else if (link.match(/^ipfs:\/\//i)) {
    link = link.substring(7);
  } else {
    assertArgument(false, "unsupported IPFS format", "link", link);
  }
  return `https://gateway.ipfs.io/ipfs/${link}`;
}
class MulticoinProviderPlugin {
  /**
   *  Creates a new **MulticoinProviderPluing** for %%name%%.
   */
  constructor(name) {
    /**
     *  The name.
     */
    __publicField(this, "name");
    defineProperties(this, { name });
  }
  connect(proivder) {
    return this;
  }
  /**
   *  Returns ``true`` if %%coinType%% is supported by this plugin.
   */
  supportsCoinType(coinType) {
    return false;
  }
  /**
   *  Resolves to the encoded %%address%% for %%coinType%%.
   */
  async encodeAddress(coinType, address) {
    throw new Error("unsupported coin");
  }
  /**
   *  Resolves to the decoded %%data%% for %%coinType%%.
   */
  async decodeAddress(coinType, data) {
    throw new Error("unsupported coin");
  }
}
const matcherIpfs = new RegExp("^(ipfs)://(.*)$", "i");
const matchers = [
  new RegExp("^(https)://(.*)$", "i"),
  new RegExp("^(data):(.*)$", "i"),
  matcherIpfs,
  new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")
];
const _EnsResolver = class _EnsResolver {
  constructor(provider, address, name) {
    __privateAdd(this, _EnsResolver_instances);
    /**
     *  The connected provider.
     */
    __publicField(this, "provider");
    /**
     *  The address of the resolver.
     */
    __publicField(this, "address");
    /**
     *  The name this resolver was resolved against.
     */
    __publicField(this, "name");
    // For EIP-2544 names, the ancestor that provided the resolver
    __privateAdd(this, _supports2544);
    __privateAdd(this, _resolver);
    defineProperties(this, { provider, address, name });
    __privateSet(this, _supports2544, null);
    __privateSet(this, _resolver, new Contract(address, [
      "function supportsInterface(bytes4) view returns (bool)",
      "function resolve(bytes, bytes) view returns (bytes)",
      "function addr(bytes32) view returns (address)",
      "function addr(bytes32, uint) view returns (bytes)",
      "function text(bytes32, string) view returns (string)",
      "function contenthash(bytes32) view returns (bytes)"
    ], provider));
  }
  /**
   *  Resolves to true if the resolver supports wildcard resolution.
   */
  async supportsWildcard() {
    if (__privateGet(this, _supports2544) == null) {
      __privateSet(this, _supports2544, (async () => {
        try {
          return await __privateGet(this, _resolver).supportsInterface("0x9061b923");
        } catch (error) {
          if (isError(error, "CALL_EXCEPTION")) {
            return false;
          }
          __privateSet(this, _supports2544, null);
          throw error;
        }
      })());
    }
    return await __privateGet(this, _supports2544);
  }
  /**
   *  Resolves to the address for %%coinType%% or null if the
   *  provided %%coinType%% has not been configured.
   */
  async getAddress(coinType) {
    if (coinType == null) {
      coinType = 60;
    }
    if (coinType === 60) {
      try {
        const result = await __privateMethod(this, _EnsResolver_instances, fetch_fn).call(this, "addr(bytes32)");
        if (result == null || result === ZeroAddress) {
          return null;
        }
        return result;
      } catch (error) {
        if (isError(error, "CALL_EXCEPTION")) {
          return null;
        }
        throw error;
      }
    }
    if (coinType >= 0 && coinType < 2147483648) {
      let ethCoinType = coinType + 2147483648;
      const data2 = await __privateMethod(this, _EnsResolver_instances, fetch_fn).call(this, "addr(bytes32,uint)", [ethCoinType]);
      if (isHexString(data2, 20)) {
        return getAddress(data2);
      }
    }
    let coinPlugin = null;
    for (const plugin of this.provider.plugins) {
      if (!(plugin instanceof MulticoinProviderPlugin)) {
        continue;
      }
      if (plugin.supportsCoinType(coinType)) {
        coinPlugin = plugin;
        break;
      }
    }
    if (coinPlugin == null) {
      return null;
    }
    const data = await __privateMethod(this, _EnsResolver_instances, fetch_fn).call(this, "addr(bytes32,uint)", [coinType]);
    if (data == null || data === "0x") {
      return null;
    }
    const address = await coinPlugin.decodeAddress(coinType, data);
    if (address != null) {
      return address;
    }
    assert(false, `invalid coin data`, "UNSUPPORTED_OPERATION", {
      operation: `getAddress(${coinType})`,
      info: { coinType, data }
    });
  }
  /**
   *  Resolves to the EIP-634 text record for %%key%%, or ``null``
   *  if unconfigured.
   */
  async getText(key) {
    const data = await __privateMethod(this, _EnsResolver_instances, fetch_fn).call(this, "text(bytes32,string)", [key]);
    if (data == null || data === "0x") {
      return null;
    }
    return data;
  }
  /**
   *  Rsolves to the content-hash or ``null`` if unconfigured.
   */
  async getContentHash() {
    const data = await __privateMethod(this, _EnsResolver_instances, fetch_fn).call(this, "contenthash(bytes32)");
    if (data == null || data === "0x") {
      return null;
    }
    const ipfs = data.match(/^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
    if (ipfs) {
      const scheme = ipfs[1] === "e3010170" ? "ipfs" : "ipns";
      const length = parseInt(ipfs[4], 16);
      if (ipfs[5].length === length * 2) {
        return `${scheme}://${encodeBase58("0x" + ipfs[2])}`;
      }
    }
    const swarm = data.match(/^0xe40101fa011b20([0-9a-f]*)$/);
    if (swarm && swarm[1].length === 64) {
      return `bzz://${swarm[1]}`;
    }
    assert(false, `invalid or unsupported content hash data`, "UNSUPPORTED_OPERATION", {
      operation: "getContentHash()",
      info: { data }
    });
  }
  /**
   *  Resolves to the avatar url or ``null`` if the avatar is either
   *  unconfigured or incorrectly configured (e.g. references an NFT
   *  not owned by the address).
   *
   *  If diagnosing issues with configurations, the [[_getAvatar]]
   *  method may be useful.
   */
  async getAvatar() {
    const avatar = await this._getAvatar();
    return avatar.url;
  }
  /**
   *  When resolving an avatar, there are many steps involved, such
   *  fetching metadata and possibly validating ownership of an
   *  NFT.
   *
   *  This method can be used to examine each step and the value it
   *  was working from.
   */
  async _getAvatar() {
    const linkage = [{ type: "name", value: this.name }];
    try {
      const avatar = await this.getText("avatar");
      if (avatar == null) {
        linkage.push({ type: "!avatar", value: "" });
        return { url: null, linkage };
      }
      linkage.push({ type: "avatar", value: avatar });
      for (let i = 0; i < matchers.length; i++) {
        const match = avatar.match(matchers[i]);
        if (match == null) {
          continue;
        }
        const scheme = match[1].toLowerCase();
        switch (scheme) {
          case "https":
          case "data":
            linkage.push({ type: "url", value: avatar });
            return { linkage, url: avatar };
          case "ipfs": {
            const url = getIpfsLink(avatar);
            linkage.push({ type: "ipfs", value: avatar });
            linkage.push({ type: "url", value: url });
            return { linkage, url };
          }
          case "erc721":
          case "erc1155": {
            const selector = scheme === "erc721" ? "tokenURI(uint256)" : "uri(uint256)";
            linkage.push({ type: scheme, value: avatar });
            const owner = await this.getAddress();
            if (owner == null) {
              linkage.push({ type: "!owner", value: "" });
              return { url: null, linkage };
            }
            const comps = (match[2] || "").split("/");
            if (comps.length !== 2) {
              linkage.push({ type: `!${scheme}caip`, value: match[2] || "" });
              return { url: null, linkage };
            }
            const tokenId = comps[1];
            const contract = new Contract(comps[0], [
              // ERC-721
              "function tokenURI(uint) view returns (string)",
              "function ownerOf(uint) view returns (address)",
              // ERC-1155
              "function uri(uint) view returns (string)",
              "function balanceOf(address, uint256) view returns (uint)"
            ], this.provider);
            if (scheme === "erc721") {
              const tokenOwner = await contract.ownerOf(tokenId);
              if (owner !== tokenOwner) {
                linkage.push({ type: "!owner", value: tokenOwner });
                return { url: null, linkage };
              }
              linkage.push({ type: "owner", value: tokenOwner });
            } else if (scheme === "erc1155") {
              const balance = await contract.balanceOf(owner, tokenId);
              if (!balance) {
                linkage.push({ type: "!balance", value: "0" });
                return { url: null, linkage };
              }
              linkage.push({ type: "balance", value: balance.toString() });
            }
            let metadataUrl = await contract[selector](tokenId);
            if (metadataUrl == null || metadataUrl === "0x") {
              linkage.push({ type: "!metadata-url", value: "" });
              return { url: null, linkage };
            }
            linkage.push({ type: "metadata-url-base", value: metadataUrl });
            if (scheme === "erc1155") {
              metadataUrl = metadataUrl.replace("{id}", toBeHex(tokenId, 32).substring(2));
              linkage.push({ type: "metadata-url-expanded", value: metadataUrl });
            }
            if (metadataUrl.match(/^ipfs:/i)) {
              metadataUrl = getIpfsLink(metadataUrl);
            }
            linkage.push({ type: "metadata-url", value: metadataUrl });
            let metadata = {};
            const response = await new FetchRequest(metadataUrl).send();
            response.assertOk();
            try {
              metadata = response.bodyJson;
            } catch (error) {
              try {
                linkage.push({ type: "!metadata", value: response.bodyText });
              } catch (error2) {
                const bytes = response.body;
                if (bytes) {
                  linkage.push({ type: "!metadata", value: hexlify(bytes) });
                }
                return { url: null, linkage };
              }
              return { url: null, linkage };
            }
            if (!metadata) {
              linkage.push({ type: "!metadata", value: "" });
              return { url: null, linkage };
            }
            linkage.push({ type: "metadata", value: JSON.stringify(metadata) });
            let imageUrl = metadata.image;
            if (typeof imageUrl !== "string") {
              linkage.push({ type: "!imageUrl", value: "" });
              return { url: null, linkage };
            }
            if (imageUrl.match(/^(https:\/\/|data:)/i)) {
            } else {
              const ipfs = imageUrl.match(matcherIpfs);
              if (ipfs == null) {
                linkage.push({ type: "!imageUrl-ipfs", value: imageUrl });
                return { url: null, linkage };
              }
              linkage.push({ type: "imageUrl-ipfs", value: imageUrl });
              imageUrl = getIpfsLink(imageUrl);
            }
            linkage.push({ type: "url", value: imageUrl });
            return { linkage, url: imageUrl };
          }
        }
      }
    } catch (error) {
    }
    return { linkage, url: null };
  }
  static async getEnsAddress(provider) {
    const network = await provider.getNetwork();
    const ensPlugin = network.getPlugin("org.ethers.plugins.network.Ens");
    assert(ensPlugin, "network does not support ENS", "UNSUPPORTED_OPERATION", {
      operation: "getEnsAddress",
      info: { network }
    });
    return ensPlugin.address;
  }
  /**
   *  Resolve to the ENS resolver for %%name%% using %%provider%% or
   *  ``null`` if unconfigured.
   */
  static async fromName(provider, name) {
    var _a3;
    let currentName = name;
    while (true) {
      if (currentName === "" || currentName === ".") {
        return null;
      }
      if (name !== "eth" && currentName === "eth") {
        return null;
      }
      const addr = await __privateMethod(_a3 = _EnsResolver, _EnsResolver_static, getResolver_fn).call(_a3, provider, currentName);
      if (addr != null) {
        const resolver = new _EnsResolver(provider, addr, name);
        if (currentName !== name && !await resolver.supportsWildcard()) {
          return null;
        }
        return resolver;
      }
      currentName = currentName.split(".").slice(1).join(".");
    }
  }
};
_supports2544 = new WeakMap();
_resolver = new WeakMap();
_EnsResolver_instances = new WeakSet();
fetch_fn = async function(funcName, params) {
  params = (params || []).slice();
  const iface = __privateGet(this, _resolver).interface;
  params.unshift(namehash(this.name));
  let fragment = null;
  if (await this.supportsWildcard()) {
    fragment = iface.getFunction(funcName);
    assert(fragment, "missing fragment", "UNKNOWN_ERROR", {
      info: { funcName }
    });
    params = [
      dnsEncode(this.name, 255),
      iface.encodeFunctionData(fragment, params)
    ];
    funcName = "resolve(bytes,bytes)";
  }
  params.push({
    enableCcipRead: true
  });
  try {
    const result = await __privateGet(this, _resolver)[funcName](...params);
    if (fragment) {
      return iface.decodeFunctionResult(fragment, result)[0];
    }
    return result;
  } catch (error) {
    if (!isError(error, "CALL_EXCEPTION")) {
      throw error;
    }
  }
  return null;
};
_EnsResolver_static = new WeakSet();
getResolver_fn = async function(provider, name) {
  const ensAddr = await _EnsResolver.getEnsAddress(provider);
  try {
    const contract = new Contract(ensAddr, [
      "function resolver(bytes32) view returns (address)"
    ], provider);
    const addr = await contract.resolver(namehash(name), {
      enableCcipRead: true
    });
    if (addr === ZeroAddress) {
      return null;
    }
    return addr;
  } catch (error) {
    throw error;
  }
  return null;
};
__privateAdd(_EnsResolver, _EnsResolver_static);
let EnsResolver = _EnsResolver;
const BN_0 = BigInt(0);
function allowNull(format2, nullValue) {
  return function(value) {
    if (value == null) {
      return nullValue;
    }
    return format2(value);
  };
}
function arrayOf(format2, allowNull2) {
  return (array) => {
    if (allowNull2 && array == null) {
      return null;
    }
    if (!Array.isArray(array)) {
      throw new Error("not an array");
    }
    return array.map((i) => format2(i));
  };
}
function object(format2, altNames) {
  return (value) => {
    const result = {};
    for (const key in format2) {
      let srcKey = key;
      if (altNames && key in altNames && !(srcKey in value)) {
        for (const altKey of altNames[key]) {
          if (altKey in value) {
            srcKey = altKey;
            break;
          }
        }
      }
      try {
        const nv = format2[key](value[srcKey]);
        if (nv !== void 0) {
          result[key] = nv;
        }
      } catch (error) {
        const message = error instanceof Error ? error.message : "not-an-error";
        assert(false, `invalid value for value.${key} (${message})`, "BAD_DATA", { value });
      }
    }
    return result;
  };
}
function formatBoolean(value) {
  switch (value) {
    case true:
    case "true":
      return true;
    case false:
    case "false":
      return false;
  }
  assertArgument(false, `invalid boolean; ${JSON.stringify(value)}`, "value", value);
}
function formatData(value) {
  assertArgument(isHexString(value, true), "invalid data", "value", value);
  return value;
}
function formatHash(value) {
  assertArgument(isHexString(value, 32), "invalid hash", "value", value);
  return value;
}
const _formatLog = object({
  address: getAddress,
  blockHash: formatHash,
  blockNumber: getNumber,
  data: formatData,
  index: getNumber,
  removed: allowNull(formatBoolean, false),
  topics: arrayOf(formatHash),
  transactionHash: formatHash,
  transactionIndex: getNumber
}, {
  index: ["logIndex"]
});
function formatLog(value) {
  return _formatLog(value);
}
const _formatBlock = object({
  hash: allowNull(formatHash),
  parentHash: formatHash,
  parentBeaconBlockRoot: allowNull(formatHash, null),
  number: getNumber,
  timestamp: getNumber,
  nonce: allowNull(formatData),
  difficulty: getBigInt,
  gasLimit: getBigInt,
  gasUsed: getBigInt,
  stateRoot: allowNull(formatHash, null),
  receiptsRoot: allowNull(formatHash, null),
  blobGasUsed: allowNull(getBigInt, null),
  excessBlobGas: allowNull(getBigInt, null),
  miner: allowNull(getAddress),
  prevRandao: allowNull(formatHash, null),
  extraData: formatData,
  baseFeePerGas: allowNull(getBigInt)
}, {
  prevRandao: ["mixHash"]
});
function formatBlock(value) {
  const result = _formatBlock(value);
  result.transactions = value.transactions.map((tx) => {
    if (typeof tx === "string") {
      return tx;
    }
    return formatTransactionResponse(tx);
  });
  return result;
}
const _formatReceiptLog = object({
  transactionIndex: getNumber,
  blockNumber: getNumber,
  transactionHash: formatHash,
  address: getAddress,
  topics: arrayOf(formatHash),
  data: formatData,
  index: getNumber,
  blockHash: formatHash
}, {
  index: ["logIndex"]
});
function formatReceiptLog(value) {
  return _formatReceiptLog(value);
}
const _formatTransactionReceipt = object({
  to: allowNull(getAddress, null),
  from: allowNull(getAddress, null),
  contractAddress: allowNull(getAddress, null),
  // should be allowNull(hash), but broken-EIP-658 support is handled in receipt
  index: getNumber,
  root: allowNull(hexlify),
  gasUsed: getBigInt,
  blobGasUsed: allowNull(getBigInt, null),
  logsBloom: allowNull(formatData),
  blockHash: formatHash,
  hash: formatHash,
  logs: arrayOf(formatReceiptLog),
  blockNumber: getNumber,
  //confirmations: allowNull(getNumber, null),
  cumulativeGasUsed: getBigInt,
  effectiveGasPrice: allowNull(getBigInt),
  blobGasPrice: allowNull(getBigInt, null),
  status: allowNull(getNumber),
  type: allowNull(getNumber, 0)
}, {
  effectiveGasPrice: ["gasPrice"],
  hash: ["transactionHash"],
  index: ["transactionIndex"]
});
function formatTransactionReceipt(value) {
  return _formatTransactionReceipt(value);
}
function formatTransactionResponse(value) {
  if (value.to && getBigInt(value.to) === BN_0) {
    value.to = "0x0000000000000000000000000000000000000000";
  }
  const result = object({
    hash: formatHash,
    // Some nodes do not return this, usually test nodes (like Ganache)
    index: allowNull(getNumber, void 0),
    type: (value2) => {
      if (value2 === "0x" || value2 == null) {
        return 0;
      }
      return getNumber(value2);
    },
    accessList: allowNull(accessListify, null),
    blobVersionedHashes: allowNull(arrayOf(formatHash, true), null),
    blockHash: allowNull(formatHash, null),
    blockNumber: allowNull(getNumber, null),
    transactionIndex: allowNull(getNumber, null),
    from: getAddress,
    // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas) must be set
    gasPrice: allowNull(getBigInt),
    maxPriorityFeePerGas: allowNull(getBigInt),
    maxFeePerGas: allowNull(getBigInt),
    maxFeePerBlobGas: allowNull(getBigInt, null),
    gasLimit: getBigInt,
    to: allowNull(getAddress, null),
    value: getBigInt,
    nonce: getNumber,
    data: formatData,
    creates: allowNull(getAddress, null),
    chainId: allowNull(getBigInt, null)
  }, {
    data: ["input"],
    gasLimit: ["gas"],
    index: ["transactionIndex"]
  })(value);
  if (result.to == null && result.creates == null) {
    result.creates = getCreateAddress(result);
  }
  if ((value.type === 1 || value.type === 2) && value.accessList == null) {
    result.accessList = [];
  }
  if (value.signature) {
    result.signature = Signature.from(value.signature);
  } else {
    result.signature = Signature.from(value);
  }
  if (result.chainId == null) {
    const chainId = result.signature.legacyChainId;
    if (chainId != null) {
      result.chainId = chainId;
    }
  }
  if (result.blockHash && getBigInt(result.blockHash) === BN_0) {
    result.blockHash = null;
  }
  return result;
}
const EnsAddress = "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e";
class NetworkPlugin {
  /**
   *  Creates a new **NetworkPlugin**.
   */
  constructor(name) {
    /**
     *  The name of the plugin.
     *
     *  It is recommended to use reverse-domain-notation, which permits
     *  unique names with a known authority as well as hierarchal entries.
     */
    __publicField(this, "name");
    defineProperties(this, { name });
  }
  /**
   *  Creates a copy of this plugin.
   */
  clone() {
    return new NetworkPlugin(this.name);
  }
}
class GasCostPlugin extends NetworkPlugin {
  /**
   *  Creates a new GasCostPlugin from %%effectiveBlock%% until the
   *  latest block or another GasCostPlugin supercedes that block number,
   *  with the associated %%costs%%.
   */
  constructor(effectiveBlock, costs) {
    if (effectiveBlock == null) {
      effectiveBlock = 0;
    }
    super(`org.ethers.network.plugins.GasCost#${effectiveBlock || 0}`);
    /**
     *  The block number to treat these values as valid from.
     *
     *  This allows a hardfork to have updated values included as well as
     *  mulutiple hardforks to be supported.
     */
    __publicField(this, "effectiveBlock");
    /**
     *  The transactions base fee.
     */
    __publicField(this, "txBase");
    /**
     *  The fee for creating a new account.
     */
    __publicField(this, "txCreate");
    /**
     *  The fee per zero-byte in the data.
     */
    __publicField(this, "txDataZero");
    /**
     *  The fee per non-zero-byte in the data.
     */
    __publicField(this, "txDataNonzero");
    /**
     *  The fee per storage key in the [[link-eip-2930]] access list.
     */
    __publicField(this, "txAccessListStorageKey");
    /**
     *  The fee per address in the [[link-eip-2930]] access list.
     */
    __publicField(this, "txAccessListAddress");
    const props = { effectiveBlock };
    function set2(name, nullish) {
      let value = (costs || {})[name];
      if (value == null) {
        value = nullish;
      }
      assertArgument(typeof value === "number", `invalud value for ${name}`, "costs", costs);
      props[name] = value;
    }
    set2("txBase", 21e3);
    set2("txCreate", 32e3);
    set2("txDataZero", 4);
    set2("txDataNonzero", 16);
    set2("txAccessListStorageKey", 1900);
    set2("txAccessListAddress", 2400);
    defineProperties(this, props);
  }
  clone() {
    return new GasCostPlugin(this.effectiveBlock, this);
  }
}
class EnsPlugin extends NetworkPlugin {
  /**
   *  Creates a new **EnsPlugin** connected to %%address%% on the
   *  %%targetNetwork%%. The default ENS address and mainnet is used
   *  if unspecified.
   */
  constructor(address, targetNetwork) {
    super("org.ethers.plugins.network.Ens");
    /**
     *  The ENS Registrty Contract address.
     */
    __publicField(this, "address");
    /**
     *  The chain ID that the ENS contract lives on.
     */
    __publicField(this, "targetNetwork");
    defineProperties(this, {
      address: address || EnsAddress,
      targetNetwork: targetNetwork == null ? 1 : targetNetwork
    });
  }
  clone() {
    return new EnsPlugin(this.address, this.targetNetwork);
  }
}
class FetchUrlFeeDataNetworkPlugin extends NetworkPlugin {
  /**
   *  Creates a new **FetchUrlFeeDataNetworkPlugin** which will
   *  be used when computing the fee data for the network.
   */
  constructor(url, processFunc) {
    super("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
    __privateAdd(this, _url2);
    __privateAdd(this, _processFunc);
    __privateSet(this, _url2, url);
    __privateSet(this, _processFunc, processFunc);
  }
  /**
   *  The URL to initialize the FetchRequest with in %%processFunc%%.
   */
  get url() {
    return __privateGet(this, _url2);
  }
  /**
   *  The callback to use when computing the FeeData.
   */
  get processFunc() {
    return __privateGet(this, _processFunc);
  }
  // We are immutable, so we can serve as our own clone
  clone() {
    return this;
  }
}
_url2 = new WeakMap();
_processFunc = new WeakMap();
const Networks = /* @__PURE__ */ new Map();
const _Network = class _Network {
  /**
   *  Creates a new **Network** for %%name%% and %%chainId%%.
   */
  constructor(name, chainId) {
    __privateAdd(this, _name);
    __privateAdd(this, _chainId2);
    __privateAdd(this, _plugins);
    __privateSet(this, _name, name);
    __privateSet(this, _chainId2, getBigInt(chainId));
    __privateSet(this, _plugins, /* @__PURE__ */ new Map());
  }
  /**
   *  Returns a JSON-compatible representation of a Network.
   */
  toJSON() {
    return { name: this.name, chainId: String(this.chainId) };
  }
  /**
   *  The network common name.
   *
   *  This is the canonical name, as networks migh have multiple
   *  names.
   */
  get name() {
    return __privateGet(this, _name);
  }
  set name(value) {
    __privateSet(this, _name, value);
  }
  /**
   *  The network chain ID.
   */
  get chainId() {
    return __privateGet(this, _chainId2);
  }
  set chainId(value) {
    __privateSet(this, _chainId2, getBigInt(value, "chainId"));
  }
  /**
   *  Returns true if %%other%% matches this network. Any chain ID
   *  must match, and if no chain ID is present, the name must match.
   *
   *  This method does not currently check for additional properties,
   *  such as ENS address or plug-in compatibility.
   */
  matches(other) {
    if (other == null) {
      return false;
    }
    if (typeof other === "string") {
      try {
        return this.chainId === getBigInt(other);
      } catch (error) {
      }
      return this.name === other;
    }
    if (typeof other === "number" || typeof other === "bigint") {
      try {
        return this.chainId === getBigInt(other);
      } catch (error) {
      }
      return false;
    }
    if (typeof other === "object") {
      if (other.chainId != null) {
        try {
          return this.chainId === getBigInt(other.chainId);
        } catch (error) {
        }
        return false;
      }
      if (other.name != null) {
        return this.name === other.name;
      }
      return false;
    }
    return false;
  }
  /**
   *  Returns the list of plugins currently attached to this Network.
   */
  get plugins() {
    return Array.from(__privateGet(this, _plugins).values());
  }
  /**
   *  Attach a new %%plugin%% to this Network. The network name
   *  must be unique, excluding any fragment.
   */
  attachPlugin(plugin) {
    if (__privateGet(this, _plugins).get(plugin.name)) {
      throw new Error(`cannot replace existing plugin: ${plugin.name} `);
    }
    __privateGet(this, _plugins).set(plugin.name, plugin.clone());
    return this;
  }
  /**
   *  Return the plugin, if any, matching %%name%% exactly. Plugins
   *  with fragments will not be returned unless %%name%% includes
   *  a fragment.
   */
  getPlugin(name) {
    return __privateGet(this, _plugins).get(name) || null;
  }
  /**
   *  Gets a list of all plugins that match %%name%%, with otr without
   *  a fragment.
   */
  getPlugins(basename2) {
    return this.plugins.filter((p2) => p2.name.split("#")[0] === basename2);
  }
  /**
   *  Create a copy of this Network.
   */
  clone() {
    const clone = new _Network(this.name, this.chainId);
    this.plugins.forEach((plugin) => {
      clone.attachPlugin(plugin.clone());
    });
    return clone;
  }
  /**
   *  Compute the intrinsic gas required for a transaction.
   *
   *  A GasCostPlugin can be attached to override the default
   *  values.
   */
  computeIntrinsicGas(tx) {
    const costs = this.getPlugin("org.ethers.plugins.network.GasCost") || new GasCostPlugin();
    let gas = costs.txBase;
    if (tx.to == null) {
      gas += costs.txCreate;
    }
    if (tx.data) {
      for (let i = 2; i < tx.data.length; i += 2) {
        if (tx.data.substring(i, i + 2) === "00") {
          gas += costs.txDataZero;
        } else {
          gas += costs.txDataNonzero;
        }
      }
    }
    if (tx.accessList) {
      const accessList = accessListify(tx.accessList);
      for (const addr in accessList) {
        gas += costs.txAccessListAddress + costs.txAccessListStorageKey * accessList[addr].storageKeys.length;
      }
    }
    return gas;
  }
  /**
   *  Returns a new Network for the %%network%% name or chainId.
   */
  static from(network) {
    injectCommonNetworks();
    if (network == null) {
      return _Network.from("mainnet");
    }
    if (typeof network === "number") {
      network = BigInt(network);
    }
    if (typeof network === "string" || typeof network === "bigint") {
      const networkFunc = Networks.get(network);
      if (networkFunc) {
        return networkFunc();
      }
      if (typeof network === "bigint") {
        return new _Network("unknown", network);
      }
      assertArgument(false, "unknown network", "network", network);
    }
    if (typeof network.clone === "function") {
      const clone = network.clone();
      return clone;
    }
    if (typeof network === "object") {
      assertArgument(typeof network.name === "string" && typeof network.chainId === "number", "invalid network object name or chainId", "network", network);
      const custom = new _Network(network.name, network.chainId);
      if (network.ensAddress || network.ensNetwork != null) {
        custom.attachPlugin(new EnsPlugin(network.ensAddress, network.ensNetwork));
      }
      return custom;
    }
    assertArgument(false, "invalid network", "network", network);
  }
  /**
   *  Register %%nameOrChainId%% with a function which returns
   *  an instance of a Network representing that chain.
   */
  static register(nameOrChainId, networkFunc) {
    if (typeof nameOrChainId === "number") {
      nameOrChainId = BigInt(nameOrChainId);
    }
    const existing = Networks.get(nameOrChainId);
    if (existing) {
      assertArgument(false, `conflicting network for ${JSON.stringify(existing.name)}`, "nameOrChainId", nameOrChainId);
    }
    Networks.set(nameOrChainId, networkFunc);
  }
};
_name = new WeakMap();
_chainId2 = new WeakMap();
_plugins = new WeakMap();
let Network = _Network;
function parseUnits(_value2, decimals) {
  const value = String(_value2);
  if (!value.match(/^[0-9.]+$/)) {
    throw new Error(`invalid gwei value: ${_value2}`);
  }
  const comps = value.split(".");
  if (comps.length === 1) {
    comps.push("");
  }
  if (comps.length !== 2) {
    throw new Error(`invalid gwei value: ${_value2}`);
  }
  while (comps[1].length < decimals) {
    comps[1] += "0";
  }
  if (comps[1].length > 9) {
    let frac = BigInt(comps[1].substring(0, 9));
    if (!comps[1].substring(9).match(/^0+$/)) {
      frac++;
    }
    comps[1] = frac.toString();
  }
  return BigInt(comps[0] + comps[1]);
}
function getGasStationPlugin(url) {
  return new FetchUrlFeeDataNetworkPlugin(url, async (fetchFeeData, provider, request2) => {
    request2.setHeader("User-Agent", "ethers");
    let response;
    try {
      const [_response, _feeData] = await Promise.all([
        request2.send(),
        fetchFeeData()
      ]);
      response = _response;
      const payload = response.bodyJson.standard;
      const feeData = {
        gasPrice: _feeData.gasPrice,
        maxFeePerGas: parseUnits(payload.maxFee, 9),
        maxPriorityFeePerGas: parseUnits(payload.maxPriorityFee, 9)
      };
      return feeData;
    } catch (error) {
      assert(false, `error encountered with polygon gas station (${JSON.stringify(request2.url)})`, "SERVER_ERROR", { request: request2, response, error });
    }
  });
}
let injected = false;
function injectCommonNetworks() {
  if (injected) {
    return;
  }
  injected = true;
  function registerEth(name, chainId, options) {
    const func = function() {
      const network = new Network(name, chainId);
      if (options.ensNetwork != null) {
        network.attachPlugin(new EnsPlugin(null, options.ensNetwork));
      }
      network.attachPlugin(new GasCostPlugin());
      (options.plugins || []).forEach((plugin) => {
        network.attachPlugin(plugin);
      });
      return network;
    };
    Network.register(name, func);
    Network.register(chainId, func);
    if (options.altNames) {
      options.altNames.forEach((name2) => {
        Network.register(name2, func);
      });
    }
  }
  registerEth("mainnet", 1, { ensNetwork: 1, altNames: ["homestead"] });
  registerEth("ropsten", 3, { ensNetwork: 3 });
  registerEth("rinkeby", 4, { ensNetwork: 4 });
  registerEth("goerli", 5, { ensNetwork: 5 });
  registerEth("kovan", 42, { ensNetwork: 42 });
  registerEth("sepolia", 11155111, { ensNetwork: 11155111 });
  registerEth("holesky", 17e3, { ensNetwork: 17e3 });
  registerEth("classic", 61, {});
  registerEth("classicKotti", 6, {});
  registerEth("arbitrum", 42161, {
    ensNetwork: 1
  });
  registerEth("arbitrum-goerli", 421613, {});
  registerEth("arbitrum-sepolia", 421614, {});
  registerEth("base", 8453, { ensNetwork: 1 });
  registerEth("base-goerli", 84531, {});
  registerEth("base-sepolia", 84532, {});
  registerEth("bnb", 56, { ensNetwork: 1 });
  registerEth("bnbt", 97, {});
  registerEth("linea", 59144, { ensNetwork: 1 });
  registerEth("linea-goerli", 59140, {});
  registerEth("linea-sepolia", 59141, {});
  registerEth("matic", 137, {
    ensNetwork: 1,
    plugins: [
      getGasStationPlugin("https://gasstation.polygon.technology/v2")
    ]
  });
  registerEth("matic-amoy", 80002, {});
  registerEth("matic-mumbai", 80001, {
    altNames: ["maticMumbai", "maticmum"],
    plugins: [
      getGasStationPlugin("https://gasstation-testnet.polygon.technology/v2")
    ]
  });
  registerEth("optimism", 10, {
    ensNetwork: 1,
    plugins: []
  });
  registerEth("optimism-goerli", 420, {});
  registerEth("optimism-sepolia", 11155420, {});
  registerEth("xdai", 100, { ensNetwork: 1 });
}
function copy$2(obj) {
  return JSON.parse(JSON.stringify(obj));
}
class PollingBlockSubscriber {
  /**
   *  Create a new **PollingBlockSubscriber** attached to %%provider%%.
   */
  constructor(provider) {
    __privateAdd(this, _PollingBlockSubscriber_instances);
    __privateAdd(this, _provider);
    __privateAdd(this, _poller);
    __privateAdd(this, _interval);
    // The most recent block we have scanned for events. The value -2
    // indicates we still need to fetch an initial block number
    __privateAdd(this, _blockNumber);
    __privateSet(this, _provider, provider);
    __privateSet(this, _poller, null);
    __privateSet(this, _interval, 4e3);
    __privateSet(this, _blockNumber, -2);
  }
  /**
   *  The polling interval.
   */
  get pollingInterval() {
    return __privateGet(this, _interval);
  }
  set pollingInterval(value) {
    __privateSet(this, _interval, value);
  }
  start() {
    if (__privateGet(this, _poller)) {
      return;
    }
    __privateSet(this, _poller, __privateGet(this, _provider)._setTimeout(__privateMethod(this, _PollingBlockSubscriber_instances, poll_fn).bind(this), __privateGet(this, _interval)));
    __privateMethod(this, _PollingBlockSubscriber_instances, poll_fn).call(this);
  }
  stop() {
    if (!__privateGet(this, _poller)) {
      return;
    }
    __privateGet(this, _provider)._clearTimeout(__privateGet(this, _poller));
    __privateSet(this, _poller, null);
  }
  pause(dropWhilePaused) {
    this.stop();
    if (dropWhilePaused) {
      __privateSet(this, _blockNumber, -2);
    }
  }
  resume() {
    this.start();
  }
}
_provider = new WeakMap();
_poller = new WeakMap();
_interval = new WeakMap();
_blockNumber = new WeakMap();
_PollingBlockSubscriber_instances = new WeakSet();
poll_fn = async function() {
  try {
    const blockNumber = await __privateGet(this, _provider).getBlockNumber();
    if (__privateGet(this, _blockNumber) === -2) {
      __privateSet(this, _blockNumber, blockNumber);
      return;
    }
    if (blockNumber !== __privateGet(this, _blockNumber)) {
      for (let b2 = __privateGet(this, _blockNumber) + 1; b2 <= blockNumber; b2++) {
        if (__privateGet(this, _poller) == null) {
          return;
        }
        await __privateGet(this, _provider).emit("block", b2);
      }
      __privateSet(this, _blockNumber, blockNumber);
    }
  } catch (error) {
  }
  if (__privateGet(this, _poller) == null) {
    return;
  }
  __privateSet(this, _poller, __privateGet(this, _provider)._setTimeout(__privateMethod(this, _PollingBlockSubscriber_instances, poll_fn).bind(this), __privateGet(this, _interval)));
};
class OnBlockSubscriber {
  /**
   *  Create a new **OnBlockSubscriber** attached to %%provider%%.
   */
  constructor(provider) {
    __privateAdd(this, _provider2);
    __privateAdd(this, _poll);
    __privateAdd(this, _running);
    __privateSet(this, _provider2, provider);
    __privateSet(this, _running, false);
    __privateSet(this, _poll, (blockNumber) => {
      this._poll(blockNumber, __privateGet(this, _provider2));
    });
  }
  /**
   *  Called on every new block.
   */
  async _poll(blockNumber, provider) {
    throw new Error("sub-classes must override this");
  }
  start() {
    if (__privateGet(this, _running)) {
      return;
    }
    __privateSet(this, _running, true);
    __privateGet(this, _poll).call(this, -2);
    __privateGet(this, _provider2).on("block", __privateGet(this, _poll));
  }
  stop() {
    if (!__privateGet(this, _running)) {
      return;
    }
    __privateSet(this, _running, false);
    __privateGet(this, _provider2).off("block", __privateGet(this, _poll));
  }
  pause(dropWhilePaused) {
    this.stop();
  }
  resume() {
    this.start();
  }
}
_provider2 = new WeakMap();
_poll = new WeakMap();
_running = new WeakMap();
class PollingBlockTagSubscriber extends OnBlockSubscriber {
  constructor(provider, tag) {
    super(provider);
    __privateAdd(this, _tag);
    __privateAdd(this, _lastBlock);
    __privateSet(this, _tag, tag);
    __privateSet(this, _lastBlock, -2);
  }
  pause(dropWhilePaused) {
    if (dropWhilePaused) {
      __privateSet(this, _lastBlock, -2);
    }
    super.pause(dropWhilePaused);
  }
  async _poll(blockNumber, provider) {
    const block = await provider.getBlock(__privateGet(this, _tag));
    if (block == null) {
      return;
    }
    if (__privateGet(this, _lastBlock) === -2) {
      __privateSet(this, _lastBlock, block.number);
    } else if (block.number > __privateGet(this, _lastBlock)) {
      provider.emit(__privateGet(this, _tag), block.number);
      __privateSet(this, _lastBlock, block.number);
    }
  }
}
_tag = new WeakMap();
_lastBlock = new WeakMap();
class PollingOrphanSubscriber extends OnBlockSubscriber {
  constructor(provider, filter) {
    super(provider);
    __privateAdd(this, _filter2);
    __privateSet(this, _filter2, copy$2(filter));
  }
  async _poll(blockNumber, provider) {
    throw new Error("@TODO");
  }
}
_filter2 = new WeakMap();
class PollingTransactionSubscriber extends OnBlockSubscriber {
  /**
   *  Create a new **PollingTransactionSubscriber** attached to
   *  %%provider%%, listening for %%hash%%.
   */
  constructor(provider, hash) {
    super(provider);
    __privateAdd(this, _hash);
    __privateSet(this, _hash, hash);
  }
  async _poll(blockNumber, provider) {
    const tx = await provider.getTransactionReceipt(__privateGet(this, _hash));
    if (tx) {
      provider.emit(__privateGet(this, _hash), tx);
    }
  }
}
_hash = new WeakMap();
class PollingEventSubscriber {
  /**
   *  Create a new **PollingTransactionSubscriber** attached to
   *  %%provider%%, listening for %%filter%%.
   */
  constructor(provider, filter) {
    __privateAdd(this, _PollingEventSubscriber_instances);
    __privateAdd(this, _provider3);
    __privateAdd(this, _filter3);
    __privateAdd(this, _poller2);
    __privateAdd(this, _running2);
    // The most recent block we have scanned for events. The value -2
    // indicates we still need to fetch an initial block number
    __privateAdd(this, _blockNumber2);
    __privateSet(this, _provider3, provider);
    __privateSet(this, _filter3, copy$2(filter));
    __privateSet(this, _poller2, __privateMethod(this, _PollingEventSubscriber_instances, poll_fn2).bind(this));
    __privateSet(this, _running2, false);
    __privateSet(this, _blockNumber2, -2);
  }
  start() {
    if (__privateGet(this, _running2)) {
      return;
    }
    __privateSet(this, _running2, true);
    if (__privateGet(this, _blockNumber2) === -2) {
      __privateGet(this, _provider3).getBlockNumber().then((blockNumber) => {
        __privateSet(this, _blockNumber2, blockNumber);
      });
    }
    __privateGet(this, _provider3).on("block", __privateGet(this, _poller2));
  }
  stop() {
    if (!__privateGet(this, _running2)) {
      return;
    }
    __privateSet(this, _running2, false);
    __privateGet(this, _provider3).off("block", __privateGet(this, _poller2));
  }
  pause(dropWhilePaused) {
    this.stop();
    if (dropWhilePaused) {
      __privateSet(this, _blockNumber2, -2);
    }
  }
  resume() {
    this.start();
  }
}
_provider3 = new WeakMap();
_filter3 = new WeakMap();
_poller2 = new WeakMap();
_running2 = new WeakMap();
_blockNumber2 = new WeakMap();
_PollingEventSubscriber_instances = new WeakSet();
poll_fn2 = async function(blockNumber) {
  if (__privateGet(this, _blockNumber2) === -2) {
    return;
  }
  const filter = copy$2(__privateGet(this, _filter3));
  filter.fromBlock = __privateGet(this, _blockNumber2) + 1;
  filter.toBlock = blockNumber;
  const logs = await __privateGet(this, _provider3).getLogs(filter);
  if (logs.length === 0) {
    if (__privateGet(this, _blockNumber2) < blockNumber - 60) {
      __privateSet(this, _blockNumber2, blockNumber - 60);
    }
    return;
  }
  for (const log of logs) {
    __privateGet(this, _provider3).emit(__privateGet(this, _filter3), log);
    __privateSet(this, _blockNumber2, log.blockNumber);
  }
};
const BN_2 = BigInt(2);
const MAX_CCIP_REDIRECTS = 10;
function isPromise(value) {
  return value && typeof value.then === "function";
}
function getTag(prefix, value) {
  return prefix + ":" + JSON.stringify(value, (k2, v3) => {
    if (v3 == null) {
      return "null";
    }
    if (typeof v3 === "bigint") {
      return `bigint:${v3.toString()}`;
    }
    if (typeof v3 === "string") {
      return v3.toLowerCase();
    }
    if (typeof v3 === "object" && !Array.isArray(v3)) {
      const keys = Object.keys(v3);
      keys.sort();
      return keys.reduce((accum, key) => {
        accum[key] = v3[key];
        return accum;
      }, {});
    }
    return v3;
  });
}
class UnmanagedSubscriber {
  /**
   *  Create a new UnmanagedSubscriber with %%name%%.
   */
  constructor(name) {
    /**
     *  The name fof the event.
     */
    __publicField(this, "name");
    defineProperties(this, { name });
  }
  start() {
  }
  stop() {
  }
  pause(dropWhilePaused) {
  }
  resume() {
  }
}
function copy$1(value) {
  return JSON.parse(JSON.stringify(value));
}
function concisify(items) {
  items = Array.from(new Set(items).values());
  items.sort();
  return items;
}
async function getSubscription(_event2, provider) {
  if (_event2 == null) {
    throw new Error("invalid event");
  }
  if (Array.isArray(_event2)) {
    _event2 = { topics: _event2 };
  }
  if (typeof _event2 === "string") {
    switch (_event2) {
      case "block":
      case "debug":
      case "error":
      case "finalized":
      case "network":
      case "pending":
      case "safe": {
        return { type: _event2, tag: _event2 };
      }
    }
  }
  if (isHexString(_event2, 32)) {
    const hash = _event2.toLowerCase();
    return { type: "transaction", tag: getTag("tx", { hash }), hash };
  }
  if (_event2.orphan) {
    const event = _event2;
    return { type: "orphan", tag: getTag("orphan", event), filter: copy$1(event) };
  }
  if (_event2.address || _event2.topics) {
    const event = _event2;
    const filter = {
      topics: (event.topics || []).map((t) => {
        if (t == null) {
          return null;
        }
        if (Array.isArray(t)) {
          return concisify(t.map((t2) => t2.toLowerCase()));
        }
        return t.toLowerCase();
      })
    };
    if (event.address) {
      const addresses = [];
      const promises = [];
      const addAddress = (addr) => {
        if (isHexString(addr)) {
          addresses.push(addr);
        } else {
          promises.push((async () => {
            addresses.push(await resolveAddress(addr, provider));
          })());
        }
      };
      if (Array.isArray(event.address)) {
        event.address.forEach(addAddress);
      } else {
        addAddress(event.address);
      }
      if (promises.length) {
        await Promise.all(promises);
      }
      filter.address = concisify(addresses.map((a2) => a2.toLowerCase()));
    }
    return { filter, tag: getTag("event", filter), type: "event" };
  }
  assertArgument(false, "unknown ProviderEvent", "event", _event2);
}
function getTime() {
  return (/* @__PURE__ */ new Date()).getTime();
}
const defaultOptions$1 = {
  cacheTimeout: 250,
  pollingInterval: 4e3
};
class AbstractProvider {
  /**
   *  Create a new **AbstractProvider** connected to %%network%%, or
   *  use the various network detection capabilities to discover the
   *  [[Network]] if necessary.
   */
  constructor(_network3, options) {
    __privateAdd(this, _AbstractProvider_instances);
    __privateAdd(this, _subs);
    __privateAdd(this, _plugins2);
    // null=unpaused, true=paused+dropWhilePaused, false=paused
    __privateAdd(this, _pausedState);
    __privateAdd(this, _destroyed);
    __privateAdd(this, _networkPromise);
    __privateAdd(this, _anyNetwork);
    __privateAdd(this, _performCache);
    // The most recent block number if running an event or -1 if no "block" event
    __privateAdd(this, _lastBlockNumber);
    __privateAdd(this, _nextTimer);
    __privateAdd(this, _timers);
    __privateAdd(this, _disableCcipRead);
    __privateAdd(this, _options2);
    __privateSet(this, _options2, Object.assign({}, defaultOptions$1, options || {}));
    if (_network3 === "any") {
      __privateSet(this, _anyNetwork, true);
      __privateSet(this, _networkPromise, null);
    } else if (_network3) {
      const network = Network.from(_network3);
      __privateSet(this, _anyNetwork, false);
      __privateSet(this, _networkPromise, Promise.resolve(network));
      setTimeout(() => {
        this.emit("network", network, null);
      }, 0);
    } else {
      __privateSet(this, _anyNetwork, false);
      __privateSet(this, _networkPromise, null);
    }
    __privateSet(this, _lastBlockNumber, -1);
    __privateSet(this, _performCache, /* @__PURE__ */ new Map());
    __privateSet(this, _subs, /* @__PURE__ */ new Map());
    __privateSet(this, _plugins2, /* @__PURE__ */ new Map());
    __privateSet(this, _pausedState, null);
    __privateSet(this, _destroyed, false);
    __privateSet(this, _nextTimer, 1);
    __privateSet(this, _timers, /* @__PURE__ */ new Map());
    __privateSet(this, _disableCcipRead, false);
  }
  get pollingInterval() {
    return __privateGet(this, _options2).pollingInterval;
  }
  /**
   *  Returns ``this``, to allow an **AbstractProvider** to implement
   *  the [[ContractRunner]] interface.
   */
  get provider() {
    return this;
  }
  /**
   *  Returns all the registered plug-ins.
   */
  get plugins() {
    return Array.from(__privateGet(this, _plugins2).values());
  }
  /**
   *  Attach a new plug-in.
   */
  attachPlugin(plugin) {
    if (__privateGet(this, _plugins2).get(plugin.name)) {
      throw new Error(`cannot replace existing plugin: ${plugin.name} `);
    }
    __privateGet(this, _plugins2).set(plugin.name, plugin.connect(this));
    return this;
  }
  /**
   *  Get a plugin by name.
   */
  getPlugin(name) {
    return __privateGet(this, _plugins2).get(name) || null;
  }
  /**
   *  Prevent any CCIP-read operation, regardless of whether requested
   *  in a [[call]] using ``enableCcipRead``.
   */
  get disableCcipRead() {
    return __privateGet(this, _disableCcipRead);
  }
  set disableCcipRead(value) {
    __privateSet(this, _disableCcipRead, !!value);
  }
  /**
   *  Resolves to the data for executing the CCIP-read operations.
   */
  async ccipReadFetch(tx, calldata, urls) {
    if (this.disableCcipRead || urls.length === 0 || tx.to == null) {
      return null;
    }
    const sender = tx.to.toLowerCase();
    const data = calldata.toLowerCase();
    const errorMessages = [];
    for (let i = 0; i < urls.length; i++) {
      const url = urls[i];
      const href = url.replace("{sender}", sender).replace("{data}", data);
      const request2 = new FetchRequest(href);
      if (url.indexOf("{data}") === -1) {
        request2.body = { data, sender };
      }
      this.emit("debug", { action: "sendCcipReadFetchRequest", request: request2, index: i, urls });
      let errorMessage = "unknown error";
      let resp;
      try {
        resp = await request2.send();
      } catch (error) {
        errorMessages.push(error.message);
        this.emit("debug", { action: "receiveCcipReadFetchError", request: request2, result: { error } });
        continue;
      }
      try {
        const result = resp.bodyJson;
        if (result.data) {
          this.emit("debug", { action: "receiveCcipReadFetchResult", request: request2, result });
          return result.data;
        }
        if (result.message) {
          errorMessage = result.message;
        }
        this.emit("debug", { action: "receiveCcipReadFetchError", request: request2, result });
      } catch (error) {
      }
      assert(resp.statusCode < 400 || resp.statusCode >= 500, `response not found during CCIP fetch: ${errorMessage}`, "OFFCHAIN_FAULT", { reason: "404_MISSING_RESOURCE", transaction: tx, info: { url, errorMessage } });
      errorMessages.push(errorMessage);
    }
    assert(false, `error encountered during CCIP fetch: ${errorMessages.map((m2) => JSON.stringify(m2)).join(", ")}`, "OFFCHAIN_FAULT", {
      reason: "500_SERVER_ERROR",
      transaction: tx,
      info: { urls, errorMessages }
    });
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a block before
   *  returning it, to add additional properties or an alternate
   *  sub-class of [[Block]].
   */
  _wrapBlock(value, network) {
    return new Block(formatBlock(value), this);
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a log before
   *  returning it, to add additional properties or an alternate
   *  sub-class of [[Log]].
   */
  _wrapLog(value, network) {
    return new Log(formatLog(value), this);
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a transaction
   *  receipt before returning it, to add additional properties or an
   *  alternate sub-class of [[TransactionReceipt]].
   */
  _wrapTransactionReceipt(value, network) {
    return new TransactionReceipt(formatTransactionReceipt(value), this);
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a transaction
   *  response before returning it, to add additional properties or an
   *  alternate sub-class of [[TransactionResponse]].
   */
  _wrapTransactionResponse(tx, network) {
    return new TransactionResponse(formatTransactionResponse(tx), this);
  }
  /**
   *  Resolves to the Network, forcing a network detection using whatever
   *  technique the sub-class requires.
   *
   *  Sub-classes **must** override this.
   */
  _detectNetwork() {
    assert(false, "sub-classes must implement this", "UNSUPPORTED_OPERATION", {
      operation: "_detectNetwork"
    });
  }
  /**
   *  Sub-classes should use this to perform all built-in operations. All
   *  methods sanitizes and normalizes the values passed into this.
   *
   *  Sub-classes **must** override this.
   */
  async _perform(req) {
    assert(false, `unsupported method: ${req.method}`, "UNSUPPORTED_OPERATION", {
      operation: req.method,
      info: req
    });
  }
  // State
  async getBlockNumber() {
    const blockNumber = getNumber(await __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, { method: "getBlockNumber" }), "%response");
    if (__privateGet(this, _lastBlockNumber) >= 0) {
      __privateSet(this, _lastBlockNumber, blockNumber);
    }
    return blockNumber;
  }
  /**
   *  Returns or resolves to the address for %%address%%, resolving ENS
   *  names and [[Addressable]] objects and returning if already an
   *  address.
   */
  _getAddress(address) {
    return resolveAddress(address, this);
  }
  /**
   *  Returns or resolves to a valid block tag for %%blockTag%%, resolving
   *  negative values and returning if already a valid block tag.
   */
  _getBlockTag(blockTag) {
    if (blockTag == null) {
      return "latest";
    }
    switch (blockTag) {
      case "earliest":
        return "0x0";
      case "finalized":
      case "latest":
      case "pending":
      case "safe":
        return blockTag;
    }
    if (isHexString(blockTag)) {
      if (isHexString(blockTag, 32)) {
        return blockTag;
      }
      return toQuantity(blockTag);
    }
    if (typeof blockTag === "bigint") {
      blockTag = getNumber(blockTag, "blockTag");
    }
    if (typeof blockTag === "number") {
      if (blockTag >= 0) {
        return toQuantity(blockTag);
      }
      if (__privateGet(this, _lastBlockNumber) >= 0) {
        return toQuantity(__privateGet(this, _lastBlockNumber) + blockTag);
      }
      return this.getBlockNumber().then((b2) => toQuantity(b2 + blockTag));
    }
    assertArgument(false, "invalid blockTag", "blockTag", blockTag);
  }
  /**
   *  Returns or resolves to a filter for %%filter%%, resolving any ENS
   *  names or [[Addressable]] object and returning if already a valid
   *  filter.
   */
  _getFilter(filter) {
    const topics = (filter.topics || []).map((t) => {
      if (t == null) {
        return null;
      }
      if (Array.isArray(t)) {
        return concisify(t.map((t2) => t2.toLowerCase()));
      }
      return t.toLowerCase();
    });
    const blockHash = "blockHash" in filter ? filter.blockHash : void 0;
    const resolve = (_address, fromBlock2, toBlock2) => {
      let address2 = void 0;
      switch (_address.length) {
        case 0:
          break;
        case 1:
          address2 = _address[0];
          break;
        default:
          _address.sort();
          address2 = _address;
      }
      if (blockHash) {
        if (fromBlock2 != null || toBlock2 != null) {
          throw new Error("invalid filter");
        }
      }
      const filter2 = {};
      if (address2) {
        filter2.address = address2;
      }
      if (topics.length) {
        filter2.topics = topics;
      }
      if (fromBlock2) {
        filter2.fromBlock = fromBlock2;
      }
      if (toBlock2) {
        filter2.toBlock = toBlock2;
      }
      if (blockHash) {
        filter2.blockHash = blockHash;
      }
      return filter2;
    };
    let address = [];
    if (filter.address) {
      if (Array.isArray(filter.address)) {
        for (const addr of filter.address) {
          address.push(this._getAddress(addr));
        }
      } else {
        address.push(this._getAddress(filter.address));
      }
    }
    let fromBlock = void 0;
    if ("fromBlock" in filter) {
      fromBlock = this._getBlockTag(filter.fromBlock);
    }
    let toBlock = void 0;
    if ("toBlock" in filter) {
      toBlock = this._getBlockTag(filter.toBlock);
    }
    if (address.filter((a2) => typeof a2 !== "string").length || fromBlock != null && typeof fromBlock !== "string" || toBlock != null && typeof toBlock !== "string") {
      return Promise.all([Promise.all(address), fromBlock, toBlock]).then((result) => {
        return resolve(result[0], result[1], result[2]);
      });
    }
    return resolve(address, fromBlock, toBlock);
  }
  /**
   *  Returns or resolves to a transaction for %%request%%, resolving
   *  any ENS names or [[Addressable]] and returning if already a valid
   *  transaction.
   */
  _getTransactionRequest(_request3) {
    const request2 = copyRequest(_request3);
    const promises = [];
    ["to", "from"].forEach((key) => {
      if (request2[key] == null) {
        return;
      }
      const addr = resolveAddress(request2[key], this);
      if (isPromise(addr)) {
        promises.push(async function() {
          request2[key] = await addr;
        }());
      } else {
        request2[key] = addr;
      }
    });
    if (request2.blockTag != null) {
      const blockTag = this._getBlockTag(request2.blockTag);
      if (isPromise(blockTag)) {
        promises.push(async function() {
          request2.blockTag = await blockTag;
        }());
      } else {
        request2.blockTag = blockTag;
      }
    }
    if (promises.length) {
      return async function() {
        await Promise.all(promises);
        return request2;
      }();
    }
    return request2;
  }
  async getNetwork() {
    if (__privateGet(this, _networkPromise) == null) {
      const detectNetwork = (async () => {
        try {
          const network = await this._detectNetwork();
          this.emit("network", network, null);
          return network;
        } catch (error) {
          if (__privateGet(this, _networkPromise) === detectNetwork) {
            __privateSet(this, _networkPromise, null);
          }
          throw error;
        }
      })();
      __privateSet(this, _networkPromise, detectNetwork);
      return (await detectNetwork).clone();
    }
    const networkPromise = __privateGet(this, _networkPromise);
    const [expected, actual] = await Promise.all([
      networkPromise,
      this._detectNetwork()
      // The actual connected network
    ]);
    if (expected.chainId !== actual.chainId) {
      if (__privateGet(this, _anyNetwork)) {
        this.emit("network", actual, expected);
        if (__privateGet(this, _networkPromise) === networkPromise) {
          __privateSet(this, _networkPromise, Promise.resolve(actual));
        }
      } else {
        assert(false, `network changed: ${expected.chainId} => ${actual.chainId} `, "NETWORK_ERROR", {
          event: "changed"
        });
      }
    }
    return expected.clone();
  }
  async getFeeData() {
    const network = await this.getNetwork();
    const getFeeDataFunc = async () => {
      const { _block, gasPrice, priorityFee } = await resolveProperties({
        _block: __privateMethod(this, _AbstractProvider_instances, getBlock_fn).call(this, "latest", false),
        gasPrice: (async () => {
          try {
            const value = await __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, { method: "getGasPrice" });
            return getBigInt(value, "%response");
          } catch (error) {
          }
          return null;
        })(),
        priorityFee: (async () => {
          try {
            const value = await __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, { method: "getPriorityFee" });
            return getBigInt(value, "%response");
          } catch (error) {
          }
          return null;
        })()
      });
      let maxFeePerGas = null;
      let maxPriorityFeePerGas = null;
      const block = this._wrapBlock(_block, network);
      if (block && block.baseFeePerGas) {
        maxPriorityFeePerGas = priorityFee != null ? priorityFee : BigInt("1000000000");
        maxFeePerGas = block.baseFeePerGas * BN_2 + maxPriorityFeePerGas;
      }
      return new FeeData(gasPrice, maxFeePerGas, maxPriorityFeePerGas);
    };
    const plugin = network.getPlugin("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
    if (plugin) {
      const req = new FetchRequest(plugin.url);
      const feeData = await plugin.processFunc(getFeeDataFunc, this, req);
      return new FeeData(feeData.gasPrice, feeData.maxFeePerGas, feeData.maxPriorityFeePerGas);
    }
    return await getFeeDataFunc();
  }
  async estimateGas(_tx) {
    let tx = this._getTransactionRequest(_tx);
    if (isPromise(tx)) {
      tx = await tx;
    }
    return getBigInt(await __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, {
      method: "estimateGas",
      transaction: tx
    }), "%response");
  }
  async call(_tx) {
    const { tx, blockTag } = await resolveProperties({
      tx: this._getTransactionRequest(_tx),
      blockTag: this._getBlockTag(_tx.blockTag)
    });
    return await __privateMethod(this, _AbstractProvider_instances, checkNetwork_fn).call(this, __privateMethod(this, _AbstractProvider_instances, call_fn).call(this, tx, blockTag, _tx.enableCcipRead ? 0 : -1));
  }
  async getBalance(address, blockTag) {
    return getBigInt(await __privateMethod(this, _AbstractProvider_instances, getAccountValue_fn).call(this, { method: "getBalance" }, address, blockTag), "%response");
  }
  async getTransactionCount(address, blockTag) {
    return getNumber(await __privateMethod(this, _AbstractProvider_instances, getAccountValue_fn).call(this, { method: "getTransactionCount" }, address, blockTag), "%response");
  }
  async getCode(address, blockTag) {
    return hexlify(await __privateMethod(this, _AbstractProvider_instances, getAccountValue_fn).call(this, { method: "getCode" }, address, blockTag));
  }
  async getStorage(address, _position, blockTag) {
    const position = getBigInt(_position, "position");
    return hexlify(await __privateMethod(this, _AbstractProvider_instances, getAccountValue_fn).call(this, { method: "getStorage", position }, address, blockTag));
  }
  // Write
  async broadcastTransaction(signedTx) {
    const { blockNumber, hash, network } = await resolveProperties({
      blockNumber: this.getBlockNumber(),
      hash: this._perform({
        method: "broadcastTransaction",
        signedTransaction: signedTx
      }),
      network: this.getNetwork()
    });
    const tx = Transaction.from(signedTx);
    if (tx.hash !== hash) {
      throw new Error("@TODO: the returned hash did not match");
    }
    return this._wrapTransactionResponse(tx, network).replaceableTransaction(blockNumber);
  }
  // Queries
  async getBlock(block, prefetchTxs) {
    const { network, params } = await resolveProperties({
      network: this.getNetwork(),
      params: __privateMethod(this, _AbstractProvider_instances, getBlock_fn).call(this, block, !!prefetchTxs)
    });
    if (params == null) {
      return null;
    }
    return this._wrapBlock(params, network);
  }
  async getTransaction(hash) {
    const { network, params } = await resolveProperties({
      network: this.getNetwork(),
      params: __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, { method: "getTransaction", hash })
    });
    if (params == null) {
      return null;
    }
    return this._wrapTransactionResponse(params, network);
  }
  async getTransactionReceipt(hash) {
    const { network, params } = await resolveProperties({
      network: this.getNetwork(),
      params: __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, { method: "getTransactionReceipt", hash })
    });
    if (params == null) {
      return null;
    }
    if (params.gasPrice == null && params.effectiveGasPrice == null) {
      const tx = await __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, { method: "getTransaction", hash });
      if (tx == null) {
        throw new Error("report this; could not find tx or effectiveGasPrice");
      }
      params.effectiveGasPrice = tx.gasPrice;
    }
    return this._wrapTransactionReceipt(params, network);
  }
  async getTransactionResult(hash) {
    const { result } = await resolveProperties({
      network: this.getNetwork(),
      result: __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, { method: "getTransactionResult", hash })
    });
    if (result == null) {
      return null;
    }
    return hexlify(result);
  }
  // Bloom-filter Queries
  async getLogs(_filter4) {
    let filter = this._getFilter(_filter4);
    if (isPromise(filter)) {
      filter = await filter;
    }
    const { network, params } = await resolveProperties({
      network: this.getNetwork(),
      params: __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, { method: "getLogs", filter })
    });
    return params.map((p2) => this._wrapLog(p2, network));
  }
  // ENS
  _getProvider(chainId) {
    assert(false, "provider cannot connect to target network", "UNSUPPORTED_OPERATION", {
      operation: "_getProvider()"
    });
  }
  async getResolver(name) {
    return await EnsResolver.fromName(this, name);
  }
  async getAvatar(name) {
    const resolver = await this.getResolver(name);
    if (resolver) {
      return await resolver.getAvatar();
    }
    return null;
  }
  async resolveName(name) {
    const resolver = await this.getResolver(name);
    if (resolver) {
      return await resolver.getAddress();
    }
    return null;
  }
  async lookupAddress(address) {
    address = getAddress(address);
    const node = namehash(address.substring(2).toLowerCase() + ".addr.reverse");
    try {
      const ensAddr = await EnsResolver.getEnsAddress(this);
      const ensContract = new Contract(ensAddr, [
        "function resolver(bytes32) view returns (address)"
      ], this);
      const resolver = await ensContract.resolver(node);
      if (resolver == null || resolver === ZeroAddress) {
        return null;
      }
      const resolverContract = new Contract(resolver, [
        "function name(bytes32) view returns (string)"
      ], this);
      const name = await resolverContract.name(node);
      const check = await this.resolveName(name);
      if (check !== address) {
        return null;
      }
      return name;
    } catch (error) {
      if (isError(error, "BAD_DATA") && error.value === "0x") {
        return null;
      }
      if (isError(error, "CALL_EXCEPTION")) {
        return null;
      }
      throw error;
    }
    return null;
  }
  async waitForTransaction(hash, _confirms, timeout) {
    const confirms = _confirms != null ? _confirms : 1;
    if (confirms === 0) {
      return this.getTransactionReceipt(hash);
    }
    return new Promise(async (resolve, reject) => {
      let timer = null;
      const listener = async (blockNumber) => {
        try {
          const receipt = await this.getTransactionReceipt(hash);
          if (receipt != null) {
            if (blockNumber - receipt.blockNumber + 1 >= confirms) {
              resolve(receipt);
              if (timer) {
                clearTimeout(timer);
                timer = null;
              }
              return;
            }
          }
        } catch (error) {
          console.log("EEE", error);
        }
        this.once("block", listener);
      };
      if (timeout != null) {
        timer = setTimeout(() => {
          if (timer == null) {
            return;
          }
          timer = null;
          this.off("block", listener);
          reject(makeError("timeout", "TIMEOUT", { reason: "timeout" }));
        }, timeout);
      }
      listener(await this.getBlockNumber());
    });
  }
  async waitForBlock(blockTag) {
    assert(false, "not implemented yet", "NOT_IMPLEMENTED", {
      operation: "waitForBlock"
    });
  }
  /**
   *  Clear a timer created using the [[_setTimeout]] method.
   */
  _clearTimeout(timerId) {
    const timer = __privateGet(this, _timers).get(timerId);
    if (!timer) {
      return;
    }
    if (timer.timer) {
      clearTimeout(timer.timer);
    }
    __privateGet(this, _timers).delete(timerId);
  }
  /**
   *  Create a timer that will execute %%func%% after at least %%timeout%%
   *  (in ms). If %%timeout%% is unspecified, then %%func%% will execute
   *  in the next event loop.
   *
   *  [Pausing](AbstractProvider-paused) the provider will pause any
   *  associated timers.
   */
  _setTimeout(_func, timeout) {
    if (timeout == null) {
      timeout = 0;
    }
    const timerId = __privateWrapper(this, _nextTimer)._++;
    const func = () => {
      __privateGet(this, _timers).delete(timerId);
      _func();
    };
    if (this.paused) {
      __privateGet(this, _timers).set(timerId, { timer: null, func, time: timeout });
    } else {
      const timer = setTimeout(func, timeout);
      __privateGet(this, _timers).set(timerId, { timer, func, time: getTime() });
    }
    return timerId;
  }
  /**
   *  Perform %%func%% on each subscriber.
   */
  _forEachSubscriber(func) {
    for (const sub of __privateGet(this, _subs).values()) {
      func(sub.subscriber);
    }
  }
  /**
   *  Sub-classes may override this to customize subscription
   *  implementations.
   */
  _getSubscriber(sub) {
    switch (sub.type) {
      case "debug":
      case "error":
      case "network":
        return new UnmanagedSubscriber(sub.type);
      case "block": {
        const subscriber = new PollingBlockSubscriber(this);
        subscriber.pollingInterval = this.pollingInterval;
        return subscriber;
      }
      case "safe":
      case "finalized":
        return new PollingBlockTagSubscriber(this, sub.type);
      case "event":
        return new PollingEventSubscriber(this, sub.filter);
      case "transaction":
        return new PollingTransactionSubscriber(this, sub.hash);
      case "orphan":
        return new PollingOrphanSubscriber(this, sub.filter);
    }
    throw new Error(`unsupported event: ${sub.type}`);
  }
  /**
   *  If a [[Subscriber]] fails and needs to replace itself, this
   *  method may be used.
   *
   *  For example, this is used for providers when using the
   *  ``eth_getFilterChanges`` method, which can return null if state
   *  filters are not supported by the backend, allowing the Subscriber
   *  to swap in a [[PollingEventSubscriber]].
   */
  _recoverSubscriber(oldSub, newSub) {
    for (const sub of __privateGet(this, _subs).values()) {
      if (sub.subscriber === oldSub) {
        if (sub.started) {
          sub.subscriber.stop();
        }
        sub.subscriber = newSub;
        if (sub.started) {
          newSub.start();
        }
        if (__privateGet(this, _pausedState) != null) {
          newSub.pause(__privateGet(this, _pausedState));
        }
        break;
      }
    }
  }
  async on(event, listener) {
    const sub = await __privateMethod(this, _AbstractProvider_instances, getSub_fn).call(this, event);
    sub.listeners.push({ listener, once: false });
    if (!sub.started) {
      sub.subscriber.start();
      sub.started = true;
      if (__privateGet(this, _pausedState) != null) {
        sub.subscriber.pause(__privateGet(this, _pausedState));
      }
    }
    return this;
  }
  async once(event, listener) {
    const sub = await __privateMethod(this, _AbstractProvider_instances, getSub_fn).call(this, event);
    sub.listeners.push({ listener, once: true });
    if (!sub.started) {
      sub.subscriber.start();
      sub.started = true;
      if (__privateGet(this, _pausedState) != null) {
        sub.subscriber.pause(__privateGet(this, _pausedState));
      }
    }
    return this;
  }
  async emit(event, ...args) {
    const sub = await __privateMethod(this, _AbstractProvider_instances, hasSub_fn).call(this, event, args);
    if (!sub || sub.listeners.length === 0) {
      return false;
    }
    const count = sub.listeners.length;
    sub.listeners = sub.listeners.filter(({ listener, once }) => {
      const payload = new EventPayload(this, once ? null : listener, event);
      try {
        listener.call(this, ...args, payload);
      } catch (error) {
      }
      return !once;
    });
    if (sub.listeners.length === 0) {
      if (sub.started) {
        sub.subscriber.stop();
      }
      __privateGet(this, _subs).delete(sub.tag);
    }
    return count > 0;
  }
  async listenerCount(event) {
    if (event) {
      const sub = await __privateMethod(this, _AbstractProvider_instances, hasSub_fn).call(this, event);
      if (!sub) {
        return 0;
      }
      return sub.listeners.length;
    }
    let total = 0;
    for (const { listeners } of __privateGet(this, _subs).values()) {
      total += listeners.length;
    }
    return total;
  }
  async listeners(event) {
    if (event) {
      const sub = await __privateMethod(this, _AbstractProvider_instances, hasSub_fn).call(this, event);
      if (!sub) {
        return [];
      }
      return sub.listeners.map(({ listener }) => listener);
    }
    let result = [];
    for (const { listeners } of __privateGet(this, _subs).values()) {
      result = result.concat(listeners.map(({ listener }) => listener));
    }
    return result;
  }
  async off(event, listener) {
    const sub = await __privateMethod(this, _AbstractProvider_instances, hasSub_fn).call(this, event);
    if (!sub) {
      return this;
    }
    if (listener) {
      const index = sub.listeners.map(({ listener: listener2 }) => listener2).indexOf(listener);
      if (index >= 0) {
        sub.listeners.splice(index, 1);
      }
    }
    if (!listener || sub.listeners.length === 0) {
      if (sub.started) {
        sub.subscriber.stop();
      }
      __privateGet(this, _subs).delete(sub.tag);
    }
    return this;
  }
  async removeAllListeners(event) {
    if (event) {
      const { tag, started, subscriber } = await __privateMethod(this, _AbstractProvider_instances, getSub_fn).call(this, event);
      if (started) {
        subscriber.stop();
      }
      __privateGet(this, _subs).delete(tag);
    } else {
      for (const [tag, { started, subscriber }] of __privateGet(this, _subs)) {
        if (started) {
          subscriber.stop();
        }
        __privateGet(this, _subs).delete(tag);
      }
    }
    return this;
  }
  // Alias for "on"
  async addListener(event, listener) {
    return await this.on(event, listener);
  }
  // Alias for "off"
  async removeListener(event, listener) {
    return this.off(event, listener);
  }
  /**
   *  If this provider has been destroyed using the [[destroy]] method.
   *
   *  Once destroyed, all resources are reclaimed, internal event loops
   *  and timers are cleaned up and no further requests may be sent to
   *  the provider.
   */
  get destroyed() {
    return __privateGet(this, _destroyed);
  }
  /**
   *  Sub-classes may use this to shutdown any sockets or release their
   *  resources and reject any pending requests.
   *
   *  Sub-classes **must** call ``super.destroy()``.
   */
  destroy() {
    this.removeAllListeners();
    for (const timerId of __privateGet(this, _timers).keys()) {
      this._clearTimeout(timerId);
    }
    __privateSet(this, _destroyed, true);
  }
  /**
   *  Whether the provider is currently paused.
   *
   *  A paused provider will not emit any events, and generally should
   *  not make any requests to the network, but that is up to sub-classes
   *  to manage.
   *
   *  Setting ``paused = true`` is identical to calling ``.pause(false)``,
   *  which will buffer any events that occur while paused until the
   *  provider is unpaused.
   */
  get paused() {
    return __privateGet(this, _pausedState) != null;
  }
  set paused(pause) {
    if (!!pause === this.paused) {
      return;
    }
    if (this.paused) {
      this.resume();
    } else {
      this.pause(false);
    }
  }
  /**
   *  Pause the provider. If %%dropWhilePaused%%, any events that occur
   *  while paused are dropped, otherwise all events will be emitted once
   *  the provider is unpaused.
   */
  pause(dropWhilePaused) {
    __privateSet(this, _lastBlockNumber, -1);
    if (__privateGet(this, _pausedState) != null) {
      if (__privateGet(this, _pausedState) == !!dropWhilePaused) {
        return;
      }
      assert(false, "cannot change pause type; resume first", "UNSUPPORTED_OPERATION", {
        operation: "pause"
      });
    }
    this._forEachSubscriber((s2) => s2.pause(dropWhilePaused));
    __privateSet(this, _pausedState, !!dropWhilePaused);
    for (const timer of __privateGet(this, _timers).values()) {
      if (timer.timer) {
        clearTimeout(timer.timer);
      }
      timer.time = getTime() - timer.time;
    }
  }
  /**
   *  Resume the provider.
   */
  resume() {
    if (__privateGet(this, _pausedState) == null) {
      return;
    }
    this._forEachSubscriber((s2) => s2.resume());
    __privateSet(this, _pausedState, null);
    for (const timer of __privateGet(this, _timers).values()) {
      let timeout = timer.time;
      if (timeout < 0) {
        timeout = 0;
      }
      timer.time = getTime();
      setTimeout(timer.func, timeout);
    }
  }
}
_subs = new WeakMap();
_plugins2 = new WeakMap();
_pausedState = new WeakMap();
_destroyed = new WeakMap();
_networkPromise = new WeakMap();
_anyNetwork = new WeakMap();
_performCache = new WeakMap();
_lastBlockNumber = new WeakMap();
_nextTimer = new WeakMap();
_timers = new WeakMap();
_disableCcipRead = new WeakMap();
_options2 = new WeakMap();
_AbstractProvider_instances = new WeakSet();
perform_fn = async function(req) {
  const timeout = __privateGet(this, _options2).cacheTimeout;
  if (timeout < 0) {
    return await this._perform(req);
  }
  const tag = getTag(req.method, req);
  let perform = __privateGet(this, _performCache).get(tag);
  if (!perform) {
    perform = this._perform(req);
    __privateGet(this, _performCache).set(tag, perform);
    setTimeout(() => {
      if (__privateGet(this, _performCache).get(tag) === perform) {
        __privateGet(this, _performCache).delete(tag);
      }
    }, timeout);
  }
  return await perform;
};
call_fn = async function(tx, blockTag, attempt) {
  assert(attempt < MAX_CCIP_REDIRECTS, "CCIP read exceeded maximum redirections", "OFFCHAIN_FAULT", {
    reason: "TOO_MANY_REDIRECTS",
    transaction: Object.assign({}, tx, { blockTag, enableCcipRead: true })
  });
  const transaction = copyRequest(tx);
  try {
    return hexlify(await this._perform({ method: "call", transaction, blockTag }));
  } catch (error) {
    if (!this.disableCcipRead && isCallException(error) && error.data && attempt >= 0 && blockTag === "latest" && transaction.to != null && dataSlice(error.data, 0, 4) === "0x556f1830") {
      const data = error.data;
      const txSender = await resolveAddress(transaction.to, this);
      let ccipArgs;
      try {
        ccipArgs = parseOffchainLookup(dataSlice(error.data, 4));
      } catch (error2) {
        assert(false, error2.message, "OFFCHAIN_FAULT", {
          reason: "BAD_DATA",
          transaction,
          info: { data }
        });
      }
      assert(ccipArgs.sender.toLowerCase() === txSender.toLowerCase(), "CCIP Read sender mismatch", "CALL_EXCEPTION", {
        action: "call",
        data,
        reason: "OffchainLookup",
        transaction,
        invocation: null,
        revert: {
          signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
          name: "OffchainLookup",
          args: ccipArgs.errorArgs
        }
      });
      const ccipResult = await this.ccipReadFetch(transaction, ccipArgs.calldata, ccipArgs.urls);
      assert(ccipResult != null, "CCIP Read failed to fetch data", "OFFCHAIN_FAULT", {
        reason: "FETCH_FAILED",
        transaction,
        info: { data: error.data, errorArgs: ccipArgs.errorArgs }
      });
      const tx2 = {
        to: txSender,
        data: concat([ccipArgs.selector, encodeBytes([ccipResult, ccipArgs.extraData])])
      };
      this.emit("debug", { action: "sendCcipReadCall", transaction: tx2 });
      try {
        const result = await __privateMethod(this, _AbstractProvider_instances, call_fn).call(this, tx2, blockTag, attempt + 1);
        this.emit("debug", { action: "receiveCcipReadCallResult", transaction: Object.assign({}, tx2), result });
        return result;
      } catch (error2) {
        this.emit("debug", { action: "receiveCcipReadCallError", transaction: Object.assign({}, tx2), error: error2 });
        throw error2;
      }
    }
    throw error;
  }
};
checkNetwork_fn = async function(promise) {
  const { value } = await resolveProperties({
    network: this.getNetwork(),
    value: promise
  });
  return value;
};
getAccountValue_fn = async function(request2, _address, _blockTag) {
  let address = this._getAddress(_address);
  let blockTag = this._getBlockTag(_blockTag);
  if (typeof address !== "string" || typeof blockTag !== "string") {
    [address, blockTag] = await Promise.all([address, blockTag]);
  }
  return await __privateMethod(this, _AbstractProvider_instances, checkNetwork_fn).call(this, __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, Object.assign(request2, { address, blockTag })));
};
getBlock_fn = async function(block, includeTransactions) {
  if (isHexString(block, 32)) {
    return await __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, {
      method: "getBlock",
      blockHash: block,
      includeTransactions
    });
  }
  let blockTag = this._getBlockTag(block);
  if (typeof blockTag !== "string") {
    blockTag = await blockTag;
  }
  return await __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, {
    method: "getBlock",
    blockTag,
    includeTransactions
  });
};
hasSub_fn = async function(event, emitArgs) {
  let sub = await getSubscription(event, this);
  if (sub.type === "event" && emitArgs && emitArgs.length > 0 && emitArgs[0].removed === true) {
    sub = await getSubscription({ orphan: "drop-log", log: emitArgs[0] }, this);
  }
  return __privateGet(this, _subs).get(sub.tag) || null;
};
getSub_fn = async function(event) {
  const subscription = await getSubscription(event, this);
  const tag = subscription.tag;
  let sub = __privateGet(this, _subs).get(tag);
  if (!sub) {
    const subscriber = this._getSubscriber(subscription);
    const addressableMap = /* @__PURE__ */ new WeakMap();
    const nameMap = /* @__PURE__ */ new Map();
    sub = { subscriber, tag, addressableMap, nameMap, started: false, listeners: [] };
    __privateGet(this, _subs).set(tag, sub);
  }
  return sub;
};
function _parseString(result, start) {
  try {
    const bytes = _parseBytes(result, start);
    if (bytes) {
      return toUtf8String(bytes);
    }
  } catch (error) {
  }
  return null;
}
function _parseBytes(result, start) {
  if (result === "0x") {
    return null;
  }
  try {
    const offset = getNumber(dataSlice(result, start, start + 32));
    const length = getNumber(dataSlice(result, offset, offset + 32));
    return dataSlice(result, offset + 32, offset + 32 + length);
  } catch (error) {
  }
  return null;
}
function numPad(value) {
  const result = toBeArray(value);
  if (result.length > 32) {
    throw new Error("internal; should not happen");
  }
  const padded = new Uint8Array(32);
  padded.set(result, 32 - result.length);
  return padded;
}
function bytesPad(value) {
  if (value.length % 32 === 0) {
    return value;
  }
  const result = new Uint8Array(Math.ceil(value.length / 32) * 32);
  result.set(value);
  return result;
}
const empty = new Uint8Array([]);
function encodeBytes(datas) {
  const result = [];
  let byteCount = 0;
  for (let i = 0; i < datas.length; i++) {
    result.push(empty);
    byteCount += 32;
  }
  for (let i = 0; i < datas.length; i++) {
    const data = getBytes(datas[i]);
    result[i] = numPad(byteCount);
    result.push(numPad(data.length));
    result.push(bytesPad(data));
    byteCount += 32 + Math.ceil(data.length / 32) * 32;
  }
  return concat(result);
}
const zeros = "0x0000000000000000000000000000000000000000000000000000000000000000";
function parseOffchainLookup(data) {
  const result = {
    sender: "",
    urls: [],
    calldata: "",
    selector: "",
    extraData: "",
    errorArgs: []
  };
  assert(dataLength(data) >= 5 * 32, "insufficient OffchainLookup data", "OFFCHAIN_FAULT", {
    reason: "insufficient OffchainLookup data"
  });
  const sender = dataSlice(data, 0, 32);
  assert(dataSlice(sender, 0, 12) === dataSlice(zeros, 0, 12), "corrupt OffchainLookup sender", "OFFCHAIN_FAULT", {
    reason: "corrupt OffchainLookup sender"
  });
  result.sender = dataSlice(sender, 12);
  try {
    const urls = [];
    const urlsOffset = getNumber(dataSlice(data, 32, 64));
    const urlsLength = getNumber(dataSlice(data, urlsOffset, urlsOffset + 32));
    const urlsData = dataSlice(data, urlsOffset + 32);
    for (let u2 = 0; u2 < urlsLength; u2++) {
      const url = _parseString(urlsData, u2 * 32);
      if (url == null) {
        throw new Error("abort");
      }
      urls.push(url);
    }
    result.urls = urls;
  } catch (error) {
    assert(false, "corrupt OffchainLookup urls", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup urls"
    });
  }
  try {
    const calldata = _parseBytes(data, 64);
    if (calldata == null) {
      throw new Error("abort");
    }
    result.calldata = calldata;
  } catch (error) {
    assert(false, "corrupt OffchainLookup calldata", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup calldata"
    });
  }
  assert(dataSlice(data, 100, 128) === dataSlice(zeros, 0, 28), "corrupt OffchainLookup callbaackSelector", "OFFCHAIN_FAULT", {
    reason: "corrupt OffchainLookup callbaackSelector"
  });
  result.selector = dataSlice(data, 96, 100);
  try {
    const extraData = _parseBytes(data, 128);
    if (extraData == null) {
      throw new Error("abort");
    }
    result.extraData = extraData;
  } catch (error) {
    assert(false, "corrupt OffchainLookup extraData", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup extraData"
    });
  }
  result.errorArgs = "sender,urls,calldata,selector,extraData".split(/,/).map((k2) => result[k2]);
  return result;
}
function checkProvider(signer, operation) {
  if (signer.provider) {
    return signer.provider;
  }
  assert(false, "missing provider", "UNSUPPORTED_OPERATION", { operation });
}
async function populate(signer, tx) {
  let pop = copyRequest(tx);
  if (pop.to != null) {
    pop.to = resolveAddress(pop.to, signer);
  }
  if (pop.from != null) {
    const from = pop.from;
    pop.from = Promise.all([
      signer.getAddress(),
      resolveAddress(from, signer)
    ]).then(([address, from2]) => {
      assertArgument(address.toLowerCase() === from2.toLowerCase(), "transaction from mismatch", "tx.from", from2);
      return address;
    });
  } else {
    pop.from = signer.getAddress();
  }
  return await resolveProperties(pop);
}
class AbstractSigner {
  /**
   *  Creates a new Signer connected to %%provider%%.
   */
  constructor(provider) {
    /**
     *  The provider this signer is connected to.
     */
    __publicField(this, "provider");
    defineProperties(this, { provider: provider || null });
  }
  async getNonce(blockTag) {
    return checkProvider(this, "getTransactionCount").getTransactionCount(await this.getAddress(), blockTag);
  }
  async populateCall(tx) {
    const pop = await populate(this, tx);
    return pop;
  }
  async populateTransaction(tx) {
    const provider = checkProvider(this, "populateTransaction");
    const pop = await populate(this, tx);
    if (pop.nonce == null) {
      pop.nonce = await this.getNonce("pending");
    }
    if (pop.gasLimit == null) {
      pop.gasLimit = await this.estimateGas(pop);
    }
    const network = await this.provider.getNetwork();
    if (pop.chainId != null) {
      const chainId = getBigInt(pop.chainId);
      assertArgument(chainId === network.chainId, "transaction chainId mismatch", "tx.chainId", tx.chainId);
    } else {
      pop.chainId = network.chainId;
    }
    const hasEip1559 = pop.maxFeePerGas != null || pop.maxPriorityFeePerGas != null;
    if (pop.gasPrice != null && (pop.type === 2 || hasEip1559)) {
      assertArgument(false, "eip-1559 transaction do not support gasPrice", "tx", tx);
    } else if ((pop.type === 0 || pop.type === 1) && hasEip1559) {
      assertArgument(false, "pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "tx", tx);
    }
    if ((pop.type === 2 || pop.type == null) && (pop.maxFeePerGas != null && pop.maxPriorityFeePerGas != null)) {
      pop.type = 2;
    } else if (pop.type === 0 || pop.type === 1) {
      const feeData = await provider.getFeeData();
      assert(feeData.gasPrice != null, "network does not support gasPrice", "UNSUPPORTED_OPERATION", {
        operation: "getGasPrice"
      });
      if (pop.gasPrice == null) {
        pop.gasPrice = feeData.gasPrice;
      }
    } else {
      const feeData = await provider.getFeeData();
      if (pop.type == null) {
        if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {
          pop.type = 2;
          if (pop.gasPrice != null) {
            const gasPrice = pop.gasPrice;
            delete pop.gasPrice;
            pop.maxFeePerGas = gasPrice;
            pop.maxPriorityFeePerGas = gasPrice;
          } else {
            if (pop.maxFeePerGas == null) {
              pop.maxFeePerGas = feeData.maxFeePerGas;
            }
            if (pop.maxPriorityFeePerGas == null) {
              pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
            }
          }
        } else if (feeData.gasPrice != null) {
          assert(!hasEip1559, "network does not support EIP-1559", "UNSUPPORTED_OPERATION", {
            operation: "populateTransaction"
          });
          if (pop.gasPrice == null) {
            pop.gasPrice = feeData.gasPrice;
          }
          pop.type = 0;
        } else {
          assert(false, "failed to get consistent fee data", "UNSUPPORTED_OPERATION", {
            operation: "signer.getFeeData"
          });
        }
      } else if (pop.type === 2 || pop.type === 3) {
        if (pop.maxFeePerGas == null) {
          pop.maxFeePerGas = feeData.maxFeePerGas;
        }
        if (pop.maxPriorityFeePerGas == null) {
          pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
        }
      }
    }
    return await resolveProperties(pop);
  }
  async estimateGas(tx) {
    return checkProvider(this, "estimateGas").estimateGas(await this.populateCall(tx));
  }
  async call(tx) {
    return checkProvider(this, "call").call(await this.populateCall(tx));
  }
  async resolveName(name) {
    const provider = checkProvider(this, "resolveName");
    return await provider.resolveName(name);
  }
  async sendTransaction(tx) {
    const provider = checkProvider(this, "sendTransaction");
    const pop = await this.populateTransaction(tx);
    delete pop.from;
    const txObj = Transaction.from(pop);
    return await provider.broadcastTransaction(await this.signTransaction(txObj));
  }
}
function copy(obj) {
  return JSON.parse(JSON.stringify(obj));
}
class FilterIdSubscriber {
  /**
   *  Creates a new **FilterIdSubscriber** which will used [[_subscribe]]
   *  and [[_emitResults]] to setup the subscription and provide the event
   *  to the %%provider%%.
   */
  constructor(provider) {
    __privateAdd(this, _FilterIdSubscriber_instances);
    __privateAdd(this, _provider4);
    __privateAdd(this, _filterIdPromise);
    __privateAdd(this, _poller3);
    __privateAdd(this, _running3);
    __privateAdd(this, _network);
    __privateAdd(this, _hault);
    __privateSet(this, _provider4, provider);
    __privateSet(this, _filterIdPromise, null);
    __privateSet(this, _poller3, __privateMethod(this, _FilterIdSubscriber_instances, poll_fn3).bind(this));
    __privateSet(this, _running3, false);
    __privateSet(this, _network, null);
    __privateSet(this, _hault, false);
  }
  /**
   *  Sub-classes **must** override this to begin the subscription.
   */
  _subscribe(provider) {
    throw new Error("subclasses must override this");
  }
  /**
   *  Sub-classes **must** override this handle the events.
   */
  _emitResults(provider, result) {
    throw new Error("subclasses must override this");
  }
  /**
   *  Sub-classes **must** override this handle recovery on errors.
   */
  _recover(provider) {
    throw new Error("subclasses must override this");
  }
  start() {
    if (__privateGet(this, _running3)) {
      return;
    }
    __privateSet(this, _running3, true);
    __privateMethod(this, _FilterIdSubscriber_instances, poll_fn3).call(this, -2);
  }
  stop() {
    if (!__privateGet(this, _running3)) {
      return;
    }
    __privateSet(this, _running3, false);
    __privateSet(this, _hault, true);
    __privateMethod(this, _FilterIdSubscriber_instances, teardown_fn).call(this);
    __privateGet(this, _provider4).off("block", __privateGet(this, _poller3));
  }
  pause(dropWhilePaused) {
    if (dropWhilePaused) {
      __privateMethod(this, _FilterIdSubscriber_instances, teardown_fn).call(this);
    }
    __privateGet(this, _provider4).off("block", __privateGet(this, _poller3));
  }
  resume() {
    this.start();
  }
}
_provider4 = new WeakMap();
_filterIdPromise = new WeakMap();
_poller3 = new WeakMap();
_running3 = new WeakMap();
_network = new WeakMap();
_hault = new WeakMap();
_FilterIdSubscriber_instances = new WeakSet();
poll_fn3 = async function(blockNumber) {
  try {
    if (__privateGet(this, _filterIdPromise) == null) {
      __privateSet(this, _filterIdPromise, this._subscribe(__privateGet(this, _provider4)));
    }
    let filterId = null;
    try {
      filterId = await __privateGet(this, _filterIdPromise);
    } catch (error) {
      if (!isError(error, "UNSUPPORTED_OPERATION") || error.operation !== "eth_newFilter") {
        throw error;
      }
    }
    if (filterId == null) {
      __privateSet(this, _filterIdPromise, null);
      __privateGet(this, _provider4)._recoverSubscriber(this, this._recover(__privateGet(this, _provider4)));
      return;
    }
    const network = await __privateGet(this, _provider4).getNetwork();
    if (!__privateGet(this, _network)) {
      __privateSet(this, _network, network);
    }
    if (__privateGet(this, _network).chainId !== network.chainId) {
      throw new Error("chaid changed");
    }
    if (__privateGet(this, _hault)) {
      return;
    }
    const result = await __privateGet(this, _provider4).send("eth_getFilterChanges", [filterId]);
    await this._emitResults(__privateGet(this, _provider4), result);
  } catch (error) {
    console.log("@TODO", error);
  }
  __privateGet(this, _provider4).once("block", __privateGet(this, _poller3));
};
teardown_fn = function() {
  const filterIdPromise = __privateGet(this, _filterIdPromise);
  if (filterIdPromise) {
    __privateSet(this, _filterIdPromise, null);
    filterIdPromise.then((filterId) => {
      if (__privateGet(this, _provider4).destroyed) {
        return;
      }
      __privateGet(this, _provider4).send("eth_uninstallFilter", [filterId]);
    });
  }
};
class FilterIdEventSubscriber extends FilterIdSubscriber {
  /**
   *  Creates a new **FilterIdEventSubscriber** attached to %%provider%%
   *  listening for %%filter%%.
   */
  constructor(provider, filter) {
    super(provider);
    __privateAdd(this, _event);
    __privateSet(this, _event, copy(filter));
  }
  _recover(provider) {
    return new PollingEventSubscriber(provider, __privateGet(this, _event));
  }
  async _subscribe(provider) {
    const filterId = await provider.send("eth_newFilter", [__privateGet(this, _event)]);
    return filterId;
  }
  async _emitResults(provider, results) {
    for (const result of results) {
      provider.emit(__privateGet(this, _event), provider._wrapLog(result, provider._network));
    }
  }
}
_event = new WeakMap();
class FilterIdPendingSubscriber extends FilterIdSubscriber {
  async _subscribe(provider) {
    return await provider.send("eth_newPendingTransactionFilter", []);
  }
  async _emitResults(provider, results) {
    for (const result of results) {
      provider.emit("pending", result);
    }
  }
}
const Primitive = "bigint,boolean,function,number,string,symbol".split(/,/g);
function deepCopy(value) {
  if (value == null || Primitive.indexOf(typeof value) >= 0) {
    return value;
  }
  if (typeof value.getAddress === "function") {
    return value;
  }
  if (Array.isArray(value)) {
    return value.map(deepCopy);
  }
  if (typeof value === "object") {
    return Object.keys(value).reduce((accum, key) => {
      accum[key] = value[key];
      return accum;
    }, {});
  }
  throw new Error(`should not happen: ${value} (${typeof value})`);
}
function stall(duration) {
  return new Promise((resolve) => {
    setTimeout(resolve, duration);
  });
}
function getLowerCase(value) {
  if (value) {
    return value.toLowerCase();
  }
  return value;
}
function isPollable(value) {
  return value && typeof value.pollingInterval === "number";
}
const defaultOptions = {
  polling: false,
  staticNetwork: null,
  batchStallTime: 10,
  batchMaxSize: 1 << 20,
  batchMaxCount: 100,
  cacheTimeout: 250,
  pollingInterval: 4e3
};
class JsonRpcSigner extends AbstractSigner {
  constructor(provider, address) {
    super(provider);
    __publicField(this, "address");
    address = getAddress(address);
    defineProperties(this, { address });
  }
  connect(provider) {
    assert(false, "cannot reconnect JsonRpcSigner", "UNSUPPORTED_OPERATION", {
      operation: "signer.connect"
    });
  }
  async getAddress() {
    return this.address;
  }
  // JSON-RPC will automatially fill in nonce, etc. so we just check from
  async populateTransaction(tx) {
    return await this.populateCall(tx);
  }
  // Returns just the hash of the transaction after sent, which is what
  // the bare JSON-RPC API does;
  async sendUncheckedTransaction(_tx) {
    const tx = deepCopy(_tx);
    const promises = [];
    if (tx.from) {
      const _from = tx.from;
      promises.push((async () => {
        const from = await resolveAddress(_from, this.provider);
        assertArgument(from != null && from.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", _tx);
        tx.from = from;
      })());
    } else {
      tx.from = this.address;
    }
    if (tx.gasLimit == null) {
      promises.push((async () => {
        tx.gasLimit = await this.provider.estimateGas({ ...tx, from: this.address });
      })());
    }
    if (tx.to != null) {
      const _to2 = tx.to;
      promises.push((async () => {
        tx.to = await resolveAddress(_to2, this.provider);
      })());
    }
    if (promises.length) {
      await Promise.all(promises);
    }
    const hexTx = this.provider.getRpcTransaction(tx);
    return this.provider.send("eth_sendTransaction", [hexTx]);
  }
  async sendTransaction(tx) {
    const blockNumber = await this.provider.getBlockNumber();
    const hash = await this.sendUncheckedTransaction(tx);
    return await new Promise((resolve, reject) => {
      const timeouts = [1e3, 100];
      let invalids = 0;
      const checkTx = async () => {
        try {
          const tx2 = await this.provider.getTransaction(hash);
          if (tx2 != null) {
            resolve(tx2.replaceableTransaction(blockNumber));
            return;
          }
        } catch (error) {
          if (isError(error, "CANCELLED") || isError(error, "BAD_DATA") || isError(error, "NETWORK_ERROR") || isError(error, "UNSUPPORTED_OPERATION")) {
            if (error.info == null) {
              error.info = {};
            }
            error.info.sendTransactionHash = hash;
            reject(error);
            return;
          }
          if (isError(error, "INVALID_ARGUMENT")) {
            invalids++;
            if (error.info == null) {
              error.info = {};
            }
            error.info.sendTransactionHash = hash;
            if (invalids > 10) {
              reject(error);
              return;
            }
          }
          this.provider.emit("error", makeError("failed to fetch transation after sending (will try again)", "UNKNOWN_ERROR", { error }));
        }
        this.provider._setTimeout(() => {
          checkTx();
        }, timeouts.pop() || 4e3);
      };
      checkTx();
    });
  }
  async signTransaction(_tx) {
    const tx = deepCopy(_tx);
    if (tx.from) {
      const from = await resolveAddress(tx.from, this.provider);
      assertArgument(from != null && from.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", _tx);
      tx.from = from;
    } else {
      tx.from = this.address;
    }
    const hexTx = this.provider.getRpcTransaction(tx);
    return await this.provider.send("eth_signTransaction", [hexTx]);
  }
  async signMessage(_message) {
    const message = typeof _message === "string" ? toUtf8Bytes(_message) : _message;
    return await this.provider.send("personal_sign", [
      hexlify(message),
      this.address.toLowerCase()
    ]);
  }
  async signTypedData(domain, types, _value2) {
    const value = deepCopy(_value2);
    const populated = await TypedDataEncoder.resolveNames(domain, types, value, async (value2) => {
      const address = await resolveAddress(value2);
      assertArgument(address != null, "TypedData does not support null address", "value", value2);
      return address;
    });
    return await this.provider.send("eth_signTypedData_v4", [
      this.address.toLowerCase(),
      JSON.stringify(TypedDataEncoder.getPayload(populated.domain, types, populated.value))
    ]);
  }
  async unlock(password) {
    return this.provider.send("personal_unlockAccount", [
      this.address.toLowerCase(),
      password,
      null
    ]);
  }
  // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign
  async _legacySignMessage(_message) {
    const message = typeof _message === "string" ? toUtf8Bytes(_message) : _message;
    return await this.provider.send("eth_sign", [
      this.address.toLowerCase(),
      hexlify(message)
    ]);
  }
}
class JsonRpcApiProvider extends AbstractProvider {
  constructor(network, options) {
    super(network, options);
    __privateAdd(this, _JsonRpcApiProvider_instances);
    __privateAdd(this, _options3);
    // The next ID to use for the JSON-RPC ID field
    __privateAdd(this, _nextId);
    // Payloads are queued and triggered in batches using the drainTimer
    __privateAdd(this, _payloads);
    __privateAdd(this, _drainTimer);
    __privateAdd(this, _notReady);
    __privateAdd(this, _network2);
    __privateAdd(this, _pendingDetectNetwork);
    __privateSet(this, _nextId, 1);
    __privateSet(this, _options3, Object.assign({}, defaultOptions, options || {}));
    __privateSet(this, _payloads, []);
    __privateSet(this, _drainTimer, null);
    __privateSet(this, _network2, null);
    __privateSet(this, _pendingDetectNetwork, null);
    {
      let resolve = null;
      const promise = new Promise((_resolve) => {
        resolve = _resolve;
      });
      __privateSet(this, _notReady, { promise, resolve });
    }
    const staticNetwork = this._getOption("staticNetwork");
    if (typeof staticNetwork === "boolean") {
      assertArgument(!staticNetwork || network !== "any", "staticNetwork cannot be used on special network 'any'", "options", options);
      if (staticNetwork && network != null) {
        __privateSet(this, _network2, Network.from(network));
      }
    } else if (staticNetwork) {
      assertArgument(network == null || staticNetwork.matches(network), "staticNetwork MUST match network object", "options", options);
      __privateSet(this, _network2, staticNetwork);
    }
  }
  /**
   *  Returns the value associated with the option %%key%%.
   *
   *  Sub-classes can use this to inquire about configuration options.
   */
  _getOption(key) {
    return __privateGet(this, _options3)[key];
  }
  /**
   *  Gets the [[Network]] this provider has committed to. On each call, the network
   *  is detected, and if it has changed, the call will reject.
   */
  get _network() {
    assert(__privateGet(this, _network2), "network is not available yet", "NETWORK_ERROR");
    return __privateGet(this, _network2);
  }
  /**
   *  Resolves to the non-normalized value by performing %%req%%.
   *
   *  Sub-classes may override this to modify behavior of actions,
   *  and should generally call ``super._perform`` as a fallback.
   */
  async _perform(req) {
    if (req.method === "call" || req.method === "estimateGas") {
      let tx = req.transaction;
      if (tx && tx.type != null && getBigInt(tx.type)) {
        if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {
          const feeData = await this.getFeeData();
          if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {
            req = Object.assign({}, req, {
              transaction: Object.assign({}, tx, { type: void 0 })
            });
          }
        }
      }
    }
    const request2 = this.getRpcRequest(req);
    if (request2 != null) {
      return await this.send(request2.method, request2.args);
    }
    return super._perform(req);
  }
  /**
   *  Sub-classes may override this; it detects the *actual* network that
   *  we are **currently** connected to.
   *
   *  Keep in mind that [[send]] may only be used once [[ready]], otherwise the
   *  _send primitive must be used instead.
   */
  async _detectNetwork() {
    const network = this._getOption("staticNetwork");
    if (network) {
      if (network === true) {
        if (__privateGet(this, _network2)) {
          return __privateGet(this, _network2);
        }
      } else {
        return network;
      }
    }
    if (__privateGet(this, _pendingDetectNetwork)) {
      return await __privateGet(this, _pendingDetectNetwork);
    }
    if (this.ready) {
      __privateSet(this, _pendingDetectNetwork, (async () => {
        try {
          const result = Network.from(getBigInt(await this.send("eth_chainId", [])));
          __privateSet(this, _pendingDetectNetwork, null);
          return result;
        } catch (error) {
          __privateSet(this, _pendingDetectNetwork, null);
          throw error;
        }
      })());
      return await __privateGet(this, _pendingDetectNetwork);
    }
    __privateSet(this, _pendingDetectNetwork, (async () => {
      const payload = {
        id: __privateWrapper(this, _nextId)._++,
        method: "eth_chainId",
        params: [],
        jsonrpc: "2.0"
      };
      this.emit("debug", { action: "sendRpcPayload", payload });
      let result;
      try {
        result = (await this._send(payload))[0];
        __privateSet(this, _pendingDetectNetwork, null);
      } catch (error) {
        __privateSet(this, _pendingDetectNetwork, null);
        this.emit("debug", { action: "receiveRpcError", error });
        throw error;
      }
      this.emit("debug", { action: "receiveRpcResult", result });
      if ("result" in result) {
        return Network.from(getBigInt(result.result));
      }
      throw this.getRpcError(payload, result);
    })());
    return await __privateGet(this, _pendingDetectNetwork);
  }
  /**
   *  Sub-classes **MUST** call this. Until [[_start]] has been called, no calls
   *  will be passed to [[_send]] from [[send]]. If it is overridden, then
   *  ``super._start()`` **MUST** be called.
   *
   *  Calling it multiple times is safe and has no effect.
   */
  _start() {
    if (__privateGet(this, _notReady) == null || __privateGet(this, _notReady).resolve == null) {
      return;
    }
    __privateGet(this, _notReady).resolve();
    __privateSet(this, _notReady, null);
    (async () => {
      while (__privateGet(this, _network2) == null && !this.destroyed) {
        try {
          __privateSet(this, _network2, await this._detectNetwork());
        } catch (error) {
          if (this.destroyed) {
            break;
          }
          console.log("JsonRpcProvider failed to detect network and cannot start up; retry in 1s (perhaps the URL is wrong or the node is not started)");
          this.emit("error", makeError("failed to bootstrap network detection", "NETWORK_ERROR", { event: "initial-network-discovery", info: { error } }));
          await stall(1e3);
        }
      }
      __privateMethod(this, _JsonRpcApiProvider_instances, scheduleDrain_fn).call(this);
    })();
  }
  /**
   *  Resolves once the [[_start]] has been called. This can be used in
   *  sub-classes to defer sending data until the connection has been
   *  established.
   */
  async _waitUntilReady() {
    if (__privateGet(this, _notReady) == null) {
      return;
    }
    return await __privateGet(this, _notReady).promise;
  }
  /**
   *  Return a Subscriber that will manage the %%sub%%.
   *
   *  Sub-classes may override this to modify the behavior of
   *  subscription management.
   */
  _getSubscriber(sub) {
    if (sub.type === "pending") {
      return new FilterIdPendingSubscriber(this);
    }
    if (sub.type === "event") {
      if (this._getOption("polling")) {
        return new PollingEventSubscriber(this, sub.filter);
      }
      return new FilterIdEventSubscriber(this, sub.filter);
    }
    if (sub.type === "orphan" && sub.filter.orphan === "drop-log") {
      return new UnmanagedSubscriber("orphan");
    }
    return super._getSubscriber(sub);
  }
  /**
   *  Returns true only if the [[_start]] has been called.
   */
  get ready() {
    return __privateGet(this, _notReady) == null;
  }
  /**
   *  Returns %%tx%% as a normalized JSON-RPC transaction request,
   *  which has all values hexlified and any numeric values converted
   *  to Quantity values.
   */
  getRpcTransaction(tx) {
    const result = {};
    ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach((key) => {
      if (tx[key] == null) {
        return;
      }
      let dstKey = key;
      if (key === "gasLimit") {
        dstKey = "gas";
      }
      result[dstKey] = toQuantity(getBigInt(tx[key], `tx.${key}`));
    });
    ["from", "to", "data"].forEach((key) => {
      if (tx[key] == null) {
        return;
      }
      result[key] = hexlify(tx[key]);
    });
    if (tx.accessList) {
      result["accessList"] = accessListify(tx.accessList);
    }
    if (tx.blobVersionedHashes) {
      result["blobVersionedHashes"] = tx.blobVersionedHashes.map((h2) => h2.toLowerCase());
    }
    return result;
  }
  /**
   *  Returns the request method and arguments required to perform
   *  %%req%%.
   */
  getRpcRequest(req) {
    switch (req.method) {
      case "chainId":
        return { method: "eth_chainId", args: [] };
      case "getBlockNumber":
        return { method: "eth_blockNumber", args: [] };
      case "getGasPrice":
        return { method: "eth_gasPrice", args: [] };
      case "getPriorityFee":
        return { method: "eth_maxPriorityFeePerGas", args: [] };
      case "getBalance":
        return {
          method: "eth_getBalance",
          args: [getLowerCase(req.address), req.blockTag]
        };
      case "getTransactionCount":
        return {
          method: "eth_getTransactionCount",
          args: [getLowerCase(req.address), req.blockTag]
        };
      case "getCode":
        return {
          method: "eth_getCode",
          args: [getLowerCase(req.address), req.blockTag]
        };
      case "getStorage":
        return {
          method: "eth_getStorageAt",
          args: [
            getLowerCase(req.address),
            "0x" + req.position.toString(16),
            req.blockTag
          ]
        };
      case "broadcastTransaction":
        return {
          method: "eth_sendRawTransaction",
          args: [req.signedTransaction]
        };
      case "getBlock":
        if ("blockTag" in req) {
          return {
            method: "eth_getBlockByNumber",
            args: [req.blockTag, !!req.includeTransactions]
          };
        } else if ("blockHash" in req) {
          return {
            method: "eth_getBlockByHash",
            args: [req.blockHash, !!req.includeTransactions]
          };
        }
        break;
      case "getTransaction":
        return {
          method: "eth_getTransactionByHash",
          args: [req.hash]
        };
      case "getTransactionReceipt":
        return {
          method: "eth_getTransactionReceipt",
          args: [req.hash]
        };
      case "call":
        return {
          method: "eth_call",
          args: [this.getRpcTransaction(req.transaction), req.blockTag]
        };
      case "estimateGas": {
        return {
          method: "eth_estimateGas",
          args: [this.getRpcTransaction(req.transaction)]
        };
      }
      case "getLogs":
        if (req.filter && req.filter.address != null) {
          if (Array.isArray(req.filter.address)) {
            req.filter.address = req.filter.address.map(getLowerCase);
          } else {
            req.filter.address = getLowerCase(req.filter.address);
          }
        }
        return { method: "eth_getLogs", args: [req.filter] };
    }
    return null;
  }
  /**
   *  Returns an ethers-style Error for the given JSON-RPC error
   *  %%payload%%, coalescing the various strings and error shapes
   *  that different nodes return, coercing them into a machine-readable
   *  standardized error.
   */
  getRpcError(payload, _error2) {
    const { method } = payload;
    const { error } = _error2;
    if (method === "eth_estimateGas" && error.message) {
      const msg = error.message;
      if (!msg.match(/revert/i) && msg.match(/insufficient funds/i)) {
        return makeError("insufficient funds", "INSUFFICIENT_FUNDS", {
          transaction: payload.params[0],
          info: { payload, error }
        });
      }
    }
    if (method === "eth_call" || method === "eth_estimateGas") {
      const result = spelunkData(error);
      const e2 = AbiCoder.getBuiltinCallException(method === "eth_call" ? "call" : "estimateGas", payload.params[0], result ? result.data : null);
      e2.info = { error, payload };
      return e2;
    }
    const message = JSON.stringify(spelunkMessage(error));
    if (typeof error.message === "string" && error.message.match(/user denied|ethers-user-denied/i)) {
      const actionMap = {
        eth_sign: "signMessage",
        personal_sign: "signMessage",
        eth_signTypedData_v4: "signTypedData",
        eth_signTransaction: "signTransaction",
        eth_sendTransaction: "sendTransaction",
        eth_requestAccounts: "requestAccess",
        wallet_requestAccounts: "requestAccess"
      };
      return makeError(`user rejected action`, "ACTION_REJECTED", {
        action: actionMap[method] || "unknown",
        reason: "rejected",
        info: { payload, error }
      });
    }
    if (method === "eth_sendRawTransaction" || method === "eth_sendTransaction") {
      const transaction = payload.params[0];
      if (message.match(/insufficient funds|base fee exceeds gas limit/i)) {
        return makeError("insufficient funds for intrinsic transaction cost", "INSUFFICIENT_FUNDS", {
          transaction,
          info: { error }
        });
      }
      if (message.match(/nonce/i) && message.match(/too low/i)) {
        return makeError("nonce has already been used", "NONCE_EXPIRED", { transaction, info: { error } });
      }
      if (message.match(/replacement transaction/i) && message.match(/underpriced/i)) {
        return makeError("replacement fee too low", "REPLACEMENT_UNDERPRICED", { transaction, info: { error } });
      }
      if (message.match(/only replay-protected/i)) {
        return makeError("legacy pre-eip-155 transactions not supported", "UNSUPPORTED_OPERATION", {
          operation: method,
          info: { transaction, info: { error } }
        });
      }
    }
    let unsupported = !!message.match(/the method .* does not exist/i);
    if (!unsupported) {
      if (error && error.details && error.details.startsWith("Unauthorized method:")) {
        unsupported = true;
      }
    }
    if (unsupported) {
      return makeError("unsupported operation", "UNSUPPORTED_OPERATION", {
        operation: payload.method,
        info: { error, payload }
      });
    }
    return makeError("could not coalesce error", "UNKNOWN_ERROR", { error, payload });
  }
  /**
   *  Requests the %%method%% with %%params%% via the JSON-RPC protocol
   *  over the underlying channel. This can be used to call methods
   *  on the backend that do not have a high-level API within the Provider
   *  API.
   *
   *  This method queues requests according to the batch constraints
   *  in the options, assigns the request a unique ID.
   *
   *  **Do NOT override** this method in sub-classes; instead
   *  override [[_send]] or force the options values in the
   *  call to the constructor to modify this method's behavior.
   */
  send(method, params) {
    if (this.destroyed) {
      return Promise.reject(makeError("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: method }));
    }
    const id2 = __privateWrapper(this, _nextId)._++;
    const promise = new Promise((resolve, reject) => {
      __privateGet(this, _payloads).push({
        resolve,
        reject,
        payload: { method, params, id: id2, jsonrpc: "2.0" }
      });
    });
    __privateMethod(this, _JsonRpcApiProvider_instances, scheduleDrain_fn).call(this);
    return promise;
  }
  /**
   *  Resolves to the [[Signer]] account for  %%address%% managed by
   *  the client.
   *
   *  If the %%address%% is a number, it is used as an index in the
   *  the accounts from [[listAccounts]].
   *
   *  This can only be used on clients which manage accounts (such as
   *  Geth with imported account or MetaMask).
   *
   *  Throws if the account doesn't exist.
   */
  async getSigner(address) {
    if (address == null) {
      address = 0;
    }
    const accountsPromise = this.send("eth_accounts", []);
    if (typeof address === "number") {
      const accounts2 = await accountsPromise;
      if (address >= accounts2.length) {
        throw new Error("no such account");
      }
      return new JsonRpcSigner(this, accounts2[address]);
    }
    const { accounts } = await resolveProperties({
      network: this.getNetwork(),
      accounts: accountsPromise
    });
    address = getAddress(address);
    for (const account of accounts) {
      if (getAddress(account) === address) {
        return new JsonRpcSigner(this, address);
      }
    }
    throw new Error("invalid account");
  }
  async listAccounts() {
    const accounts = await this.send("eth_accounts", []);
    return accounts.map((a2) => new JsonRpcSigner(this, a2));
  }
  destroy() {
    if (__privateGet(this, _drainTimer)) {
      clearTimeout(__privateGet(this, _drainTimer));
      __privateSet(this, _drainTimer, null);
    }
    for (const { payload, reject } of __privateGet(this, _payloads)) {
      reject(makeError("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: payload.method }));
    }
    __privateSet(this, _payloads, []);
    super.destroy();
  }
}
_options3 = new WeakMap();
_nextId = new WeakMap();
_payloads = new WeakMap();
_drainTimer = new WeakMap();
_notReady = new WeakMap();
_network2 = new WeakMap();
_pendingDetectNetwork = new WeakMap();
_JsonRpcApiProvider_instances = new WeakSet();
scheduleDrain_fn = function() {
  if (__privateGet(this, _drainTimer)) {
    return;
  }
  const stallTime = this._getOption("batchMaxCount") === 1 ? 0 : this._getOption("batchStallTime");
  __privateSet(this, _drainTimer, setTimeout(() => {
    __privateSet(this, _drainTimer, null);
    const payloads = __privateGet(this, _payloads);
    __privateSet(this, _payloads, []);
    while (payloads.length) {
      const batch = [payloads.shift()];
      while (payloads.length) {
        if (batch.length === __privateGet(this, _options3).batchMaxCount) {
          break;
        }
        batch.push(payloads.shift());
        const bytes = JSON.stringify(batch.map((p2) => p2.payload));
        if (bytes.length > __privateGet(this, _options3).batchMaxSize) {
          payloads.unshift(batch.pop());
          break;
        }
      }
      (async () => {
        const payload = batch.length === 1 ? batch[0].payload : batch.map((p2) => p2.payload);
        this.emit("debug", { action: "sendRpcPayload", payload });
        try {
          const result = await this._send(payload);
          this.emit("debug", { action: "receiveRpcResult", result });
          for (const { resolve, reject, payload: payload2 } of batch) {
            if (this.destroyed) {
              reject(makeError("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: payload2.method }));
              continue;
            }
            const resp = result.filter((r3) => r3.id === payload2.id)[0];
            if (resp == null) {
              const error = makeError("missing response for request", "BAD_DATA", {
                value: result,
                info: { payload: payload2 }
              });
              this.emit("error", error);
              reject(error);
              continue;
            }
            if ("error" in resp) {
              reject(this.getRpcError(payload2, resp));
              continue;
            }
            resolve(resp.result);
          }
        } catch (error) {
          this.emit("debug", { action: "receiveRpcError", error });
          for (const { reject } of batch) {
            reject(error);
          }
        }
      })();
    }
  }, stallTime));
};
class JsonRpcApiPollingProvider extends JsonRpcApiProvider {
  constructor(network, options) {
    super(network, options);
    __privateAdd(this, _pollingInterval);
    let pollingInterval = this._getOption("pollingInterval");
    if (pollingInterval == null) {
      pollingInterval = defaultOptions.pollingInterval;
    }
    __privateSet(this, _pollingInterval, pollingInterval);
  }
  _getSubscriber(sub) {
    const subscriber = super._getSubscriber(sub);
    if (isPollable(subscriber)) {
      subscriber.pollingInterval = __privateGet(this, _pollingInterval);
    }
    return subscriber;
  }
  /**
   *  The polling interval (default: 4000 ms)
   */
  get pollingInterval() {
    return __privateGet(this, _pollingInterval);
  }
  set pollingInterval(value) {
    if (!Number.isInteger(value) || value < 0) {
      throw new Error("invalid interval");
    }
    __privateSet(this, _pollingInterval, value);
    this._forEachSubscriber((sub) => {
      if (isPollable(sub)) {
        sub.pollingInterval = __privateGet(this, _pollingInterval);
      }
    });
  }
}
_pollingInterval = new WeakMap();
class JsonRpcProvider extends JsonRpcApiPollingProvider {
  constructor(url, network, options) {
    if (url == null) {
      url = "http://localhost:8545";
    }
    super(network, options);
    __privateAdd(this, _connect);
    if (typeof url === "string") {
      __privateSet(this, _connect, new FetchRequest(url));
    } else {
      __privateSet(this, _connect, url.clone());
    }
  }
  _getConnection() {
    return __privateGet(this, _connect).clone();
  }
  async send(method, params) {
    await this._start();
    return await super.send(method, params);
  }
  async _send(payload) {
    const request2 = this._getConnection();
    request2.body = JSON.stringify(payload);
    request2.setHeader("content-type", "application/json");
    const response = await request2.send();
    response.assertOk();
    let resp = response.bodyJson;
    if (!Array.isArray(resp)) {
      resp = [resp];
    }
    return resp;
  }
}
_connect = new WeakMap();
function spelunkData(value) {
  if (value == null) {
    return null;
  }
  if (typeof value.message === "string" && value.message.match(/revert/i) && isHexString(value.data)) {
    return { message: value.message, data: value.data };
  }
  if (typeof value === "object") {
    for (const key in value) {
      const result = spelunkData(value[key]);
      if (result) {
        return result;
      }
    }
    return null;
  }
  if (typeof value === "string") {
    try {
      return spelunkData(JSON.parse(value));
    } catch (error) {
    }
  }
  return null;
}
function _spelunkMessage(value, result) {
  if (value == null) {
    return;
  }
  if (typeof value.message === "string") {
    result.push(value.message);
  }
  if (typeof value === "object") {
    for (const key in value) {
      _spelunkMessage(value[key], result);
    }
  }
  if (typeof value === "string") {
    try {
      return _spelunkMessage(JSON.parse(value), result);
    } catch (error) {
    }
  }
}
function spelunkMessage(value) {
  const result = [];
  _spelunkMessage(value, result);
  return result;
}
class BrowserProvider extends JsonRpcApiPollingProvider {
  /**
   *  Connect to the %%ethereum%% provider, optionally forcing the
   *  %%network%%.
   */
  constructor(ethereum, network, _options4) {
    const options = Object.assign({}, _options4 != null ? _options4 : {}, { batchMaxCount: 1 });
    assertArgument(ethereum && ethereum.request, "invalid EIP-1193 provider", "ethereum", ethereum);
    super(network, options);
    __privateAdd(this, _request2);
    __privateSet(this, _request2, async (method, params) => {
      const payload = { method, params };
      this.emit("debug", { action: "sendEip1193Request", payload });
      try {
        const result = await ethereum.request(payload);
        this.emit("debug", { action: "receiveEip1193Result", result });
        return result;
      } catch (e2) {
        const error = new Error(e2.message);
        error.code = e2.code;
        error.data = e2.data;
        error.payload = payload;
        this.emit("debug", { action: "receiveEip1193Error", error });
        throw error;
      }
    });
  }
  async send(method, params) {
    await this._start();
    return await super.send(method, params);
  }
  async _send(payload) {
    assertArgument(!Array.isArray(payload), "EIP-1193 does not support batch request", "payload", payload);
    try {
      const result = await __privateGet(this, _request2).call(this, payload.method, payload.params || []);
      return [{ id: payload.id, result }];
    } catch (e2) {
      return [{
        id: payload.id,
        error: { code: e2.code, data: e2.data, message: e2.message }
      }];
    }
  }
  getRpcError(payload, error) {
    error = JSON.parse(JSON.stringify(error));
    switch (error.error.code || -1) {
      case 4001:
        error.error.message = `ethers-user-denied: ${error.error.message}`;
        break;
      case 4200:
        error.error.message = `ethers-unsupported: ${error.error.message}`;
        break;
    }
    return super.getRpcError(payload, error);
  }
  /**
   *  Resolves to ``true`` if the provider manages the %%address%%.
   */
  async hasSigner(address) {
    if (address == null) {
      address = 0;
    }
    const accounts = await this.send("eth_accounts", []);
    if (typeof address === "number") {
      return accounts.length > address;
    }
    address = address.toLowerCase();
    return accounts.filter((a2) => a2.toLowerCase() === address).length !== 0;
  }
  async getSigner(address) {
    if (address == null) {
      address = 0;
    }
    if (!await this.hasSigner(address)) {
      try {
        await __privateGet(this, _request2).call(this, "eth_requestAccounts", []);
      } catch (error) {
        const payload = error.payload;
        throw this.getRpcError(payload, { id: payload.id, error });
      }
    }
    return await super.getSigner(address);
  }
}
_request2 = new WeakMap();
var lr$3 = Object.create;
var $e$8 = Object.defineProperty;
var cr$4 = Object.getOwnPropertyDescriptor;
var yr$3 = Object.getOwnPropertyNames;
var mr$2 = Object.getPrototypeOf, fr$4 = Object.prototype.hasOwnProperty;
var hr$2 = (n4, e2) => () => (n4 && (e2 = n4(n4 = 0)), e2);
var de$7 = (n4, e2) => () => (e2 || n4((e2 = { exports: {} }).exports, e2), e2.exports), gr$3 = (n4, e2) => {
  for (var t in e2) $e$8(n4, t, { get: e2[t], enumerable: true });
}, br$6 = (n4, e2, t, r3) => {
  if (e2 && typeof e2 == "object" || typeof e2 == "function") for (let a2 of yr$3(e2)) !fr$4.call(n4, a2) && a2 !== t && $e$8(n4, a2, { get: () => e2[a2], enumerable: !(r3 = cr$4(e2, a2)) || r3.enumerable });
  return n4;
};
var Te$6 = (n4, e2, t) => (t = n4 != null ? lr$3(mr$2(n4)) : {}, br$6(!n4 || !n4.__esModule ? $e$8(t, "default", { value: n4, enumerable: true }) : t, n4));
var Ut$3 = de$7((Re2) => {
  y$3();
  Re2.byteLength = wr2;
  Re2.toByteArray = vr2;
  Re2.fromByteArray = Cr2;
  var W2 = [], K2 = [], Ar2 = typeof Uint8Array < "u" ? Uint8Array : Array, Qe2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (re2 = 0, Nt2 = Qe2.length; re2 < Nt2; ++re2) W2[re2] = Qe2[re2], K2[Qe2.charCodeAt(re2)] = re2;
  var re2, Nt2;
  K2[45] = 62;
  K2[95] = 63;
  function Rt2(n4) {
    var e2 = n4.length;
    if (e2 % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
    var t = n4.indexOf("=");
    t === -1 && (t = e2);
    var r3 = t === e2 ? 0 : 4 - t % 4;
    return [t, r3];
  }
  function wr2(n4) {
    var e2 = Rt2(n4), t = e2[0], r3 = e2[1];
    return (t + r3) * 3 / 4 - r3;
  }
  function Tr2(n4, e2, t) {
    return (e2 + t) * 3 / 4 - t;
  }
  function vr2(n4) {
    var e2, t = Rt2(n4), r3 = t[0], a2 = t[1], s2 = new Ar2(Tr2(n4, r3, a2)), i = 0, o2 = a2 > 0 ? r3 - 4 : r3, u2;
    for (u2 = 0; u2 < o2; u2 += 4) e2 = K2[n4.charCodeAt(u2)] << 18 | K2[n4.charCodeAt(u2 + 1)] << 12 | K2[n4.charCodeAt(u2 + 2)] << 6 | K2[n4.charCodeAt(u2 + 3)], s2[i++] = e2 >> 16 & 255, s2[i++] = e2 >> 8 & 255, s2[i++] = e2 & 255;
    return a2 === 2 && (e2 = K2[n4.charCodeAt(u2)] << 2 | K2[n4.charCodeAt(u2 + 1)] >> 4, s2[i++] = e2 & 255), a2 === 1 && (e2 = K2[n4.charCodeAt(u2)] << 10 | K2[n4.charCodeAt(u2 + 1)] << 4 | K2[n4.charCodeAt(u2 + 2)] >> 2, s2[i++] = e2 >> 8 & 255, s2[i++] = e2 & 255), s2;
  }
  function xr2(n4) {
    return W2[n4 >> 18 & 63] + W2[n4 >> 12 & 63] + W2[n4 >> 6 & 63] + W2[n4 & 63];
  }
  function Er2(n4, e2, t) {
    for (var r3, a2 = [], s2 = e2; s2 < t; s2 += 3) r3 = (n4[s2] << 16 & 16711680) + (n4[s2 + 1] << 8 & 65280) + (n4[s2 + 2] & 255), a2.push(xr2(r3));
    return a2.join("");
  }
  function Cr2(n4) {
    for (var e2, t = n4.length, r3 = t % 3, a2 = [], s2 = 16383, i = 0, o2 = t - r3; i < o2; i += s2) a2.push(Er2(n4, i, i + s2 > o2 ? o2 : i + s2));
    return r3 === 1 ? (e2 = n4[t - 1], a2.push(W2[e2 >> 2] + W2[e2 << 4 & 63] + "==")) : r3 === 2 && (e2 = (n4[t - 2] << 8) + n4[t - 1], a2.push(W2[e2 >> 10] + W2[e2 >> 4 & 63] + W2[e2 << 2 & 63] + "=")), a2.join("");
  }
});
var Bt$5 = de$7((et2) => {
  y$3();
  et2.read = function(n4, e2, t, r3, a2) {
    var s2, i, o2 = a2 * 8 - r3 - 1, u2 = (1 << o2) - 1, l2 = u2 >> 1, c = -7, d2 = t ? a2 - 1 : 0, b2 = t ? -1 : 1, f2 = n4[e2 + d2];
    for (d2 += b2, s2 = f2 & (1 << -c) - 1, f2 >>= -c, c += o2; c > 0; s2 = s2 * 256 + n4[e2 + d2], d2 += b2, c -= 8) ;
    for (i = s2 & (1 << -c) - 1, s2 >>= -c, c += r3; c > 0; i = i * 256 + n4[e2 + d2], d2 += b2, c -= 8) ;
    if (s2 === 0) s2 = 1 - l2;
    else {
      if (s2 === u2) return i ? NaN : (f2 ? -1 : 1) * (1 / 0);
      i = i + Math.pow(2, r3), s2 = s2 - l2;
    }
    return (f2 ? -1 : 1) * i * Math.pow(2, s2 - r3);
  };
  et2.write = function(n4, e2, t, r3, a2, s2) {
    var i, o2, u2, l2 = s2 * 8 - a2 - 1, c = (1 << l2) - 1, d2 = c >> 1, b2 = a2 === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f2 = r3 ? 0 : s2 - 1, A2 = r3 ? 1 : -1, S2 = e2 < 0 || e2 === 0 && 1 / e2 < 0 ? 1 : 0;
    for (e2 = Math.abs(e2), isNaN(e2) || e2 === 1 / 0 ? (o2 = isNaN(e2) ? 1 : 0, i = c) : (i = Math.floor(Math.log(e2) / Math.LN2), e2 * (u2 = Math.pow(2, -i)) < 1 && (i--, u2 *= 2), i + d2 >= 1 ? e2 += b2 / u2 : e2 += b2 * Math.pow(2, 1 - d2), e2 * u2 >= 2 && (i++, u2 /= 2), i + d2 >= c ? (o2 = 0, i = c) : i + d2 >= 1 ? (o2 = (e2 * u2 - 1) * Math.pow(2, a2), i = i + d2) : (o2 = e2 * Math.pow(2, d2 - 1) * Math.pow(2, a2), i = 0)); a2 >= 8; n4[t + f2] = o2 & 255, f2 += A2, o2 /= 256, a2 -= 8) ;
    for (i = i << a2 | o2, l2 += a2; l2 > 0; n4[t + f2] = i & 255, f2 += A2, i /= 256, l2 -= 8) ;
    n4[t + f2 - A2] |= S2 * 128;
  };
});
var ut$3 = de$7((ce2) => {
  y$3();
  var tt2 = Ut$3(), le2 = Bt$5(), Ft2 = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  ce2.Buffer = p2;
  ce2.SlowBuffer = Nr;
  ce2.INSPECT_MAX_BYTES = 50;
  var Ue2 = 2147483647;
  ce2.kMaxLength = Ue2;
  p2.TYPED_ARRAY_SUPPORT = Ir2();
  !p2.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
  function Ir2() {
    try {
      var n4 = new Uint8Array(1), e2 = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(e2, Uint8Array.prototype), Object.setPrototypeOf(n4, e2), n4.foo() === 42;
    } catch {
      return false;
    }
  }
  Object.defineProperty(p2.prototype, "parent", { enumerable: true, get: function() {
    if (p2.isBuffer(this)) return this.buffer;
  } });
  Object.defineProperty(p2.prototype, "offset", { enumerable: true, get: function() {
    if (p2.isBuffer(this)) return this.byteOffset;
  } });
  function J2(n4) {
    if (n4 > Ue2) throw new RangeError('The value "' + n4 + '" is invalid for option "size"');
    var e2 = new Uint8Array(n4);
    return Object.setPrototypeOf(e2, p2.prototype), e2;
  }
  function p2(n4, e2, t) {
    if (typeof n4 == "number") {
      if (typeof e2 == "string") throw new TypeError('The "string" argument must be of type string. Received type number');
      return st2(n4);
    }
    return Pt2(n4, e2, t);
  }
  p2.poolSize = 8192;
  function Pt2(n4, e2, t) {
    if (typeof n4 == "string") return Sr2(n4, e2);
    if (ArrayBuffer.isView(n4)) return Mr2(n4);
    if (n4 == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof n4);
    if (G2(n4, ArrayBuffer) || n4 && G2(n4.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (G2(n4, SharedArrayBuffer) || n4 && G2(n4.buffer, SharedArrayBuffer))) return rt2(n4, e2, t);
    if (typeof n4 == "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
    var r3 = n4.valueOf && n4.valueOf();
    if (r3 != null && r3 !== n4) return p2.from(r3, e2, t);
    var a2 = kr2(n4);
    if (a2) return a2;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof n4[Symbol.toPrimitive] == "function") return p2.from(n4[Symbol.toPrimitive]("string"), e2, t);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof n4);
  }
  p2.from = function(n4, e2, t) {
    return Pt2(n4, e2, t);
  };
  Object.setPrototypeOf(p2.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(p2, Uint8Array);
  function Kt2(n4) {
    if (typeof n4 != "number") throw new TypeError('"size" argument must be of type number');
    if (n4 < 0) throw new RangeError('The value "' + n4 + '" is invalid for option "size"');
  }
  function _r3(n4, e2, t) {
    return Kt2(n4), n4 <= 0 ? J2(n4) : e2 !== void 0 ? typeof t == "string" ? J2(n4).fill(e2, t) : J2(n4).fill(e2) : J2(n4);
  }
  p2.alloc = function(n4, e2, t) {
    return _r3(n4, e2, t);
  };
  function st2(n4) {
    return Kt2(n4), J2(n4 < 0 ? 0 : it2(n4) | 0);
  }
  p2.allocUnsafe = function(n4) {
    return st2(n4);
  };
  p2.allocUnsafeSlow = function(n4) {
    return st2(n4);
  };
  function Sr2(n4, e2) {
    if ((typeof e2 != "string" || e2 === "") && (e2 = "utf8"), !p2.isEncoding(e2)) throw new TypeError("Unknown encoding: " + e2);
    var t = Vt2(n4, e2) | 0, r3 = J2(t), a2 = r3.write(n4, e2);
    return a2 !== t && (r3 = r3.slice(0, a2)), r3;
  }
  function nt2(n4) {
    for (var e2 = n4.length < 0 ? 0 : it2(n4.length) | 0, t = J2(e2), r3 = 0; r3 < e2; r3 += 1) t[r3] = n4[r3] & 255;
    return t;
  }
  function Mr2(n4) {
    if (G2(n4, Uint8Array)) {
      var e2 = new Uint8Array(n4);
      return rt2(e2.buffer, e2.byteOffset, e2.byteLength);
    }
    return nt2(n4);
  }
  function rt2(n4, e2, t) {
    if (e2 < 0 || n4.byteLength < e2) throw new RangeError('"offset" is outside of buffer bounds');
    if (n4.byteLength < e2 + (t || 0)) throw new RangeError('"length" is outside of buffer bounds');
    var r3;
    return e2 === void 0 && t === void 0 ? r3 = new Uint8Array(n4) : t === void 0 ? r3 = new Uint8Array(n4, e2) : r3 = new Uint8Array(n4, e2, t), Object.setPrototypeOf(r3, p2.prototype), r3;
  }
  function kr2(n4) {
    if (p2.isBuffer(n4)) {
      var e2 = it2(n4.length) | 0, t = J2(e2);
      return t.length === 0 || n4.copy(t, 0, 0, e2), t;
    }
    if (n4.length !== void 0) return typeof n4.length != "number" || ot2(n4.length) ? J2(0) : nt2(n4);
    if (n4.type === "Buffer" && Array.isArray(n4.data)) return nt2(n4.data);
  }
  function it2(n4) {
    if (n4 >= Ue2) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + Ue2.toString(16) + " bytes");
    return n4 | 0;
  }
  function Nr(n4) {
    return +n4 != n4 && (n4 = 0), p2.alloc(+n4);
  }
  p2.isBuffer = function(e2) {
    return e2 != null && e2._isBuffer === true && e2 !== p2.prototype;
  };
  p2.compare = function(e2, t) {
    if (G2(e2, Uint8Array) && (e2 = p2.from(e2, e2.offset, e2.byteLength)), G2(t, Uint8Array) && (t = p2.from(t, t.offset, t.byteLength)), !p2.isBuffer(e2) || !p2.isBuffer(t)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (e2 === t) return 0;
    for (var r3 = e2.length, a2 = t.length, s2 = 0, i = Math.min(r3, a2); s2 < i; ++s2) if (e2[s2] !== t[s2]) {
      r3 = e2[s2], a2 = t[s2];
      break;
    }
    return r3 < a2 ? -1 : a2 < r3 ? 1 : 0;
  };
  p2.isEncoding = function(e2) {
    switch (String(e2).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  p2.concat = function(e2, t) {
    if (!Array.isArray(e2)) throw new TypeError('"list" argument must be an Array of Buffers');
    if (e2.length === 0) return p2.alloc(0);
    var r3;
    if (t === void 0) for (t = 0, r3 = 0; r3 < e2.length; ++r3) t += e2[r3].length;
    var a2 = p2.allocUnsafe(t), s2 = 0;
    for (r3 = 0; r3 < e2.length; ++r3) {
      var i = e2[r3];
      if (G2(i, Uint8Array)) s2 + i.length > a2.length ? p2.from(i).copy(a2, s2) : Uint8Array.prototype.set.call(a2, i, s2);
      else if (p2.isBuffer(i)) i.copy(a2, s2);
      else throw new TypeError('"list" argument must be an Array of Buffers');
      s2 += i.length;
    }
    return a2;
  };
  function Vt2(n4, e2) {
    if (p2.isBuffer(n4)) return n4.length;
    if (ArrayBuffer.isView(n4) || G2(n4, ArrayBuffer)) return n4.byteLength;
    if (typeof n4 != "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof n4);
    var t = n4.length, r3 = arguments.length > 2 && arguments[2] === true;
    if (!r3 && t === 0) return 0;
    for (var a2 = false; ; ) switch (e2) {
      case "ascii":
      case "latin1":
      case "binary":
        return t;
      case "utf8":
      case "utf-8":
        return at2(n4).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return t * 2;
      case "hex":
        return t >>> 1;
      case "base64":
        return Xt2(n4).length;
      default:
        if (a2) return r3 ? -1 : at2(n4).length;
        e2 = ("" + e2).toLowerCase(), a2 = true;
    }
  }
  p2.byteLength = Vt2;
  function Rr2(n4, e2, t) {
    var r3 = false;
    if ((e2 === void 0 || e2 < 0) && (e2 = 0), e2 > this.length || ((t === void 0 || t > this.length) && (t = this.length), t <= 0) || (t >>>= 0, e2 >>>= 0, t <= e2)) return "";
    for (n4 || (n4 = "utf8"); ; ) switch (n4) {
      case "hex":
        return Lr2(this, e2, t);
      case "utf8":
      case "utf-8":
        return Lt2(this, e2, t);
      case "ascii":
        return Vr2(this, e2, t);
      case "latin1":
      case "binary":
        return Hr2(this, e2, t);
      case "base64":
        return Pr2(this, e2, t);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return Wr2(this, e2, t);
      default:
        if (r3) throw new TypeError("Unknown encoding: " + n4);
        n4 = (n4 + "").toLowerCase(), r3 = true;
    }
  }
  p2.prototype._isBuffer = true;
  function ae2(n4, e2, t) {
    var r3 = n4[e2];
    n4[e2] = n4[t], n4[t] = r3;
  }
  p2.prototype.swap16 = function() {
    var e2 = this.length;
    if (e2 % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (var t = 0; t < e2; t += 2) ae2(this, t, t + 1);
    return this;
  };
  p2.prototype.swap32 = function() {
    var e2 = this.length;
    if (e2 % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (var t = 0; t < e2; t += 4) ae2(this, t, t + 3), ae2(this, t + 1, t + 2);
    return this;
  };
  p2.prototype.swap64 = function() {
    var e2 = this.length;
    if (e2 % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (var t = 0; t < e2; t += 8) ae2(this, t, t + 7), ae2(this, t + 1, t + 6), ae2(this, t + 2, t + 5), ae2(this, t + 3, t + 4);
    return this;
  };
  p2.prototype.toString = function() {
    var e2 = this.length;
    return e2 === 0 ? "" : arguments.length === 0 ? Lt2(this, 0, e2) : Rr2.apply(this, arguments);
  };
  p2.prototype.toLocaleString = p2.prototype.toString;
  p2.prototype.equals = function(e2) {
    if (!p2.isBuffer(e2)) throw new TypeError("Argument must be a Buffer");
    return this === e2 ? true : p2.compare(this, e2) === 0;
  };
  p2.prototype.inspect = function() {
    var e2 = "", t = ce2.INSPECT_MAX_BYTES;
    return e2 = this.toString("hex", 0, t).replace(/(.{2})/g, "$1 ").trim(), this.length > t && (e2 += " ... "), "<Buffer " + e2 + ">";
  };
  Ft2 && (p2.prototype[Ft2] = p2.prototype.inspect);
  p2.prototype.compare = function(e2, t, r3, a2, s2) {
    if (G2(e2, Uint8Array) && (e2 = p2.from(e2, e2.offset, e2.byteLength)), !p2.isBuffer(e2)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e2);
    if (t === void 0 && (t = 0), r3 === void 0 && (r3 = e2 ? e2.length : 0), a2 === void 0 && (a2 = 0), s2 === void 0 && (s2 = this.length), t < 0 || r3 > e2.length || a2 < 0 || s2 > this.length) throw new RangeError("out of range index");
    if (a2 >= s2 && t >= r3) return 0;
    if (a2 >= s2) return -1;
    if (t >= r3) return 1;
    if (t >>>= 0, r3 >>>= 0, a2 >>>= 0, s2 >>>= 0, this === e2) return 0;
    for (var i = s2 - a2, o2 = r3 - t, u2 = Math.min(i, o2), l2 = this.slice(a2, s2), c = e2.slice(t, r3), d2 = 0; d2 < u2; ++d2) if (l2[d2] !== c[d2]) {
      i = l2[d2], o2 = c[d2];
      break;
    }
    return i < o2 ? -1 : o2 < i ? 1 : 0;
  };
  function Ht2(n4, e2, t, r3, a2) {
    if (n4.length === 0) return -1;
    if (typeof t == "string" ? (r3 = t, t = 0) : t > 2147483647 ? t = 2147483647 : t < -2147483648 && (t = -2147483648), t = +t, ot2(t) && (t = a2 ? 0 : n4.length - 1), t < 0 && (t = n4.length + t), t >= n4.length) {
      if (a2) return -1;
      t = n4.length - 1;
    } else if (t < 0) if (a2) t = 0;
    else return -1;
    if (typeof e2 == "string" && (e2 = p2.from(e2, r3)), p2.isBuffer(e2)) return e2.length === 0 ? -1 : Ot2(n4, e2, t, r3, a2);
    if (typeof e2 == "number") return e2 = e2 & 255, typeof Uint8Array.prototype.indexOf == "function" ? a2 ? Uint8Array.prototype.indexOf.call(n4, e2, t) : Uint8Array.prototype.lastIndexOf.call(n4, e2, t) : Ot2(n4, [e2], t, r3, a2);
    throw new TypeError("val must be string, number or Buffer");
  }
  function Ot2(n4, e2, t, r3, a2) {
    var s2 = 1, i = n4.length, o2 = e2.length;
    if (r3 !== void 0 && (r3 = String(r3).toLowerCase(), r3 === "ucs2" || r3 === "ucs-2" || r3 === "utf16le" || r3 === "utf-16le")) {
      if (n4.length < 2 || e2.length < 2) return -1;
      s2 = 2, i /= 2, o2 /= 2, t /= 2;
    }
    function u2(f2, A2) {
      return s2 === 1 ? f2[A2] : f2.readUInt16BE(A2 * s2);
    }
    var l2;
    if (a2) {
      var c = -1;
      for (l2 = t; l2 < i; l2++) if (u2(n4, l2) === u2(e2, c === -1 ? 0 : l2 - c)) {
        if (c === -1 && (c = l2), l2 - c + 1 === o2) return c * s2;
      } else c !== -1 && (l2 -= l2 - c), c = -1;
    } else for (t + o2 > i && (t = i - o2), l2 = t; l2 >= 0; l2--) {
      for (var d2 = true, b2 = 0; b2 < o2; b2++) if (u2(n4, l2 + b2) !== u2(e2, b2)) {
        d2 = false;
        break;
      }
      if (d2) return l2;
    }
    return -1;
  }
  p2.prototype.includes = function(e2, t, r3) {
    return this.indexOf(e2, t, r3) !== -1;
  };
  p2.prototype.indexOf = function(e2, t, r3) {
    return Ht2(this, e2, t, r3, true);
  };
  p2.prototype.lastIndexOf = function(e2, t, r3) {
    return Ht2(this, e2, t, r3, false);
  };
  function Ur2(n4, e2, t, r3) {
    t = Number(t) || 0;
    var a2 = n4.length - t;
    r3 ? (r3 = Number(r3), r3 > a2 && (r3 = a2)) : r3 = a2;
    var s2 = e2.length;
    r3 > s2 / 2 && (r3 = s2 / 2);
    for (var i = 0; i < r3; ++i) {
      var o2 = parseInt(e2.substr(i * 2, 2), 16);
      if (ot2(o2)) return i;
      n4[t + i] = o2;
    }
    return i;
  }
  function Br2(n4, e2, t, r3) {
    return Be2(at2(e2, n4.length - t), n4, t, r3);
  }
  function Fr2(n4, e2, t, r3) {
    return Be2(Xr2(e2), n4, t, r3);
  }
  function Or2(n4, e2, t, r3) {
    return Be2(Xt2(e2), n4, t, r3);
  }
  function Dr2(n4, e2, t, r3) {
    return Be2(qr2(e2, n4.length - t), n4, t, r3);
  }
  p2.prototype.write = function(e2, t, r3, a2) {
    if (t === void 0) a2 = "utf8", r3 = this.length, t = 0;
    else if (r3 === void 0 && typeof t == "string") a2 = t, r3 = this.length, t = 0;
    else if (isFinite(t)) t = t >>> 0, isFinite(r3) ? (r3 = r3 >>> 0, a2 === void 0 && (a2 = "utf8")) : (a2 = r3, r3 = void 0);
    else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    var s2 = this.length - t;
    if ((r3 === void 0 || r3 > s2) && (r3 = s2), e2.length > 0 && (r3 < 0 || t < 0) || t > this.length) throw new RangeError("Attempt to write outside buffer bounds");
    a2 || (a2 = "utf8");
    for (var i = false; ; ) switch (a2) {
      case "hex":
        return Ur2(this, e2, t, r3);
      case "utf8":
      case "utf-8":
        return Br2(this, e2, t, r3);
      case "ascii":
      case "latin1":
      case "binary":
        return Fr2(this, e2, t, r3);
      case "base64":
        return Or2(this, e2, t, r3);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return Dr2(this, e2, t, r3);
      default:
        if (i) throw new TypeError("Unknown encoding: " + a2);
        a2 = ("" + a2).toLowerCase(), i = true;
    }
  };
  p2.prototype.toJSON = function() {
    return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
  };
  function Pr2(n4, e2, t) {
    return e2 === 0 && t === n4.length ? tt2.fromByteArray(n4) : tt2.fromByteArray(n4.slice(e2, t));
  }
  function Lt2(n4, e2, t) {
    t = Math.min(n4.length, t);
    for (var r3 = [], a2 = e2; a2 < t; ) {
      var s2 = n4[a2], i = null, o2 = s2 > 239 ? 4 : s2 > 223 ? 3 : s2 > 191 ? 2 : 1;
      if (a2 + o2 <= t) {
        var u2, l2, c, d2;
        switch (o2) {
          case 1:
            s2 < 128 && (i = s2);
            break;
          case 2:
            u2 = n4[a2 + 1], (u2 & 192) === 128 && (d2 = (s2 & 31) << 6 | u2 & 63, d2 > 127 && (i = d2));
            break;
          case 3:
            u2 = n4[a2 + 1], l2 = n4[a2 + 2], (u2 & 192) === 128 && (l2 & 192) === 128 && (d2 = (s2 & 15) << 12 | (u2 & 63) << 6 | l2 & 63, d2 > 2047 && (d2 < 55296 || d2 > 57343) && (i = d2));
            break;
          case 4:
            u2 = n4[a2 + 1], l2 = n4[a2 + 2], c = n4[a2 + 3], (u2 & 192) === 128 && (l2 & 192) === 128 && (c & 192) === 128 && (d2 = (s2 & 15) << 18 | (u2 & 63) << 12 | (l2 & 63) << 6 | c & 63, d2 > 65535 && d2 < 1114112 && (i = d2));
        }
      }
      i === null ? (i = 65533, o2 = 1) : i > 65535 && (i -= 65536, r3.push(i >>> 10 & 1023 | 55296), i = 56320 | i & 1023), r3.push(i), a2 += o2;
    }
    return Kr2(r3);
  }
  var Dt2 = 4096;
  function Kr2(n4) {
    var e2 = n4.length;
    if (e2 <= Dt2) return String.fromCharCode.apply(String, n4);
    for (var t = "", r3 = 0; r3 < e2; ) t += String.fromCharCode.apply(String, n4.slice(r3, r3 += Dt2));
    return t;
  }
  function Vr2(n4, e2, t) {
    var r3 = "";
    t = Math.min(n4.length, t);
    for (var a2 = e2; a2 < t; ++a2) r3 += String.fromCharCode(n4[a2] & 127);
    return r3;
  }
  function Hr2(n4, e2, t) {
    var r3 = "";
    t = Math.min(n4.length, t);
    for (var a2 = e2; a2 < t; ++a2) r3 += String.fromCharCode(n4[a2]);
    return r3;
  }
  function Lr2(n4, e2, t) {
    var r3 = n4.length;
    (!e2 || e2 < 0) && (e2 = 0), (!t || t < 0 || t > r3) && (t = r3);
    for (var a2 = "", s2 = e2; s2 < t; ++s2) a2 += jr2[n4[s2]];
    return a2;
  }
  function Wr2(n4, e2, t) {
    for (var r3 = n4.slice(e2, t), a2 = "", s2 = 0; s2 < r3.length - 1; s2 += 2) a2 += String.fromCharCode(r3[s2] + r3[s2 + 1] * 256);
    return a2;
  }
  p2.prototype.slice = function(e2, t) {
    var r3 = this.length;
    e2 = ~~e2, t = t === void 0 ? r3 : ~~t, e2 < 0 ? (e2 += r3, e2 < 0 && (e2 = 0)) : e2 > r3 && (e2 = r3), t < 0 ? (t += r3, t < 0 && (t = 0)) : t > r3 && (t = r3), t < e2 && (t = e2);
    var a2 = this.subarray(e2, t);
    return Object.setPrototypeOf(a2, p2.prototype), a2;
  };
  function M2(n4, e2, t) {
    if (n4 % 1 !== 0 || n4 < 0) throw new RangeError("offset is not uint");
    if (n4 + e2 > t) throw new RangeError("Trying to access beyond buffer length");
  }
  p2.prototype.readUintLE = p2.prototype.readUIntLE = function(e2, t, r3) {
    e2 = e2 >>> 0, t = t >>> 0, r3 || M2(e2, t, this.length);
    for (var a2 = this[e2], s2 = 1, i = 0; ++i < t && (s2 *= 256); ) a2 += this[e2 + i] * s2;
    return a2;
  };
  p2.prototype.readUintBE = p2.prototype.readUIntBE = function(e2, t, r3) {
    e2 = e2 >>> 0, t = t >>> 0, r3 || M2(e2, t, this.length);
    for (var a2 = this[e2 + --t], s2 = 1; t > 0 && (s2 *= 256); ) a2 += this[e2 + --t] * s2;
    return a2;
  };
  p2.prototype.readUint8 = p2.prototype.readUInt8 = function(e2, t) {
    return e2 = e2 >>> 0, t || M2(e2, 1, this.length), this[e2];
  };
  p2.prototype.readUint16LE = p2.prototype.readUInt16LE = function(e2, t) {
    return e2 = e2 >>> 0, t || M2(e2, 2, this.length), this[e2] | this[e2 + 1] << 8;
  };
  p2.prototype.readUint16BE = p2.prototype.readUInt16BE = function(e2, t) {
    return e2 = e2 >>> 0, t || M2(e2, 2, this.length), this[e2] << 8 | this[e2 + 1];
  };
  p2.prototype.readUint32LE = p2.prototype.readUInt32LE = function(e2, t) {
    return e2 = e2 >>> 0, t || M2(e2, 4, this.length), (this[e2] | this[e2 + 1] << 8 | this[e2 + 2] << 16) + this[e2 + 3] * 16777216;
  };
  p2.prototype.readUint32BE = p2.prototype.readUInt32BE = function(e2, t) {
    return e2 = e2 >>> 0, t || M2(e2, 4, this.length), this[e2] * 16777216 + (this[e2 + 1] << 16 | this[e2 + 2] << 8 | this[e2 + 3]);
  };
  p2.prototype.readIntLE = function(e2, t, r3) {
    e2 = e2 >>> 0, t = t >>> 0, r3 || M2(e2, t, this.length);
    for (var a2 = this[e2], s2 = 1, i = 0; ++i < t && (s2 *= 256); ) a2 += this[e2 + i] * s2;
    return s2 *= 128, a2 >= s2 && (a2 -= Math.pow(2, 8 * t)), a2;
  };
  p2.prototype.readIntBE = function(e2, t, r3) {
    e2 = e2 >>> 0, t = t >>> 0, r3 || M2(e2, t, this.length);
    for (var a2 = t, s2 = 1, i = this[e2 + --a2]; a2 > 0 && (s2 *= 256); ) i += this[e2 + --a2] * s2;
    return s2 *= 128, i >= s2 && (i -= Math.pow(2, 8 * t)), i;
  };
  p2.prototype.readInt8 = function(e2, t) {
    return e2 = e2 >>> 0, t || M2(e2, 1, this.length), this[e2] & 128 ? (255 - this[e2] + 1) * -1 : this[e2];
  };
  p2.prototype.readInt16LE = function(e2, t) {
    e2 = e2 >>> 0, t || M2(e2, 2, this.length);
    var r3 = this[e2] | this[e2 + 1] << 8;
    return r3 & 32768 ? r3 | 4294901760 : r3;
  };
  p2.prototype.readInt16BE = function(e2, t) {
    e2 = e2 >>> 0, t || M2(e2, 2, this.length);
    var r3 = this[e2 + 1] | this[e2] << 8;
    return r3 & 32768 ? r3 | 4294901760 : r3;
  };
  p2.prototype.readInt32LE = function(e2, t) {
    return e2 = e2 >>> 0, t || M2(e2, 4, this.length), this[e2] | this[e2 + 1] << 8 | this[e2 + 2] << 16 | this[e2 + 3] << 24;
  };
  p2.prototype.readInt32BE = function(e2, t) {
    return e2 = e2 >>> 0, t || M2(e2, 4, this.length), this[e2] << 24 | this[e2 + 1] << 16 | this[e2 + 2] << 8 | this[e2 + 3];
  };
  p2.prototype.readFloatLE = function(e2, t) {
    return e2 = e2 >>> 0, t || M2(e2, 4, this.length), le2.read(this, e2, true, 23, 4);
  };
  p2.prototype.readFloatBE = function(e2, t) {
    return e2 = e2 >>> 0, t || M2(e2, 4, this.length), le2.read(this, e2, false, 23, 4);
  };
  p2.prototype.readDoubleLE = function(e2, t) {
    return e2 = e2 >>> 0, t || M2(e2, 8, this.length), le2.read(this, e2, true, 52, 8);
  };
  p2.prototype.readDoubleBE = function(e2, t) {
    return e2 = e2 >>> 0, t || M2(e2, 8, this.length), le2.read(this, e2, false, 52, 8);
  };
  function O2(n4, e2, t, r3, a2, s2) {
    if (!p2.isBuffer(n4)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (e2 > a2 || e2 < s2) throw new RangeError('"value" argument is out of bounds');
    if (t + r3 > n4.length) throw new RangeError("Index out of range");
  }
  p2.prototype.writeUintLE = p2.prototype.writeUIntLE = function(e2, t, r3, a2) {
    if (e2 = +e2, t = t >>> 0, r3 = r3 >>> 0, !a2) {
      var s2 = Math.pow(2, 8 * r3) - 1;
      O2(this, e2, t, r3, s2, 0);
    }
    var i = 1, o2 = 0;
    for (this[t] = e2 & 255; ++o2 < r3 && (i *= 256); ) this[t + o2] = e2 / i & 255;
    return t + r3;
  };
  p2.prototype.writeUintBE = p2.prototype.writeUIntBE = function(e2, t, r3, a2) {
    if (e2 = +e2, t = t >>> 0, r3 = r3 >>> 0, !a2) {
      var s2 = Math.pow(2, 8 * r3) - 1;
      O2(this, e2, t, r3, s2, 0);
    }
    var i = r3 - 1, o2 = 1;
    for (this[t + i] = e2 & 255; --i >= 0 && (o2 *= 256); ) this[t + i] = e2 / o2 & 255;
    return t + r3;
  };
  p2.prototype.writeUint8 = p2.prototype.writeUInt8 = function(e2, t, r3) {
    return e2 = +e2, t = t >>> 0, r3 || O2(this, e2, t, 1, 255, 0), this[t] = e2 & 255, t + 1;
  };
  p2.prototype.writeUint16LE = p2.prototype.writeUInt16LE = function(e2, t, r3) {
    return e2 = +e2, t = t >>> 0, r3 || O2(this, e2, t, 2, 65535, 0), this[t] = e2 & 255, this[t + 1] = e2 >>> 8, t + 2;
  };
  p2.prototype.writeUint16BE = p2.prototype.writeUInt16BE = function(e2, t, r3) {
    return e2 = +e2, t = t >>> 0, r3 || O2(this, e2, t, 2, 65535, 0), this[t] = e2 >>> 8, this[t + 1] = e2 & 255, t + 2;
  };
  p2.prototype.writeUint32LE = p2.prototype.writeUInt32LE = function(e2, t, r3) {
    return e2 = +e2, t = t >>> 0, r3 || O2(this, e2, t, 4, 4294967295, 0), this[t + 3] = e2 >>> 24, this[t + 2] = e2 >>> 16, this[t + 1] = e2 >>> 8, this[t] = e2 & 255, t + 4;
  };
  p2.prototype.writeUint32BE = p2.prototype.writeUInt32BE = function(e2, t, r3) {
    return e2 = +e2, t = t >>> 0, r3 || O2(this, e2, t, 4, 4294967295, 0), this[t] = e2 >>> 24, this[t + 1] = e2 >>> 16, this[t + 2] = e2 >>> 8, this[t + 3] = e2 & 255, t + 4;
  };
  p2.prototype.writeIntLE = function(e2, t, r3, a2) {
    if (e2 = +e2, t = t >>> 0, !a2) {
      var s2 = Math.pow(2, 8 * r3 - 1);
      O2(this, e2, t, r3, s2 - 1, -s2);
    }
    var i = 0, o2 = 1, u2 = 0;
    for (this[t] = e2 & 255; ++i < r3 && (o2 *= 256); ) e2 < 0 && u2 === 0 && this[t + i - 1] !== 0 && (u2 = 1), this[t + i] = (e2 / o2 >> 0) - u2 & 255;
    return t + r3;
  };
  p2.prototype.writeIntBE = function(e2, t, r3, a2) {
    if (e2 = +e2, t = t >>> 0, !a2) {
      var s2 = Math.pow(2, 8 * r3 - 1);
      O2(this, e2, t, r3, s2 - 1, -s2);
    }
    var i = r3 - 1, o2 = 1, u2 = 0;
    for (this[t + i] = e2 & 255; --i >= 0 && (o2 *= 256); ) e2 < 0 && u2 === 0 && this[t + i + 1] !== 0 && (u2 = 1), this[t + i] = (e2 / o2 >> 0) - u2 & 255;
    return t + r3;
  };
  p2.prototype.writeInt8 = function(e2, t, r3) {
    return e2 = +e2, t = t >>> 0, r3 || O2(this, e2, t, 1, 127, -128), e2 < 0 && (e2 = 255 + e2 + 1), this[t] = e2 & 255, t + 1;
  };
  p2.prototype.writeInt16LE = function(e2, t, r3) {
    return e2 = +e2, t = t >>> 0, r3 || O2(this, e2, t, 2, 32767, -32768), this[t] = e2 & 255, this[t + 1] = e2 >>> 8, t + 2;
  };
  p2.prototype.writeInt16BE = function(e2, t, r3) {
    return e2 = +e2, t = t >>> 0, r3 || O2(this, e2, t, 2, 32767, -32768), this[t] = e2 >>> 8, this[t + 1] = e2 & 255, t + 2;
  };
  p2.prototype.writeInt32LE = function(e2, t, r3) {
    return e2 = +e2, t = t >>> 0, r3 || O2(this, e2, t, 4, 2147483647, -2147483648), this[t] = e2 & 255, this[t + 1] = e2 >>> 8, this[t + 2] = e2 >>> 16, this[t + 3] = e2 >>> 24, t + 4;
  };
  p2.prototype.writeInt32BE = function(e2, t, r3) {
    return e2 = +e2, t = t >>> 0, r3 || O2(this, e2, t, 4, 2147483647, -2147483648), e2 < 0 && (e2 = 4294967295 + e2 + 1), this[t] = e2 >>> 24, this[t + 1] = e2 >>> 16, this[t + 2] = e2 >>> 8, this[t + 3] = e2 & 255, t + 4;
  };
  function Wt2(n4, e2, t, r3, a2, s2) {
    if (t + r3 > n4.length) throw new RangeError("Index out of range");
    if (t < 0) throw new RangeError("Index out of range");
  }
  function Gt2(n4, e2, t, r3, a2) {
    return e2 = +e2, t = t >>> 0, a2 || Wt2(n4, e2, t, 4), le2.write(n4, e2, t, r3, 23, 4), t + 4;
  }
  p2.prototype.writeFloatLE = function(e2, t, r3) {
    return Gt2(this, e2, t, true, r3);
  };
  p2.prototype.writeFloatBE = function(e2, t, r3) {
    return Gt2(this, e2, t, false, r3);
  };
  function zt2(n4, e2, t, r3, a2) {
    return e2 = +e2, t = t >>> 0, a2 || Wt2(n4, e2, t, 8), le2.write(n4, e2, t, r3, 52, 8), t + 8;
  }
  p2.prototype.writeDoubleLE = function(e2, t, r3) {
    return zt2(this, e2, t, true, r3);
  };
  p2.prototype.writeDoubleBE = function(e2, t, r3) {
    return zt2(this, e2, t, false, r3);
  };
  p2.prototype.copy = function(e2, t, r3, a2) {
    if (!p2.isBuffer(e2)) throw new TypeError("argument should be a Buffer");
    if (r3 || (r3 = 0), !a2 && a2 !== 0 && (a2 = this.length), t >= e2.length && (t = e2.length), t || (t = 0), a2 > 0 && a2 < r3 && (a2 = r3), a2 === r3 || e2.length === 0 || this.length === 0) return 0;
    if (t < 0) throw new RangeError("targetStart out of bounds");
    if (r3 < 0 || r3 >= this.length) throw new RangeError("Index out of range");
    if (a2 < 0) throw new RangeError("sourceEnd out of bounds");
    a2 > this.length && (a2 = this.length), e2.length - t < a2 - r3 && (a2 = e2.length - t + r3);
    var s2 = a2 - r3;
    return this === e2 && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(t, r3, a2) : Uint8Array.prototype.set.call(e2, this.subarray(r3, a2), t), s2;
  };
  p2.prototype.fill = function(e2, t, r3, a2) {
    if (typeof e2 == "string") {
      if (typeof t == "string" ? (a2 = t, t = 0, r3 = this.length) : typeof r3 == "string" && (a2 = r3, r3 = this.length), a2 !== void 0 && typeof a2 != "string") throw new TypeError("encoding must be a string");
      if (typeof a2 == "string" && !p2.isEncoding(a2)) throw new TypeError("Unknown encoding: " + a2);
      if (e2.length === 1) {
        var s2 = e2.charCodeAt(0);
        (a2 === "utf8" && s2 < 128 || a2 === "latin1") && (e2 = s2);
      }
    } else typeof e2 == "number" ? e2 = e2 & 255 : typeof e2 == "boolean" && (e2 = Number(e2));
    if (t < 0 || this.length < t || this.length < r3) throw new RangeError("Out of range index");
    if (r3 <= t) return this;
    t = t >>> 0, r3 = r3 === void 0 ? this.length : r3 >>> 0, e2 || (e2 = 0);
    var i;
    if (typeof e2 == "number") for (i = t; i < r3; ++i) this[i] = e2;
    else {
      var o2 = p2.isBuffer(e2) ? e2 : p2.from(e2, a2), u2 = o2.length;
      if (u2 === 0) throw new TypeError('The value "' + e2 + '" is invalid for argument "value"');
      for (i = 0; i < r3 - t; ++i) this[i + t] = o2[i % u2];
    }
    return this;
  };
  var Gr2 = /[^+/0-9A-Za-z-_]/g;
  function zr2(n4) {
    if (n4 = n4.split("=")[0], n4 = n4.trim().replace(Gr2, ""), n4.length < 2) return "";
    for (; n4.length % 4 !== 0; ) n4 = n4 + "=";
    return n4;
  }
  function at2(n4, e2) {
    e2 = e2 || 1 / 0;
    for (var t, r3 = n4.length, a2 = null, s2 = [], i = 0; i < r3; ++i) {
      if (t = n4.charCodeAt(i), t > 55295 && t < 57344) {
        if (!a2) {
          if (t > 56319) {
            (e2 -= 3) > -1 && s2.push(239, 191, 189);
            continue;
          } else if (i + 1 === r3) {
            (e2 -= 3) > -1 && s2.push(239, 191, 189);
            continue;
          }
          a2 = t;
          continue;
        }
        if (t < 56320) {
          (e2 -= 3) > -1 && s2.push(239, 191, 189), a2 = t;
          continue;
        }
        t = (a2 - 55296 << 10 | t - 56320) + 65536;
      } else a2 && (e2 -= 3) > -1 && s2.push(239, 191, 189);
      if (a2 = null, t < 128) {
        if ((e2 -= 1) < 0) break;
        s2.push(t);
      } else if (t < 2048) {
        if ((e2 -= 2) < 0) break;
        s2.push(t >> 6 | 192, t & 63 | 128);
      } else if (t < 65536) {
        if ((e2 -= 3) < 0) break;
        s2.push(t >> 12 | 224, t >> 6 & 63 | 128, t & 63 | 128);
      } else if (t < 1114112) {
        if ((e2 -= 4) < 0) break;
        s2.push(t >> 18 | 240, t >> 12 & 63 | 128, t >> 6 & 63 | 128, t & 63 | 128);
      } else throw new Error("Invalid code point");
    }
    return s2;
  }
  function Xr2(n4) {
    for (var e2 = [], t = 0; t < n4.length; ++t) e2.push(n4.charCodeAt(t) & 255);
    return e2;
  }
  function qr2(n4, e2) {
    for (var t, r3, a2, s2 = [], i = 0; i < n4.length && !((e2 -= 2) < 0); ++i) t = n4.charCodeAt(i), r3 = t >> 8, a2 = t % 256, s2.push(a2), s2.push(r3);
    return s2;
  }
  function Xt2(n4) {
    return tt2.toByteArray(zr2(n4));
  }
  function Be2(n4, e2, t, r3) {
    for (var a2 = 0; a2 < r3 && !(a2 + t >= e2.length || a2 >= n4.length); ++a2) e2[a2 + t] = n4[a2];
    return a2;
  }
  function G2(n4, e2) {
    return n4 instanceof e2 || n4 != null && n4.constructor != null && n4.constructor.name != null && n4.constructor.name === e2.name;
  }
  function ot2(n4) {
    return n4 !== n4;
  }
  var jr2 = function() {
    for (var n4 = "0123456789abcdef", e2 = new Array(256), t = 0; t < 16; ++t) for (var r3 = t * 16, a2 = 0; a2 < 16; ++a2) e2[r3 + a2] = n4[t] + n4[a2];
    return e2;
  }();
});
var mn$1 = de$7((g2, yn2) => {
  y$3();
  Object.defineProperty(g2, "__esModule", { value: true });
  var h2 = { exports: {} }, x2 = h2.exports = {}, z2, X2;
  function pt2() {
    throw new Error("setTimeout has not been defined");
  }
  function dt2() {
    throw new Error("clearTimeout has not been defined");
  }
  (function() {
    try {
      typeof setTimeout == "function" ? z2 = setTimeout : z2 = pt2;
    } catch {
      z2 = pt2;
    }
    try {
      typeof clearTimeout == "function" ? X2 = clearTimeout : X2 = dt2;
    } catch {
      X2 = dt2;
    }
  })();
  function qt2(n4) {
    if (z2 === setTimeout) return setTimeout(n4, 0);
    if ((z2 === pt2 || !z2) && setTimeout) return z2 = setTimeout, setTimeout(n4, 0);
    try {
      return z2(n4, 0);
    } catch {
      try {
        return z2.call(null, n4, 0);
      } catch {
        return z2.call(this, n4, 0);
      }
    }
  }
  function Jr2(n4) {
    if (X2 === clearTimeout) return clearTimeout(n4);
    if ((X2 === dt2 || !X2) && clearTimeout) return X2 = clearTimeout, clearTimeout(n4);
    try {
      return X2(n4);
    } catch {
      try {
        return X2.call(null, n4);
      } catch {
        return X2.call(this, n4);
      }
    }
  }
  var Y2 = [], ye2 = false, se2, Fe2 = -1;
  function Yr2() {
    !ye2 || !se2 || (ye2 = false, se2.length ? Y2 = se2.concat(Y2) : Fe2 = -1, Y2.length && jt2());
  }
  function jt2() {
    if (!ye2) {
      var n4 = qt2(Yr2);
      ye2 = true;
      for (var e2 = Y2.length; e2; ) {
        for (se2 = Y2, Y2 = []; ++Fe2 < e2; ) se2 && se2[Fe2].run();
        Fe2 = -1, e2 = Y2.length;
      }
      se2 = null, ye2 = false, Jr2(n4);
    }
  }
  x2.nextTick = function(n4) {
    var e2 = new Array(arguments.length - 1);
    if (arguments.length > 1) for (var t = 1; t < arguments.length; t++) e2[t - 1] = arguments[t];
    Y2.push(new Jt2(n4, e2)), Y2.length === 1 && !ye2 && qt2(jt2);
  };
  function Jt2(n4, e2) {
    this.fun = n4, this.array = e2;
  }
  Jt2.prototype.run = function() {
    this.fun.apply(null, this.array);
  };
  x2.title = "browser";
  x2.browser = true;
  x2.env = {};
  x2.argv = [];
  x2.version = "";
  x2.versions = {};
  function Z2() {
  }
  x2.on = Z2;
  x2.addListener = Z2;
  x2.once = Z2;
  x2.off = Z2;
  x2.removeListener = Z2;
  x2.removeAllListeners = Z2;
  x2.emit = Z2;
  x2.prependListener = Z2;
  x2.prependOnceListener = Z2;
  x2.listeners = function(n4) {
    return [];
  };
  x2.binding = function(n4) {
    throw new Error("process.binding is not supported");
  };
  x2.cwd = function() {
    return "/";
  };
  x2.chdir = function(n4) {
    throw new Error("process.chdir is not supported");
  };
  x2.umask = function() {
    return 0;
  };
  function ie2() {
  }
  var Yt2 = h2.exports.browser, Zt2 = ie2, $t2 = h2.exports.binding, Qt2 = ie2, en2 = 1, tn2 = {}, nn2 = ie2, rn2 = ie2, an2 = ie2, sn2 = ie2, on2 = ie2, un2 = "browser", pn2 = "browser", dn2 = "browser", ln2 = [], cn2 = { nextTick: h2.exports.nextTick, title: h2.exports.title, browser: Yt2, env: h2.exports.env, argv: h2.exports.argv, version: h2.exports.version, versions: h2.exports.versions, on: h2.exports.on, addListener: h2.exports.addListener, once: h2.exports.once, off: h2.exports.off, removeListener: h2.exports.removeListener, removeAllListeners: h2.exports.removeAllListeners, emit: h2.exports.emit, emitWarning: Zt2, prependListener: h2.exports.prependListener, prependOnceListener: h2.exports.prependOnceListener, listeners: h2.exports.listeners, binding: $t2, cwd: h2.exports.cwd, chdir: h2.exports.chdir, umask: h2.exports.umask, exit: Qt2, pid: en2, features: tn2, kill: nn2, dlopen: rn2, uptime: an2, memoryUsage: sn2, uvCounters: on2, platform: un2, arch: pn2, execPath: dn2, execArgv: ln2 };
  g2.addListener = h2.exports.addListener;
  g2.arch = pn2;
  g2.argv = h2.exports.argv;
  g2.binding = $t2;
  g2.browser = Yt2;
  g2.chdir = h2.exports.chdir;
  g2.cwd = h2.exports.cwd;
  g2.default = cn2;
  g2.dlopen = rn2;
  g2.emit = h2.exports.emit;
  g2.emitWarning = Zt2;
  g2.env = h2.exports.env;
  g2.execArgv = ln2;
  g2.execPath = dn2;
  g2.exit = Qt2;
  g2.features = tn2;
  g2.kill = nn2;
  g2.listeners = h2.exports.listeners;
  g2.memoryUsage = sn2;
  g2.nextTick = h2.exports.nextTick;
  g2.off = h2.exports.off;
  g2.on = h2.exports.on;
  g2.once = h2.exports.once;
  g2.pid = en2;
  g2.platform = un2;
  g2.prependListener = h2.exports.prependListener;
  g2.prependOnceListener = h2.exports.prependOnceListener;
  g2.removeAllListeners = h2.exports.removeAllListeners;
  g2.removeListener = h2.exports.removeListener;
  g2.title = h2.exports.title;
  g2.umask = h2.exports.umask;
  g2.uptime = an2;
  g2.uvCounters = on2;
  g2.version = h2.exports.version;
  g2.versions = h2.exports.versions;
  g2 = yn2.exports = cn2;
});
var T$2, Zr$1, w$5, y$3 = hr$2(() => {
  T$2 = Te$6(ut$3()), Te$6(mn$1()), Zr$1 = function(n4) {
    function e2() {
      var r3 = this || self;
      return delete n4.prototype.__magic__, r3;
    }
    if (typeof globalThis == "object") return globalThis;
    if (this) return e2();
    n4.defineProperty(n4.prototype, "__magic__", { configurable: true, get: e2 });
    var t = __magic__;
    return t;
  }(Object), w$5 = Zr$1;
});
var hn$2 = de$7((Ja2, fn2) => {
  y$3();
  function $r2(n4) {
    if (n4.length >= 255) throw new TypeError("Alphabet too long");
    for (var e2 = new Uint8Array(256), t = 0; t < e2.length; t++) e2[t] = 255;
    for (var r3 = 0; r3 < n4.length; r3++) {
      var a2 = n4.charAt(r3), s2 = a2.charCodeAt(0);
      if (e2[s2] !== 255) throw new TypeError(a2 + " is ambiguous");
      e2[s2] = r3;
    }
    var i = n4.length, o2 = n4.charAt(0), u2 = Math.log(i) / Math.log(256), l2 = Math.log(256) / Math.log(i);
    function c(f2) {
      if (f2 instanceof Uint8Array || (ArrayBuffer.isView(f2) ? f2 = new Uint8Array(f2.buffer, f2.byteOffset, f2.byteLength) : Array.isArray(f2) && (f2 = Uint8Array.from(f2))), !(f2 instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
      if (f2.length === 0) return "";
      for (var A2 = 0, S2 = 0, E3 = 0, C2 = f2.length; E3 !== C2 && f2[E3] === 0; ) E3++, A2++;
      for (var P2 = (C2 - E3) * l2 + 1 >>> 0, L2 = new Uint8Array(P2); E3 !== C2; ) {
        for (var U2 = f2[E3], j2 = 0, V2 = P2 - 1; (U2 !== 0 || j2 < S2) && V2 !== -1; V2--, j2++) U2 += 256 * L2[V2] >>> 0, L2[V2] = U2 % i >>> 0, U2 = U2 / i >>> 0;
        if (U2 !== 0) throw new Error("Non-zero carry");
        S2 = j2, E3++;
      }
      for (var B2 = P2 - S2; B2 !== P2 && L2[B2] === 0; ) B2++;
      for (var we2 = o2.repeat(A2); B2 < P2; ++B2) we2 += n4.charAt(L2[B2]);
      return we2;
    }
    function d2(f2) {
      if (typeof f2 != "string") throw new TypeError("Expected String");
      if (f2.length === 0) return new Uint8Array();
      for (var A2 = 0, S2 = 0, E3 = 0; f2[A2] === o2; ) S2++, A2++;
      for (var C2 = (f2.length - A2) * u2 + 1 >>> 0, P2 = new Uint8Array(C2); f2[A2]; ) {
        var L2 = f2.charCodeAt(A2);
        if (L2 > 255) return;
        var U2 = e2[L2];
        if (U2 === 255) return;
        for (var j2 = 0, V2 = C2 - 1; (U2 !== 0 || j2 < E3) && V2 !== -1; V2--, j2++) U2 += i * P2[V2] >>> 0, P2[V2] = U2 % 256 >>> 0, U2 = U2 / 256 >>> 0;
        if (U2 !== 0) throw new Error("Non-zero carry");
        E3 = j2, A2++;
      }
      for (var B2 = C2 - E3; B2 !== C2 && P2[B2] === 0; ) B2++;
      for (var we2 = new Uint8Array(S2 + (C2 - B2)), dr2 = S2; B2 !== C2; ) we2[dr2++] = P2[B2++];
      return we2;
    }
    function b2(f2) {
      var A2 = d2(f2);
      if (A2) return A2;
      throw new Error("Non-base" + i + " character");
    }
    return { encode: c, decodeUnsafe: d2, decode: b2 };
  }
  fn2.exports = $r2;
});
var lt$6 = de$7((Za2, gn2) => {
  y$3();
  var Qr2 = hn$2(), ea2 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
  gn2.exports = Qr2(ea2);
});
y$3();
y$3();
y$3();
var Ee$4 = Te$6(lt$6());
y$3();
var N$6 = 2n ** 255n - 19n, me$5 = 2n ** 252n + 27742317777372353535851937790883648493n, ct$4 = 0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51an, yt$5 = 0x6666666666666666666666666666666666666666666666666666666666666658n, ta$4 = 37095705934669439343138083508754565189542113879843219016388785533085940283555n, Oe$2 = { a: -1n, d: ta$4, h: 8 }, R$4 = (n4 = "") => {
  throw new Error(n4);
}, xn$2 = (n4) => typeof n4 == "string", na$1 = (n4) => n4 instanceof Uint8Array || ArrayBuffer.isView(n4) && n4.constructor.name === "Uint8Array", fe$3 = (n4, e2) => !na$1(n4) || typeof e2 == "number" && e2 > 0 && n4.length !== e2 ? R$4("Uint8Array of valid length expected") : n4, he$6 = (n4) => new Uint8Array(n4), Pe$3 = (n4, e2) => fe$3(xn$2(n4) ? ht$5(n4) : he$6(fe$3(n4)), e2), m$2 = (n4, e2 = N$6) => {
  let t = n4 % e2;
  return t >= 0n ? t : e2 + t;
}, bn$3 = (n4) => n4 instanceof ee$4 ? n4 : R$4("Point expected"), ee$4 = class n2 {
  constructor(e2, t, r3, a2) {
    this.ex = e2, this.ey = t, this.ez = r3, this.et = a2;
  }
  static fromAffine(e2) {
    return new n2(e2.x, e2.y, 1n, m$2(e2.x * e2.y));
  }
  static fromHex(e2, t = false) {
    let { d: r3 } = Oe$2;
    e2 = Pe$3(e2, 32);
    let a2 = e2.slice(), s2 = e2[31];
    a2[31] = s2 & -129;
    let i = In$2(a2);
    t && !(0n <= i && i < 2n ** 256n) && R$4("bad y coord 1"), !t && !(0n <= i && i < N$6) && R$4("bad y coord 2");
    let o2 = m$2(i * i), u2 = m$2(o2 - 1n), l2 = m$2(r3 * o2 + 1n), { isValid: c, value: d2 } = aa$1(u2, l2);
    c || R$4("bad y coordinate 3");
    let b2 = (d2 & 1n) === 1n, f2 = (s2 & 128) !== 0;
    return !t && d2 === 0n && f2 && R$4("bad y coord 3"), f2 !== b2 && (d2 = m$2(-d2)), new n2(d2, i, 1n, m$2(d2 * i));
  }
  get x() {
    return this.toAffine().x;
  }
  get y() {
    return this.toAffine().y;
  }
  equals(e2) {
    let { ex: t, ey: r3, ez: a2 } = this, { ex: s2, ey: i, ez: o2 } = bn$3(e2), u2 = m$2(t * o2), l2 = m$2(s2 * a2), c = m$2(r3 * o2), d2 = m$2(i * a2);
    return u2 === l2 && c === d2;
  }
  is0() {
    return this.equals(ve$7);
  }
  negate() {
    return new n2(m$2(-this.ex), this.ey, this.ez, m$2(-this.et));
  }
  double() {
    let { ex: e2, ey: t, ez: r3 } = this, { a: a2 } = Oe$2, s2 = m$2(e2 * e2), i = m$2(t * t), o2 = m$2(2n * m$2(r3 * r3)), u2 = m$2(a2 * s2), l2 = e2 + t, c = m$2(m$2(l2 * l2) - s2 - i), d2 = u2 + i, b2 = d2 - o2, f2 = u2 - i, A2 = m$2(c * b2), S2 = m$2(d2 * f2), E3 = m$2(c * f2), C2 = m$2(b2 * d2);
    return new n2(A2, S2, C2, E3);
  }
  add(e2) {
    let { ex: t, ey: r3, ez: a2, et: s2 } = this, { ex: i, ey: o2, ez: u2, et: l2 } = bn$3(e2), { a: c, d: d2 } = Oe$2, b2 = m$2(t * i), f2 = m$2(r3 * o2), A2 = m$2(s2 * d2 * l2), S2 = m$2(a2 * u2), E3 = m$2((t + r3) * (i + o2) - b2 - f2), C2 = m$2(S2 - A2), P2 = m$2(S2 + A2), L2 = m$2(f2 - c * b2), U2 = m$2(E3 * C2), j2 = m$2(P2 * L2), V2 = m$2(E3 * L2), B2 = m$2(C2 * P2);
    return new n2(U2, j2, B2, V2);
  }
  mul(e2, t = true) {
    if (e2 === 0n) return t === true ? R$4("cannot multiply by 0") : ve$7;
    if (typeof e2 == "bigint" && 0n < e2 && e2 < me$5 || R$4("invalid scalar, must be < L"), !t && this.is0() || e2 === 1n) return this;
    if (this.equals(ue$8)) return pa(e2).p;
    let r3 = ve$7, a2 = ue$8;
    for (let s2 = this; e2 > 0n; s2 = s2.double(), e2 >>= 1n) e2 & 1n ? r3 = r3.add(s2) : t && (a2 = a2.add(s2));
    return r3;
  }
  multiply(e2) {
    return this.mul(e2);
  }
  clearCofactor() {
    return this.mul(BigInt(Oe$2.h), false);
  }
  isSmallOrder() {
    return this.clearCofactor().is0();
  }
  isTorsionFree() {
    let e2 = this.mul(me$5 / 2n, false).double();
    return me$5 % 2n && (e2 = e2.add(this)), e2.is0();
  }
  toAffine() {
    let { ex: e2, ey: t, ez: r3 } = this;
    if (this.equals(ve$7)) return { x: 0n, y: 1n };
    let a2 = _n$1(r3, N$6);
    return m$2(r3 * a2) !== 1n && R$4("invalid inverse"), { x: m$2(e2 * a2), y: m$2(t * a2) };
  }
  toRawBytes() {
    let { x: e2, y: t } = this.toAffine(), r3 = Cn$1(t);
    return r3[31] |= e2 & 1n ? 128 : 0, r3;
  }
  toHex() {
    return ft$4(this.toRawBytes());
  }
};
ee$4.BASE = new ee$4(ct$4, yt$5, 1n, m$2(ct$4 * yt$5));
ee$4.ZERO = new ee$4(0n, 1n, 1n, 0n);
var { BASE: ue$8, ZERO: ve$7 } = ee$4, En$2 = (n4, e2) => n4.toString(16).padStart(e2, "0"), ft$4 = (n4) => Array.from(fe$3(n4)).map((e2) => En$2(e2, 2)).join(""), $$5 = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 }, An$3 = (n4) => {
  if (n4 >= $$5._0 && n4 <= $$5._9) return n4 - $$5._0;
  if (n4 >= $$5.A && n4 <= $$5.F) return n4 - ($$5.A - 10);
  if (n4 >= $$5.a && n4 <= $$5.f) return n4 - ($$5.a - 10);
}, ht$5 = (n4) => {
  let e2 = "hex invalid";
  if (!xn$2(n4)) return R$4(e2);
  let t = n4.length, r3 = t / 2;
  if (t % 2) return R$4(e2);
  let a2 = he$6(r3);
  for (let s2 = 0, i = 0; s2 < r3; s2++, i += 2) {
    let o2 = An$3(n4.charCodeAt(i)), u2 = An$3(n4.charCodeAt(i + 1));
    if (o2 === void 0 || u2 === void 0) return R$4(e2);
    a2[s2] = o2 * 16 + u2;
  }
  return a2;
}, Cn$1 = (n4) => ht$5(En$2(n4, 32 * 2)).reverse(), In$2 = (n4) => BigInt("0x" + ft$4(he$6(fe$3(n4)).reverse())), De$6 = (...n4) => {
  let e2 = he$6(n4.reduce((r3, a2) => r3 + fe$3(a2).length, 0)), t = 0;
  return n4.forEach((r3) => {
    e2.set(r3, t), t += r3.length;
  }), e2;
}, _n$1 = (n4, e2) => {
  (n4 === 0n || e2 <= 0n) && R$4("no inverse n=" + n4 + " mod=" + e2);
  let t = m$2(n4, e2), r3 = e2, a2 = 0n, i = 1n;
  for (; t !== 0n; ) {
    let u2 = r3 / t, l2 = r3 % t, c = a2 - i * u2;
    r3 = t, t = l2, a2 = i, i = c;
  }
  return r3 === 1n ? m$2(a2, e2) : R$4("no inverse");
}, q$3 = (n4, e2) => {
  let t = n4;
  for (; e2-- > 0n; ) t *= t, t %= N$6;
  return t;
}, ra$1 = (n4) => {
  let t = n4 * n4 % N$6 * n4 % N$6, r3 = q$3(t, 2n) * t % N$6, a2 = q$3(r3, 1n) * n4 % N$6, s2 = q$3(a2, 5n) * a2 % N$6, i = q$3(s2, 10n) * s2 % N$6, o2 = q$3(i, 20n) * i % N$6, u2 = q$3(o2, 40n) * o2 % N$6, l2 = q$3(u2, 80n) * u2 % N$6, c = q$3(l2, 80n) * u2 % N$6, d2 = q$3(c, 10n) * s2 % N$6;
  return { pow_p_5_8: q$3(d2, 2n) * n4 % N$6, b2: t };
}, wn$4 = 19681161376707505956807079304988542015446066515923890162744021073123829784752n, aa$1 = (n4, e2) => {
  let t = m$2(e2 * e2 * e2), r3 = m$2(t * t * e2), a2 = ra$1(n4 * r3).pow_p_5_8, s2 = m$2(n4 * t * a2), i = m$2(e2 * s2 * s2), o2 = s2, u2 = m$2(s2 * wn$4), l2 = i === n4, c = i === m$2(-n4), d2 = i === m$2(-n4 * wn$4);
  return l2 && (s2 = o2), (c || d2) && (s2 = u2), (m$2(s2) & 1n) === 1n && (s2 = m$2(-s2)), { isValid: l2 || c, value: s2 };
}, mt$4 = (n4) => m$2(In$2(n4), me$5), xe$3, gt$2 = (...n4) => At$3.sha512Async(...n4), Sn$4 = (...n4) => typeof xe$3 == "function" ? xe$3(...n4) : R$4("etc.sha512Sync not set"), Mn$1 = (n4) => {
  let e2 = n4.slice(0, 32);
  e2[0] &= 248, e2[31] &= 127, e2[31] |= 64;
  let t = n4.slice(32, 64), r3 = mt$4(e2), a2 = ue$8.mul(r3), s2 = a2.toRawBytes();
  return { head: e2, prefix: t, scalar: r3, point: a2, pointBytes: s2 };
}, bt$6 = (n4) => gt$2(Pe$3(n4, 32)).then(Mn$1), sa$2 = (n4) => Mn$1(Sn$4(Pe$3(n4, 32))), kn = (n4) => bt$6(n4).then((e2) => e2.pointBytes);
function ia$1(n4, e2) {
  return n4 ? gt$2(e2.hashable).then(e2.finish) : e2.finish(Sn$4(e2.hashable));
}
var oa$3 = (n4, e2, t) => {
  let { pointBytes: r3, scalar: a2 } = n4, s2 = mt$4(e2), i = ue$8.mul(s2).toRawBytes();
  return { hashable: De$6(i, r3, t), finish: (l2) => {
    let c = m$2(s2 + mt$4(l2) * a2, me$5);
    return fe$3(De$6(i, Cn$1(c)), 64);
  } };
}, Nn$3 = async (n4, e2) => {
  let t = Pe$3(n4), r3 = await bt$6(e2), a2 = await gt$2(r3.prefix, t);
  return ia$1(true, oa$3(r3, a2, t));
};
var Tn$1 = () => typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0, At$3 = { bytesToHex: ft$4, hexToBytes: ht$5, concatBytes: De$6, mod: m$2, invert: _n$1, randomBytes: (n4 = 32) => {
  let e2 = Tn$1();
  return (!e2 || !e2.getRandomValues) && R$4("crypto.getRandomValues must be defined"), e2.getRandomValues(he$6(n4));
}, sha512Async: async (...n4) => {
  let e2 = Tn$1(), t = e2 && e2.subtle;
  t || R$4("etc.sha512Async or crypto.subtle must be defined");
  let r3 = De$6(...n4);
  return he$6(await t.digest("SHA-512", r3.buffer));
}, sha512Sync: void 0 };
Object.defineProperties(At$3, { sha512Sync: { configurable: false, get() {
  return xe$3;
}, set(n4) {
  xe$3 || (xe$3 = n4);
} } });
var Ke$8 = { getExtendedPublicKeyAsync: bt$6, getExtendedPublicKey: sa$2, randomPrivateKey: () => At$3.randomBytes(32), precompute: (n4 = 8, e2 = ue$8) => (e2.multiply(3n), e2) }, oe$9 = 8, ua$3 = () => {
  let n4 = [], e2 = 256 / oe$9 + 1, t = ue$8, r3 = t;
  for (let a2 = 0; a2 < e2; a2++) {
    r3 = t, n4.push(r3);
    for (let s2 = 1; s2 < 2 ** (oe$9 - 1); s2++) r3 = r3.add(t), n4.push(r3);
    t = r3.double();
  }
  return n4;
}, vn$2, pa = (n4) => {
  let e2 = vn$2 || (vn$2 = ua$3()), t = (c, d2) => {
    let b2 = d2.negate();
    return c ? b2 : d2;
  }, r3 = ve$7, a2 = ue$8, s2 = 1 + 256 / oe$9, i = 2 ** (oe$9 - 1), o2 = BigInt(2 ** oe$9 - 1), u2 = 2 ** oe$9, l2 = BigInt(oe$9);
  for (let c = 0; c < s2; c++) {
    let d2 = c * i, b2 = Number(n4 & o2);
    n4 >>= l2, b2 > i && (b2 -= u2, n4 += 1n);
    let f2 = d2, A2 = d2 + Math.abs(b2) - 1, S2 = c % 2 !== 0, E3 = b2 < 0;
    b2 === 0 ? a2 = a2.add(t(S2, e2[f2])) : r3 = r3.add(t(E3, e2[A2]));
  }
  return { p: r3, f: a2 };
};
var H$2 = class n3 {
  static generateKey() {
    let e2, t;
    do
      e2 = Ke$8.randomPrivateKey(), t = (0, Ee$4.encode)(e2);
    while (t.length !== 44);
    return new n3(t);
  }
  constructor(e2) {
    this.secretKey = e2;
    let t = (0, Ee$4.decode)(e2);
    this.privateKey = T$2.Buffer.from(t).toString("hex");
  }
  async sign(e2) {
    return await Nn$3(e2, this.privateKey);
  }
  async getPublicKey() {
    let e2 = await kn(this.privateKey);
    return `ed25519:${(0, Ee$4.encode)(e2)}`;
  }
  toString() {
    return this.privateKey;
  }
};
var Ve$5 = class Ve {
  constructor(e2 = "testnet") {
    this.networkId = e2;
  }
  get keyPrefix() {
    return `orderly_${this.networkId}_`;
  }
}, Ce$4 = class Ce extends Ve$5 {
  getOrderlyKey(e2) {
    let t;
    if (e2) t = this.getItem(e2, "orderlyKey");
    else {
      let r3 = this.getAddress();
      if (!r3) return null;
      t = this.getItem(r3, "orderlyKey");
    }
    return t ? new H$2(t) : null;
  }
  getAccountId(e2) {
    return this.getItem(e2, "accountId");
  }
  setAccountId(e2, t) {
    this.setItem(e2, { accountId: t });
  }
  getAddress() {
    return localStorage.getItem(`${this.keyPrefix}address`);
  }
  setAddress(e2) {
    localStorage.setItem(`${this.keyPrefix}address`, e2);
  }
  removeAddress() {
    localStorage.removeItem(`${this.keyPrefix}address`);
  }
  generateKey() {
    return H$2.generateKey();
  }
  setKey(e2, t) {
    this.setItem(e2, { orderlyKey: t.secretKey });
  }
  cleanAllKey(e2) {
    localStorage.removeItem(`${this.keyPrefix}${e2}`), localStorage.removeItem(`${this.keyPrefix}address`);
  }
  cleanKey(e2, t) {
    let r3 = this.getItem(e2);
    delete r3[t], localStorage.setItem(`${this.keyPrefix}${e2}`, JSON.stringify(r3));
  }
  setItem(e2, t) {
    let r3 = `${this.keyPrefix}${e2}`, a2 = localStorage.getItem(r3);
    a2 ? a2 = JSON.parse(a2) : a2 = {}, localStorage.setItem(r3, JSON.stringify({ ...a2, ...t }));
  }
  getItem(e2, t) {
    let r3 = `${this.keyPrefix}${e2}`, a2 = localStorage.getItem(r3);
    return a2 ? a2 = JSON.parse(a2) : a2 = {}, typeof t > "u" ? a2 : a2[t];
  }
};
y$3();
var Un$2 = {};
gr$3(Un$2, { base64url: () => wt$5, calculateStringHash: () => vt$5, formatByUnits: () => Le$6, getGlobalObject: () => Se$7, getTimestamp: () => I$7, isHex: () => _e$6, isHexString: () => ma$3, parseAccountId: () => Tt$3, parseBrokerHash: () => pe$5, parseTokenHash: () => He$6, parseUnits: () => parseUnits$1 });
y$3();
var wt$5 = function(n4) {
  return n4.replace(/\+/g, "-").replace(/\//g, "_");
};
function pe$5(n4) {
  return vt$5(n4);
}
function Tt$3(n4, e2) {
  let t = AbiCoder.defaultAbiCoder();
  return keccak256(t.encode(["address", "bytes32"], [n4, pe$5(e2)]));
}
function He$6(n4) {
  return vt$5(n4);
}
function vt$5(n4) {
  return solidityPackedKeccak256(["string"], [n4]);
}
function Le$6(n4, e2 = "ether") {
  return formatUnits(n4, e2);
}
function _e$6(n4) {
  return /^[a-f0-9]+$/iu.test(n4);
}
function ma$3(n4) {
  return typeof n4 == "string" && n4.startsWith("0x") && _e$6(n4);
}
var Se$7 = () => {
  if (typeof globalThis < "u") return globalThis;
  if (typeof self < "u") return self;
  if (typeof window < "u") return window;
  if (typeof w$5 < "u") return w$5;
  throw new Error("cannot find the global object");
}, I$7 = () => {
  var _a3;
  if (typeof window < "u") {
    let n4 = (_a3 = Se$7()) == null ? void 0 : _a3.__ORDERLY_timestamp_offset;
    if (typeof n4 == "number") return Date.now() + (n4 || 0);
  }
  return Date.now();
};
var xt$3 = Te$6(ut$3()), te$5 = class te {
  constructor(e2) {
    this.keyStore = e2;
  }
  async sign(e2, t = I$7()) {
    let r3 = t.toString(), a2 = [r3, e2.method.toUpperCase(), e2.url].join("");
    e2.data && Object.keys(e2.data).length && (a2 += JSON.stringify(e2.data));
    let { signature: s2, publicKey: i } = await this.signText(a2);
    return { "orderly-key": i, "orderly-timestamp": r3, "orderly-signature": s2 };
  }
  async signText(e2) {
    let t = this.keyStore.getOrderlyKey();
    if (!t) throw new Error("orderlyKeyPair is not defined");
    let r3 = xt$3.Buffer.from(e2), a2 = await t.sign(r3), s2 = xt$3.Buffer.from(a2).toString("base64");
    return { signature: wt$5(s2), publicKey: await t.getPublicKey() };
  }
};
y$3();
y$3();
y$3();
var Fn$1 = "0xfd064A18f3BF249cf1f87FC203E90D8f650f2d63";
var On$1 = "0x0EaC556c0C2321BA25b9DC01e4e3c95aD5CDCd2f", Dn$1 = "0x1826B75e2ef249173FC735149AE4B8e9ea10abff", Pn$2 = "0xaf88d065e77c8cC2239327C5EDb3A432268e5831", Kn$1 = "0x816f722424B49Cf1275cc86DA9840Fbd5a6167e9", Vn$1 = "0x6F7a338F2aA472838dEFD3283eB360d4Dff5D203", Hn$1 = "ErBmAD61mGFKvrFNaTJuxoPwqrS8GgtwtqJTJVjFWx9Q", Ln$1 = "9shwxWDUNhtwkHocsUAmrNAQfBH2DHh4njdAEdHZZkF2";
var Wn$5 = "5zBjLor7vEraAt4zp2H82sy9MSqFoDnNa1Lx6EYKTYRZ", Gn$3 = "4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU", zn$2 = "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v", _$4 = { statusChanged: "change:status", validateStart: "validate:start", validateEnd: "validate:end", switchAccount: "switch:account" }, Xn$3 = "0x65B99E978d1eeE9CfEdfD463EC7A81317e5A5073", qn = "0x9442e24203e999db4aE87E35Dc0c8F3C610c29A0", jn$3 = "0x77F77926C6596c78f285D230Cd0dC8dC3540e3a6", Jn$1 = "0xdd6E018D747D70C705BA84B67B6eAD7748a57cDa", Yn = "0x84A71ccD554Cc1b02749b35d22F684CC8ec987e1", Zn$1 = "0xa0BB43E2eA7fcE91F07e628d72fD6333e80F47D2", $n$1 = "0x44Df3723136b7372a61c404Dc1Bd503460833310", Qn$1 = "0xf14Ff11F3bb1011ff42665Ec869c7827c43745Fd", er$2 = "0x2c65ea2eE7265df755d7258291202690c27C6d2d", tr$3 = "0xE80F2396A266e898FBbD251b89CFE65B3e41fD18";
var Et$4 = [{ anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "owner", type: "address" }, { indexed: true, internalType: "address", name: "spender", type: "address" }, { indexed: false, internalType: "uint256", name: "value", type: "uint256" }], name: "Approval", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "authorizer", type: "address" }, { indexed: true, internalType: "bytes32", name: "nonce", type: "bytes32" }], name: "AuthorizationCanceled", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "authorizer", type: "address" }, { indexed: true, internalType: "bytes32", name: "nonce", type: "bytes32" }], name: "AuthorizationUsed", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "_account", type: "address" }], name: "Blacklisted", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "newBlacklister", type: "address" }], name: "BlacklisterChanged", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "burner", type: "address" }, { indexed: false, internalType: "uint256", name: "amount", type: "uint256" }], name: "Burn", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "newMasterMinter", type: "address" }], name: "MasterMinterChanged", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "minter", type: "address" }, { indexed: true, internalType: "address", name: "to", type: "address" }, { indexed: false, internalType: "uint256", name: "amount", type: "uint256" }], name: "Mint", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "minter", type: "address" }, { indexed: false, internalType: "uint256", name: "minterAllowedAmount", type: "uint256" }], name: "MinterConfigured", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "oldMinter", type: "address" }], name: "MinterRemoved", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "address", name: "previousOwner", type: "address" }, { indexed: false, internalType: "address", name: "newOwner", type: "address" }], name: "OwnershipTransferred", type: "event" }, { anonymous: false, inputs: [], name: "Pause", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "newAddress", type: "address" }], name: "PauserChanged", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "newRescuer", type: "address" }], name: "RescuerChanged", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "from", type: "address" }, { indexed: true, internalType: "address", name: "to", type: "address" }, { indexed: false, internalType: "uint256", name: "value", type: "uint256" }], name: "Transfer", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "_account", type: "address" }], name: "UnBlacklisted", type: "event" }, { anonymous: false, inputs: [], name: "Unpause", type: "event" }, { inputs: [], name: "CANCEL_AUTHORIZATION_TYPEHASH", outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }], stateMutability: "view", type: "function" }, { inputs: [], name: "DOMAIN_SEPARATOR", outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }], stateMutability: "view", type: "function" }, { inputs: [], name: "PERMIT_TYPEHASH", outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }], stateMutability: "view", type: "function" }, { inputs: [], name: "RECEIVE_WITH_AUTHORIZATION_TYPEHASH", outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }], stateMutability: "view", type: "function" }, { inputs: [], name: "TRANSFER_WITH_AUTHORIZATION_TYPEHASH", outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "owner", type: "address" }, { internalType: "address", name: "spender", type: "address" }], name: "allowance", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "spender", type: "address" }, { internalType: "uint256", name: "value", type: "uint256" }], name: "approve", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "authorizer", type: "address" }, { internalType: "bytes32", name: "nonce", type: "bytes32" }], name: "authorizationState", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "account", type: "address" }], name: "balanceOf", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "_account", type: "address" }], name: "blacklist", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "blacklister", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint256", name: "_amount", type: "uint256" }], name: "burn", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "authorizer", type: "address" }, { internalType: "bytes32", name: "nonce", type: "bytes32" }, { internalType: "uint8", name: "v", type: "uint8" }, { internalType: "bytes32", name: "r", type: "bytes32" }, { internalType: "bytes32", name: "s", type: "bytes32" }], name: "cancelAuthorization", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "minter", type: "address" }, { internalType: "uint256", name: "minterAllowedAmount", type: "uint256" }], name: "configureMinter", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "currency", outputs: [{ internalType: "string", name: "", type: "string" }], stateMutability: "view", type: "function" }, { inputs: [], name: "decimals", outputs: [{ internalType: "uint8", name: "", type: "uint8" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "spender", type: "address" }, { internalType: "uint256", name: "decrement", type: "uint256" }], name: "decreaseAllowance", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "spender", type: "address" }, { internalType: "uint256", name: "increment", type: "uint256" }], name: "increaseAllowance", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "string", name: "tokenName", type: "string" }, { internalType: "string", name: "tokenSymbol", type: "string" }, { internalType: "string", name: "tokenCurrency", type: "string" }, { internalType: "uint8", name: "tokenDecimals", type: "uint8" }, { internalType: "address", name: "newMasterMinter", type: "address" }, { internalType: "address", name: "newPauser", type: "address" }, { internalType: "address", name: "newBlacklister", type: "address" }, { internalType: "address", name: "newOwner", type: "address" }], name: "initialize", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "string", name: "newName", type: "string" }], name: "initializeV2", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "lostAndFound", type: "address" }], name: "initializeV2_1", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_account", type: "address" }], name: "isBlacklisted", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "account", type: "address" }], name: "isMinter", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [], name: "masterMinter", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "_to", type: "address" }, { internalType: "uint256", name: "_amount", type: "uint256" }], name: "mint", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "minter", type: "address" }], name: "minterAllowance", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [], name: "name", outputs: [{ internalType: "string", name: "", type: "string" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "owner", type: "address" }], name: "nonces", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [], name: "owner", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [], name: "pause", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "paused", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [], name: "pauser", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "owner", type: "address" }, { internalType: "address", name: "spender", type: "address" }, { internalType: "uint256", name: "value", type: "uint256" }, { internalType: "uint256", name: "deadline", type: "uint256" }, { internalType: "uint8", name: "v", type: "uint8" }, { internalType: "bytes32", name: "r", type: "bytes32" }, { internalType: "bytes32", name: "s", type: "bytes32" }], name: "permit", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "from", type: "address" }, { internalType: "address", name: "to", type: "address" }, { internalType: "uint256", name: "value", type: "uint256" }, { internalType: "uint256", name: "validAfter", type: "uint256" }, { internalType: "uint256", name: "validBefore", type: "uint256" }, { internalType: "bytes32", name: "nonce", type: "bytes32" }, { internalType: "uint8", name: "v", type: "uint8" }, { internalType: "bytes32", name: "r", type: "bytes32" }, { internalType: "bytes32", name: "s", type: "bytes32" }], name: "receiveWithAuthorization", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "minter", type: "address" }], name: "removeMinter", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "contract IERC20", name: "tokenContract", type: "address" }, { internalType: "address", name: "to", type: "address" }, { internalType: "uint256", name: "amount", type: "uint256" }], name: "rescueERC20", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "rescuer", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [], name: "symbol", outputs: [{ internalType: "string", name: "", type: "string" }], stateMutability: "view", type: "function" }, { inputs: [], name: "totalSupply", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "to", type: "address" }, { internalType: "uint256", name: "value", type: "uint256" }], name: "transfer", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "from", type: "address" }, { internalType: "address", name: "to", type: "address" }, { internalType: "uint256", name: "value", type: "uint256" }], name: "transferFrom", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "newOwner", type: "address" }], name: "transferOwnership", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "from", type: "address" }, { internalType: "address", name: "to", type: "address" }, { internalType: "uint256", name: "value", type: "uint256" }, { internalType: "uint256", name: "validAfter", type: "uint256" }, { internalType: "uint256", name: "validBefore", type: "uint256" }, { internalType: "bytes32", name: "nonce", type: "bytes32" }, { internalType: "uint8", name: "v", type: "uint8" }, { internalType: "bytes32", name: "r", type: "bytes32" }, { internalType: "bytes32", name: "s", type: "bytes32" }], name: "transferWithAuthorization", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_account", type: "address" }], name: "unBlacklist", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "unpause", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_newBlacklister", type: "address" }], name: "updateBlacklister", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_newMasterMinter", type: "address" }], name: "updateMasterMinter", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_newPauser", type: "address" }], name: "updatePauser", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "newRescuer", type: "address" }], name: "updateRescuer", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "version", outputs: [{ internalType: "string", name: "", type: "string" }], stateMutability: "view", type: "function" }];
var nr$2 = [{ inputs: [], stateMutability: "nonpayable", type: "constructor" }, { inputs: [], name: "AccountIdInvalid", type: "error" }, { inputs: [], name: "AddressZero", type: "error" }, { inputs: [{ internalType: "uint256", name: "balance", type: "uint256" }, { internalType: "uint128", name: "amount", type: "uint128" }], name: "BalanceNotEnough", type: "error" }, { inputs: [], name: "BrokerNotAllowed", type: "error" }, { inputs: [], name: "EnumerableSetError", type: "error" }, { inputs: [], name: "OnlyCrossChainManagerCanCall", type: "error" }, { inputs: [], name: "TokenNotAllowed", type: "error" }, { inputs: [], name: "ZeroDepositFee", type: "error" }, { anonymous: false, inputs: [{ indexed: true, internalType: "bytes32", name: "accountId", type: "bytes32" }, { indexed: true, internalType: "address", name: "userAddress", type: "address" }, { indexed: true, internalType: "uint64", name: "depositNonce", type: "uint64" }, { indexed: false, internalType: "bytes32", name: "tokenHash", type: "bytes32" }, { indexed: false, internalType: "uint128", name: "tokenAmount", type: "uint128" }], name: "AccountDeposit", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "bytes32", name: "accountId", type: "bytes32" }, { indexed: true, internalType: "address", name: "userAddress", type: "address" }, { indexed: true, internalType: "uint64", name: "depositNonce", type: "uint64" }, { indexed: false, internalType: "bytes32", name: "tokenHash", type: "bytes32" }, { indexed: false, internalType: "uint128", name: "tokenAmount", type: "uint128" }], name: "AccountDepositTo", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "bytes32", name: "accountId", type: "bytes32" }, { indexed: true, internalType: "uint64", name: "withdrawNonce", type: "uint64" }, { indexed: false, internalType: "bytes32", name: "brokerHash", type: "bytes32" }, { indexed: false, internalType: "address", name: "sender", type: "address" }, { indexed: false, internalType: "address", name: "receiver", type: "address" }, { indexed: false, internalType: "bytes32", name: "tokenHash", type: "bytes32" }, { indexed: false, internalType: "uint128", name: "tokenAmount", type: "uint128" }, { indexed: false, internalType: "uint128", name: "fee", type: "uint128" }], name: "AccountWithdraw", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "address", name: "oldAddress", type: "address" }, { indexed: false, internalType: "address", name: "newAddress", type: "address" }], name: "ChangeCrossChainManager", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "bytes32", name: "_tokenHash", type: "bytes32" }, { indexed: false, internalType: "address", name: "_tokenAddress", type: "address" }], name: "ChangeTokenAddressAndAllow", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "uint8", name: "version", type: "uint8" }], name: "Initialized", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "previousOwner", type: "address" }, { indexed: true, internalType: "address", name: "newOwner", type: "address" }], name: "OwnershipTransferred", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "address", name: "account", type: "address" }], name: "Paused", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "bytes32", name: "_brokerHash", type: "bytes32" }, { indexed: false, internalType: "bool", name: "_allowed", type: "bool" }], name: "SetAllowedBroker", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "bytes32", name: "_tokenHash", type: "bytes32" }, { indexed: false, internalType: "bool", name: "_allowed", type: "bool" }], name: "SetAllowedToken", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "address", name: "account", type: "address" }], name: "Unpaused", type: "event" }, { inputs: [{ internalType: "bytes32", name: "", type: "bytes32" }], name: "allowedToken", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "_tokenHash", type: "bytes32" }, { internalType: "address", name: "_tokenAddress", type: "address" }], name: "changeTokenAddressAndAllow", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "crossChainManagerAddress", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ components: [{ internalType: "bytes32", name: "accountId", type: "bytes32" }, { internalType: "bytes32", name: "brokerHash", type: "bytes32" }, { internalType: "bytes32", name: "tokenHash", type: "bytes32" }, { internalType: "uint128", name: "tokenAmount", type: "uint128" }], internalType: "struct VaultTypes.VaultDepositFE", name: "data", type: "tuple" }], name: "deposit", outputs: [], stateMutability: "payable", type: "function" }, { inputs: [{ components: [{ internalType: "bytes32", name: "accountId", type: "bytes32" }, { internalType: "bytes32", name: "brokerHash", type: "bytes32" }, { internalType: "bytes32", name: "tokenHash", type: "bytes32" }, { internalType: "uint128", name: "tokenAmount", type: "uint128" }], internalType: "struct VaultTypes.VaultDepositFE", name: "data", type: "tuple" }], name: "deposit", outputs: [], stateMutability: "payable", type: "function" }, { inputs: [], name: "depositFeeEnabled", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [], name: "depositId", outputs: [{ internalType: "uint64", name: "", type: "uint64" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "receiver", type: "address" }, { components: [{ internalType: "bytes32", name: "accountId", type: "bytes32" }, { internalType: "bytes32", name: "brokerHash", type: "bytes32" }, { internalType: "bytes32", name: "tokenHash", type: "bytes32" }, { internalType: "uint128", name: "tokenAmount", type: "uint128" }], internalType: "struct VaultTypes.VaultDepositFE", name: "data", type: "tuple" }], name: "depositTo", outputs: [], stateMutability: "payable", type: "function" }, { inputs: [], name: "emergencyPause", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "emergencyUnpause", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "bool", name: "_enabled", type: "bool" }], name: "enableDepositFee", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "getAllAllowedBroker", outputs: [{ internalType: "bytes32[]", name: "", type: "bytes32[]" }], stateMutability: "view", type: "function" }, { inputs: [], name: "getAllAllowedToken", outputs: [{ internalType: "bytes32[]", name: "", type: "bytes32[]" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "_brokerHash", type: "bytes32" }], name: "getAllowedBroker", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "_tokenHash", type: "bytes32" }], name: "getAllowedToken", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "receiver", type: "address" }, { components: [{ internalType: "bytes32", name: "accountId", type: "bytes32" }, { internalType: "bytes32", name: "brokerHash", type: "bytes32" }, { internalType: "bytes32", name: "tokenHash", type: "bytes32" }, { internalType: "uint128", name: "tokenAmount", type: "uint128" }], internalType: "struct VaultTypes.VaultDepositFE", name: "data", type: "tuple" }], name: "getDepositFee", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [], name: "initialize", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "messageTransmitterContract", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [], name: "owner", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [], name: "paused", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [{ components: [{ internalType: "uint32", name: "dstDomain", type: "uint32" }, { internalType: "uint64", name: "rebalanceId", type: "uint64" }, { internalType: "uint128", name: "amount", type: "uint128" }, { internalType: "bytes32", name: "tokenHash", type: "bytes32" }, { internalType: "uint256", name: "burnChainId", type: "uint256" }, { internalType: "uint256", name: "mintChainId", type: "uint256" }, { internalType: "address", name: "dstVaultAddress", type: "address" }], internalType: "struct RebalanceTypes.RebalanceBurnCCData", name: "data", type: "tuple" }], name: "rebalanceBurn", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ components: [{ internalType: "uint64", name: "rebalanceId", type: "uint64" }, { internalType: "uint128", name: "amount", type: "uint128" }, { internalType: "bytes32", name: "tokenHash", type: "bytes32" }, { internalType: "uint256", name: "burnChainId", type: "uint256" }, { internalType: "uint256", name: "mintChainId", type: "uint256" }, { internalType: "bytes", name: "messageBytes", type: "bytes" }, { internalType: "bytes", name: "messageSignature", type: "bytes" }], internalType: "struct RebalanceTypes.RebalanceMintCCData", name: "data", type: "tuple" }], name: "rebalanceMint", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "renounceOwnership", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "bytes32", name: "_brokerHash", type: "bytes32" }, { internalType: "bool", name: "_allowed", type: "bool" }], name: "setAllowedBroker", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "bytes32", name: "_tokenHash", type: "bytes32" }, { internalType: "bool", name: "_allowed", type: "bool" }], name: "setAllowedToken", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_crossChainManagerAddress", type: "address" }], name: "setCrossChainManager", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_rebalanceMessengerContract", type: "address" }], name: "setRebalanceMessengerContract", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_tokenMessengerContract", type: "address" }], name: "setTokenMessengerContract", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "tokenMessengerContract", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "newOwner", type: "address" }], name: "transferOwnership", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ components: [{ internalType: "bytes32", name: "accountId", type: "bytes32" }, { internalType: "bytes32", name: "brokerHash", type: "bytes32" }, { internalType: "bytes32", name: "tokenHash", type: "bytes32" }, { internalType: "uint128", name: "tokenAmount", type: "uint128" }, { internalType: "uint128", name: "fee", type: "uint128" }, { internalType: "address", name: "sender", type: "address" }, { internalType: "address", name: "receiver", type: "address" }, { internalType: "uint64", name: "withdrawNonce", type: "uint64" }], internalType: "struct VaultTypes.VaultWithdraw", name: "data", type: "tuple" }], name: "withdraw", outputs: [], stateMutability: "nonpayable", type: "function" }];
var Ct$4 = [{ inputs: [{ internalType: "string", name: "name_", type: "string" }, { internalType: "string", name: "symbol_", type: "string" }, { internalType: "uint8", name: "decimals_", type: "uint8" }], stateMutability: "nonpayable", type: "constructor" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "owner", type: "address" }, { indexed: true, internalType: "address", name: "spender", type: "address" }, { indexed: false, internalType: "uint256", name: "value", type: "uint256" }], name: "Approval", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "from", type: "address" }, { indexed: true, internalType: "address", name: "to", type: "address" }, { indexed: false, internalType: "uint256", name: "value", type: "uint256" }], name: "Transfer", type: "event" }, { inputs: [{ internalType: "address", name: "owner", type: "address" }, { internalType: "address", name: "spender", type: "address" }], name: "allowance", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "spender", type: "address" }, { internalType: "uint256", name: "amount", type: "uint256" }], name: "approve", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "account", type: "address" }], name: "balanceOf", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [], name: "decimals", outputs: [{ internalType: "uint8", name: "", type: "uint8" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "spender", type: "address" }, { internalType: "uint256", name: "subtractedValue", type: "uint256" }], name: "decreaseAllowance", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "spender", type: "address" }, { internalType: "uint256", name: "addedValue", type: "uint256" }], name: "increaseAllowance", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "uint256", name: "amount", type: "uint256" }], name: "issue", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_to", type: "address" }, { internalType: "uint256", name: "_amount", type: "uint256" }], name: "mint", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "name", outputs: [{ internalType: "string", name: "", type: "string" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bool", name: "_paused", type: "bool" }], name: "pauseTransfers", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "symbol", outputs: [{ internalType: "string", name: "", type: "string" }], stateMutability: "view", type: "function" }, { inputs: [], name: "totalSupply", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "recipient", type: "address" }, { internalType: "uint256", name: "amount", type: "uint256" }], name: "transfer", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "sender", type: "address" }, { internalType: "address", name: "recipient", type: "address" }, { internalType: "uint256", name: "amount", type: "uint256" }], name: "transferFrom", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "nonpayable", type: "function" }];
var rr$3 = [{ inputs: [], stateMutability: "nonpayable", type: "constructor" }, { inputs: [], name: "AccountIdInvalid", type: "error" }, { inputs: [], name: "AddressZero", type: "error" }, { inputs: [{ internalType: "uint256", name: "balance", type: "uint256" }, { internalType: "uint128", name: "amount", type: "uint128" }], name: "BalanceNotEnough", type: "error" }, { inputs: [], name: "BrokerNotAllowed", type: "error" }, { inputs: [], name: "EnumerableSetError", type: "error" }, { inputs: [], name: "OnlyCrossChainManagerCanCall", type: "error" }, { inputs: [], name: "TokenNotAllowed", type: "error" }, { inputs: [], name: "ZeroDepositFee", type: "error" }, { anonymous: false, inputs: [{ indexed: true, internalType: "bytes32", name: "accountId", type: "bytes32" }, { indexed: true, internalType: "address", name: "userAddress", type: "address" }, { indexed: true, internalType: "uint64", name: "depositNonce", type: "uint64" }, { indexed: false, internalType: "bytes32", name: "tokenHash", type: "bytes32" }, { indexed: false, internalType: "uint128", name: "tokenAmount", type: "uint128" }], name: "AccountDeposit", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "bytes32", name: "accountId", type: "bytes32" }, { indexed: true, internalType: "address", name: "userAddress", type: "address" }, { indexed: true, internalType: "uint64", name: "depositNonce", type: "uint64" }, { indexed: false, internalType: "bytes32", name: "tokenHash", type: "bytes32" }, { indexed: false, internalType: "uint128", name: "tokenAmount", type: "uint128" }], name: "AccountDepositTo", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "bytes32", name: "accountId", type: "bytes32" }, { indexed: true, internalType: "uint64", name: "withdrawNonce", type: "uint64" }, { indexed: false, internalType: "bytes32", name: "brokerHash", type: "bytes32" }, { indexed: false, internalType: "address", name: "sender", type: "address" }, { indexed: false, internalType: "address", name: "receiver", type: "address" }, { indexed: false, internalType: "bytes32", name: "tokenHash", type: "bytes32" }, { indexed: false, internalType: "uint128", name: "tokenAmount", type: "uint128" }, { indexed: false, internalType: "uint128", name: "fee", type: "uint128" }], name: "AccountWithdraw", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "address", name: "oldAddress", type: "address" }, { indexed: false, internalType: "address", name: "newAddress", type: "address" }], name: "ChangeCrossChainManager", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "bytes32", name: "_tokenHash", type: "bytes32" }, { indexed: false, internalType: "address", name: "_tokenAddress", type: "address" }], name: "ChangeTokenAddressAndAllow", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "uint8", name: "version", type: "uint8" }], name: "Initialized", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "previousOwner", type: "address" }, { indexed: true, internalType: "address", name: "newOwner", type: "address" }], name: "OwnershipTransferred", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "address", name: "account", type: "address" }], name: "Paused", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "bytes32", name: "_brokerHash", type: "bytes32" }, { indexed: false, internalType: "bool", name: "_allowed", type: "bool" }], name: "SetAllowedBroker", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "bytes32", name: "_tokenHash", type: "bytes32" }, { indexed: false, internalType: "bool", name: "_allowed", type: "bool" }], name: "SetAllowedToken", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "address", name: "account", type: "address" }], name: "Unpaused", type: "event" }, { inputs: [{ internalType: "bytes32", name: "", type: "bytes32" }], name: "allowedToken", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "_tokenHash", type: "bytes32" }, { internalType: "address", name: "_tokenAddress", type: "address" }], name: "changeTokenAddressAndAllow", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "crossChainManagerAddress", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ components: [{ internalType: "bytes32", name: "accountId", type: "bytes32" }, { internalType: "bytes32", name: "brokerHash", type: "bytes32" }, { internalType: "bytes32", name: "tokenHash", type: "bytes32" }, { internalType: "uint128", name: "tokenAmount", type: "uint128" }], internalType: "struct VaultTypes.VaultDepositFE", name: "data", type: "tuple" }], name: "deposit", outputs: [], stateMutability: "payable", type: "function" }, { inputs: [], name: "depositFeeEnabled", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [], name: "depositId", outputs: [{ internalType: "uint64", name: "", type: "uint64" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "receiver", type: "address" }, { components: [{ internalType: "bytes32", name: "accountId", type: "bytes32" }, { internalType: "bytes32", name: "brokerHash", type: "bytes32" }, { internalType: "bytes32", name: "tokenHash", type: "bytes32" }, { internalType: "uint128", name: "tokenAmount", type: "uint128" }], internalType: "struct VaultTypes.VaultDepositFE", name: "data", type: "tuple" }], name: "depositTo", outputs: [], stateMutability: "payable", type: "function" }, { inputs: [], name: "emergencyPause", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "emergencyUnpause", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "bool", name: "_enabled", type: "bool" }], name: "enableDepositFee", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "getAllAllowedBroker", outputs: [{ internalType: "bytes32[]", name: "", type: "bytes32[]" }], stateMutability: "view", type: "function" }, { inputs: [], name: "getAllAllowedToken", outputs: [{ internalType: "bytes32[]", name: "", type: "bytes32[]" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "_brokerHash", type: "bytes32" }], name: "getAllowedBroker", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "_tokenHash", type: "bytes32" }], name: "getAllowedToken", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "receiver", type: "address" }, { components: [{ internalType: "bytes32", name: "accountId", type: "bytes32" }, { internalType: "bytes32", name: "brokerHash", type: "bytes32" }, { internalType: "bytes32", name: "tokenHash", type: "bytes32" }, { internalType: "uint128", name: "tokenAmount", type: "uint128" }], internalType: "struct VaultTypes.VaultDepositFE", name: "data", type: "tuple" }], name: "getDepositFee", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [], name: "initialize", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "messageTransmitterContract", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [], name: "owner", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [], name: "paused", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [{ components: [{ internalType: "uint32", name: "dstDomain", type: "uint32" }, { internalType: "uint64", name: "rebalanceId", type: "uint64" }, { internalType: "uint128", name: "amount", type: "uint128" }, { internalType: "bytes32", name: "tokenHash", type: "bytes32" }, { internalType: "uint256", name: "burnChainId", type: "uint256" }, { internalType: "uint256", name: "mintChainId", type: "uint256" }, { internalType: "address", name: "dstVaultAddress", type: "address" }], internalType: "struct RebalanceTypes.RebalanceBurnCCData", name: "data", type: "tuple" }], name: "rebalanceBurn", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ components: [{ internalType: "uint64", name: "rebalanceId", type: "uint64" }, { internalType: "uint128", name: "amount", type: "uint128" }, { internalType: "bytes32", name: "tokenHash", type: "bytes32" }, { internalType: "uint256", name: "burnChainId", type: "uint256" }, { internalType: "uint256", name: "mintChainId", type: "uint256" }, { internalType: "bytes", name: "messageBytes", type: "bytes" }, { internalType: "bytes", name: "messageSignature", type: "bytes" }], internalType: "struct RebalanceTypes.RebalanceMintCCData", name: "data", type: "tuple" }], name: "rebalanceMint", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "renounceOwnership", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "bytes32", name: "_brokerHash", type: "bytes32" }, { internalType: "bool", name: "_allowed", type: "bool" }], name: "setAllowedBroker", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "bytes32", name: "_tokenHash", type: "bytes32" }, { internalType: "bool", name: "_allowed", type: "bool" }], name: "setAllowedToken", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_crossChainManagerAddress", type: "address" }], name: "setCrossChainManager", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_rebalanceMessengerContract", type: "address" }], name: "setRebalanceMessengerContract", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_tokenMessengerContract", type: "address" }], name: "setTokenMessengerContract", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "tokenMessengerContract", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "newOwner", type: "address" }], name: "transferOwnership", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ components: [{ internalType: "bytes32", name: "accountId", type: "bytes32" }, { internalType: "bytes32", name: "brokerHash", type: "bytes32" }, { internalType: "bytes32", name: "tokenHash", type: "bytes32" }, { internalType: "uint128", name: "tokenAmount", type: "uint128" }, { internalType: "uint128", name: "fee", type: "uint128" }, { internalType: "address", name: "sender", type: "address" }, { internalType: "address", name: "receiver", type: "address" }, { internalType: "uint64", name: "withdrawNonce", type: "uint64" }], internalType: "struct VaultTypes.VaultWithdraw", name: "data", type: "tuple" }], name: "withdraw", outputs: [], stateMutability: "nonpayable", type: "function" }];
var Me$7 = class Me {
  constructor(e2) {
    this.configStore = e2;
  }
  getContractInfoByEnv() {
    let e2 = this.configStore.get("networkId"), t = this.configStore.get("env"), r3 = Dn$1;
    if (e2 === "mainnet") return { usdcAddress: Pn$2, usdcAbi: Et$4, vaultAddress: Kn$1, vaultAbi: nr$2, verifyContractAddress: Vn$1, erc20Abi: Et$4, solanaUSDCAddress: zn$2, solanaVaultAddress: Hn$1, abstractVaultAddress: tr$3, abstractUSDCAddress: Yn };
    let a2 = Ln$1, s2 = Xn$3, i = qn, o2 = jn$3, u2 = er$2, l2 = Zn$1;
    return t === "qa" ? (a2 = Wn$5, r3 = "0x50F59504D3623Ad99302835da367676d1f7E3D44", s2 = "0xFeA61647309cA4624EfF3c86EEEeb76a6F3eaFf7", i = Jn$1, u2 = Qn$1) : t === "dev" && (u2 = $n$1, r3 = "0x8794E7260517B1766fc7b55cAfcd56e6bf08600e"), { usdcAddress: Fn$1, usdcAbi: Ct$4, vaultAddress: On$1, solanaVaultAddress: a2, solanaUSDCAddress: Gn$3, vaultAbi: rr$3, verifyContractAddress: r3, erc20Abi: Ct$4, storyTestnetVaultAddress: s2, monadTestnetVaultAddress: i, monadTestnetUSDCAddress: o2, abstractUSDCAddress: l2, abstractVaultAddress: u2 };
  }
};
y$3();
y$3();
var It$4 = class It {
  constructor(e2 = [], t = {}) {
    this.providers = e2;
    this.services = t;
    this.injectProperties = {};
  }
  register(...e2) {
    this.providers.push(...e2), e2.forEach((t) => {
      let r3 = t;
      r3 instanceof Function && (r3 = new t()), this.add(r3);
    });
  }
  registerByName(e2, t) {
    let r3 = t;
    r3 instanceof Function && (r3 = new t()), this.addByName(e2, r3);
  }
  get(e2) {
    return this.services[e2];
  }
  getAll() {
    return Object.assign({}, this.services);
  }
  add(e2) {
    return this.addByName(e2.constructor.name, e2);
  }
  addByName(e2, t) {
    return this.services[e2] = t, this.services[e2.toLowerCase()] = t, this.injectIntoProperties(t, e2), this.get(e2);
  }
  inject(e2, t, r3) {
    e2 && r3 && (e2[t] = r3);
  }
  injectIntoProperties(e2, t = e2.constructor.name) {
    this.getInjectProperty(t.toLowerCase()).forEach((r3) => {
      this.inject(r3.target, r3.propertyKey, e2);
    });
  }
  getInjectProperty(e2) {
    return this.injectProperties[e2] || (this.injectProperties[e2] = []), this.injectProperties[e2];
  }
}, ar$1 = It$4;
var F$5 = class F {
  static getContainer() {
    return F.container || (Se$7()[F.KEY] = F.container = new ar$1()), F.container;
  }
  static register(...e2) {
    F.getContainer().register(...e2);
  }
  static registerByName(e2, t) {
    F.getContainer().registerByName(e2, t);
  }
  static get(e2) {
    return F.getContainer().get(e2);
  }
  static getOr(e2, t) {
    return F.getContainer().get(e2) || F.registerByName(e2, t), t;
  }
  static getAll() {
    return F.getContainer().getAll();
  }
  constructor() {
  }
};
F$5.KEY = "__ORDERLY_CONTAINER__", F$5.container = Se$7()[F$5.KEY] || null;
var ke$5 = F$5, Ia$1 = ke$5;
y$3();
y$3();
var We$9 = class We {
  constructor(e2) {
    this.repository = e2;
  }
  save(e2, t) {
    this.repository.save(e2, t);
  }
  getAll(e2) {
    return this.repository.getAll(e2);
  }
  get(e2, t) {
    return this.repository.get(e2, t);
  }
  clear(e2) {
    this.repository.clear(e2);
  }
};
y$3();
var Xe$5 = class Xe {
  constructor(e2, t, r3) {
    this.configStore = e2;
    this.contractManger = t;
    this.account = r3;
  }
  async withdraw(e2) {
    var _a3;
    if (!this.account.walletAdapter) throw new Error("walletAdapter is undefined");
    if (!this.account.stateValue.address) throw new Error("account address is required");
    let { chainId: t, token: r3, allowCrossChainWithdraw: a2 } = e2, { amount: s2 } = e2;
    typeof s2 == "number" && (s2 = s2.toString());
    let i = "/v1/withdraw_request", o2 = await this.getWithdrawalNonce(), u2 = I$7(), l2 = { receiver: this.account.stateValue.address, token: r3, brokerId: this.configStore.get("brokerId"), amount: this.account.walletAdapter.parseUnits(s2), nonce: o2, timestamp: u2, verifyContract: this.contractManger.getContractInfoByEnv().verifyContractAddress }, c = ((_a3 = this.account.getAdditionalInfo()) == null ? void 0 : _a3.AGWAddress) ?? "";
    ABSTRACT_CHAIN_ID_MAP.has(t) && c && (l2.receiver = c);
    let { message: d2, signatured: b2, domain: f2 } = await this.account.walletAdapter.generateWithdrawMessage(l2), A2 = { signature: b2, message: d2, userAddress: this.account.stateValue.address, verifyingContract: f2.verifyingContract }, S2 = { method: "POST", url: i, data: A2 };
    a2 && (A2.message = { ...A2.message, allowCrossChainWithdraw: a2 });
    let E3 = await this.account.signer.sign(S2, I$7()), C2 = await this._simpleFetch(i, { method: "POST", body: JSON.stringify(A2), headers: { "Content-Type": "application/json", "orderly-account-id": this.account.stateValue.accountId, ...E3 } });
    if (!C2.success) throw new ApiError2(C2.message, C2.code);
    return C2;
  }
  async getWithdrawalNonce() {
    var _a3;
    let e2 = I$7().toString(), t = "/v1/withdraw_nonce", r3 = [e2, "GET", t].join(""), a2 = this.account.signer, { publicKey: s2, signature: i } = await a2.signText(r3), o2 = await this._simpleFetch(t, { headers: { "orderly-account-id": this.account.stateValue.accountId, "orderly-key": s2, "orderly-timestamp": e2, "orderly-signature": i } });
    if (o2.success) return (_a3 = o2.data) == null ? void 0 : _a3.withdraw_nonce;
    throw new Error(o2.message);
  }
  async getNativeBalance(e2) {
    if (!this.account.walletAdapter) return "0";
    let t = await this.account.walletAdapter.getBalance();
    return Le$6(t, e2 == null ? void 0 : e2.decimals);
  }
  async getBalance(e2, t) {
    var _a3, _b2, _c2;
    if (!this.account.walletAdapter) return "0";
    let r3 = this.contractManger.getContractInfoByEnv(), a2 = e2 ?? r3.usdcAddress, s2 = this.account.stateValue.address;
    ABSTRACT_CHAIN_ID_MAP.has(this.account.walletAdapter.chainId) && (a2 = r3.abstractUSDCAddress ?? "");
    let i = ((_a3 = this.account.getAdditionalInfo()) == null ? void 0 : _a3.AGWAddress) ?? "";
    ABSTRACT_CHAIN_ID_MAP.has(this.account.walletAdapter.chainId) && i && (s2 = i);
    let o2 = await ((_b2 = this.account.walletAdapter) == null ? void 0 : _b2.call(a2, "balanceOf", [s2], { abi: r3.usdcAbi }));
    return (_c2 = this.account.walletAdapter) == null ? void 0 : _c2.formatUnits(o2, t == null ? void 0 : t.decimals);
  }
  async getBalanceByAddress(e2, t) {
    var _a3;
    if (!this.account.walletAdapter) return "0";
    let r3 = this.contractManger.getContractInfoByEnv(), a2 = await ((_a3 = this.account.walletAdapter) == null ? void 0 : _a3.call(e2, "balanceOf", [this.account.stateValue.address], { abi: r3.erc20Abi }));
    return Le$6(a2, t == null ? void 0 : t.decimals);
  }
  async getAllowance(e2, t) {
    var _a3, _b2, _c2;
    let { address: r3, vaultAddress: a2, decimals: s2 } = typeof e2 == "object" ? e2 : { address: e2, vaultAddress: t, decimals: void 0 };
    if (!this.account.walletAdapter) return "0";
    let i = this.account.stateValue.address, o2 = this.contractManger.getContractInfoByEnv(), u2 = a2 ?? o2.vaultAddress, l2 = r3;
    this.account.walletAdapter.chainId === STORY_TESTNET_CHAINID && (u2 = o2.storyTestnetVaultAddress ?? ""), this.account.walletAdapter.chainId === MONAD_TESTNET_CHAINID && (u2 = o2.monadTestnetVaultAddress ?? "", l2 = o2.monadTestnetUSDCAddress), ABSTRACT_CHAIN_ID_MAP.has(this.account.walletAdapter.chainId) && (u2 = o2.abstractVaultAddress ?? "", l2 = o2.abstractUSDCAddress ?? "");
    let c = ((_a3 = this.account.getAdditionalInfo()) == null ? void 0 : _a3.AGWAddress) ?? "";
    ABSTRACT_CHAIN_ID_MAP.has(this.account.walletAdapter.chainId) && c && (i = c);
    let d2 = await ((_b2 = this.account.walletAdapter) == null ? void 0 : _b2.call(l2 ?? "", "allowance", [i, u2], { abi: o2.usdcAbi }));
    return (_c2 = this.account.walletAdapter) == null ? void 0 : _c2.formatUnits(d2, s2);
  }
  async approve(e2, t, r3) {
    var _a3;
    let { address: a2, amount: s2, vaultAddress: i, decimals: o2 } = typeof e2 == "object" ? e2 : { address: e2, amount: t, vaultAddress: r3, decimals: void 0 };
    if (!a2) throw new Error("address is required");
    if (!this.account.walletAdapter) throw new Error("walletAdapter is undefined");
    let u2 = this.contractManger.getContractInfoByEnv(), l2 = typeof s2 < "u" && s2 !== "" ? this.account.walletAdapter.parseUnits(s2, o2) : MaxUint256.toString(), c = i || u2.vaultAddress, d2 = a2;
    return this.account.walletAdapter.chainId === STORY_TESTNET_CHAINID && (c = u2.storyTestnetVaultAddress ?? ""), this.account.walletAdapter.chainId === MONAD_TESTNET_CHAINID && (c = u2.monadTestnetVaultAddress ?? "", d2 = u2.monadTestnetUSDCAddress ?? ""), ABSTRACT_CHAIN_ID_MAP.has(this.account.walletAdapter.chainId) && (c = u2.abstractVaultAddress ?? ""), await ((_a3 = this.account.walletAdapter) == null ? void 0 : _a3.call(d2, "approve", [c, l2], { abi: u2.usdcAbi }));
  }
  async approveByAddress(e2) {
    var _a3;
    let { address: t, amount: r3, decimals: a2 } = e2;
    if (!this.account.walletAdapter) throw new Error("walletAdapter is undefined");
    let s2 = typeof r3 < "u" && r3 !== "" ? this.account.walletAdapter.parseUnits(r3, a2) : MaxUint256.toString(), i = this.contractManger.getContractInfoByEnv();
    return await ((_a3 = this.account.walletAdapter) == null ? void 0 : _a3.call(t, "approve", [i.vaultAddress, s2], { abi: i.erc20Abi }));
  }
  async getDepositFee(e2, t) {
    var _a3;
    if (!this.account.walletAdapter) throw new Error("walletAdapter is undefined");
    let r3 = this.configStore.get("brokerId");
    if (!r3) throw new Error("[Assets]:brokerId is required");
    let a2 = { accountId: this.account.accountIdHashStr, brokerHash: pe$5(r3), tokenHash: He$6("USDC"), tokenAmount: (_a3 = this.account.walletAdapter) == null ? void 0 : _a3.parseUnits(e2) }, s2 = this.contractManger.getContractInfoByEnv(), i = this.account.stateValue.address, o2 = s2.vaultAddress;
    return this.account.walletAdapter.chainNamespace === ChainNamespace.solana && (o2 = s2.solanaVaultAddress, a2.USDCAddress = s2.solanaUSDCAddress), t.chain_id === STORY_TESTNET_CHAINID && (o2 = s2.storyTestnetVaultAddress ?? ""), t.chain_id === MONAD_TESTNET_CHAINID && (o2 = s2.monadTestnetVaultAddress ?? ""), ABSTRACT_CHAIN_ID_MAP.has(this.account.walletAdapter.chainId) && (o2 = s2.abstractVaultAddress ?? ""), console.log("xxx get deposit fee", { userAddress: i, vaultAddress: o2, depositData: a2 }), await this.account.walletAdapter.callOnChain(t, o2, "getDepositFee", [i, a2], { abi: s2.vaultAbi });
  }
  async deposit(e2, t = 0n) {
    var _a3, _b2, _c2;
    if (!this.account.walletAdapter) throw new Error("walletAdapter is undefined");
    let r3 = this.configStore.get("brokerId");
    if (!r3) throw new Error("[Assets]:brokerId is required");
    let a2 = this.contractManger.getContractInfoByEnv(), s2 = { accountId: this.account.accountIdHashStr, brokerHash: pe$5(r3), tokenHash: He$6("USDC"), tokenAmount: (_a3 = this.account.walletAdapter) == null ? void 0 : _a3.parseUnits(e2) }, i = a2.vaultAddress, o2 = this.account.stateValue.address;
    this.account.walletAdapter.chainNamespace === ChainNamespace.solana && (i = a2.solanaVaultAddress, s2.USDCAddress = a2.solanaUSDCAddress), this.account.walletAdapter.chainId === STORY_TESTNET_CHAINID && (i = a2.storyTestnetVaultAddress ?? ""), this.account.walletAdapter.chainId === MONAD_TESTNET_CHAINID && (i = a2.monadTestnetVaultAddress ?? ""), ABSTRACT_CHAIN_ID_MAP.has(this.account.walletAdapter.chainId) && (i = a2.abstractVaultAddress ?? "");
    let u2 = ((_b2 = this.account.getAdditionalInfo()) == null ? void 0 : _b2.AGWAddress) ?? "", l2 = "deposit", c = o2, d2 = [s2];
    return console.log("agw address", u2, this.account.walletAdapter.chainId), ABSTRACT_CHAIN_ID_MAP.has(this.account.walletAdapter.chainId) && u2 && (l2 = "depositTo", c = u2, d2 = [o2, s2]), console.log("xxx deposit", { fromAddress: c, contractMethod: l2, contractData: d2 }), await ((_c2 = this.account.walletAdapter) == null ? void 0 : _c2.sendTransaction(i, l2, { from: c, to: i, data: d2, value: t }, { abi: a2.vaultAbi }));
  }
  async _simpleFetch(e2, t = {}) {
    let r3 = `${this.configStore.get("apiBaseUrl")}${e2}`;
    return fetch(r3, t).then((a2) => a2.json());
  }
  get usdcAddress() {
    return this.contractManger.getContractInfoByEnv().usdcAddress;
  }
};
y$3();
var qe$7 = class qe {
  constructor(e2) {
    this.name = e2;
  }
  save(e2, t) {
    this.run(() => {
      let r3 = this.getAll(e2);
      r3 = { [e2]: { ...r3, ...t } }, localStorage.setItem(this.name, JSON.stringify(r3));
    });
  }
  get(e2, t) {
    let r3 = this.getAll(e2);
    return r3 ? r3[t] : null;
  }
  getAll(e2) {
    try {
      let t = localStorage.getItem(this.name);
      return t ? JSON.parse(t)[e2] : null;
    } catch (t) {
      return console.error(t), null;
    }
  }
  clear(e2) {
    this.run(() => {
      let t = this.getAll(e2);
      t && (delete t[e2], localStorage.setItem(this.name, JSON.stringify(t)));
    });
  }
  update(e2, t, r3) {
    this.run(() => {
      let a2 = this.getAll(e2);
      a2[t] = r3, localStorage.setItem(this.name, JSON.stringify(a2));
    });
  }
  run(e2) {
    typeof window < "u" && typeof localStorage < "u" && e2();
  }
};
y$3();
var je$6 = class je {
  constructor(e2) {
    this.walletAdapters = e2;
    if (!this.walletAdapters.length) throw new Error("No wallet adapters provided");
  }
  get adapter() {
    return this._adapter;
  }
  get isEmpty() {
    return this.walletAdapters.length === 0;
  }
  get isAdapterExist() {
    return !!this._adapter;
  }
  switchWallet(e2, t, r3, a2) {
    console.log("-- this.walletAdapters", this.walletAdapters, e2);
    let s2 = this.walletAdapters.find((o2) => o2.chainNamespace === e2.toUpperCase());
    if (!s2) throw new Error("Unsupported chain namespace");
    let i = { address: t, chain: { id: r3 }, provider: a2.provider, contractManager: a2.contractManager };
    if (console.log("------+++++---", i), this._adapter) if (this._adapter === s2) {
      this._adapter.update(i);
      return;
    } else this._adapter.deactivate();
    this._adapter = s2, this._adapter.active(i);
  }
  get chainId() {
    var _a3;
    return (_a3 = this.adapter) == null ? void 0 : _a3.chainId;
  }
};
var Ne$4 = class Ne {
  constructor(e2, t, r3, a2) {
    this.configStore = e2;
    this.keyStore = t;
    this._ee = new Na();
    this._state = { status: AccountStatusEnum.NotConnected, validating: false, isNew: false };
    (a2 == null ? void 0 : a2.contracts) ? this.contractManger = a2.contracts : this.contractManger = new Me$7(e2), this.assetsManager = new Xe$5(e2, this.contractManger, this), this.walletAdapterManager = new je$6(r3), this.additionalInfoRepository = new We$9(new qe$7(Ne.additionalInfoRepositoryName)), this._bindEvents();
  }
  logout() {
  }
  async setAddress(e2, t) {
    var _a3, _b2;
    if (!e2) throw new SDKError("Address is required");
    if (!t) throw new SDKError("Wallet is required");
    if (!((_a3 = t == null ? void 0 : t.chain) == null ? void 0 : _a3.id)) throw new SDKError("Chain id is required");
    if (this.stateValue.address === e2) return console.warn("address parameter is the same as the current address, if you want to change chain, please use `switchChain` method."), this.stateValue.status;
    this.stateValue.status > AccountStatusEnum.NotConnected && this._ee.emit(_$4.switchAccount, e2), t.chain.id = this.parseChainId((_b2 = t == null ? void 0 : t.chain) == null ? void 0 : _b2.id), this.keyStore.setAddress(e2), this.saveAdditionalInfo(e2, t);
    let r3 = { ...this.stateValue, status: AccountStatusEnum.Connected, address: e2, chainNamespace: t.chain.namespace, accountId: void 0, connectWallet: { name: t.wallet.name || "unknown", chainId: t.chain.id }, validating: true };
    this._ee.emit(_$4.statusChanged, r3), this.walletAdapterManager.switchWallet(t.chain.namespace, e2, t.chain.id, { provider: t.provider, contractManager: this.contractManger }), this.configStore.set("chainNamespace", t.chain.namespace), this._ee.emit(_$4.validateStart);
    let a2 = await this._checkAccount(e2);
    return this._ee.emit(_$4.validateEnd, a2), a2;
  }
  saveAdditionalInfo(e2, t) {
    typeof t.additionalInfo < "u" && (typeof t.additionalInfo != "object" ? console.warn("`wallet.additionalInfo` is not an object") : this.additionalInfoRepository.save(e2, t.additionalInfo));
  }
  get stateValue() {
    return this._state;
  }
  get accountId() {
    return this.stateValue.accountId;
  }
  get accountIdHashStr() {
    var _a3;
    if (!this.address) throw new Error("address is error");
    let e2 = this.configStore.get("brokerId");
    if (((_a3 = this.walletAdapter) == null ? void 0 : _a3.chainNamespace) === ChainNamespace.solana) {
      let t = new PublicKey(this.address), r3 = T$2.Buffer.from(t.toBytes()), a2 = AbiCoder.defaultAbiCoder();
      return keccak256(a2.encode(["bytes32", "bytes32"], [r3, pe$5(e2)]));
    }
    return Tt$3(this.address, e2);
  }
  get address() {
    return this.stateValue.address;
  }
  get chainId() {
    if (this.walletAdapterManager.isAdapterExist) return this.walletAdapterManager.chainId;
  }
  get apiBaseUrl() {
    return this.configStore.get("apiBaseUrl");
  }
  _bindEvents() {
    this._ee.addListener(_$4.statusChanged, (e2) => {
      this._state = e2;
    });
  }
  async _checkAccount(e2) {
    let t;
    try {
      let r3 = await this._checkAccountExist(e2);
      if (r3 && r3.account_id) this.keyStore.setAccountId(e2, r3.account_id), t = { ...this.stateValue, status: AccountStatusEnum.SignedIn, accountId: r3.account_id, userId: r3.user_id }, this._ee.emit(_$4.statusChanged, t);
      else return t = { ...this.stateValue, validating: false, status: AccountStatusEnum.NotSignedIn }, this._ee.emit(_$4.statusChanged, t), AccountStatusEnum.NotSignedIn;
      let a2 = this.keyStore.getOrderlyKey();
      if (!a2) return this._ee.emit(_$4.statusChanged, { ...this.stateValue, isNew: false, validating: false, status: AccountStatusEnum.DisabledTrading }), AccountStatusEnum.DisabledTrading;
      let s2 = await a2.getPublicKey(), i = await this._checkOrderlyKeyState(r3.account_id, s2);
      if (i && i.orderly_key && i.key_status === "ACTIVE") {
        let o2 = I$7(), u2 = i.expiration;
        return o2 > u2 ? (this._ee.emit(_$4.statusChanged, { ...this.stateValue, validating: false }), this.keyStore.cleanKey(e2, "orderlyKey"), AccountStatusEnum.DisabledTrading) : (this._ee.emit(_$4.statusChanged, { ...this.stateValue, validating: false, status: AccountStatusEnum.EnableTrading }), AccountStatusEnum.EnableTrading);
      }
      return this._ee.emit(_$4.statusChanged, { ...this.stateValue, validating: false }), this.keyStore.cleanKey(e2, "orderlyKey"), AccountStatusEnum.NotConnected;
    } catch {
      this._ee.emit(_$4.statusChanged, { ...this.stateValue, validating: false });
    }
    return AccountStatusEnum.NotSignedIn;
  }
  async _checkAccountExist(e2, t) {
    let r3 = await this._getAccountInfo(e2, t);
    return r3.success ? r3.data : null;
  }
  async createAccount() {
    let { nonce: e2, timestamp: t } = await this._getRegisterationNonce(), r3 = this.stateValue.address;
    if (!r3) throw new Error("address is undefined");
    let { message: a2, signatured: s2 } = await this.walletAdapterManager.adapter.generateRegisterAccountMessage({ registrationNonce: e2, brokerId: this.configStore.get("brokerId"), timestamp: t }), i = await this._simpleFetch("/v1/register_account", { method: "POST", body: JSON.stringify({ signature: s2, message: a2, userAddress: r3 }), headers: { "Content-Type": "application/json" } });
    if (i.success) {
      this.keyStore.setAccountId(r3, i.data.account_id);
      let o2 = { ...this.stateValue, status: AccountStatusEnum.DisabledTrading, accountId: i.data.account_id, userId: i.data.user_id, isNew: true };
      return this._ee.emit(_$4.statusChanged, o2), i;
    } else throw new Error(i.message);
  }
  async createApiKey(e2, t) {
    var _a3;
    try {
      let { res: r3, keyPair: a2 } = await this.generateApiKey(e2, t);
      if (r3.success) return { key: (await a2.getPublicKey()).replace("ed25519:", ""), secretKey: (_a3 = a2.secretKey) == null ? void 0 : _a3.replace("ed25519:", "") };
    } catch (r3) {
      throw console.log("createApiKey error", r3), `${r3}`.includes("user rejected action") ? new Error("User rejected the request.") : r3;
    }
    throw new Error("create api key failed");
  }
  async createOrderlyKey(e2, t) {
    let { res: r3, address: a2, keyPair: s2 } = await this.generateApiKey(e2, t);
    if (r3.success) {
      this.keyStore.setKey(a2, s2);
      let i = { ...this.stateValue, status: AccountStatusEnum.EnableTrading };
      return this._ee.emit(_$4.statusChanged, i), r3;
    } else throw new Error(r3.message);
  }
  async generateApiKey(e2, t) {
    if (this.stateValue.accountId === void 0) throw new Error("account id is undefined");
    if (!this.walletAdapter) throw new Error("walletAdapter is undefined");
    if (!this.walletAdapterManager.isAdapterExist) throw new Error("wallet adapter is not exist");
    if (typeof e2 != "number") throw new Error("the 'expiration' must be valid number");
    let r3 = this.walletAdapter.generateSecretKey(), a2 = new H$2(r3), s2 = await a2.getPublicKey(), i = this.stateValue.address;
    if (!i) throw new Error("address is undefined");
    let { message: o2, signatured: u2 } = await this.walletAdapter.generateAddOrderlyKeyMessage({ brokerId: this.configStore.get("brokerId"), publicKey: s2, expiration: e2, timestamp: I$7(), scope: t == null ? void 0 : t.scope, tag: t == null ? void 0 : t.tag });
    return console.log("generateAPiKey", s2, i), { res: await this._simpleFetch("/v1/orderly_key", { method: "POST", body: JSON.stringify({ signature: u2, message: o2, userAddress: i }), headers: { "X-Account-Id": this.stateValue.accountId, "Content-Type": "application/json" } }), address: i, keyPair: a2 };
  }
  async importOrderlyKey(e2) {
    var _a3;
    let { address: t, secretKey: r3, chainNamespace: a2 } = e2;
    if (!t || !r3 || !a2) return;
    let i = (_a3 = await this._checkAccountExist(t, a2)) == null ? void 0 : _a3.account_id;
    if (!i) return;
    let o2 = new H$2(r3), u2 = await this.checkOrderlyKey(t, o2, i);
    return u2 && this.configStore.set("chainNamespace", a2), u2;
  }
  async checkOrderlyKey(e2, t, r3) {
    if (!e2 || !t || !r3) return;
    let a2 = await t.getPublicKey(), s2 = await this._checkOrderlyKeyState(r3, a2), { orderly_key: i, key_status: o2, expiration: u2 } = s2 || {}, l2 = I$7();
    if (i && o2 === "ACTIVE" && u2 > l2) {
      this.keyStore.setAddress(e2), this.keyStore.setKey(e2, t), this.keyStore.setAccountId(e2, r3);
      let c = { ...this.stateValue, address: e2, accountId: r3, status: AccountStatusEnum.EnableTradingWithoutConnected };
      return this._ee.emit(_$4.statusChanged, c), true;
    }
  }
  async settle() {
    if (!this.walletAdapter) return Promise.reject("walletAdapter is undefined");
    let e2 = await this._getSettleNonce(), t = this.stateValue.address, r3 = "/v1/settle_pnl", a2 = I$7(), { message: s2, signatured: i, domain: o2 } = await this.walletAdapter.generateSettleMessage({ settlePnlNonce: e2, timestamp: a2, brokerId: this.configStore.get("brokerId"), verifyContract: this.contractManger.getContractInfoByEnv().verifyContractAddress }), u2 = { signature: i, message: s2, userAddress: t, verifyingContract: o2.verifyingContract }, l2 = { method: "POST", url: r3, data: u2 }, c = await this.signer.sign(l2, I$7()), d2 = await this._simpleFetch(r3, { method: "POST", body: JSON.stringify(u2), headers: { "Content-Type": "application/json", "orderly-account-id": this.stateValue.accountId, ...c } });
    return d2.success ? Promise.resolve(d2) : Promise.reject(d2);
  }
  async destroyOrderlyKey() {
    this.stateValue.address && this.keyStore.cleanKey(this.stateValue.address, "orderlyKey");
    let e2 = { ...this.stateValue, status: AccountStatusEnum.DisabledTrading };
    this._ee.emit(_$4.statusChanged, e2);
  }
  async disconnect() {
    this.stateValue.address && (this.keyStore.removeAddress(), this.additionalInfoRepository.clear(this.stateValue.address));
    let e2 = { ...this.stateValue, status: AccountStatusEnum.NotConnected, accountId: void 0, userId: void 0, address: void 0 };
    this._ee.emit(_$4.statusChanged, e2);
  }
  switchChainId(e2) {
    e2 = this.parseChainId(e2);
    let t = { ...this.stateValue, connectWallet: { ...this.stateValue.connectWallet, chainId: e2 } };
    this.walletAdapter && (this.walletAdapter.chainId = e2), this._ee.emit(_$4.statusChanged, t);
  }
  parseChainId(e2) {
    return typeof e2 == "string" && (_e$6(e2) || e2.startsWith("0x") && _e$6(e2.slice(2))) && (e2 = parseInt(e2, 16)), e2;
  }
  async _checkOrderlyKeyState(e2, t) {
    let r3 = await this._simpleFetch(`/v1/get_orderly_key?account_id=${e2}&orderly_key=${t}`);
    return r3.success ? r3.data : null;
  }
  get signer() {
    return this._singer || (this._singer = new te$5(this.keyStore)), this._singer;
  }
  get walletAdapter() {
    return this.walletAdapterManager.adapter;
  }
  async _getRegisterationNonce() {
    var _a3;
    let e2 = await this._simpleFetch("/v1/registration_nonce", { headers: { "orderly-account-id": this.stateValue.accountId } });
    if (e2.success) return { nonce: (_a3 = e2.data) == null ? void 0 : _a3.registration_nonce, timestamp: e2.timestamp };
    throw new Error(e2.message);
  }
  async _getTimestampFromServer() {
    let e2 = await this._getAccountInfo();
    if (e2.success) return e2.timestamp;
    throw new SDKError("get timestamp error");
  }
  async _getAccountInfo(e2, t) {
    let r3 = this.configStore.get("brokerId"), a2 = e2 || this.address, s2 = t || this.stateValue.chainNamespace;
    return await this._simpleFetch(`/v1/get_account?address=${a2}&broker_id=${r3}&chain_type=${s2}`);
  }
  async _getSettleNonce() {
    var _a3;
    let e2 = I$7().toString(), r3 = [e2, "GET", "/v1/settle_nonce"].join(""), a2 = this.signer, { publicKey: s2, signature: i } = await a2.signText(r3), o2 = await this._simpleFetch("/v1/settle_nonce", { headers: { "orderly-account-id": this.stateValue.accountId, "orderly-key": s2, "orderly-timestamp": e2, "orderly-signature": i } });
    if (o2.success) return (_a3 = o2.data) == null ? void 0 : _a3.settle_nonce;
    throw new Error(o2.message);
  }
  async _simpleFetch(e2, t = {}) {
    let r3 = `${this.configStore.get("apiBaseUrl")}${e2}`;
    return fetch(r3, t).then((a2) => a2.json());
  }
  getAdditionalInfo() {
    return this.stateValue.address ? this.additionalInfoRepository.getAll(this.stateValue.address) : null;
  }
  get on() {
    return this._ee.on.bind(this._ee);
  }
  get once() {
    return this._ee.once.bind(this._ee);
  }
  get off() {
    return this._ee.off.bind(this._ee);
  }
};
Ne$4.instanceName = "account", Ne$4.additionalInfoRepositoryName = "walletAdditionalInfo";
var _t$3 = Ne$4;
y$3();
y$3();
var or$5 = { mainnet: { apiBaseUrl: "https://api.orderly.org", publicWsUrl: "wss://ws-evm.orderly.org", privateWsUrl: "wss://ws-private-evm.orderly.org", operatorUrl: { EVM: "https://operator-evm.orderly.org", SOL: "https://operator-solana.orderly.org" } }, testnet: { apiBaseUrl: "https://testnet-api.orderly.org", publicWsUrl: "wss://testnet-ws-evm.orderly.org", privateWsUrl: "wss://testnet-ws-private-evm.orderly.org", operatorUrl: { EVM: "https://testnet-operator-evm.orderly.org", SOL: "https://testnet-operator-sol.orderly.org" } } }, St$5 = class St {
  constructor(e2) {
    let t = e2.env || "prod", r3 = e2.networkId || "mainnet", a2 = or$5[r3], s2 = (e2 == null ? void 0 : e2.brokerId) || "orderly", i = (e2 == null ? void 0 : e2.brokerName) || "Orderly", o2 = (e2 == null ? void 0 : e2.chainNamespace) || ChainNamespace.evm;
    this.map = /* @__PURE__ */ new Map([["env", t], ["brokerId", s2], ["brokerName", i], ["networkId", r3], ["chainNamespace", o2], ["apiBaseUrl", a2.apiBaseUrl], ["publicWsUrl", a2.publicWsUrl], ["privateWsUrl", a2.privateWsUrl], ["operatorUrl", a2.operatorUrl]]);
  }
  get(e2) {
    let t = this.map.get(e2);
    return typeof t != "object" || t === null ? t : t[this.get("chainNamespace")];
  }
  getOr(e2, t) {
    return this.map.get(e2) ?? t;
  }
  set(e2, t) {
    this.map.set(e2, t);
  }
  clear() {
    throw new Error("Method not implemented.");
  }
};
y$3();
var pr$3 = Te$6(lt$6());
var Mt$5 = class Mt {
  async signMessageByOrderlyKey(e2) {
    let t = ke$5.get("account"), a2 = await t.signer.sign(e2, I$7());
    return a2["orderly-account-id"] = t.accountId, a2;
  }
  get address() {
    throw new SDKError("Method not implemented.");
  }
  get chainId() {
    throw new SDKError("Method not implemented.");
  }
  active(e2) {
    throw new SDKError("Method not implemented.");
  }
  update(e2) {
    throw new SDKError("Method not implemented.");
  }
  generateSecretKey() {
    let e2, t;
    do
      e2 = Ke$8.randomPrivateKey(), t = (0, pr$3.encode)(e2);
    while (t.length !== 44);
    return t;
  }
  parseUnits(e2, t = 6) {
    return parseUnits$1(e2, t).toString();
  }
  formatUnits(e2, t = 6) {
    return formatUnits(e2, t);
  }
  on(e2, t) {
    throw new SDKError("Method not implemented.");
  }
  off(e2, t) {
    throw new SDKError("Method not implemented.");
  }
};
y$3();
y$3();
y$3();
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

@noble/ed25519/index.js:
  (*! noble-ed25519 - MIT License (c) 2019 Paul Miller (paulmillr.com) *)
*/
a.set({ rounding: a.ROUND_DOWN });
var g$6 = a, $$4 = new a(0), E$4 = (t, e2) => {
  if (typeof t == "string" && isNaN(Number(t))) return (e2 == null ? void 0 : e2.fallback) || "--";
  let r3 = (e2 == null ? void 0 : e2.prefix) || "";
  if (typeof t == "undefined") return r3 + ((e2 == null ? void 0 : e2.fallback) || "--");
  let n4 = d$2(t, e2 == null ? void 0 : e2.fix);
  if (e2 && e2.padEnd && e2.fix) {
    let i = (e2 == null ? void 0 : e2.fillString) || "0", s2 = n4.includes("."), o2 = n4.split(".");
    return s2 ? r3 + o2[0] + "." + o2[1].padEnd(e2.fix, i) : r3 + o2[0] + "." + "".padEnd(e2.fix, i);
  }
  return r3 + n4;
}, d$2 = (t, e2) => {
  let r3 = `${t}`, n4 = r3.split("."), i = n4[0], s2 = n4[1], o2 = /\B(?=(\d{3})+(?!\d))/g, c = r3.endsWith(".") && r3.length > 1, u2 = i.replace(o2, ",") + (s2 ? "." + s2.substring(0, e2 || s2.length) : c ? "." : "");
  return e2 === 0 && u2.includes(".") ? u2.substring(0, u2.indexOf(".")) : u2;
}, _$3 = (t) => {
  t = m$1(Number(t));
  let e2 = t.toString().split(".");
  return e2[1] ? e2[1].length : 0;
};
function m$1(t) {
  let e2 = t.toExponential().match(/\d(?:\.(\d*))?e([+-]\d+)/);
  return Array.isArray(e2) ? t.toFixed(Math.max(0, (e2[1] || "").length - e2[2])) : t;
}
function C$3(t, e2 = 2, r3) {
  let i = ["", "K", "M", "B", "T"], s2 = 0;
  for (; t >= 1e3 && s2 < i.length - 1; ) t /= 1e3, s2++;
  let o2 = new a(t).toFixed(e2, a.ROUND_DOWN).toString();
  return o2 = o2.replace(/\.0+$/, ""), `${o2}${i[s2]}`;
}
function I$6(t, e2 = 16) {
  let r3 = `${t}`, i = /^[-+]?[0-9]+(\.[0-9]+)?[eE][-+]?[0-9]+$/.test(r3);
  return !t.toString().includes(".") && !i ? `${t}` : new a(t).toFixed(e2).replace(/(\.[0-9]*[1-9])0+$/, "$1");
}
var O$7 = (t, e2) => {
  if (t === void 0 || t === "" || (typeof t == "number" && (t = t.toString()), t.endsWith("."))) return t;
  let r3 = t.split(".");
  return r3.length === 1 || r3[1].length <= e2 || !r3[1] ? t : `${r3[0]}.${r3[1].substring(0, e2)}`;
};
var P$3 = (t) => {
  t /= 1e3;
  let e2 = Math.floor(t / 3600), r3 = Math.floor(t / 60 % 60), n4 = Math.floor(t % 60);
  return [e2, r3, n4];
};
function R$3(t, e2) {
  let r3 = e2 || /* @__PURE__ */ new Date(), n4 = new Date(r3);
  return n4.setDate(r3.getDate() - t), n4;
}
var f$3 = (t) => parseInt(t), B$7 = (t) => `0x${t.toString(16)}`, N$5 = (t) => typeof t == "string" && t.startsWith("0x") && /^[a-f0-9]+$/iu.test(t.slice(2)) ? f$3(t) : t, z$4 = N$5, L$5 = (t) => [ARBITRUM_TESTNET_CHAINID, SOLANA_TESTNET_CHAINID, STORY_TESTNET_CHAINID, MONAD_TESTNET_CHAINID, ABSTRACT_TESTNET_CHAINID].includes(t);
function j$4(t) {
  let e2 = t.toLowerCase();
  return e2.charAt(0).toUpperCase() + e2.slice(1);
}
function G$7(t) {
  let e2 = t.split("_");
  if (e2.length !== 3) throw new Error("Invalid string format");
  let [r3, n4, i] = e2;
  if (!r3.startsWith("PERP")) throw new Error("Invalid string format");
  return `${n4}-${r3}`;
}
function Y$4(t) {
  return t.replace(/([a-z])([A-Z])/g, "$1_$2").toLowerCase();
}
var K$5 = (t, e2) => {
  for (let r3 = 0; r3 < t.length; r3++) {
    let n4 = t.at(r3), i = e2.at(r3);
    if (n4 !== i) return r3;
  }
  return -1;
};
var w$4 = (t) => {
  typeof window != "undefined" && t();
}, l$1 = () => {
  if (typeof globalThis != "undefined") return globalThis;
  if (typeof self != "undefined") return self;
  if (typeof window != "undefined") return window;
  if (typeof dist.global != "undefined") return dist.global;
  throw new Error("cannot find the global object");
}, T$1 = () => {
  var t;
  if (typeof window != "undefined") {
    let e2 = (t = l$1()) == null ? void 0 : t.__ORDERLY_timestamp_offset;
    if (typeof e2 == "number") return Date.now() + (e2 || 0);
  }
  return Date.now();
};
var __defProp$1 = Object.defineProperty;
var __export$1 = (target, all) => {
  for (var name in all)
    __defProp$1(target, name, { get: all[name], enumerable: true });
};
if (typeof window !== "undefined") {
  window.__ORDERLY_VERSION__ = window.__ORDERLY_VERSION__ || {};
  window.__ORDERLY_VERSION__["@orderly.network/perp"] = "4.2.0";
}
var positions_exports = {};
__export$1(positions_exports, {
  MMR: () => MMR,
  estOffsetForTP: () => estOffsetForTP,
  estPnLForSL: () => estPnLForSL,
  estPnLForTP: () => estPnLForTP,
  estPriceForTP: () => estPriceForTP,
  estPriceFromOffsetForTP: () => estPriceFromOffsetForTP,
  liqPrice: () => liqPrice,
  maintenanceMargin: () => maintenanceMargin,
  notional: () => notional,
  totalNotional: () => totalNotional,
  totalUnrealizedPnL: () => totalUnrealizedPnL,
  totalUnsettlementPnL: () => totalUnsettlementPnL,
  unrealizedPnL: () => unrealizedPnL,
  unrealizedPnLROI: () => unrealizedPnLROI,
  unsettlementPnL: () => unsettlementPnL
});
var IMRFactorPower = 4 / 5;
function notional(qty, mark_price) {
  return new g$6(qty).mul(mark_price).abs().toNumber();
}
function totalNotional(positions) {
  return positions.reduce((acc, cur) => {
    return acc + notional(cur.position_qty, cur.mark_price);
  }, 0);
}
function unrealizedPnL(inputs) {
  return new g$6(inputs.qty).mul(inputs.markPrice - inputs.openPrice).toNumber();
}
function unrealizedPnLROI(inputs) {
  const { openPrice, IMR: IMR2 } = inputs;
  if (inputs.unrealizedPnL === 0 || inputs.positionQty === 0 || openPrice === 0 || IMR2 === 0)
    return 0;
  return new g$6(inputs.unrealizedPnL).div(new g$6(Math.abs(inputs.positionQty)).mul(openPrice).mul(IMR2)).toNumber();
}
function totalUnrealizedPnL(positions) {
  return positions.reduce((acc, cur) => {
    return acc + unrealizedPnL({
      qty: cur.position_qty,
      openPrice: cur.average_open_price,
      markPrice: cur.mark_price
    });
  }, 0);
}
function liqPrice(inputs) {
  const { markPrice, totalCollateral: totalCollateral2, positions, positionQty, MMR: MMR3 } = inputs;
  if (positionQty === 0 || totalCollateral2 === 0) {
    return null;
  }
  const totalNotional2 = positions.reduce((acc, cur) => {
    return acc.add(
      new g$6(notional(cur.position_qty, cur.mark_price)).mul(cur.mmr)
    );
  }, $$4);
  return Math.max(
    new g$6(markPrice).add(
      new g$6(totalCollateral2).sub(totalNotional2).div(new g$6(positionQty).abs().mul(MMR3).sub(positionQty))
    ).toNumber(),
    0
  );
}
function maintenanceMargin(inputs) {
  const { positionQty, markPrice, MMR: MMR3 } = inputs;
  return new g$6(positionQty).mul(markPrice).mul(MMR3).abs().toNumber();
}
function unsettlementPnL(inputs) {
  const {
    positionQty,
    markPrice,
    costPosition,
    sumUnitaryFunding,
    lastSumUnitaryFunding
  } = inputs;
  const qty = new g$6(positionQty);
  return qty.mul(markPrice).sub(costPosition).sub(qty.mul(new g$6(sumUnitaryFunding).sub(lastSumUnitaryFunding))).toNumber();
}
function totalUnsettlementPnL(positions) {
  if (!Array.isArray(positions) || positions.length === 0) {
    return 0;
  }
  return positions.reduce((acc, cur) => {
    return acc + unsettlementPnL({
      positionQty: cur.position_qty,
      markPrice: cur.mark_price,
      costPosition: cur.cost_position,
      sumUnitaryFunding: cur.sum_unitary_funding,
      lastSumUnitaryFunding: cur.last_sum_unitary_funding
    });
  }, 0);
}
function MMR(inputs) {
  const {
    baseMMR,
    baseIMR,
    IMRFactor,
    positionNotional,
    IMR_factor_power = IMRFactorPower
  } = inputs;
  return Math.max(
    baseMMR,
    new g$6(baseMMR).div(baseIMR).mul(IMRFactor).mul(Math.pow(Math.abs(positionNotional), IMR_factor_power)).toNumber()
  );
}
function estPnLForTP(inputs) {
  return new g$6(inputs.positionQty).mul(new g$6(inputs.price).sub(inputs.entryPrice)).toNumber();
}
function estPriceForTP(inputs) {
  return new g$6(inputs.pnl).add(inputs.entryPrice).div(inputs.positionQty).toNumber();
}
function estOffsetForTP(inputs) {
  return new g$6(inputs.price).div(inputs.entryPrice).toNumber();
}
function estPriceFromOffsetForTP(inputs) {
  return new g$6(inputs.offset).add(inputs.entryPrice).toNumber();
}
function estPnLForSL(inputs) {
  return 0;
}
var account_exports = {};
__export$1(account_exports, {
  IMR: () => IMR,
  MMR: () => MMR2,
  availableBalance: () => availableBalance,
  buyOrdersFilter_by_symbol: () => buyOrdersFilter_by_symbol,
  currentLeverage: () => currentLeverage,
  extractSymbols: () => extractSymbols,
  freeCollateral: () => freeCollateral,
  getPositonsAndOrdersNotionalBySymbol: () => getPositonsAndOrdersNotionalBySymbol,
  getQtyFromOrdersBySide: () => getQtyFromOrdersBySide,
  getQtyFromPositions: () => getQtyFromPositions,
  groupOrdersBySymbol: () => groupOrdersBySymbol,
  initialMarginWithOrder: () => initialMarginWithOrder,
  maxQty: () => maxQty,
  maxQtyByLong: () => maxQtyByLong,
  maxQtyByShort: () => maxQtyByShort,
  otherIMs: () => otherIMs,
  positionNotionalWithOrder_by_symbol: () => positionNotionalWithOrder_by_symbol,
  positionQtyWithOrders_by_symbol: () => positionQtyWithOrders_by_symbol,
  sellOrdersFilter_by_symbol: () => sellOrdersFilter_by_symbol,
  totalCollateral: () => totalCollateral,
  totalInitialMarginWithOrders: () => totalInitialMarginWithOrders,
  totalInitialMarginWithQty: () => totalInitialMarginWithQty,
  totalMarginRatio: () => totalMarginRatio,
  totalUnrealizedROI: () => totalUnrealizedROI,
  totalValue: () => totalValue
});
function totalValue(inputs) {
  const { totalUnsettlementPnL: totalUnsettlementPnL2, USDCHolding, nonUSDCHolding } = inputs;
  const nonUSDCHoldingValue = nonUSDCHolding.reduce((acc, cur) => {
    return new g$6(cur.holding).mul(cur.markPrice).add(acc);
  }, $$4);
  return nonUSDCHoldingValue.add(USDCHolding).add(totalUnsettlementPnL2);
}
function freeCollateral(inputs) {
  const value = inputs.totalCollateral.sub(inputs.totalInitialMarginWithOrders);
  return value.isNegative() ? $$4 : value;
}
function totalCollateral(inputs) {
  const { USDCHolding, nonUSDCHolding } = inputs;
  const nonUSDCHoldingValue = nonUSDCHolding.reduce((acc, cur) => {
    return acc + new g$6(cur.holding).mul(cur.markPrice).mul(cur.discount).toNumber();
  }, 0);
  return new g$6(USDCHolding).add(nonUSDCHoldingValue).add(inputs.unsettlementPnL);
}
function initialMarginWithOrder() {
}
function positionNotionalWithOrder_by_symbol(inputs) {
  return new g$6(inputs.markPrice).mul(inputs.positionQtyWithOrders);
}
function positionQtyWithOrders_by_symbol(inputs) {
  const { positionQty, buyOrdersQty, sellOrdersQty } = inputs;
  const positionQtyDecimal = new g$6(positionQty);
  const qty = Math.max(
    positionQtyDecimal.add(buyOrdersQty).abs().toNumber(),
    positionQtyDecimal.sub(sellOrdersQty).abs().toNumber()
  );
  return qty;
}
function IMR(inputs) {
  const {
    maxLeverage,
    baseIMR,
    IMR_Factor,
    positionNotional,
    ordersNotional: orderNotional,
    IMR_factor_power = IMRFactorPower
  } = inputs;
  return Math.max(
    1 / maxLeverage,
    baseIMR,
    new g$6(IMR_Factor).mul(
      new g$6(positionNotional).add(orderNotional).abs().toPower(IMR_factor_power)
    ).toNumber()
  );
}
function buyOrdersFilter_by_symbol(orders, symbol) {
  return orders.filter(
    (item) => item.symbol === symbol && item.side === OrderSide.BUY
  );
}
function sellOrdersFilter_by_symbol(orders, symbol) {
  return orders.filter(
    (item) => item.symbol === symbol && item.side === OrderSide.SELL
  );
}
function getQtyFromPositions(positions, symbol) {
  if (!positions) {
    return 0;
  }
  const position = positions.find((item) => item.symbol === symbol);
  return (position == null ? void 0 : position.position_qty) || 0;
}
function getQtyFromOrdersBySide(orders, symbol, side) {
  const ordersBySide = side === OrderSide.SELL ? sellOrdersFilter_by_symbol(orders, symbol) : buyOrdersFilter_by_symbol(orders, symbol);
  return ordersBySide.reduce((acc, cur) => {
    return acc + cur.quantity;
  }, 0);
}
function getPositonsAndOrdersNotionalBySymbol(inputs) {
  const { positions, orders, symbol, markPrice } = inputs;
  const positionQty = getQtyFromPositions(positions, symbol);
  const buyOrdersQty = getQtyFromOrdersBySide(orders, symbol, OrderSide.BUY);
  const sellOrdersQty = getQtyFromOrdersBySide(orders, symbol, OrderSide.SELL);
  const markPriceDecimal = new g$6(markPrice);
  return markPriceDecimal.mul(positionQty).add(markPriceDecimal.mul(new g$6(buyOrdersQty).add(sellOrdersQty))).abs().toNumber();
}
function totalInitialMarginWithOrders(inputs) {
  const {
    positions,
    orders,
    markPrices,
    IMR_Factors,
    maxLeverage,
    symbolInfo
  } = inputs;
  const symbols = extractSymbols(positions, orders);
  const total_initial_margin_with_orders = symbols.reduce((acc, cur) => {
    const symbol = cur;
    const positionQty = getQtyFromPositions(positions, symbol);
    const buyOrdersQty = getQtyFromOrdersBySide(orders, symbol, OrderSide.BUY);
    const sellOrdersQty = getQtyFromOrdersBySide(
      orders,
      symbol,
      OrderSide.SELL
    );
    const markPrice = markPrices[symbol] || 0;
    const positionQtyWithOrders = positionQtyWithOrders_by_symbol({
      positionQty,
      buyOrdersQty,
      sellOrdersQty
    });
    const position_notional_with_orders = positionNotionalWithOrder_by_symbol({
      markPrice,
      positionQtyWithOrders
    });
    const markPriceDecimal = new g$6(markPrice);
    const imr = IMR({
      positionNotional: markPriceDecimal.mul(positionQty).toNumber(),
      ordersNotional: markPriceDecimal.mul(new g$6(buyOrdersQty).add(sellOrdersQty)).toNumber(),
      maxLeverage,
      IMR_Factor: IMR_Factors[symbol],
      baseIMR: symbolInfo[symbol]("base_imr", 0)
    });
    return position_notional_with_orders.mul(imr).add(acc).toNumber();
  }, 0);
  return total_initial_margin_with_orders;
}
function totalInitialMarginWithQty(inputs) {
  const { positions, markPrices, IMR_Factors, symbolInfo, maxLeverage } = inputs;
  const symbols = positions.map((item) => item.symbol);
  const total_initial_margin_with_orders = symbols.reduce((acc, cur) => {
    const symbol = cur;
    const position = positions.find((item) => item.symbol === symbol);
    const positionQty = (position == null ? void 0 : position.position_qty) || 0;
    const buyOrdersQty = (position == null ? void 0 : position.pending_long_qty) || 0;
    const sellOrdersQty = (position == null ? void 0 : position.pending_short_qty) || 0;
    const markPrice = markPrices[symbol] || 0;
    const positionQtyWithOrders = positionQtyWithOrders_by_symbol({
      positionQty,
      buyOrdersQty,
      sellOrdersQty
    });
    const position_notional_with_orders = positionNotionalWithOrder_by_symbol({
      markPrice,
      positionQtyWithOrders
    });
    const markPriceDecimal = new g$6(markPrice);
    const imr = IMR({
      positionNotional: markPriceDecimal.mul(positionQty).toNumber(),
      ordersNotional: markPriceDecimal.mul(new g$6(buyOrdersQty).add(sellOrdersQty)).toNumber(),
      maxLeverage,
      IMR_Factor: IMR_Factors[symbol],
      baseIMR: symbolInfo[symbol]("base_imr", 0)
    });
    return position_notional_with_orders.mul(imr).add(acc).toNumber();
  }, 0);
  return total_initial_margin_with_orders;
}
function groupOrdersBySymbol(orders) {
  const symbols = {};
  orders.forEach((item) => {
    if (!symbols[item.symbol]) {
      symbols[item.symbol] = [];
    }
    symbols[item.symbol].push(item);
  });
  return symbols;
}
function extractSymbols(positions, orders) {
  const symbols = /* @__PURE__ */ new Set();
  positions.forEach((item) => {
    symbols.add(item.symbol);
  });
  orders.forEach((item) => {
    symbols.add(item.symbol);
  });
  return Array.from(symbols);
}
function otherIMs(inputs) {
  const {
    orders,
    positions,
    maxLeverage,
    IMR_Factors,
    symbolInfo,
    markPrices
  } = inputs;
  const symbols = extractSymbols(positions, orders);
  return symbols.reduce((acc, cur) => {
    const symbol = cur;
    if (typeof markPrices[symbol] === "undefined") {
      console.warn("markPrices[%s] is undefined", symbol);
      return acc;
    }
    const markPriceDecimal = new g$6(markPrices[symbol] || 0);
    const positionQty = getQtyFromPositions(positions, symbol);
    const positionNotional = markPriceDecimal.mul(positionQty).toNumber();
    const buyOrdersQty = getQtyFromOrdersBySide(
      orders,
      symbol,
      OrderSide.BUY
    );
    const sellOrdersQty = getQtyFromOrdersBySide(
      orders,
      symbol,
      OrderSide.SELL
    );
    const ordersNotional = markPriceDecimal.mul(new g$6(buyOrdersQty).add(sellOrdersQty)).toNumber();
    const IMR_Factor = IMR_Factors[symbol];
    if (!IMR_Factor) {
      console.warn("IMR_Factor is not found:", symbol);
      return acc;
    }
    const imr = IMR({
      maxLeverage,
      IMR_Factor,
      baseIMR: symbolInfo[symbol]("base_imr", 0),
      positionNotional,
      ordersNotional
    });
    const positionQtyWithOrders = positionQtyWithOrders_by_symbol({
      positionQty,
      buyOrdersQty,
      sellOrdersQty
    });
    const positionNotionalWithOrders = positionNotionalWithOrder_by_symbol({
      markPrice: markPrices[symbol] || 0,
      positionQtyWithOrders
    });
    return acc.add(positionNotionalWithOrders.mul(imr));
  }, $$4).toNumber();
}
function maxQty(side, inputs, options) {
  if (side === OrderSide.BUY) {
    return maxQtyByLong(inputs);
  }
  return maxQtyByShort(inputs);
}
function maxQtyByLong(inputs, options) {
  try {
    const {
      baseMaxQty,
      totalCollateral: totalCollateral2,
      otherIMs: otherIMs2,
      maxLeverage,
      baseIMR,
      markPrice,
      IMR_Factor,
      positionQty,
      buyOrdersQty,
      takerFeeRate
    } = inputs;
    if (totalCollateral2 === 0) {
      return 0;
    }
    const totalCollateralDecimal = new g$6(totalCollateral2);
    const factor_1 = totalCollateralDecimal.sub(otherIMs2).div(
      new g$6(takerFeeRate).mul(2).mul(1e-4).add(Math.max(1 / maxLeverage, baseIMR))
    ).div(markPrice).mul(0.995).sub(new g$6(positionQty).add(buyOrdersQty)).toNumber();
    if (positionQty === 0 && buyOrdersQty === 0) {
      return Math.min(baseMaxQty, factor_1);
    }
    const factor_2 = totalCollateralDecimal.sub(otherIMs2).div(IMR_Factor).toPower(1 / 1.8).div(markPrice).sub(
      new g$6(positionQty).add(buyOrdersQty)
      // .abs()
      // .div(new Decimal(takerFeeRate).mul(2).mul(0.0001).add(1))
    ).div(new g$6(takerFeeRate).mul(2).mul(1e-4).add(1)).mul(0.995).toNumber();
    return Math.min(baseMaxQty, factor_1, factor_2);
  } catch (error) {
    return 0;
  }
}
function maxQtyByShort(inputs, options) {
  try {
    const {
      baseMaxQty,
      totalCollateral: totalCollateral2,
      otherIMs: otherIMs2,
      maxLeverage,
      baseIMR,
      markPrice,
      IMR_Factor,
      positionQty,
      buyOrdersQty,
      sellOrdersQty,
      takerFeeRate
    } = inputs;
    const totalCollateralDecimal = new g$6(totalCollateral2);
    const factor_1 = totalCollateralDecimal.sub(otherIMs2).div(
      new g$6(takerFeeRate).mul(2).mul(1e-4).add(Math.max(1 / maxLeverage, baseIMR))
    ).div(markPrice).mul(0.995).add(positionQty).sub(sellOrdersQty).toNumber();
    if (positionQty === 0 && buyOrdersQty === 0) {
      return Math.min(baseMaxQty, factor_1);
    }
    const factor_2 = totalCollateralDecimal.sub(otherIMs2).div(IMR_Factor).toPower(1 / 1.8).div(markPrice).add(positionQty).sub(sellOrdersQty).div(new g$6(takerFeeRate).mul(2).mul(1e-4).add(1)).mul(0.995).toNumber();
    return Math.min(baseMaxQty, factor_1, factor_2);
  } catch (error) {
    return 0;
  }
}
function totalMarginRatio(inputs, dp) {
  const { totalCollateral: totalCollateral2, markPrices, positions } = inputs;
  if (totalCollateral2 === 0) {
    return 0;
  }
  const totalCollateralDecimal = new g$6(totalCollateral2);
  const totalPositionNotional = positions.reduce((acc, cur) => {
    const markPrice = markPrices[cur.symbol] || 0;
    return acc.add(new g$6(cur.position_qty).mul(markPrice).abs());
  }, $$4);
  if (totalPositionNotional.eq($$4)) {
    return 0;
  }
  return totalCollateralDecimal.div(totalPositionNotional).toNumber();
}
function totalUnrealizedROI(inputs) {
  const { totalUnrealizedPnL: totalUnrealizedPnL2, totalValue: totalValue2 } = inputs;
  return new g$6(totalUnrealizedPnL2).div(totalValue2 - totalUnrealizedPnL2).toNumber();
}
function currentLeverage(totalMarginRatio2) {
  if (totalMarginRatio2 === 0) {
    return 0;
  }
  return 1 / totalMarginRatio2;
}
function availableBalance(inputs) {
  const { USDCHolding, unsettlementPnL: unsettlementPnL2 } = inputs;
  return new g$6(USDCHolding).add(unsettlementPnL2).toNumber();
}
function MMR2(inputs) {
  if (inputs.positionsNotional === 0) {
    return null;
  }
  if (inputs.positionsMMR === 0)
    return null;
  return new g$6(inputs.positionsMMR).div(inputs.positionsNotional).toNumber();
}
var order_exports = {};
__export$1(order_exports, {
  estLeverage: () => estLeverage,
  estLiqPrice: () => estLiqPrice,
  maxPrice: () => maxPrice$1,
  minPrice: () => minPrice$1,
  orderFee: () => orderFee,
  scopePrice: () => scopePrice$1
});
function maxPrice$1(markprice, range) {
  return markprice * (1 + range);
}
function minPrice$1(markprice, range) {
  return markprice * (1 - range);
}
function scopePrice$1(price, scope, side) {
  if (side === "BUY") {
    return price * (1 - scope);
  }
  return price * (1 + scope);
}
function orderFee(inputs) {
  return new g$6(inputs.qty).mul(inputs.price).mul(inputs.futuresTakeFeeRate).toNumber();
}
function estLiqPrice(inputs) {
  var _a3;
  const {
    positions,
    newOrder,
    totalCollateral: totalCollateral2,
    markPrice,
    baseIMR,
    baseMMR,
    orderFee: orderFee2,
    IMR_Factor
  } = inputs;
  let currentPosition = void 0;
  let newTotalMM = $$4;
  const hasPosition = positions.filter((item) => item.position_qty > 0).length > 0;
  const basePrice = hasPosition ? markPrice : newOrder.price;
  const newOrderNotional = new g$6(newOrder.qty).mul(newOrder.price);
  for (let index = 0; index < positions.length; index++) {
    const position = positions[index];
    let notional2 = new g$6(position.position_qty).mul(position.mark_price);
    if (newOrder.symbol === position.symbol) {
      currentPosition = position;
      notional2 = notional2.add(newOrderNotional);
    }
    newTotalMM = newTotalMM.add(notional2.abs().mul(position.mmr));
  }
  if (!currentPosition) {
    newTotalMM = newTotalMM.add(newOrderNotional.mul(baseMMR));
  }
  const newMMR = Math.max(
    baseMMR,
    new g$6(baseMMR).div(baseIMR).mul(IMR_Factor).mul(
      newOrderNotional.add(
        !!currentPosition ? new g$6(currentPosition.position_qty).mul(
          currentPosition.mark_price
        ) : $$4
      ).abs()
    ).toPower(4 / 5).toNumber()
  );
  const newQty = new g$6(newOrder.qty).add(
    (_a3 = currentPosition == null ? void 0 : currentPosition.position_qty) != null ? _a3 : 0
  );
  if (newQty.eq(0)) {
    return 0;
  }
  const price = new g$6(basePrice).add(
    new g$6(totalCollateral2).sub(newTotalMM).sub(orderFee2).div(newQty.abs().mul(newMMR).sub(newQty))
  ).toNumber();
  return Math.max(0, price);
}
function estLeverage(inputs) {
  const { totalCollateral: totalCollateral2, positions, newOrder } = inputs;
  if (totalCollateral2 <= 0) {
    return null;
  }
  let hasPosition = false;
  let sumPositionNotional = positions.reduce((acc, cur) => {
    let count = new g$6(cur.position_qty).mul(cur.mark_price);
    if (cur.symbol === newOrder.symbol) {
      hasPosition = true;
      count = count.add(new g$6(newOrder.qty).mul(newOrder.price));
    }
    return acc.add(count.abs());
  }, $$4);
  if (!hasPosition) {
    sumPositionNotional = sumPositionNotional.add(
      new g$6(newOrder.qty).mul(newOrder.price).abs()
    );
  }
  if (sumPositionNotional.eq($$4)) {
    return null;
  }
  const totalMarginRatio2 = new g$6(totalCollateral2).div(
    sumPositionNotional
  );
  return new g$6(1).div(totalMarginRatio2).toDecimalPlaces(2, g$6.ROUND_HALF_EVEN).toNumber();
}
const { encode: N$4 } = ((_c = (_b = __cjsInterop1__) == null ? void 0 : _b.default) == null ? void 0 : _c.__esModule) ? __cjsInterop1__.default : __cjsInterop1__;
var S$4 = Object.defineProperty, E$3 = Object.defineProperties;
var _$2 = Object.getOwnPropertyDescriptors;
var M$4 = Object.getOwnPropertySymbols;
var O$6 = Object.prototype.hasOwnProperty, A$4 = Object.prototype.propertyIsEnumerable;
var I$5 = (s2, a2, e2) => a2 in s2 ? S$4(s2, a2, { enumerable: true, configurable: true, writable: true, value: e2 }) : s2[a2] = e2, g$5 = (s2, a2) => {
  for (var e2 in a2 || (a2 = {})) O$6.call(a2, e2) && I$5(s2, e2, a2[e2]);
  if (M$4) for (var e2 of M$4(a2)) A$4.call(a2, e2) && I$5(s2, e2, a2[e2]);
  return s2;
}, p$2 = (s2, a2) => E$3(s2, _$2(a2));
var y$2 = (s2, a2, e2) => (I$5(s2, typeof a2 != "symbol" ? a2 + "" : a2, e2), e2);
var m = (s2, a2, e2) => new Promise((t, n4) => {
  var i = (o2) => {
    try {
      d2(e2.next(o2));
    } catch (c) {
      n4(c);
    }
  }, r3 = (o2) => {
    try {
      d2(e2.throw(o2));
    } catch (c) {
      n4(c);
    }
  }, d2 = (o2) => o2.done ? t(o2.value) : Promise.resolve(o2.value).then(i, r3);
  d2((e2 = e2.apply(s2, a2)).next());
});
typeof window != "undefined" && (window.__ORDERLY_VERSION__ = window.__ORDERLY_VERSION__ || {}, window.__ORDERLY_VERSION__["@orderly.network/default-evm-adapter"] = "2.2.0");
function f$2(s2) {
  return m(this, null, function* () {
    let { chainId: a2, receiver: e2, token: t, amount: n4, nonce: i, brokerId: r3, domain: d2 } = s2, o2 = "Withdraw", c = Date.now(), h2 = { EIP712Domain: definedTypes.EIP712Domain, [o2]: definedTypes[o2] }, l2 = { brokerId: r3, chainId: a2, receiver: e2, token: t, amount: n4, timestamp: c, withdrawNonce: i };
    return [l2, { domain: d2, message: l2, primaryType: o2, types: h2 }];
  });
}
function v$2(s2) {
  return m(this, null, function* () {
    let { publicKey: a2, chainId: e2, brokerId: t, expiration: n4 = 365, timestamp: i = Date.now(), scope: r3, tag: d2, domain: o2 } = s2, c = "AddOrderlyKey", h2 = g$5({ brokerId: t, orderlyKey: a2, scope: r3 || "read,trading", chainId: e2, timestamp: i, expiration: i + 1e3 * 60 * 60 * 24 * n4 }, typeof d2 != "undefined" ? { tag: d2 } : {}), l2 = { EIP712Domain: definedTypes.EIP712Domain, [c]: definedTypes[c] };
    return [h2, { domain: o2, message: h2, primaryType: c, types: l2 }];
  });
}
function b$3(s2) {
  return m(this, null, function* () {
    let { chainId: a2, domain: e2, registrationNonce: t, brokerId: n4, timestamp: i } = s2, r3 = "Registration", d2 = { brokerId: n4, chainId: a2, timestamp: i, registrationNonce: t }, o2 = { EIP712Domain: definedTypes.EIP712Domain, [r3]: definedTypes[r3] };
    return [d2, { domain: e2, message: d2, primaryType: r3, types: o2 }];
  });
}
function D$2(s2) {
  return m(this, null, function* () {
    let { settlePnlNonce: a2, brokerId: e2, chainId: t, timestamp: n4, domain: i } = s2, r3 = "SettlePnl", d2 = { EIP712Domain: definedTypes.EIP712Domain, [r3]: definedTypes[r3] }, o2 = { brokerId: e2, chainId: t, timestamp: n4, settleNonce: a2 };
    return [o2, { domain: i, message: o2, primaryType: r3, types: d2 }];
  });
}
var w$3 = class w extends Mt$5 {
  constructor(e2) {
    super();
    this.web3Provider = e2;
    y$2(this, "chainNamespace", ChainNamespace.evm);
    y$2(this, "_address");
    y$2(this, "_chainId");
    y$2(this, "contractManager");
  }
  get address() {
    return this._address;
  }
  get chainId() {
    return this._chainId;
  }
  set chainId(e2) {
    this._chainId = e2;
  }
  setConfig(e2) {
    if (this._address = e2.address, this._chainId = e2.chain.id, e2.provider && (this.web3Provider.provider = e2.provider), e2.contractManager) this.contractManager = e2.contractManager;
    else throw new Error("Please provide contract manager class");
  }
  active(e2) {
    this.setConfig(e2), this.lifecycleName("active", e2);
  }
  deactivate() {
    this.lifecycleName("deactivate", {});
  }
  update(e2) {
    this.lifecycleName("update", e2), this.setConfig(e2);
  }
  generateSecretKey() {
    let e2, t;
    do
      e2 = P$4.utils.randomPrivateKey(), t = N$4(e2);
    while (t.length !== 44);
    return t;
  }
  lifecycleName(e2, t) {
    console.log("lifecycle", e2, t);
  }
  signTypedData(e2) {
    return m(this, null, function* () {
      return console.log("toSignatureMessage", this.address), yield this.web3Provider.signTypedData(this.address, JSON.stringify(e2));
    });
  }
  generateRegisterAccountMessage(e2) {
    return m(this, null, function* () {
      let [t, n4] = yield b$3(p$2(g$5({}, e2), { chainId: this.chainId, domain: this.getDomain() })), i = yield this.signTypedData(n4);
      return { message: p$2(g$5({}, t), { chainType: "EVM" }), signatured: i };
    });
  }
  generateAddOrderlyKeyMessage(e2) {
    return m(this, null, function* () {
      let [t, n4] = yield v$2(p$2(g$5({}, e2), { chainId: this.chainId, domain: this.getDomain() })), i = yield this.signTypedData(n4);
      return { message: p$2(g$5({}, t), { chainType: "EVM" }), signatured: i };
    });
  }
  generateWithdrawMessage(e2) {
    return m(this, null, function* () {
      let t = this.getDomain(true), [n4, i] = yield f$2(p$2(g$5({}, e2), { chainId: this.chainId, domain: t })), r3 = yield this.signTypedData(i);
      return { message: p$2(g$5({}, n4), { chainType: "EVM" }), signatured: r3, domain: t };
    });
  }
  generateSettleMessage(e2) {
    return m(this, null, function* () {
      let t = this.getDomain(true), [n4, i] = yield D$2(p$2(g$5({}, e2), { chainId: this.chainId, domain: t })), r3 = yield this.signTypedData(i);
      return { message: p$2(g$5({}, n4), { chainType: "EVM" }), signatured: r3, domain: t };
    });
  }
  getBalance() {
    return this.web3Provider.getBalance(this.address);
  }
  call(e2, t, n4, i) {
    return this.web3Provider.call(e2, t, n4, i);
  }
  sendTransaction(e2, t, n4, i) {
    return this.web3Provider.sendTransaction(e2, t, n4, i);
  }
  callOnChain(e2, t, n4, i, r3) {
    return this.web3Provider.callOnChain(e2, t, n4, i, r3);
  }
  getDomain(e2) {
    if (!this.web3Provider) throw new Error("web3Provider is undefined");
    return { name: "Orderly", version: "1", chainId: this.chainId, verifyingContract: e2 ? this.contractManager.getContractInfoByEnv().verifyContractAddress : "0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC" };
  }
  pollTransactionReceiptWithBackoff(e2, t, n4, i) {
    return this.web3Provider.pollTransactionReceiptWithBackoff(e2, t, n4, i);
  }
};
const { encode: Xn$2 } = ((_e2 = (_d2 = __cjsInterop1__) == null ? void 0 : _d2.default) == null ? void 0 : _e2.__esModule) ? __cjsInterop1__.default : __cjsInterop1__;
const { decode: Gn$2 } = ((_g = (_f = __cjsInterop1__) == null ? void 0 : _f.default) == null ? void 0 : _g.__esModule) ? __cjsInterop1__.default : __cjsInterop1__;
const { BN: _e$5, Program: ln$2 } = ((_i2 = (_h = __cjsInterop1__$1) == null ? void 0 : _h.default) == null ? void 0 : _i2.__esModule) ? __cjsInterop1__$1.default : __cjsInterop1__$1;
var In$1 = Object.defineProperty, wn$3 = Object.defineProperties;
var _n = Object.getOwnPropertyDescriptors;
var Ke$7 = Object.getOwnPropertySymbols;
var Tn = Object.prototype.hasOwnProperty, xn$1 = Object.prototype.propertyIsEnumerable;
var ie$1 = (n4, a2, e2) => a2 in n4 ? In$1(n4, a2, { enumerable: true, configurable: true, writable: true, value: e2 }) : n4[a2] = e2, g$4 = (n4, a2) => {
  for (var e2 in a2 || (a2 = {})) Tn.call(a2, e2) && ie$1(n4, e2, a2[e2]);
  if (Ke$7) for (var e2 of Ke$7(a2)) xn$1.call(a2, e2) && ie$1(n4, e2, a2[e2]);
  return n4;
}, S$3 = (n4, a2) => wn$3(n4, _n(a2));
var B$6 = (n4, a2, e2) => (ie$1(n4, typeof a2 != "symbol" ? a2 + "" : a2, e2), e2);
var l = (n4, a2, e2) => new Promise((s2, i) => {
  var t = (r3) => {
    try {
      m2(e2.next(r3));
    } catch (u2) {
      i(u2);
    }
  }, o2 = (r3) => {
    try {
      m2(e2.throw(r3));
    } catch (u2) {
      i(u2);
    }
  }, m2 = (r3) => r3.done ? s2(r3.value) : Promise.resolve(r3.value).then(t, o2);
  m2((e2 = e2.apply(n4, a2)).next());
});
typeof window != "undefined" && (window.__ORDERLY_VERSION__ = window.__ORDERLY_VERSION__ || {}, window.__ORDERLY_VERSION__["@orderly.network/default-solana-adapter"] = "2.2.0");
var oe$8 = { version: "0.1.0", name: "solana_vault", instructions: [{ name: "initVault", accounts: [{ name: "signer", isMut: true, isSigner: true }, { name: "vaultAuthority", isMut: true, isSigner: false }, { name: "systemProgram", isMut: false, isSigner: false }], args: [{ name: "params", type: { defined: "InitVaultParams" } }] }, { name: "deposit", accounts: [{ name: "user", isMut: true, isSigner: true }, { name: "userTokenAccount", isMut: true, isSigner: false }, { name: "vaultAuthority", isMut: true, isSigner: false }, { name: "vaultTokenAccount", isMut: true, isSigner: false }, { name: "depositToken", isMut: false, isSigner: false }, { name: "peer", isMut: false, isSigner: false }, { name: "enforcedOptions", isMut: false, isSigner: false }, { name: "oappConfig", isMut: false, isSigner: false }, { name: "allowedBroker", isMut: false, isSigner: false }, { name: "allowedToken", isMut: false, isSigner: false }, { name: "tokenProgram", isMut: false, isSigner: false }, { name: "associatedTokenProgram", isMut: false, isSigner: false }, { name: "systemProgram", isMut: false, isSigner: false }], args: [{ name: "depositParams", type: { defined: "DepositParams" } }, { name: "oappParams", type: { defined: "OAppSendParams" } }], returns: { defined: "MessagingReceipt" } }, { name: "initOapp", accounts: [{ name: "payer", isMut: true, isSigner: true }, { name: "oappConfig", isMut: true, isSigner: false }, { name: "lzReceiveTypes", isMut: true, isSigner: false }, { name: "systemProgram", isMut: false, isSigner: false }], args: [{ name: "params", type: { defined: "InitOAppParams" } }] }, { name: "resetOapp", accounts: [{ name: "admin", isMut: true, isSigner: true }, { name: "oappConfig", isMut: true, isSigner: false }], args: [] }, { name: "reinitOapp", accounts: [{ name: "owner", isMut: true, isSigner: true }, { name: "oappConfig", isMut: true, isSigner: false }, { name: "vaultAuthority", isMut: false, isSigner: false }, { name: "systemProgram", isMut: false, isSigner: false }], args: [{ name: "params", type: { defined: "ReinitOAppParams" } }] }, { name: "resetVault", accounts: [{ name: "owner", isMut: true, isSigner: true }, { name: "vaultAuthority", isMut: true, isSigner: false }], args: [] }, { name: "reinitVault", accounts: [{ name: "admin", isMut: true, isSigner: true }, { name: "vaultAuthority", isMut: true, isSigner: false }, { name: "oappConfig", isMut: false, isSigner: false }, { name: "systemProgram", isMut: false, isSigner: false }], args: [{ name: "params", type: { defined: "ReinitVaultParams" } }] }, { name: "setBroker", accounts: [{ name: "admin", isMut: true, isSigner: true }, { name: "allowedBroker", isMut: true, isSigner: false }, { name: "oappConfig", isMut: false, isSigner: false }, { name: "systemProgram", isMut: false, isSigner: false }], args: [{ name: "params", type: { defined: "SetBrokerParams" } }] }, { name: "setToken", accounts: [{ name: "admin", isMut: true, isSigner: true }, { name: "allowedToken", isMut: true, isSigner: false }, { name: "oappConfig", isMut: false, isSigner: false }, { name: "mintAccount", isMut: false, isSigner: false }, { name: "systemProgram", isMut: false, isSigner: false }], args: [{ name: "params", type: { defined: "SetTokenParams" } }] }, { name: "setOrderDelivery", accounts: [{ name: "owner", isMut: true, isSigner: true }, { name: "vaultAuthority", isMut: true, isSigner: false }], args: [{ name: "params", type: { defined: "SetOrderDeliveryParams" } }] }, { name: "oappQuote", accounts: [{ name: "oappConfig", isMut: false, isSigner: false }, { name: "peer", isMut: false, isSigner: false }, { name: "enforcedOptions", isMut: false, isSigner: false }, { name: "vaultAuthority", isMut: false, isSigner: false }], args: [{ name: "params", type: { defined: "DepositParams" } }], returns: { defined: "MessagingFee" } }, { name: "lzReceive", accounts: [{ name: "payer", isMut: true, isSigner: true }, { name: "peer", isMut: false, isSigner: false }, { name: "oappConfig", isMut: false, isSigner: false }, { name: "user", isMut: false, isSigner: false, docs: ["CHECK"] }, { name: "userDepositWallet", isMut: true, isSigner: false }, { name: "vaultAuthority", isMut: true, isSigner: false }, { name: "vaultDepositWallet", isMut: true, isSigner: false }, { name: "depositToken", isMut: false, isSigner: false }, { name: "tokenProgram", isMut: false, isSigner: false }, { name: "systemProgram", isMut: false, isSigner: false }, { name: "eventAuthority", isMut: false, isSigner: false }, { name: "program", isMut: false, isSigner: false }], args: [{ name: "params", type: { defined: "OAppLzReceiveParams" } }] }, { name: "lzReceiveTypes", accounts: [{ name: "oappConfig", isMut: false, isSigner: false }], args: [{ name: "params", type: { defined: "OAppLzReceiveParams" } }], returns: { vec: { defined: "oapp::endpoint_cpi::LzAccount" } } }, { name: "setRateLimit", accounts: [{ name: "admin", isMut: false, isSigner: true }, { name: "peer", isMut: true, isSigner: false }, { name: "oappConfig", isMut: false, isSigner: false }], args: [{ name: "params", type: { defined: "SetRateLimitParams" } }] }, { name: "setDelegate", accounts: [{ name: "admin", isMut: false, isSigner: true }, { name: "oappConfig", isMut: false, isSigner: false }], args: [{ name: "params", type: { defined: "SetDelegateParams" } }] }, { name: "transferAdmin", accounts: [{ name: "admin", isMut: false, isSigner: true }, { name: "oappConfig", isMut: true, isSigner: false }], args: [{ name: "params", type: { defined: "TransferAdminParams" } }] }, { name: "setPeer", accounts: [{ name: "admin", isMut: true, isSigner: true }, { name: "peer", isMut: true, isSigner: false }, { name: "oappConfig", isMut: false, isSigner: false }, { name: "systemProgram", isMut: false, isSigner: false }], args: [{ name: "params", type: { defined: "SetPeerParams" } }] }, { name: "setEnforcedOptions", accounts: [{ name: "admin", isMut: true, isSigner: true }, { name: "enforcedOptions", isMut: true, isSigner: false }, { name: "oappConfig", isMut: false, isSigner: false }, { name: "systemProgram", isMut: false, isSigner: false }], args: [{ name: "params", type: { defined: "SetEnforcedOptionsParams" } }] }], accounts: [{ name: "enforcedOptions", type: { kind: "struct", fields: [{ name: "send", type: "bytes" }, { name: "sendAndCall", type: "bytes" }, { name: "bump", type: "u8" }] } }, { name: "oAppConfig", type: { kind: "struct", fields: [{ name: "endpointProgram", type: "publicKey" }, { name: "bump", type: "u8" }, { name: "admin", type: "publicKey" }, { name: "usdcHash", type: { array: ["u8", 32] } }, { name: "usdcMint", type: "publicKey" }] } }, { name: "oAppLzReceiveTypesAccounts", type: { kind: "struct", fields: [{ name: "oappConfig", type: "publicKey" }] } }, { name: "peer", type: { kind: "struct", fields: [{ name: "address", type: { array: ["u8", 32] } }, { name: "rateLimiter", type: { option: { defined: "RateLimiter" } } }, { name: "bump", type: "u8" }] } }, { name: "allowedBroker", type: { kind: "struct", fields: [{ name: "brokerHash", type: { array: ["u8", 32] } }, { name: "allowed", type: "bool" }, { name: "bump", type: "u8" }] } }, { name: "allowedToken", type: { kind: "struct", fields: [{ name: "mintAccount", type: "publicKey" }, { name: "tokenHash", type: { array: ["u8", 32] } }, { name: "tokenDecimals", type: "u8" }, { name: "allowed", type: "bool" }, { name: "bump", type: "u8" }] } }, { name: "vaultAuthority", type: { kind: "struct", fields: [{ name: "bump", docs: ["Bump seed for the vault authority PDA"], type: "u8" }, { name: "owner", type: "publicKey" }, { name: "depositNonce", type: "u64" }, { name: "orderDelivery", type: "bool" }, { name: "inboundNonce", type: "u64" }, { name: "dstEid", type: "u32" }, { name: "solChainId", type: "u128" }] } }], types: [{ name: "VaultDepositParams", type: { kind: "struct", fields: [{ name: "accountId", type: { array: ["u8", 32] } }, { name: "brokerHash", type: { array: ["u8", 32] } }, { name: "userAddress", type: { array: ["u8", 32] } }, { name: "tokenHash", type: { array: ["u8", 32] } }, { name: "srcChainId", type: "u128" }, { name: "tokenAmount", type: "u128" }, { name: "srcChainDepositNonce", type: "u64" }] } }, { name: "LzMessage", type: { kind: "struct", fields: [{ name: "msgType", type: "u8" }, { name: "payload", type: "bytes" }] } }, { name: "InitOAppParams", type: { kind: "struct", fields: [{ name: "admin", type: "publicKey" }, { name: "endpointProgram", type: { option: "publicKey" } }, { name: "usdcHash", type: { array: ["u8", 32] } }, { name: "usdcMint", type: "publicKey" }] } }, { name: "OAppLzReceiveParams", type: { kind: "struct", fields: [{ name: "srcEid", type: "u32" }, { name: "sender", type: { array: ["u8", 32] } }, { name: "nonce", type: "u64" }, { name: "guid", type: { array: ["u8", 32] } }, { name: "message", type: "bytes" }, { name: "extraData", type: "bytes" }] } }, { name: "AccountWithdrawSol", type: { kind: "struct", fields: [{ name: "accountId", type: { array: ["u8", 32] } }, { name: "sender", type: { array: ["u8", 32] } }, { name: "receiver", type: { array: ["u8", 32] } }, { name: "brokerHash", type: { array: ["u8", 32] } }, { name: "tokenHash", type: { array: ["u8", 32] } }, { name: "tokenAmount", type: "u64" }, { name: "fee", type: "u64" }, { name: "chainId", type: "u64" }, { name: "withdrawNonce", type: "u64" }] } }, { name: "VaultWithdrawParams", type: { kind: "struct", fields: [{ name: "accountId", type: { array: ["u8", 32] } }, { name: "sender", type: { array: ["u8", 32] } }, { name: "receiver", type: { array: ["u8", 32] } }, { name: "brokerHash", type: { array: ["u8", 32] } }, { name: "tokenHash", type: { array: ["u8", 32] } }, { name: "tokenAmount", type: "u64" }, { name: "fee", type: "u128" }, { name: "chainId", type: "u128" }, { name: "withdrawNonce", type: "u64" }] } }, { name: "MessagingFee", type: { kind: "struct", fields: [{ name: "nativeFee", type: "u64" }, { name: "lzTokenFee", type: "u64" }] } }, { name: "ReinitOAppParams", type: { kind: "struct", fields: [{ name: "admin", type: "publicKey" }, { name: "endpointProgram", type: { option: "publicKey" } }, { name: "usdcHash", type: { array: ["u8", 32] } }, { name: "usdcMint", type: "publicKey" }] } }, { name: "SetDelegateParams", type: { kind: "struct", fields: [{ name: "delegate", type: "publicKey" }] } }, { name: "SetEnforcedOptionsParams", type: { kind: "struct", fields: [{ name: "dstEid", type: "u32" }, { name: "send", type: "bytes" }, { name: "sendAndCall", type: "bytes" }] } }, { name: "SetPeerParams", type: { kind: "struct", fields: [{ name: "dstEid", type: "u32" }, { name: "peer", type: { array: ["u8", 32] } }] } }, { name: "SetRateLimitParams", type: { kind: "struct", fields: [{ name: "dstEid", type: "u32" }, { name: "refillPerSecond", type: { option: "u64" } }, { name: "capacity", type: { option: "u64" } }, { name: "enabled", type: "bool" }] } }, { name: "TransferAdminParams", type: { kind: "struct", fields: [{ name: "admin", type: "publicKey" }] } }, { name: "DepositParams", type: { kind: "struct", fields: [{ name: "accountId", type: { array: ["u8", 32] } }, { name: "brokerHash", type: { array: ["u8", 32] } }, { name: "tokenHash", type: { array: ["u8", 32] } }, { name: "userAddress", type: { array: ["u8", 32] } }, { name: "tokenAmount", type: "u64" }] } }, { name: "OAppSendParams", type: { kind: "struct", fields: [{ name: "nativeFee", type: "u64" }, { name: "lzTokenFee", type: "u64" }] } }, { name: "InitVaultParams", type: { kind: "struct", fields: [{ name: "owner", type: "publicKey" }, { name: "orderDelivery", type: "bool" }, { name: "dstEid", type: "u32" }, { name: "solChainId", type: "u128" }] } }, { name: "ReinitVaultParams", type: { kind: "struct", fields: [{ name: "owner", type: "publicKey" }, { name: "dstEid", type: "u32" }, { name: "depositNonce", type: "u64" }, { name: "orderDelivery", type: "bool" }, { name: "inboundNonce", type: "u64" }, { name: "solChainId", type: "u128" }] } }, { name: "SetBrokerParams", type: { kind: "struct", fields: [{ name: "brokerHash", type: { array: ["u8", 32] } }, { name: "allowed", type: "bool" }] } }, { name: "SetOrderDeliveryParams", type: { kind: "struct", fields: [{ name: "orderDelivery", type: "bool" }, { name: "nonce", type: "u64" }] } }, { name: "SetTokenParams", type: { kind: "struct", fields: [{ name: "mintAccount", type: "publicKey" }, { name: "tokenHash", type: { array: ["u8", 32] } }, { name: "allowed", type: "bool" }] } }, { name: "RateLimiter", type: { kind: "struct", fields: [{ name: "capacity", type: "u64" }, { name: "tokens", type: "u64" }, { name: "refillPerSecond", type: "u64" }, { name: "lastRefillTime", type: "u64" }] } }, { name: "OAppError", type: { kind: "enum", variants: [{ name: "Unauthorized" }, { name: "InvalidSender" }, { name: "InvalidOptions" }, { name: "InvalidEndpointProgram" }, { name: "RateLimitExceeded" }, { name: "WithdrawFailed" }, { name: "InvalidInboundNonce" }] } }, { name: "MsgType", type: { kind: "enum", variants: [{ name: "Deposit" }, { name: "Withdraw" }, { name: "RebalanceBurn" }, { name: "RebalanceMint" }] } }], events: [{ name: "SetAllowedBroker", fields: [{ name: "brokerHash", type: { array: ["u8", 32] }, index: false }] }, { name: "ResetAllowedBroker", fields: [{ name: "brokerHash", type: { array: ["u8", 32] }, index: false }] }, { name: "SetAllowedToken", fields: [{ name: "tokenHash", type: { array: ["u8", 32] }, index: false }, { name: "mintAccount", type: "publicKey", index: false }] }, { name: "ResetAllowedToken", fields: [{ name: "tokenHash", type: { array: ["u8", 32] }, index: false }, { name: "mintAccount", type: "publicKey", index: false }] }, { name: "Deposited", fields: [{ name: "user", type: "publicKey", index: false }, { name: "amount", type: "u64", index: false }] }, { name: "Withdrawn", fields: [{ name: "user", type: "publicKey", index: false }, { name: "amount", type: "u64", index: false }] }, { name: "VaultDeposited", fields: [{ name: "accountId", type: { array: ["u8", 32] }, index: false }, { name: "brokerHash", type: { array: ["u8", 32] }, index: false }, { name: "userAddress", type: { array: ["u8", 32] }, index: false }, { name: "tokenHash", type: { array: ["u8", 32] }, index: false }, { name: "srcChainId", type: "u128", index: false }, { name: "tokenAmount", type: "u64", index: false }, { name: "srcChainDepositNonce", type: "u64", index: false }] }, { name: "VaultWithdrawn", fields: [{ name: "accountId", type: { array: ["u8", 32] }, index: false }, { name: "sender", type: { array: ["u8", 32] }, index: false }, { name: "receiver", type: { array: ["u8", 32] }, index: false }, { name: "brokerHash", type: { array: ["u8", 32] }, index: false }, { name: "tokenHash", type: { array: ["u8", 32] }, index: false }, { name: "tokenAmount", type: "u64", index: false }, { name: "fee", type: "u128", index: false }, { name: "chainId", type: "u128", index: false }, { name: "withdrawNonce", type: "u64", index: false }] }, { name: "OAppSent", fields: [{ name: "guid", type: { array: ["u8", 32] }, index: false }, { name: "dstEid", type: "u32", index: false }] }, { name: "OAppReceived", fields: [{ name: "guid", type: { array: ["u8", 32] }, index: false }, { name: "srcEid", type: "u32", index: false }] }], errors: [{ code: 6e3, name: "InsufficientFunds", msg: "Deposited funds are insufficient for withdrawal" }, { code: 6001, name: "UserInfoBelongsToAnotherUser", msg: "User info pda belongs to another user" }, { code: 6002, name: "BrokerNotAllowed", msg: "Broker is not allowed" }, { code: 6003, name: "TokenNotAllowed", msg: "Token is not allowed" }, { code: 6004, name: "InvalidAccountId", msg: "AccountId is invalid" }, { code: 6005, name: "InvalidVaultOwner", msg: "Vault owner is not the same as the payer" }] };
var y$1 = new PublicKey("76y77prsiCMvXMjuoZ5VRrhG5qYBrUMYTE5WgHqgjEn6"), f$1 = new PublicKey("7a4WjyR8VZ7yZz5XJAKm39BUGn5iT9CKcv2pmG9tdXVH"), O$5 = new PublicKey("6doghB248px58JSSwG4qejQ46kFMW4AMj7vzJnWZHNZn"), I$4 = new PublicKey("8ahPGPjEbpgGaZx2NV1iG5Shj7TDwvsjkEDcGWjt94TP"), Le$5 = f$1, Ne$3 = f$1, C$2 = new PublicKey("HtEYV4xB4wvsj5fgTkcfuChYpvGYzgzwvNhgDZQNh7wW"), He$5 = "VaultAuthority", We$8 = "Broker", Ue$5 = "Token", ue$7 = addressToBytes32("0x9Dc724b24146BeDD2dA28b8C4B74126169B8f312"), Ve$4 = addressToBytes32("0x45b6C6266A7A2170617d8A27A50C642fd68b91c4"), Ge$3 = addressToBytes32("0x5Bf771A65d057e778C5f0Ed52A0003316f94322D"), Fe$6 = addressToBytes32("0xCecAe061aa078e13b5e70D5F9eCee90a3F2B6AeA"), ze$5 = 40200, Ye$5 = 30213, G$6 = new PublicKey("BWp8HaYYhiNHekt3zgQhqoCrRftneGxxfgKmCZ6svHN"), Qe$5 = new PublicKey("BswrQQoPKAFojTuJutZcBMtigAgTghEH4M8ofn3EG2X2"), je$5 = new PublicKey("BbGKfxuPwDmu58BjPpd7PMG69TqnZjSpKaLDMgf9E9Dr"), Ze$4 = new PublicKey("8iq7xCQt3bLdRRn4A46d5GuaXYinBoiAhbe2sUmZVzwg"), me$4 = new PublicKey("EYJq9eU4GMRUriUJBgGoZ8YLQBXcWaciXuSsEXE7ieQS"), de$6 = new PublicKey("5zBjLor7vEraAt4zp2H82sy9MSqFoDnNa1Lx6EYKTYRZ"), le$6 = new PublicKey("9shwxWDUNhtwkHocsUAmrNAQfBH2DHh4njdAEdHZZkF2"), F$4 = new PublicKey("ErBmAD61mGFKvrFNaTJuxoPwqrS8GgtwtqJTJVjFWx9Q");
var K$4 = (n4, a2) => getAssociatedTokenAddressSync(n4, a2, true);
function ce$a(n4) {
  return PublicKey.findProgramAddressSync([dist.Buffer.from(He$5, "utf8")], n4)[0];
}
function $e$7(n4, a2) {
  let e2 = Array.from(dist.Buffer.from(a2.slice(2), "hex"));
  return PublicKey.findProgramAddressSync([dist.Buffer.from(We$8, "utf8"), dist.Buffer.from(e2)], n4)[0];
}
function en$3(n4, a2) {
  let e2 = Array.from(dist.Buffer.from(a2.slice(2), "hex"));
  return PublicKey.findProgramAddressSync([dist.Buffer.from(Ue$5, "utf8"), dist.Buffer.from(e2)], n4)[0];
}
function pe$4(n4) {
  return PublicKey.findProgramAddressSync([dist.Buffer.from(OAPP_SEED, "utf8")], n4)[0];
}
function fe$2(n4, a2, e2) {
  let s2 = dist.Buffer.alloc(4);
  return s2.writeUInt32BE(e2), PublicKey.findProgramAddressSync([dist.Buffer.from(PEER_SEED, "utf8"), a2.toBuffer(), s2], n4)[0];
}
function ye$4(n4, a2, e2) {
  let s2 = dist.Buffer.alloc(4);
  return s2.writeUInt32BE(e2), PublicKey.findProgramAddressSync([dist.Buffer.from(ENFORCED_OPTIONS_SEED, "utf8"), a2.toBuffer(), s2], n4)[0];
}
function nn$2() {
  return PublicKey.findProgramAddressSync([dist.Buffer.from(MESSAGE_LIB_SEED, "utf8")], f$1)[0];
}
function ge$3(n4, a2) {
  let e2 = dist.Buffer.alloc(4);
  return e2.writeUInt32BE(a2), PublicKey.findProgramAddressSync([dist.Buffer.from(SEND_LIBRARY_CONFIG_SEED, "utf8"), n4.toBuffer(), e2], y$1)[0];
}
function Se$6(n4) {
  let a2 = dist.Buffer.alloc(4);
  return a2.writeUInt32BE(n4), PublicKey.findProgramAddressSync([dist.Buffer.from(SEND_LIBRARY_CONFIG_SEED, "utf8"), a2], y$1)[0];
}
function an$2(n4) {
  return PublicKey.findProgramAddressSync([dist.Buffer.from(MESSAGE_LIB_SEED, "utf8"), n4.toBuffer()], y$1)[0];
}
function be$5() {
  return PublicKey.findProgramAddressSync([dist.Buffer.from(ENDPOINT_SEED, "utf8")], y$1)[0];
}
function Vn(n4) {
  let a2 = ue$7;
  return n4.toBase58() === me$4.toBase58() && (a2 = ue$7), n4.toBase58() === de$6.toBase58() && (a2 = Ve$4), n4.toBase58() === le$6.toBase58() && (a2 = Ge$3), n4.toBase58() === F$4.toBase58() && (a2 = Fe$6), a2;
}
function Ae$2(n4, a2, e2) {
  let s2 = dist.Buffer.alloc(4), i = Vn(n4);
  return s2.writeUInt32BE(e2), PublicKey.findProgramAddressSync([dist.Buffer.from(NONCE_SEED, "utf8"), a2.toBuffer(), s2, i], y$1)[0];
}
function tn$2() {
  return PublicKey.findProgramAddressSync([dist.Buffer.from(EVENT_SEED, "utf8")], y$1)[0];
}
function sn$1() {
  return PublicKey.findProgramAddressSync([dist.Buffer.from(ULN_SEED, "utf8")], f$1)[0];
}
function Pe$2(n4, a2) {
  let e2 = dist.Buffer.alloc(4);
  return e2.writeUInt32BE(a2), PublicKey.findProgramAddressSync([dist.Buffer.from(SEND_CONFIG_SEED, "utf8"), e2, n4.toBuffer()], f$1)[0];
}
function ke$4(n4) {
  let a2 = dist.Buffer.alloc(4);
  return a2.writeUInt32BE(n4), PublicKey.findProgramAddressSync([dist.Buffer.from(SEND_CONFIG_SEED, "utf8"), a2], Le$5)[0];
}
function rn$2() {
  return PublicKey.findProgramAddressSync([dist.Buffer.from(EVENT_SEED, "utf8")], f$1)[0];
}
function he$5() {
  return PublicKey.findProgramAddressSync([dist.Buffer.from(EXECUTOR_CONFIG_SEED, "utf8")], O$5)[0];
}
function De$5() {
  return PublicKey.findProgramAddressSync([dist.Buffer.from(PRICE_FEED_SEED, "utf8")], I$4)[0];
}
function Ee$3() {
  return PublicKey.findProgramAddressSync([dist.Buffer.from(DVN_CONFIG_SEED, "utf8")], C$2)[0];
}
function Me$6(n4) {
  return n4.toBase58() === F$4.toBase58() ? Ye$5 : ze$5;
}
function Ie$5(n4) {
  return n4.toBase58() === me$4.toBase58() ? (console.log("DEV_LOOKUP_TABLE_ADDRESS: ", G$6.toBase58()), G$6) : n4.toBase58() === de$6.toBase58() ? Qe$5 : n4.toBase58() === le$6.toBase58() ? je$5 : n4.toBase58() === F$4.toBase58() ? Ze$4 : G$6;
}
function on$2(n4) {
  return PublicKey.findProgramAddressSync([dist.Buffer.from(MESSAGE_LIB_SEED, "utf8")], n4 || f$1)[0];
}
function un$1(n4, a2) {
  return PublicKey.findProgramAddressSync([dist.Buffer.from(MESSAGE_LIB_SEED, "utf8"), n4.toBytes()], y$1)[0];
}
function we$5(n4, a2) {
  return l(this, null, function* () {
    return (yield n4.getAddressLookupTable(a2)).value;
  });
}
function cn$1(n4) {
  let { publicKey: a2, brokerId: e2, expiration: s2 = 365, timestamp: i = Date.now(), scope: t, tag: o2, chainId: m2 } = n4, r3 = S$3(g$4({ brokerId: e2, chainType: "SOL", orderlyKey: a2, scope: t || "read,trading", chainId: m2, timestamp: i }, typeof o2 != "undefined" ? { tag: o2 } : {}), { expiration: i + 1e3 * 60 * 60 * 24 * s2 }), u2 = solidityPackedKeccak256(["string"], [r3.brokerId]), c = solidityPackedKeccak256(["string"], [r3.orderlyKey]), b2 = solidityPackedKeccak256(["string"], [r3.scope]), D2 = AbiCoder.defaultAbiCoder(), k2 = keccak256$1(hexToBytes(D2.encode(["bytes32", "bytes32", "bytes32", "uint256", "uint256", "uint256"], [u2, c, b2, r3.chainId, r3.timestamp, r3.expiration]))), E3 = bytesToHex(k2), M2 = new TextEncoder().encode(E3);
  return [r3, M2];
}
function pn$1(n4) {
  let { chainId: a2, registrationNonce: e2, brokerId: s2, timestamp: i } = n4, t = { brokerId: s2, chainId: a2, timestamp: i, registrationNonce: e2 }, o2 = solidityPackedKeccak256(["string"], [t.brokerId]), m2 = AbiCoder.defaultAbiCoder(), r3 = keccak256$1(hexToBytes(m2.encode(["bytes32", "uint256", "uint256", "uint256"], [o2, t.chainId, t.timestamp, t.registrationNonce]))), u2 = bytesToHex(r3), c = new TextEncoder().encode(u2);
  return [t, c];
}
function fn$1(n4) {
  let { chainId: a2, receiver: e2, token: s2, amount: i, nonce: t, brokerId: o2 } = n4, m2 = Date.now(), r3 = { brokerId: o2, chainId: a2, receiver: e2, token: s2, amount: i, withdrawNonce: t, timestamp: m2, chainType: "SOL" }, u2 = solidityPackedKeccak256(["string"], [r3.brokerId]), c = solidityPackedKeccak256(["string"], [r3.token]), b2 = keccak256$1(dist.Buffer.from("Orderly Network")), D2 = AbiCoder.defaultAbiCoder(), k2 = keccak256$1(hexToBytes(D2.encode(["bytes32", "bytes32", "uint256", "bytes32", "uint256", "uint64", "uint64", "bytes32"], [u2, c, a2, Gn$2(r3.receiver), r3.amount, r3.withdrawNonce, m2, b2]))), E3 = bytesToHex(k2), M2 = new TextEncoder().encode(E3);
  return [r3, M2];
}
function yn$2(n4) {
  let { settlePnlNonce: a2, brokerId: e2, chainId: s2, timestamp: i } = n4, t = { brokerId: e2, chainId: s2, timestamp: i, chainType: "SOL", settleNonce: a2 }, o2 = solidityPackedKeccak256(["string"], [e2]), m2 = AbiCoder.defaultAbiCoder(), r3 = keccak256$1(hexToBytes(m2.encode(["bytes32", "uint256", "uint64", "uint64"], [o2, t.chainId, t.settleNonce, t.timestamp]))), u2 = bytesToHex(r3), c = new TextEncoder().encode(u2);
  return [t, c];
}
function Te$5(i) {
  return l(this, arguments, function* ({ vaultAddress: n4, userAddress: a2, connection: e2, depositData: s2 }) {
    console.log("-- vaultAddress", n4);
    let t = new PublicKey(n4), o2 = Me$6(t), m2 = new ln$2(oe$8, t, { connection: e2 }), r3 = new PublicKey(a2), u2 = pe$4(t), c = fe$2(t, u2, o2), b2 = ye$4(t, u2, o2), D2 = ge$3(u2, o2), k2 = Se$6(o2), E3 = be$5(), M2 = Ae$2(t, u2, o2), Z2 = Pe$2(u2, o2), A2 = ke$4(o2), P2 = he$5(), N2 = De$5(), q2 = Ee$3(), H2 = on$2(f$1), X2 = un$1(H2), J2 = ce$a(t), $2 = gn$1(a2, s2), ee2 = yield m2.methods.oappQuote($2).accounts({ oappConfig: u2, peer: c, enforcedOptions: b2, vaultAuthority: J2 }).remainingAccounts([{ pubkey: y$1, isWritable: false, isSigner: false }, { pubkey: f$1, isWritable: false, isSigner: false }, { pubkey: D2, isWritable: false, isSigner: false }, { pubkey: k2, isWritable: false, isSigner: false }, { pubkey: X2, isWritable: false, isSigner: false }, { pubkey: E3, isWritable: false, isSigner: false }, { pubkey: M2, isWritable: false, isSigner: false }, { pubkey: H2, isWritable: false, isSigner: false }, { pubkey: Z2, isWritable: false, isSigner: false }, { pubkey: A2, isWritable: false, isSigner: false }, { pubkey: O$5, isWritable: false, isSigner: false }, { pubkey: P2, isWritable: false, isSigner: false }, { pubkey: I$4, isWritable: false, isSigner: false }, { pubkey: N2, isWritable: false, isSigner: false }, { pubkey: C$2, isWritable: false, isSigner: false }, { pubkey: q2, isWritable: false, isSigner: false }, { pubkey: I$4, isWritable: false, isSigner: false }, { pubkey: N2, isWritable: false, isSigner: false }]).instruction(), ne2 = yield e2.getLatestBlockhash(), ae2 = Ie$5(t), W2 = yield we$5(e2, ae2);
    if (!W2) throw console.log("-- lookup table account error"), new Error("-- lookup table account error");
    let te3 = new TransactionMessage({ payerKey: r3, recentBlockhash: ne2.blockhash, instructions: [ee2] }).compileToV0Message([W2]), se2 = new VersionedTransaction(te3), h2 = yield e2.simulateTransaction(se2);
    if (console.log("-- feeRes", h2), h2.value.err) {
      let x2 = typeof h2.value.err == "object" ? JSON.stringify(h2.value.err) : h2.value.err;
      throw x2.toString().includes("AccountNotFound") ? new Error("Error: Account gas is insufficient.") : new Error(`Error: ${x2}`);
    }
    let U2 = `Program return: ${m2.programId} `, R2 = h2.value.logs.find((x2) => x2.startsWith(U2));
    if (!R2) throw new Error("Error: get deposit fee error");
    let re2 = R2.slice(U2.length), T2 = dist.Buffer.from(re2, "base64");
    return console.log(T2.readBigUInt64LE(0), T2.readBigUInt64LE(1)), T2.readBigUInt64LE(0);
  });
}
var gn$1 = (n4, a2) => {
  let e2 = a2.brokerHash, s2 = Array.from(dist.Buffer.from(e2.slice(2), "hex")), i = a2.tokenHash, t = Array.from(dist.Buffer.from(i.slice(2), "hex")), o2 = a2.accountId, m2 = Array.from(dist.Buffer.from(o2.slice(2), "hex")), r3 = new PublicKey(n4);
  return { accountId: m2, brokerHash: s2, tokenHash: t, userAddress: Array.from(r3.toBuffer()), tokenAmount: new _e$5(a2.tokenAmount) };
};
function Sn$3(t) {
  return l(this, arguments, function* ({ vaultAddress: n4, userAddress: a2, connection: e2, sendTransaction: s2, depositData: i }) {
    let o2 = i.brokerHash, m2 = i.tokenHash;
    console.log("-- vault address", n4);
    let r3 = new PublicKey(n4), u2 = new ln$2(oe$8, r3, { connection: e2 }), c = new PublicKey(i.USDCAddress), b2 = new PublicKey(a2), D2 = K$4(c, b2), k2 = ce$a(r3), E3 = K$4(c, k2), M2 = $e$7(r3, o2), Z2 = en$3(r3, m2), A2 = pe$4(r3);
    console.log("-- oappconfig pda", A2.toBase58());
    let P2 = Me$6(r3), N2 = fe$2(r3, A2, P2), q2 = ye$4(r3, A2, P2), H2 = nn$2(), X2 = ge$3(A2, P2), J2 = Se$6(P2), $2 = an$2(H2), ee2 = be$5(), ne2 = Ae$2(r3, A2, P2), ae2 = tn$2(), W2 = sn$1(), te3 = Pe$2(A2, P2), se2 = ke$4(P2), h2 = rn$2(), U2 = he$5(), R2 = De$5(), re2 = Ee$3(), T2 = gn$1(a2, i), x2 = yield Te$5({ vaultAddress: n4, userAddress: a2, connection: e2, depositData: i }), Re2 = { nativeFee: new _e$5(x2.toString()), lzTokenFee: new _e$5(0) };
    console.log("--- value params", { vaultDepositParams: T2, sendParam: Re2 });
    let Pn2 = yield u2.methods.deposit(T2, Re2).accounts({ userTokenAccount: D2, vaultAuthority: k2, vaultTokenAccount: E3, depositToken: c, user: b2, peer: N2, enforcedOptions: q2, oappConfig: A2, allowedBroker: M2, allowedToken: Z2 }).remainingAccounts([{ isSigner: false, isWritable: false, pubkey: y$1 }, { isSigner: false, isWritable: false, pubkey: A2 }, { isSigner: false, isWritable: false, pubkey: f$1 }, { isSigner: false, isWritable: false, pubkey: X2 }, { isSigner: false, isWritable: false, pubkey: J2 }, { isSigner: false, isWritable: false, pubkey: $2 }, { isSigner: false, isWritable: false, pubkey: ee2 }, { isSigner: false, isWritable: true, pubkey: ne2 }, { isSigner: false, isWritable: false, pubkey: ae2 }, { isSigner: false, isWritable: false, pubkey: y$1 }, { isSigner: false, isWritable: false, pubkey: W2 }, { isSigner: false, isWritable: false, pubkey: te3 }, { isSigner: false, isWritable: false, pubkey: se2 }, { isSigner: true, isWritable: false, pubkey: b2 }, { isSigner: false, isWritable: false, pubkey: Ne$3 }, { isSigner: false, isWritable: false, pubkey: SystemProgram.programId }, { isSigner: false, isWritable: false, pubkey: h2 }, { isSigner: false, isWritable: false, pubkey: f$1 }, { isSigner: false, isWritable: false, pubkey: O$5 }, { isSigner: false, isWritable: true, pubkey: U2 }, { isSigner: false, isWritable: false, pubkey: I$4 }, { isSigner: false, isWritable: false, pubkey: R2 }, { isSigner: false, isWritable: false, pubkey: C$2 }, { isSigner: false, isWritable: true, pubkey: re2 }, { isSigner: false, isWritable: false, pubkey: I$4 }, { isSigner: false, isWritable: false, pubkey: R2 }]).instruction(), kn2 = Ie$5(r3), Oe2 = yield we$5(e2, kn2);
    if (!Oe2) {
      console.log("-- lookup table account error");
      return;
    }
    let hn2 = ComputeBudgetProgram.setComputeUnitLimit({ units: 4e5 }), Dn2 = yield e2.getLatestBlockhash(), En2 = new TransactionMessage({ payerKey: b2, recentBlockhash: Dn2.blockhash, instructions: [Pn2, hn2] }).compileToV0Message([Oe2]), Mn2 = new VersionedTransaction(En2), Ce3 = yield s2(Mn2, e2);
    return console.log("res", Ce3), Ce3;
  });
}
function bn$2(n4) {
  let a2 = window.localStorage.getItem(LedgerWalletKey);
  if (!a2) return false;
  let e2 = JSON.parse(a2 != null ? a2 : "[]");
  return console.log("-- addressArr", e2), !!e2.includes(n4);
}
var ve$6 = class ve extends Mt$5 {
  constructor() {
    super();
    B$6(this, "chainNamespace", ChainNamespace.solana);
    B$6(this, "_address");
    B$6(this, "_chainId");
    B$6(this, "_provider");
    B$6(this, "_connection");
  }
  get address() {
    return this._address;
  }
  get chainId() {
    return this._chainId;
  }
  set chainId(e2) {
    this._chainId = e2;
  }
  get connection() {
    if (this._connection) return this._connection;
    if (this._provider.rpcUrl) return this._connection = new Connection(this._provider.rpcUrl, { commitment: "confirmed" }), this._connection;
    if (this._provider.network === WalletAdapterNetwork.Devnet) return this._connection = new Connection(clusterApiUrl(this._provider.network), { commitment: "confirmed" }), this._connection;
    let e2 = Ia$1.get("account"), s2 = "/v1/solana-rpc-proxy";
    return this._connection = new Connection(`${e2.apiBaseUrl}${s2}`, { commitment: "confirmed", fetchMiddleware: (i, t, o2) => l(this, null, function* () {
      let m2 = { url: s2, method: t == null ? void 0 : t.method, data: JSON.parse(t == null ? void 0 : t.body) }, r3 = yield this.signMessageByOrderlyKey(m2);
      for (let u2 of Object.keys(r3)) (t == null ? void 0 : t.headers)[u2] = r3[u2];
      return o2(i, t);
    }) }), this._connection;
  }
  setConfig(e2) {
    this._address = e2.address, this._chainId = e2.chain.id, e2.provider && (this._provider = e2.provider);
  }
  lifecycleName(e2, s2) {
    console.log("lifecycle", e2, s2);
  }
  active(e2) {
    this.setConfig(e2), this.lifecycleName("active", e2);
  }
  deactivate() {
    this.lifecycleName("deactivate", {});
  }
  update(e2) {
    this.lifecycleName("update", e2), this.setConfig(e2);
  }
  generateSecretKey() {
    let e2, s2;
    do
      e2 = P$4.utils.randomPrivateKey(), s2 = Xn$2(e2);
    while (s2.length !== 44);
    return s2;
  }
  uint8ArrayToHexString(e2) {
    return Array.from(e2).map((s2) => s2.toString(16).padStart(2, "0")).join("");
  }
  signMessage(e2) {
    return l(this, null, function* () {
      if (bn$2(this._address)) {
        let t = new Transaction$1();
        t.add(new TransactionInstruction({ keys: [], programId: new PublicKey("ComputeBudget111111111111111111111111111111"), data: new Uint8Array([3, 0, 0, 0, 0, 0, 0, 0, 0]) })), t.add(new TransactionInstruction({ keys: [], programId: new PublicKey("ComputeBudget111111111111111111111111111111"), data: new Uint8Array([2, 0, 0, 0, 0]) })), t.add(new TransactionInstruction({ keys: [], programId: new PublicKey("MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr"), data: e2 }));
        let o2 = new PublicKey(this.address);
        t.feePayer = o2;
        let m2 = new Uint8Array(32).fill(0);
        t.recentBlockhash = new PublicKey(m2).toString();
        let u2 = (yield this._provider.signTransaction(t)).signatures[0].signature;
        if (u2) return this.uint8ArrayToHexString(u2);
        throw console.log("-- sign message error", u2), new Error("Unsupported signature");
      }
      let i = yield this._provider.signMessage(e2);
      return "0x" + bytesToHex(i);
    });
  }
  generateRegisterAccountMessage(e2) {
    return l(this, null, function* () {
      let [s2, i] = pn$1(S$3(g$4({}, e2), { chainId: this.chainId })), t = yield this.signMessage(i);
      return { message: S$3(g$4({}, s2), { chainType: "SOL" }), signatured: t };
    });
  }
  generateWithdrawMessage(e2) {
    return l(this, null, function* () {
      let [s2, i] = fn$1(S$3(g$4({}, e2), { chainId: this.chainId })), t = yield this.signMessage(i);
      return { message: S$3(g$4({}, s2), { chainType: "SOL" }), domain: { name: "", version: "", chainId: this.chainId, verifyingContract: e2.verifyContract }, signatured: t };
    });
  }
  generateAddOrderlyKeyMessage(e2) {
    return l(this, null, function* () {
      let [s2, i] = cn$1(S$3(g$4({}, e2), { chainId: this.chainId })), t = yield this.signMessage(i);
      return { message: S$3(g$4({}, s2), { chainType: "SOL" }), signatured: t };
    });
  }
  generateSettleMessage(e2) {
    return l(this, null, function* () {
      let [s2, i] = yn$2(S$3(g$4({}, e2), { chainId: this.chainId })), t = yield this.signMessage(i);
      return { message: S$3(g$4({}, s2), { chainType: "SOL" }), domain: { name: "", version: "", chainId: this.chainId, verifyingContract: e2.verifyContract }, signatured: t };
    });
  }
  getBalance() {
    return l(this, null, function* () {
      return BigInt(0);
    });
  }
  call(e2, s2, i, t) {
    return l(this, null, function* () {
      if (s2 === "balanceOf") {
        let o2 = new PublicKey(e2), m2 = new PublicKey(this._address), r3 = K$4(o2, m2), u2 = this.connection;
        return (yield getAccount(u2, r3, "confirmed")).amount;
      }
      return s2 === "allowance" ? MaxUint256 : BigInt(0);
    });
  }
  sendTransaction(e2, s2, i, t) {
    return l(this, null, function* () {
      if (console.log("-- solanan sendTransaction", { contractAddress: e2, method: s2, payload: i, options: t }), s2 === "deposit") return Sn$3({ vaultAddress: e2, userAddress: this._address, connection: this.connection, depositData: i.data[0], sendTransaction: this._provider.sendTransaction });
    });
  }
  callOnChain(e2, s2, i, t, o2) {
    return l(this, null, function* () {
      return console.log("-- params ", { chain: e2, address: s2, method: i, params: t }), i === "getDepositFee" ? Te$5({ vaultAddress: s2, userAddress: this._address, connection: this.connection, depositData: t[1] }) : 0;
    });
  }
  pollTransactionReceiptWithBackoff(e2, s2, i, t) {
    return l(this, null, function* () {
      return Promise.resolve({ status: 1 });
    });
  }
};
var P$2 = Object.defineProperty;
var u$2 = (d2, r3, t) => r3 in d2 ? P$2(d2, r3, { enumerable: true, configurable: true, writable: true, value: t }) : d2[r3] = t;
var p$1 = (d2, r3, t) => (u$2(d2, typeof r3 != "symbol" ? r3 + "" : r3, t), t);
var g$3 = (d2, r3, t) => new Promise((e2, s2) => {
  var o2 = (i) => {
    try {
      n4(t.next(i));
    } catch (a2) {
      s2(a2);
    }
  }, c = (i) => {
    try {
      n4(t.throw(i));
    } catch (a2) {
      s2(a2);
    }
  }, n4 = (i) => i.done ? e2(i.value) : Promise.resolve(i.value).then(o2, c);
  n4((t = t.apply(d2, r3)).next());
});
var v$1 = class v {
  constructor() {
    p$1(this, "_provider");
    p$1(this, "_originalProvider");
  }
  parseUnits(r3, t) {
    return parseUnits$1(r3, t).toString();
  }
  formatUnits(r3, t) {
    return formatUnits(r3, t);
  }
  set provider(r3) {
    this._provider = new BrowserProvider(r3, "any"), this._originalProvider = r3;
  }
  get browserProvider() {
    if (!this._provider) throw new Error("browserProvider is not initialized");
    return this._provider;
  }
  signTypedData(r3, t) {
    return g$3(this, null, function* () {
      var e2;
      return yield (e2 = this.browserProvider) == null ? void 0 : e2.send("eth_signTypedData_v4", [r3, t]);
    });
  }
  call(r3, t, e2, s2) {
    return g$3(this, null, function* () {
      let o2 = ["approve"];
      if (this._originalProvider.agwWallet && o2.includes(t)) try {
        return { hash: yield this._originalProvider.writeContract({ abi: s2.abi, address: r3, functionName: t, args: e2 }) };
      } catch (i) {
        let a2 = getParsedEthersError(i);
        throw i.message.includes("rejected") ? new Error({ content: "REJECTED_TRANSACTION" }) : a2;
      }
      let c = yield this.browserProvider.getSigner();
      return new Contract(r3, s2.abi, c)[t].apply(null, e2).catch((i) => {
        throw getParsedEthersError(i);
      });
    });
  }
  send(r3, t) {
    return this.browserProvider.send(r3, t);
  }
  sendTransaction(r3, t, e2, s2) {
    return g$3(this, null, function* () {
      var a2;
      let o2 = yield (a2 = this.browserProvider) == null ? void 0 : a2.getSigner();
      if (!o2) throw new Error("singer is not exist");
      let n4 = new Contract(r3, s2.abi, this.browserProvider).interface.encodeFunctionData(t, e2.data), i = { from: e2.from, to: e2.to, data: n4, value: e2.value };
      try {
        return t === "depositTo" ? yield this._originalProvider.sendTransaction({ to: r3, data: n4, value: e2.value }) : yield o2.sendTransaction(i);
      } catch (l2) {
        throw getParsedEthersError(l2);
      }
    });
  }
  pollTransactionReceiptWithBackoff(r3, t = 1e3, e2 = 6e3, s2 = 30) {
    return g$3(this, null, function* () {
      let o2 = t, c = 0;
      for (; c < s2; ) {
        try {
          let n4 = yield this.browserProvider.getTransactionReceipt(r3);
          if (n4) return n4;
        } catch (n4) {
        }
        yield new Promise((n4) => setTimeout(n4, o2)), o2 = Math.min(o2 * 2, e2), c++;
      }
      throw new Error("Transaction did not complete after maximum retries.");
    });
  }
  callOnChain(r3, t, e2, s2, o2) {
    let c = new JsonRpcProvider(r3.public_rpc_url);
    return new Contract(t, o2.abi, c)[e2].apply(null, s2).catch((i) => {
      throw getParsedEthersError(i);
    });
  }
  getBalance(r3) {
    return this.browserProvider.getBalance(r3).then((t) => t);
  }
};
const { debounce } = ((_k = (_j = __cjsInterop1__$2) == null ? void 0 : _j.default) == null ? void 0 : _k.__esModule) ? __cjsInterop1__$2.default : __cjsInterop1__$2;
var __defProp2 = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp2(target, name, { get: all[name], enumerable: true });
};
if (typeof window !== "undefined") {
  window.__ORDERLY_VERSION__ = window.__ORDERLY_VERSION__ || {};
  window.__ORDERLY_VERSION__["@orderly.network/hooks"] = "2.2.0";
}
var version_default = "2.2.0";
var fetcher = (url, init2 = {}, queryOptions) => get(url, init2, queryOptions == null ? void 0 : queryOptions.formatter);
var OrderlyContext = createContext({
  // configStore: new MemoryConfigStore(),
});
var OrderlyProvider = OrderlyContext.Provider;
function useConfig(key, defaultValue) {
  const { configStore } = useContext(OrderlyContext);
  if (!configStore) {
    throw new SDKError(
      "useConfig must be used within OrderlyConfigProvider or OrderlyAppProvider"
    );
  }
  if (typeof key !== "undefined") {
    return configStore.get(key);
  }
  return configStore;
}
var useQuery = (query, options) => {
  const apiBaseUrl = useConfig("apiBaseUrl");
  const { formatter, ...swrOptions } = options || {};
  if (typeof apiBaseUrl === "undefined") {
    throw new SDKError("please add OrderlyConfigProvider to your app");
  }
  return useSWR(
    query,
    (url, init2) => fetcher(url.startsWith("http") ? url : `${apiBaseUrl}${url}`, init2, {
      formatter
    }),
    swrOptions
  );
};
var useLazyQuery = (query, options) => {
  const apiBaseUrl = useConfig("apiBaseUrl");
  const { formatter, init: init2, ...swrOptions } = {};
  if (typeof apiBaseUrl === "undefined") {
    throw new SDKError("please add OrderlyConfigProvider to your app");
  }
  return useSWRMutation(
    query,
    (url, options2) => {
      url = url.startsWith("http") ? url : `${apiBaseUrl}${url}`;
      if (options2 == null ? void 0 : options2.arg) {
        const queryString = Object.entries(options2.arg).map(
          ([key, value]) => `${key}=${encodeURIComponent(value)}`
        ).join("&");
        url = `${url}?${queryString}`;
      }
      return fetcher(url, init2, {
        formatter
      });
    },
    swrOptions
  );
};
var useAccountInstance = () => {
  const { configStore, keyStore, walletAdapters } = useContext(OrderlyContext);
  if (!configStore)
    throw new SDKError(
      "configStore is not defined, please use OrderlyProvider"
    );
  if (!keyStore) {
    throw new SDKError(
      "keyStore is not defined, please use OrderlyProvider and provide keyStore"
    );
  }
  const account5 = useConstant(() => {
    let account6 = Ia$1.get("account");
    if (!account6) {
      account6 = new _t$3(
        configStore,
        keyStore,
        // getWalletAdapter,
        walletAdapters
      );
      Ia$1.registerByName("account", account6);
    }
    return account6;
  });
  return account5;
};
var fetcher2 = (url, options) => {
  const init2 = {
    method: options.arg.method,
    headers: {
      ...options.arg.signature
    }
  };
  if (options.arg.data) {
    init2.body = JSON.stringify(options.arg.data);
  }
  if (typeof options.arg.params === "object" && Object.keys(options.arg.params).length) {
    let search = new URLSearchParams(options.arg.params);
    url = `${url}?${search.toString()}`;
  }
  return mutate(url, init2);
};
var useMutation = (url, method = "POST", options) => {
  const apiBaseUrl = useConfig("apiBaseUrl");
  let fullUrl = url;
  if (!url.startsWith("http")) {
    fullUrl = `${apiBaseUrl}${url}`;
  }
  const account5 = useAccountInstance();
  const { trigger, data, error, reset, isMutating } = useSWRMutation(
    fullUrl,
    // method === "POST" ? fetcher : deleteFetcher,
    fetcher2,
    options
  );
  const mutation = async (data2, params, options2) => {
    let newUrl = url;
    if (typeof params === "object" && Object.keys(params).length) {
      let search = new URLSearchParams(params);
      newUrl = `${url}?${search.toString()}`;
    }
    const payload = {
      method,
      url: newUrl,
      data: data2
    };
    const signer = account5.signer;
    const signature = await signer.sign(payload, T$1());
    return trigger(
      {
        data: data2,
        params,
        method,
        signature: {
          ...signature,
          "orderly-account-id": account5.accountId
        }
      },
      options2
    );
  };
  return [
    mutation,
    {
      data,
      error,
      reset,
      isMutating
    }
  ];
};
var signatureMiddleware = (useSWRNext) => {
  const apiBaseUrl = useConfig("apiBaseUrl");
  return (key, fetcher3, config2) => {
    try {
      const extendedFetcher = async (args) => {
        let url = Array.isArray(args) ? args[0] : args;
        let account5 = Ia$1.get("account");
        let fullUrl = `${apiBaseUrl}${url}`;
        const signer = account5.signer;
        const payload = {
          method: "GET",
          url
        };
        const signature = await signer.sign(payload, T$1());
        return fetcher3(fullUrl, {
          headers: {
            ...signature,
            "orderly-account-id": account5.accountId
          }
        });
      };
      return useSWRNext(key, extendedFetcher, config2);
    } catch (e2) {
      throw e2;
    }
  };
};
var useEventEmitter = () => {
  return useConstant(() => {
    let ee2 = Ia$1.get("EE");
    if (!ee2) {
      ee2 = new Na();
      Ia$1.registerByName("EE", ee2);
    }
    return ee2;
  });
};
var WalletConnectorContext = createContext({});
var useWalletConnector = () => {
  return useContext(WalletConnectorContext);
};
var useTrack = () => {
  const ee2 = useEventEmitter();
  const { wallet } = useWalletConnector();
  const tracking = useCallback(
    (eventName, params) => {
      w$4(() => {
        const location = window.location;
        const origin = location.origin;
        const url = location.pathname;
        const title = document.title;
        const userAgent = window.navigator.userAgent;
        Object.assign(params, {
          page_title: title,
          page_url: url,
          page_domain: origin,
          user_agent: userAgent
        });
        if (eventName === TrackerEventName.placeOrderSuccess) {
          Object.assign(params, {
            wallet: (wallet == null ? void 0 : wallet.label) || "QR code"
          });
        }
        ee2.emit(eventName, params);
      });
    },
    [wallet]
  );
  const track2 = useCallback(debounce(tracking, 500), [tracking]);
  const setTrackUserId = useCallback((userId) => {
    ee2.emit(TrackerEventName.trackIdentifyUserId, userId);
  }, []);
  const setIdentify = useCallback((params) => {
    ee2.emit(TrackerEventName.trackIdentify, params);
  }, []);
  return {
    track: track2,
    tracking,
    setTrackUserId,
    setIdentify
  };
};
var useAccount = () => {
  const {
    configStore,
    keyStore
    // onWalletConnect,
    // onWalletDisconnect,
    // onSetChain,
  } = useContext(OrderlyContext);
  if (!configStore)
    throw new SDKError(
      "configStore is not defined, please use OrderlyProvider"
    );
  if (!keyStore) {
    throw new SDKError(
      "keyStore is not defined, please use OrderlyProvider and provide keyStore"
    );
  }
  const account5 = useAccountInstance();
  const [state, setState] = useState(account5.stateValue);
  const { track: track2 } = useTrack();
  const statusChangeHandler = (nextState) => {
    setState(() => nextState);
  };
  useEffect(() => {
    account5.on("change:status", statusChangeHandler);
    return () => {
      account5.off("change:status", statusChangeHandler);
    };
  }, []);
  const createOrderlyKey = useCallback(
    async (remember) => {
      var _a3;
      track2(TrackerEventName.signinSuccess, {
        network: account5.chainId,
        wallet: (_a3 = state.connectWallet) == null ? void 0 : _a3.name
      });
      return account5.createOrderlyKey(remember ? 365 : 30);
    },
    [account5, state]
  );
  const createAccount = useCallback(async () => {
    return account5.createAccount();
  }, [account5]);
  return {
    account: account5,
    state,
    // info: {},
    // login,
    createOrderlyKey,
    createAccount
    // disconnect,
    // connect,
    // setChain,
    // settlement,
  };
};
var usePrivateQuery = (query, options) => {
  const { formatter, ...swrOptions } = options || {};
  const { state } = useAccount();
  const middleware = Array.isArray(options == null ? void 0 : options.use) ? (options == null ? void 0 : options.use) ?? [] : [];
  return useSWR(
    () => state.status >= AccountStatusEnum.EnableTrading || state.status === AccountStatusEnum.EnableTradingWithoutConnected ? [query, state.accountId] : null,
    (url, init2) => {
      return fetcher(url, init2, { formatter });
    },
    {
      ...swrOptions,
      use: [signatureMiddleware, ...middleware],
      onError: (err) => {
      }
    }
  );
};
var usePrivateInfiniteQuery = (getKey, options) => {
  const { formatter, ...restOptions } = options || {};
  const { state } = useAccount();
  const middleware = Array.isArray(restOptions == null ? void 0 : restOptions.use) ? (restOptions == null ? void 0 : restOptions.use) ?? [] : [];
  const result = useSWRInfinite(
    (pageIndex, previousPageData) => {
      const queryKey = getKey(pageIndex, previousPageData);
      if (queryKey && (state.status >= AccountStatusEnum.EnableTrading || state.status === AccountStatusEnum.EnableTradingWithoutConnected)) {
        return [queryKey, state.accountId];
      }
      return null;
    },
    (url, init2) => {
      var _a3;
      return ((_a3 = restOptions.fetcher) == null ? void 0 : _a3.call(restOptions, url, init2)) || get(url, init2, formatter);
    },
    {
      ...restOptions,
      use: [signatureMiddleware, ...middleware]
    }
  );
  return result;
};
var usePreLoadData = () => {
  const [timestampOffsetInitialized, setTimestampOffsetInitialized] = useState(false);
  const { error: tokenError, data: tokenData } = useQuery(
    "https://api.orderly.org/v1/public/token",
    {
      revalidateOnFocus: false
    }
  );
  const apiBaseUrl = useConfig("apiBaseUrl");
  const { data: systemInfo } = useSWR(
    "/v1/public/system_info",
    async (url, init2) => {
      const data = await fetch(
        url.startsWith("http") ? url : `${apiBaseUrl}${url}`,
        init2
      );
      return await data.json();
    },
    {
      errorRetryCount: 3,
      errorRetryInterval: 500
    }
  );
  useEffect(() => {
    if (timestampOffsetInitialized)
      return;
    if (typeof systemInfo !== "undefined") {
      const sd2 = systemInfo.timestamp;
      const ld = Date.now();
      const diff = sd2 - ld;
      if (isNaN(diff)) {
        return;
      }
      l$1().__ORDERLY_timestamp_offset = diff;
      setTimestampOffsetInitialized(true);
    }
  }, [systemInfo, timestampOffsetInitialized]);
  const isDone = useMemo(() => {
    return !!tokenData && timestampOffsetInitialized;
  }, [timestampOffsetInitialized, tokenData]);
  return {
    error: tokenError,
    done: isDone
  };
};
function parseJSON(value) {
  try {
    return value === "undefined" ? void 0 : JSON.parse(value ?? "");
  } catch {
    return void 0;
  }
}
function useSessionStorage(key, initialValue) {
  const readValue = useCallback(() => {
    if (typeof window === "undefined") {
      return initialValue;
    }
    try {
      const item = window.sessionStorage.getItem(key);
      return item ? parseJSON(item) : initialValue;
    } catch (error) {
      return initialValue;
    }
  }, [initialValue, key]);
  const [storedValue, setStoredValue] = useState(readValue);
  const setValue = (value) => {
    try {
      const newValue = value instanceof Function ? value(storedValue) : value;
      window.sessionStorage.setItem(key, JSON.stringify(newValue));
      setStoredValue(newValue);
    } catch (error) {
    }
  };
  useEffect(() => {
    setStoredValue(readValue());
  }, []);
  useEffect(() => {
    var _a3;
    if (typeof window == "undefined") {
      return;
    }
    (_a3 = window.addEventListener) == null ? void 0 : _a3.call(window, "storage", handleStorageChange);
    return () => {
      var _a4;
      (_a4 = window.removeEventListener) == null ? void 0 : _a4.call(window, "storage", handleStorageChange);
    };
  });
  const handleStorageChange = useCallback(
    (event) => {
      if ((event == null ? void 0 : event.key) && event.key !== key) {
        return;
      }
      setStoredValue(readValue());
    },
    [key, readValue]
  );
  return [storedValue, setValue];
}
function useLocalStorage(key, initialValue) {
  const readValue = useCallback(() => {
    if (typeof window === "undefined") {
      return initialValue;
    }
    try {
      const item = window.localStorage.getItem(key);
      return item ? parseJSON(item) : initialValue;
    } catch (error) {
      return initialValue;
    }
  }, [initialValue, key]);
  const [storedValue, setStoredValue] = useState(readValue);
  const setValue = useCallback(
    (value) => {
      try {
        const newValue = value instanceof Function ? value(storedValue) : value;
        window.localStorage.setItem(key, JSON.stringify(newValue));
        window.dispatchEvent(new Event("storage"));
        setStoredValue(() => newValue);
      } catch (error) {
      }
    },
    [storedValue]
  );
  useEffect(() => {
    setStoredValue(readValue());
  }, []);
  useEffect(() => {
    var _a3;
    const handleStorageChange = (event) => {
      if ((event == null ? void 0 : event.key) && event.key !== key) {
        return;
      }
      setStoredValue(readValue());
    };
    (_a3 = window == null ? void 0 : window.addEventListener) == null ? void 0 : _a3.call(window, "storage", handleStorageChange);
    return () => {
      var _a4;
      (_a4 = window == null ? void 0 : window.removeEventListener) == null ? void 0 : _a4.call(window, "storage", handleStorageChange);
    };
  }, [key]);
  return [storedValue, setValue];
}
var apiKeyMap = {
  dev: "4d6b7db0fdd6e9de2b6a270414fd51e0",
  qa: "96476b00bc2701360f9b480629ae5263",
  staging: "dffc00e003479b86d410c448e00f2304",
  prod: "3ab9ae56ed16cc57bc2ac97ffc1098c2"
};
var AmplitudeTracker = class {
  constructor(env, sdkInfo) {
    this._ee = Ia$1.get("EE");
    amplitude.init(apiKeyMap[env], { serverZone: "EU" });
    this.setSdkInfo(sdkInfo);
    this._bindEvents();
  }
  setUserId(userId) {
    if (userId === this._userId) {
      return;
    }
    amplitude.setUserId(userId);
    this._userId = userId;
  }
  setSdkInfo(sdkInfo) {
    if (this._sdkInfoTag && sdkInfo.address === this._sdkInfoTag)
      return;
    this.identify(sdkInfo);
    this._sdkInfoTag = sdkInfo.address;
  }
  identify(properties) {
    const identify2 = new amplitude.Identify();
    Object.entries(properties).forEach(([key, value]) => {
      identify2.set(key, value);
    });
    amplitude.identify(identify2);
  }
  track(eventName, properties) {
    amplitude.track(eventName, properties);
  }
  _bindEvents() {
    const listenKeys = Object.values(TrackerEventName);
    listenKeys.forEach((key) => {
      this._ee.addListener(key, (params = {}) => {
        if (key === TrackerEventName.trackIdentifyUserId) {
          this.setUserId(params);
        } else if (key === TrackerEventName.trackIdentify) {
          this.identify(params);
        } else if (key === TrackerEventName.trackCustomEvent) {
          const { eventName, ...rest } = params;
          if (!eventName) {
            return;
          }
          this.track(eventName, rest);
        } else {
          this.track(key, params);
        }
      });
    });
  }
};
AmplitudeTracker.instanceName = "amplitudeTracker";
var useTrackingInstance = () => {
  const { configStore } = useContext(OrderlyContext);
  if (!configStore)
    throw new Error("configStore is not defined, please use OrderlyProvider");
  const env = configStore.get("env");
  const brokerId = configStore.get("brokerId");
  const trackInstace = useConstant(() => {
    var _a3;
    let instance = Ia$1.get("amplitudeTracker");
    if (!instance) {
      instance = new AmplitudeTracker(env, {
        brokerId,
        sdk_version: ((_a3 = window == null ? void 0 : window.__ORDERLY_VERSION__) == null ? void 0 : _a3["@orderly.network/net"]) ?? ""
      });
      Ia$1.registerByName("instance", instance);
    }
    return instance;
  });
  return trackInstace;
};
var WS_NAME = "nativeWebsocketClient";
var useWS = () => {
  const { configStore } = useContext(OrderlyContext);
  const ws2 = useConstant(() => {
    let websocketClient = Ia$1.get(WS_NAME);
    const account5 = Ia$1.get(_t$3.instanceName);
    if (!websocketClient) {
      websocketClient = new WS({
        networkId: configStore.get("networkId"),
        publicUrl: configStore.get("publicWsUrl"),
        privateUrl: configStore.get("privateWsUrl"),
        onSigntureRequest: async (accountId) => {
          const signer = account5.signer;
          const timestamp = T$1();
          const result = await signer.signText(timestamp.toString());
          return { ...result, timestamp };
        }
      });
      if ((account5.stateValue.status === AccountStatusEnum.EnableTrading || account5.stateValue.status === AccountStatusEnum.EnableTradingWithoutConnected) && account5.stateValue.accountId) {
        websocketClient.openPrivate(account5.stateValue.accountId);
      }
      account5.on("change:status", (nextState) => {
        if ((nextState.status === AccountStatusEnum.EnableTrading || nextState.status === AccountStatusEnum.EnableTradingWithoutConnected) && nextState.accountId) {
          websocketClient.openPrivate(nextState.accountId);
        } else {
          websocketClient.closePrivate(1e3, "switch account");
        }
      });
      if (typeof window !== "undefined") {
        l$1()["__Orderly_WS"] = websocketClient;
      }
      Ia$1.registerByName(WS_NAME, websocketClient);
    }
    return websocketClient;
  });
  return ws2;
};
var useKeyStore = () => {
  const ctx = useContext(OrderlyContext);
  return ctx.keyStore;
};
var useSimpleDI = () => {
  return {
    get: Ia$1.get,
    // getOr: SimpleDI.getOr<T>(name, SimpleDI.get<T>(name)),
    register: Ia$1.register
  };
};
var WsNetworkStatus = /* @__PURE__ */ ((WsNetworkStatus2) => {
  WsNetworkStatus2["Connected"] = "connected";
  WsNetworkStatus2["Unstable"] = "unstable";
  WsNetworkStatus2["Disconnected"] = "disconnected";
  return WsNetworkStatus2;
})(WsNetworkStatus || {});
function useWsStatus() {
  const ws2 = useWS();
  const [wsStatus, setWsStatus] = useState(
    ws2.client.public.readyState ? "connected" : "disconnected"
    /* Disconnected */
  );
  const connectCount = useRef(0);
  useEffect(() => {
    ws2.on("status:change", (status) => {
      const { type, isPrivate } = status;
      if (!isPrivate) {
        switch (type) {
          case "open":
            connectCount.current = 0;
            setWsStatus(
              "connected"
              /* Connected */
            );
            break;
          case "close":
            connectCount.current = 0;
            setWsStatus(
              "disconnected"
              /* Disconnected */
            );
            break;
          case "reconnecting":
            connectCount.current++;
            if (connectCount.current >= 3) {
              setWsStatus(
                "unstable"
                /* Unstable */
              );
            }
            break;
        }
      }
    });
    return () => ws2.off("websocket:status", () => {
    });
  }, []);
  return wsStatus;
}
var StatusContext = createContext({});
var StatusProvider = (props) => {
  const wsStatus = useWsStatus();
  return /* @__PURE__ */ jsx(StatusContext.Provider, { value: { ws: wsStatus }, children: props.children });
};
var BaseMergeHandler = class {
  constructor(message) {
    this.message = message;
    this.data = this.formatOrder(message);
  }
  /**
   * format the order data;
   */
  formatOrder(message) {
    const data = this.pre(message);
    if (!data.created_time) {
      data.created_time = data.timestamp;
    }
    if (data.status === OrderStatus.FILLED && !data.updated_time) {
      data.updated_time = data.timestamp;
    }
    if (data.child_orders && data.child_orders.length) {
      data.child_orders.map((child) => {
        if (child.algo_status === OrderStatus.FILLED && child.is_activated && !child.updated_time) {
          child.updated_time = data.timestamp;
        }
      });
    }
    if (data.type && data.type.endsWith("_ORDER")) {
      data.type = data.type.replace("_ORDER", "");
    }
    return data;
  }
  merge(key, message, prevData) {
    switch (this.status) {
      case "NEW": {
        if (key.startsWith("orders:CANCELLED") || key.startsWith("orders:FILLED") || key.startsWith("orders:REJECTED")) {
          return prevData;
        }
        return this.insetOrUpdate(prevData);
      }
      case "CANCELLED": {
        if (key.startsWith("orders:FILLED") || key.startsWith("orders:REJECTED")) {
          return prevData;
        }
        if (key.startsWith("orders:NEW") || key.startsWith("orders:INCOMPLETE")) {
          return this.remove(prevData);
        }
        if (key.startsWith("orders:CANCELLED")) {
          return this.insert(prevData);
        }
        return this.update(prevData);
      }
      case "REPLACED":
        return this.update(prevData);
      case "FILLED": {
        if (this.orderIsExisting(prevData)) {
          if (key.startsWith("orders:INCOMPLETE") || key.startsWith("orders:NEW") || // all orders key
          key.startsWith("orders:")) {
            if (this.isFullFilled()) {
              return this.remove(prevData);
            }
            return this.update(prevData);
          }
        } else {
          if (key.startsWith("orders:CANCELLED") || key.startsWith("orders:INCOMPLETE") || key.startsWith("orders:NEW")) {
            return prevData;
          }
          return this.insert(prevData);
        }
      }
      default:
        return prevData || [];
    }
  }
  insert(orders) {
    const index = lensIndex(0);
    return over(
      //@ts-ignore
      index,
      (item) => ({
        meta: {
          ...item.meta,
          total: item.meta.total + 1
        },
        rows: [this.data, ...item.rows]
      }),
      orders
    );
  }
  insetOrUpdate(orders) {
    if (this.orderIsExisting(orders)) {
      return this.update(orders);
    }
    return this.insert(orders);
  }
  update(prevData) {
    const idx = this.findOrderIndex(prevData);
    if (!Array.isArray(idx)) {
      return prevData || [];
    }
    const [index, index2] = idx;
    return prevData.map((item, i) => {
      return {
        meta: { ...item.meta },
        rows: item.rows.map((order, j2) => {
          if (index === i && index2 === j2) {
            return { ...order, ...this.data };
          }
          return order;
        })
      };
    });
  }
  remove(prevData) {
    const idx = this.findOrderIndex(prevData);
    if (!Array.isArray(idx)) {
      return prevData;
    }
    const [index, index2] = idx;
    return prevData.map((item, i) => {
      return {
        meta: { ...item.meta, total: item.meta.total - 1 },
        rows: index === i ? item.rows.filter((_2, i2) => i2 !== index2) : item.rows
      };
    });
  }
  findOrderIndex(orders) {
    let index = 0;
    let index2;
    for (; index < orders.length; index++) {
      const item = orders[index];
      for (let idx2 = 0; idx2 < item.rows.length; idx2++) {
        const element = item.rows[idx2];
        if (element.algo_order_id === this.orderId || element.order_id === this.orderId) {
          index2 = idx2;
          break;
        }
      }
      if (typeof index2 !== "undefined") {
        break;
      }
    }
    if (typeof index2 === "undefined") {
      return;
    }
    return [index, index2];
  }
  orderIsExisting(orders) {
    const index = this.findOrderIndex(orders);
    return Array.isArray(index);
  }
};
function object2underscore(obj) {
  return Object.keys(obj).reduce((acc, key) => {
    acc[Y$4(key)] = obj[key];
    return acc;
  }, {});
}
var AlgoOrderMergeHandler = class _AlgoOrderMergeHandler extends BaseMergeHandler {
  get orderId() {
    return this.data.algo_order_id;
  }
  get status() {
    return this.data.root_algo_status;
  }
  //   merge(
  //     key: string,
  //     message: WSMessage.AlgoOrder[],
  //     prevData: API.OrderResponse[]
  //   ): API.OrderResponse[] | undefined {
  //     switch (this.status) {
  //       case "TRIGGER": {
  //       }
  //       default:
  //         return super.merge(key, message, prevData);
  //     }
  //   }
  pre(message, prevData) {
    return _AlgoOrderMergeHandler.groupOrders(message);
  }
  isFullFilled() {
    if ("total_executed_quantity" in this.data && this.data.total_executed_quantity !== 0) {
      return this.data.total_executed_quantity === this.data.quantity;
    } else if ("total_executed_quantity" in this.data.child_orders[0]) {
      return this.data.child_orders[0].total_executed_quantity === this.data.child_orders[0].quantity;
    }
    return false;
  }
  static groupOrders(orders) {
    const rootOrderIndex = orders.findIndex(
      (order) => order.parentAlgoOrderId === 0 && order.algoOrderId === order.rootAlgoOrderId
    );
    if (rootOrderIndex === -1) {
      throw new SDKError("Root order not found");
    }
    const rootOrder_ = object2underscore(
      orders[rootOrderIndex]
    );
    rootOrder_.child_orders = orders.filter((_2, index) => index !== rootOrderIndex).map((order) => {
      return object2underscore(order);
    });
    if (rootOrder_.algo_type === "BRACKET" && rootOrder_.child_orders.length > 0) {
      const childOrders = this.groupBracketChildOrders([
        ...rootOrder_.child_orders
      ]);
      rootOrder_.child_orders = [childOrders];
    }
    return rootOrder_;
  }
  static groupBracketChildOrders(orders) {
    const innerOrders = [...orders];
    const rootOrderIndex = innerOrders.findIndex(
      (order) => order.algoType !== AlgoOrderType.STOP_LOSS && order.algoType !== AlgoOrderType.TAKE_PROFIT
    );
    if (rootOrderIndex === -1) {
      throw new SDKError("Root order not found");
    }
    const rootOrder = innerOrders.splice(
      rootOrderIndex,
      1
    )[0];
    rootOrder.child_orders = innerOrders;
    return rootOrder;
  }
};
var RegularOrderMergeHandler = class extends BaseMergeHandler {
  get orderId() {
    return this.data.order_id;
  }
  get status() {
    return this.data.status;
  }
  pre(message, prevData) {
    return object2underscore(message);
  }
  isFullFilled() {
    return "total_executed_quantity" in this.data && this.data.total_executed_quantity === this.data.quantity;
  }
};
var generateKeyFun = (args) => (pageIndex, previousPageData) => {
  var _a3;
  if (previousPageData && !((_a3 = previousPageData.rows) == null ? void 0 : _a3.length))
    return null;
  const { status, symbol, side, size = 100, page, dateRange } = args;
  const search = new URLSearchParams([
    ["size", size.toString()],
    ["page", `${pageIndex + 1}`],
    ["source_type", "ALL"]
  ]);
  if (dateRange) {
    if (dateRange.from) {
      search.set("start_t", `${dateRange.from.getTime()}`);
    }
    if (dateRange.to) {
      search.set("end_t", `${dateRange.to.getTime()}`);
    }
  }
  if (page) {
    search.set("page", `${page}`);
  }
  if (status) {
    search.set(`status`, status);
  }
  if (symbol) {
    search.set(`symbol`, symbol);
  }
  if (side) {
    search.set(`side`, side);
  }
  return `/v1/orders?${search.toString()}`;
};
var updateOrdersHandler = (key, updatedOrder, orders) => {
  if (!orders) {
    return;
  }
  const handler = new RegularOrderMergeHandler(updatedOrder);
  return handler.merge(key, updatedOrder, orders);
};
function updateAlgoOrdersHandler(key, message, orders) {
  if (!orders) {
    return;
  }
  const mergeHandler = new AlgoOrderMergeHandler(message);
  const result = mergeHandler.merge(key, message, orders);
  return result;
}
function getPositionBySymbol(symbol) {
}
var useAppStore = create()(
  immer((set2) => ({
    // accountInfo: null,
    portfolio: {
      totalCollateral: $$4,
      totalValue: null,
      freeCollateral: $$4,
      availableBalance: 0,
      unsettledPnL: 0,
      totalUnrealizedROI: 0
    },
    appState: {
      positionsLoading: false,
      ordersLoading: false,
      fundingRatesLoading: false,
      ready: false
    },
    actions: {
      cleanAll: () => {
        set2((state) => {
          state.accountInfo = void 0;
          state.portfolio = {
            totalCollateral: $$4,
            totalValue: null,
            freeCollateral: $$4,
            availableBalance: 0,
            unsettledPnL: 0,
            totalUnrealizedROI: 0
          };
        }, false);
      },
      setAccountInfo: (accountInfo) => {
        set2(
          (state) => {
            state.accountInfo = accountInfo;
          },
          false
          // "setAccountInfo"
        );
      },
      setSymbolsInfo: (symbolsInfo) => {
        set2(
          (state) => {
            state.symbolsInfo = symbolsInfo;
          },
          false
          // "setSymbolsInfo"
        );
      },
      setFundingRates: (fundingRates) => {
        set2(
          (state) => {
            state.fundingRates = fundingRates;
          },
          false
          // "setFundingRates"
        );
      },
      updateAppStatus: (key, value) => {
        set2(
          (state) => {
            state.appState[key] = value;
          },
          false
          // "updateAppStatus"
        );
      },
      updatePortfolio: (key, value) => {
        set2(
          (state) => {
            state.portfolio[key] = value;
          },
          false
          // "updatePortfolio"
        );
      },
      batchUpdateForPortfolio: (data) => {
        set2(
          (state) => {
            state.portfolio = { ...state.portfolio, ...data };
          },
          false
          // "batchUpdateForPortfolio"
        );
      },
      restoreHolding: (holding) => {
        set2(
          (state) => {
            state.portfolio.holding = holding;
          },
          false
          // "updateHolding"
        );
      },
      updateHolding(msg) {
        set2(
          (state) => {
            if (state.portfolio.holding && state.portfolio.holding.length) {
              for (const key in msg) {
                const holding = state.portfolio.holding.find(
                  (item) => item.token === key
                );
                if (holding) {
                  holding.holding = msg[key].holding;
                  holding.frozen = msg[key].frozen;
                }
              }
            }
          },
          false
          // "updateHolding"
        );
      }
    }
  }))
);
var useAccountInfo = () => useAppStore((state) => state.accountInfo);
var BaseCalculator = class {
  cache(data) {
    this._cache = data;
  }
};
var useMarkPriceStore = create((set2, get3) => ({
  markPrices: {},
  // orderBook: {},
  // ask_bid: [],
  actions: {
    updateMarkPrice: (markPrice) => {
      set2({
        markPrices: markPrice
      });
    },
    getMarkPriceBySymbol: (symbol) => {
      return get3().markPrices[symbol];
    }
  }
}));
var useMarkPriceActions = () => useMarkPriceStore((state) => state.actions);
var MarketCalculatorName = "markPriceCalculator";
var MarkPriceCalculator = class extends BaseCalculator {
  constructor() {
    super(...arguments);
    this.name = MarketCalculatorName;
  }
  calc(scope, data, ctx) {
    return data;
  }
  update(data, scope) {
    useMarkPriceStore.getState().actions.updateMarkPrice(data);
  }
};
var CalculatorContext = class _CalculatorContext {
  static get instance() {
    return this._instance;
  }
  static create(scope, data) {
    if (!this._instance) {
      this._instance = new _CalculatorContext(scope, data);
    }
    return this._instance.update(scope, data);
  }
  constructor(scope, data) {
    this.setCtxData();
    this.output = {
      // rows: positions,
    };
  }
  update(scope, data) {
    this.setCtxData();
    this.markPrices = scope === "markPrice" ? data : this.output[MarketCalculatorName];
    this.portfolio = this.output["portfolio"] || useAppStore.getState().portfolio;
    return this;
  }
  setCtxData() {
    this.accountInfo = useAppStore.getState().accountInfo;
    this.symbolsInfo = useAppStore.getState().symbolsInfo;
    this.fundingRates = useAppStore.getState().fundingRates;
  }
  get(fn2) {
    return fn2(this.output);
  }
  getCacheValue(name, fallback) {
    return this.output[name] || fallback();
  }
  clearCache() {
    this.output = {};
    this.accountInfo = void 0;
    this.portfolio = void 0;
  }
  deleteByName(name) {
    delete this.output[name];
  }
  // get positions(): API.PositionTPSLExt[] {
  //   if (this.output.positionCalculator) return this.output.positionCalculator;
  //   return usePositionStore.getState().positions;
  // }
  get isReady() {
    return !!this.accountInfo;
  }
  saveOutput(name, data) {
    this.output[name] = data;
  }
  outputToValue() {
    return this.output;
  }
};
var CalculatorService = class {
  constructor(scheduler, calculators) {
    this.scheduler = scheduler;
    this.pendingCalc = [];
    this.calcQueue = [];
    this.referenceCount = /* @__PURE__ */ new Map();
    this.isPaused = false;
    this.calculators = new Map(calculators);
  }
  register(scope, calculator) {
    const ref_count_name = `${scope}_${calculator.name}`;
    const count = this.referenceCount.get(ref_count_name);
    if (typeof count !== "undefined" && count > 0) {
      this.referenceCount.set(ref_count_name, count + 1);
      return;
    }
    const calculators = this.calculators.get(scope);
    if (Array.isArray(calculators)) {
      calculators.push(calculator);
    } else {
      this.calculators.set(scope, [calculator]);
    }
    this.referenceCount.set(ref_count_name, 1);
  }
  unregister(scope, calculator) {
    var _a3, _b2;
    const ref_count_name = `${scope}_${calculator.name}`;
    const count = this.referenceCount.get(ref_count_name);
    if (typeof count !== "undefined" && count > 1) {
      this.referenceCount.set(ref_count_name, count - 1);
      return;
    }
    const calculators = this.calculators.get(scope);
    if (Array.isArray(calculators)) {
      const index = calculators.findIndex((c) => c.name === calculator.name);
      if (index > -1) {
        (_b2 = (_a3 = calculators[index]).destroy) == null ? void 0 : _b2.call(_a3);
        calculators.splice(index, 1);
      }
    }
    this.referenceCount.delete(ref_count_name);
  }
  async calc(scope, data, options) {
    if (scope !== "position") {
      if (!(options == null ? void 0 : options.skipWhenOnPause)) ;
    }
    const ctx = CalculatorContext.create(scope, data);
    if (!ctx.isReady && (options == null ? void 0 : options.skipPending)) {
      return;
    }
    if ((options == null ? void 0 : options.skipWhenOnPause) && !this.windowIsVisible)
      return;
    this.calcQueue.push({ scope, data, options });
    await this.handleCalcQueue(ctx);
    this.ctx = ctx;
  }
  // private async handlePendingCalc() {
  //   // console.log("[handlePendingCalc]:", this.pendingCalc);
  //   if (this.pendingCalc.length === 0) return;
  //   this.calcQueue = [...this.pendingCalc, ...this.calcQueue];
  //   this.pendingCalc = [];
  // }
  async handleCalcQueue(context) {
    const first = this.calcQueue.shift();
    if (first) {
      const { scope, data, options } = first;
      const ctx = context || CalculatorContext.create(scope, data);
      const calculators = this.calculators.get(scope);
      if (Array.isArray(calculators) && calculators.length) {
        try {
          await this.scheduler.calc(scope, calculators, data, ctx);
        } catch (e2) {
        }
        if (!(options == null ? void 0 : options.skipUpdate)) {
          this.scheduler.update(scope, calculators, ctx.outputToValue());
        }
      }
      if (this.calcQueue.length) {
        this.handleCalcQueue(ctx);
      }
    }
  }
  stop() {
    var _a3;
    this.calcQueue = [];
    (_a3 = this.ctx) == null ? void 0 : _a3.clearCache();
  }
  get windowIsVisible() {
    if (typeof document === "undefined")
      return true;
    return document.visibilityState === "visible";
  }
};
var CalculatorServiceID = "CalculatorService";
var requestIdleCallbackPolyfill = (callback, options) => {
  const startTime = Date.now();
  return setTimeout(() => {
    callback({
      didTimeout: false,
      timeRemaining: () => Math.max(0, 50 - (Date.now() - startTime))
    });
  }, 1);
};
var cancelIdleCallbackPolyfill = (id2) => {
  clearTimeout(id2);
};
var safeRequestIdleCallback = typeof window !== "undefined" && window.requestIdleCallback ? window.requestIdleCallback.bind(window) : requestIdleCallbackPolyfill;
typeof window !== "undefined" && window.cancelIdleCallback ? window.cancelIdleCallback.bind(window) : cancelIdleCallbackPolyfill;
var ShardingScheduler = class {
  // run(calculators: Calculator[]) {}
  calc(scope, calculators, data, ctx) {
    return new Promise((resolve, reject) => {
      try {
        this.computation(
          calculators,
          (shard) => {
            const results = [];
            for (let index = 0; index < shard.length; index++) {
              const calculator = shard[index];
              const result = calculator.calc(scope, data, ctx);
              if (result) {
                ctx.saveOutput(calculator.name, result);
                results.push(result);
              }
            }
            return results;
          },
          (results) => {
            resolve(results);
          }
        );
      } catch (error) {
        reject(error);
      }
    });
  }
  update(scope, calculators, data) {
    for (let index = 0; index < calculators.length; index++) {
      const calculator = calculators[index];
      const item = data[calculator.name];
      if (!!item) {
        calculator.update(item, scope);
      }
    }
    return Promise.resolve();
  }
  computation(data, processor, onComplete) {
    let index = 0;
    const results = [];
    const estimatedShardSize = Math.min(data.length, 2);
    function processNextShard(deadline) {
      let shardSize = estimatedShardSize;
      while (index + shardSize <= data.length && deadline.timeRemaining() > 0) {
        const shard = data.slice(index, index + shardSize);
        const result = processor(shard);
        results.push(result);
        index += shardSize;
        if (deadline.timeRemaining() < 1) {
          shardSize = Math.max(1, Math.floor(shardSize / 2));
        } else {
          shardSize = Math.min(data.length - index, shardSize * 2);
        }
      }
      if (index < data.length) {
        safeRequestIdleCallback(processNextShard, {
          timeout: 1e3
        });
      } else {
        onComplete(results.flat());
      }
    }
    safeRequestIdleCallback(processNextShard, {
      timeout: 1e3
    });
  }
};
var POSITION_EMPTY = {
  rows: null,
  margin_ratio: 0,
  initial_margin_ratio: 0,
  maintenance_margin_ratio: 0,
  open_margin_ratio: 0,
  current_margin_ratio_with_orders: 0,
  initial_margin_ratio_with_orders: 0,
  maintenance_margin_ratio_with_orders: 0,
  total_collateral_value: 0,
  free_collateral: 0,
  total_pnl_24_h: 0,
  unrealPnL: 0,
  total_unreal_pnl: 0,
  unsettledPnL: 0,
  total_unsettled_pnl: 0,
  notional: 0,
  unrealPnlROI: 0
};
var usePositionStore = create()(
  immer((set2) => ({
    positions: {
      all: POSITION_EMPTY
    },
    actions: {
      setPositions: (key, positions2) => {
        set2((state) => {
          state.positions[key] = positions2;
        });
      },
      closePosition: (symbol) => {
        set2((state) => {
          delete state.positions[symbol];
        });
      },
      clearAll: () => {
        set2((state) => {
          state.positions = {
            all: POSITION_EMPTY
          };
        });
      }
    }
  }))
);
var usePositions = (symbol = "all") => usePositionStore((state) => (state.positions[symbol] ?? POSITION_EMPTY).rows);
var usePositionActions = () => usePositionStore((state) => state.actions);
var useApiStatusStore = create()(
  immer((set2) => ({
    apis: {
      positions: {
        loading: false
      }
    },
    actions: {
      updateStatus: (key, status) => {
        set2((state) => {
          state.apis[key] = status;
        });
      },
      updateApiLoading: (key, loading) => {
        set2((state) => {
          state.apis[key].loading = loading;
        });
      },
      updateApiError: (key, error) => {
        set2((state) => {
          state.apis[key] = {
            loading: false,
            error
          };
        });
      }
    }
  }))
);
var useApiStatusActions = () => useApiStatusStore((state) => state.actions);
var NAME_PREFIX = "positionCalculator";
var AllPositions = "all";
var PositionCalculator = class extends BaseCalculator {
  // private id: string;
  constructor(symbol = AllPositions) {
    super();
    this.name = `${NAME_PREFIX}_${symbol}`;
    this.symbol = symbol;
  }
  calc(scope, data, ctx) {
    if (scope === "markPrice") {
      return this.calcByMarkPrice(data, ctx);
    }
    if (scope === "indexPrice") {
      return this.calcByIndexPrice(data, ctx);
    }
    if (scope === "position") {
      return this.calcByPosition(
        this.preprocess(data),
        ctx
      );
    }
    return data;
  }
  update(data, scope) {
    if (!data || !Array.isArray(data.rows))
      return;
    usePositionStore.getState().actions.setPositions(this.symbol, data);
    if (Array.isArray(data.rows) && useApiStatusStore.getState().apis.positions.loading) {
      useApiStatusStore.getState().actions.updateApiLoading("positions", false);
    }
  }
  calcByMarkPrice(markPrice, ctx) {
    let positions2 = this.getPosition(markPrice, ctx);
    if (!positions2 || !Array.isArray(positions2.rows) || !positions2.rows.length)
      return positions2;
    positions2 = {
      ...positions2,
      rows: positions2.rows.map((item) => ({
        ...item,
        mark_price: markPrice[item.symbol] || item.mark_price
      }))
    };
    return this.format(positions2, ctx);
  }
  calcByIndexPrice(indexPrice, ctx) {
    let positions2 = this.getPosition(indexPrice, ctx);
    if (!positions2) {
      return positions2;
    }
    if (!Array.isArray(positions2.rows) || !positions2.rows.length)
      return positions2;
    positions2 = {
      ...positions2,
      rows: positions2.rows.map((item) => ({
        ...item,
        index_price: indexPrice[item.symbol] || item.index_price || item.mark_price
      }))
    };
    return this.format(positions2, ctx);
  }
  calcByPosition(positions2, ctx) {
    if (positions2.rows.length === 0)
      return positions2;
    return this.format(positions2, ctx);
  }
  format(data, ctx) {
    const { accountInfo, symbolsInfo, fundingRates, portfolio } = ctx;
    if (!accountInfo || !fundingRates || !symbolsInfo) {
      return data;
    }
    let unrealPnL_total = $$4, unrealPnL_total_index = $$4, notional_total = $$4, unsettlementPnL_total = $$4;
    let rows = data.rows.map((item) => {
      const info = symbolsInfo[item.symbol];
      const notional2 = positions_exports.notional(item.position_qty, item.mark_price);
      const unrealPnl = positions_exports.unrealizedPnL({
        qty: item.position_qty,
        openPrice: item == null ? void 0 : item.average_open_price,
        // markPrice: unRealizedPrice,
        markPrice: item.mark_price
      });
      let unrealPnl_index = 0, unrealPnlROI_index = 0;
      const imr = account_exports.IMR({
        maxLeverage: accountInfo.max_leverage,
        baseIMR: info == null ? void 0 : info["base_imr"],
        IMR_Factor: accountInfo.imr_factor[item.symbol],
        positionNotional: notional2,
        ordersNotional: 0,
        IMR_factor_power: 4 / 5
      });
      const unrealPnlROI = positions_exports.unrealizedPnLROI({
        positionQty: item.position_qty,
        openPrice: item.average_open_price,
        IMR: imr,
        unrealizedPnL: unrealPnl
      });
      if (item.index_price) {
        unrealPnl_index = positions_exports.unrealizedPnL({
          qty: item.position_qty,
          openPrice: item == null ? void 0 : item.average_open_price,
          // markPrice: unRealizedPrice,
          markPrice: item.index_price
        });
        unrealPnlROI_index = positions_exports.unrealizedPnLROI({
          positionQty: item.position_qty,
          openPrice: item.average_open_price,
          IMR: imr,
          unrealizedPnL: unrealPnl_index
        });
      }
      const unsettlementPnL22 = positions_exports.unsettlementPnL({
        positionQty: item.position_qty,
        markPrice: item.mark_price,
        costPosition: item.cost_position,
        sumUnitaryFunding: propOr(
          0,
          "sum_unitary_funding",
          fundingRates[item.symbol]
        ),
        lastSumUnitaryFunding: item.last_sum_unitary_funding
      });
      const MMR3 = positions_exports.MMR({
        baseMMR: info == null ? void 0 : info["base_mmr"],
        baseIMR: info == null ? void 0 : info["base_imr"],
        IMRFactor: accountInfo.imr_factor[item.symbol],
        positionNotional: notional2,
        IMR_factor_power: 4 / 5
      });
      unrealPnL_total = unrealPnL_total.add(unrealPnl);
      unrealPnL_total_index = unrealPnL_total_index.add(unrealPnl_index);
      notional_total = notional_total.add(notional2);
      unsettlementPnL_total = unsettlementPnL_total.add(unsettlementPnL22);
      return {
        ...item,
        mm: positions_exports.maintenanceMargin({
          positionQty: item.position_qty,
          markPrice: item.mark_price,
          MMR: MMR3
        }),
        mmr: MMR3,
        notional: notional2,
        unsettlement_pnl: unsettlementPnL22,
        unrealized_pnl: unrealPnl,
        unrealized_pnl_index: unrealPnl_index,
        unrealized_pnl_ROI: unrealPnlROI,
        unrealized_pnl_ROI_index: unrealPnlROI_index
      };
    });
    const totalUnrealPnl = unrealPnL_total.toNumber();
    const totalUnrealPnl_index = unrealPnL_total_index.toNumber();
    const unsettlementPnL2 = unsettlementPnL_total.toNumber();
    let totalUnrealizedROI2 = 0, totalUnrealizedROI_index = 0;
    if (portfolio) {
      const { totalValue: totalValue2, totalCollateral: totalCollateral2 } = portfolio;
      rows = rows.map((item) => {
        const est_liq_price = positions_exports.liqPrice({
          markPrice: item.mark_price,
          totalCollateral: totalCollateral2.toNumber(),
          positionQty: item.position_qty,
          positions: rows,
          MMR: item.mmr
        });
        return {
          ...item,
          est_liq_price
        };
      });
      if (totalValue2 !== null && !totalValue2.eq($$4)) {
        totalUnrealizedROI2 = account_exports.totalUnrealizedROI({
          totalUnrealizedPnL: totalUnrealPnl,
          totalValue: totalValue2.toNumber()
        });
        totalUnrealizedROI_index = account_exports.totalUnrealizedROI({
          totalUnrealizedPnL: totalUnrealPnl_index,
          totalValue: totalValue2.toNumber()
        });
      }
    }
    return {
      ...data,
      unrealPnL: totalUnrealPnl,
      total_unreal_pnl: totalUnrealPnl,
      total_unreal_pnl_index: totalUnrealPnl_index,
      notional: notional_total.toNumber(),
      unsettledPnL: unsettlementPnL2,
      total_unsettled_pnl: unsettlementPnL2,
      unrealPnlROI: totalUnrealizedROI2,
      unrealPnlROI_index: totalUnrealizedROI_index,
      rows
    };
  }
  preprocess(data) {
    let rows = data.rows;
    if (this.symbol !== AllPositions && Array.isArray(rows)) {
      rows = rows.filter((item) => item.symbol === this.symbol);
    }
    return {
      ...data,
      rows
    };
  }
  getPosition(_2, ctx) {
    let positions2 = ctx.get((output) => output[this.name]) || usePositionStore.getState().positions[this.symbol];
    if (this.symbol === AllPositions) {
      return positions2;
    }
    if (positions2 && Array.isArray(positions2.rows)) {
      return positions2;
    }
    return this.preprocess(this.getAllPositions(ctx));
  }
  destroy() {
    var _a3;
    usePositionStore.getState().actions.closePosition(this.symbol);
    (_a3 = CalculatorContext.instance) == null ? void 0 : _a3.deleteByName(this.name);
  }
  getAllPositions(ctx) {
    return ctx.get((output) => output[AllPositions]) || usePositionStore.getState().positions[AllPositions];
  }
};
PositionCalculator.logPosition = (symbol = "all") => {
  return usePositionStore.getState().positions[symbol];
};
var parseHolding = (holding, markPrices) => {
  const nonUSDC = [];
  let USDC_holding = 0;
  holding.forEach((item) => {
    if (item.token === "USDC") {
      USDC_holding = item.holding;
    } else {
      nonUSDC.push({
        holding: item.holding,
        markPrice: markPrices[item.token] ?? 0,
        // markPrice: 0,
        discount: 0
      });
    }
  });
  return [USDC_holding, nonUSDC];
};
function createGetter(data, depth = 2) {
  const getValue2 = (value, defaultValue) => {
    if (defaultValue === void 0) {
      return value;
    }
    return value ?? defaultValue;
  };
  return new Proxy(data || {}, {
    get(target, property, receiver) {
      if (property === "isNil") {
        return isNil(data);
      }
      if (depth === 1) {
        return (defaultValue) => {
          if (!target)
            return defaultValue;
          return getValue2(target[property], defaultValue);
        };
      }
      return (key, defaultValue) => {
        var _a3;
        if (key) {
          return getValue2((_a3 = target[property]) == null ? void 0 : _a3[key], defaultValue);
        } else {
          return getValue2(target[property], defaultValue);
        }
      };
    }
  });
}
var PortfolioCalculatorName = "portfolio";
var PortfolioCalculator = class extends BaseCalculator {
  constructor() {
    super(...arguments);
    this.name = PortfolioCalculatorName;
  }
  calc(scope, data, ctx) {
    let markPrices, positions2;
    const portfolio = this.getPortfolio(ctx);
    if (scope === "markPrice") {
      markPrices = data;
    } else {
      markPrices = ctx.get(
        (cache) => cache[MarketCalculatorName]
      );
    }
    positions2 = ctx.get(
      (output) => output.positionCalculator_all
    );
    let holding = portfolio.holding;
    if (scope === "portfolio" && data.holding && Array.isArray(holding)) {
      holding = holding.map((item) => {
        if (data.holding[item.token]) {
          return {
            ...item,
            holding: data.holding[item.token].holding,
            frozen: data.holding[item.token].frozen
          };
        }
        return item;
      });
    }
    const accountInfo = ctx.accountInfo;
    const symbolsInfo = ctx.symbolsInfo;
    return this.format({
      holding,
      positions: positions2,
      markPrices,
      accountInfo,
      symbolsInfo
    });
  }
  getPortfolio(ctx) {
    return ctx.get((output) => output[this.name]) || useAppStore.getState().portfolio;
  }
  format(inputs) {
    const { holding, positions: positions2, markPrices, accountInfo, symbolsInfo } = inputs;
    if (!holding || !positions2 || !Array.isArray(positions2.rows) || !markPrices || !accountInfo) {
      return null;
    }
    const unsettledPnL = pathOr(0, ["total_unsettled_pnl"])(positions2);
    const unrealizedPnL2 = pathOr(0, ["total_unreal_pnl"])(positions2);
    const [USDC_holding, nonUSDC] = parseHolding(holding, markPrices);
    const usdc = holding.find((item) => item.token === "USDC");
    const totalCollateral2 = account_exports.totalCollateral({
      USDCHolding: USDC_holding,
      nonUSDCHolding: nonUSDC,
      unsettlementPnL: unsettledPnL
    });
    const totalValue2 = account_exports.totalValue({
      totalUnsettlementPnL: unsettledPnL,
      USDCHolding: USDC_holding,
      nonUSDCHolding: nonUSDC
    });
    const totalUnrealizedROI2 = account_exports.totalUnrealizedROI({
      totalUnrealizedPnL: unrealizedPnL2,
      totalValue: totalValue2.toNumber()
    });
    const totalInitialMarginWithOrders2 = account_exports.totalInitialMarginWithQty({
      positions: positions2.rows,
      markPrices,
      IMR_Factors: accountInfo.imr_factor,
      maxLeverage: accountInfo.max_leverage,
      symbolInfo: createGetter({ ...symbolsInfo })
    });
    const freeCollateral2 = account_exports.freeCollateral({
      totalCollateral: totalCollateral2,
      totalInitialMarginWithOrders: totalInitialMarginWithOrders2
    });
    const availableBalance2 = account_exports.availableBalance({
      USDCHolding: (usdc == null ? void 0 : usdc.holding) ?? 0,
      unsettlementPnL: positions2.total_unsettled_pnl ?? 0
    });
    return {
      totalCollateral: totalCollateral2,
      totalValue: totalValue2,
      totalUnrealizedROI: totalUnrealizedROI2,
      freeCollateral: freeCollateral2,
      availableBalance: availableBalance2,
      unsettledPnL,
      holding
    };
  }
  update(data, scope) {
    if (!!data) {
      useAppStore.getState().actions.batchUpdateForPortfolio({
        totalCollateral: data.totalCollateral,
        totalValue: data.totalValue,
        freeCollateral: data.freeCollateral,
        availableBalance: data.availableBalance,
        totalUnrealizedROI: data.totalUnrealizedROI,
        unsettledPnL: data.unsettledPnL,
        holding: Array.isArray(data.holding) ? data.holding : []
      });
    }
  }
};
var useIndexPriceStore = create((set2) => ({
  indexPrices: {},
  actions: {
    updateIndexPrice: (indexPrice) => {
      set2({
        indexPrices: indexPrice
      });
    }
  }
}));
var IndexPriceCalculatorName = "indexPriceCalculator";
var IndexPriceCalculator = class extends BaseCalculator {
  constructor() {
    super(...arguments);
    this.name = IndexPriceCalculatorName;
  }
  calc(scope, data, ctx) {
    return data;
  }
  update(data) {
    if (!data)
      return;
    useIndexPriceStore.getState().actions.updateIndexPrice(data);
  }
  static getValue() {
    return useIndexPriceStore.getState().indexPrices;
  }
};
var useCalculatorService = () => {
  const { get: get3 } = useSimpleDI();
  const calculatorService = useConstant(() => {
    let calculatorService2 = get3(CalculatorServiceID);
    if (!calculatorService2) {
      const positionCalculator = new PositionCalculator();
      const portfolioCalculator = new PortfolioCalculator();
      const markPriceCalculator = new MarkPriceCalculator();
      const indexPriceCalculator = new IndexPriceCalculator();
      calculatorService2 = new CalculatorService(new ShardingScheduler(), [
        [
          "markPrice",
          [
            markPriceCalculator,
            positionCalculator,
            portfolioCalculator,
            positionCalculator
          ]
        ],
        ["position", [positionCalculator, portfolioCalculator]],
        ["portfolio", [portfolioCalculator]],
        // indexPrice
        [
          "indexPrice",
          [indexPriceCalculator, positionCalculator]
        ]
      ]);
      Ia$1.registerByName(CalculatorServiceID, calculatorService2);
    }
    return calculatorService2;
  });
  return calculatorService;
};
var defaultRawOrderBook = {
  asks: [],
  bids: [],
  ts: 0
};
var OrderbookService = class _OrderbookService {
  constructor() {
    this.bufferedOrderBookUpdates = {};
    this.rawOrderBook = {};
  }
  static getInstance() {
    if (!this.instance) {
      this.instance = new _OrderbookService();
    }
    return this.instance;
  }
  sortBufferedOrderBookUpdates(symbol) {
    var _a3;
    (_a3 = this.bufferedOrderBookUpdates[symbol]) == null ? void 0 : _a3.sort((a2, b2) => a2.ts - b2.ts);
  }
  applyUpdateToRawOrderBook(symbol, update) {
    const rawOrderBook = this.rawOrderBook[symbol];
    if (!rawOrderBook || rawOrderBook.ts > update.prevTs) {
      return;
    }
    const askMap = /* @__PURE__ */ new Map();
    const bidMap = /* @__PURE__ */ new Map();
    rawOrderBook.asks.forEach((ask) => askMap.set(ask[0], ask[1]));
    rawOrderBook.bids.forEach((bid) => bidMap.set(bid[0], bid[1]));
    update.asks.forEach((ask) => ask[1] === 0 ? askMap.delete(ask[0]) : askMap.set(ask[0], ask[1]));
    update.bids.forEach((bid) => bid[1] === 0 ? bidMap.delete(bid[0]) : bidMap.set(bid[0], bid[1]));
    rawOrderBook.asks = Array.from(askMap.entries()).sort((a2, b2) => a2[0] - b2[0]);
    rawOrderBook.bids = Array.from(bidMap.entries()).sort((a2, b2) => b2[0] - a2[0]);
    rawOrderBook.ts = update.ts;
  }
  applyBufferedUpdatesToRawOrderBooks(symbol) {
    var _a3;
    (_a3 = this.bufferedOrderBookUpdates[symbol]) == null ? void 0 : _a3.forEach((update) => this.applyUpdateToRawOrderBook(symbol, update));
  }
  deleteBufferedOrderBookUpdates(symbol) {
    delete this.bufferedOrderBookUpdates[symbol];
  }
  commitOrderBook(symbol) {
    const rawOrderBook = this.rawOrderBook[symbol];
    if (!rawOrderBook) {
      return;
    }
  }
  pushUpdateToBuffer(symbol, update) {
    if (this.bufferedOrderBookUpdates[symbol] === void 0) {
      this.bufferedOrderBookUpdates[symbol] = [];
    }
    const buffer = this.bufferedOrderBookUpdates[symbol];
    if (buffer.length > 0) {
      const lastUpdate = buffer[buffer.length - 1];
      if (lastUpdate.ts !== update.prevTs) {
        this.bufferedOrderBookUpdates[symbol] = [];
      }
    }
    this.bufferedOrderBookUpdates[symbol].push(update);
  }
  isValidFullOrderBook(symbol, currentTs) {
    var _a3;
    if ((((_a3 = this.bufferedOrderBookUpdates[symbol]) == null ? void 0 : _a3.length) ?? 0) !== 0) {
      const earliestUpdates = this.bufferedOrderBookUpdates[symbol][0];
      return earliestUpdates.prevTs <= currentTs;
    }
    return true;
  }
  setFullOrderbook(symbol, rawOrderbook) {
    const { ts: ts2 } = rawOrderbook;
    this.rawOrderBook[symbol] = rawOrderbook;
    this.sortBufferedOrderBookUpdates(symbol);
    if (this.isValidFullOrderBook(symbol, ts2)) {
      this.applyBufferedUpdatesToRawOrderBooks(symbol);
    }
  }
  updateOrderbook(symbol, update, callback) {
    const { asks, bids, prevTs, ts: ts2 } = update;
    const rawOrderBook = this.rawOrderBook[symbol];
    if (!rawOrderBook) {
      return;
    }
    const currentTs = rawOrderBook.ts;
    if (currentTs === 0) {
      this.pushUpdateToBuffer(symbol, { asks, bids, prevTs, ts: ts2 });
      return;
    }
    if (prevTs !== currentTs) {
      this.pushUpdateToBuffer(symbol, { asks, bids, prevTs, ts: ts2 });
      if (callback) {
        callback();
      }
      return;
    }
    this.applyUpdateToRawOrderBook(symbol, update);
    this.deleteBufferedOrderBookUpdates(symbol);
  }
  getRawOrderbook(symbol) {
    return this.rawOrderBook[symbol];
  }
  resetOrderBook(symbol) {
    this.rawOrderBook[symbol] = defaultRawOrderBook;
  }
};
var orderBookService = OrderbookService.getInstance();
var orderbook_service_default = orderBookService;
var useMarkPrice = (symbol) => {
  const ws2 = useWS();
  const [price, setPrice] = useState(0);
  useEffect(() => {
    const unsubscribe = ws2.subscribe(`${symbol}@markprice`, {
      onMessage: (message) => {
        setPrice(message.price);
      }
    });
    return () => {
      unsubscribe == null ? void 0 : unsubscribe();
    };
  }, [symbol]);
  return { data: price };
};
var useSymbolsInfo = () => {
  const symbolsInfo = useAppStore((state) => state.symbolsInfo);
  return useMemo(
    () => createGetter({ ...symbolsInfo }),
    [symbolsInfo]
  );
};
var useIndexPrice = (symbol) => {
  symbol = symbol.replace("PERP", "SPOT");
  const ws2 = useWS();
  return useSWRSubscription(`${symbol}@indexprice`, (key, { next }) => {
    const unsubscribe = ws2.subscribe(`${symbol}@indexprice`, {
      onMessage: (message) => {
        next(null, message.price);
      }
    });
    return () => {
      unsubscribe == null ? void 0 : unsubscribe();
    };
  });
};
var useOpenInterest = (symbol) => {
  const ws2 = useWS();
  return useSWRSubscription(`${symbol}@openinterest`, (key, { next }) => {
    const unsubscribe = ws2.subscribe(`${symbol}@openinterest`, {
      onMessage: (message) => {
        next(null, message.openInterest);
      }
    });
    return () => {
      unsubscribe == null ? void 0 : unsubscribe();
    };
  });
};
var useFutures = () => {
  const { data, isLoading, error } = useQuery(
    `/v1/public/futures`,
    {
      revalidateOnFocus: false
    }
  );
  const [sortedData, setSortedData] = useState(data);
  useWS();
  useEffect(() => {
  }, []);
  useEffect(() => {
    if (data) {
      const sortedData2 = data.sort((a2, b2) => {
        return 0;
      });
      setSortedData(sortedData2);
    }
  }, [data]);
  const sortBy = useCallback((key) => {
  }, [data]);
  const filterBy = useCallback((key) => {
  }, [data]);
  return {
    data: sortedData,
    sortBy,
    filterBy,
    isLoading,
    error
  };
};
var useTickerStream = (symbol) => {
  if (!symbol) {
    throw new SDKError("Symbol is required");
  }
  const { data: info } = useQuery(
    `/v1/public/futures/${symbol}`,
    {
      revalidateOnFocus: false
    }
  );
  const [ticker, setTicker] = useState();
  const ws2 = useWS();
  useEffect(() => {
    const unsubscribe = ws2.subscribe(
      // { event: "subscribe", topic: "markprices" },
      `${symbol}@ticker`,
      {
        onMessage: (message) => {
          if (message.symbol !== symbol)
            return;
          setTicker(message);
        }
        // onUnsubscribe: () => {
        //   return "markprices";
        // },
        // onError: (error: any) => {
        //
        // },
      }
    );
    return () => {
      setTicker(void 0);
      unsubscribe == null ? void 0 : unsubscribe();
    };
  }, [symbol]);
  const { data: markPrice } = useMarkPrice(symbol);
  const { data: indexPrice } = useIndexPrice(symbol);
  const { data: openInterest } = useOpenInterest(symbol);
  const { data: futures } = useFutures();
  const value = useMemo(() => {
    if (!info)
      return null;
    if (!ticker || ticker.symbol !== symbol)
      return info;
    const futureIndex = futures == null ? void 0 : futures.findIndex(
      (item) => item.symbol === symbol
    );
    let _oi = openInterest;
    if (!_oi && futureIndex !== -1 && futures) {
      _oi = futures[futureIndex].open_interest;
    }
    const config2 = {
      ...info,
      mark_price: markPrice,
      index_price: indexPrice,
      open_interest: _oi
    };
    if (ticker.open !== void 0) {
      config2["24h_open"] = ticker.open;
    }
    if (ticker.close !== void 0) {
      config2["24h_close"] = ticker.close;
    }
    if (ticker.high !== void 0) {
      config2["24h_high"] = ticker.high;
    }
    if (ticker.low !== void 0) {
      config2["24h_low"] = ticker.low;
    }
    if (ticker.volume !== void 0) {
      config2["24h_volumn"] = ticker.volume;
      config2["24h_volume"] = ticker.volume;
    }
    if (ticker.close !== void 0 && ticker.open !== void 0) {
      config2["change"] = new g$6(ticker.close).minus(ticker.open).div(ticker.open).toNumber();
      config2["24h_change"] = new g$6(ticker.close).minus(ticker.open).toNumber();
    }
    return config2;
  }, [info, symbol, ticker, futures, openInterest]);
  return value;
};
var paddingFn = (len) => Array(len).fill([
  Number.NaN,
  Number.NaN,
  Number.NaN,
  Number.NaN
]);
var reduceItems = (depth, level, data, asks = false) => {
  if (!Array.isArray(data) || data.length === 0) {
    return [];
  }
  let newData = [...data];
  const result = [];
  if (typeof depth !== "undefined") {
    const prices = /* @__PURE__ */ new Map();
    for (let i = 0; i < data.length; i++) {
      const [price, quantity] = data[i];
      if (isNaN(price) || isNaN(quantity))
        continue;
      let priceKey;
      if (asks) {
        priceKey = new g$6(Math.ceil(price / depth)).mul(depth).toNumber();
      } else {
        priceKey = new g$6(Math.floor(price / depth)).mul(depth).toNumber();
      }
      if (depth < 1 && depth > 0 && priceKey.toString().indexOf(".") !== -1) {
        const priceStr = price.toString();
        const index = priceStr.indexOf(".");
        const decimal = priceStr.slice(index + 1);
        const decimalDepth = I$6(depth).toString().slice(2).length;
        const decimalStr = decimal.slice(0, min(decimal.length, decimalDepth));
        priceKey = new g$6(
          priceStr.slice(0, index) + "." + decimalStr
        ).toNumber();
      }
      if (prices.has(priceKey)) {
        const item = prices.get(priceKey);
        const itemPrice = new g$6(item[1]).add(quantity).toNumber();
        prices.set(priceKey, [priceKey, itemPrice]);
      } else {
        prices.set(priceKey, [priceKey, quantity]);
      }
    }
    newData = Array.from(prices.values());
  }
  for (let i = 0; i < newData.length; i++) {
    const [price, quantity] = newData[i];
    if (isNaN(price) || isNaN(quantity))
      continue;
    const newQuantity = new g$6(quantity).add(result.length > 0 ? result[result.length - 1][2] : 0).toNumber();
    const newAmount = new g$6(quantity * price).add(result.length > 0 ? result[result.length - 1][3] : 0).toNumber();
    result.push([price, quantity, newQuantity, newAmount]);
  }
  return result;
};
var reduceOrderbook = (depth, level, padding2, data) => {
  let asks = reduceItems(depth, level, data.asks, true);
  let bids = reduceItems(depth, level, data.bids);
  if (asks.length !== 0 && bids.length !== 0 && asks[0][0] <= bids[0][0]) {
    if (asks.length === 1) {
      const [price, qty, newQuantity, newAmount] = asks[0];
      asks.shift();
      asks.push([
        price + (depth === void 0 ? 0 : Number(depth)),
        qty,
        newQuantity,
        newAmount
      ]);
    } else {
      const [bidPrice] = bids[0];
      while (asks.length > 0) {
        const [askPrice, askQty, newQuantity, newAmount] = asks[0];
        if (askPrice <= bidPrice) {
          asks.shift();
          for (let index = 0; index < asks.length; index++) {
            if (index === 0) {
              const quantity = asks[index][1] + askQty;
              asks[index][1] = quantity;
              asks[index][2] = quantity;
              asks[index][3] = Math.ceil(quantity) * asks[index][0];
            } else {
              asks[index][3] = asks[index][0] * asks[index][1] + asks[index - 1][3];
            }
          }
        } else {
          break;
        }
      }
    }
  }
  asks = asks.reverse();
  if (padding2) {
    asks = asks.length < level ? paddingFn(level - asks.length).concat(asks) : asks;
    bids = bids.length < level ? bids.concat(paddingFn(level - bids.length)) : bids;
  }
  return {
    asks,
    bids
  };
};
var INIT_DATA = { asks: [], bids: [] };
var useOrderbookStream = (symbol, initial = INIT_DATA, options) => {
  var _a3, _b2, _c2, _d3, _e3, _f2, _g2, _h2, _i3, _j2, _k2, _l3, _m3, _n3, _o3, _p2, _q, _r3, _s3, _t2;
  if (!symbol) {
    throw new SDKError("Symbol is required");
  }
  const level = (options == null ? void 0 : options.level) ?? 10;
  const padding2 = (options == null ? void 0 : options.padding) ?? true;
  const symbolRef = useRef(symbol);
  symbolRef.current = symbol;
  const [requestData, setRequestData] = useState(null);
  const [data, setData] = useState(initial);
  const [isLoading, setIsLoading] = useState(true);
  const config2 = useSymbolsInfo()[symbol];
  const [depth, setDepth] = useState();
  const prevMiddlePrice = useRef(0);
  const depths = useMemo(() => {
    const tick = config2("quote_tick");
    if (typeof tick === "undefined")
      return [];
    try {
      const base = new g$6(tick);
      return [
        base.toNumber(),
        base.mul(10).toNumber(),
        base.mul(100).toNumber(),
        base.mul(1e3).toNumber()
      ];
    } catch (e2) {
    }
    return [tick];
  }, [config2("quote_tick")]);
  useEffect(() => {
    setDepth(config2("quote_tick"));
  }, [config2("quote_tick")]);
  const ws2 = useWS();
  const ticker = useTickerStream(symbol);
  const eventEmitter = useEventEmitter();
  useEffect(() => {
    let needRequestFullOrderbook = true;
    setIsLoading(true);
    let orderBookUpdateSub;
    let fullOrderBookUpdateSub;
    orderBookUpdateSub = ws2.subscribe(
      {
        event: "subscribe",
        topic: `${symbol}@orderbookupdate`
      },
      {
        formatter: (message) => message,
        onMessage: (message) => {
          const { data: wsData, ts: ts2 } = message;
          const { symbol: symbol2, asks, bids, prevTs } = wsData;
          if (symbolRef.current !== symbol2) {
            orderBookUpdateSub == null ? void 0 : orderBookUpdateSub();
            return;
          }
          orderbook_service_default.updateOrderbook(
            symbol2,
            { asks, bids, ts: ts2, prevTs },
            () => needRequestFullOrderbook = true
          );
          const data2 = orderbook_service_default.getRawOrderbook(symbol2);
          setData({ bids: data2.bids, asks: data2.asks });
        }
      }
    );
    if (needRequestFullOrderbook) {
      setIsLoading(true);
      fullOrderBookUpdateSub = ws2.onceSubscribe(
        {
          event: "request",
          id: `${symbol}@orderbook`,
          params: {
            type: "orderbook",
            symbol
          }
        },
        {
          formatter: (message) => message,
          onMessage: (message) => {
            const { symbol: symbol2, asks, bids, ts: ts2 } = message.data;
            if (symbolRef.current !== symbol2) {
              return;
            }
            orderbook_service_default.setFullOrderbook(symbol2, { asks, bids, ts: ts2 });
            const data2 = orderbook_service_default.getRawOrderbook(symbol2);
            setData({ bids: data2.bids, asks: data2.asks });
            setIsLoading(false);
          }
        }
      );
      needRequestFullOrderbook = false;
    }
    return () => {
      orderBookUpdateSub == null ? void 0 : orderBookUpdateSub();
      fullOrderBookUpdateSub == null ? void 0 : fullOrderBookUpdateSub();
      orderbook_service_default.resetOrderBook(symbol);
      setData(INIT_DATA);
    };
  }, [symbol]);
  const { data: markPrice } = useMarkPrice(symbol);
  const onItemClick = useCallback((item) => {
    eventEmitter.emit("orderbook:item:click", item);
  }, []);
  const onDepthChange = useCallback((depth2) => {
    setDepth(() => depth2);
  }, []);
  const reducedData = reduceOrderbook(depth, level, padding2, {
    asks: [...data.asks],
    bids: [...data.bids]
  });
  useEffect(() => {
    var _a4, _b3, _c3, _d4, _e4, _f3, _g3, _h3, _i4, _j3, _k3, _l4, _m4, _n4, _o4, _p3, _q2, _r4, _s4, _t3;
    const updateData = [
      [
        (_b3 = (_a4 = reducedData.asks) == null ? void 0 : _a4[reducedData.asks.length - 1]) == null ? void 0 : _b3[0],
        (_d4 = (_c3 = reducedData.bids) == null ? void 0 : _c3[0]) == null ? void 0 : _d4[0]
      ],
      [
        (_f3 = (_e4 = reducedData.asks) == null ? void 0 : _e4[reducedData.asks.length - 2]) == null ? void 0 : _f3[0],
        (_h3 = (_g3 = reducedData.bids) == null ? void 0 : _g3[1]) == null ? void 0 : _h3[0]
      ],
      [
        (_j3 = (_i4 = reducedData.asks) == null ? void 0 : _i4[reducedData.asks.length - 3]) == null ? void 0 : _j3[0],
        (_l4 = (_k3 = reducedData.bids) == null ? void 0 : _k3[2]) == null ? void 0 : _l4[0]
      ],
      [
        (_n4 = (_m4 = reducedData.asks) == null ? void 0 : _m4[reducedData.asks.length - 4]) == null ? void 0 : _n4[0],
        (_p3 = (_o4 = reducedData.bids) == null ? void 0 : _o4[3]) == null ? void 0 : _p3[0]
      ],
      [
        (_r4 = (_q2 = reducedData.asks) == null ? void 0 : _q2[reducedData.asks.length - 5]) == null ? void 0 : _r4[0],
        (_t3 = (_s4 = reducedData.bids) == null ? void 0 : _s4[4]) == null ? void 0 : _t3[0]
      ]
    ];
    eventEmitter.emit("orderbook:update", updateData);
  }, [
    (_b2 = (_a3 = reducedData.asks) == null ? void 0 : _a3[reducedData.asks.length - 1]) == null ? void 0 : _b2[0],
    (_d3 = (_c2 = reducedData.asks) == null ? void 0 : _c2[reducedData.asks.length - 2]) == null ? void 0 : _d3[0],
    (_f2 = (_e3 = reducedData.asks) == null ? void 0 : _e3[reducedData.asks.length - 3]) == null ? void 0 : _f2[0],
    (_h2 = (_g2 = reducedData.asks) == null ? void 0 : _g2[reducedData.asks.length - 4]) == null ? void 0 : _h2[0],
    (_j2 = (_i3 = reducedData.asks) == null ? void 0 : _i3[reducedData.asks.length - 5]) == null ? void 0 : _j2[0],
    (_l3 = (_k2 = reducedData.bids) == null ? void 0 : _k2[0]) == null ? void 0 : _l3[0],
    (_n3 = (_m3 = reducedData.bids) == null ? void 0 : _m3[1]) == null ? void 0 : _n3[0],
    (_p2 = (_o3 = reducedData.bids) == null ? void 0 : _o3[2]) == null ? void 0 : _p2[0],
    (_r3 = (_q = reducedData.bids) == null ? void 0 : _q[3]) == null ? void 0 : _r3[0],
    (_t2 = (_s3 = reducedData.bids) == null ? void 0 : _s3[4]) == null ? void 0 : _t2[0]
  ]);
  const middlePrice = useMemo(() => {
    var _a4, _b3;
    let asksFrist = 0, bidsFirst = 0;
    if (data.asks.length > 0) {
      asksFrist = (_b3 = (_a4 = reducedData.asks) == null ? void 0 : _a4[reducedData.asks.length - 1]) == null ? void 0 : _b3[0];
    }
    if (data.bids.length > 0) {
      bidsFirst = data.bids[0][0];
    }
    if (isNaN(asksFrist) || isNaN(bidsFirst) || !ticker)
      return 0;
    return [asksFrist, bidsFirst, ticker["24h_close"]].sort()[1];
  }, [ticker == null ? void 0 : ticker["24h_close"], data]);
  useEffect(() => {
    prevMiddlePrice.current = middlePrice;
  }, [middlePrice]);
  return [
    {
      asks: reducedData.asks.slice(-level),
      bids: reducedData.bids.slice(0, level),
      markPrice,
      middlePrice: [prevMiddlePrice.current, middlePrice]
    },
    { onDepthChange, depth, allDepths: depths, isLoading, onItemClick }
  ];
};
var useAccountInfo2 = () => {
  return usePrivateQuery("/v1/client/info");
};
var useMarketsStream = () => {
  const ws2 = useWS();
  const { data: futures } = useQuery(`/v1/public/futures`, {
    revalidateOnFocus: false
  });
  const topic = "tickers";
  const { data: tickers } = useSWRSubscription("tickers", (_2, { next }) => {
    const unsubscribe = ws2.subscribe(
      // { event: "subscribe", topic: "markprices" },
      topic,
      {
        onMessage: (message) => {
          next(null, message);
        }
        // onUnsubscribe: () => {
        //   return "markprices";
        // },
        // onError: (error: any) => {
        //
        // },
      }
    );
    return () => {
      unsubscribe == null ? void 0 : unsubscribe();
    };
  });
  const value = useMemo(() => {
    if (!futures)
      return null;
    if (!tickers)
      return futures;
    return futures.map((item) => {
      const ticker = tickers.find(
        (t) => t.symbol === item.symbol
      );
      if (ticker) {
        const data = {
          ...item,
          ["24h_close"]: ticker.close,
          ["24h_open"]: ticker.open,
          /**
           * @deprecated
           * spelling mistake, use 24h_volume to instead, will be remove next version
           */
          ["24h_volumn"]: ticker.volume,
          ["24h_volume"]: ticker.volume,
          ["24h_amount"]: ticker.amount,
          change: 0
        };
        if (ticker.close !== void 0 && ticker.open !== void 0) {
          data["change"] = new g$6(ticker.close).minus(ticker.open).div(ticker.open).toNumber();
        }
        return data;
      }
      return item;
    });
  }, [futures, tickers]);
  return { data: value };
};
var useFundingRates = () => {
  const data = useAppStore((state) => state.fundingRates);
  return createGetter({ ...data });
};
var MarketsType = /* @__PURE__ */ ((MarketsType2) => {
  MarketsType2[MarketsType2["FAVORITES"] = 0] = "FAVORITES";
  MarketsType2[MarketsType2["RECENT"] = 1] = "RECENT";
  MarketsType2[MarketsType2["ALL"] = 2] = "ALL";
  MarketsType2[MarketsType2["NEW_LISTING"] = 3] = "NEW_LISTING";
  return MarketsType2;
})(MarketsType || {});
var MarketsStorageKey = "orderly_markets";
var DefaultFavoriteTab = { name: "Popular", id: 1 };
var useMarketsStore = () => {
  const { configStore } = useContext(OrderlyContext);
  const ee2 = useEventEmitter();
  const id2 = useId();
  const getStore = () => {
    const store = configStore.get(MarketsStorageKey);
    return store || getDefaultStoreData();
  };
  const getStoreByKey = (key, defaultValue) => {
    const store = getStore();
    return store[key] || defaultValue;
  };
  const updateStore = (data) => {
    configStore.set(MarketsStorageKey, {
      ...getStore(),
      ...data
    });
  };
  const getFavoriteTabs = () => {
    return getStoreByKey("favoriteTabs", [{ ...DefaultFavoriteTab }]);
  };
  const getSelectedFavoriteTab = () => {
    return getStoreByKey("selectedFavoriteTab", { ...DefaultFavoriteTab });
  };
  const getFavorites = () => {
    const favs = getStoreByKey("favorites", []);
    const tabs = getFavoriteTabs();
    return filterInvalidTabs(favs, tabs);
  };
  const getRecent = () => {
    return getStoreByKey("recent", []);
  };
  const getNewListing = () => {
    return getStoreByKey("newListing", []);
  };
  const getTabSort = () => {
    return getStoreByKey("tabSort", {});
  };
  const [favoriteTabs, setFavoriteTabs] = useState(getFavoriteTabs);
  const [selectedFavoriteTab, setSelectedFavoriteTab] = useState(
    getSelectedFavoriteTab
  );
  const [favorites, setFavorites] = useState(getFavorites);
  const [recent, setRecent] = useState(getRecent);
  const [newListing, setNewListing] = useState(getNewListing);
  const [tabSort, setTabSort] = useState(getTabSort);
  const updateFavoriteTabs = (tab, operator) => {
    const tabs = updateTabs(favoriteTabs, tab, operator);
    setFavoriteTabs(tabs);
    ee2.emit("markets:changed", createEventData(id2, "favoriteTabs", tabs));
  };
  const updateSelectedFavoriteTab = (tab) => {
    setSelectedFavoriteTab(tab);
    ee2.emit(
      "markets:changed",
      createEventData(id2, "lastSelectedFavoriteTab", tab)
    );
  };
  const updateSymbolFavoriteState = (symbol, tab, remove = false) => {
    const list = updateSymbolFavorite({ favorites, symbol, tab, remove });
    setFavorites(list);
    ee2.emit("markets:changed", createEventData(id2, "favorites", list));
  };
  const addToHistory = (symbol) => {
    const list = addToTop(recent, symbol);
    setRecent(list);
    ee2.emit("markets:changed", id2);
    ee2.emit("markets:changed", createEventData(id2, "recent", list));
  };
  const pinToTop = (symbol) => {
    const newList = moveToTop(favorites, symbol);
    if (newList) {
      setFavorites(newList);
      ee2.emit("markets:changed", createEventData(id2, "favorites", newList));
    }
  };
  const updateTabsSortState = (tabId, sortKey, sortOrder) => {
    const map = getStoreByKey("tabSort", {});
    map[tabId] = {
      sortKey,
      sortOrder
    };
    setTabSort(map);
  };
  useEffect(() => {
    updateStore({
      favoriteTabs,
      favorites,
      recent,
      newListing,
      tabSort,
      selectedFavoriteTab
    });
  }, [
    favoriteTabs,
    favorites,
    recent,
    newListing,
    tabSort,
    selectedFavoriteTab
  ]);
  useEffect(() => {
    const event = ({ id: srcId, key, data }) => {
      if (srcId === id2) {
        return;
      }
      if (key === "favoriteTabs") {
        setFavoriteTabs(data);
      } else if (key === "lastSelectedFavoriteTab") {
        setSelectedFavoriteTab(data);
      } else if (key === "favorites") {
        setFavorites(data);
      } else if (key === "recent") {
        setRecent(data);
      } else if (key === "newListing") {
        setNewListing(data);
      }
    };
    ee2.on("markets:changed", event);
    return () => {
      ee2.off("markets:changed", event);
    };
  }, [id2]);
  return {
    favoriteTabs,
    favorites,
    recent,
    newListing,
    tabSort,
    selectedFavoriteTab,
    updateFavorites: setFavorites,
    updateFavoriteTabs,
    updateSymbolFavoriteState,
    pinToTop,
    addToHistory,
    updateSelectedFavoriteTab,
    updateTabsSortState
  };
};
var useMarkets = (type = 2) => {
  const { data: futures } = useMarketsStream();
  const symbolsInfo = useSymbolsInfo();
  const [markets, setMarkets] = useState([]);
  const store = useMarketsStore();
  const { favorites, recent, newListing } = store;
  useEffect(() => {
    const markets2 = addFieldToMarkets(futures, symbolsInfo);
    const filterList = filterMarkets({
      markets: markets2,
      favorites,
      recent,
      newListing,
      type
    });
    setMarkets(filterList);
  }, [futures, symbolsInfo, favorites, recent, newListing, type]);
  return [markets, store];
};
var addFieldToMarkets = (futures, symbolsInfo) => {
  var _a3;
  return (_a3 = futures || []) == null ? void 0 : _a3.map((item) => {
    const info = symbolsInfo[item.symbol];
    return {
      ...item,
      quote_dp: info("quote_dp"),
      created_time: info("created_time"),
      leverage: getLeverage(info("base_imr")),
      openInterest: getOpenInterest(item.open_interest, item.index_price),
      "8h_funding": get8hFunding2(item.est_funding_rate, info("funding_period")),
      change: get24hChange2({
        change: item.change,
        close: item["24h_close"],
        open: item["24h_open"]
      })
    };
  });
};
var filterMarkets = (params) => {
  const { markets, favorites, recent, newListing, type } = params;
  let curData = [];
  if (type === 2) {
    curData = markets;
  } else if (type === 3) {
    curData = markets.filter((item) => isNewListing(item.created_time)).sort((a2, b2) => b2.created_time - a2.created_time);
  } else {
    const storageData = type === 0 ? favorites : type === 1 ? recent : newListing;
    const keys = storageData.map((item) => item.name);
    curData = markets == null ? void 0 : markets.filter((item) => keys.includes(item.symbol));
  }
  const favoriteKeys = favorites.map((item) => item.name);
  return curData == null ? void 0 : curData.map((item) => ({
    ...item,
    isFavorite: type === 0 ? true : favoriteKeys.includes(item.symbol)
  }));
};
function isEmpty(value) {
  return value === void 0 || value === null;
}
var isNewListing = (createdTime) => {
  const thirtyDaysInMs = 30 * 24 * 60 * 60 * 1e3;
  const now = Date.now();
  return now - createdTime < thirtyDaysInMs;
};
function get8hFunding2(est_funding_rate, funding_period) {
  let funding8h = 0;
  if (isEmpty(est_funding_rate)) {
    return null;
  }
  if (funding_period) {
    funding8h = new g$6(est_funding_rate || 0).mul(funding_period).div(8).toNumber();
  }
  return funding8h;
}
function get24hChange2(params) {
  const { change, close, open: open2 } = params;
  if (change !== void 0) {
    return change;
  }
  if (!isEmpty(close) && !isEmpty(open2)) {
    if (open2 === 0) {
      return 0;
    }
    return new g$6(close).minus(open2).div(open2).toNumber();
  }
}
function getLeverage(base_imr) {
  return base_imr ? 1 / base_imr : void 0;
}
function getOpenInterest(open_interest, index_price) {
  return new g$6(open_interest || 0).mul(index_price || 0).toNumber();
}
function getDefaultStoreData() {
  return {
    recent: [],
    favorites: [
      { name: "PERP_ETH_USDC", tabs: [{ ...DefaultFavoriteTab }] },
      { name: "PERP_BTC_USDC", tabs: [{ ...DefaultFavoriteTab }] }
    ],
    favoriteTabs: [{ ...DefaultFavoriteTab }],
    selectedFavoriteTab: { ...DefaultFavoriteTab },
    tabSort: {}
  };
}
function filterInvalidTabs(favorites, tabs) {
  return favorites.map((favorite) => {
    return {
      ...favorite,
      tabs: favorite.tabs.filter(
        (tab) => !!tabs.find((item) => item.id === tab.id)
      )
    };
  }).filter((item) => !!item.tabs.length);
}
function updateTabs(favoriteTabs, tab, operator) {
  if (Array.isArray(tab)) {
    return tab;
  }
  const tabs = [...favoriteTabs];
  const index = tabs.findIndex((item) => item.id === tab.id);
  if (operator == null ? void 0 : operator.add) {
    tabs.push(tab);
  } else if ((operator == null ? void 0 : operator.update) && index !== -1) {
    tabs[index] = tab;
  } else if ((operator == null ? void 0 : operator.delete) && index !== -1) {
    tabs.splice(index, 1);
  }
  return tabs;
}
function addToTop(recent, symbol) {
  const list = [...recent];
  const index = list.findIndex((item) => item.name == symbol.symbol);
  if (index !== -1) {
    list.splice(index, 1);
  }
  list.unshift({ name: symbol.symbol });
  return list;
}
function moveToTop(favorites, symbol) {
  const index = favorites.findIndex((item) => item.name === symbol.symbol);
  if (index !== -1) {
    const item = favorites[index];
    const list = [...favorites];
    list.splice(index, 1);
    list.unshift(item);
    return list;
  }
}
function updateSymbolFavorite(params) {
  const { favorites, symbol, tab, remove = false } = params;
  const list = [...favorites];
  const index = list.findIndex((item) => item.name == symbol.symbol);
  const tabs = Array.isArray(tab) ? tab : [tab];
  if (index === -1) {
    if (tabs.length && !remove) {
      list.unshift({ name: symbol.symbol, tabs });
    }
  } else {
    const favorite = list[index];
    if (Array.isArray(tab)) {
      if (!tab.length) {
        list.splice(index, 1);
      } else {
        list[index] = { ...favorite, tabs: tab };
      }
    } else {
      if (remove) {
        const tabs2 = favorite.tabs.filter((item) => item.id != tab.id);
        if (!tabs2.length) {
          list.splice(index, 1);
        } else {
          list[index] = { ...favorite, tabs: tabs2 };
        }
      } else {
        list[index] = { ...favorite, tabs: [...favorite.tabs, tab] };
      }
    }
  }
  return list;
}
function createEventData(id2, key, data) {
  return {
    id: id2,
    key,
    data
  };
}
var useMarkPricesStream = () => {
  const data = useMarkPriceStore((state) => state.markPrices);
  return { data };
};
var generateLeverageLevers = (max3) => {
  const min3 = 1;
  const parts = 5;
  const step = (max3 - min3) / (parts - 1);
  const result = [];
  for (let i = 0; i < parts; i++) {
    result.push(Math.floor(min3 + step * i));
  }
  return result;
};
var useLeverage = () => {
  const { data, mutate: mutate3 } = usePrivateQuery(
    "/v1/client/info"
  );
  const [update, { isMutating }] = useMutation("/v1/client/leverage");
  const { data: leverageConfig, isLoading } = useQuery("/v1/public/leverage", {
    revalidateOnFocus: false,
    errorRetryCount: 3
    // formatter: (data) => data,
  });
  const updateLeverage = useCallback(
    async (data2) => {
      const res = await update(data2);
      if (res.success) {
        return mutate3();
      } else {
        throw new Error(res.message);
      }
    },
    [update, mutate3]
  );
  const memoizedCurLeverage = useMemo(() => {
    if ((data == null ? void 0 : data.max_leverage) !== void 0) {
      return Number(data.max_leverage);
    }
    return 1;
  }, [data == null ? void 0 : data.max_leverage]);
  const memoizedMaxLeverage = useMemo(() => {
    if ((leverageConfig == null ? void 0 : leverageConfig.max_futures_leverage) !== void 0) {
      return Number(leverageConfig.max_futures_leverage);
    }
    return 1;
  }, [leverageConfig == null ? void 0 : leverageConfig.max_futures_leverage]);
  const memoizedLeverageLevers = useMemo(() => {
    return generateLeverageLevers(memoizedMaxLeverage);
  }, [memoizedMaxLeverage]);
  return {
    update: updateLeverage,
    isLoading: isLoading || isMutating,
    leverageLevers: memoizedLeverageLevers,
    curLeverage: memoizedCurLeverage,
    maxLeverage: memoizedMaxLeverage
  };
};
var useFundingRate = (symbol) => {
  if (!symbol) {
    throw new SDKError("Symbol is required");
  }
  const [countDown, setCountDown] = useState("00:00:00");
  const { data } = useQuery(
    `/v1/public/funding_rate/${symbol}`,
    {
      fallbackData: {
        est_funding_rate: 0,
        next_funing_time: 0
      }
    }
  );
  useEffect(() => {
    if (!data)
      return;
    const { next_funding_time } = data;
    if (!next_funding_time || next_funding_time <= 0) {
      return;
    }
    const timer = setInterval(() => {
      const diff = new Date(next_funding_time).getTime() - T$1();
      const result = P$3(diff);
      if (result.length === 3) {
        setCountDown(
          `${result[0].toString().padStart(2, "0")}:${result[1].toString().padStart(2, "0")}:${result[2].toString().padStart(2, "0")}`
        );
      }
    }, 1e3);
    return () => {
      clearInterval(timer);
    };
  }, [data]);
  const est_funding_rate = useMemo(() => {
    if (!data)
      return;
    const { next_funding_time, est_funding_rate: est_funding_rate2 = 0 } = data;
    if (T$1() > next_funding_time) {
      return null;
    }
    return new g$6(Number(est_funding_rate2) * 100).toFixed(
      4,
      g$6.ROUND_DOWN
    );
  }, [data]);
  return {
    ...data,
    est_funding_rate,
    countDown
  };
};
var calculatePositiveRate = (periodData, period) => {
  if (!periodData || !period)
    return 0;
  const daysMap = {
    "1d": 1,
    "3d": 3,
    "7d": 7,
    "14d": 14,
    "30d": 30,
    "90d": 90
  };
  const totalTimes = daysMap[period] * 3;
  return periodData.positive / totalTimes;
};
var useFundingRateHistory = () => {
  const { data: historyData, isLoading } = useQuery(
    "/v1/public/market_info/funding_history"
  );
  const getPositiveRates = useCallback(
    (data, period) => {
      if (!(data == null ? void 0 : data.length))
        return {};
      return data.reduce(
        (acc, item) => {
          acc[item.symbol] = calculatePositiveRate(
            item.funding[period],
            period
          );
          return acc;
        },
        {}
      );
    },
    []
  );
  return {
    data: historyData ?? [],
    isLoading,
    getPositiveRates
  };
};
var findTPSLFromOrders = (orders, symbol) => {
  const order = findPositionTPSLFromOrders(orders, symbol);
  if (!order)
    return;
  return findTPSLFromOrder(order);
};
var findTPSLFromOrder = (order) => {
  var _a3, _b2;
  let tp_trigger_price;
  let sl_trigger_price;
  const tpOrder = (_a3 = order == null ? void 0 : order.child_orders) == null ? void 0 : _a3.find(
    (order2) => order2.algo_type === AlgoOrderType.TAKE_PROFIT
  );
  const slOrder = (_b2 = order == null ? void 0 : order.child_orders) == null ? void 0 : _b2.find(
    (order2) => order2.algo_type === AlgoOrderType.STOP_LOSS
  );
  if (tpOrder) {
    tp_trigger_price = tpOrder.trigger_price;
  }
  if (slOrder) {
    sl_trigger_price = slOrder.trigger_price;
  }
  return {
    tp_trigger_price,
    sl_trigger_price
  };
};
var findPositionTPSLFromOrders = (orders, symbol) => {
  return orders == null ? void 0 : orders.find((order) => {
    return order.symbol === symbol && order.algo_type === AlgoOrderRootType.POSITIONAL_TP_SL && (order.root_algo_status === OrderStatus.NEW || order.root_algo_status === OrderStatus.REPLACED || order.root_algo_status === OrderStatus.PARTIAL_FILLED);
  });
};
var usePositionStream = (symbol = "all", options) => {
  const { calcMode } = options || {};
  const { includedPendingOrder = false } = options || {};
  const positionCalculator = useRef(null);
  const calculatorService = useCalculatorService();
  const [tpslOrders] = useOrderStream(
    {
      symbol: symbol === "all" ? void 0 : symbol,
      status: OrderStatus.INCOMPLETE,
      includes: [AlgoOrderRootType.POSITIONAL_TP_SL, AlgoOrderRootType.TP_SL],
      size: 500
    },
    {
      keeplive: true
    }
  );
  const { positions: positionStatus } = useApiStatusStore(
    (state) => state.apis
  );
  useEffect(() => {
    if (symbol === "all")
      return;
    positionCalculator.current = new PositionCalculator(symbol);
    calculatorService.register(
      "position",
      positionCalculator.current
    );
    calculatorService.register(
      "markPrice",
      positionCalculator.current
    );
    calculatorService.register(
      "indexPrice",
      positionCalculator.current
    );
    return () => {
      calculatorService.unregister(
        "position",
        positionCalculator.current
      );
      calculatorService.unregister(
        "markPrice",
        positionCalculator.current
      );
      calculatorService.unregister(
        "indexPrice",
        positionCalculator.current
      );
    };
  }, [symbol]);
  const formattedPositions = usePositionStore((state) => {
    const positions2 = state.positions[symbol] ?? POSITION_EMPTY;
    return [positions2.rows, omit(["rows"], positions2)];
  });
  const { totalCollateral: totalCollateral2, totalValue: totalValue2, totalUnrealizedROI: totalUnrealizedROI2 } = useAppStore(
    (state) => state.portfolio
  );
  const aggregated = useMemo(() => {
    let data = formattedPositions[1];
    if (!data)
      return {};
    if (calcMode === "markPrice")
      return data;
    const { total_unreal_pnl_index, unrealPnlROI_index, ...rest } = data;
    return {
      ...rest,
      unrealPnL: total_unreal_pnl_index,
      total_unreal_pnl: total_unreal_pnl_index,
      unrealPnlROI: unrealPnlROI_index
    };
  }, [calcMode]);
  let rows = formattedPositions[0];
  {
    if (!rows) {
      rows = [];
    }
    if (!includedPendingOrder) {
      rows = rows.filter((item) => item.position_qty !== 0);
    } else {
      rows = rows.filter(
        (item) => item.position_qty !== 0 || item.pending_long_qty !== 0 || item.pending_short_qty !== 0
      );
    }
    if (calcMode === "lastPrice") {
      rows = rows.map((item) => {
        const {
          unrealized_pnl_index,
          unrealized_pnl_ROI_index,
          ...rust
        } = item;
        return {
          ...rust,
          unrealized_pnl: unrealized_pnl_index ?? 0,
          unsettled_pnl_ROI: unrealized_pnl_ROI_index ?? 0
          // mark_price: item.last_price,
        };
      });
    }
    if (Array.isArray(tpslOrders) && tpslOrders.length) {
      rows = rows.map((item) => {
        const related_order = findPositionTPSLFromOrders(
          tpslOrders,
          item.symbol
        );
        const tp_sl_pricer = !!related_order ? findTPSLFromOrder(related_order) : void 0;
        return {
          ...item,
          tp_trigger_price: tp_sl_pricer == null ? void 0 : tp_sl_pricer.tp_trigger_price,
          sl_trigger_price: tp_sl_pricer == null ? void 0 : tp_sl_pricer.sl_trigger_price,
          algo_order: related_order
        };
      });
    }
  }
  const positionInfoGetter = createGetter(aggregated, 1);
  return [
    {
      rows,
      // rows: formattedPositions[0],
      aggregated: (formattedPositions == null ? void 0 : formattedPositions[1]) ?? {},
      totalCollateral: totalCollateral2,
      totalValue: totalValue2,
      totalUnrealizedROI: totalUnrealizedROI2
    },
    positionInfoGetter,
    {
      /**
       * @deprecated use `isLoading` instead
       */
      loading: positionStatus.loading,
      isLoading: positionStatus.loading
      // isValidating,
      // // showSymbol,
      // error,
      // // loadMore: () => {},
      // refresh: refreshPositions,
    }
  ];
};
pathOr(0, [
  0,
  "aggregated",
  "unsettledPnL"
]);
var useOrderStream = (params, options) => {
  var _a3;
  const {
    status,
    symbol,
    side,
    size = 50,
    page,
    dateRange
  } = params;
  const [includes2, setIncludes] = useState(params.includes ?? ["ALL"]);
  const [excludes, setExcludes] = useState(params.excludes ?? []);
  const { data: markPrices } = useMarkPricesStream();
  const { registerKeyHandler, unregisterKeyHandler } = useDataCenterContext();
  const [
    doCancelOrder,
    { error: cancelOrderError, isMutating: cancelMutating }
  ] = useMutation("/v1/order", "DELETE");
  const [doCancelAllOrders] = useMutation("/v1/orders", "DELETE");
  const [
    doUpdateOrder,
    { error: updateOrderError, isMutating: updateMutating }
  ] = useMutation("/v1/order", "PUT");
  const [
    doCancelAlgolOrder,
    { error: cancelAlgoOrderError, isMutating: cancelAlgoMutating }
  ] = useMutation("/v1/algo/order", "DELETE");
  const [doCancelAllAlgoOrders] = useMutation("/v1/algo/orders", "DELETE");
  const [
    doUpdateAlgoOrder,
    { error: updateAlgoOrderError, isMutating: updateAlgoMutating }
  ] = useMutation("/v1/algo/order", "PUT");
  useEffect(() => {
    const formatKey = (value) => value ? `:${value}` : "";
    const key = `orders${formatKey(status)}${formatKey(symbol)}${formatKey(
      side
    )}${formatKey(size.toString())}`;
    registerKeyHandler == null ? void 0 : registerKeyHandler(
      key,
      generateKeyFun({ status, symbol, side, size, page, dateRange })
    );
    return () => {
      if (!(options == null ? void 0 : options.stopOnUnmount))
        return;
      unregisterKeyHandler(key);
    };
  }, [status, symbol, side, size, page, dateRange, options == null ? void 0 : options.keeplive]);
  const ordersResponse = usePrivateInfiniteQuery(
    generateKeyFun({ status, symbol, side, size, page, dateRange }),
    {
      initialSize: 1,
      // revalidateFirstPage: false,
      // onError: (err) => {
      //   console.error("fetch failed::::", err);
      // },
      formatter: (data) => data,
      revalidateOnFocus: false
    }
  );
  const flattenOrders = useMemo(() => {
    var _a4, _b2;
    if (!ordersResponse.data) {
      return null;
    }
    let orders2 = (_b2 = (_a4 = ordersResponse.data) == null ? void 0 : _a4.map((item) => item.rows)) == null ? void 0 : _b2.flat();
    if (includes2.includes("ALL") && excludes.length === 0) {
      return orders2;
    }
    if (includes2.includes("ALL") && excludes.length > 0) {
      return orders2 == null ? void 0 : orders2.filter((item) => !excludes.includes(item.algo_type));
    }
    if (includes2.length > 0 && excludes.length === 0) {
      return orders2 == null ? void 0 : orders2.filter((item) => includes2.includes(item.algo_type));
    }
    if (includes2.length > 0 && excludes.length > 0) {
      return orders2 == null ? void 0 : orders2.filter(
        (item) => includes2.includes(item.algo_type) && !excludes.includes(item.algo_type)
      );
    }
    return orders2;
  }, [ordersResponse.data, includes2, excludes]);
  const orders = useMemo(() => {
    if (!flattenOrders) {
      return null;
    }
    if (status !== OrderStatus.NEW && status !== OrderStatus.INCOMPLETE) {
      return flattenOrders;
    }
    return flattenOrders.map((item) => {
      const order = {
        ...item,
        mark_price: (markPrices ?? {})[item.symbol] ?? 0
      };
      if (order.algo_type === AlgoOrderRootType.POSITIONAL_TP_SL || order.algo_type === AlgoOrderRootType.TP_SL) {
        order.quantity = order.child_orders[0].quantity;
      }
      return order;
    });
  }, [flattenOrders, markPrices, status]);
  const total = useMemo(() => {
    return (orders == null ? void 0 : orders.length) || 0;
  }, [orders == null ? void 0 : orders.length]);
  const cancelAlgoOrdersByTypes = (types) => {
    if (!types) {
      throw new SDKError("Types is required");
    }
    if (!Array.isArray(types)) {
      throw new SDKError("Types should be an array");
    }
    return Promise.all(
      types.map((type) => {
        return doCancelAllAlgoOrders(null, { algo_type: type });
      })
    );
  };
  const cancelAllOrders = useCallback(() => {
    return Promise.all([
      doCancelAllOrders(null),
      doCancelAllAlgoOrders(null, { algo_type: "STOP" })
    ]);
  }, [ordersResponse.data]);
  const cancelAllTPSLOrders = useCallback(() => {
    return cancelAlgoOrdersByTypes([
      AlgoOrderRootType.POSITIONAL_TP_SL,
      AlgoOrderRootType.TP_SL
    ]);
  }, [ordersResponse.data]);
  const _updateOrder = useCallback(
    (orderId, order, type) => {
      switch (type) {
        case "algoOrder":
          return doUpdateAlgoOrder({
            order_id: orderId,
            price: order["order_price"],
            quantity: order["order_quantity"],
            trigger_price: order["trigger_price"]
          });
        default:
          return doUpdateOrder({ ...order, order_id: orderId });
      }
    },
    []
  );
  const updateOrder = useCallback((orderId, order) => {
    return _updateOrder(orderId, order, "normalOrder");
  }, []);
  const updateAlgoOrder = useCallback((orderId, order) => {
    return _updateOrder(orderId, order, "algoOrder");
  }, []);
  const _cancelOrder = useCallback(
    (orderId, type, symbol2) => {
      switch (type) {
        case "algoOrder":
          return doCancelAlgolOrder(null, {
            // @ts-ignore
            order_id: orderId,
            symbol: symbol2,
            source: `SDK${version_default}`
          }).then((res) => {
            if (res.success) {
              ordersResponse.mutate();
              return res;
            } else {
              throw new Error(res.message);
            }
          });
        default:
          return doCancelOrder(null, {
            order_id: orderId,
            symbol: symbol2,
            source: `SDK_${version_default}`
          }).then((res) => {
            if (res.success) {
              return res;
            } else {
              throw new Error(res.message);
            }
          });
      }
    },
    []
  );
  const cancelOrder = useCallback((orderId, symbol2) => {
    return _cancelOrder(orderId, "normalOrder", symbol2);
  }, []);
  const cancelAlgoOrder = useCallback((orderId, symbol2) => {
    return _cancelOrder(orderId, "algoOrder", symbol2);
  }, []);
  const loadMore = () => {
    ordersResponse.setSize(ordersResponse.size + 1);
  };
  const cancelTPSLChildOrder = useCallback(
    (orderId, rootAlgoOrderId) => {
      return doUpdateAlgoOrder({
        order_id: rootAlgoOrderId,
        child_orders: [
          {
            order_id: orderId,
            is_activated: false
          }
        ]
      });
    },
    []
  );
  const updateTPSLOrder = useCallback(
    (orderId, childOrders) => {
      if (!Array.isArray(childOrders)) {
        throw new SDKError("Children orders is required");
      }
      return doUpdateAlgoOrder({
        order_id: orderId,
        child_orders: childOrders
      });
    },
    []
  );
  const meta2 = useMemo(() => {
    var _a4, _b2;
    return (_b2 = (_a4 = ordersResponse.data) == null ? void 0 : _a4[0]) == null ? void 0 : _b2.meta;
  }, [(_a3 = ordersResponse.data) == null ? void 0 : _a3[0]]);
  return [
    orders,
    {
      total,
      isLoading: ordersResponse.isLoading,
      refresh: ordersResponse.mutate,
      loadMore,
      cancelAllOrders,
      cancelAllTPSLOrders,
      cancelAlgoOrdersByTypes,
      updateOrder,
      cancelOrder,
      updateAlgoOrder,
      cancelAlgoOrder,
      cancelTPSLChildOrder,
      updateTPSLOrder,
      meta: meta2,
      errors: {
        cancelOrder: cancelOrderError,
        updateOrder: updateOrderError,
        cancelAlgoOrder: cancelAlgoOrderError,
        updateAlgoOrder: updateAlgoOrderError
      },
      submitting: {
        cancelOrder: cancelMutating,
        updateOrder: updateMutating,
        cancelAlgoOrder: cancelAlgoMutating,
        updateAlglOrder: updateAlgoMutating
      }
    }
  ];
};
var useMarketTradeStream = (symbol, options = {}) => {
  if (!symbol) {
    throw new SDKError("Symbol is required");
  }
  const [trades, setTrades] = useState([]);
  const [isLoading, setIsLoading] = useState(false);
  const { limit = 50 } = options;
  const ws2 = useWS();
  useEffect(() => {
    setIsLoading(true);
    setTrades(() => []);
    ws2.onceSubscribe(
      {
        id: `${symbol}@trade`,
        event: "request",
        params: {
          type: "trade",
          symbol,
          limit
        }
      },
      {
        onMessage: (data) => {
          setIsLoading(false);
          setTrades(() => data);
        }
      }
    );
  }, [symbol]);
  useEffect(() => {
    const unsubscript = ws2.subscribe(
      {
        id: `${symbol}@trade`,
        event: "subscribe",
        topic: `${symbol}@trade`,
        ts: T$1()
      },
      {
        onMessage: (data) => {
          setTrades((prev) => {
            const arr = [{ ...data, ts: T$1() }, ...prev];
            if (arr.length > limit) {
              arr.pop();
            }
            return arr;
          });
        }
      }
    );
    return () => {
      unsubscript == null ? void 0 : unsubscript();
    };
  }, [symbol]);
  return { data: trades, isLoading };
};
var useCollateral = (options = { dp: 6 }) => {
  const { dp } = options;
  const {
    totalCollateral: totalCollateral2,
    totalValue: totalValue2,
    freeCollateral: freeCollateral2,
    availableBalance: availableBalance2,
    unsettledPnL
  } = useAppStore((state) => state.portfolio);
  const accountInfo = useAppStore((state) => state.accountInfo);
  return {
    totalCollateral: totalCollateral2.toDecimalPlaces(dp).toNumber(),
    freeCollateral: freeCollateral2.toDecimalPlaces(dp).toNumber(),
    totalValue: (totalValue2 == null ? void 0 : totalValue2.toDecimalPlaces(dp).toNumber()) ?? null,
    availableBalance: availableBalance2,
    unsettledPnL,
    accountInfo
    // @hidden
    // positions: positionsPath(positions),
  };
};
var useMaxQty = (symbol, side, reduceOnly = false) => {
  const positions2 = usePositions();
  const [orders] = useOrderStream({ status: OrderStatus.NEW, size: 500 });
  const accountInfo = useAccountInfo();
  const symbolInfo = useSymbolsInfo();
  const { totalCollateral: totalCollateral2 } = useCollateral();
  const { data: markPrices } = useMarkPricesStream();
  const maxQty2 = useMemo(() => {
    if (!symbol)
      return 0;
    const positionQty = account_exports.getQtyFromPositions(
      positions2 === null ? [] : positions2,
      symbol
    );
    if (reduceOnly) {
      if (positionQty > 0) {
        if (side === OrderSide.BUY) {
          return 0;
        } else {
          return Math.abs(positionQty);
        }
      }
      if (positionQty < 0) {
        if (side === OrderSide.BUY) {
          return Math.abs(positionQty);
        } else {
          return 0;
        }
      }
      return 0;
    }
    if (!markPrices || !markPrices[symbol] || !orders || !accountInfo)
      return 0;
    const getSymbolInfo = symbolInfo[symbol];
    const filterAlgoOrders = orders.filter(
      (item) => item.algo_order_id === void 0 || item.algo_type === "BRACKET"
    );
    const buyOrdersQty = account_exports.getQtyFromOrdersBySide(
      filterAlgoOrders,
      symbol,
      OrderSide.BUY
    );
    const sellOrdersQty = account_exports.getQtyFromOrdersBySide(
      filterAlgoOrders,
      symbol,
      OrderSide.SELL
    );
    const otherPositions = !Array.isArray(positions2) ? [] : positions2.filter((item) => item.symbol !== symbol);
    const otherOrders = filterAlgoOrders.filter(
      (item) => item.symbol !== symbol
    );
    const otherIMs2 = account_exports.otherIMs({
      orders: otherOrders,
      positions: otherPositions,
      symbolInfo,
      markPrices,
      IMR_Factors: accountInfo.imr_factor,
      maxLeverage: accountInfo.max_leverage
    });
    return account_exports.maxQty(side, {
      markPrice: markPrices[symbol],
      symbol,
      baseMaxQty: getSymbolInfo("base_max"),
      totalCollateral: totalCollateral2,
      maxLeverage: accountInfo.max_leverage,
      takerFeeRate: accountInfo.futures_taker_fee_rate,
      baseIMR: getSymbolInfo("base_imr"),
      otherIMs: otherIMs2,
      positionQty,
      buyOrdersQty,
      sellOrdersQty,
      IMR_Factor: accountInfo.imr_factor[symbol]
    });
  }, [
    symbol,
    positions2,
    reduceOnly,
    markPrices,
    orders,
    accountInfo,
    symbolInfo,
    side,
    totalCollateral2
  ]);
  return Math.max(maxQty2, 0);
};
var useMarginRatio = () => {
  const positions2 = usePositionStore((state2) => state2.positions.all);
  const { rows } = positions2;
  const { notional: notional2 } = positions2;
  const { state } = useAccount();
  const { data: markPrices } = useMarkPricesStream();
  const { totalCollateral: totalCollateral2 } = useCollateral();
  const marginRatio = useMemo(() => {
    if (!rows || !markPrices || !totalCollateral2 || rows.length === 0) {
      return 0;
    }
    return account_exports.totalMarginRatio({
      totalCollateral: totalCollateral2,
      markPrices,
      positions: rows ?? []
    });
  }, [rows, markPrices, totalCollateral2]);
  const currentLeverage2 = useMemo(() => {
    if (state.status >= AccountStatusEnum.EnableTrading || state.status === AccountStatusEnum.EnableTradingWithoutConnected) {
      return account_exports.currentLeverage(marginRatio);
    }
    return null;
  }, [marginRatio, state.status]);
  const mmr = useMemo(() => {
    if (!rows || rows.length <= 0 || notional2 == null)
      return null;
    let positionsMM = $$4;
    for (let index = 0; index < rows.length; index++) {
      const item = rows[index];
      if (item.mm !== null) {
        positionsMM = positionsMM.add(item.mm);
      }
    }
    return account_exports.MMR({
      positionsMMR: positionsMM.toNumber(),
      positionsNotional: notional2
    });
  }, [rows, notional2]);
  return { marginRatio, currentLeverage: currentLeverage2, mmr };
};
var TestNetWhiteList = [
  ARBITRUM_TESTNET_CHAINID,
  SOLANA_TESTNET_CHAINID,
  MONAD_TESTNET_CHAINID,
  ABSTRACT_TESTNET_CHAINID
];
var testnetTokenFallback = TesntTokenFallback([
  ArbitrumSepoliaTokenInfo,
  SolanaDevnetTokenInfo
]);
var testnetChainFallback = [ArbitrumSepoliaChainInfo, SolanaDevnetChainInfo];
function useChains(networkId, options = {}) {
  const { pick: pickField, ...swrOptions } = options;
  const {
    filteredChains: allowedChains,
    configStore,
    customChains
  } = useContext(OrderlyContext);
  const filterFun = useRef(options == null ? void 0 : options.filter);
  filterFun.current = options == null ? void 0 : options.filter;
  const chainsMap = useRef(/* @__PURE__ */ new Map());
  const commonSwrOpts = {
    revalidateIfStale: false,
    revalidateOnFocus: false,
    revalidateOnReconnect: false,
    // If false, undefined data gets cached against the key.
    revalidateOnMount: true,
    // dont duplicate a request w/ same key for 1hr
    dedupingInterval: 36e5,
    ...swrOptions
  };
  const { data: tokenChainsRes, error: tokenError } = useQuery(
    "https://api.orderly.org/v1/public/token",
    { ...commonSwrOpts }
  );
  const { data: testTokenChainsRes } = useQuery(
    "https://testnet-api.orderly.org/v1/public/token",
    {
      ...commonSwrOpts,
      fallbackData: testnetTokenFallback
    }
  );
  const brokerId = configStore.get("brokerId");
  const needFetchFromAPI = options.forceAPI || !customChains;
  const { data: chainInfos, error: chainInfoErr } = useQuery(
    needFetchFromAPI ? `https://api.orderly.org/v1/public/chain_info${brokerId !== "orderly" ? `?broker_id=${brokerId}` : ""}` : null,
    { ...commonSwrOpts }
  );
  const { data: testChainInfos, error: testChainInfoError } = useQuery(
    needFetchFromAPI ? `https://testnet-api.orderly.org/v1/public/chain_info${brokerId !== "orderly" ? `?broker_id=${brokerId}` : ""}` : null,
    {
      ...commonSwrOpts,
      fallbackData: testnetChainFallback,
      onError: (error) => {
      }
    }
  );
  const chains = useMemo(() => {
    const tokenChains = fillChainsInfo(
      tokenChainsRes,
      filterFun.current,
      chainInfos
    );
    const testTokenChains = fillChainsInfo(
      testTokenChainsRes,
      void 0,
      testChainInfos
    );
    let testnetArr = needFetchFromAPI ? filterAndUpdateChains(testTokenChains, testChainInfos, void 0, true) : customChains == null ? void 0 : customChains.testnet;
    tokenChains == null ? void 0 : tokenChains.forEach((item) => {
      var _a3;
      const chainId = (_a3 = item.network_infos) == null ? void 0 : _a3.chain_id;
      chainsMap.current.set(chainId, item);
    });
    testnetArr.forEach((chain) => {
      var _a3;
      chainsMap.current.set((_a3 = chain.network_infos) == null ? void 0 : _a3.chain_id, chain);
    });
    let mainnetArr = [];
    mainnetArr = filterAndUpdateChains(
      tokenChains,
      chainInfos,
      filterFun.current
    );
    mainnetArr = needFetchFromAPI ? mainnetArr : customChains == null ? void 0 : customChains.mainnet;
    mainnetArr.forEach((item) => {
      var _a3;
      const chainId = (_a3 = item.network_infos) == null ? void 0 : _a3.chain_id;
      chainsMap.current.set(chainId, item);
    });
    mainnetArr = filterByAllowedChains(mainnetArr, allowedChains == null ? void 0 : allowedChains.mainnet);
    testnetArr = filterByAllowedChains(
      testnetArr,
      (allowedChains == null ? void 0 : allowedChains.testnet) ?? TestNetWhiteList.map((id2) => ({ id: id2 }))
    );
    if (!!pickField) {
      testnetArr = testnetArr.map((item) => item[pickField]);
      mainnetArr = mainnetArr.map((item) => item[pickField]);
    }
    if (networkId === "mainnet") {
      return mainnetArr;
    }
    if (networkId === "testnet") {
      return testnetArr;
    }
    return {
      testnet: testnetArr,
      mainnet: mainnetArr
    };
  }, [
    networkId,
    tokenChainsRes,
    chainInfos,
    testChainInfos,
    testTokenChainsRes,
    customChains,
    pickField,
    allowedChains
  ]);
  const findByChainId = useCallback(
    (chainId, field) => {
      var _a3, _b2;
      const chain = chainsMap.current.get(chainId);
      if (chain) {
        chain.nativeToken = ((_a3 = chain.token_infos) == null ? void 0 : _a3.find(
          (item) => item.address === nativeTokenAddress
        )) || {
          symbol: (_b2 = chain.network_infos) == null ? void 0 : _b2.currency_symbol
        };
      }
      if (typeof field === "string") {
        return prop(field, chain);
      }
      return chain;
    },
    [chains, chainsMap]
  );
  const checkChainSupport = useCallback(
    (chainId, networkId2) => {
      const _chains = Array.isArray(chains) ? chains : chains[networkId2];
      return _checkChainSupport(chainId, _chains);
    },
    [chains]
  );
  return [
    chains,
    {
      findByChainId,
      checkChainSupport,
      error: tokenError
    }
  ];
}
function _checkChainSupport(chainId, chains) {
  if (typeof chainId === "string") {
    chainId = parseInt(chainId);
  }
  return chains.some((chain) => {
    return chain.network_infos.chain_id === chainId;
  });
}
function fillChainsInfo(chains, filter, chainInfos) {
  const _chains = [];
  chains == null ? void 0 : chains.forEach((item) => {
    item.chain_details.forEach((chain) => {
      const chainId = Number(chain.chain_id);
      const chainInfo = chainInfos == null ? void 0 : chainInfos.find(
        (item2) => item2.chain_id == chainId
      );
      const _chain = {
        network_infos: {
          name: chain.chain_name ?? (chainInfo == null ? void 0 : chainInfo.name) ?? "--",
          chain_id: chainId,
          withdrawal_fee: chain.withdrawal_fee,
          cross_chain_withdrawal_fee: chain.cross_chain_withdrawal_fee,
          bridgeless: true
        },
        token_infos: [
          {
            symbol: item.token,
            address: chain.contract_address,
            decimals: chain.decimals,
            display_name: chain.display_name
          }
        ]
      };
      if (typeof filter === "function") {
        if (!filter(_chain))
          return;
      }
      _chains.push(_chain);
    });
  });
  return _chains;
}
function filterAndUpdateChains(chains, chainInfos, filter, isTestNet) {
  const filterChains = [];
  chains.forEach((chain) => {
    const _chain = { ...chain };
    const networkInfo = chainInfos == null ? void 0 : chainInfos.find(
      (item) => item.chain_id == chain.network_infos.chain_id
    );
    if (networkInfo) {
      const { name, public_rpc_url, currency_symbol, explorer_base_url } = networkInfo;
      _chain.network_infos = {
        ..._chain.network_infos,
        name,
        shortName: name,
        public_rpc_url,
        currency_symbol,
        bridge_enable: true,
        mainnet: !isTestNet,
        explorer_base_url
        // est_txn_mins: null,
      };
    }
    if (typeof filter === "function") {
      if (!filter(_chain))
        return;
    }
    if (networkInfo) {
      filterChains.push(_chain);
    }
  });
  return filterChains;
}
function filterByAllowedChains(chains, allowedChains) {
  if (!allowedChains) {
    return chains;
  }
  return chains.filter(
    (chain) => allowedChains.some(
      (allowedChain) => {
        var _a3;
        return allowedChain.id === parseInt((_a3 = chain == null ? void 0 : chain.network_infos) == null ? void 0 : _a3.chain_id);
      }
    )
  );
}
function useStorageChain() {
  const [chain, setChain] = useLocalStorage(ChainKey, null);
  const setStorageChain = (chainId) => {
    let namespace = ChainNamespace.evm;
    if (SolanaChains$1.has(chainId)) {
      namespace = ChainNamespace.solana;
    }
    setChain({
      chainId,
      namespace
    });
  };
  return {
    storageChain: chain,
    setStorageChain
  };
}
var useHoldingStream = () => {
  const ws2 = useWS();
  const { data, isLoading, mutate: mutate3 } = usePrivateQuery(
    "/v1/client/holding",
    {
      formatter: (data2) => {
        return data2.holding;
      }
    }
  );
  const usdc = useMemo(() => {
    const usdc2 = data == null ? void 0 : data.find((item) => item.token === "USDC");
    return usdc2;
  }, [data]);
  useSWRSubscription("holding", (_2, { next }) => {
    const unsubscribe = ws2.privateSubscribe(
      {
        id: "balance",
        event: "subscribe",
        topic: "balance",
        ts: T$1()
      },
      {
        onMessage: (data2) => {
          const holding = (data2 == null ? void 0 : data2.balances) ?? {};
          if (holding) {
            mutate3((prevData) => {
              return prevData == null ? void 0 : prevData.map((item) => {
                const token = holding[item.token];
                return {
                  ...item,
                  frozen: token.frozen,
                  holding: token.holding
                };
              });
            });
            next(holding);
          }
        }
      }
    );
    return () => unsubscribe();
  });
  return {
    data,
    usdc,
    isLoading
  };
};
var useWithdraw = (options) => {
  const { account: account5, state } = useAccount();
  const [isLoading, setIsLoading] = useState(false);
  const { unsettledPnL, availableBalance: availableBalance2, freeCollateral: freeCollateral2 } = useCollateral();
  const networkId = useConfig("networkId");
  const [_2, { findByChainId }] = useChains(void 0);
  useEventEmitter();
  const { track: track2 } = useTrack();
  useHoldingStream();
  const maxAmount = useMemo(() => {
    return freeCollateral2;
  }, [freeCollateral2]);
  const availableWithdraw = useMemo(() => {
    if (unsettledPnL < 0) {
      return freeCollateral2;
    } else {
      return freeCollateral2 - unsettledPnL;
    }
  }, [freeCollateral2, unsettledPnL]);
  const targetChain = useMemo(() => {
    var _a3;
    let chain;
    if (networkId === "testnet") {
      chain = findByChainId(
        L$5(options == null ? void 0 : options.srcChainId) ? options == null ? void 0 : options.srcChainId : ARBITRUM_TESTNET_CHAINID
      );
    } else {
      chain = findByChainId(options == null ? void 0 : options.srcChainId);
      if (!((_a3 = chain == null ? void 0 : chain.network_infos) == null ? void 0 : _a3.bridgeless)) {
        chain = findByChainId(ARBITRUM_MAINNET_CHAINID);
      }
    }
    return chain;
  }, [networkId, findByChainId, options == null ? void 0 : options.srcChainId]);
  const dst = useMemo(() => {
    var _a3, _b2;
    const USDC = targetChain == null ? void 0 : targetChain.token_infos.find(
      (token) => token.symbol === "USDC"
    );
    return {
      symbol: (USDC == null ? void 0 : USDC.display_name) || "USDC",
      decimals: (USDC == null ? void 0 : USDC.decimals) || 6,
      address: USDC == null ? void 0 : USDC.address,
      chainId: (_a3 = targetChain == null ? void 0 : targetChain.network_infos) == null ? void 0 : _a3.chain_id,
      network: (_b2 = targetChain == null ? void 0 : targetChain.network_infos) == null ? void 0 : _b2.shortName
    };
  }, [targetChain]);
  const withdraw = useCallback(
    (inputs) => {
      return account5.assetsManager.withdraw(inputs).then((res) => {
        var _a3;
        if (res.success) {
          track2(TrackerEventName.withdrawSuccess, {
            wallet: (_a3 = state == null ? void 0 : state.connectWallet) == null ? void 0 : _a3.name,
            network: targetChain == null ? void 0 : targetChain.network_infos.name,
            quantity: inputs.amount
          });
        }
        return res;
      }).catch((err) => {
        var _a3;
        track2(TrackerEventName.withdrawFailed, {
          wallet: (_a3 = state == null ? void 0 : state.connectWallet) == null ? void 0 : _a3.name,
          network: targetChain == null ? void 0 : targetChain.network_infos.name,
          msg: JSON.stringify(err)
        });
        throw err;
      });
    },
    [state, targetChain, state]
  );
  return {
    dst,
    withdraw,
    isLoading,
    maxAmount,
    availableBalance: availableBalance2,
    availableWithdraw,
    unsettledPnL
  };
};
var useDeposit = (options) => {
  const networkId = useConfig("networkId");
  const [balanceRevalidating, setBalanceRevalidating] = useState(false);
  const [allowanceRevalidating, setAllowanceRevalidating] = useState(false);
  useEventEmitter();
  const [_2, { findByChainId }] = useChains(void 0);
  const [quantity, setQuantity] = useState("");
  const [depositFee, setDepositFee] = useState(0n);
  const [depositFeeRevalidating, setDepositFeeRevalidating] = useState(false);
  const [balance, setBalance] = useState("0");
  const [allowance, setAllowance] = useState("0");
  const { account: account5, state } = useAccount();
  const { track: track2 } = useTrack();
  const prevAddress = useRef();
  const getBalanceListener = useRef();
  const targetChain = useMemo(() => {
    var _a3;
    let chain;
    if (networkId === "testnet") {
      chain = findByChainId(
        L$5(options == null ? void 0 : options.srcChainId) ? options == null ? void 0 : options.srcChainId : ARBITRUM_TESTNET_CHAINID
      );
    } else {
      chain = findByChainId(options == null ? void 0 : options.srcChainId);
      if (!((_a3 = chain == null ? void 0 : chain.network_infos) == null ? void 0 : _a3.bridgeless)) {
        chain = findByChainId(ARBITRUM_MAINNET_CHAINID);
      }
    }
    return chain;
  }, [networkId, findByChainId, options == null ? void 0 : options.srcChainId]);
  const dst = useMemo(() => {
    var _a3, _b2;
    const USDC = targetChain == null ? void 0 : targetChain.token_infos.find(
      (token) => token.symbol === "USDC"
    );
    return {
      symbol: "USDC",
      address: USDC == null ? void 0 : USDC.address,
      decimals: USDC == null ? void 0 : USDC.decimals,
      chainId: (_a3 = targetChain == null ? void 0 : targetChain.network_infos) == null ? void 0 : _a3.chain_id,
      network: (_b2 = targetChain == null ? void 0 : targetChain.network_infos) == null ? void 0 : _b2.shortName
    };
  }, [targetChain]);
  const isNativeToken = useMemo(
    () => isNativeTokenChecker((options == null ? void 0 : options.address) || ""),
    [options == null ? void 0 : options.address]
  );
  const fetchBalanceHandler = useCallback(
    async (address, decimals) => {
      let balance2;
      if (!!address && isNativeTokenChecker(address)) {
        balance2 = await account5.assetsManager.getNativeBalance({
          decimals
        });
      } else {
        balance2 = await account5.assetsManager.getBalance(address, { decimals });
      }
      return balance2;
    },
    []
  );
  const fetchBalance = useCallback(
    async (address, decimals) => {
      if (!address)
        return;
      try {
        const balance2 = await fetchBalanceHandler(address, decimals);
        setBalance(() => balance2);
      } catch (e2) {
        setBalance(() => "0");
      }
    },
    [state]
  );
  const fetchBalances = useCallback(async (tokens) => {
    const tasks = [];
    for (const token of tokens) {
      if (isNativeTokenChecker(token.address)) {
        continue;
      }
      tasks.push(
        account5.assetsManager.getBalanceByAddress(token.address, {
          decimals: token == null ? void 0 : token.decimals
        })
      );
    }
    await Promise.all(tasks);
  }, []);
  const getAllowance = async (inputs) => {
    const { address, vaultAddress, decimals } = inputs;
    const key = `${address}-${vaultAddress}`;
    if (prevAddress.current === key)
      return;
    if (!address || !vaultAddress)
      return;
    if (address && isNativeTokenChecker(address))
      return;
    prevAddress.current = key;
    const allowance2 = await account5.assetsManager.getAllowance({
      address,
      vaultAddress,
      decimals
    });
    setAllowance(() => allowance2);
    return allowance2;
  };
  const getAllowanceByDefaultAddress = async (inputs) => {
    const { address, decimals } = inputs;
    if (prevAddress.current === address)
      return;
    if (!address || isNativeTokenChecker(address))
      return;
    prevAddress.current = address;
    const allowance2 = await account5.assetsManager.getAllowance({
      address,
      decimals
    });
    setAllowance(() => allowance2);
  };
  const queryBalance = useDebouncedCallback(
    (address, decimals) => {
      fetchBalance(address, decimals).finally(() => {
        setBalanceRevalidating(false);
      });
    },
    100
  );
  const queryAllowance = useDebouncedCallback(
    (inputs) => {
      getAllowance(inputs);
    },
    100
  );
  useEffect(() => {
    var _a3;
    if (state.status < AccountStatusEnum.Connected)
      return;
    setBalanceRevalidating(true);
    queryBalance(options == null ? void 0 : options.address, options == null ? void 0 : options.decimals);
    const params = {
      address: options == null ? void 0 : options.address,
      decimals: options == null ? void 0 : options.decimals
    };
    if (((_a3 = account5.walletAdapter) == null ? void 0 : _a3.chainNamespace) === ChainNamespace.solana) {
      setAllowance(account5.walletAdapter.formatUnits(MaxUint256));
      return;
    }
    if (dst.chainId !== (options == null ? void 0 : options.srcChainId)) {
      queryAllowance(params);
    } else {
      if (dst.symbol !== (options == null ? void 0 : options.srcToken)) {
        queryAllowance(params);
      } else {
        getAllowanceByDefaultAddress(params);
      }
    }
  }, [
    state.status,
    options == null ? void 0 : options.address,
    options == null ? void 0 : options.srcChainId,
    options == null ? void 0 : options.srcToken,
    options == null ? void 0 : options.decimals,
    account5.address,
    dst.chainId,
    dst.symbol
  ]);
  const updateAllowanceWhenTxSuccess = useCallback(
    (txHash) => {
      var _a3;
      return (_a3 = account5.walletAdapter) == null ? void 0 : _a3.pollTransactionReceiptWithBackoff(txHash).then((receipt) => {
        if (receipt.status === 1) {
          account5.assetsManager.getAllowance({ address: options == null ? void 0 : options.address }).then((allowance2) => {
            setAllowance(() => allowance2);
          });
        }
      });
    },
    [account5, options == null ? void 0 : options.address]
  );
  const approve = useCallback(
    async (amount) => {
      if (!(options == null ? void 0 : options.address)) {
        throw new SDKError("Address is required");
      }
      return account5.assetsManager.approve({
        address: options.address,
        amount
      }).then((res) => {
        return updateAllowanceWhenTxSuccess(res.hash);
      }).catch((e2) => {
        throw e2;
      });
    },
    [account5, getAllowance, options == null ? void 0 : options.address, dst]
  );
  const deposit = useCallback(async () => {
    if (!(options == null ? void 0 : options.address)) {
      throw new SDKError("Address is required");
    }
    const _allowance = await account5.assetsManager.getAllowance({
      address: options == null ? void 0 : options.address
    });
    setAllowance(() => _allowance);
    if (new g$6(quantity).greaterThan(_allowance)) {
      throw new SDKError("Insufficient allowance");
    }
    return account5.assetsManager.deposit(quantity, depositFee).then((res) => {
      var _a3;
      track2(TrackerEventName.depositSuccess, {
        wallet: (_a3 = state == null ? void 0 : state.connectWallet) == null ? void 0 : _a3.name,
        network: targetChain == null ? void 0 : targetChain.network_infos.name,
        quantity
      });
      updateAllowanceWhenTxSuccess(res.hash);
      setBalance((value) => new g$6(value).sub(quantity).toString());
      return res;
    }).catch((e2) => {
      var _a3, _b2;
      track2(TrackerEventName.depositFailed, {
        wallet: (_a3 = state == null ? void 0 : state.connectWallet) == null ? void 0 : _a3.name,
        network: (_b2 = targetChain == null ? void 0 : targetChain.network_infos) == null ? void 0 : _b2.name,
        msg: JSON.stringify(e2)
      });
      throw e2;
    });
  }, [account5, fetchBalance, quantity, depositFee, options == null ? void 0 : options.address]);
  const loopGetBalance = async () => {
    var _a3;
    getBalanceListener.current && clearTimeout(getBalanceListener.current);
    const time = ((_a3 = account5.walletAdapter) == null ? void 0 : _a3.chainNamespace) === ChainNamespace.solana ? 1e4 : 3e3;
    getBalanceListener.current = setTimeout(async () => {
      try {
        const balance2 = await fetchBalanceHandler(
          options == null ? void 0 : options.address,
          options == null ? void 0 : options.decimals
        );
        setBalance(balance2);
        loopGetBalance();
      } catch (err) {
      }
    }, time);
  };
  const getDepositFee = useCallback(
    async (quantity2) => {
      return account5.assetsManager.getDepositFee(
        quantity2,
        targetChain == null ? void 0 : targetChain.network_infos
      );
    },
    [account5, targetChain]
  );
  const enquiryDepositFee = useCallback(() => {
    if (isNaN(Number(quantity)) || !quantity || Number(quantity) === 0) {
      setDepositFee(0n);
      setDepositFeeRevalidating(false);
      return;
    }
    setDepositFeeRevalidating(true);
    getDepositFee(quantity).then((res = 0n) => {
      const fee = BigInt(
        new g$6(res.toString()).mul(DEPOSIT_FEE_RATE).toFixed(0, g$6.ROUND_UP).toString()
      );
      setDepositFee(fee);
    }).catch((error) => {
    }).finally(() => {
      setDepositFeeRevalidating(false);
    });
  }, [quantity]);
  useEffect(() => {
    enquiryDepositFee();
  }, [quantity]);
  useEffect(() => {
    if (!(options == null ? void 0 : options.address)) {
      return;
    }
    loopGetBalance();
    return () => {
      getBalanceListener.current && clearTimeout(getBalanceListener.current);
    };
  }, [options == null ? void 0 : options.address, options == null ? void 0 : options.decimals]);
  return {
    /** orderly support chain dst */
    dst,
    balance,
    allowance,
    isNativeToken,
    balanceRevalidating,
    allowanceRevalidating,
    /** input quantiy */
    quantity,
    /** orderly deposit fee, unit: wei */
    depositFee,
    /** enquiring depositFee status on chain */
    depositFeeRevalidating,
    approve,
    deposit,
    fetchBalances,
    fetchBalance: fetchBalanceHandler,
    /** set input quantity */
    setQuantity
  };
};
var useWalletSubscription = (options) => {
  const ws2 = useWS();
  return useSWRSubscription("wallet", (_2, { next }) => {
    const unsubscribe = ws2.privateSubscribe(
      {
        id: "wallet",
        event: "subscribe",
        topic: "wallet",
        ts: Date.now()
      },
      {
        onMessage: (data) => {
          var _a3;
          (_a3 = options == null ? void 0 : options.onMessage) == null ? void 0 : _a3.call(options, data);
          next(null, data);
        }
      }
    );
    return () => unsubscribe();
  });
};
var useSettleSubscription = (options) => {
  const ws2 = useWS();
  return useSWRSubscription("settle", (_2, { next }) => {
    const unsubscribe = ws2.privateSubscribe(
      {
        id: "settle",
        event: "subscribe",
        topic: "settle",
        ts: T$1()
      },
      {
        onMessage: (data) => {
          var _a3;
          (_a3 = options == null ? void 0 : options.onMessage) == null ? void 0 : _a3.call(options, data);
          next(data);
        }
      }
    );
    return () => unsubscribe();
  });
};
var useSymbolPriceRange = (symbol, side, price) => {
  const config2 = useSymbolsInfo();
  const priceRange = config2 == null ? void 0 : config2[symbol]("price_range");
  const priceScrope = config2 == null ? void 0 : config2[symbol]("price_scope");
  const { data: prices } = useMarkPricesStream();
  const markPrice = price || (prices == null ? void 0 : prices[symbol]);
  const range = useMemo(() => {
    if (config2 === void 0 || markPrice === void 0) {
      return void 0;
    }
    if (priceRange === void 0 || Number.isNaN(markPrice)) {
      return void 0;
    }
    if (side === "BUY") {
      return {
        max: new g$6(markPrice).mul(1 + priceRange).toNumber(),
        min: new g$6(markPrice).mul(1 - priceScrope).toNumber()
      };
    }
    return {
      max: new g$6(markPrice).mul(1 + priceScrope).toNumber(),
      min: new g$6(markPrice).mul(1 - priceRange).toNumber()
    };
  }, [symbol, side, priceRange, markPrice]);
  return range;
};
function offsetToPrice(inputs) {
  const { offset, entryPrice, orderType, orderSide } = inputs;
  if (!offset)
    return;
  if (orderSide === OrderSide.BUY) {
    if (orderType === AlgoOrderType.TAKE_PROFIT) {
      return new g$6(entryPrice).add(new g$6(offset)).toNumber();
    }
    return new g$6(entryPrice).minus(new g$6(offset)).toNumber();
  }
  if (orderSide === OrderSide.SELL) {
    if (orderType === AlgoOrderType.TAKE_PROFIT) {
      return new g$6(entryPrice).minus(new g$6(offset)).toNumber();
    }
    return new g$6(entryPrice).add(new g$6(offset)).toNumber();
  }
}
function priceToOffset(inputs, options = {}) {
  const { price, entryPrice, orderType, orderSide } = inputs;
  const { symbol } = options;
  let decimal;
  if (orderSide === OrderSide.BUY) {
    if (orderType === AlgoOrderType.TAKE_PROFIT) {
      decimal = new g$6(price).minus(new g$6(entryPrice));
    }
    decimal = new g$6(price).minus(new g$6(entryPrice));
  }
  if (orderSide === OrderSide.SELL) {
    if (orderType === AlgoOrderType.TAKE_PROFIT) {
      decimal = new g$6(price).minus(new g$6(entryPrice));
    }
    decimal = new g$6(entryPrice).minus(new g$6(price));
  }
  if (symbol) {
    return decimal.abs().todp(symbol.quote_dp, g$6.ROUND_UP).toNumber();
  }
  return decimal.abs().toNumber();
}
function offsetPercentageToPrice(inputs) {
  const { percentage, entryPrice, orderType, orderSide } = inputs;
  if (!percentage)
    return;
  if (orderSide === OrderSide.BUY) {
    if (orderType === AlgoOrderType.TAKE_PROFIT) {
      return new g$6(1).add(new g$6(percentage)).mul(new g$6(entryPrice)).toNumber();
    }
    return new g$6(1).minus(new g$6(percentage)).mul(new g$6(entryPrice)).toNumber();
  }
  if (orderSide === OrderSide.SELL) {
    if (orderType === AlgoOrderType.TAKE_PROFIT) {
      return new g$6(1).minus(new g$6(percentage)).mul(new g$6(entryPrice)).toNumber();
    }
    return new g$6(1).add(new g$6(percentage)).mul(new g$6(entryPrice)).toNumber();
  }
}
function priceToOffsetPercentage(inputs) {
  const { price, entryPrice, orderType, orderSide } = inputs;
  if (orderSide === OrderSide.BUY) {
    if (entryPrice === 0)
      return 0;
    if (orderType === AlgoOrderType.TAKE_PROFIT) {
      return new g$6(price).div(new g$6(entryPrice)).minus(1).toDecimalPlaces(4, g$6.ROUND_DOWN).toNumber();
    }
    return new g$6(1).minus(new g$6(price).div(new g$6(entryPrice))).toDecimalPlaces(4, g$6.ROUND_DOWN).toNumber();
  }
  if (orderSide === OrderSide.SELL) {
    if (entryPrice === 0)
      return 0;
    if (orderType === AlgoOrderType.TAKE_PROFIT) {
      return new g$6(1).minus(new g$6(price).div(new g$6(entryPrice))).abs().toDecimalPlaces(4, g$6.ROUND_DOWN).toNumber();
    }
    return new g$6(price).div(new g$6(entryPrice)).minus(1).toDecimalPlaces(4, g$6.ROUND_DOWN).toNumber();
  }
}
function pnlToPrice(inputs) {
  const { qty, pnl, entryPrice, orderType, orderSide } = inputs;
  if (!pnl) {
    return;
  }
  if (qty === 0)
    return;
  if (orderSide === OrderSide.BUY) {
    if (orderType === AlgoOrderType.TAKE_PROFIT) {
      return new g$6(entryPrice).plus(new g$6(pnl).div(new g$6(qty))).toNumber();
    }
    return new g$6(entryPrice).add(new g$6(pnl).div(new g$6(qty))).toNumber();
  }
  if (orderSide === OrderSide.SELL) {
    if (orderType === AlgoOrderType.TAKE_PROFIT) {
      return new g$6(entryPrice).add(new g$6(pnl).div(new g$6(qty))).toNumber();
    }
    return new g$6(entryPrice).add(new g$6(pnl).div(new g$6(qty))).toNumber();
  }
}
function priceToPnl(inputs, options = {}) {
  const { qty, price, entryPrice, orderType, orderSide } = inputs;
  const { symbol } = options;
  let decimal = $$4;
  if (orderSide === OrderSide.BUY) {
    if (orderType === AlgoOrderType.TAKE_PROFIT) {
      decimal = new g$6(qty).mul(
        new g$6(price).minus(new g$6(entryPrice))
      );
    }
    decimal = new g$6(qty).mul(
      new g$6(price).minus(new g$6(entryPrice))
    );
  }
  if (orderSide === OrderSide.SELL) {
    if (orderType === AlgoOrderType.TAKE_PROFIT) {
      decimal = new g$6(qty).mul(
        new g$6(price).minus(new g$6(entryPrice))
      );
    }
    decimal = new g$6(qty).mul(
      new g$6(price).minus(new g$6(entryPrice))
    );
  }
  if (symbol) {
    return decimal.todp(2, g$6.ROUND_DOWN).toNumber();
  }
  return decimal.toNumber();
}
function calcTPSL_ROI(inputs) {
  const qtyNum = Number(inputs.qty);
  const priceNum = Number(inputs.price);
  if (qtyNum === 0 || priceNum === 0)
    return "0";
  return new g$6(inputs.pnl).div(new g$6(qtyNum).abs().mul(new g$6(priceNum))).toString();
}
function tpslCalculateHelper(key, inputs, options = {}) {
  var _a3;
  const { symbol } = options;
  if (key !== "quantity" && key !== "tp_trigger_price" && key !== "sl_trigger_price" && key !== "tp_pnl" && key !== "sl_pnl" && key !== "tp_offset" && key !== "sl_offset" && key !== "tp_offset_percentage" && key !== "sl_offset_percentage") {
    return {
      [key]: inputs.value
    };
  }
  const orderType = key.startsWith("tp_") ? AlgoOrderType.TAKE_PROFIT : AlgoOrderType.STOP_LOSS;
  const keyPrefix = key.slice(0, 3);
  let qty = Number(key === "quantity" ? inputs.value : inputs.qty);
  if (qty === 0 && (key === "tp_pnl" || key === "sl_pnl" || key === "tp_trigger_price" || key === "sl_trigger_price")) {
    return {
      [`${keyPrefix}trigger_price`]: "",
      // [`${keyPrefix}offset`]: "",
      // [`${keyPrefix}offset_percentage`]: "",
      [`${keyPrefix}pnl`]: "",
      [key]: inputs.value
    };
  }
  let trigger_price, offset, offset_percentage, pnl;
  const entryPrice = new g$6(inputs.entryPrice).todp(((_a3 = options.symbol) == null ? void 0 : _a3.quote_dp) ?? 2, g$6.ROUND_UP).toNumber();
  switch (key) {
    case "tp_trigger_price":
    case "sl_trigger_price": {
      trigger_price = inputs.value;
      if (inputs.value === "") {
        return {
          [`${keyPrefix}trigger_price`]: trigger_price,
          [`${keyPrefix}offset`]: "",
          [`${keyPrefix}offset_percentage`]: "",
          [`${keyPrefix}pnl`]: "",
          [`${keyPrefix}ROI`]: ""
        };
      }
      break;
    }
    case "tp_pnl":
    case "sl_pnl": {
      pnl = inputs.value;
      trigger_price = pnlToPrice({
        qty,
        pnl: Number(inputs.value),
        entryPrice,
        orderSide: inputs.orderSide,
        orderType
      });
      break;
    }
    case "tp_offset":
    case "sl_offset": {
      offset = inputs.value;
      trigger_price = offsetToPrice({
        offset: Number(inputs.value),
        entryPrice,
        orderSide: inputs.orderSide,
        orderType: key === "tp_offset" ? AlgoOrderType.TAKE_PROFIT : AlgoOrderType.STOP_LOSS
      });
      break;
    }
    case "tp_offset_percentage":
    case "sl_offset_percentage": {
      offset_percentage = inputs.value;
      trigger_price = offsetPercentageToPrice({
        percentage: Number(`${inputs.value}`.replace(/\.0{0,2}$/, "")),
        entryPrice,
        orderSide: inputs.orderSide,
        orderType
      });
      break;
    }
  }
  if (!trigger_price)
    return {
      [`${keyPrefix}trigger_price`]: "",
      [`${keyPrefix}offset`]: "",
      [`${keyPrefix}offset_percentage`]: "",
      [`${keyPrefix}pnl`]: "",
      [`${keyPrefix}ROI`]: "",
      [key]: inputs.value
    };
  return {
    [`${keyPrefix}trigger_price`]: O$7(
      trigger_price,
      (symbol == null ? void 0 : symbol.quote_dp) ?? 2
    ),
    [`${keyPrefix}offset`]: offset ?? priceToOffset(
      {
        price: Number(trigger_price),
        entryPrice,
        orderSide: inputs.orderSide,
        orderType
      },
      options
    ),
    [`${keyPrefix}offset_percentage`]: offset_percentage ?? priceToOffsetPercentage({
      price: Number(trigger_price),
      entryPrice,
      orderSide: inputs.orderSide,
      orderType
    }),
    [`${keyPrefix}pnl`]: pnl ?? priceToPnl(
      {
        qty,
        price: Number(trigger_price),
        entryPrice,
        orderSide: inputs.orderSide,
        orderType
      },
      options
    )
    // [`${keyPrefix}ROI`]: calcROI({
    //   pnl: Number(pnl ?? 0),
    //   qty,
    //   price: Number(trigger_price!),
    // }),
  };
}
function getMinNotional(props) {
  const { price, base_tick, qty, min_notional, base_dp, quote_dp, quote_tick } = props;
  if (price !== void 0 && qty !== void 0 && min_notional !== void 0) {
    try {
      const calcNotional = new g$6(price).mul(new g$6(qty)).toNumber();
      const notional2 = Number.parseFloat(`${min_notional}`);
      if (calcNotional < notional2) {
        let minQty = new g$6(notional2).div(price).toDecimalPlaces(base_dp, g$6.ROUND_DOWN).add(base_tick ?? 0);
        if (base_tick && base_tick > 0) {
          minQty = new g$6(
            getRoundedDownDivision(minQty.toNumber(), base_tick)
          );
        }
        const newMinNotional = minQty.mul(price).add(quote_tick ?? 0).toFixed(quote_dp);
        return newMinNotional;
      }
    } catch (e2) {
    }
  }
}
function getRoundedDownDivision(value, tick) {
  const decimalValue = new g$6(value);
  const decimalTick = new g$6(tick);
  const quotient = decimalValue.dividedToIntegerBy(decimalTick);
  return quotient.mul(decimalTick).toNumber();
}
var OrderValidation = class {
  static getLabel(key) {
    switch (key) {
      case "quantity":
      case "order_quantity":
        return "Quantity";
      case "order_price":
        return "Price";
      case "trigger_price":
        return "Trigger price";
      case "tp_trigger_price":
        return "TP price";
      case "sl_trigger_price":
        return "SL price";
      default:
        return key;
    }
  }
  static required(key) {
    return {
      type: "required",
      message: `${this.getLabel(key)} is required`
    };
  }
  static min(key, value) {
    return {
      type: "min",
      message: `${this.getLabel(key)} must be greater than ${value}`,
      value
    };
  }
  static max(key, value) {
    return {
      type: "max",
      message: `${this.getLabel(key)} must be less than ${value}`,
      value
    };
  }
};
var BaseOrderCreator = class {
  baseOrder(data) {
    const order = {
      symbol: data.symbol,
      order_type: data.order_type === OrderType.LIMIT ? !!data.order_type_ext ? data.order_type_ext : data.order_type : data.order_type,
      side: data.side,
      reduce_only: data.reduce_only,
      order_quantity: data.order_quantity,
      total: data.total
    };
    if (data.visible_quantity === 0) {
      order.visible_quantity = data.visible_quantity;
    }
    const bracketOrder = this.parseBracketOrder(data);
    if (!bracketOrder) {
      return order;
    }
    return {
      ...order,
      algo_type: AlgoOrderRootType.BRACKET,
      child_orders: [bracketOrder]
    };
  }
  baseValidate(values2, configs) {
    const errors = {};
    const { maxQty: maxQty2, symbol, markPrice } = configs;
    let { order_quantity, total, order_price, reduce_only, order_type } = values2;
    const { min_notional, base_tick, quote_dp, quote_tick, base_dp } = symbol || {};
    if (!order_quantity) {
      if (total && order_price) {
        const { quote_dp: quote_dp2 } = configs.symbol;
        const totalNumber = new g$6(total);
        const qty = totalNumber.dividedBy(order_price).toFixed(quote_dp2);
        order_quantity = qty;
      }
    }
    if (!order_quantity) {
      errors.order_quantity = OrderValidation.required("order_quantity");
    } else {
      const { base_min, quote_dp: quote_dp2, base_dp: base_dp2 } = configs.symbol;
      const qty = new g$6(order_quantity);
      if (qty.lt(base_min)) {
        errors.order_quantity = OrderValidation.min(
          "order_quantity",
          new g$6(base_min).todp(base_dp2).toString()
        );
      } else if (qty.gt(maxQty2)) {
        errors.order_quantity = OrderValidation.max(
          "order_quantity",
          new g$6(maxQty2).todp(base_dp2).toString()
        );
      }
    }
    const price = `${order_type}`.includes("MARKET") ? markPrice : order_price;
    const minNotional = getMinNotional({
      base_tick,
      quote_tick,
      price,
      qty: order_quantity,
      min_notional,
      quote_dp,
      base_dp
    });
    if (minNotional !== void 0 && !reduce_only) {
      errors.total = {
        type: "min",
        message: `The order value should be greater or equal to ${minNotional} USDC`,
        value: minNotional
      };
    }
    this.validateBracketOrder(values2, configs, errors);
    return Promise.resolve(errors);
  }
  totalToQuantity(order, config2) {
    if (!order.order_quantity && order.total && order.order_price) {
      const { base_dp } = config2.symbol;
      const totalNumber = new g$6(order.total);
      const qty = totalNumber.div(order.order_price).toDecimalPlaces(base_dp);
      order.order_quantity = qty.toNumber();
      delete order.total;
    }
    return order;
  }
  get type() {
    return this.orderType;
  }
  parseBracketOrder(data) {
    const orders = [];
    const side = data.side === OrderSide.BUY ? OrderSide.SELL : OrderSide.BUY;
    if (!!data.tp_trigger_price) {
      const tp_trigger_price = data.tp_trigger_price;
      orders.push({
        algo_type: AlgoOrderType.TAKE_PROFIT,
        side,
        type: OrderType.CLOSE_POSITION,
        trigger_price: tp_trigger_price,
        symbol: data.symbol,
        reduce_only: true
      });
    }
    if (!!data.sl_trigger_price) {
      const sl_trigger_price = data.sl_trigger_price;
      orders.push({
        algo_type: AlgoOrderType.STOP_LOSS,
        side,
        type: OrderType.CLOSE_POSITION,
        trigger_price: sl_trigger_price,
        symbol: data.symbol,
        reduce_only: true
      });
    }
    if (!orders.length)
      return null;
    return {
      symbol: data.symbol,
      algo_type: AlgoOrderRootType.POSITIONAL_TP_SL,
      child_orders: orders
    };
  }
  validateBracketOrder(values2, config2, errors) {
    const { tp_trigger_price, sl_trigger_price, side, order_price } = values2;
    const { markPrice } = config2;
    if (!tp_trigger_price && !sl_trigger_price)
      return errors;
    const hasTPPrice = !!tp_trigger_price;
    const hasSLPrice = !!sl_trigger_price;
    const { symbol } = config2;
    const { price_range, price_scope, quote_max, quote_min, quote_dp } = symbol;
    const _orderPrice = order_price || markPrice;
    if (hasTPPrice) {
      const tpPrice = new g$6(tp_trigger_price);
      if (tpPrice.gt(quote_max)) {
        errors.tp_trigger_price = OrderValidation.max(
          "tp_trigger_price",
          quote_max
        );
      }
      if (tpPrice.lt(quote_min)) {
        errors.tp_trigger_price = OrderValidation.min(
          "tp_trigger_price",
          quote_min
        );
      }
      if (side === OrderSide.BUY) {
        if (tpPrice.lte(_orderPrice)) {
          errors.tp_trigger_price = OrderValidation.min(
            "tp_trigger_price",
            _orderPrice
          );
        }
      }
      if (side === OrderSide.SELL) {
        if (tpPrice.gte(_orderPrice)) {
          errors.tp_trigger_price = OrderValidation.max(
            "tp_trigger_price",
            _orderPrice
          );
        }
      }
    }
    if (hasSLPrice) {
      const slPrice = new g$6(sl_trigger_price);
      if (slPrice.gt(quote_max)) {
        errors.sl_trigger_price = OrderValidation.max(
          "sl_trigger_price",
          quote_max
        );
      }
      if (slPrice.lt(quote_min)) {
        errors.sl_trigger_price = OrderValidation.min(
          "sl_trigger_price",
          quote_min
        );
      }
      if (side === OrderSide.BUY) {
        if (slPrice.gte(_orderPrice)) {
          errors.sl_trigger_price = OrderValidation.max(
            "sl_trigger_price",
            _orderPrice
          );
        }
      }
      if (side === OrderSide.SELL) {
        if (slPrice.lte(_orderPrice)) {
          errors.sl_trigger_price = OrderValidation.min(
            "sl_trigger_price",
            _orderPrice
          );
        }
      }
    }
    return errors;
  }
};
var MarketOrderCreator = class extends BaseOrderCreator {
  create(values2) {
    const data = this.baseOrder(values2);
    delete data["order_price"];
    delete data["total"];
    delete data["trigger_price"];
    delete data["isStopOrder"];
    return {
      ...data
    };
  }
  validate(values2, configs) {
    return this.baseValidate(values2, configs);
  }
};
var { maxPrice, minPrice, scopePrice } = order_exports;
var LimitOrderCreator = class extends BaseOrderCreator {
  constructor() {
    super(...arguments);
    this.orderType = OrderType.LIMIT;
  }
  create(values2, config2) {
    const order = {
      ...this.baseOrder(values2),
      order_price: values2.order_price
    };
    this.totalToQuantity(order, config2);
    return pick(
      [
        "symbol",
        "order_price",
        "order_quantity",
        "visible_quantity",
        "reduce_only",
        "side",
        "order_type",
        "algo_type",
        "child_orders"
      ],
      order
    );
  }
  validate(values2, config2) {
    return this.baseValidate(values2, config2).then((errors) => {
      const { order_price, side } = values2;
      if (!order_price) {
        errors.order_price = OrderValidation.required("order_price");
      } else {
        const price = new g$6(order_price);
        const { symbol } = config2;
        const { price_range, price_scope, quote_max, quote_min } = symbol;
        const maxPriceNumber = maxPrice(config2.markPrice, price_range);
        const minPriceNumber = minPrice(config2.markPrice, price_range);
        const scopePriceNumber = scopePrice(
          config2.markPrice,
          price_scope,
          side
        );
        const priceRange = side === "BUY" ? {
          min: scopePriceNumber,
          max: maxPriceNumber
        } : {
          min: minPriceNumber,
          max: scopePriceNumber
        };
        if (price.gt(quote_max)) {
          errors.order_price = OrderValidation.max("order_price", quote_max);
        } else {
          if (price.gt(priceRange == null ? void 0 : priceRange.max)) {
            errors.order_price = OrderValidation.max(
              "order_price",
              new g$6(priceRange.max).todp(symbol.quote_dp).toString()
            );
          }
        }
        if (price.lt(quote_min)) {
          errors.order_price = OrderValidation.min("order_price", quote_min);
        } else {
          if (price.lt(priceRange == null ? void 0 : priceRange.min)) {
            errors.order_price = OrderValidation.min(
              "order_price",
              new g$6(priceRange.min).todp(symbol.quote_dp).toString()
            );
          }
        }
      }
      return errors;
    });
  }
};
var { maxPrice: maxPrice2, minPrice: minPrice2, scopePrice: scopePrice2 } = order_exports;
var StopLimitOrderCreator = class extends BaseOrderCreator {
  constructor() {
    super(...arguments);
    this.orderType = OrderType.STOP_LIMIT;
  }
  create(values2, config2) {
    this.totalToQuantity(values2, config2);
    const order = {
      ...this.baseOrder(values2),
      trigger_price: values2.trigger_price,
      algo_type: AlgoOrderRootType.STOP,
      type: OrderType.LIMIT,
      quantity: values2["order_quantity"],
      price: values2["order_price"],
      trigger_price_type: TriggerPriceType.MARK_PRICE
    };
    return pick(
      [
        "symbol",
        "trigger_price",
        "algo_type",
        "type",
        "quantity",
        "price",
        "trigger_price_type",
        "side",
        "reduce_only",
        "visible_quantity"
      ],
      order
    );
  }
  validate(values2, config2) {
    return this.baseValidate(values2, config2).then((errors) => {
      const { order_price, trigger_price, side } = values2;
      const { symbol } = config2;
      const { price_range, price_scope, quote_max, quote_min } = symbol;
      if (!trigger_price) {
        errors.trigger_price = OrderValidation.required("trigger_price");
      }
      if (!order_price) {
        errors.order_price = OrderValidation.required("order_price");
      }
      if (trigger_price > quote_max) {
        errors.trigger_price = OrderValidation.max("trigger_price", quote_max);
      } else if (trigger_price < quote_min) {
        errors.trigger_price = OrderValidation.min("trigger_price", quote_min);
      } else {
        if (trigger_price && order_price) {
          const price = new g$6(order_price);
          const maxPriceNumber = maxPrice2(trigger_price, price_range);
          const minPriceNumber = minPrice2(trigger_price, price_range);
          const scropePriceNumbere = scopePrice2(
            trigger_price,
            price_scope,
            side
          );
          const priceRange = side === "BUY" ? {
            min: scropePriceNumbere,
            max: maxPriceNumber
          } : {
            min: minPriceNumber,
            max: scropePriceNumbere
          };
          if (price.gt(quote_max)) {
            errors.order_price = OrderValidation.max("order_price", quote_max);
          } else {
            if (price.gt(priceRange == null ? void 0 : priceRange.max)) {
              errors.order_price = OrderValidation.max(
                "order_price",
                new g$6(priceRange.max).todp(symbol.quote_dp).toString()
              );
            }
          }
          if (price.lt(quote_min)) {
            errors.order_price = OrderValidation.min("order_price", quote_min);
          } else {
            if (price.lt(priceRange == null ? void 0 : priceRange.min)) {
              errors.order_price = OrderValidation.min(
                "order_price",
                new g$6(priceRange.min).todp(symbol.quote_dp).toString()
              );
            }
          }
        }
      }
      return errors;
    });
  }
};
var GeneralOrderCreator = class extends BaseOrderCreator {
  create(data) {
    return {
      ...this.baseOrder(data),
      order_price: data.order_price,
      order_quantity: data.order_quantity
    };
  }
  validate(values2, configs) {
    return super.baseValidate(values2, configs);
  }
};
var StopMarketOrderCreator = class extends BaseOrderCreator {
  create(values2) {
    const order = {
      ...this.baseOrder(values2),
      // order_price: values.order_price,
      trigger_price: values2.trigger_price,
      algo_type: AlgoOrderRootType.STOP,
      type: OrderType.MARKET,
      quantity: values2["order_quantity"],
      // price: values["order_price"],
      trigger_price_type: TriggerPriceType.MARK_PRICE
    };
    return pick(
      [
        "symbol",
        "trigger_price",
        "algo_type",
        "type",
        "quantity",
        // "price",
        "trigger_price_type",
        "side",
        "reduce_only",
        "visible_quantity"
      ],
      order
    );
  }
  validate(values2, config2) {
    return this.baseValidate(values2, config2).then((errors) => {
      const { order_price, trigger_price, side } = values2;
      const { symbol } = config2;
      const { quote_max, quote_min } = symbol;
      if (!trigger_price) {
        errors.trigger_price = OrderValidation.required("trigger_price");
      }
      if (trigger_price > quote_max) {
        errors.trigger_price = OrderValidation.max("trigger_price", quote_max);
      } else if (trigger_price < quote_min) {
        errors.trigger_price = OrderValidation.min("trigger_price", quote_min);
      }
      return errors;
    });
  }
};
var PostOnlyOrderCreator = class extends LimitOrderCreator {
};
var FOKOrderCreator = class extends LimitOrderCreator {
};
var IOCOrderCreator = class extends LimitOrderCreator {
};
var BaseAlgoOrderCreator = class {
  /**
   * base validate
   */
  validate(values2, config2) {
    const result = /* @__PURE__ */ Object.create(null);
    return Promise.resolve().then(() => {
      const { tp_trigger_price, sl_trigger_price, side } = values2;
      const qty = Number(values2.quantity);
      const maxQty2 = config2.maxQty;
      const orderType = values2.order_type;
      const {
        quote_max,
        quote_min,
        price_scope,
        quote_dp,
        base_min,
        min_notional
      } = config2.symbol ?? {};
      if (!isNaN(qty) && qty > maxQty2) {
        result.quantity = OrderValidation.max("quantity", config2.maxQty);
      }
      if (!isNaN(qty) && qty < base_min) {
        result.quantity = OrderValidation.min("quantity", base_min);
      }
      if (Number(tp_trigger_price) < 0) {
        result.tp_trigger_price = OrderValidation.min("tp_trigger_price", 0);
      }
      if (Number(sl_trigger_price) < 0) {
        result.sl_trigger_price = OrderValidation.min("sl_trigger_price", 0);
      }
      const mark_price = orderType === OrderType.MARKET || orderType == null ? config2.markPrice : values2.order_price ? Number(values2.order_price) : void 0;
      if (side === OrderSide.BUY && mark_price) {
        const slTriggerPriceScope = new g$6(mark_price * (1 - price_scope)).toDecimalPlaces(quote_dp, g$6.ROUND_DOWN).toNumber();
        if (!!sl_trigger_price && Number(sl_trigger_price) < slTriggerPriceScope) {
          result.sl_trigger_price = OrderValidation.min(
            "sl_trigger_price",
            slTriggerPriceScope
          );
        }
        if (!!sl_trigger_price && Number(sl_trigger_price) > config2.markPrice) {
          result.sl_trigger_price = OrderValidation.max(
            "sl_trigger_price",
            config2.markPrice
          );
        }
        if (!!tp_trigger_price && Number(tp_trigger_price) <= config2.markPrice) {
          result.tp_trigger_price = OrderValidation.min(
            "tp_trigger_price",
            config2.markPrice
          );
        }
        if (!!tp_trigger_price && Number(tp_trigger_price) > quote_max) {
          result.tp_trigger_price = OrderValidation.max(
            "tp_trigger_price",
            quote_max
          );
        }
        if (!!sl_trigger_price && Number(sl_trigger_price) < quote_min) {
          result.sl_trigger_price = OrderValidation.min(
            "sl_trigger_price",
            quote_min
          );
        }
      }
      if (side === OrderSide.SELL && mark_price) {
        const slTriggerPriceScope = new g$6(mark_price * (1 + price_scope)).toDecimalPlaces(quote_dp, g$6.ROUND_DOWN).toNumber();
        if (!!sl_trigger_price && Number(sl_trigger_price) > slTriggerPriceScope) {
          result.sl_trigger_price = OrderValidation.max(
            "sl_trigger_price",
            slTriggerPriceScope
          );
        }
        if (!!sl_trigger_price && Number(sl_trigger_price) < config2.markPrice) {
          result.sl_trigger_price = OrderValidation.min(
            "sl_trigger_price",
            config2.markPrice
          );
        }
        if (!!tp_trigger_price && Number(tp_trigger_price) >= config2.markPrice) {
          result.tp_trigger_price = OrderValidation.max(
            "tp_trigger_price",
            config2.markPrice
          );
        }
        if (!!tp_trigger_price && Number(tp_trigger_price) > quote_max) {
          result.tp_trigger_price = OrderValidation.max(
            "tp_trigger_price",
            quote_max
          );
        }
        if (!!sl_trigger_price && Number(sl_trigger_price) < quote_min) {
          result.sl_trigger_price = OrderValidation.min(
            "sl_trigger_price",
            quote_min
          );
        }
      }
      return Object.keys(result).length > 0 ? result : null;
    });
  }
};
var TPSLOrderCreator = class extends BaseAlgoOrderCreator {
  constructor() {
    super(...arguments);
    this.type = OrderType.MARKET;
  }
  create(values2, config2) {
    const side = values2.side === OrderSide.BUY ? OrderSide.SELL : OrderSide.BUY;
    const child_orders = [];
    if (typeof values2.tp_trigger_price !== "undefined") {
      const tp_trigger_price = !!values2.tp_trigger_price ? new g$6(values2.tp_trigger_price).todp(config2.symbol.quote_dp).toNumber() : values2.tp_trigger_price;
      child_orders.push({
        algo_type: AlgoOrderType.TAKE_PROFIT,
        reduce_only: true,
        side,
        type: OrderType.MARKET,
        trigger_price: tp_trigger_price,
        symbol: values2.symbol,
        is_activated: !!values2.tp_trigger_price
      });
    }
    if (typeof values2.sl_trigger_price !== "undefined") {
      const sl_trigger_price = !!values2.sl_trigger_price ? new g$6(values2.sl_trigger_price).todp(config2.symbol.quote_dp).toNumber() : values2.sl_trigger_price;
      child_orders.push({
        algo_type: AlgoOrderType.STOP_LOSS,
        reduce_only: true,
        side,
        type: OrderType.MARKET,
        trigger_price: sl_trigger_price,
        symbol: values2.symbol,
        is_activated: !!values2.sl_trigger_price
      });
    }
    return {
      algo_type: AlgoOrderRootType.TP_SL,
      trigger_price_type: TriggerPriceType.MARK_PRICE,
      reduce_only: true,
      quantity: values2.quantity,
      symbol: values2.symbol,
      child_orders
    };
  }
  crateUpdateOrder(values2, oldValue, config2) {
    const data = this.create(values2, config2);
    const newData = [];
    const needUpdateQty = values2.quantity !== oldValue.quantity;
    data.child_orders.forEach((order) => {
      var _a3;
      let _order = /* @__PURE__ */ Object.create(null);
      if (needUpdateQty) {
        _order["quantity"] = data.quantity;
      }
      const oldOrder = (_a3 = oldValue.child_orders) == null ? void 0 : _a3.find(
        (oldOrder2) => oldOrder2.algo_type === order.algo_type
      );
      if (oldOrder) {
        if (!order.is_activated) {
          _order["is_activated"] = false;
        } else if (oldOrder.trigger_price !== order.trigger_price) {
          _order["trigger_price"] = order.trigger_price;
        }
        if (Object.keys(_order).length > 0) {
          _order["order_id"] = Number(oldOrder.algo_order_id);
          newData.push(_order);
        }
      }
    });
    if (needUpdateQty && newData.length < 2) {
      const missingOrders = oldValue.child_orders.filter(
        (order) => order.algo_order_id !== newData[0].order_id
      );
      if (missingOrders.length) {
        newData.push({
          quantity: Number(data.quantity),
          order_id: missingOrders[0].algo_order_id
        });
      }
    }
    return [
      {
        child_orders: newData
      },
      data
    ];
  }
};
var TPSLPositionOrderCreator = class extends BaseAlgoOrderCreator {
  constructor() {
    super(...arguments);
    this.type = AlgoOrderRootType.POSITIONAL_TP_SL;
  }
  create(values2, config2) {
    const side = values2.side === OrderSide.BUY ? OrderSide.SELL : OrderSide.BUY;
    const child_orders = [];
    if (typeof values2.tp_trigger_price !== "undefined") {
      const tp_trigger_price = !!values2.tp_trigger_price ? new g$6(values2.tp_trigger_price).todp(config2.symbol.quote_dp).toNumber() : values2.tp_trigger_price;
      child_orders.push({
        algo_type: AlgoOrderType.TAKE_PROFIT,
        reduce_only: true,
        side,
        type: OrderType.CLOSE_POSITION,
        trigger_price: tp_trigger_price,
        trigger_price_type: TriggerPriceType.MARK_PRICE,
        symbol: values2.symbol,
        is_activated: !!values2.tp_trigger_price
      });
    }
    if (typeof values2.sl_trigger_price !== "undefined") {
      const sl_trigger_price = !!values2.sl_trigger_price ? new g$6(values2.sl_trigger_price).todp(config2.symbol.quote_dp).toNumber() : values2.sl_trigger_price;
      child_orders.push({
        algo_type: AlgoOrderType.STOP_LOSS,
        reduce_only: true,
        side,
        type: OrderType.CLOSE_POSITION,
        trigger_price: sl_trigger_price,
        trigger_price_type: TriggerPriceType.MARK_PRICE,
        symbol: values2.symbol,
        is_activated: !!values2.sl_trigger_price
      });
    }
    return {
      algo_type: AlgoOrderRootType.POSITIONAL_TP_SL,
      trigger_price_type: TriggerPriceType.MARK_PRICE,
      // reduce_only: true,
      symbol: values2.symbol,
      child_orders
    };
  }
  crateUpdateOrder(values2, oldValue, config2) {
    const data = this.create(values2, config2);
    const newData = [];
    data.child_orders.forEach((order) => {
      var _a3;
      const oldOrder = (_a3 = oldValue.child_orders) == null ? void 0 : _a3.find(
        (oldOrder2) => oldOrder2.algo_type === order.algo_type
      );
      if (oldOrder) {
        if (!order.is_activated) {
          newData.push({
            is_activated: false,
            order_id: Number(oldOrder.algo_order_id)
          });
        } else if (oldOrder.trigger_price !== order.trigger_price) {
          newData.push({
            trigger_price: order.trigger_price,
            order_id: Number(oldOrder.algo_order_id)
          });
        }
      }
    });
    return [
      {
        child_orders: newData
      },
      data
    ];
  }
};
async function bracketOrderValidator(values2, config2) {
  const result = /* @__PURE__ */ Object.create(null);
  await Promise.resolve();
  const { tp_trigger_price, sl_trigger_price, side } = values2;
  const qty = Number(values2.quantity);
  const maxQty2 = config2.maxQty;
  const type = values2.order_type;
  const { quote_max, quote_min, price_scope, quote_dp } = config2.symbol ?? {};
  const mark_price = type === OrderType.MARKET ? config2.markPrice : values2.order_price ? Number(values2.order_price) : void 0;
  if (!isNaN(qty) && qty > maxQty2) {
    result.quantity = OrderValidation.max("quantity", config2.maxQty);
  }
  if (Number(tp_trigger_price) < 0) {
    result.tp_trigger_price = OrderValidation.min("tp_trigger_price", 0);
  }
  if (Number(sl_trigger_price) < 0) {
    result.sl_trigger_price = OrderValidation.min("sl_trigger_price", 0);
  }
  if (side === OrderSide.BUY && mark_price) {
    const slTriggerPriceScope = new g$6(mark_price * (1 - price_scope)).toDecimalPlaces(quote_dp, g$6.ROUND_DOWN).toNumber();
    if (!!sl_trigger_price && Number(sl_trigger_price) < slTriggerPriceScope) {
      result.sl_trigger_price = OrderValidation.min(
        "sl_trigger_price",
        slTriggerPriceScope
      );
    }
    if (!!tp_trigger_price && Number(tp_trigger_price) <= mark_price) {
      result.tp_trigger_price = OrderValidation.min(
        "tp_trigger_price",
        mark_price
      );
    }
    if (!!tp_trigger_price && Number(tp_trigger_price) > quote_max) {
      result.tp_trigger_price = OrderValidation.max(
        "tp_trigger_price",
        quote_max
      );
    }
    if (!!sl_trigger_price && Number(sl_trigger_price) < quote_min) {
      result.sl_trigger_price = OrderValidation.min(
        "sl_trigger_price",
        quote_min
      );
    }
  }
  if (side === OrderSide.SELL && mark_price) {
    const slTriggerPriceScope = new g$6(mark_price * (1 + price_scope)).toDecimalPlaces(quote_dp, g$6.ROUND_DOWN).toNumber();
    if (!!sl_trigger_price && Number(sl_trigger_price) > slTriggerPriceScope) {
      result.sl_trigger_price = OrderValidation.max(
        "sl_trigger_price",
        slTriggerPriceScope
      );
    }
    if (!!tp_trigger_price && Number(tp_trigger_price) >= mark_price) {
      result.tp_trigger_price = OrderValidation.max(
        "tp_trigger_price",
        mark_price
      );
    }
    if (!!tp_trigger_price && Number(tp_trigger_price) > quote_max) {
      result.tp_trigger_price = OrderValidation.max(
        "tp_trigger_price",
        quote_max
      );
    }
    if (!!sl_trigger_price && Number(sl_trigger_price) < quote_min) {
      result.sl_trigger_price = OrderValidation.min(
        "sl_trigger_price",
        quote_min
      );
    }
  }
  return Object.keys(result).length > 0 ? result : null;
}
var BracketLimitOrderCreator = class extends LimitOrderCreator {
  // orderType: OrderType;
  create(values2, config2) {
    const order = super.create(values2, config2);
    return {
      ...order,
      quantity: order.order_quantity,
      type: order.order_type,
      price: order.order_price
    };
  }
  async validate(values2, config2) {
    const value = await super.validate(values2, config2);
    const bracketData = await bracketOrderValidator(values2, config2);
    return { ...value, ...bracketData };
  }
};
var BracketMarketOrderCreator = class extends MarketOrderCreator {
  constructor() {
    super(...arguments);
    this.orderType = OrderType.MARKET;
  }
  create(values2) {
    const order = super.create(values2);
    return {
      ...order,
      quantity: order.order_quantity,
      type: order.order_type,
      price: order.order_price
    };
  }
  async validate(values2, config2) {
    const value = await super.validate(values2, config2);
    const bracketData = await bracketOrderValidator(values2, config2);
    return { ...value, ...bracketData };
  }
};
var BBOOrderCreator = class extends BaseOrderCreator {
  create(values2) {
    const order = {
      ...this.baseOrder(values2),
      level: values2.level
    };
    return pick(
      [
        "symbol",
        "order_quantity",
        "visible_quantity",
        "reduce_only",
        "side",
        "order_type",
        "level"
      ],
      order
    );
  }
  async validate(values2, configs) {
    return this.baseValidate(values2, configs).then((errors) => {
      delete errors["total"];
      let { order_quantity, order_price, reduce_only, level } = values2;
      const { symbol } = configs;
      const { min_notional, base_tick, quote_dp, quote_tick, base_dp } = symbol || {};
      const minNotional = getMinNotional({
        base_tick,
        quote_tick,
        price: order_price,
        qty: order_quantity,
        min_notional,
        quote_dp,
        base_dp
      });
      if (minNotional !== void 0 && !reduce_only) {
        errors.total = {
          type: "min",
          message: `The order value should be greater or equal to ${minNotional} USDC`,
          value: minNotional
        };
      }
      return errors;
    });
  }
};
var OrderFactory = class {
  static create(type) {
    switch (type) {
      case `${AlgoOrderRootType.BRACKET}:${OrderType.LIMIT}`:
        return new BracketLimitOrderCreator();
      case `${AlgoOrderRootType.BRACKET}:${OrderType.MARKET}`:
        return new BracketMarketOrderCreator();
      case OrderType.LIMIT:
        return new LimitOrderCreator();
      case OrderType.MARKET:
        return new MarketOrderCreator();
      case OrderType.ASK:
      case OrderType.BID:
        return new BBOOrderCreator();
      case OrderType.IOC:
        return new IOCOrderCreator();
      case OrderType.FOK:
        return new FOKOrderCreator();
      case OrderType.POST_ONLY:
        return new PostOnlyOrderCreator();
      case OrderType.STOP_LIMIT:
        return new StopLimitOrderCreator();
      case OrderType.STOP_MARKET:
        return new StopMarketOrderCreator();
      case AlgoOrderRootType.TP_SL:
        return new TPSLOrderCreator();
      case AlgoOrderRootType.POSITIONAL_TP_SL:
        return new TPSLPositionOrderCreator();
      default:
        return new GeneralOrderCreator();
    }
  }
};
var useTaskProfitAndStopLossInternal = (position, options) => {
  var _a3, _b2, _c2, _d3;
  const isEditing = typeof (options == null ? void 0 : options.isEditing) !== "undefined" ? options.isEditing : !!(options == null ? void 0 : options.defaultOrder);
  const [order, setOrder] = useState({
    algo_order_id: (_a3 = options == null ? void 0 : options.defaultOrder) == null ? void 0 : _a3.algo_order_id,
    symbol: position.symbol,
    side: Number(position.position_qty) > 0 ? OrderSide.BUY : OrderSide.SELL,
    quantity: isEditing ? ((_b2 = options == null ? void 0 : options.defaultOrder) == null ? void 0 : _b2.quantity) === 0 ? Math.abs(position.position_qty) : (_c2 = options == null ? void 0 : options.defaultOrder) == null ? void 0 : _c2.quantity : "",
    // quantity:
    //   options?.defaultOrder?.quantity || Math.abs(position.position_qty),
    algo_type: (_d3 = options == null ? void 0 : options.defaultOrder) == null ? void 0 : _d3.algo_type
  });
  const symbolInfo = useSymbolsInfo()[position.symbol]();
  const { data: markPrice } = useMarkPrice(order.symbol);
  const [doCreateOrder, { isMutating: isCreateMutating }] = useMutation("/v1/algo/order");
  const [doUpdateOrder, { isMutating: isUpdateMutating }] = useMutation(
    "/v1/algo/order",
    "PUT"
  );
  const [doDeleteOrder] = useMutation("/v1/algo/order", "DELETE");
  const [errors, setErrors] = useState(null);
  useEffect(() => {
    if (!isEditing || !(options == null ? void 0 : options.defaultOrder))
      return;
    const trigger_prices = findTPSLFromOrder(options.defaultOrder);
    if (trigger_prices.tp_trigger_price) {
      setOrderValue("tp_trigger_price", trigger_prices.tp_trigger_price, {
        ignoreValidate: true
      });
    }
    if (trigger_prices.sl_trigger_price) {
      setOrderValue("sl_trigger_price", trigger_prices.sl_trigger_price, {
        ignoreValidate: true
      });
    }
  }, []);
  const _setOrderValue = (key, value, options2) => {
    setOrder((prev) => {
      const side = position.position_qty > 0 ? OrderSide.BUY : OrderSide.SELL;
      const newValue = tpslCalculateHelper(
        key,
        {
          value,
          entryPrice: position.average_open_price,
          qty: side === OrderSide.BUY ? Number(prev.quantity) : -Number(prev.quantity),
          orderSide: side
        },
        {
          symbol: symbolInfo
        }
      );
      return {
        ...prev,
        ...newValue,
        ignoreValidate: options2 == null ? void 0 : options2.ignoreValidate
      };
    });
  };
  const setOrderValue = async (key, value, options2) => {
    if (key === "quantity") {
      setOrder((prev) => ({ ...prev, quantity: value }));
      if (typeof order.sl_trigger_price !== "undefined") {
        _setOrderValue("sl_trigger_price", order.sl_trigger_price, {
          ignoreValidate: true
        });
      }
      if (typeof order.tp_trigger_price !== "undefined") {
        _setOrderValue("tp_trigger_price", order.tp_trigger_price, {
          ignoreValidate: true
        });
      }
      _setOrderValue(key, value, options2);
      return;
    }
    _setOrderValue(key, value, options2);
  };
  const valueConfig = {
    symbol: symbolInfo,
    maxQty: Math.abs(position.position_qty),
    markPrice
  };
  useEffect(() => {
    requestAnimationFrame(() => {
      if (order.ignoreValidate)
        return;
      const orderCreator = getOrderCreator2();
      orderCreator.validate(order, valueConfig).then((errors2) => {
        setErrors(errors2);
      });
    });
  }, [order, valueConfig.markPrice, order.quantity]);
  const setValues = (values2) => {
    const keys = Object.keys(values2);
    keys.forEach((key) => {
      setOrderValue(
        key,
        values2[key]
      );
    });
  };
  const validate = () => {
    const orderCreator = getOrderCreator2();
    return new Promise((resolve, reject) => {
      return orderCreator.validate(
        order,
        valueConfig
      ).then((errors2) => {
        if (errors2) {
          setErrors(errors2);
          return reject(errors2);
        }
        resolve(
          orderCreator.create(
            order,
            valueConfig
          )
        );
      });
    });
  };
  const compare = () => {
    const quantityNum = Number(order.quantity);
    if (isNaN(quantityNum))
      return false;
    return quantityNum === Math.abs(Number(position.position_qty));
  };
  const getOrderCreator2 = () => {
    var _a4;
    if (((_a4 = options == null ? void 0 : options.defaultOrder) == null ? void 0 : _a4.algo_type) === AlgoOrderRootType.TP_SL) {
      return OrderFactory.create(AlgoOrderRootType.TP_SL);
    }
    return OrderFactory.create(
      compare() ? AlgoOrderRootType.POSITIONAL_TP_SL : AlgoOrderRootType.TP_SL
    );
  };
  const submit = async () => {
    const defaultOrder = options == null ? void 0 : options.defaultOrder;
    const orderId = defaultOrder == null ? void 0 : defaultOrder.algo_order_id;
    const algoType = defaultOrder == null ? void 0 : defaultOrder.algo_type;
    if (!orderId) {
      return createOrder();
    }
    if (algoType === AlgoOrderRootType.POSITIONAL_TP_SL) {
      if (compare()) {
        return updateOrder(orderId);
      }
      return createOrder();
    }
    return updateOrder(orderId);
  };
  const createOrder = () => {
    const orderCreator = getOrderCreator2();
    const orderBody = orderCreator.create(
      order,
      valueConfig
    );
    if (orderBody.child_orders.length === 0) {
      throw new SDKError("No child orders");
    }
    orderBody.child_orders = orderBody.child_orders.filter(
      (order2) => order2.is_activated
    );
    return doCreateOrder(orderBody);
  };
  const deleteOrder = (orderId, symbol) => {
    return doDeleteOrder(null, {
      order_id: orderId,
      symbol
    });
  };
  const updateOrder = (orderId) => {
    const orderCreator = getOrderCreator2();
    const [updatedOrderEntity, orderEntity] = orderCreator.crateUpdateOrder(
      // @ts-ignore
      order,
      options == null ? void 0 : options.defaultOrder,
      valueConfig
    );
    if (updatedOrderEntity.child_orders.length === 0) {
      return Promise.resolve("Not any order needs to update");
    }
    const needDelete = orderEntity.child_orders.filter(
      (order2) => typeof order2.is_activated === "boolean" && !order2.is_activated
    ).length === orderEntity.child_orders.length;
    if (needDelete) {
      return deleteOrder(orderId, order.symbol);
    }
    return doUpdateOrder({
      order_id: orderId,
      ...updatedOrderEntity
    });
  };
  return [
    omit(["ignoreValidate"], order),
    {
      submit,
      deleteOrder,
      // create: submit,
      // update: updateOrder,/
      setValue: setOrderValue,
      setValues,
      // createPositionTPSL: submit,
      // createTPSL: submit,
      validate,
      errors,
      isCreateMutating,
      isUpdateMutating
    }
  ];
};
var useTPSLOrder = (position, options) => {
  if (!position) {
    throw new SDKError("Position is required");
  }
  if (!position.symbol) {
    throw new SDKError("Symbol is required");
  }
  if (typeof position.average_open_price === "undefined") {
    throw new SDKError("Average open price is required");
  }
  if (typeof position.position_qty === "undefined") {
    throw new SDKError("Position quantity is required");
  }
  const result = useTaskProfitAndStopLossInternal(position, options);
  return result;
};
var useSymbolLeverage = (symbol) => {
  const { data: info } = useAccountInfo2();
  const maxAccountLeverage = info == null ? void 0 : info.max_leverage;
  const res = useQuery(`/v1/public/info/${symbol}`, {
    dedupingInterval: 1e3 * 60 * 60 * 24,
    revalidateOnFocus: false,
    errorRetryCount: 2,
    errorRetryInterval: 200
  });
  const maxSymbolLeverage = useMemo(() => {
    var _a3;
    const base = (_a3 = res == null ? void 0 : res.data) == null ? void 0 : _a3.base_imr;
    if (base)
      return 1 / base;
  }, [res]);
  const maxLeverage = useMemo(() => {
    if (!maxAccountLeverage || !maxSymbolLeverage) {
      return "-";
    }
    return Math.min(maxAccountLeverage, maxSymbolLeverage);
  }, [maxAccountLeverage, maxSymbolLeverage]);
  return maxLeverage;
};
var useAssetsHistory = (options) => {
  const { page = 1, pageSize = 10 } = options;
  const ee2 = useEventEmitter();
  const getKey = () => {
    const searchParams = new URLSearchParams();
    searchParams.set("page", page.toString());
    searchParams.set("size", pageSize.toString());
    if (options.side && options.side !== "All")
      searchParams.set("side", options.side);
    if (options.startTime)
      searchParams.set("start_t", options.startTime);
    if (options.endTime)
      searchParams.set("end_t", options.endTime);
    return `/v1/asset/history?${searchParams.toString()}`;
  };
  const { data, isLoading, mutate: mutate3 } = usePrivateQuery(
    getKey(),
    {
      formatter: (data2) => data2,
      revalidateOnFocus: false,
      errorRetryInterval: 60 * 1e3
    }
  );
  const updateList = useDebouncedCallback(
    (data2) => {
      mutate3();
    },
    // delay in ms
    300
  );
  useEffect(() => {
    ee2.on("wallet:changed", updateList);
    return () => {
      ee2.off("wallet:changed", updateList);
    };
  }, []);
  return [
    (data == null ? void 0 : data.rows) || [],
    {
      meta: data == null ? void 0 : data.meta,
      isLoading
    }
  ];
};
var useStatisticsDaily = (params, options) => {
  const { startDate, endDate, page = 1 } = params;
  const { ignoreAggregation = false } = options || {};
  if (!startDate || !endDate) {
    throw new SDKError("Start date and end date are required");
  }
  const getPeriod = (startDate2, endDate2) => {
    if (startDate2 === endDate2) {
      return 1;
    }
    const diff = new Date(endDate2).getTime() - new Date(startDate2).getTime();
    return diff / (1e3 * 60 * 60 * 24);
  };
  const key = useMemo(() => {
    const searchParams = new URLSearchParams();
    searchParams.set("page", page.toString());
    searchParams.set(
      "size",
      (getPeriod(startDate, endDate) + (ignoreAggregation ? 0 : 1)).toString()
    );
    const modifiedStartDate = new Date(startDate);
    modifiedStartDate.setDate(new Date(startDate).getDate() - 1);
    searchParams.set(
      "start_date",
      modifiedStartDate.toISOString().split("T")[0]
    );
    searchParams.set("end_date", params.endDate);
    return `/v1/client/statistics/daily?${searchParams.toString()}`;
  }, [page, startDate, endDate]);
  const { data } = usePrivateQuery(key, {
    formatter: (data2) => data2.rows.reverse(),
    revalidateOnFocus: false
  });
  const aggregateValue = useMemo(() => {
    if (ignoreAggregation) {
      return { vol: null, pnl: null, roi: null };
    }
    let vol = $$4;
    let pnl = $$4;
    let roi = $$4;
    if (Array.isArray(data) && data.length) {
      const prevDate = data.shift();
      data.forEach((d2) => {
        vol = vol.add(d2.perp_volume);
        pnl = pnl.add(d2.pnl);
      });
      roi = pnl.div(prevDate.account_value);
    }
    return { vol: vol.toNumber(), pnl: pnl.toNumber(), roi: roi.toNumber() };
  }, [data]);
  return [
    data || [],
    {
      aggregateValue
    }
  ];
};
var useFundingFeeHistory = (params, options) => {
  let { symbol, dataRange, page = 1, pageSize = 10 } = params;
  const infos = useSymbolsInfo();
  const getKey = () => {
    const search = new URLSearchParams();
    if (typeof symbol !== "undefined" && symbol !== "All") {
      search.set("symbol", symbol);
    }
    search.set("page", `${page}`);
    search.set("size", `${pageSize}`);
    if (dataRange) {
      search.set("start_t", dataRange[0].toString());
      search.set("end_t", dataRange[1].toString());
    }
    return `/v1/funding_fee/history?${search.toString()}`;
  };
  const { data, isLoading, isValidating } = usePrivateQuery(getKey(), {
    // initialSize: 1,
    formatter: (data2) => data2,
    revalidateOnFocus: false,
    errorRetryCount: 3,
    // keepPreviousData: true,
    ...options
  });
  const parsedData = useMemo(() => {
    if (!data || !Array.isArray(data == null ? void 0 : data.rows) || infos.isNil) {
      return null;
    }
    return data.rows.map((row) => {
      const config2 = infos[row.symbol];
      return {
        ...row,
        annual_rate: row.funding_rate * (24 / config2("funding_period")) * 365
      };
    });
  }, [data, infos]);
  return [
    parsedData,
    {
      meta: data == null ? void 0 : data.meta,
      isLoading,
      isValidating
    }
  ];
};
var useDistributionHistory = (parmas) => {
  let { type, dataRange, page, pageSize } = parmas;
  const infos = useSymbolsInfo();
  const getKey = () => {
    const search = new URLSearchParams();
    if (typeof type !== "undefined" && type !== "All") {
      search.set("type", type);
    }
    search.set("page", page.toString());
    search.set("size", pageSize.toString());
    if (dataRange) {
      search.set("start_t", dataRange[0].toString());
      search.set("end_t", dataRange[1].toString());
    }
    return `/v1/client/distribution_history?${search.toString()}`;
  };
  const { data, isLoading, isValidating } = usePrivateQuery(getKey(), {
    // initialSize: 1,
    formatter: (data2) => data2,
    revalidateOnFocus: false,
    errorRetryCount: 3
  });
  const parsedData = useMemo(() => {
    if (!Array.isArray(data == null ? void 0 : data.rows) || !(data == null ? void 0 : data.rows.length) || infos.isNil) {
      return [];
    }
    return data.rows.map((row) => {
      const config2 = infos[row.symbol];
      return {
        ...row,
        annual_rate: row.funding_rate * (24 / config2("funding_period"))
      };
    });
  }, [data, infos]);
  return [
    parsedData,
    {
      meta: data == null ? void 0 : data.meta,
      isLoading,
      isValidating
    }
  ];
};
var MaintenanceStatus = /* @__PURE__ */ ((MaintenanceStatus2) => {
  MaintenanceStatus2[MaintenanceStatus2["None"] = 0] = "None";
  MaintenanceStatus2[MaintenanceStatus2["Maintenance"] = 2] = "Maintenance";
  return MaintenanceStatus2;
})(MaintenanceStatus || {});
function useMaintenanceStatus() {
  const [status, setStatus] = useState(
    0
    /* None */
  );
  const [startTime, setStartTime] = useState();
  const [endTime, setEndTime] = useState();
  const [brokerName, setBrokerName] = useState("Orderly network");
  const { data: systemInfo, mutate: mutate3 } = useQuery(
    `/v1/public/system_info?source=maintenance`,
    {
      revalidateOnFocus: false,
      errorRetryCount: 2,
      errorRetryInterval: 200
    }
  );
  const ws2 = useWS();
  const config2 = useConfig();
  useEffect(() => {
    if (!systemInfo) {
      return;
    }
    const brokerName2 = config2.get("brokerName");
    if (brokerName2) {
      setBrokerName(brokerName2);
    }
    if (systemInfo.scheduled_maintenance) {
      setStartTime(systemInfo.scheduled_maintenance.start_time);
      setEndTime(systemInfo.scheduled_maintenance.end_time);
    }
    if (systemInfo.status === 2) {
      setStatus(
        2
        /* Maintenance */
      );
    }
  }, [systemInfo, config2]);
  useEffect(() => {
    const unsubscribe = ws2.subscribe(`maintenance_status`, {
      onMessage: (message) => {
        setStatus(message.status);
        if (message.scheduled_maintenance) {
          setStartTime(message.scheduled_maintenance.start_time);
          setEndTime(message.scheduled_maintenance.end_time);
        }
      }
    });
    return () => {
      unsubscribe == null ? void 0 : unsubscribe();
    };
  }, []);
  return {
    status,
    brokerName,
    startTime,
    endTime
  };
}
var useStorageLedgerAddress = () => {
  const [ledgerWallet, setLedgerWallet] = useLocalStorage(LedgerWalletKey, []);
  const setLedgerAddress = (address) => {
    if (!ledgerWallet.includes(address)) {
      const arr = [...ledgerWallet, address];
      setLedgerWallet(arr);
    }
  };
  return {
    setLedgerAddress,
    ledgerWallet
  };
};
var usePrivateDataObserver = (options) => {
  const ws2 = useWS();
  const ee2 = useEventEmitter();
  const { state, account: account5 } = useAccount();
  const { setAccountInfo, restoreHolding, cleanAll } = useAppStore(
    (state2) => state2.actions
  );
  const statusActions = useApiStatusActions();
  const calculatorService = useCalculatorService();
  const positionsActions = usePositionActions();
  const { data: clientInfo } = usePrivateQuery("/v1/client/info");
  useEffect(() => {
    if (clientInfo) {
      setAccountInfo(clientInfo);
    }
  }, [clientInfo, setAccountInfo]);
  const { data: positions2, isLoading: isPositionLoading } = usePrivateQuery("/v1/positions", {
    formatter: (data) => data,
    onError: (error) => {
      statusActions.updateApiError("positions", error.message);
    }
    // revalidateOnFocus: false,
  });
  useEffect(() => {
    const handler = (state2) => {
      if (!state2.accountId) {
        calculatorService.stop();
        cleanAll();
        positionsActions.clearAll();
      }
    };
    account5.on(_$4.statusChanged, handler);
    return () => {
      account5.off(_$4.statusChanged, handler);
    };
  }, []);
  useEffect(() => {
    if (isPositionLoading) {
      statusActions.updateApiLoading("positions", isPositionLoading);
    }
  }, [isPositionLoading, statusActions]);
  useEffect(() => {
    if (positions2 && Array.isArray(positions2.rows)) {
      calculatorService.calc("position", positions2);
    }
  }, [calculatorService, positions2]);
  const { data: holding } = usePrivateQuery(
    "/v1/client/holding",
    {
      formatter: (data) => data.holding
      // revalidateOnFocus: false,
    }
  );
  useEffect(() => {
    const unsubscribe = ws2.privateSubscribe(
      {
        id: "balance",
        event: "subscribe",
        topic: "balance",
        ts: Date.now()
      },
      {
        onMessage: (data) => {
          const holding2 = (data == null ? void 0 : data.balances) ?? {};
          if (holding2) {
            calculatorService.calc("portfolio", { holding: holding2 });
          }
        }
      }
    );
    return () => unsubscribe();
  }, []);
  useEffect(() => {
    if (holding) {
      restoreHolding(holding);
    }
  }, [holding]);
  const [subOrder, setSubOrder] = useLocalStorage(
    "orderly_subscribe_order",
    true
  );
  const updateOrders = (data, isAlgoOrder) => {
    const keysMap = options.getKeysMap("orders");
    keysMap.forEach((getKey, key) => {
      mutate$1(
        unstable_serialize((index, prevData) => [
          getKey(index, prevData),
          state.accountId
        ]),
        (prevData) => {
          try {
            if (isAlgoOrder) {
              const result = updateAlgoOrdersHandler(
                key,
                data,
                prevData
              );
              return result;
            }
            return updateOrdersHandler(key, data, prevData);
          } catch (error) {
            return prevData;
          }
        },
        {
          revalidate: false
        }
      );
    });
    const formattedData = isAlgoOrder ? AlgoOrderMergeHandler.groupOrders(data) : object2underscore(data);
    ee2.emit("orders:changed", {
      ...formattedData,
      status: isAlgoOrder ? formattedData.algo_status : data.status
    });
  };
  useEffect(() => {
    if (!state.accountId)
      return;
    if (subOrder !== true)
      return;
    const unsubscribe = ws2.privateSubscribe("executionreport", {
      onMessage: (data) => {
        updateOrders(data, false);
      }
    });
    return () => unsubscribe == null ? void 0 : unsubscribe();
  }, [state.accountId, subOrder]);
  useEffect(() => {
    if (!state.accountId)
      return;
    if (subOrder !== true)
      return;
    const unsubscribe = ws2.privateSubscribe("algoexecutionreport", {
      onMessage: (data) => {
        updateOrders(data, true);
      }
    });
    return () => unsubscribe == null ? void 0 : unsubscribe();
  }, [state.accountId, subOrder]);
  useEffect(() => {
    if (!state.accountId)
      return;
    const key = ["/v1/positions", state.accountId];
    const unsubscribe = ws2.privateSubscribe("position", {
      onMessage: (data) => {
        const { positions: nextPositions } = data;
        mutate$1(
          key,
          (prevPositions) => {
            if (!!prevPositions) {
              const newPositions = {
                ...prevPositions,
                rows: prevPositions.rows.map((row) => {
                  const itemIndex = nextPositions.findIndex(
                    (item) => item.symbol === row.symbol
                  );
                  if (itemIndex >= 0) {
                    const itemArr = nextPositions.splice(itemIndex, 1);
                    const item = itemArr[0];
                    if (item.averageOpenPrice === 0 && item.positionQty !== 0) {
                      return row;
                    }
                    return object2underscore(item);
                  }
                  return row;
                })
              };
              if (nextPositions.length > 0) {
                newPositions.rows = [
                  ...newPositions.rows,
                  ...nextPositions.map((item) => {
                    return object2underscore(item);
                  })
                ];
              }
              return newPositions;
            }
          },
          {
            revalidate: false
          }
        );
      }
    });
    return () => {
      unsubscribe == null ? void 0 : unsubscribe();
    };
  }, [state.accountId]);
};
var useWSObserver = (calculatorService) => {
  const ws2 = useWS();
  useEffect(() => {
    const markPriceSubscription = ws2.subscribe("markprices", {
      onMessage: (message) => {
        const data = /* @__PURE__ */ Object.create(null);
        for (let index = 0; index < message.length; index++) {
          const element = message[index];
          data[element.symbol] = element.price;
        }
        calculatorService.calc("markPrice", data, {
          skipWhenOnPause: true
        });
      },
      onError: (error) => {
      }
    });
    const indexPriceSubscription = ws2.subscribe("indexprices", {
      onMessage: (message) => {
        if (!Array.isArray(message))
          return;
        const prices = /* @__PURE__ */ Object.create(null);
        for (let index = 0; index < message.length; index++) {
          const element = message[index];
          prices[element.symbol.replace("SPOT", "PERP")] = element.price;
        }
        calculatorService.calc("indexPrice", prices, {
          skipWhenOnPause: true
        });
      }
    });
    return () => {
      markPriceSubscription == null ? void 0 : markPriceSubscription();
      indexPriceSubscription == null ? void 0 : indexPriceSubscription();
    };
  }, []);
};
var useMarketStore = create(
  (set2, get3) => ({
    market: [],
    // marketSymbols: [],
    marketMap: null,
    actions: {
      updateMarket: (data) => {
        const marketMap = {};
        data.forEach((item) => {
          marketMap[item.symbol] = item;
        });
        set2({
          market: data,
          // marketSymbols: symbols,
          marketMap
        });
      },
      updateTicker: (data) => {
        set2(
          produce((state) => {
            state.market = data;
          })
        );
      }
    }
  })
);
var publicQueryOptions = {
  focusThrottleInterval: 1e3 * 60 * 60 * 24,
  revalidateOnFocus: false,
  dedupingInterval: 1e3 * 60 * 60 * 24
};
var usePublicDataObserver = () => {
  const { setSymbolsInfo, setFundingRates } = useAppStore(
    (state) => state.actions
  );
  const { updateMarket } = useMarketStore((state) => state.actions);
  useQuery(`/v1/public/info`, {
    ...publicQueryOptions,
    onSuccess(data) {
      if (!data || !(data == null ? void 0 : data.length)) {
        return {};
      }
      const obj = {};
      for (let index = 0; index < data.length; index++) {
        const item = data[index];
        const arr = item.symbol.split("_");
        const base_dp = _$3(item.base_tick);
        const quote_dp = _$3(item.quote_tick);
        obj[item.symbol] = {
          ...item,
          base_dp,
          quote_dp,
          base: arr[1],
          quote: arr[2],
          type: arr[0],
          name: `${arr[1]}-${arr[0]}`
        };
      }
      setSymbolsInfo(obj);
    }
  });
  useQuery(`/v1/public/funding_rates`, {
    ...publicQueryOptions,
    onSuccess(data) {
      if (!data || !(data == null ? void 0 : data.length)) {
        return {};
      }
      const obj = /* @__PURE__ */ Object.create(null);
      for (let index = 0; index < data.length; index++) {
        const item = data[index];
        obj[item.symbol] = {
          ...item,
          est_funding_rate: getEstFundingRate(item)
        };
      }
      setFundingRates(obj);
    }
  });
  useQuery(`/v1/public/futures`, {
    // revalidateOnFocus: false,
    ...publicQueryOptions,
    onSuccess(data) {
      if (!data || !(data == null ? void 0 : data.length)) {
        return [];
      }
      updateMarket(data);
    }
  });
};
function getEstFundingRate(data) {
  if (!data)
    return;
  const { next_funding_time, est_funding_rate } = data;
  if (Date.now() > next_funding_time) {
    return null;
  }
  return est_funding_rate;
}
var DataCenterContext = createContext(
  {}
);
var useDataCenterContext = () => useContext(DataCenterContext);
var DataCenterProvider = ({ children }) => {
  const { error, done } = usePreLoadData();
  const calculatorService = useCalculatorService();
  usePublicDataObserver();
  useWSObserver(calculatorService);
  const getKeyHandlerMapRef = useRef(/* @__PURE__ */ new Map());
  usePrivateDataObserver({
    getKeysMap(type) {
      return getKeyHandlerMapRef.current;
    }
  });
  if (error) {
    return /* @__PURE__ */ jsx("div", { children: "Data load failed" });
  }
  if (!done)
    return null;
  return /* @__PURE__ */ jsx(
    DataCenterContext.Provider,
    {
      value: {
        registerKeyHandler: (key, fun) => {
          getKeyHandlerMapRef.current.set(key, fun);
        },
        unregisterKeyHandler: (key) => {
          getKeyHandlerMapRef.current.delete(key);
        }
      },
      children
    }
  );
};
var ProxyConfigStore = class {
  constructor(_originConfigStore) {
    this._originConfigStore = _originConfigStore;
    w$4(() => {
      this._proxyConfigStore = window.__ORDERLY_CONFIG_STORE__ || _originConfigStore;
    });
  }
  get(key) {
    var _a3;
    const value = (_a3 = this._proxyConfigStore) == null ? void 0 : _a3.get(key);
    if (typeof value === "undefined") {
      return this._originConfigStore.get(key);
    }
    return value;
  }
  getOr(key, defaultValue) {
    return (this._proxyConfigStore ?? this._originConfigStore).getOr(
      key,
      defaultValue
    );
  }
  set(key, value) {
    (this._proxyConfigStore ?? this._originConfigStore).set(key, value);
  }
  clear() {
    throw new SDKError("Method not implemented.");
  }
  getFromOrigin(key) {
    return this._originConfigStore.get(key);
  }
  getOrFromOrigin(key, defaultValue) {
    return this._originConfigStore.getOr(key, defaultValue);
  }
  setToOrigin(key, value) {
    this._originConfigStore.set(key, value);
  }
  clearOrigin() {
    this._originConfigStore.clear();
  }
};
var ExtendedConfigStore = class extends St$5 {
  constructor(init2) {
    super(init2);
  }
  get(key) {
    if (key === MarketsStorageKey) {
      const jsonStr = localStorage.getItem(MarketsStorageKey);
      if (!jsonStr) {
        const oldJsonStr = localStorage.getItem(
          MarketsStorageKey.replace("orderly_", "")
        );
        return oldJsonStr ? JSON.parse(oldJsonStr) : "";
      }
      return JSON.parse(jsonStr);
    }
    return super.get(key);
  }
  set(key, value) {
    if (key === MarketsStorageKey) {
      const jsonStr = JSON.stringify(value);
      localStorage.setItem(MarketsStorageKey, jsonStr);
      return;
    }
    super.set(key, value);
  }
};
var OrderlyConfigProvider = (props) => {
  const [account5, setAccount] = ze__default__default.useState(null);
  const {
    configStore,
    keyStore,
    // getWalletAdapter,
    walletAdapters,
    brokerId,
    brokerName,
    networkId,
    contracts,
    chainFilter,
    customChains
  } = props;
  if (typeof configStore !== "undefined" && !configStore.get("brokerId")) {
    throw new SDKError(
      "if configStore is provided, brokerId is required in configStore"
    );
  }
  if (typeof brokerId !== "undefined" && typeof configStore !== "undefined" && brokerId !== configStore.get("brokerId")) {
    throw new SDKError(
      "If you have provided a custom `configStore` and the `brokerId` is set in the `configStore`, please remove the `brokerId` prop."
    );
  }
  const innerConfigStore = useMemo(() => {
    return new ProxyConfigStore(
      configStore || new ExtendedConfigStore({ brokerId, brokerName, networkId })
    );
  }, [configStore, brokerId, brokerName, networkId]);
  const innerKeyStore = useMemo(() => {
    return keyStore || new Ce$4(networkId);
  }, [networkId, keyStore]);
  const innerWalletAdapters = useMemo(() => {
    return walletAdapters || [
      new w$3(new v$1()),
      new ve$6()
    ];
  }, [walletAdapters]);
  useLayoutEffect(() => {
    let account6 = Ia$1.get(_t$3.instanceName);
    if (!account6) {
      account6 = new _t$3(
        innerConfigStore,
        innerKeyStore,
        // innerGetWalletAdapter,
        innerWalletAdapters,
        {
          contracts
        }
      );
      Ia$1.registerByName(_t$3.instanceName, account6);
    }
    setAccount(account6);
  }, []);
  const filteredChains = useMemo(() => {
    if (typeof chainFilter === "function") {
      return chainFilter(innerConfigStore);
    }
    return chainFilter;
  }, [props.chainFilter, innerConfigStore]);
  if (!account5) {
    return null;
  }
  return /* @__PURE__ */ jsx(
    OrderlyProvider,
    {
      value: {
        configStore: innerConfigStore,
        keyStore: innerKeyStore,
        // getWalletAdapter: innerGetWalletAdapter,
        networkId: innerConfigStore.get("networkId") || networkId,
        filteredChains,
        walletAdapters: innerWalletAdapters,
        // apiBaseUrl,
        customChains
      },
      children: /* @__PURE__ */ jsx(StatusProvider, { children: /* @__PURE__ */ jsx(DataCenterProvider, { children: props.children }) })
    }
  );
};
var needNumberOnlyFields = [
  "order_quantity",
  "order_price",
  "trigger_price",
  "total"
];
var cleanStringStyle = (str) => {
  if (typeof str !== "string") {
    str = `${str}`;
  }
  str = str.replace(/,/g, "");
  str = str.replace(/[^\d.]/g, "").replace(".", "$#$").replace(/\./g, "").replace("$#$", ".");
  return str;
};
function baseInputHandle(inputs) {
  let [values2, input, value, markPrice, config2] = inputs;
  needNumberOnlyFields.forEach((field) => {
    if (typeof values2[field] !== "undefined") {
      values2[field] = cleanStringStyle(values2[field]);
    }
  });
  if (needNumberOnlyFields.includes(input)) {
    value = cleanStringStyle(value);
  }
  return [
    {
      ...values2,
      [input]: value
    },
    input,
    value,
    markPrice,
    config2
  ];
}
function orderTypeHandle(inputs) {
  const [values2, input, value, markPrice, config2] = inputs;
  if (value === OrderType.LIMIT || value === OrderType.STOP_LIMIT) {
    if (values2.order_price === "") {
      values2.total = "";
    }
  }
  if (value === OrderType.MARKET || value === OrderType.LIMIT) {
    values2.trigger_price = void 0;
  }
  if (value === OrderType.MARKET || value === OrderType.STOP_MARKET) ;
  return [values2, input, value, markPrice, config2];
}
function orderEntityFormatHandle(baseTick, quoteTick) {
  return function(inputs) {
    const [values2, input, value, markPrice, config2] = inputs;
    return [values2, input, value, markPrice, config2];
  };
}
function priceInputHandle(inputs) {
  const [values2, input, value, markPrice, config2] = inputs;
  if (value === "") {
    return [{ ...values2, total: "" }, input, value, markPrice, config2];
  }
  const price = new g$6(value);
  const priceDP = price.dp();
  if (priceDP > config2.quote_dp) {
    values2.order_price = price.toDecimalPlaces(config2.quote_dp).toString();
  }
  price.toDecimalPlaces(Math.min(priceDP, config2.quote_dp));
  if (!values2.order_quantity && !values2.total) {
    return [values2, input, value, markPrice, config2];
  }
  const newValue = {
    ...values2
  };
  if (values2.order_quantity) {
    newValue.total = price.mul(values2.order_quantity).todp(2).toString();
  } else if (values2.total) {
    newValue.order_quantity = new g$6(values2.total).div(price).todp(config2.base_dp).toString();
  }
  return [
    // {
    //   ...values,
    //   total: total.todp(2).toString(),
    // },
    newValue,
    input,
    value,
    markPrice,
    config2
  ];
}
function quantityInputHandle(inputs) {
  const [values2, input, value, markPrice, config2] = inputs;
  if (value === "") {
    return [{ ...values2, total: "" }, input, value, markPrice, config2];
  }
  let quantity = new g$6(value);
  const quantityDP = quantity.dp();
  if (quantityDP > config2.base_dp) {
    quantity = quantity.toDecimalPlaces(config2.base_dp);
    values2.order_quantity = quantity.toString();
  }
  if (values2.order_type === OrderType.MARKET || values2.order_type === OrderType.STOP_MARKET) {
    if (!markPrice) {
      return [values2, input, value, markPrice, config2];
    }
    const price = markPrice;
    values2.order_price = "";
    values2.total = quantity.mul(price).todp(2).toString();
  }
  if (values2.order_type === OrderType.LIMIT || values2.order_type === OrderType.STOP_LIMIT) {
    if (values2.order_price) {
      const price = Number(values2.order_price);
      const total = quantity.mul(price);
      values2.total = total.todp(config2.quote_dp).toString();
    } else {
      values2.total = "";
    }
  }
  return [
    {
      ...values2
    },
    input,
    value,
    markPrice,
    config2
  ];
}
function totalInputHandle(inputs) {
  const [values2, input, value, markPrice, config2] = inputs;
  if (value === "") {
    return [{ ...values2, order_quantity: "" }, input, value, markPrice, config2];
  }
  let price = markPrice;
  if ((values2.order_type === OrderType.LIMIT || values2.order_type === OrderType.STOP_LIMIT) && !!values2.order_price) {
    price = Number(values2.order_price);
  }
  let total = new g$6(value);
  const totalDP = total.dp();
  if (totalDP > config2.quote_dp) {
    total = total.toDecimalPlaces(config2.quote_dp);
    values2.total = total.toString();
  }
  const quantity = total.div(price);
  let order_quantity = quantity.toDecimalPlaces(Math.min(config2.base_dp, quantity.dp())).toString();
  if (config2.base_tick >= 1) {
    order_quantity = formatNumber(
      order_quantity,
      new g$6((config2 == null ? void 0 : config2.base_tick) || "0").toNumber()
    );
  }
  return [
    {
      ...values2,
      order_quantity
    },
    input,
    value,
    markPrice,
    config2
  ];
}
function tpslInputHandle(inputs) {
  const [values2, input, value, markPrice, config2] = inputs;
  const price = values2.order_type === OrderType.MARKET || values2.order_type === OrderType.STOP_MARKET ? markPrice : values2.order_price;
  if (!price || !values2.order_quantity) {
    return [values2, input, value, markPrice, config2];
  }
  const _tpslValue = tpslCalculateHelper(
    input,
    {
      value,
      entryPrice: price,
      // order price or mark price
      qty: values2.side === OrderSide.BUY ? Number(values2.order_quantity) : Number(values2.order_quantity) * -1,
      orderSide: values2.side
      // values: newValues,
    },
    {
      symbol: config2
    }
  );
  return [{ ...values2, ..._tpslValue }, input, value, markPrice, config2];
}
function otherInputHandle(inputs) {
  return inputs;
}
var getCalculateHandler = (fieldName) => {
  switch (fieldName) {
    case "order_type":
      return orderTypeHandle;
    case "order_quantity": {
      return quantityInputHandle;
    }
    case "order_price": {
      return priceInputHandle;
    }
    case "total": {
      return totalInputHandle;
    }
    case "tp_pnl":
    case "sl_pnl":
    case "tp_trigger_price":
    case "sl_trigger_price":
    case "tp_offset":
    case "sl_offset":
    case "tp_offset_percentage":
    case "sl_offset_percentage":
      return tpslInputHandle;
    default:
      return otherInputHandle;
  }
};
function formatNumber(qty, dp) {
  if (typeof qty === "undefined")
    return qty;
  if (typeof dp === "undefined")
    return `${qty}`;
  const _qty = `${qty}`.replace(/,/g, "");
  try {
    const _dp = new g$6(dp);
    const _qtyDecimal = new g$6(_qty);
    if (_dp.lessThan(1)) {
      if (`${_qty}`.endsWith("."))
        return `${_qty}`;
      const numStr = dp.toString();
      const decimalIndex = numStr.indexOf(".");
      const digitsAfterDecimal = decimalIndex === -1 ? 0 : numStr.length - decimalIndex - 1;
      const result = _qtyDecimal.toDecimalPlaces(digitsAfterDecimal, g$6.ROUND_DOWN).toString();
      return result;
    }
    if (_qtyDecimal.lessThan(_dp)) {
      return _qty;
    }
    return _qtyDecimal.dividedBy(_dp).toDecimalPlaces(0, g$6.ROUND_DOWN).mul(dp).toString();
  } catch (e2) {
    return void 0;
  }
}
function useOrderEntry(symbolOrOrder, sideOrOptions, reduceOnly, options) {
  let isNewVersion = false;
  if (typeof symbolOrOrder === "object") {
    isNewVersion = true;
    if (!symbolOrOrder.symbol) {
      throw new SDKError("Symbol is required");
    }
    if (!symbolOrOrder.side) {
      throw new SDKError("Order side is required");
    }
    if (!symbolOrOrder.order_type) {
      throw new SDKError("Order type is required");
    }
  }
  const prevOrderData = useRef(null);
  const orderDataCache = useRef(null);
  const notSupportData = useRef({});
  const [errors, setErrors] = useState(null);
  const ee2 = useEventEmitter();
  const positions2 = usePositions();
  const fieldDirty = useRef({});
  const submitted = useRef(false);
  const askAndBid = useRef([]);
  const onOrderBookUpdate = useDebouncedCallback((data) => {
    askAndBid.current = data;
  }, 200);
  const { freeCollateral: freeCollateral2, totalCollateral: totalCollateral2, accountInfo } = useCollateral();
  const symbolInfo = useSymbolsInfo();
  const symbol = useMemo(() => {
    if (typeof symbolOrOrder === "string") {
      return symbolOrOrder;
    }
    return symbolOrOrder.symbol;
  }, [symbolOrOrder]);
  const optionsValue = useMemo(() => {
    if (typeof sideOrOptions === "object") {
      return sideOrOptions;
    }
    return options;
  }, [sideOrOptions]);
  const isReduceOnly = useMemo(() => {
    if (typeof reduceOnly === "boolean") {
      return reduceOnly;
    }
    if (typeof symbolOrOrder === "object") {
      return !!symbolOrOrder.reduce_only;
    }
    return false;
  }, [symbolOrOrder, reduceOnly]);
  const sideValue = useMemo(() => {
    if (typeof symbolOrOrder === "object") {
      return symbolOrOrder.side;
    }
    return sideOrOptions;
  }, [symbolOrOrder, sideOrOptions]);
  const baseDP = useMemo(
    () => _$3(symbolInfo[symbol]("base_tick", 0)),
    [symbolInfo]
  );
  const quoteDP = useMemo(() => {
    return _$3(symbolInfo[symbol]("quote_tick", 0));
  }, [symbolInfo]);
  const baseIMR = useMemo(
    () => symbolInfo[symbol]("base_imr", 0),
    [symbolInfo]
  );
  const baseMMR = useMemo(
    () => symbolInfo[symbol]("base_mmr", 0),
    [symbolInfo]
  );
  const { data: markPrice } = useMarkPrice(symbol);
  const diffOrderEntry = (prev, current) => {
    if (!prev)
      return null;
    let key, value, preValue;
    const keys = Object.keys(current);
    for (let i = 0; i < keys.length; i++) {
      const k2 = keys[i];
      let preveValue = prev[k2];
      let currentValue = current[k2];
      if (typeof preveValue === "undefined" && typeof currentValue === "undefined")
        continue;
      if (preveValue !== currentValue) {
        key = k2;
        value = currentValue;
        preValue = preveValue;
        break;
      }
    }
    if (!key)
      return null;
    return { key, value, preValue };
  };
  const maxQty2 = useMaxQty(symbol, sideValue, isReduceOnly);
  const parseString2Number = (order, key, dp) => {
    if (typeof order[key] !== "string")
      return;
    if (order[key] && order[key].startsWith(".")) {
      order[key] = `0${order[key]}`;
    }
    order[key] = order[key].replace(/,/g, "");
    if (dp && order[key].length > 0) {
      const hasPoint = `${order[key]}`.includes(".");
      const endOfPoint = `${order[key]}`.endsWith(".");
      const decimalPart = `${order[key]}`.split(".");
      if (hasPoint && !endOfPoint) {
        order[key] = `${decimalPart[0]}.${decimalPart[1].slice(
          0,
          quoteDP
        )}`;
      }
    }
  };
  const needParse = useMemo(() => {
    if (typeof symbolOrOrder === "string") {
      return null;
    }
    return pick([
      "order_price",
      "side",
      "order_quantity",
      "visible_quantity",
      "order_type",
      "order_type_ext",
      "symbol",
      "total",
      "reduce_only",
      "trigger_price"
    ])(
      //@ts-ignore
      symbolOrOrder
    );
  }, [symbolOrOrder]);
  const parsedData = useMemo(() => {
    if (typeof symbolOrOrder === "string") {
      return null;
    }
    if (typeof symbolOrOrder.order_quantity === "string") {
      parseString2Number(symbolOrOrder, "order_quantity");
    } else if (typeof symbolOrOrder.order_quantity === "number") {
      symbolOrOrder.order_quantity = new g$6(symbolOrOrder.order_quantity).toDecimalPlaces(baseDP).toString();
    }
    if (typeof symbolOrOrder.order_price === "string") {
      parseString2Number(symbolOrOrder, "order_price", quoteDP);
    }
    if (typeof symbolOrOrder.total === "string") {
      parseString2Number(symbolOrOrder, "total", quoteDP);
    }
    if (typeof symbolOrOrder.trigger_price === "string") {
      parseString2Number(symbolOrOrder, "trigger_price", quoteDP);
    }
    return symbolOrOrder;
  }, [
    needParse == null ? void 0 : needParse.order_price,
    needParse == null ? void 0 : needParse.order_quantity,
    needParse == null ? void 0 : needParse.total,
    needParse == null ? void 0 : needParse.trigger_price,
    needParse == null ? void 0 : needParse.order_type,
    needParse == null ? void 0 : needParse.order_type_ext,
    needParse == null ? void 0 : needParse.symbol,
    needParse == null ? void 0 : needParse.reduce_only,
    needParse == null ? void 0 : needParse.side,
    needParse == null ? void 0 : needParse.visible_quantity,
    quoteDP,
    baseDP
  ]);
  const isAlgoOrder = (parsedData == null ? void 0 : parsedData.order_type) === OrderType.STOP_LIMIT || (parsedData == null ? void 0 : parsedData.order_type) === OrderType.STOP_MARKET || (parsedData == null ? void 0 : parsedData.order_type) === OrderType.CLOSE_POSITION;
  const [doCreateOrder, { isMutating }] = useMutation(
    isAlgoOrder ? "/v1/algo/order" : "/v1/order"
  );
  const createOrder = (values2) => {
    if (!values2.symbol) {
      throw new SDKError("Symbol is error");
    }
    if (!values2.side) {
      throw new SDKError("Order side is error");
    }
    if (!values2 || typeof values2.order_type === "undefined") {
      throw new SDKError("Order type is error");
    }
    const orderCreator = OrderFactory.create(
      // @ts-ignore
      values2.order_type_ext ? values2.order_type_ext : values2.order_type
    );
    if (!orderCreator) {
      return Promise.reject(new SDKError("Order creator is null"));
    }
    return new Promise((resolve, reject) => {
      return orderCreator.validate(values2, {
        symbol: symbolInfo[symbol](),
        // token: tokenInfo[symbol](),
        maxQty: maxQty2,
        markPrice
      }).then((errors2) => {
        var _a3, _b2;
        submitted.current = true;
        if (errors2.order_price || errors2.order_quantity || errors2.trigger_price || errors2.total) {
          setErrors(errors2);
          reject(
            ((_a3 = errors2.order_price) == null ? void 0 : _a3.message) || ((_b2 = errors2.order_quantity) == null ? void 0 : _b2.message)
          );
        } else {
          const data = orderCreator.create(values2, {
            symbol: symbolInfo[symbol](),
            maxQty: maxQty2,
            markPrice
          });
          return doCreateOrder(
            omit(["order_type_ext"], {
              // ...values,
              // ...omit(["order_price"], values),
              ...data
            })
          ).then((res) => {
            if (res && res.success) {
              resolve(res.data);
            } else {
              reject(res);
            }
          }, reject);
        }
      });
    });
  };
  const onSubmit = (values2) => {
    if (typeof reduceOnly === "boolean" && reduceOnly && !values2.reduce_only) {
      return Promise.reject(
        new SDKError(
          "The reduceOny parameter of hook does not match your order data"
        )
      );
    }
    return createOrder({
      ...values2,
      symbol
    });
  };
  const submit = useCallback(() => {
    if (!parsedData) {
      throw new SDKError("Function is not supported, please use onSubmit()");
    }
    return createOrder(parsedData);
  }, [parsedData]);
  const calculate = useCallback(
    (values2, field, value) => {
      const fieldHandler = getCalculateHandler(field);
      const newValues = compose(
        head,
        orderEntityFormatHandle(),
        fieldHandler,
        baseInputHandle
      )([
        values2,
        field,
        value,
        markPrice,
        { base_dp: baseDP, quote_dp: quoteDP }
      ]);
      return newValues;
    },
    [markPrice]
  );
  const validator = (values2) => {
    const creator = OrderFactory.create(values2.order_type);
    return creator == null ? void 0 : creator.validate(values2, {
      symbol: symbolInfo[symbol](),
      // token: tokenInfo[symbol](),
      maxQty: maxQty2,
      markPrice
    });
  };
  const formattedOrder = useMemo(() => {
    var _a3;
    if (!parsedData) {
      return notSupportData.current;
    }
    if (!prevOrderData.current) {
      prevOrderData.current = parsedData;
      orderDataCache.current = {
        ...parsedData,
        total: ""
      };
      return orderDataCache.current;
    }
    const item = diffOrderEntry(prevOrderData.current, parsedData);
    if (!item) {
      return orderDataCache.current;
    }
    if (typeof parsedData.order_price !== "undefined") {
      fieldDirty.current.order_price = true;
    }
    if (typeof parsedData.order_quantity !== "undefined") {
      fieldDirty.current.order_quantity = true;
    }
    const values2 = calculate(parsedData, item.key, item.value);
    values2.isStopOrder = ((_a3 = values2.order_type) == null ? void 0 : _a3.startsWith("STOP")) || false;
    values2.total = values2.total || "";
    prevOrderData.current = parsedData;
    orderDataCache.current = values2;
    return values2;
  }, [parsedData, markPrice]);
  useEffect(() => {
    var _a3;
    if (!markPrice || symbolInfo.isNil)
      return;
    (_a3 = validator(formattedOrder)) == null ? void 0 : _a3.then((err) => {
      setErrors(err);
    }).catch((err) => {
    });
  }, [
    formattedOrder.broker_id,
    formattedOrder.order_quantity,
    formattedOrder.total,
    formattedOrder.trigger_price,
    formattedOrder.order_type,
    markPrice
  ]);
  useEffect(() => {
    if (isNewVersion) {
      if (!(optionsValue == null ? void 0 : optionsValue.watchOrderbook)) {
        throw new SDKError(
          "In order to calculate the estimated liquidation price, the `options.watchOrderbook` parameter must be set to true."
        );
      }
    } else {
      if (!(optionsValue == null ? void 0 : optionsValue.watchOrderbook)) {
        return;
      }
    }
    ee2.on("orderbook:update", onOrderBookUpdate);
    return () => {
      ee2.off("orderbook:update", onOrderBookUpdate);
    };
  }, [optionsValue == null ? void 0 : optionsValue.watchOrderbook]);
  useEffect(() => {
    askAndBid.current = [];
  }, [parsedData == null ? void 0 : parsedData.symbol]);
  const getPriceAndQty2 = (symbolOrOrder2) => {
    let quantity = Number(symbolOrOrder2.order_quantity);
    const orderPrice = Number(symbolOrOrder2.order_price);
    if (isNaN(quantity) || quantity <= 0) {
      return null;
    }
    if ((symbolOrOrder2.order_type === OrderType.LIMIT || symbolOrOrder2.order_type === OrderType.STOP_LIMIT) && isNaN(orderPrice))
      return null;
    let price;
    if (symbolOrOrder2.order_type === OrderType.MARKET || symbolOrOrder2.order_type === OrderType.STOP_MARKET) {
      if (symbolOrOrder2.side === OrderSide.BUY) {
        price = askAndBid.current[0];
      } else {
        price = askAndBid.current[1];
      }
    } else {
      if (symbolOrOrder2.side === OrderSide.BUY) {
        if (orderPrice >= askAndBid.current[0]) {
          price = askAndBid.current[0];
        } else {
          price = orderPrice;
        }
      } else {
        if (orderPrice <= askAndBid.current[1]) {
          price = askAndBid.current[1];
        } else {
          price = orderPrice;
        }
      }
    }
    if (symbolOrOrder2.side === OrderSide.SELL) {
      quantity = -quantity;
    }
    return { price, quantity };
  };
  const estLiqPrice2 = useMemo(() => {
    if (!accountInfo || !parsedData || !markPrice)
      return null;
    const result = getPriceAndQty2(formattedOrder);
    if (result === null)
      return null;
    const { price, quantity } = result;
    if (!price || !quantity)
      return null;
    const orderFee2 = order_exports.orderFee({
      qty: quantity,
      price,
      futuresTakeFeeRate: Number(accountInfo["futures_taker_fee_rate"]) / 1e4
    });
    const liqPrice2 = order_exports.estLiqPrice({
      markPrice,
      baseIMR,
      baseMMR,
      totalCollateral: totalCollateral2,
      positions: positions2 == null ? [] : positions2,
      IMR_Factor: accountInfo["imr_factor"][symbol],
      orderFee: orderFee2,
      newOrder: {
        qty: quantity,
        price,
        symbol: parsedData.symbol
      }
    });
    if (liqPrice2 <= 0)
      return null;
    return liqPrice2;
  }, [
    markPrice,
    baseIMR,
    baseMMR,
    totalCollateral2,
    formattedOrder == null ? void 0 : formattedOrder.order_price,
    formattedOrder == null ? void 0 : formattedOrder.order_quantity,
    formattedOrder == null ? void 0 : formattedOrder.total,
    formattedOrder == null ? void 0 : formattedOrder.trigger_price,
    accountInfo
  ]);
  const estLeverage2 = useMemo(() => {
    if (!accountInfo || !parsedData)
      return null;
    const result = getPriceAndQty2(formattedOrder);
    if (result === null || !result.price || !result.quantity)
      return null;
    const leverage = order_exports.estLeverage({
      totalCollateral: totalCollateral2,
      positions: positions2 === null ? [] : positions2,
      newOrder: {
        symbol: parsedData.symbol,
        qty: result.quantity,
        price: result.price
      }
    });
    return leverage;
  }, [
    baseIMR,
    baseMMR,
    totalCollateral2,
    positions2,
    formattedOrder == null ? void 0 : formattedOrder.order_price,
    formattedOrder == null ? void 0 : formattedOrder.order_quantity,
    formattedOrder == null ? void 0 : formattedOrder.total,
    formattedOrder == null ? void 0 : formattedOrder.trigger_price
  ]);
  return {
    maxQty: maxQty2,
    freeCollateral: freeCollateral2,
    markPrice,
    onSubmit,
    submit,
    submitting: isMutating,
    formattedOrder,
    // errors,
    estLiqPrice: estLiqPrice2,
    estLeverage: estLeverage2,
    helper: {
      //@ts-ignore
      calculate,
      validator
      // clearErrors,
    },
    metaState: {
      dirty: fieldDirty.current,
      submitted: submitted.current,
      errors
    },
    symbolConfig: symbolInfo[symbol]()
  };
}
function useMediaQuery(query) {
  const getMatches = (query2) => {
    if (typeof window !== "undefined") {
      return window.matchMedia(query2).matches;
    }
    return false;
  };
  const [matches, setMatches] = useState(getMatches(query));
  function handleChange() {
    setMatches(getMatches(query));
  }
  useEffect(() => {
    var _a3;
    const matchMedia = window == null ? void 0 : window.matchMedia(query);
    handleChange();
    if (matchMedia == null ? void 0 : matchMedia.addListener) {
      matchMedia == null ? void 0 : matchMedia.addListener(handleChange);
    } else {
      (_a3 = matchMedia == null ? void 0 : matchMedia.addEventListener) == null ? void 0 : _a3.call(matchMedia, "change", handleChange);
    }
    return () => {
      var _a4;
      if (matchMedia == null ? void 0 : matchMedia.removeListener) {
        matchMedia == null ? void 0 : matchMedia.removeListener(handleChange);
      } else {
        (_a4 = matchMedia == null ? void 0 : matchMedia.removeEventListener) == null ? void 0 : _a4.call(matchMedia, "change", handleChange);
      }
    };
  }, [query]);
  return matches;
}
var BasePaint = class {
  constructor(ctx, painter) {
    this.ctx = ctx;
    this.painter = painter;
  }
};
var BackgroundPaint = class extends BasePaint {
  constructor() {
    super(...arguments);
    this.img = null;
  }
  async draw(options) {
    if (typeof options.backgroundImg !== "undefined" && options.backgroundImg !== "") {
      return this._drawImage(options);
    } else if (typeof options.backgroundColor !== "undefined") {
      return this._drawColor(options);
    }
  }
  _drawColor(options) {
    this.ctx.fillStyle = options.backgroundColor || "black";
    this.ctx.fillRect(
      0,
      0,
      this.painter.width * this.painter.ratio,
      this.painter.height * this.painter.ratio
    );
  }
  async _drawImage(options) {
    return this.loadImg(options.backgroundImg).then((img) => {
      this.img = img;
      this.ctx.drawImage(
        this.img,
        0,
        0,
        this.painter.width * this.painter.ratio,
        this.painter.height * this.painter.ratio
      );
    });
  }
  loadImg(url) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.crossOrigin = "anonymous";
      img.onload = () => {
        resolve(img);
      };
      img.onerror = (e2) => {
        reject(e2);
      };
      img.src = url;
    });
  }
};
var qrPaint = (ctx, options) => {
  const { size, left, top, data, padding: padding2 } = options;
  const qr2 = qrcode(data);
  const canvas = document.createElement("canvas");
  canvas.width = size;
  canvas.height = size;
  const ctx2 = canvas.getContext("2d");
  const cells = qr2.modules;
  if (!cells) {
    return;
  }
  const tileW = size / cells.length;
  const tileH = size / cells.length;
  for (let r3 = 0; r3 < cells.length; ++r3) {
    const row = cells[r3];
    for (let c = 0; c < row.length; ++c) {
      ctx2.fillStyle = row[c] ? "#000" : "#fff";
      const w4 = Math.ceil((c + 1) * tileW) - Math.floor(c * tileW);
      const h2 = Math.ceil((r3 + 1) * tileH) - Math.floor(r3 * tileH);
      ctx2.fillRect(Math.round(c * tileW), Math.round(r3 * tileH), w4, h2);
    }
  }
  ctx.save();
  ctx.fillStyle = "#fff";
  ctx.fillRect(
    left - padding2,
    top - padding2,
    size + padding2 * 2,
    size + padding2 * 2
  );
  ctx.restore();
  ctx.drawImage(canvas, left, top, size, size);
};
var DataPaint = class extends BasePaint {
  constructor() {
    super(...arguments);
    this.positionInfoCellWidth = 90;
    this.DEFAULT_PROFIT_COLOR = "rgb(0,181,159)";
    this.DEFAULT_LOSS_COLOR = "rgb(255,103,194)";
    this.transformTop = 0;
    this.QRCODE_SIZE = 56;
  }
  async draw(options) {
    var _a3, _b2, _c2, _d3, _e3, _f2, _g2, _h2, _i3, _j2;
    const needDrawDetails = Array.isArray((_b2 = (_a3 = options.data) == null ? void 0 : _a3.position) == null ? void 0 : _b2.informations) && (((_e3 = (_d3 = (_c2 = options.data) == null ? void 0 : _c2.position) == null ? void 0 : _d3.informations) == null ? void 0 : _e3.length) ?? 0) > 0;
    const hasReferral = this.hasReferral(options);
    this.transformTop = 0;
    const offsetTop = 0;
    if (!!((_f2 = options.data) == null ? void 0 : _f2.message)) {
      this.drawMessage(options);
    }
    if (!!((_g2 = options.data) == null ? void 0 : _g2.position)) {
      this.drawPosition(
        options,
        needDrawDetails || hasReferral ? 0 : offsetTop
      );
    }
    if (needDrawDetails) {
      this.drawInformations(options);
    }
    this.drawUnrealizedPnL(
      options,
      needDrawDetails || hasReferral ? 0 : offsetTop
    );
    if (!hasReferral) {
      if (!!((_h2 = options.data) == null ? void 0 : _h2.domain)) {
        this.drawDomainUrl(options);
      }
      if (typeof ((_i3 = options.data) == null ? void 0 : _i3.updateTime) !== "undefined") {
        this.drawPositionTime(options);
      }
    }
    if (typeof ((_j2 = options.data) == null ? void 0 : _j2.referral) !== "undefined") {
      this.drawReferralCode(options);
    }
  }
  drawMessage(options) {
    var _a3;
    const layout = path(
      ["layout", "message"],
      options
    );
    const { position } = layout;
    this._drawText(`"${(_a3 = options.data) == null ? void 0 : _a3.message}"`, {
      color: layout.color,
      fontSize: this._ratio(layout.fontSize),
      top: this._ratio(position.top),
      left: this._ratio(position.left),
      textBaseline: "top",
      fontFamily: options.fontFamily
    });
  }
  drawPosition(options, offsetTop = 0) {
    var _a3, _b2, _c2, _d3, _e3, _f2;
    const layout = path(
      ["layout", "position"],
      options
    );
    const { position, fontSize = 14 } = layout;
    let left = this._ratio(position.left);
    let top = layout.position.top + offsetTop + this.transformTop;
    let prevElementBoundingBox = {};
    if (typeof ((_a3 = options.data) == null ? void 0 : _a3.position.side) !== "undefined") {
      prevElementBoundingBox = this._drawText(options.data.position.side, {
        color: ((_b2 = options.data) == null ? void 0 : _b2.position.side.toUpperCase()) === "LONG" ? options.profitColor || this.DEFAULT_PROFIT_COLOR : options.lossColor || this.DEFAULT_LOSS_COLOR,
        left,
        top: this._ratio(top),
        fontSize: this._ratio(fontSize),
        fontFamily: options.fontFamily
      });
    }
    if (typeof ((_c2 = options.data) == null ? void 0 : _c2.position.symbol) !== "undefined") {
      left += (prevElementBoundingBox.width ?? 0) + this._ratio(7);
      if (prevElementBoundingBox.width) {
        prevElementBoundingBox = this._drawText("|", {
          color: "rgba(255,255,255,0.2)",
          left,
          top: this._ratio(top),
          fontSize: this._ratio(fontSize),
          fontFamily: options.fontFamily
        });
      }
      left += (prevElementBoundingBox.width ?? 0) + this._ratio(7);
      prevElementBoundingBox = this._drawText((_d3 = options.data) == null ? void 0 : _d3.position.symbol, {
        color: layout.color,
        left,
        top: this._ratio(top),
        fontSize: this._ratio(fontSize),
        fontFamily: options.fontFamily
      });
    }
    if (typeof ((_e3 = options.data) == null ? void 0 : _e3.position.leverage) !== "undefined") {
      left += (prevElementBoundingBox.width ?? 0) + this._ratio(7);
      if (prevElementBoundingBox.width) {
        prevElementBoundingBox = this._drawText("|", {
          color: "rgba(255,255,255,0.2)",
          left,
          top: this._ratio(top),
          fontSize: this._ratio(fontSize),
          fontFamily: options.fontFamily
        });
      }
      left += (prevElementBoundingBox.width ?? 0) + this._ratio(7);
      prevElementBoundingBox = this._drawText(
        `${(_f2 = options.data) == null ? void 0 : _f2.position.leverage}X`,
        {
          color: layout.color,
          left,
          top: this._ratio(top),
          fontSize: this._ratio(fontSize),
          fontFamily: options.fontFamily
        }
      );
    }
  }
  drawUnrealizedPnL(options, offsetTop = 0) {
    var _a3, _b2, _c2, _d3, _e3, _f2, _g2;
    const layout = path(
      ["layout", "unrealizedPnl"],
      options
    );
    const { position } = layout;
    let left = this._ratio(position.left);
    let prevElementBoundingBox = {};
    const top = (position.top ?? 0) + offsetTop + this.transformTop;
    if (typeof ((_a3 = options.data) == null ? void 0 : _a3.position.ROI) !== "undefined") {
      const prefix = ((_b2 = options.data) == null ? void 0 : _b2.position.ROI) > 0 ? "+" : "";
      prevElementBoundingBox = this._drawText(
        `${prefix}${d$2((_c2 = options.data) == null ? void 0 : _c2.position.ROI)}%`,
        {
          color: prefix === "+" ? options.profitColor || this.DEFAULT_PROFIT_COLOR : options.lossColor || this.DEFAULT_LOSS_COLOR,
          left,
          top: this._ratio(top),
          fontSize: this._ratio(layout.fontSize),
          fontWeight: 700,
          fontFamily: options.fontFamily
        }
      );
    }
    if (typeof ((_d3 = options.data) == null ? void 0 : _d3.position.pnl) !== "undefined") {
      const prefix = ((_e3 = options.data) == null ? void 0 : _e3.position.pnl) >= 0 ? "+" : "";
      let text = `${prefix}${d$2((_f2 = options.data) == null ? void 0 : _f2.position.pnl)} ${(_g2 = options.data) == null ? void 0 : _g2.position.currency}`;
      let fontWeight = 600;
      if (prevElementBoundingBox.width) {
        left += (prevElementBoundingBox.width ?? 0) + this._ratio(8);
        text = `(${text})`;
      } else {
        left = this._ratio(position.left);
        fontWeight = 700;
      }
      const color = typeof options.data.position.ROI === "undefined" ? prefix === "+" ? options.profitColor || this.DEFAULT_PROFIT_COLOR : options.lossColor || this.DEFAULT_LOSS_COLOR : layout.secondaryColor;
      const fontSize = typeof options.data.position.ROI === "undefined" ? this._ratio(layout.fontSize) : this._ratio(layout.secondaryFontSize);
      prevElementBoundingBox = this._drawText(text, {
        color,
        left,
        top: this._ratio(top),
        fontSize,
        fontWeight,
        fontFamily: options.fontFamily
      });
    }
  }
  drawInformations(options) {
    var _a3, _b2, _c2;
    const layout = path(
      ["layout", "informations"],
      options
    );
    const { position } = layout;
    const informations = ((_b2 = (_a3 = options.data) == null ? void 0 : _a3.position) == null ? void 0 : _b2.informations) || [];
    (((_c2 = options.data) == null ? void 0 : _c2.position.informations.length) ?? 0) === 2;
    const col = informations.length > 4 ? 3 : 2;
    informations.forEach((info, index) => {
      let left = position.left + index % col * this.positionInfoCellWidth;
      let top = position.top + Math.floor(index / col) * 38 + this.transformTop;
      this._drawText(info.title, {
        left: this._ratio(left),
        top: this._ratio(top),
        fontSize: this._ratio(10),
        color: layout.labelColor,
        fontFamily: options.fontFamily
      });
      this._drawText(info.value, {
        left: this._ratio(left),
        top: this._ratio(top + 17),
        fontSize: this._ratio(layout.fontSize),
        fontWeight: 500,
        color: layout.color,
        fontFamily: options.fontFamily
      });
    });
  }
  drawDomainUrl(options, onlyMeasure = false) {
    var _a3;
    const layout = path(
      ["layout", "domain"],
      options
    );
    const hasReferral = this.hasReferral(options);
    const { position } = layout;
    const top = this.painter.height - position.bottom;
    return this._drawText(
      (_a3 = options.data) == null ? void 0 : _a3.domain,
      {
        left: !hasReferral ? this._ratio(position.left) : this._ratio(this.painter.width - 20),
        top: !hasReferral ? this._ratio(top) : this._ratio(this.painter.height - 16),
        fontSize: this._ratio(layout.fontSize),
        color: options.brandColor ?? this.DEFAULT_PROFIT_COLOR,
        fontFamily: options.fontFamily,
        textBaseline: layout.textBaseline,
        textAlign: !hasReferral ? layout.textAlign : "end",
        fontWeight: 600
      },
      onlyMeasure
    );
  }
  drawPositionTime(options) {
    var _a3, _b2;
    const layout = path(
      ["layout", "updateTime"],
      options
    );
    const { position } = layout;
    const hasReferral = this.hasReferral(options);
    let top = this.painter.height - position.bottom;
    let left = this._ratio(position.left);
    if (hasReferral) {
      const metrics = this.drawDomainUrl(options, true);
      left = this._ratio(this.painter.width) - metrics.width - this._ratio(8 + position.left);
      top = this.painter.height - position.bottom;
    }
    this._drawText(
      !hasReferral ? (_a3 = options.data) == null ? void 0 : _a3.updateTime : `Share on ${(_b2 = options.data) == null ? void 0 : _b2.updateTime}   |`,
      {
        left,
        top: this._ratio(top),
        // top: 536,
        fontSize: this._ratio(layout.fontSize),
        color: layout.color,
        // color: "red",
        textAlign: !hasReferral ? layout.textAlign : "end",
        fontFamily: options.fontFamily,
        textBaseline: layout.textBaseline
      }
    );
  }
  drawReferralCode(options) {
    var _a3;
    if (!((_a3 = options.data) == null ? void 0 : _a3.referral)) {
      return;
    }
    const layout = path(
      ["layout", "updateTime"],
      options
    );
    const { position } = layout;
    const top = this.painter.height - (position.bottom ?? 0);
    const messageLayout = path(
      ["layout", "message"],
      options
    );
    const url = new URL(options.data.referral.link);
    const searchParams = url.searchParams;
    searchParams.append("ref", options.data.referral.code);
    url.search = searchParams.toString();
    qrPaint(this.ctx, {
      size: this._ratio(this.QRCODE_SIZE),
      padding: this._ratio(2),
      left: this._ratio(position.left),
      top: this._ratio(top - this.QRCODE_SIZE),
      data: `${url.toString()}`
    });
    this._drawText(options.data.referral.slogan, {
      left: this._ratio(position.left + 66),
      top: this._ratio(top - this.QRCODE_SIZE),
      fontSize: this._ratio(14),
      color: options.brandColor ?? this.DEFAULT_PROFIT_COLOR,
      fontFamily: options.fontFamily,
      textBaseline: "top"
    });
    this._drawText("Referral Code", {
      left: this._ratio(position.left + 66),
      top: this._ratio(top - 29),
      fontSize: this._ratio(12),
      color: layout.color,
      fontFamily: options.fontFamily,
      textBaseline: "middle"
    });
    this._drawText(options.data.referral.code, {
      left: this._ratio(position.left + 66),
      top: this._ratio(top),
      fontSize: this._ratio(16),
      color: messageLayout.color,
      fontFamily: options.fontFamily,
      textBaseline: "bottom"
    });
  }
  _drawText(str, options, onlyMeasure = false) {
    let boundingBox;
    const {
      left = 30,
      top = 30,
      fontSize = 13,
      fontWeight = 500,
      color = "black",
      textBaseline = "middle",
      textAlign = "start"
    } = options ?? {};
    this.ctx.save();
    this.ctx.font = `${fontWeight} ${fontSize}px ${options == null ? void 0 : options.fontFamily}`;
    this.ctx.fillStyle = color;
    this.ctx.textBaseline = textBaseline;
    this.ctx.textAlign = textAlign;
    boundingBox = this.ctx.measureText(str);
    if (!onlyMeasure) {
      this.ctx.fillText(str, left, top);
    }
    this.ctx.restore();
    return boundingBox;
  }
  hasReferral(options) {
    var _a3;
    return typeof ((_a3 = options.data) == null ? void 0 : _a3.referral) !== "undefined";
  }
  _ratio(num) {
    return num * this.painter.ratio;
  }
};
var PosterPainter = class {
  // resourceManager: Resource;
  constructor(canvas, options) {
    this.canvas = canvas;
    this.width = 0;
    this.height = 0;
    this.ctx = this.canvas.getContext("2d");
    this.width = this.canvas.width;
    this.height = this.canvas.height;
    this.ratio = Math.max(
      (options == null ? void 0 : options.ratio) || 1,
      typeof window !== "undefined" ? Math.ceil(window.devicePixelRatio) : 1
    );
    this.canvas.width = this.width * this.ratio;
    this.canvas.height = this.height * this.ratio;
    this.canvas.style.width = this.width + "px";
    this.canvas.style.height = this.height + "px";
  }
  draw(options) {
    requestAnimationFrame(() => this._draw.bind(this)(options));
  }
  async _draw(options) {
    if (this.ctx === null)
      return;
    await new BackgroundPaint(this.ctx, this).draw(options);
    await new DataPaint(this.ctx, this).draw(options);
  }
};
var DefaultLayoutConfig = {
  domain: {
    fontSize: 13,
    // color: undefined,
    textBaseline: "bottom",
    position: {
      left: 20,
      bottom: 32
    }
  },
  message: {
    fontSize: 20,
    color: "rgba(255, 255, 255, 0.98)",
    textBaseline: "top",
    position: {
      left: 20,
      top: 16
    }
  },
  position: {
    fontSize: 14,
    color: "rgba(255,255,255,0.98)",
    position: {
      left: 20,
      top: 70
    }
  },
  unrealizedPnl: {
    fontSize: 36,
    color: "rgba(255,255,255,0.5)",
    secondaryColor: "rgba(255,255,255,0.54)",
    secondaryFontSize: 20,
    position: {
      left: 20,
      top: 110
    }
  },
  informations: {
    fontSize: 12,
    color: "rgba(255, 255, 255, 0.8)",
    labelColor: "rgba(255,255,255,0.36)",
    position: {
      left: 20,
      top: 150
    }
  },
  updateTime: {
    fontSize: 10,
    color: "rgba(255,255,255,0.3)",
    textAlign: "start",
    textBaseline: "bottom",
    position: {
      left: 20,
      bottom: 17
    }
  }
};
var usePoster = (data, options) => {
  const [error, setError] = useState(null);
  const [canCopy, setCanCopy] = useState(
    () => typeof navigator.clipboard !== "undefined"
  );
  const painterRef = useRef(null);
  const [target, setTarget] = useState(null);
  useEffect(() => {
    if (target) {
      if (!painterRef.current) {
        painterRef.current = new PosterPainter(target, {
          ratio: (options == null ? void 0 : options.ratio) || 1,
          ...options
        });
      }
      painterRef.current.draw(
        mergeDeepRight(
          { layout: DefaultLayoutConfig, fontFamily: "Manrope" },
          data
        )
      );
    }
  }, [target, data]);
  const toDataURL = (type, encoderOptions) => {
    if (!target) {
      throw new SDKError("The ref must be a canvas element");
    }
    return target.toDataURL(type, encoderOptions);
  };
  const toBlob = useCallback(
    (type, encoderOptions) => {
      return new Promise((resolve) => {
        if (!target) {
          resolve(null);
          return;
        }
        target.toBlob(resolve, type, encoderOptions);
      });
    },
    [target]
  );
  const ref = (ref2) => {
    if (!ref2)
      return;
    if (ref2.tagName.toUpperCase() !== "CANVAS") {
      setError(new SDKError("The ref must be a canvas element"));
      return;
    }
    setTarget(ref2);
  };
  const download = useCallback(
    (filename, type = "image/png", encoderOptions) => {
      if (!target) {
        throw new SDKError("The ref must be a canvas element");
      }
      const img = new Image();
      img.src = target.toDataURL(type, encoderOptions);
      const link = document.createElement("a");
      link.href = img.src;
      link.download = filename;
      link.click();
    },
    [target]
  );
  const copy2 = useCallback(() => {
    if (!target) {
      throw new SDKError("The ref must be a canvas element");
    }
    return new Promise((resolve, reject) => {
      if (!navigator.clipboard) {
        reject(new SDKError("Clipboard API is not supported"));
        return;
      }
      target.toBlob((blob) => {
        if (!blob) {
          reject(new SDKError("Failed to create blob"));
          return;
        }
        return navigator.clipboard.write([new ClipboardItem({ [blob.type]: blob })]).then(resolve, reject);
      });
    });
  }, [target]);
  return {
    error,
    /**
     * The ref to the canvas element, you should pass this ref to the canvas element
     */
    ref,
    /**
     * Converts the poster to a data URL
     */
    toDataURL,
    /**
     * Converts the poster to a blob
     */
    toBlob,
    /**
     * Downloads the poster as an image
     */
    download,
    /**
     * Browser if supports copy image to clipboard
     */
    canCopy,
    copy: copy2
  };
};
var utils_exports = {};
__export(utils_exports, {
  calcTPSL_ROI: () => calcTPSL_ROI,
  cleanStringStyle: () => cleanStringStyle,
  findPositionTPSLFromOrders: () => findPositionTPSLFromOrders,
  findTPSLFromOrder: () => findTPSLFromOrder,
  findTPSLFromOrders: () => findTPSLFromOrders,
  formatNumber: () => formatNumber,
  getPositionBySymbol: () => getPositionBySymbol,
  priceToPnl: () => priceToPnl
});
var useGetReferralCode = (accountId) => {
  const { data, error, isLoading } = useQuery(
    typeof accountId === "undefined" ? null : `/v1/public/referral/check_ref_code?account_id=${accountId}`
  );
  if (typeof accountId === "undefined") {
    return {
      referral_code: void 0,
      error: "The account id is empty or undefined",
      isLoading: false
    };
  }
  return {
    referral_code: data == null ? void 0 : data.referral_code,
    error,
    isLoading
  };
};
var useReferralInfo = () => {
  const {
    data,
    mutate: mutate3,
    isLoading,
    error
  } = usePrivateQuery("/v1/referral/info", {
    revalidateOnFocus: true
  });
  const isTrader = useMemo(() => {
    var _a3, _b2, _c2;
    if (typeof ((_a3 = data == null ? void 0 : data.referee_info) == null ? void 0 : _a3.referer_code) === "undefined")
      return void 0;
    return (((_c2 = (_b2 = data == null ? void 0 : data.referee_info) == null ? void 0 : _b2.referer_code) == null ? void 0 : _c2.length) || 0) > 0;
  }, [data == null ? void 0 : data.referee_info]);
  const isAffiliate = useMemo(() => {
    var _a3, _b2, _c2;
    if (typeof ((_a3 = data == null ? void 0 : data.referrer_info) == null ? void 0 : _a3.referral_codes) === "undefined")
      return void 0;
    return (((_c2 = (_b2 = data == null ? void 0 : data.referrer_info) == null ? void 0 : _b2.referral_codes) == null ? void 0 : _c2.length) || 0) > 0;
  }, [data == null ? void 0 : data.referrer_info]);
  const [pinCodes] = useLocalStorage("orderly_referral_codes", []);
  const getFirstRefCode = useCallback(() => {
    if (!(data == null ? void 0 : data.referrer_info.referral_codes))
      return void 0;
    const referralCodes = [...data == null ? void 0 : data.referrer_info.referral_codes];
    const pinedItems = [];
    for (let i = 0; i < pinCodes.length; i++) {
      const code = pinCodes[i];
      const index = referralCodes.findIndex((item) => item.code === code);
      if (index !== -1) {
        pinedItems.push({ ...referralCodes[index] });
        referralCodes.splice(index, 1);
      }
    }
    const newCodes = [...pinedItems, ...referralCodes];
    return newCodes == null ? void 0 : newCodes[0];
  }, [pinCodes, data]);
  return {
    data,
    isTrader,
    isAffiliate,
    error,
    isLoading,
    getFirstRefCode
  };
};
var TWType = /* @__PURE__ */ ((TWType2) => {
  TWType2["normal"] = "normal";
  TWType2["mm"] = "mm";
  return TWType2;
})(TWType || {});
var useEpochInfo = (type) => {
  const [curEpochInfo, setCurEpochInfo] = useState(
    void 0
  );
  const path2 = type === "normal" ? "/v1/public/trading_rewards/epoch_info" : "/v1/public/market_making_rewards/epoch_info";
  const {
    data: epochInfo,
    error,
    isLoading,
    mutate: refresh
  } = useQuery(path2, {
    formatter: (res) => {
      if (typeof res === "object" && "rows" in res && "current_epoch" in res) {
        const { rows, current_epoch } = res;
        if (Array.isArray(rows)) {
          const list = rows.map(
            (e2) => e2
          );
          list.sort((a2, b2) => b2.end_time - a2.end_time);
          const curEpochIndex = list == null ? void 0 : list.findIndex(
            (item) => item.epoch_id === current_epoch
          );
          const epochOne = list.find((item) => item.epoch_id === 1);
          if (epochOne && (epochOne == null ? void 0 : epochOne.start_time) > T$1()) {
            setCurEpochInfo(epochOne);
          } else {
            setCurEpochInfo(
              curEpochIndex !== -1 ? list == null ? void 0 : list[curEpochIndex] : void 0
            );
          }
          return list;
        }
      }
      return [];
    }
  });
  const isNotStared = useMemo(() => {
    const epochOne = epochInfo == null ? void 0 : epochInfo.find((item) => item.epoch_id === 1);
    if (epochOne) {
      return epochOne.start_time > T$1();
    }
    return true;
  }, [epochInfo]);
  return [epochInfo, { isLoading, curEpochInfo, isNotStared, refresh }];
};
var useAllBrokers = () => {
  const { data } = useQuery("/v1/public/broker/name", {
    formatter: (res) => {
      const { rows } = res;
      return rows == null ? void 0 : rows.map((item) => ({ [item.broker_id]: item.broker_name })).reduce((acc, curr) => ({ ...acc, ...curr }), {});
    }
  });
  return [data];
};
var useCurEpochEstimate = (type) => {
  const [data, setData] = useState(void 0);
  const { account: account5 } = useAccount();
  const brokers = useAllBrokers();
  const address = account5.address;
  const path2 = type === "normal" ? `/v1/public/trading_rewards/current_epoch_estimate?address=${address}` : `/v1/public/market_making_rewards/current_epoch_estimate?address=${address}`;
  const { data: estimateData } = useQuery(address !== void 0 ? path2 : "", {
    formatter: (res) => {
      var _a3;
      const data2 = {
        ...res,
        rows: ((_a3 = res.rows) == null ? void 0 : _a3.map((item) => ({
          ...item,
          broker_name: item.broker_id
        }))) || [],
        est_trading_volume: (res == null ? void 0 : res.est_maker_volume) || (res == null ? void 0 : res.est_trading_volume)
      };
      return data2;
    }
  });
  const reuslt = useMemo(() => {
    var _a3;
    if (estimateData) {
      const newData = { ...estimateData };
      newData.rows = (_a3 = newData.rows) == null ? void 0 : _a3.map((item) => ({
        ...item,
        broker_name: brokers[item.broker_id] || item.broker_id
      }));
      return newData;
    }
    return data;
  }, [estimateData, brokers]);
  return [reuslt];
};
var orderTokenAbi_default = [
  {
    inputs: [
      {
        internalType: "address",
        name: "target",
        type: "address"
      }
    ],
    name: "AddressEmptyCode",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "AddressInsufficientBalance",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "implementation",
        type: "address"
      }
    ],
    name: "ERC1967InvalidImplementation",
    type: "error"
  },
  {
    inputs: [],
    name: "ERC1967NonPayable",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "allowance",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "needed",
        type: "uint256"
      }
    ],
    name: "ERC20InsufficientAllowance",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "balance",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "needed",
        type: "uint256"
      }
    ],
    name: "ERC20InsufficientBalance",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "approver",
        type: "address"
      }
    ],
    name: "ERC20InvalidApprover",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "receiver",
        type: "address"
      }
    ],
    name: "ERC20InvalidReceiver",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "ERC20InvalidSender",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "spender",
        type: "address"
      }
    ],
    name: "ERC20InvalidSpender",
    type: "error"
  },
  {
    inputs: [],
    name: "EnforcedPause",
    type: "error"
  },
  {
    inputs: [],
    name: "ExpectedPause",
    type: "error"
  },
  {
    inputs: [],
    name: "FailedInnerCall",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidDelegate",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidEndpointCall",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidInitialization",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidLocalDecimals",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "options",
        type: "bytes"
      }
    ],
    name: "InvalidOptions",
    type: "error"
  },
  {
    inputs: [],
    name: "LzTokenUnavailable",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "uint32",
        name: "eid",
        type: "uint32"
      }
    ],
    name: "NoPeer",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "msgValue",
        type: "uint256"
      }
    ],
    name: "NotEnoughNative",
    type: "error"
  },
  {
    inputs: [],
    name: "NotInitializing",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "addr",
        type: "address"
      }
    ],
    name: "OnlyEndpoint",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "uint32",
        name: "eid",
        type: "uint32"
      },
      {
        internalType: "bytes32",
        name: "sender",
        type: "bytes32"
      }
    ],
    name: "OnlyPeer",
    type: "error"
  },
  {
    inputs: [],
    name: "OnlySelf",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "OwnableInvalidOwner",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "OwnableUnauthorizedAccount",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address"
      }
    ],
    name: "SafeERC20FailedOperation",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "result",
        type: "bytes"
      }
    ],
    name: "SimulationResult",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "amountLD",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "minAmountLD",
        type: "uint256"
      }
    ],
    name: "SlippageExceeded",
    type: "error"
  },
  {
    inputs: [],
    name: "UUPSUnauthorizedCallContext",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "slot",
        type: "bytes32"
      }
    ],
    name: "UUPSUnsupportedProxiableUUID",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        components: [
          {
            internalType: "uint32",
            name: "eid",
            type: "uint32"
          },
          {
            internalType: "uint16",
            name: "msgType",
            type: "uint16"
          },
          {
            internalType: "bytes",
            name: "options",
            type: "bytes"
          }
        ],
        indexed: false,
        internalType: "struct EnforcedOptionParam[]",
        name: "_enforcedOptions",
        type: "tuple[]"
      }
    ],
    name: "EnforcedOptionSet",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint64",
        name: "version",
        type: "uint64"
      }
    ],
    name: "Initialized",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "inspector",
        type: "address"
      }
    ],
    name: "MsgInspectorSet",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "guid",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "uint32",
        name: "srcEid",
        type: "uint32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "toAddress",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amountReceivedLD",
        type: "uint256"
      }
    ],
    name: "OFTReceived",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "guid",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "uint32",
        name: "dstEid",
        type: "uint32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "fromAddress",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amountSentLD",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amountReceivedLD",
        type: "uint256"
      }
    ],
    name: "OFTSent",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "previousOwner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnershipTransferred",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "Paused",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint32",
        name: "eid",
        type: "uint32"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "peer",
        type: "bytes32"
      }
    ],
    name: "PeerSet",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "preCrimeAddress",
        type: "address"
      }
    ],
    name: "PreCrimeSet",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "Unpaused",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "implementation",
        type: "address"
      }
    ],
    name: "Upgraded",
    type: "event"
  },
  {
    inputs: [],
    name: "SEND",
    outputs: [
      {
        internalType: "uint16",
        name: "",
        type: "uint16"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "SEND_AND_CALL",
    outputs: [
      {
        internalType: "uint16",
        name: "",
        type: "uint16"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "UPGRADE_INTERFACE_VERSION",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "uint32",
            name: "srcEid",
            type: "uint32"
          },
          {
            internalType: "bytes32",
            name: "sender",
            type: "bytes32"
          },
          {
            internalType: "uint64",
            name: "nonce",
            type: "uint64"
          }
        ],
        internalType: "struct Origin",
        name: "origin",
        type: "tuple"
      }
    ],
    name: "allowInitializePath",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "spender",
        type: "address"
      }
    ],
    name: "allowance",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "approvalRequired",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "approve",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint32",
        name: "_srcEid",
        type: "uint32"
      },
      {
        internalType: "bytes32",
        name: "_sender",
        type: "bytes32"
      },
      {
        internalType: "uint64",
        name: "_nonce",
        type: "uint64"
      },
      {
        internalType: "bytes32",
        name: "_payloadHash",
        type: "bytes32"
      }
    ],
    name: "burnInboundNonce",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "uint32",
            name: "srcEid",
            type: "uint32"
          },
          {
            internalType: "bytes32",
            name: "sender",
            type: "bytes32"
          },
          {
            internalType: "uint64",
            name: "nonce",
            type: "uint64"
          }
        ],
        internalType: "struct Origin",
        name: "_origin",
        type: "tuple"
      },
      {
        internalType: "bytes32",
        name: "_guid",
        type: "bytes32"
      },
      {
        internalType: "bytes",
        name: "_message",
        type: "bytes"
      }
    ],
    name: "clearInboundNonce",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint32",
        name: "_eid",
        type: "uint32"
      },
      {
        internalType: "uint16",
        name: "_msgType",
        type: "uint16"
      },
      {
        internalType: "bytes",
        name: "_extraOptions",
        type: "bytes"
      }
    ],
    name: "combineOptions",
    outputs: [
      {
        internalType: "bytes",
        name: "",
        type: "bytes"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "decimalConversionRate",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "decimals",
    outputs: [
      {
        internalType: "uint8",
        name: "",
        type: "uint8"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "endpoint",
    outputs: [
      {
        internalType: "contract ILayerZeroEndpointV2",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint32",
        name: "eid",
        type: "uint32"
      },
      {
        internalType: "uint16",
        name: "msgType",
        type: "uint16"
      }
    ],
    name: "enforcedOptions",
    outputs: [
      {
        internalType: "bytes",
        name: "enforcedOption",
        type: "bytes"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_lzEndpoint",
        type: "address"
      },
      {
        internalType: "address",
        name: "_delegate",
        type: "address"
      }
    ],
    name: "initialize",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "uint32",
            name: "srcEid",
            type: "uint32"
          },
          {
            internalType: "bytes32",
            name: "sender",
            type: "bytes32"
          },
          {
            internalType: "uint64",
            name: "nonce",
            type: "uint64"
          }
        ],
        internalType: "struct Origin",
        name: "",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "",
        type: "bytes"
      },
      {
        internalType: "address",
        name: "_sender",
        type: "address"
      }
    ],
    name: "isComposeMsgSender",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint32",
        name: "_eid",
        type: "uint32"
      },
      {
        internalType: "bytes32",
        name: "_peer",
        type: "bytes32"
      }
    ],
    name: "isPeer",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "uint32",
            name: "srcEid",
            type: "uint32"
          },
          {
            internalType: "bytes32",
            name: "sender",
            type: "bytes32"
          },
          {
            internalType: "uint64",
            name: "nonce",
            type: "uint64"
          }
        ],
        internalType: "struct Origin",
        name: "_origin",
        type: "tuple"
      },
      {
        internalType: "bytes32",
        name: "_guid",
        type: "bytes32"
      },
      {
        internalType: "bytes",
        name: "_message",
        type: "bytes"
      },
      {
        internalType: "address",
        name: "_executor",
        type: "address"
      },
      {
        internalType: "bytes",
        name: "_extraData",
        type: "bytes"
      }
    ],
    name: "lzReceive",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            components: [
              {
                internalType: "uint32",
                name: "srcEid",
                type: "uint32"
              },
              {
                internalType: "bytes32",
                name: "sender",
                type: "bytes32"
              },
              {
                internalType: "uint64",
                name: "nonce",
                type: "uint64"
              }
            ],
            internalType: "struct Origin",
            name: "origin",
            type: "tuple"
          },
          {
            internalType: "uint32",
            name: "dstEid",
            type: "uint32"
          },
          {
            internalType: "address",
            name: "receiver",
            type: "address"
          },
          {
            internalType: "bytes32",
            name: "guid",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "executor",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "message",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "extraData",
            type: "bytes"
          }
        ],
        internalType: "struct InboundPacket[]",
        name: "_packets",
        type: "tuple[]"
      }
    ],
    name: "lzReceiveAndRevert",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "uint32",
            name: "srcEid",
            type: "uint32"
          },
          {
            internalType: "bytes32",
            name: "sender",
            type: "bytes32"
          },
          {
            internalType: "uint64",
            name: "nonce",
            type: "uint64"
          }
        ],
        internalType: "struct Origin",
        name: "_origin",
        type: "tuple"
      },
      {
        internalType: "bytes32",
        name: "_guid",
        type: "bytes32"
      },
      {
        internalType: "bytes",
        name: "_message",
        type: "bytes"
      },
      {
        internalType: "address",
        name: "_executor",
        type: "address"
      },
      {
        internalType: "bytes",
        name: "_extraData",
        type: "bytes"
      }
    ],
    name: "lzReceiveSimulate",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint32",
        name: "",
        type: "uint32"
      },
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    name: "maxReceivedNonce",
    outputs: [
      {
        internalType: "uint64",
        name: "",
        type: "uint64"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "msgInspector",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "name",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint32",
        name: "_srcEid",
        type: "uint32"
      },
      {
        internalType: "bytes32",
        name: "_sender",
        type: "bytes32"
      }
    ],
    name: "nextNonce",
    outputs: [
      {
        internalType: "uint64",
        name: "",
        type: "uint64"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint32",
        name: "_srcEid",
        type: "uint32"
      },
      {
        internalType: "bytes32",
        name: "_sender",
        type: "bytes32"
      },
      {
        internalType: "uint64",
        name: "_nonce",
        type: "uint64"
      },
      {
        internalType: "bytes32",
        name: "_payloadHash",
        type: "bytes32"
      }
    ],
    name: "nilifyInboundNonce",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "oApp",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "oAppVersion",
    outputs: [
      {
        internalType: "uint64",
        name: "senderVersion",
        type: "uint64"
      },
      {
        internalType: "uint64",
        name: "receiverVersion",
        type: "uint64"
      }
    ],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [],
    name: "oftVersion",
    outputs: [
      {
        internalType: "bytes4",
        name: "interfaceId",
        type: "bytes4"
      },
      {
        internalType: "uint64",
        name: "version",
        type: "uint64"
      }
    ],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [],
    name: "orderedNonce",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "pause",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "paused",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint32",
        name: "eid",
        type: "uint32"
      }
    ],
    name: "peers",
    outputs: [
      {
        internalType: "bytes32",
        name: "peer",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "preCrime",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "proxiableUUID",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "uint32",
            name: "dstEid",
            type: "uint32"
          },
          {
            internalType: "bytes32",
            name: "to",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "amountLD",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "minAmountLD",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "extraOptions",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "composeMsg",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "oftCmd",
            type: "bytes"
          }
        ],
        internalType: "struct SendParam",
        name: "_sendParam",
        type: "tuple"
      }
    ],
    name: "quoteOFT",
    outputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "minAmountLD",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxAmountLD",
            type: "uint256"
          }
        ],
        internalType: "struct OFTLimit",
        name: "oftLimit",
        type: "tuple"
      },
      {
        components: [
          {
            internalType: "int256",
            name: "feeAmountLD",
            type: "int256"
          },
          {
            internalType: "string",
            name: "description",
            type: "string"
          }
        ],
        internalType: "struct OFTFeeDetail[]",
        name: "oftFeeDetails",
        type: "tuple[]"
      },
      {
        components: [
          {
            internalType: "uint256",
            name: "amountSentLD",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "amountReceivedLD",
            type: "uint256"
          }
        ],
        internalType: "struct OFTReceipt",
        name: "oftReceipt",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "uint32",
            name: "dstEid",
            type: "uint32"
          },
          {
            internalType: "bytes32",
            name: "to",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "amountLD",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "minAmountLD",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "extraOptions",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "composeMsg",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "oftCmd",
            type: "bytes"
          }
        ],
        internalType: "struct SendParam",
        name: "_sendParam",
        type: "tuple"
      },
      {
        internalType: "bool",
        name: "_payInLzToken",
        type: "bool"
      }
    ],
    name: "quoteSend",
    outputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "nativeFee",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "lzTokenFee",
            type: "uint256"
          }
        ],
        internalType: "struct MessagingFee",
        name: "msgFee",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "renounceOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "uint32",
            name: "dstEid",
            type: "uint32"
          },
          {
            internalType: "bytes32",
            name: "to",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "amountLD",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "minAmountLD",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "extraOptions",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "composeMsg",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "oftCmd",
            type: "bytes"
          }
        ],
        internalType: "struct SendParam",
        name: "_sendParam",
        type: "tuple"
      },
      {
        components: [
          {
            internalType: "uint256",
            name: "nativeFee",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "lzTokenFee",
            type: "uint256"
          }
        ],
        internalType: "struct MessagingFee",
        name: "_fee",
        type: "tuple"
      },
      {
        internalType: "address",
        name: "_refundAddress",
        type: "address"
      }
    ],
    name: "send",
    outputs: [
      {
        components: [
          {
            internalType: "bytes32",
            name: "guid",
            type: "bytes32"
          },
          {
            internalType: "uint64",
            name: "nonce",
            type: "uint64"
          },
          {
            components: [
              {
                internalType: "uint256",
                name: "nativeFee",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "lzTokenFee",
                type: "uint256"
              }
            ],
            internalType: "struct MessagingFee",
            name: "fee",
            type: "tuple"
          }
        ],
        internalType: "struct MessagingReceipt",
        name: "msgReceipt",
        type: "tuple"
      },
      {
        components: [
          {
            internalType: "uint256",
            name: "amountSentLD",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "amountReceivedLD",
            type: "uint256"
          }
        ],
        internalType: "struct OFTReceipt",
        name: "oftReceipt",
        type: "tuple"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_delegate",
        type: "address"
      }
    ],
    name: "setDelegate",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "uint32",
            name: "eid",
            type: "uint32"
          },
          {
            internalType: "uint16",
            name: "msgType",
            type: "uint16"
          },
          {
            internalType: "bytes",
            name: "options",
            type: "bytes"
          }
        ],
        internalType: "struct EnforcedOptionParam[]",
        name: "_enforcedOptions",
        type: "tuple[]"
      }
    ],
    name: "setEnforcedOptions",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_msgInspector",
        type: "address"
      }
    ],
    name: "setMsgInspector",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bool",
        name: "_orderedNonce",
        type: "bool"
      }
    ],
    name: "setOrderedNonce",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint32",
        name: "_eid",
        type: "uint32"
      },
      {
        internalType: "bytes32",
        name: "_peer",
        type: "bytes32"
      }
    ],
    name: "setPeer",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_preCrime",
        type: "address"
      }
    ],
    name: "setPreCrime",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "sharedDecimals",
    outputs: [
      {
        internalType: "uint8",
        name: "",
        type: "uint8"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint32",
        name: "_srcEid",
        type: "uint32"
      },
      {
        internalType: "bytes32",
        name: "_sender",
        type: "bytes32"
      },
      {
        internalType: "uint64",
        name: "_nonce",
        type: "uint64"
      }
    ],
    name: "skipInboundNonce",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "symbol",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "token",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "totalSupply",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "transfer",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "transferFrom",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "unpause",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newImplementation",
        type: "address"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "upgradeToAndCall",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  }
];
var proxyLedgerAbi_default = [
  { type: "constructor", inputs: [], stateMutability: "nonpayable" },
  { type: "receive", stateMutability: "payable" },
  {
    type: "function",
    name: "DEFAULT_ADMIN_ROLE",
    inputs: [],
    outputs: [{ name: "", type: "bytes32", internalType: "bytes32" }],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "UPGRADE_INTERFACE_VERSION",
    inputs: [],
    outputs: [{ name: "", type: "string", internalType: "string" }],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "_msgPayload",
    inputs: [],
    outputs: [{ name: "", type: "bytes", internalType: "bytes" }],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "_msgReceipt",
    inputs: [],
    outputs: [
      { name: "guid", type: "bytes32", internalType: "bytes32" },
      { name: "nonce", type: "uint64", internalType: "uint64" },
      {
        name: "fee",
        type: "tuple",
        internalType: "struct MessagingFee",
        components: [
          { name: "nativeFee", type: "uint256", internalType: "uint256" },
          { name: "lzTokenFee", type: "uint256", internalType: "uint256" }
        ]
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "_oftReceipt",
    inputs: [],
    outputs: [
      { name: "amountSentLD", type: "uint256", internalType: "uint256" },
      { name: "amountReceivedLD", type: "uint256", internalType: "uint256" }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "_options",
    inputs: [],
    outputs: [{ name: "", type: "bytes", internalType: "bytes" }],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "chainId2Eid",
    inputs: [{ name: "", type: "uint256", internalType: "uint256" }],
    outputs: [{ name: "", type: "uint32", internalType: "uint32" }],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "chainedEventId",
    inputs: [],
    outputs: [{ name: "", type: "uint256", internalType: "uint256" }],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "claimReward",
    inputs: [
      { name: "distributionId", type: "uint32", internalType: "uint32" },
      { name: "cumulativeAmount", type: "uint256", internalType: "uint256" },
      { name: "merkleProof", type: "bytes32[]", internalType: "bytes32[]" }
    ],
    outputs: [],
    stateMutability: "payable"
  },
  {
    type: "function",
    name: "defaultOftGas",
    inputs: [],
    outputs: [{ name: "", type: "uint128", internalType: "uint128" }],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "eid2ChainId",
    inputs: [{ name: "", type: "uint32", internalType: "uint32" }],
    outputs: [{ name: "", type: "uint256", internalType: "uint256" }],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getLzSendReceipt",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "tuple",
        internalType: "struct MessagingReceipt",
        components: [
          { name: "guid", type: "bytes32", internalType: "bytes32" },
          { name: "nonce", type: "uint64", internalType: "uint64" },
          {
            name: "fee",
            type: "tuple",
            internalType: "struct MessagingFee",
            components: [
              { name: "nativeFee", type: "uint256", internalType: "uint256" },
              { name: "lzTokenFee", type: "uint256", internalType: "uint256" }
            ]
          }
        ]
      },
      {
        name: "",
        type: "tuple",
        internalType: "struct OFTReceipt",
        components: [
          { name: "amountSentLD", type: "uint256", internalType: "uint256" },
          { name: "amountReceivedLD", type: "uint256", internalType: "uint256" }
        ]
      },
      { name: "", type: "bytes", internalType: "bytes" },
      { name: "", type: "bytes", internalType: "bytes" }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getRoleAdmin",
    inputs: [{ name: "role", type: "bytes32", internalType: "bytes32" }],
    outputs: [{ name: "", type: "bytes32", internalType: "bytes32" }],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "grantRole",
    inputs: [
      { name: "role", type: "bytes32", internalType: "bytes32" },
      { name: "account", type: "address", internalType: "address" }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "hasRole",
    inputs: [
      { name: "role", type: "bytes32", internalType: "bytes32" },
      { name: "account", type: "address", internalType: "address" }
    ],
    outputs: [{ name: "", type: "bool", internalType: "bool" }],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "initialize",
    inputs: [
      { name: "_oft", type: "address", internalType: "address" },
      { name: "_usdc", type: "address", internalType: "address" },
      { name: "_owner", type: "address", internalType: "address" }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "ledgerAddr",
    inputs: [],
    outputs: [{ name: "", type: "address", internalType: "address" }],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "ledgerChainId",
    inputs: [],
    outputs: [{ name: "", type: "uint256", internalType: "uint256" }],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "lzCompose",
    inputs: [
      { name: "from", type: "address", internalType: "address" },
      { name: "", type: "bytes32", internalType: "bytes32" },
      { name: "_message", type: "bytes", internalType: "bytes" },
      { name: "", type: "address", internalType: "address" },
      { name: "", type: "bytes", internalType: "bytes" }
    ],
    outputs: [],
    stateMutability: "payable"
  },
  {
    type: "function",
    name: "lzEndpoint",
    inputs: [],
    outputs: [{ name: "", type: "address", internalType: "address" }],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "myChainId",
    inputs: [],
    outputs: [{ name: "", type: "uint256", internalType: "uint256" }],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "orderTokenOft",
    inputs: [],
    outputs: [{ name: "", type: "address", internalType: "address" }],
    stateMutability: "view"
  },
  { type: "function", name: "pause", inputs: [], outputs: [], stateMutability: "nonpayable" },
  {
    type: "function",
    name: "paused",
    inputs: [],
    outputs: [{ name: "", type: "bool", internalType: "bool" }],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "payloadType2BackwardFee",
    inputs: [{ name: "", type: "uint8", internalType: "uint8" }],
    outputs: [{ name: "", type: "uint256", internalType: "uint256" }],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "payloadType2DstGas",
    inputs: [{ name: "", type: "uint8", internalType: "uint8" }],
    outputs: [{ name: "", type: "uint128", internalType: "uint128" }],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "proxiableUUID",
    inputs: [],
    outputs: [{ name: "", type: "bytes32", internalType: "bytes32" }],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "quoteClaimReward",
    inputs: [
      { name: "distributionId", type: "uint32", internalType: "uint32" },
      { name: "user", type: "address", internalType: "address" },
      { name: "cumulativeAmount", type: "uint256", internalType: "uint256" },
      { name: "merkleProof", type: "bytes32[]", internalType: "bytes32[]" }
    ],
    outputs: [{ name: "", type: "uint256", internalType: "uint256" }],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "quoteSendUserRequest",
    inputs: [
      { name: "amount", type: "uint256", internalType: "uint256" },
      { name: "user", type: "address", internalType: "address" },
      { name: "payloadType", type: "uint8", internalType: "uint8" }
    ],
    outputs: [{ name: "", type: "uint256", internalType: "uint256" }],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "quoteStakeOrder",
    inputs: [
      { name: "amount", type: "uint256", internalType: "uint256" },
      { name: "sender", type: "address", internalType: "address" }
    ],
    outputs: [{ name: "", type: "uint256", internalType: "uint256" }],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "renounceRole",
    inputs: [
      { name: "role", type: "bytes32", internalType: "bytes32" },
      { name: "callerConfirmation", type: "address", internalType: "address" }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "revokeRole",
    inputs: [
      { name: "role", type: "bytes32", internalType: "bytes32" },
      { name: "account", type: "address", internalType: "address" }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "sendUserRequest",
    inputs: [
      { name: "amount", type: "uint256", internalType: "uint256" },
      { name: "payloadType", type: "uint8", internalType: "uint8" }
    ],
    outputs: [],
    stateMutability: "payable"
  },
  {
    type: "function",
    name: "setChainId2Eid",
    inputs: [
      { name: "chainId", type: "uint256", internalType: "uint256" },
      { name: "eid", type: "uint32", internalType: "uint32" }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setDefaultOftGas",
    inputs: [{ name: "_defaultOftGas", type: "uint128", internalType: "uint128" }],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setLedgerInfo",
    inputs: [
      { name: "_ledgerChainId", type: "uint256", internalType: "uint256" },
      { name: "_ledgerAddr", type: "address", internalType: "address" }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setLzEndpoint",
    inputs: [{ name: "_lzEndpoint", type: "address", internalType: "address" }],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setMyChainId",
    inputs: [{ name: "_myChainId", type: "uint256", internalType: "uint256" }],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setOrderTokenOft",
    inputs: [{ name: "_orderTokenOft", type: "address", internalType: "address" }],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setPayloadType2BackwardFee",
    inputs: [
      { name: "payloadType", type: "uint8", internalType: "uint8" },
      { name: "backwardFee", type: "uint256", internalType: "uint256" }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setPayloadType2DstGas",
    inputs: [
      { name: "payloadType", type: "uint8", internalType: "uint8" },
      { name: "dstGas", type: "uint128", internalType: "uint128" }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "stakeOrder",
    inputs: [{ name: "amount", type: "uint256", internalType: "uint256" }],
    outputs: [],
    stateMutability: "payable"
  },
  {
    type: "function",
    name: "supportsInterface",
    inputs: [{ name: "interfaceId", type: "bytes4", internalType: "bytes4" }],
    outputs: [{ name: "", type: "bool", internalType: "bool" }],
    stateMutability: "view"
  },
  { type: "function", name: "unpause", inputs: [], outputs: [], stateMutability: "nonpayable" },
  {
    type: "function",
    name: "upgradeToAndCall",
    inputs: [
      { name: "newImplementation", type: "address", internalType: "address" },
      { name: "data", type: "bytes", internalType: "bytes" }
    ],
    outputs: [],
    stateMutability: "payable"
  },
  {
    type: "function",
    name: "usdcAddr",
    inputs: [],
    outputs: [{ name: "", type: "address", internalType: "address" }],
    stateMutability: "view"
  },
  {
    type: "event",
    name: "ClaimRewardTokenTransferred",
    inputs: [
      { name: "user", type: "address", indexed: true, internalType: "address" },
      { name: "amount", type: "uint256", indexed: false, internalType: "uint256" }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "ClaimUsdcRevenueTransferred",
    inputs: [
      { name: "user", type: "address", indexed: true, internalType: "address" },
      { name: "amount", type: "uint256", indexed: false, internalType: "uint256" }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "ClaimVestingRequestTransferred",
    inputs: [
      { name: "user", type: "address", indexed: true, internalType: "address" },
      { name: "amount", type: "uint256", indexed: false, internalType: "uint256" }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "Initialized",
    inputs: [{ name: "version", type: "uint64", indexed: false, internalType: "uint64" }],
    anonymous: false
  },
  {
    type: "event",
    name: "Paused",
    inputs: [{ name: "account", type: "address", indexed: false, internalType: "address" }],
    anonymous: false
  },
  {
    type: "event",
    name: "RoleAdminChanged",
    inputs: [
      { name: "role", type: "bytes32", indexed: true, internalType: "bytes32" },
      { name: "previousAdminRole", type: "bytes32", indexed: true, internalType: "bytes32" },
      { name: "newAdminRole", type: "bytes32", indexed: true, internalType: "bytes32" }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "RoleGranted",
    inputs: [
      { name: "role", type: "bytes32", indexed: true, internalType: "bytes32" },
      { name: "account", type: "address", indexed: true, internalType: "address" },
      { name: "sender", type: "address", indexed: true, internalType: "address" }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "RoleRevoked",
    inputs: [
      { name: "role", type: "bytes32", indexed: true, internalType: "bytes32" },
      { name: "account", type: "address", indexed: true, internalType: "address" },
      { name: "sender", type: "address", indexed: true, internalType: "address" }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "Unpaused",
    inputs: [{ name: "account", type: "address", indexed: false, internalType: "address" }],
    anonymous: false
  },
  {
    type: "event",
    name: "Upgraded",
    inputs: [{ name: "implementation", type: "address", indexed: true, internalType: "address" }],
    anonymous: false
  },
  {
    type: "event",
    name: "WithdrawOrderTokenTransferred",
    inputs: [
      { name: "user", type: "address", indexed: true, internalType: "address" },
      { name: "amount", type: "uint256", indexed: false, internalType: "uint256" }
    ],
    anonymous: false
  },
  { type: "error", name: "AccessControlBadConfirmation", inputs: [] },
  {
    type: "error",
    name: "AccessControlUnauthorizedAccount",
    inputs: [
      { name: "account", type: "address", internalType: "address" },
      { name: "neededRole", type: "bytes32", internalType: "bytes32" }
    ]
  },
  { type: "error", name: "AddressEmptyCode", inputs: [{ name: "target", type: "address", internalType: "address" }] },
  { type: "error", name: "AddressInsufficientBalance", inputs: [{ name: "account", type: "address", internalType: "address" }] },
  {
    type: "error",
    name: "ERC1967InvalidImplementation",
    inputs: [{ name: "implementation", type: "address", internalType: "address" }]
  },
  { type: "error", name: "ERC1967NonPayable", inputs: [] },
  { type: "error", name: "EnforcedPause", inputs: [] },
  { type: "error", name: "ExpectedPause", inputs: [] },
  { type: "error", name: "FailedInnerCall", inputs: [] },
  { type: "error", name: "InvalidInitialization", inputs: [] },
  { type: "error", name: "InvalidOptionType", inputs: [{ name: "optionType", type: "uint16", internalType: "uint16" }] },
  { type: "error", name: "NotInitializing", inputs: [] },
  { type: "error", name: "ReentrancyGuardReentrantCall", inputs: [] },
  {
    type: "error",
    name: "SafeCastOverflowedUintDowncast",
    inputs: [
      { name: "bits", type: "uint8", internalType: "uint8" },
      { name: "value", type: "uint256", internalType: "uint256" }
    ]
  },
  { type: "error", name: "SafeERC20FailedOperation", inputs: [{ name: "token", type: "address", internalType: "address" }] },
  { type: "error", name: "UUPSUnauthorizedCallContext", inputs: [] },
  { type: "error", name: "UUPSUnsupportedProxiableUUID", inputs: [{ name: "slot", type: "bytes32", internalType: "bytes32" }] }
];
var OmnichainLedgerV1ABI_default = [
  {
    inputs: [],
    name: "AccessControlBadConfirmation",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        internalType: "bytes32",
        name: "neededRole",
        type: "bytes32"
      }
    ],
    name: "AccessControlUnauthorizedAccount",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "target",
        type: "address"
      }
    ],
    name: "AddressEmptyCode",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "AddressInsufficientBalance",
    type: "error"
  },
  {
    inputs: [],
    name: "AmountIsGreaterThanCollectedValor",
    type: "error"
  },
  {
    inputs: [],
    name: "AmountIsZero",
    type: "error"
  },
  {
    inputs: [],
    name: "BatchIsNotCreatedYet",
    type: "error"
  },
  {
    inputs: [],
    name: "BatchIsNotFinished",
    type: "error"
  },
  {
    inputs: [],
    name: "BatchValorToUsdcRateIsNotFixed",
    type: "error"
  },
  {
    inputs: [],
    name: "CannotUpdateRoot",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "amountEsorderDeposited",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "amountEsorderRequested",
        type: "uint256"
      }
    ],
    name: "DepositNotEnough",
    type: "error"
  },
  {
    inputs: [],
    name: "DistributionAlreadyExists",
    type: "error"
  },
  {
    inputs: [],
    name: "DistributionNotFound",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "implementation",
        type: "address"
      }
    ],
    name: "ERC1967InvalidImplementation",
    type: "error"
  },
  {
    inputs: [],
    name: "ERC1967NonPayable",
    type: "error"
  },
  {
    inputs: [],
    name: "EnforcedPause",
    type: "error"
  },
  {
    inputs: [],
    name: "ExpectedPause",
    type: "error"
  },
  {
    inputs: [],
    name: "FailedInnerCall",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidInitialization",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidMerkleProof",
    type: "error"
  },
  {
    inputs: [],
    name: "NoActiveMerkleRoot",
    type: "error"
  },
  {
    inputs: [],
    name: "NoPendingUnstakeRequest",
    type: "error"
  },
  {
    inputs: [],
    name: "NotInitializing",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "user",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "chainId",
        type: "uint256"
      }
    ],
    name: "NothingToClaim",
    type: "error"
  },
  {
    inputs: [],
    name: "ProposedMerkleRootIsZero",
    type: "error"
  },
  {
    inputs: [],
    name: "RedemptionAmountIsZero",
    type: "error"
  },
  {
    inputs: [],
    name: "ReentrancyGuardReentrantCall",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address"
      }
    ],
    name: "SafeERC20FailedOperation",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "enum LedgerToken",
        name: "token",
        type: "uint8"
      }
    ],
    name: "StakingBalanceInsufficient",
    type: "error"
  },
  {
    inputs: [],
    name: "StartTimestampIsInThePast",
    type: "error"
  },
  {
    inputs: [],
    name: "ThisMerkleRootIsAlreadyProposed",
    type: "error"
  },
  {
    inputs: [],
    name: "TokenIsNotSupportedForDistribution",
    type: "error"
  },
  {
    inputs: [],
    name: "TooEarlyUsdcNetFeeRevenueUpdate",
    type: "error"
  },
  {
    inputs: [],
    name: "UUPSUnauthorizedCallContext",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "slot",
        type: "bytes32"
      }
    ],
    name: "UUPSUnsupportedProxiableUUID",
    type: "error"
  },
  {
    inputs: [],
    name: "UnlockTimeNotPassedYet",
    type: "error"
  },
  {
    inputs: [],
    name: "UnsupportedPayloadType",
    type: "error"
  },
  {
    inputs: [],
    name: "UnsupportedToken",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_user",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_requestId",
        type: "uint256"
      }
    ],
    name: "UserDontHaveVestingRequest",
    type: "error"
  },
  {
    inputs: [],
    name: "ValorPerSecondExceedsMaxValue",
    type: "error"
  },
  {
    inputs: [],
    name: "VestingAmountIsZero",
    type: "error"
  },
  {
    inputs: [],
    name: "VestingLinearPeriodIsZero",
    type: "error"
  },
  {
    inputs: [],
    name: "VestingLockPeriodIsZero",
    type: "error"
  },
  {
    inputs: [],
    name: "VestingLockPeriodNotPassed",
    type: "error"
  },
  {
    inputs: [],
    name: "VestingPeriodIsOutOfRange",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint16",
        name: "batchId",
        type: "uint16"
      }
    ],
    name: "BatchPreparedToClaim",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint16",
        name: "batchId",
        type: "uint16"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "fixedValorToUsdcRate",
        type: "uint256"
      }
    ],
    name: "BatchValorToUsdcRateIsFixed",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "timestamp",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "usdcNetFeeRevenue",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "totalUsdcInTreasure",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "totalValorAmount",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "valorToUsdcRateScaled",
        type: "uint256"
      }
    ],
    name: "DailyUsdcNetFeeRevenueUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "eventId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint32",
        name: "distributionId",
        type: "uint32"
      },
      {
        indexed: false,
        internalType: "enum LedgerToken",
        name: "token",
        type: "uint8"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "merkleRoot",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "startTimestamp",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "ipfsCid",
        type: "bytes"
      }
    ],
    name: "DistributionCreated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "chainedEventId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "chainId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "staker",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "EsOrderUnstake",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint64",
        name: "version",
        type: "uint64"
      }
    ],
    name: "Initialized",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "staker",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "totalUnstakedAmount",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "unlockTimestamp",
        type: "uint256"
      }
    ],
    name: "OrderUnstakeAmount",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "chainedEventId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "chainId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "staker",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "pendingOrderAmount",
        type: "uint256"
      }
    ],
    name: "OrderUnstakeCancelled",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "chainedEventId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "chainId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "staker",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "OrderUnstakeRequested",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "chainedEventId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "chainId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "staker",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "OrderWithdrawn",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "Paused",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "chainedEventId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "chainId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint32",
        name: "distributionId",
        type: "uint32"
      },
      {
        indexed: false,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "enum LedgerToken",
        name: "token",
        type: "uint8"
      }
    ],
    name: "RewardsClaimed",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "previousAdminRole",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "newAdminRole",
        type: "bytes32"
      }
    ],
    name: "RoleAdminChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "RoleGranted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "RoleRevoked",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "eventId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint32",
        name: "distributionId",
        type: "uint32"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "merkleRoot",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "startTimestamp",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "ipfsCid",
        type: "bytes"
      }
    ],
    name: "RootProposed",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "eventId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint32",
        name: "distributionId",
        type: "uint32"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "merkleRoot",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "startTimestamp",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "ipfsCid",
        type: "bytes"
      }
    ],
    name: "RootUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "chainedEventId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "chainId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "staker",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "enum LedgerToken",
        name: "token",
        type: "uint8"
      }
    ],
    name: "Staked",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "Unpaused",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "implementation",
        type: "address"
      }
    ],
    name: "Upgraded",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "chainEventId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "chainId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "user",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "usdcAmount",
        type: "uint256"
      }
    ],
    name: "UsdcRevenueClaimed",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "chainEventId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "chainId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "user",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint16",
        name: "batchId",
        type: "uint16"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "valorAmount",
        type: "uint256"
      }
    ],
    name: "ValorRedeemed",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "chainEventId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "chainId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "user",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "requestId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amountEsorderStakedBack",
        type: "uint256"
      }
    ],
    name: "VestingCanceled",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "chainEventId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "chainId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "user",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "requestId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amountEsorderBurned",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amountOrderVested",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "vestedPeriod",
        type: "uint256"
      }
    ],
    name: "VestingClaimed",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "chainEventId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "chainId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "user",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "requestId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amountEsorderRequested",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "unlockTimestamp",
        type: "uint256"
      }
    ],
    name: "VestingRequested",
    type: "event"
  },
  {
    inputs: [],
    name: "DEFAULT_ADMIN_ROLE",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "ROOT_UPDATER_ROLE",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "TREASURE_UPDATER_ROLE",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "UPGRADE_INTERFACE_VERSION",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "VALOR_TO_USDC_RATE_PRECISION",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "VERSION",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [],
    name: "accValorPerShareScaled",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint16",
        name: "_batchId",
        type: "uint16"
      }
    ],
    name: "batchPreparedToClaim",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    name: "batches",
    outputs: [
      {
        internalType: "bool",
        name: "claimable",
        type: "bool"
      },
      {
        internalType: "uint256",
        name: "redeemedValorAmount",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "fixedValorToUsdcRateScaled",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_user",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_requestId",
        type: "uint256"
      }
    ],
    name: "calculateVestingOrderAmount",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint32",
        name: "_distributionId",
        type: "uint32"
      }
    ],
    name: "canUpdateRoot",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    name: "collectedValor",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint32",
        name: "_distributionId",
        type: "uint32"
      },
      {
        internalType: "enum LedgerToken",
        name: "_token",
        type: "uint8"
      },
      {
        internalType: "bytes32",
        name: "_merkleRoot",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "_startTimestamp",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "_ipfsCid",
        type: "bytes"
      }
    ],
    name: "createDistribution",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_usdcNetFeeRevenue",
        type: "uint256"
      }
    ],
    name: "dailyUsdcNetFeeRevenue",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint16",
        name: "_batchId",
        type: "uint16"
      }
    ],
    name: "fixBatchValorToUsdcRate",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint16",
        name: "_batchId",
        type: "uint16"
      }
    ],
    name: "getBatchChainedValorAmount",
    outputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "chainId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        internalType: "struct Revenue.ChainedAmount[]",
        name: "",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint16",
        name: "_batchId",
        type: "uint16"
      }
    ],
    name: "getBatchInfo",
    outputs: [
      {
        internalType: "uint256",
        name: "batchStartTime",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "batchEndTime",
        type: "uint256"
      },
      {
        internalType: "bool",
        name: "claimable",
        type: "bool"
      },
      {
        internalType: "uint256",
        name: "redeemedValorAmount",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "fixedValorToUsdcRateScaled",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint32",
        name: "_distributionId",
        type: "uint32"
      },
      {
        internalType: "address",
        name: "_user",
        type: "address"
      }
    ],
    name: "getClaimed",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getCurrentBatchId",
    outputs: [
      {
        internalType: "uint16",
        name: "",
        type: "uint16"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint32",
        name: "_distributionId",
        type: "uint32"
      }
    ],
    name: "getDistribution",
    outputs: [
      {
        internalType: "enum LedgerToken",
        name: "token",
        type: "uint8"
      },
      {
        internalType: "bytes32",
        name: "merkleRoot",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "startTimestamp",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "ipfsCid",
        type: "bytes"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_user",
        type: "address"
      }
    ],
    name: "getOrderAvailableToWithdraw",
    outputs: [
      {
        internalType: "uint256",
        name: "orderAmount",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint32",
        name: "_distributionId",
        type: "uint32"
      }
    ],
    name: "getProposedRoot",
    outputs: [
      {
        internalType: "bytes32",
        name: "merkleRoot",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "startTimestamp",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "ipfsCid",
        type: "bytes"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      }
    ],
    name: "getRoleAdmin",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_user",
        type: "address"
      }
    ],
    name: "getStakingInfo",
    outputs: [
      {
        internalType: "uint256",
        name: "orderBalance",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "esOrderBalance",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint16",
        name: "_batchId",
        type: "uint16"
      }
    ],
    name: "getUsdcAmountForBatch",
    outputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "chainId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        internalType: "struct Revenue.ChainedAmount[]",
        name: "chainedUsdcAmount",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_user",
        type: "address"
      },
      {
        internalType: "uint16",
        name: "_batchId",
        type: "uint16"
      },
      {
        internalType: "uint256",
        name: "_chainId",
        type: "uint256"
      }
    ],
    name: "getUserRedeemedValorAmountForBatchAndChain",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_user",
        type: "address"
      }
    ],
    name: "getUserValor",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_user",
        type: "address"
      }
    ],
    name: "getUserVestingRequests",
    outputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "requestId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "esOrderAmount",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "unlockTimestamp",
            type: "uint256"
          }
        ],
        internalType: "struct Vesting.VestingRequest[]",
        name: "",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "grantRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint32",
        name: "_distributionId",
        type: "uint32"
      }
    ],
    name: "hasPendingRoot",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "hasRole",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "_occAdaptor",
        type: "address"
      },
      {
        internalType: "address",
        name: "_orderCollector",
        type: "address"
      },
      {
        internalType: "contract IOFT",
        name: "_orderTokenOft",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_valorPerSecond",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "_maximumValorEmission",
        type: "uint256"
      }
    ],
    name: "initialize",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint32",
        name: "_distributionId",
        type: "uint32"
      }
    ],
    name: "isDistributionRecordBased",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "lastUsdcNetFeeRevenueUpdateTimestamp",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "lastValorUpdateTimestamp",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "srcChainId",
            type: "uint256"
          },
          {
            internalType: "enum LedgerToken",
            name: "token",
            type: "uint8"
          },
          {
            internalType: "uint256",
            name: "tokenAmount",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "uint8",
            name: "payloadType",
            type: "uint8"
          },
          {
            internalType: "bytes",
            name: "payload",
            type: "bytes"
          }
        ],
        internalType: "struct OCCVaultMessage",
        name: "message",
        type: "tuple"
      }
    ],
    name: "ledgerRecvFromVault",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "maximumValorEmission",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "occAdaptor",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "orderCollector",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "orderTokenOft",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "pause",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "paused",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint32",
        name: "_distributionId",
        type: "uint32"
      },
      {
        internalType: "bytes32",
        name: "_merkleRoot",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "_startTimestamp",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "_ipfsCid",
        type: "bytes"
      }
    ],
    name: "proposeRoot",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "proxiableUUID",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "callerConfirmation",
        type: "address"
      }
    ],
    name: "renounceRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "revokeRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_occAdaptor",
        type: "address"
      }
    ],
    name: "setOccAdaptor",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_orderCollector",
        type: "address"
      }
    ],
    name: "setOrderCollector",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract IOFT",
        name: "_orderTokenOft",
        type: "address"
      }
    ],
    name: "setOrderTokenOft",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_valorPerSecond",
        type: "uint256"
      }
    ],
    name: "setValorPerSecond",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    name: "srcChainIdToEventId",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "startTimestamp",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "interfaceId",
        type: "bytes4"
      }
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "totalStakedAmount",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "totalUsdcInTreasure",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "totalValorAmount",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "totalValorEmitted",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "unpause",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "unstakeLockPeriod",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint32",
        name: "_distributionId",
        type: "uint32"
      }
    ],
    name: "updateRoot",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "updateValorVars",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newImplementation",
        type: "address"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "upgradeToAndCall",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    name: "userPendingUnstake",
    outputs: [
      {
        internalType: "uint256",
        name: "balanceOrder",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "unlockTimestamp",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_user",
        type: "address"
      }
    ],
    name: "userTotalStakingBalance",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "valorPerSecond",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "valorToUsdcRateScaled",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "vestingLinearPeriod",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "vestingLockPeriod",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];
var ENVType2 = /* @__PURE__ */ ((ENVType3) => {
  ENVType3["prod"] = "prod";
  ENVType3["staging"] = "staging";
  ENVType3["qa"] = "qa";
  ENVType3["dev"] = "dev";
  return ENVType3;
})(ENVType2 || {});
var useGetEnv = () => {
  const { configStore } = useContext(OrderlyContext);
  const env = configStore.get("env");
  const networkId = configStore.get("networkId");
  if (networkId === "mainnet") {
    return "prod";
  }
  if (networkId === "testnet" && env === "prod") {
    return "staging";
  }
  return env ?? "staging";
};
var orderlySepolia = "0x1cB262C876AE47A75Ec354D89766593839681C29";
var arbitrumSepolia = "0x13b2d9219e4afb48c085e60a9cfacbc193a61f43";
function getOrderlyChainRPC(env) {
  if (env === "prod") {
    return "https://rpc.orderly.network";
  }
  return "https://testnet-rpc.orderly.org";
}
var getContractByEnv = (env) => {
  const data = {
    orderTokenAddress: "",
    orderTokenAddressOnEthereum: "",
    orderTokenAbi: orderTokenAbi_default,
    orderlyContract: orderlySepolia,
    orderlyContractABI: OmnichainLedgerV1ABI_default,
    contract: arbitrumSepolia,
    contractABI: proxyLedgerAbi_default,
    orderlyChainRpcUrl: getOrderlyChainRPC(env)
  };
  if (env === "dev") {
    data.orderTokenAddress = "0xe2eB2df1CA9D90c8501049bAEEEf57f111782903";
    data.orderTokenAddressOnEthereum = "0x4cdE8A33afbb7f0F80841d9AE3Ada59fA1413F38";
    data.orderlyContract = "0x741a48F39683c345Ff37A86791537154869C77D4";
    data.contract = "0x0180107E72FB14a22a776913063b8a4081E9dc94";
  }
  if (env === "qa") {
    data.orderTokenAddress = "0x562874e9fcb02Ae6164781EcFb4AeAa169E99B18";
    data.orderTokenAddressOnEthereum = "0x8F7c2c827f0E9248CB5cf81fE732FDa62207F09c";
    data.orderlyContract = "0x871106E5c5f33F6B743990a0b465B61D6cd64714";
    data.contract = "0xB20A18d8A53Ea23A5E8da32465De374f942693D7";
  }
  if (env === "staging") {
    data.orderTokenAddress = "0x5f11B4510BC50EfB82Fb55D7839a46e9b621f8C2";
    data.orderTokenAddressOnEthereum = "0x48465104e96AEE47bdD0E40dD40b1DFE1a66e232";
    data.orderlyContract = "0xAFEabBA48Aa0D33267a4ADf92a63C3E1A1284AB5";
    data.contract = "0x912196EB2583A2f0a18FaD632ee5dB65B8C93EEf";
  }
  if (env === "prod") {
    data.orderTokenAddress = "0x4E200fE2f3eFb977d5fd9c430A41531FB04d97B8";
    data.orderTokenAddressOnEthereum = "0xABD4C63d2616A5201454168269031355f4764337";
    data.orderlyContract = "0x7819704B69a38fD63Cc768134b8410dc08B987D0";
    data.contract = "0xC8A8Ce0Ab010E499ca57477AC031358febCbbF17";
  }
  return data;
};
function toOrder(value) {
  if (value === null || value === BigInt(0)) {
    return value === BigInt(0) ? 0 : void 0;
  }
  const decimalValue = new g$6(value.toString()).div(1e18);
  return Number(decimalValue.toFixed(18));
}
var DistributionId = /* @__PURE__ */ ((DistributionId2) => {
  DistributionId2[DistributionId2["order"] = 0] = "order";
  DistributionId2[DistributionId2["esORder"] = 1] = "esORder";
  DistributionId2[DistributionId2["mmOrder"] = 2] = "mmOrder";
  DistributionId2[DistributionId2["mmEsOrder"] = 3] = "mmEsOrder";
  return DistributionId2;
})(DistributionId || {});
var useGetClaimed = (id2) => {
  const [data, setData] = useState(0);
  const { account: account5 } = useAccount();
  const address = account5.address;
  const env = useGetEnv();
  const refresh = useCallback(() => {
    var _a3;
    const params = getContractByEnv(env);
    if (typeof address === "undefined")
      return;
    (_a3 = account5.walletAdapter) == null ? void 0 : _a3.callOnChain(
      // @ts-ignore
      { public_rpc_url: params.orderlyChainRpcUrl },
      params.orderlyContract,
      "getClaimed",
      [id2, address],
      {
        abi: params.orderlyContractABI
      }
    ).catch((error) => {
      throw error;
    }).then((res) => {
      const resOrder = toOrder(res);
      setData(resOrder);
    }).catch((error) => {
    });
  }, [address, env]);
  useEffect(() => {
    refresh();
  }, [env, id2, address]);
  return [data, { refresh }];
};
var useApiKeyManager = (queryParams) => {
  const { account: account5 } = useAccount();
  const { keyInfo } = queryParams || {};
  const keyInfoPrams = getQueryParamsFromObject(keyInfo);
  const { data, mutate: mutate3, error, isLoading } = usePrivateQuery(
    `/v1/client/key_info${keyInfoPrams.length > 0 ? `?${keyInfoPrams}` : ""}`,
    {
      formatter: (data2) => data2 == null ? void 0 : data2.rows
    }
  );
  const [doIPRestriction] = useMutation(
    "/v1/client/set_orderly_key_ip_restriction",
    "POST"
  );
  const [doRemoveOrderKey] = useMutation(
    "/v1/client/remove_orderly_key",
    "POST"
  );
  const [doResetIPRestriction] = useMutation(
    "/v1/client/reset_orderly_key_ip_restriction",
    "POST"
  );
  const setIPRestriction = useCallback(
    (orderly_key, ip_restriction_list) => {
      return doIPRestriction({
        orderly_key,
        ip_restriction_list
      });
    },
    []
  );
  const removeOrderlyKey = useCallback((orderly_key) => {
    return doRemoveOrderKey({
      orderly_key
    });
  }, []);
  const generateOrderlyKey = (scope) => {
    return account5 == null ? void 0 : account5.createApiKey(365, {
      tag: "manualCreated",
      scope
    });
  };
  const resetOrderlyKeyIPRestriction = (orderlyKey, mode2) => {
    return doResetIPRestriction({
      orderly_key: orderlyKey,
      reset_mode: mode2
    });
  };
  return [
    data,
    {
      refresh: mutate3,
      error,
      isLoading,
      generateOrderlyKey,
      setIPRestriction,
      removeOrderlyKey,
      resetOrderlyKeyIPRestriction
    }
  ];
};
function getQueryParamsFromObject(obj) {
  if (typeof obj === "undefined")
    return "";
  const queryParams = new URLSearchParams();
  for (const [key, value] of Object.entries(obj)) {
    if (value !== void 0) {
      if (Array.isArray(value)) {
        value.forEach((item) => {
          queryParams.append(key, item.toString());
        });
      } else {
        queryParams.set(key, value.toString());
      }
    }
  }
  return queryParams.toString();
}
var getCreateOrderUrl = (order) => {
  const isAlgoOrder = (order == null ? void 0 : order.order_type) === OrderType.STOP_LIMIT || (order == null ? void 0 : order.order_type) === OrderType.STOP_MARKET || (order == null ? void 0 : order.order_type) === OrderType.CLOSE_POSITION || order.algo_type && order.algo_type === AlgoOrderRootType.BRACKET || isBracketOrder(order);
  return isAlgoOrder ? "/v1/algo/order" : "/v1/order";
};
var getOrderCreator = (order) => {
  let type;
  if (isBracketOrder(order)) {
    type = `${AlgoOrderRootType.BRACKET}:${order.order_type}`;
  } else if (order.order_type === OrderType.LIMIT) {
    type = order.order_type_ext || order.order_type;
  } else {
    type = order.order_type;
  }
  return OrderFactory.create(type);
};
var tpslFields = [
  "tp_trigger_price",
  "sl_trigger_price",
  "tp_pnl",
  "sl_pnl",
  "tp_offset",
  "sl_offset",
  "tp_offset_percentage",
  "sl_offset_percentage"
];
var isBracketOrder = (order) => {
  return !!order.tp_trigger_price || !!order.sl_trigger_price;
};
var hasTPSL = (order) => {
  return tpslFields.some((field) => !!order[field]);
};
var getPriceAndQty = (symbolOrOrder, askAndBid) => {
  let quantity = Number(symbolOrOrder.order_quantity);
  const orderPrice = Number(symbolOrOrder.order_price);
  if (isNaN(quantity) || quantity <= 0) {
    return null;
  }
  if (askAndBid.length === 0) {
    return null;
  }
  if ((symbolOrOrder.order_type === OrderType.LIMIT || symbolOrOrder.order_type === OrderType.STOP_LIMIT) && isNaN(orderPrice))
    return null;
  let price;
  if (symbolOrOrder.order_type === OrderType.MARKET || symbolOrOrder.order_type === OrderType.STOP_MARKET) {
    if (symbolOrOrder.side === OrderSide.BUY) {
      price = askAndBid[0];
    } else {
      price = askAndBid[1];
    }
  } else {
    if (symbolOrOrder.side === OrderSide.BUY) {
      if (orderPrice >= askAndBid[0]) {
        price = askAndBid[0];
      } else {
        price = orderPrice;
      }
    } else {
      if (orderPrice <= askAndBid[1]) {
        price = askAndBid[1];
      } else {
        price = orderPrice;
      }
    }
  }
  if (symbolOrOrder.side === OrderSide.SELL) {
    quantity = -quantity;
  }
  return { price, quantity };
};
var calcEstLiqPrice = (order$1, askAndBid, inputs) => {
  const result = getPriceAndQty(order$1, askAndBid);
  if (!result)
    return null;
  const { price, quantity } = result;
  if (!price || !quantity)
    return null;
  const {
    symbol,
    baseIMR,
    baseMMR,
    imr_factor,
    markPrice,
    totalCollateral: totalCollateral2,
    futures_taker_fee_rate,
    positions: positions2
  } = inputs;
  const orderFee2 = order_exports.orderFee({
    qty: quantity,
    price,
    futuresTakeFeeRate: Number(futures_taker_fee_rate) / 1e4
  });
  const liqPrice2 = order_exports.estLiqPrice({
    markPrice,
    baseIMR,
    baseMMR,
    totalCollateral: totalCollateral2,
    positions: positions2 == null ? [] : positions2,
    IMR_Factor: imr_factor,
    orderFee: orderFee2,
    newOrder: {
      qty: quantity,
      price,
      symbol
    }
  });
  if (liqPrice2 <= 0)
    return null;
  return liqPrice2;
};
var calcEstLeverage = (order$1, askAndBid, inputs) => {
  const result = getPriceAndQty(order$1, askAndBid);
  const { totalCollateral: totalCollateral2, positions: positions2, symbol } = inputs;
  if (!result)
    return null;
  const { price, quantity } = result;
  if (!price || !quantity)
    return null;
  return order_exports.estLeverage({
    totalCollateral: totalCollateral2,
    positions: positions2,
    newOrder: {
      symbol,
      qty: result.quantity,
      price: result.price
    }
  });
};
function isBBOOrder(options) {
  const { order_type, order_type_ext } = options;
  return order_type === OrderType.LIMIT && [OrderType.ASK, OrderType.BID].includes(order_type_ext);
}
var initialOrderState = {
  order_price: "",
  order_quantity: "",
  trigger_price: "",
  tp_trigger_price: "",
  sl_trigger_price: "",
  tp_pnl: "",
  sl_pnl: "",
  tp_offset_percentage: "",
  sl_offset_percentage: "",
  tp_offset: "",
  sl_offset: "",
  total: ""
  // symbol: "",
};
var useOrderStore = (initialOrder) => {
  const [entry2, setEntry] = useState(initialOrder);
  const [estLeverage2, setEstLeverage] = useState(null);
  const [estLiquidationPrice, setEstLiquidationPrice] = useState(
    null
  );
  const [errors, setErrors] = useState({});
  const updateOrder = (order) => {
    setEntry(
      produce((draft) => {
        return { ...draft, ...order };
      })
      // (prev) => ({ ...prev, ...order })
    );
  };
  const updateOrderByKey = (key, value) => {
    setEntry(
      produce((draft) => {
        draft[key] = value;
      })
    );
  };
  const restoreOrder = (order) => {
    setEntry(produce((draft) => order));
  };
  const updateOrderComputed = (data) => {
    setEstLeverage(data.estLeverage);
    setEstLiquidationPrice(data.estLiquidationPrice);
  };
  const resetOrder = (order) => {
    setEntry(
      produce((draft) => ({
        ...draft,
        ...order ?? initialOrderState
      }))
    );
  };
  const hasTP_SL = () => {
    return typeof entry2.tp_trigger_price !== "undefined" || typeof entry2.sl_trigger_price !== "undefined";
  };
  return {
    entry: entry2,
    estLeverage: estLeverage2,
    estLiquidationPrice,
    errors,
    actions: {
      updateOrder,
      updateOrderByKey,
      restoreOrder,
      updateOrderComputed,
      resetOrder,
      hasTP_SL
    }
  };
};
var useOrderEntryNextInternal = (symbol, options = {}) => {
  const { symbolInfo } = options;
  const initialOrder = {
    side: OrderSide.BUY,
    order_type: OrderType.LIMIT,
    order_price: "",
    symbol,
    ...options.initialOrder
  };
  const { actions: orderEntryActions, entry: orderEntity } = useOrderStore(initialOrder);
  const calculate = useCallback(
    (values2, fieldName, value, markPrice, config2) => {
      const fieldHandler = getCalculateHandler(fieldName);
      const newValues = compose(
        head,
        // orderEntityFormatHandle(baseDP, quoteDP),
        fieldHandler,
        baseInputHandle
      )([values2, fieldName, value, markPrice, config2]);
      return newValues;
    },
    []
  );
  useEffect(() => {
    orderEntryActions.updateOrderByKey("symbol", symbol);
  }, [orderEntryActions, symbol]);
  const setValue = (key, value, additional) => {
    if (!symbolInfo) {
      orderEntryActions.updateOrderByKey(key, value);
      return;
    }
    const { markPrice } = additional ?? { markPrice: 0 };
    let newValues = calculate(
      { ...orderEntity },
      key,
      value,
      markPrice,
      symbolInfo
    );
    if (key === "order_type") {
      if (value === OrderType.MARKET || value === OrderType.STOP_MARKET) {
        newValues = calculate(
          newValues,
          "order_price",
          markPrice,
          markPrice,
          symbolInfo
        );
      }
    }
    if ((key === "order_quantity" || key === "order_price") && hasTPSL(newValues)) {
      newValues = calculateTPSL(key, newValues, markPrice, symbolInfo);
    }
    {
      if (newValues.tp_pnl && newValues.order_quantity) {
        newValues.tp_ROI = calcTPSL_ROI({
          qty: newValues.order_quantity,
          price: newValues.order_price || markPrice,
          pnl: newValues.tp_pnl
        });
      }
      if (newValues.sl_pnl && newValues.order_quantity) {
        newValues.sl_ROI = calcTPSL_ROI({
          qty: newValues.order_quantity,
          price: newValues.order_price || markPrice,
          pnl: newValues.sl_pnl
        });
      }
    }
    orderEntryActions.updateOrder(newValues);
    return newValues;
  };
  const calculateTPSL = (key, newValues, markPrice, symbolInfo2) => {
    if (key === "order_price") {
      if (typeof newValues.tp_pnl !== "undefined") {
        newValues = calculate(
          newValues,
          "tp_pnl",
          newValues.tp_pnl,
          markPrice,
          symbolInfo2
        );
      }
      if (typeof newValues.sl_pnl !== "undefined") {
        newValues = calculate(
          newValues,
          "sl_pnl",
          newValues.sl_pnl,
          markPrice,
          symbolInfo2
        );
      }
    } else {
      if (typeof newValues.tp_trigger_price !== "undefined") {
        newValues = calculate(
          newValues,
          "tp_trigger_price",
          newValues.tp_trigger_price,
          markPrice,
          symbolInfo2
        );
      }
      if (typeof newValues.sl_trigger_price !== "undefined") {
        newValues = calculate(
          newValues,
          "sl_trigger_price",
          newValues.sl_trigger_price,
          markPrice,
          symbolInfo2
        );
      }
    }
    return newValues;
  };
  const setValues = (values2, additional) => {
    if (!symbolInfo) {
      orderEntryActions.updateOrder(values2);
      return;
    }
    let newValues = { ...orderEntity };
    Object.keys(values2).forEach((key) => {
      newValues = calculate(
        newValues,
        key,
        values2[key],
        (additional == null ? void 0 : additional.markPrice) ?? 0,
        symbolInfo
      );
    });
    orderEntryActions.updateOrder(newValues);
    return newValues;
  };
  const onMarkPriceUpdated = useCallback(
    (markPrice, baseOn = []) => {
      if (!options.symbolInfo)
        return;
      let newValues = { ...orderEntity };
      if (baseOn.length === 0) {
        newValues = calculate(
          { ...orderEntity },
          "order_price",
          markPrice,
          markPrice,
          options.symbolInfo
        );
      } else {
        baseOn.forEach((key) => {
          newValues = calculate(
            { ...newValues },
            key,
            orderEntity[key],
            markPrice,
            options.symbolInfo
          );
        });
      }
      if (hasTPSL(newValues)) {
        if (newValues.tp_pnl && newValues.order_quantity) {
          newValues.tp_ROI = calcTPSL_ROI({
            qty: newValues.order_quantity,
            price: newValues.order_price || markPrice,
            pnl: newValues.tp_pnl
          });
        }
        if (newValues.sl_pnl && newValues.order_quantity) {
          newValues.sl_ROI = calcTPSL_ROI({
            qty: newValues.order_quantity,
            price: newValues.order_price || markPrice,
            pnl: newValues.sl_pnl
          });
        }
      }
      orderEntryActions.updateOrder(newValues);
    },
    [calculate, options.symbolInfo, orderEntity, orderEntryActions]
  );
  const validate = (order, creator, options2) => {
    const { markPrice, maxQty: maxQty2 } = options2;
    return creator == null ? void 0 : creator.validate(order, {
      symbol: symbolInfo,
      maxQty: maxQty2,
      markPrice
    });
  };
  const generateOrder = (creator, options2) => {
    const order = creator.create(orderEntity, {
      ...options2,
      symbol: symbolInfo
    });
    return order;
  };
  const submitOrder = useCallback(() => {
  }, [orderEntity]);
  const resetOrder = (order) => {
    orderEntryActions.resetOrder(order);
  };
  return {
    formattedOrder: orderEntity,
    setValue,
    setValues,
    submit: submitOrder,
    reset: resetOrder,
    generateOrder,
    validate,
    onMarkPriceChange: onMarkPriceUpdated
  };
};
var useOrderEntry2 = (symbol, options = {}) => {
  if (!symbol) {
    throw new SDKError("Symbol is required");
  }
  const ee2 = useEventEmitter();
  const { track: track2 } = useTrack();
  const [meta2, setMeta] = useState({
    dirty: {},
    submitted: false,
    validated: false,
    errors: null
  });
  const askAndBid = useRef([[]]);
  const lastChangedField = useRef();
  const lastOrderTypeExt = useRef();
  const lastLevel = useRef();
  const calculateTPSL_baseOn = useRef({
    tp: "",
    sl: ""
  });
  const actions = useMarkPriceActions();
  const symbolConfig = useSymbolsInfo();
  const accountInfo = useAccountInfo();
  const positions2 = usePositions();
  const symbolInfo = symbolConfig[symbol]();
  const markPrice = actions.getMarkPriceBySymbol(symbol);
  const {
    formattedOrder,
    setValue: setValueInternal,
    setValues: setValuesInternal,
    validate,
    generateOrder,
    reset,
    // submit,
    ...orderEntryActions
  } = useOrderEntryNextInternal(symbol, {
    ...options,
    symbolInfo
  });
  const [doCreateOrder, { isMutating }] = useMutation(
    getCreateOrderUrl(formattedOrder)
  );
  const maxQty2 = useMaxQty(
    symbol,
    formattedOrder.side,
    formattedOrder.reduce_only
  );
  const updateOrderPrice = () => {
    var _a3, _b2;
    const order_type = formattedOrder.order_type;
    const order_type_ext = formattedOrder.order_type_ext ?? lastOrderTypeExt.current;
    const level = formattedOrder.level ?? lastLevel.current;
    const isBBO = isBBOOrder({ order_type, order_type_ext });
    if (!isBBO || level === void 0) {
      return;
    }
    lastOrderTypeExt.current = order_type_ext;
    lastLevel.current = level;
    const index = order_type_ext === OrderType.ASK ? 0 : 1;
    const price = (_b2 = (_a3 = askAndBid.current) == null ? void 0 : _a3[level]) == null ? void 0 : _b2[index];
    if (price) {
      setValue("order_price", price, {
        shouldUpdateLastChangedField: false
      });
    }
  };
  const updateOrderPriceByOrderBook = () => {
    const { order_type, order_type_ext } = formattedOrder;
    const isBBO = isBBOOrder({ order_type, order_type_ext });
    if (lastChangedField.current !== "total" && isBBO) {
      updateOrderPrice();
    }
  };
  useEffect(() => {
    updateOrderPrice();
  }, [formattedOrder.order_type_ext, formattedOrder.level]);
  const onOrderBookUpdate = useDebouncedCallback((data) => {
    askAndBid.current = data;
    updateOrderPriceByOrderBook();
  }, 200);
  useEffect(() => {
    ee2.on("orderbook:update", onOrderBookUpdate);
    return () => {
      ee2.off("orderbook:update", onOrderBookUpdate);
    };
  }, []);
  useEffect(() => {
    if ((formattedOrder.order_type === OrderType.MARKET || formattedOrder.order_type === OrderType.STOP_MARKET) && markPrice) {
      const baseOn = /* @__PURE__ */ new Set();
      if (lastChangedField.current) {
        baseOn.add(lastChangedField.current);
      }
      if (calculateTPSL_baseOn.current.tp) {
        baseOn.add(calculateTPSL_baseOn.current.tp);
      }
      if (calculateTPSL_baseOn.current.sl) {
        baseOn.add(calculateTPSL_baseOn.current.sl);
      }
      orderEntryActions.onMarkPriceChange(markPrice, Array.from(baseOn));
    }
  }, [markPrice, formattedOrder.order_type]);
  const prepareData = useCallback(() => {
    return {
      markPrice: actions.getMarkPriceBySymbol(symbol),
      maxQty: maxQty2
    };
  }, [maxQty2, symbol]);
  const interactiveValidate = (order) => {
    validateFunc(order).then((errors) => {
      const keys = Object.keys(errors);
      if (keys.length > 0) {
        setMeta(
          produce((draft) => {
            draft.errors = errors;
          })
        );
      } else {
        setMeta(
          produce((draft) => {
            draft.errors = null;
          })
        );
      }
    });
  };
  const canSetTPSLPrice = (key, value, orderType) => {
    if (tpslFields.includes(key) && value !== "" && value !== void 0 && value !== null && orderType !== OrderType.LIMIT && orderType !== OrderType.MARKET) {
      return false;
    }
    return true;
  };
  const setValue = (key, value, options2) => {
    const { shouldUpdateLastChangedField = true, shouldUpdateDirty = true } = options2 || {};
    if (!canSetTPSLPrice(key, value, formattedOrder.order_type)) {
      return;
    }
    if (shouldUpdateDirty) {
      setMeta(
        produce((draft) => {
          draft.dirty[key] = true;
        })
      );
    }
    const values2 = setValueInternal(key, value, prepareData());
    if (values2) {
      interactiveValidate(values2);
    }
    if (shouldUpdateLastChangedField) {
      if (key.startsWith("tp_")) {
        calculateTPSL_baseOn.current.tp = key;
      } else if (key.startsWith("sl_")) {
        calculateTPSL_baseOn.current.sl = key;
      }
      lastChangedField.current = key;
    }
  };
  const setValues = (values2) => {
    if (!Object.keys(values2).every(
      (key) => canSetTPSLPrice(
        key,
        values2[key],
        formattedOrder.order_type
      )
    )) {
      return;
    }
    const newValues = setValuesInternal(values2, prepareData());
    if (newValues) {
      interactiveValidate(newValues);
    }
  };
  async function validateFunc(order) {
    const creator = getOrderCreator(order);
    return validate(order, creator, prepareData());
  }
  const validateOrder = () => {
    return new Promise(
      async (resolve, reject) => {
        const creator = getOrderCreator(formattedOrder);
        const errors = await validate(formattedOrder, creator, prepareData());
        const keys = Object.keys(errors);
        if (keys.length > 0) {
          setMeta(
            produce((draft) => {
              draft.errors = errors;
            })
          );
          if (!meta2.validated) {
            setMeta(
              produce((draft) => {
                draft.validated = true;
              })
            );
          }
          reject(errors);
        }
        const order = generateOrder(creator, prepareData());
        resolve(order);
      }
    );
  };
  const { freeCollateral: freeCollateral2, totalCollateral: totalCollateral2 } = useCollateral();
  const estLiqPrice2 = useMemo(() => {
    const markPrice2 = actions.getMarkPriceBySymbol(symbol);
    if (!markPrice2 || !accountInfo)
      return null;
    const orderQuantity = Number(formattedOrder.order_quantity);
    if (orderQuantity === 0 || orderQuantity > maxQty2) {
      return null;
    }
    const estLiqPrice22 = calcEstLiqPrice(formattedOrder, askAndBid.current[0], {
      baseIMR: symbolInfo == null ? void 0 : symbolInfo.base_imr,
      baseMMR: symbolInfo == null ? void 0 : symbolInfo.base_mmr,
      markPrice: markPrice2,
      totalCollateral: totalCollateral2,
      futures_taker_fee_rate: accountInfo.futures_taker_fee_rate,
      imr_factor: accountInfo.imr_factor[symbol],
      symbol,
      positions: positions2
    });
    return estLiqPrice22;
  }, [formattedOrder, accountInfo, positions2, totalCollateral2, symbol, maxQty2]);
  const estLeverage2 = useMemo(() => {
    const orderQuantity = Number(formattedOrder.order_quantity);
    if (orderQuantity === 0 || orderQuantity > maxQty2) {
      return null;
    }
    return calcEstLeverage(formattedOrder, askAndBid.current[0], {
      totalCollateral: totalCollateral2,
      positions: positions2,
      symbol
    });
  }, [formattedOrder, accountInfo, positions2, totalCollateral2, symbol, maxQty2]);
  const resetErrors = () => {
    setMeta(
      produce((draft) => {
        draft.errors = null;
      })
    );
  };
  const resetMetaState = () => {
    setMeta(
      produce((draft) => {
        draft.errors = null;
        draft.submitted = false;
        draft.validated = false;
        draft.dirty = {};
      })
    );
  };
  const submitOrder = async (options2) => {
    const creator = getOrderCreator(formattedOrder);
    const errors = await validate(formattedOrder, creator, prepareData());
    const { resetOnSuccess = true } = options2 || {};
    setMeta(
      produce((draft) => {
        draft.submitted = true;
        draft.validated = true;
      })
    );
    if (Object.keys(errors).length > 0) {
      setMeta(
        produce((draft) => {
          draft.errors = errors;
        })
      );
      throw new SDKError("Order validation failed");
    }
    const order = generateOrder(creator, prepareData());
    const result = await doCreateOrder(order);
    if (result.success) {
      track2(TrackerEventName.placeOrderSuccess, {
        side: order.side,
        order_type: order.order_type,
        tp_sl: hasTPSL(formattedOrder),
        symbol: order.symbol
      });
    }
    if (result.success && resetOnSuccess) {
      reset();
      resetMetaState();
    }
    return result;
  };
  return {
    ...orderEntryActions,
    submit: submitOrder,
    reset,
    resetErrors,
    resetMetaState,
    formattedOrder,
    maxQty: maxQty2,
    estLiqPrice: estLiqPrice2,
    estLeverage: estLeverage2,
    helper: {
      /**
       * @deprecated use validate instead
       */
      validator: validateOrder,
      validate: validateOrder
    },
    freeCollateral: freeCollateral2,
    setValue,
    setValues,
    symbolInfo: symbolInfo || {},
    metaState: meta2,
    isMutating,
    markPrice
  };
};
var initialOrderState2 = {
  order_price: "",
  order_quantity: "",
  trigger_price: "",
  tp_trigger_price: "",
  sl_trigger_price: "",
  total: "",
  symbol: ""
};
create()(
  immer((set2, get3) => ({
    entry: {
      side: OrderSide.BUY,
      order_type: OrderType.LIMIT,
      ...initialOrderState2
    },
    estLeverage: null,
    estLiquidationPrice: null,
    errors: {},
    actions: {
      hasTP_SL: () => {
        const order = get3().entry;
        return typeof order.tp_trigger_price !== "undefined" || typeof order.sl_trigger_price !== "undefined";
      },
      updateOrderComputed: (data) => {
        set2(
          (state) => {
            state.estLeverage = data.estLeverage;
            state.estLiquidationPrice = data.estLiquidationPrice;
          },
          false
          // "updateOrderComputed"
        );
      },
      updateOrder: (order) => {
        set2(
          (state) => {
            state.entry = {
              ...state.entry,
              ...order
            };
          },
          false
          // "updateOrder"
        );
      },
      updateOrderByKey: (key, value) => {
        set2(
          (state) => {
            state.entry[key] = value;
          },
          false
          // "updateOrderByKey"
        );
      },
      restoreOrder: (order) => {
        set2(
          (state) => {
            state.entry = order;
          },
          false
          // "restoreOrder"
        );
      },
      resetOrder: (order) => {
        set2(
          (state) => {
            state.entry.order_price = "";
            state.entry.order_quantity = "";
            state.entry.trigger_price = "";
            state.entry.total = "";
            state.entry.tp_trigger_price = "";
            state.entry.tp_pnl = "";
            state.entry.tp_offset = "";
            state.entry.tp_offset_percentage = "";
            state.entry.sl_trigger_price = "";
            state.entry.sl_pnl = "";
            state.entry.sl_offset = "";
            state.entry.sl_offset_percentage = "";
          },
          true
          // "resetOrder"
        );
      }
    }
  }))
);
var useOrderEntity = (order, options) => {
  if (!order.symbol) {
    throw new SDKError("Symbol is required");
  }
  const [errors, setErrors] = useState();
  const maxQty2 = useMaxQty(order.symbol, order.side, order.reduce_only);
  const finalMaxQty = (options == null ? void 0 : options.maxQty) ?? maxQty2;
  const actions = useMarkPriceActions();
  const markPrice = actions.getMarkPriceBySymbol(order.symbol);
  const prepareData = useCallback(() => {
    return {
      markPrice: actions.getMarkPriceBySymbol(order.symbol),
      maxQty: finalMaxQty
    };
  }, [finalMaxQty, order.symbol, order]);
  const symbolInfo = useSymbolsInfo();
  const validate = () => {
    return new Promise(
      async (resolve, reject) => {
        const creator = getOrderCreator(order);
        const _symbol = symbolInfo[order.symbol]();
        const errors2 = await (creator == null ? void 0 : creator.validate(order, {
          symbol: _symbol,
          maxQty: finalMaxQty,
          markPrice
        }));
        const keys = Object.keys(errors2);
        if (keys.length > 0) {
          setErrors(errors2);
          reject(errors2);
        } else {
          setErrors({});
        }
        const orderEntity = creator.create(order, {
          ...prepareData(),
          symbol: _symbol
        });
        resolve(orderEntity);
      }
    );
  };
  const autoCheck = useThrottledCallback(
    () => {
      validate().then(
        () => {
        },
        (reject) => {
        }
      );
    },
    50,
    {}
  );
  useEffect(() => {
    autoCheck();
  }, [order.order_price, order.order_quantity, order.trigger_price]);
  return {
    validate,
    errors,
    markPrice,
    symbolInfo
  };
};
var useRestrictedInfo = (options) => {
  const {
    enableDefault = false,
    customRestrictedIps = [],
    customRestrictedRegions = [],
    content
  } = options || {};
  const apiBaseUrl = useConfig("apiBaseUrl");
  const [invalidWebCity, setInvalidWebCity] = useState([]);
  const [invalidWebCountry, setInvalidWebCountry] = useState([]);
  const [invalidRegions, setInvalidRegions] = useState([]);
  const [allInvalidAreas, setAllInvalidAreas] = useState([]);
  const [city, setCity] = useState("");
  const [region, setRegion] = useState("");
  const [ip, setIp] = useState("");
  const [restrictedOpen, setRestrictedOpen] = useState(false);
  useEffect(() => {
    const fetchData = async () => {
      var _a3, _b2, _c2, _d3, _e3, _f2, _g2, _h2, _i3, _j2, _k2, _l3, _m3;
      try {
        const areaRes = await fetch(`${apiBaseUrl}/v1/restricted_areas`);
        const areaResdata = await areaRes.json();
        const ipRes = await fetch(`${apiBaseUrl}/v1/ip_info`);
        const ipData = await ipRes.json();
        if (areaResdata.success && ipData.success) {
          const invalidCountries = (_c2 = (_b2 = (_a3 = areaResdata == null ? void 0 : areaResdata.data) == null ? void 0 : _a3.invalid_web_country) == null ? void 0 : _b2.toLocaleLowerCase()) == null ? void 0 : _c2.replace(/\s+/g, "").split(",");
          const invalidCities = (_f2 = (_e3 = (_d3 = areaResdata == null ? void 0 : areaResdata.data) == null ? void 0 : _d3.invalid_web_city) == null ? void 0 : _e3.toLocaleLowerCase()) == null ? void 0 : _f2.replace(/\s+/g, "").split(",");
          const combinedInvalidRegions = (enableDefault ? invalidCities.concat(invalidCountries) : []).concat(
            customRestrictedRegions == null ? void 0 : customRestrictedRegions.map(
              (item) => {
                var _a4;
                return (_a4 = item == null ? void 0 : item.replace(/\s+/g, "")) == null ? void 0 : _a4.toLocaleLowerCase();
              }
            )
          );
          const allInvalidAreas2 = [
            enableDefault ? (_g2 = areaResdata == null ? void 0 : areaResdata.data) == null ? void 0 : _g2.invalid_web_country : "",
            enableDefault ? (_h2 = areaResdata == null ? void 0 : areaResdata.data) == null ? void 0 : _h2.invalid_web_city : "",
            customRestrictedRegions == null ? void 0 : customRestrictedRegions.join(", ")
          ].filter((item) => !!item);
          setInvalidWebCity(invalidCities);
          setInvalidWebCountry(invalidCountries);
          setInvalidRegions(combinedInvalidRegions);
          setAllInvalidAreas(allInvalidAreas2);
          const { city: city2, region: region2, ip: ip2 } = ipData.data;
          setCity(city2);
          setRegion(region2);
          setIp(ip2);
          if (combinedInvalidRegions.includes(
            (_j2 = (_i3 = ipData == null ? void 0 : ipData.data) == null ? void 0 : _i3.city) == null ? void 0 : _j2.replace(/\s+/g, "").toLocaleLowerCase()
          ) || combinedInvalidRegions.includes(
            (_l3 = (_k2 = ipData == null ? void 0 : ipData.data) == null ? void 0 : _k2.region) == null ? void 0 : _l3.replace(/\s+/g, "").toLocaleLowerCase()
          ) || customRestrictedIps.includes((_m3 = ipData == null ? void 0 : ipData.data) == null ? void 0 : _m3.ip)) {
            setRestrictedOpen(true);
          }
        }
      } catch (error) {
      }
    };
    fetchData();
  }, [apiBaseUrl]);
  return {
    ip,
    invalidRegions: allInvalidAreas,
    restrictedOpen,
    content
  };
};
var yu = Object.defineProperty;
var vr$4 = (e2, o2) => {
  for (var t in o2) yu(e2, t, { get: o2[t], enumerable: true });
};
var ct$3 = { variants: { gap: { 0: "oui-gap-0", 1: "oui-gap-1", 2: "oui-gap-2", 3: "oui-gap-3", 4: "oui-gap-4", 5: "oui-gap-5", 6: "oui-gap-6", 8: "oui-gap-8", 10: "oui-gap-10" }, gapX: { 0: "oui-gap-x-0", 1: "oui-gap-x-1", 2: "oui-gap-x-2", 3: "oui-gap-x-3", 4: "oui-gap-x-4", 5: "oui-gap-x-5", 6: "oui-gap-x-6", 8: "oui-gap-x-8", 10: "oui-gap-x-10" }, gapY: { 0: "oui-gap-y-0", 1: "oui-gap-y-1", 2: "oui-gap-y-2", 3: "oui-gap-y-3", 4: "oui-gap-y-4", 5: "oui-gap-y-5", 6: "oui-gap-y-6", 8: "oui-gap-y-8", 10: "oui-gap-y-10" } } };
var h$2 = createTV({ twMergeConfig: { prefix: "oui-" } });
var ma$2 = { variants: { p: { 0: "oui-p-0", 1: "oui-p-1", 2: "oui-p-2", 3: "oui-p-3", 4: "oui-p-4", 5: "oui-p-5", 6: "oui-p-6", 7: "oui-p-7", 8: "oui-p-8", 9: "oui-p-9", 10: "oui-p-10" }, px: { 0: "oui-px-0", 1: "oui-px-1", 2: "oui-px-2", 3: "oui-px-3", 4: "oui-px-4", 5: "oui-px-5", 6: "oui-px-6", 7: "oui-px-7", 8: "oui-px-8", 9: "oui-px-9", 10: "oui-px-10" }, py: { 0: "oui-py-0", 1: "oui-py-1", 2: "oui-py-2", 3: "oui-py-3", 4: "oui-py-4", 5: "oui-py-5", 6: "oui-py-6", 7: "oui-py-7", 8: "oui-py-8", 9: "oui-py-9", 10: "oui-py-10" }, pt: { 0: "oui-pt-0", 1: "oui-pt-1", 2: "oui-pt-2", 3: "oui-pt-3", 4: "oui-pt-4", 5: "oui-pt-5", 6: "oui-pt-6", 7: "oui-pt-7", 8: "oui-pt-8", 9: "oui-pt-9", 10: "oui-pt-10" }, pb: { 0: "oui-pb-0", 1: "oui-pb-1", 2: "oui-pb-2", 3: "oui-pb-3", 4: "oui-pb-4", 5: "oui-pb-5", 6: "oui-pb-6", 7: "oui-pb-7", 8: "oui-pb-8", 9: "oui-pb-9", 10: "oui-pb-10" }, pl: { 0: "oui-pl-0", 1: "oui-pl-1", 2: "oui-pl-2", 3: "oui-pl-3", 4: "oui-pl-4", 5: "oui-pl-5", 6: "oui-pl-6", 7: "oui-pl-7", 8: "oui-pl-8", 9: "oui-pl-9", 10: "oui-pl-10" }, pr: { 0: "oui-pr-0", 1: "oui-pr-1", 2: "oui-pr-2", 3: "oui-pr-3", 4: "oui-pr-4", 5: "oui-pr-5", 6: "oui-pr-6", 7: "oui-pr-7", 8: "oui-pr-8", 9: "oui-pr-9", 10: "oui-pr-10" }, m: { 0: "oui-m-0", 1: "oui-m-1", 2: "oui-m-2", 3: "oui-m-3", 4: "oui-m-4", 5: "oui-m-5", 6: "oui-m-6", 7: "oui-m-7", 8: "oui-m-8", 9: "oui-m-9", 10: "oui-m-10" }, mx: { 0: "oui-mx-0", 1: "oui-mx-1", 2: "oui-mx-2", 3: "oui-mx-3", 4: "oui-mx-4", 5: "oui-mx-5", 6: "oui-mx-6", 7: "oui-mx-7", 8: "oui-mx-8", 9: "oui-mx-9", 10: "oui-mx-10" }, my: { 0: "oui-my-0", 1: "oui-my-1", 2: "oui-my-2", 3: "oui-my-3", 4: "oui-my-4", 5: "oui-my-5", 6: "oui-my-6", 7: "oui-my-7", 8: "oui-my-8", 9: "oui-my-9", 10: "oui-my-10" }, mt: { 0: "oui-mt-0", 1: "oui-mt-1", 2: "oui-mt-2", 3: "oui-mt-3", 4: "oui-mt-4", 5: "oui-mt-5", 6: "oui-mt-6", 7: "oui-mt-7", 8: "oui-mt-8", 9: "oui-mt-9", 10: "oui-mt-10" }, mb: { 0: "oui-mb-0", 1: "oui-mb-1", 2: "oui-mb-2", 3: "oui-mb-3", 4: "oui-mb-4", 5: "oui-mb-5", 6: "oui-mb-6", 7: "oui-mb-7", 8: "oui-mb-8", 9: "oui-mb-9", 10: "oui-mb-10" }, ml: { 0: "oui-ml-0", 1: "oui-ml-1", 2: "oui-ml-2", 3: "oui-ml-3", 4: "oui-ml-4", 5: "oui-ml-5", 6: "oui-ml-6", 7: "oui-ml-7", 8: "oui-ml-8", 9: "oui-ml-9", 10: "oui-ml-10" }, mr: { 0: "oui-mr-0", 1: "oui-mr-1", 2: "oui-mr-2", 3: "oui-mr-3", 4: "oui-mr-4", 5: "oui-mr-5", 6: "oui-mr-6", 7: "oui-mr-7", 8: "oui-mr-8", 9: "oui-mr-9", 10: "oui-mr-10" }, grow: { true: "oui-grow" } } };
var ga$2 = (e2) => {
  let { width: o2, height: t, angle: r3, left: i, top: n4, bottom: a2, right: s2, ...l2 } = e2, u2 = /* @__PURE__ */ Object.create(null);
  return r3 && (u2["--oui-gradient-angle"] = `${r3}deg`), je$4("--oui-width", o2, u2), je$4("--oui-height", t, u2), je$4("--oui-left", i, u2), je$4("--oui-right", s2, u2), je$4("--oui-top", n4, u2), je$4("--oui-bottom", a2, u2), { ...l2, style: { ...l2.style, ...u2 } };
};
function je$4(e2, o2, t) {
  typeof o2 < "u" && (t[e2] = Pu(o2));
}
function Pu(e2) {
  return typeof e2 == "number" ? `${e2}px` : e2;
}
var pt$6 = (e2) => {
  let { angle: o2 } = e2;
  return { "--oui-gradient-angle": o2 ? `${o2}deg` : "180deg" };
};
var dt$4 = { variants: { shadow: { sm: "oui-shadow-sm", base: "oui-shadow", md: "oui-shadow-md", lg: "oui-shadow-lg", xl: "oui-shadow-xl", "2xl": "oui-shadow-2xl", inner: "oui-shadow-inner", none: "oui-shadow-none" } } };
var mt$3 = { variants: { border: { true: "oui-border oui-border-line" }, r: { none: "oui-rounded-none", sm: "oui-rounded-sm", base: "oui-rounded", md: "oui-rounded-md", lg: "oui-rounded-lg", xl: "oui-rounded-xl", "2xl": "oui-rounded-2xl", full: "oui-rounded-full" }, gradient: { primary: "oui-gradient-primary", secondary: "oui-gradient-secondary", brand: "oui-gradient-brand", success: "oui-gradient-success", warning: "oui-gradient-warning", danger: "oui-gradient-danger", neutral: "oui-gradient-neutral" }, intensity: { 100: "oui-bg-base-1", 200: "oui-bg-base-2", 300: "oui-bg-base-3", 400: "oui-bg-base-4", 500: "oui-bg-base-5", 600: "oui-bg-base-6", 700: "oui-bg-base-7", 800: "oui-bg-base-8", 900: "oui-bg-base-9" }, borderColor: { 4: "oui-border-line-4", 6: "oui-border-line-6", 8: "oui-border-line", 12: "oui-border-line-12", 16: "oui-border-line-16" } } };
var fa$1 = { variants: { position: { static: "oui-static", fixed: "oui-fixed", absolute: "oui-absolute", relative: "oui-relative", sticky: "oui-sticky" }, zIndex: { 0: "oui-z-0", 10: "oui-z-10", 20: "oui-z-20", 30: "oui-z-30", 40: "oui-z-40", 50: "oui-z-50", auto: "oui-z-auto" } } };
var xa = { variants: { invisible: { true: "oui-invisible" } } };
var yr$2 = h$2({ base: ["oui-box"], variants: { ...ma$2.variants, ...dt$4.variants, ...mt$3.variants, ...fa$1.variants, ...xa.variants, __position: { true: "oui-position" }, __size_width: { true: "oui-size-width" }, __size_height: { true: "oui-size-height" } }, defaultVariants: { __position: false, __size: false } }), W$2 = ze__default__default.forwardRef((e2, o2) => {
  let { asChild: t = false, as: r3 = "div", className: i, p: n4, px: a2, py: s2, pt: l2, pb: u2, pl: p2, pr: g2, m: m2, mx: c, my: x2, mr: b2, mt: k2, mb: f2, ml: T2, grow: N2, zIndex: v3, style: M2, shadow: y2, border: B2, gradient: U2, r: K2, invisible: ne2, intensity: w4, position: V2, borderColor: O2, ...Le2 } = ga$2(e2);
  return jsx(t ? Slot : r3, { style: M2, className: yr$2({ className: i, p: n4, r: K2, px: a2, py: s2, pt: l2, pb: u2, pr: g2, pl: p2, m: m2, mx: c, my: x2, mt: k2, mb: f2, ml: T2, mr: b2, zIndex: v3, shadow: y2, border: B2, gradient: U2, position: V2, intensity: w4, invisible: ne2, grow: N2, borderColor: O2, __position: typeof V2 < "u", __size_width: typeof e2.width < "u", __size_height: typeof e2.height < "u" }), ...Le2, ref: o2 });
});
W$2.displayName = "Box";
var Nu = h$2({ variants: { ...ct$3.variants } }), ba$2 = h$2({ extend: Nu, base: ["oui-flex"], variants: { display: { flex: "oui-flex", inlineFlex: "oui-inline-flex" }, direction: { row: "oui-flex-row", rowReverse: "oui-flex-row-reverse", column: "oui-flex-col", columnReverse: "oui-flex-col-reverse" }, itemAlign: { start: "oui-items-start", end: "oui-items-end", center: "oui-items-center", baseline: "oui-items-baseline", stretch: "oui-items-stretch" }, justify: { start: "oui-justify-start", end: "oui-justify-end", center: "oui-justify-center", between: "oui-justify-between", around: "oui-justify-around", evenly: "oui-justify-evenly", stretch: "oui-justify-stretch" }, wrap: { noWrap: "oui-flex-nowrap", wrap: "oui-flex-wrap", wrapReverse: "oui-flex-wrap-reverse" } }, defaultVariants: { display: "flex", direction: "row", itemAlign: "center", justify: "start", wrap: "noWrap" } }, { responsiveVariants: true }), z$3 = forwardRef((e2, o2) => {
  let { className: t, display: r3, gap: i, gapX: n4, gapY: a2, wrap: s2, justify: l2, itemAlign: u2, direction: p2, ...g2 } = e2;
  return jsx(W$2, { ref: o2, className: ba$2({ className: t, display: r3, gap: i, gapX: n4, gapY: a2, wrap: s2, justify: l2, itemAlign: u2, direction: p2 }), ...g2 });
});
z$3.displayName = "Flex";
var wa$1 = tv({ base: "oui-text-gray-200 oui-animate-spin dark:oui-text-gray-600 oui-fill-primary-darken", variants: { size: { xs: "oui-w-3 oui-h-3", sm: "oui-w-4 oui-h-4", md: "oui-w-6 oui-h-6", lg: "oui-w-8 oui-h-8", xl: "oui-w-10 oui-h-10" }, color: { primary: "oui-fill-primary-darken", success: "oui-fill-success", danger: "oui-fill-danger", warning: "oui-fill-warning-darken", gray: "oui-fill-gray", darkGray: "oui-fill-darkGray", white: "oui-fill-white" } }, defaultVariants: { size: "lg", color: "primary" } }), Ie$4 = (e2) => {
  let { size: o2, color: t, loading: r3 = true, children: i, className: n4 } = e2;
  return r3 ? jsxs("span", { role: "status", className: "oui-inline-block", children: [jsxs("svg", { "aria-hidden": "true", className: wa$1({ size: o2, className: n4, color: t }), viewBox: "0 0 100 101", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsx("path", { d: "M100 50.5908C100 78.2051 77.6142 100.591 50 100.591C22.3858 100.591 0 78.2051 0 50.5908C0 22.9766 22.3858 0.59082 50 0.59082C77.6142 0.59082 100 22.9766 100 50.5908ZM9.08144 50.5908C9.08144 73.1895 27.4013 91.5094 50 91.5094C72.5987 91.5094 90.9186 73.1895 90.9186 50.5908C90.9186 27.9921 72.5987 9.67226 50 9.67226C27.4013 9.67226 9.08144 27.9921 9.08144 50.5908Z", fill: "currentColor", fillOpacity: 0.2 }), jsx("path", { d: "M93.9676 39.0409C96.393 38.4038 97.8624 35.9116 97.0079 33.5539C95.2932 28.8227 92.871 24.3692 89.8167 20.348C85.8452 15.1192 80.8826 10.7238 75.2124 7.41289C69.5422 4.10194 63.2754 1.94025 56.7698 1.05124C51.7666 0.367541 46.6976 0.446843 41.7345 1.27873C39.2613 1.69328 37.813 4.19778 38.4501 6.62326C39.0873 9.04874 41.5694 10.4717 44.0505 10.1071C47.8511 9.54855 51.7191 9.52689 55.5402 10.0491C60.8642 10.7766 65.9928 12.5457 70.6331 15.2552C75.2735 17.9648 79.3347 21.5619 82.5849 25.841C84.9175 28.9121 86.7997 32.2913 88.1811 35.8758C89.083 38.2158 91.5421 39.6781 93.9676 39.0409Z", fill: "currentFill" })] }), jsx("span", { className: "oui-sr-only", children: "Loading..." })] }) : jsx(Fragment$1, { children: i });
};
var Pr$2 = ze__default__default.forwardRef((e2, o2) => {
  let { asChild: t = false, children: r3, loading: i, leading: n4, trailing: a2, size: s2, icon: l2, disabled: u2, ...p2 } = e2, g2 = t ? Slot : "button", m2 = typeof u2 < "u" ? u2 : i, c = useMemo(() => l2 ? ze__default__default.cloneElement(l2, { size: s2 === "xs" || s2 === "sm" ? 12 : s2 === "md" ? 14 : s2 === "lg" ? 16 : s2 === "xl" ? 18 : 12, className: "oui-text-inherit", opacity: i ? 0 : 1 }) : null, [s2, l2]), x2 = useMemo(() => !n4 && !a2 && !c ? r3 : jsxs(z$3, { as: "span", itemAlign: "center", className: "oui-space-x-1", children: [n4, c, jsx("span", { children: r3 }), a2] }), [r3, n4, a2, c]), b2 = useMemo(() => {
    switch (s2) {
      case "xl":
        return "md";
      case "lg":
        return "md";
      case "md":
        return "sm";
      case "sm":
      case "xs":
        return "xs";
      default:
        return "md";
    }
  }, [s2]);
  return jsx(g2, { ...p2, disabled: m2, ref: o2, children: i ? jsxs(Fragment$1, { children: [jsx("span", { className: "oui-invisible", children: x2 }), jsx(z$3, { itemAlign: "center", justify: "center", position: "absolute", as: "span", children: jsx(Ie$4, { size: b2, color: "white" }) })] }) : x2 });
});
Pr$2.displayName = "BaseButton";
var ft$3 = tv({ base: ["oui-button", "oui-inline-flex", "oui-items-center", "oui-justify-center", "oui-whitespace-nowrap", "oui-transition-colors", "disabled:oui-cursor-not-allowed", "disabled:oui-bg-base-3", "disabled:oui-text-base-contrast-36", "disabled:hover:oui-bg-base-3"], variants: { ...dt$4.variants, variant: { text: "oui-bg-transparent", outlined: "oui-border", contained: "oui-text-white", gradient: "oui-gradient-brand oui-text-[rgba(0,0,0,0.88)]" }, size: { xs: ["oui-px-2", "oui-rounded", "oui-h-6", "oui-text-2xs"], sm: ["oui-px-3", "oui-rounded", "oui-h-7", "oui-text-2xs"], md: ["oui-px-3", "oui-rounded-md", "oui-h-8", "oui-text-sm"], lg: ["oui-px-3", "oui-rounded-md", "oui-h-10", "oui-text-base"], xl: ["oui-px-4", "oui-rounded-lg", "oui-h-13", "oui-text-lg"] }, color: { primary: ["hover:oui-bg-primary-darken/80 active:oui-bg-primary-darken/70"], secondary: "hover:oui-bg-base-4/80 active:oui-bg-base-4/70", success: "hover:oui-bg-success/80 active:oui-bg-success/70", buy: "hover:oui-bg-success/80 active:oui-bg-success/70", danger: "hover:oui-bg-danger/80 active:oui-bg-danger/70", sell: "hover:oui-bg-danger/80 active:oui-bg-danger/70", warning: "hover:oui-bg-warning-darken/80 active:oui-bg-warning-darken/70", gray: "hover:oui-bg-base-2/80 active:oui-bg-base-2/70", light: "hover:oui-bg-white/80 active:oui-bg-white/50 disable:oui-bg-white/20" }, fullWidth: { true: "oui-w-full" } }, compoundVariants: [{ variant: "contained", color: "primary", className: ["oui-bg-primary-darken", "oui-text-primary-contrast"] }, { variant: "contained", color: "secondary", className: ["oui-bg-base-4", "oui-text-primary-contrast"] }, { variant: "contained", color: "success", className: ["oui-bg-success", "oui-text-success-contrast"] }, { variant: "contained", color: "buy", className: ["oui-bg-trade-profit", "oui-text-success-contrast"] }, { variant: "contained", color: "warning", className: ["oui-bg-warning-darken", "oui-text-warning-contrast"] }, { variant: "contained", color: "danger", className: ["oui-bg-danger", "oui-text-danger-contrast"] }, { variant: "contained", color: "sell", className: ["oui-bg-trade-loss", "oui-text-danger-contrast"] }, { variant: "contained", color: "gray", className: ["oui-bg-base-2", "oui-text-base-contrast"] }, { variant: "contained", color: "light", className: ["oui-bg-white", "oui-text-black/[.88]", "disabled:oui-bg-white/30 hover:disabled:oui-bg-white/30 disabled:oui-text-black/[.36]"] }, { variant: "outlined", color: "primary", className: ["oui-border-primary-darken", "oui-text-primary-darken", "hover:oui-bg-primary-darken/20"] }, { variant: "outlined", color: "secondary", className: ["oui-border-base-4", "oui-text-base-contrast-54", "hover:oui-bg-base-4/20"] }, { variant: "outlined", color: "success", className: ["oui-border-success", "oui-text-success", "hover:oui-bg-success/20"] }, { variant: "outlined", color: "warning", className: ["oui-border-warning-darken", "oui-text-warning-contrast", "hover:oui-bg-warning-darken/20"] }, { variant: "outlined", color: "danger", className: ["oui-border-danger", "oui-text-danger", "hover:oui-bg-danger/20"] }, { variant: "outlined", color: "gray", className: ["oui-border-base-2", "oui-text-base"] }, { variant: "text", color: "primary", className: ["oui-text-primary-darken hover:oui-bg-primary-darken/10"] }, { variant: "text", color: "success", className: ["oui-text-success hover:oui-bg-success/10"] }, { variant: "text", color: "warning", className: ["oui-text-warning-contrast hover:oui-bg-warning-darken/10"] }, { variant: "text", color: "danger", className: ["oui-text-danger hover:oui-bg-danger/10"] }, { variant: "text", color: "gray", className: ["oui-text-base hover:oui-bg-base-2/10"] }, { variant: "text", color: "secondary", className: ["oui-text-base-contrast-36 hover:oui-bg-base-2/10"] }], defaultVariants: { size: "lg", variant: "contained", color: "primary" } }, { responsiveVariants: ["md", "lg"] }), $e$6 = ze__default__default.forwardRef(({ className: e2, variant: o2, size: t, color: r3, fullWidth: i, shadow: n4, angle: a2, style: s2, ...l2 }, u2) => {
  let p2 = pt$6({ angle: a2 });
  return jsx(Pr$2, { className: ft$3({ variant: o2, size: t, color: r3, className: e2, fullWidth: i, shadow: n4 }), size: t, ref: u2, style: { ...s2, ...p2 }, ...l2 });
});
$e$6.displayName = "Button";
var Sr$2 = ze__default__default.forwardRef(({ onClick: e2, throttleDuration: o2 = 700, ...t }, r3) => {
  let i = useRef(0), a2 = useCallback((s2, l2) => function(...u2) {
    let p2 = Date.now();
    p2 - i.current >= s2 && (i.current = p2, l2 == null ? void 0 : l2(...u2));
  }, [o2])(o2, e2);
  return jsx($e$6, { onClick: a2, ref: r3, ...t });
});
var Ca$1 = h$2({ extend: ct$3, base: ["oui-grid"], variants: { cols: { 1: "oui-grid-cols-1", 2: "oui-grid-cols-2", 3: "oui-grid-cols-3", 4: "oui-grid-cols-4", 5: "oui-grid-cols-5", 6: "oui-grid-cols-6", 7: "oui-grid-cols-7", 8: "oui-grid-cols-8", 9: "oui-grid-cols-9", none: "oui-grid-cols-none" }, rows: { 1: "oui-grid-rows-1", 2: "oui-grid-rows-2", 3: "oui-grid-rows-3", 4: "oui-grid-rows-4", 5: "oui-grid-rows-5", 6: "oui-grid-rows-6", 7: "oui-grid-rows-7", 8: "oui-grid-rows-8", 9: "oui-grid-rows-9", none: "oui-grid-rows-none" }, autoFlow: { row: "oui-grid-flow-row", col: "oui-grid-flow-col", rowDense: "oui-grid-flow-row-dense", colDense: "oui-grid-flow-col-dense" }, gap: { 0: "oui-gap-0", 1: "oui-gap-1", 2: "oui-gap-2", 3: "oui-gap-3", 4: "oui-gap-4", 5: "oui-gap-5" }, gapX: { 0: "oui-gap-x-0", 1: "oui-gap-x-1", 2: "oui-gap-x-2", 3: "oui-gap-x-3", 4: "oui-gap-x-4", 5: "oui-gap-x-5" }, gapY: { 0: "oui-gap-y-0", 1: "oui-gap-y-1", 2: "oui-gap-y-2", 3: "oui-gap-y-3", 4: "oui-gap-y-4", 5: "oui-gap-y-5" } }, defaultVariants: {} }), kr$2 = ze__default__default.forwardRef((e2, o2) => {
  let { className: t, cols: r3, rows: i, gap: n4, gapX: a2, gapY: s2, autoFlow: l2, ...u2 } = e2;
  return jsx(W$2, { ref: o2, ...u2, className: Ca$1({ className: t, cols: r3, rows: i, gap: n4, gapX: a2, gapY: s2, autoFlow: l2 }) });
});
kr$2.displayName = "Grid";
var Uu = h$2({ variants: { colSpan: { auto: "oui-col-auto", 1: "oui-col-span-1", 2: "oui-col-span-2", 3: "oui-col-span-3", 4: "oui-col-span-4", 5: "oui-col-span-5", 6: "oui-col-span-6", 7: "oui-col-span-7", 8: "oui-col-span-8", 9: "oui-col-span-9" }, rowSpan: { auto: "oui-row-auto", 1: "oui-row-span-1", 2: "oui-row-span-2", 3: "oui-row-span-3", 4: "oui-row-span-4", 5: "oui-row-span-5", 6: "oui-row-span-6", 7: "oui-row-span-7", 8: "oui-row-span-8", 9: "oui-row-span-9" } } }), Pa = (e2) => {
  let { colSpan: o2, rowSpan: t, className: r3, ...i } = e2, n4 = useRef(null);
  return useEffect(() => {
    if (n4.current) {
      let a2 = n4.current.parentElement;
      !a2 || a2.classList.contains("oui-grid");
    }
  }, []), jsx(W$2, { ref: n4, ...i, className: Uu({ colSpan: o2, rowSpan: t, className: r3 }) });
};
var Sa$1 = kr$2;
Sa$1.span = Pa;
var Ra = h$2({ variants: { size: { "3xs": ["oui-text-3xs"], "2xs": ["oui-text-2xs"], xs: ["oui-text-xs"], sm: ["oui-text-sm"], base: ["oui-text-base"], lg: ["oui-text-lg"], xl: ["oui-text-xl"], "2xl": ["oui-text-2xl"], "3xl": ["oui-text-3xl"], "4xl": ["oui-text-4xl"], "5xl": ["oui-text-5xl"], "6xl": ["oui-text-6xl"] }, weight: { regular: ["oui-font-normal"], semibold: ["oui-font-semibold"], bold: ["oui-font-bold"] }, color: { inherit: "oui-text-inherit", neutral: "oui-text-base-contrast-54", primary: "oui-text-primary", primaryLight: "oui-text-primary-light", secondary: "oui-text-secondary", tertiary: "oui-text-tertiary", warning: "oui-text-warning-darken", danger: "oui-text-danger", success: "oui-text-success", buy: "oui-text-trade-profit", sell: "oui-text-trade-loss", lose: "oui-text-trade-loss", withdraw: "oui-text-trade-loss", profit: "oui-text-trade-profit", deposit: "oui-text-trade-profit" }, intensity: { 12: "oui-text-base-contrast-12", 20: "oui-text-base-contrast-20", 36: "oui-text-base-contrast-36", 54: "oui-text-base-contrast-54", 80: "oui-text-base-contrast-80", 98: "oui-text-base-contrast" }, dashBoard: { default: "oui-border-b oui-border-dashed oui-border-base-contrast-12" } } }), ee$3 = ze__default__default.forwardRef((e2, o2) => {
  let { children: t, className: r3, asChild: i, as: n4 = "span", color: a2, size: s2, weight: l2, intensity: u2, ...p2 } = e2;
  return jsx(Slot, { "data-accent-color": a2, ...p2, ref: o2, className: Ra({ className: r3, color: a2, size: s2, weight: l2, intensity: u2 }), children: i ? t : jsx(n4, { children: t }) });
});
ee$3.displayName = "Text";
var Ir$1 = (e2, o2 = {}) => {
  var _a3;
  let { rule: t, dp: r3, tick: i, rm: n4 = g$6.ROUND_DOWN, padding: a2 = true, abs: s2 } = o2;
  if (Number.isNaN(e2)) return "--";
  if (r3 = typeof r3 < "u" ? r3 : i ? _$3(i) : 2, t === "human") return C$3(typeof e2 == "number" ? e2 : Number(e2), r3);
  let l2 = new g$6(e2);
  if (s2 && (l2 = l2.abs()), t === "percentages") return Ia(l2.mul(100), { dp: r3, rm: n4, padding: a2 }) + "%";
  let u2 = Ia(l2, { dp: r3, rm: n4, padding: a2 });
  return t === "price" ? d$2(u2) : (u2 == null ? void 0 : u2.includes("e")) ? (_a3 = new g$6(u2)) == null ? void 0 : _a3.toFixed() : u2;
};
function Ia(e2, o2) {
  let { dp: t, rm: r3, padding: i } = o2;
  return r3 === "truncate" ? O$7(e2.toString(), t) : i ? e2.toFixed(t, r3) : e2.todp(t, r3).toString();
}
function Ju(e2, o2) {
  if (e2 == null) return "";
  let [t, r3] = o2 ?? [6, 4], i = new RegExp(`^(.{${t}})(.*)(.{${r3}})$`);
  return `${e2.replace(i, "$1...$3")}`;
}
var Da$1 = (e2) => ["percentages", "price", "human"].includes(e2), qe$6 = (e2) => {
  let { rule: o2 = "price", coloring: t, dp: r3, tick: i, suffix: n4, prefix: a2, visible: s2, unit: l2, currency: u2, rm: p2, padding: g2 = true, showIdentifier: m2 = false, identifiers: c, className: x2, unitClassName: b2, placeholder: k2, masking: f2, ignoreDP: T2, ...N2 } = e2, v3 = Number(e2.children), M2 = useMemo(() => e2.children === "-" ? e2.children : isNaN(v3) ? k2 ?? "--" : typeof s2 < "u" && !s2 ? f2 ?? "*****" : T2 ? e2.showIdentifier ? Math.abs(v3).toString() : v3 : Ir$1(v3, { rule: o2, dp: r3, tick: i, rm: p2, padding: g2, abs: m2 }), [v3, s2, i, r3]), y2 = N2.color || "inherit", B2 = useMemo(() => !t || typeof s2 < "u" && !s2 || Number.isNaN(v3) ? y2 : v3 === 0 ? "neutral" : v3 < 0 ? "lose" : "profit", [t, v3, N2.color, e2.visible]), U2 = useMemo(() => !m2 || Number.isNaN(v3) || v3 === 0 || typeof s2 < "u" && !s2 ? null : v3 < 0 ? (c == null ? void 0 : c.loss) ? c.loss : jsx("span", { children: "-" }) : (c == null ? void 0 : c.profit) ? c.profit : jsx("span", { children: "+" }), [v3, e2.visible, m2]), K2 = useMemo(() => {
    if (typeof n4 > "u" && typeof a2 > "u" && typeof l2 > "u" && typeof u2 > "u" && !m2) return M2;
    let ne2 = n4 ? typeof n4 == "string" ? jsx("span", { children: n4 }) : n4 : void 0, w4 = l2 ? jsx("span", { className: cnBase("orderly-numeral-unit", b2), children: l2 }) : void 0, V2 = a2 || (u2 ? jsx("span", { children: u2 }) : void 0), O2 = jsxs(Fragment$1, { children: [M2, w4] });
    return jsxs(Fragment$1, { children: [V2, typeof U2 < "u" ? jsxs("span", { children: [U2, jsx("span", { children: O2 })] }) : jsx("span", { children: O2 }), ne2] });
  }, [M2, n4, l2, a2, U2, b2]);
  return jsx(ee$3, { ...N2, color: B2, className: cnBase("oui-tabular-nums", x2), children: K2 });
};
var Mr$2 = h$2({ slots: { root: "oui-text-base oui-flex oui-flex-col", label: "oui-text-xs oui-text-base-contrast-36", value: "" }, variants: { align: { start: { root: "oui-items-start" }, end: { root: "oui-items-end" } } }, defaultVariants: { align: "start" } }), zr$3 = ze__default__default.forwardRef((e2, o2) => {
  let { label: t } = Mr$2({});
  return jsx("div", { ref: o2, className: t({ className: cnBase("oui-statistic-label", e2.className) }), children: e2.children });
});
zr$3.displayName = "StatisticLabel";
var za$1 = ze__default__default.forwardRef((e2, o2) => {
  let { label: t, valueProps: r3, align: i, className: n4, classNames: a2, children: s2, ...l2 } = e2, { root: u2, value: p2 } = Mr$2({ align: i }), g2 = useMemo(() => {
    if (typeof s2 == "string" || typeof s2 == "number") {
      let { className: m2, ...c } = r3 ?? {};
      return jsx(qe$6, { ...c, className: cnBase(p2({ className: m2 }), "oui-font-semibold", !(r3 == null ? void 0 : r3.coloring) && "oui-text-base-contrast-80"), children: s2 });
    }
    return s2;
  }, [s2, r3]);
  return jsxs("div", { ...l2, className: u2({ className: cnBase(n4, a2 == null ? void 0 : a2.root) }), ref: o2, children: [jsx(zr$3, { className: a2 == null ? void 0 : a2.label, children: t }), g2] });
});
za$1.displayName = "Statistic";
var ic = tv({ variants: { color: { primary: "oui-text-primary-darken", success: "oui-text-success", danger: "oui-text-danger", warning: "oui-text-warning-darken", white: "oui-text-white", black: "oui-text-black", inherit: "oui-text-inherit" } }, defaultVariants: { color: "black" } }), d$1 = ze__default__default.forwardRef((e2, o2) => {
  let { size: t = 24, color: r3, className: i, children: n4, ...a2 } = e2;
  return jsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: t, height: t, fill: "none", viewBox: "0 0 24 24", ref: o2, className: ic({ className: i, color: r3 }), ...a2, children: n4 });
});
d$1.displayName = "BaseIcon";
var S$2 = ze__default__default.forwardRef((e2, o2) => {
  let { opacity: t = 0.54, d: r3, ...i } = e2;
  return jsx(d$1, { ref: o2, ...i, children: jsx("path", { fill: "currentcolor", fillOpacity: t, fillRule: "evenodd", clipRule: "evenodd", d: r3 }) });
});
var bt$5 = ze__default__default.forwardRef((e2, o2) => jsx(S$2, { ref: o2, ...e2, d: "M6.998 2.99a4 4 0 00-4 4v6a4 4 0 004 4 4 4 0 004 4h6a4 4 0 004-4v-6a4 4 0 00-4-4 4 4 0 00-4-4h-6zm10 6a2 2 0 012 2v6a2 2 0 01-2 2h-6a2 2 0 01-2-2h4a4 4 0 004-4v-4z" }));
bt$5.displayName = "CopyIcon";
var Vr = h$2({ slots: { root: "oui-relative oui-flex oui-shrink-0 oui-overflow-hidden oui-rounded-full", image: "oui-aspect-square oui-h-full oui-w-full", fallback: "oui-flex oui-h-full oui-w-full oui-items-center oui-justify-center oui-rounded-full oui-bg-base-2" }, variants: { size: { "2xs": { root: "oui-w-4 oui-h-4" }, xs: { root: "oui-w-5 oui-h-5" }, sm: { root: "oui-w-6 oui-h-6" }, md: { root: "oui-w-8 oui-h-8" }, lg: { root: "oui-w-10 oui-h-10" }, xl: { root: "oui-w-12 oui-h-12" } } }, defaultVariants: { size: "sm" } }), Br = ze__default.forwardRef(({ className: e2, size: o2, ...t }, r3) => {
  let { root: i } = Vr({ size: o2 });
  return jsx(fe$4.Root, { ref: r3, ...t, className: i({ className: e2 }) });
});
Br.displayName = fe$4.Root.displayName;
var Lr$4 = ze__default.forwardRef(({ className: e2, ...o2 }, t) => {
  let { image: r3 } = Vr();
  return jsx(fe$4.Image, { ref: t, className: r3({ className: e2 }), ...o2 });
});
Lr$4.displayName = fe$4.Image.displayName;
var Er$2 = ze__default.forwardRef(({ className: e2, ...o2 }, t) => {
  let { fallback: r3 } = Vr({ className: e2 });
  return jsx(fe$4.Fallback, { ref: t, className: r3(), ...o2 });
});
Er$2.displayName = fe$4.Fallback.displayName;
var xe$2 = ze__default.forwardRef((e2, o2) => {
  let { size: t, src: r3, fallback: i, delayMs: n4, alt: a2, onLoadingStatusChange: s2, ...l2 } = e2;
  return jsxs(Br, { ...l2, ref: o2, size: t, children: [jsx(Lr$4, { src: r3, onLoadingStatusChange: s2, alt: a2 }), typeof i < "u" && jsx(Er$2, { delayMs: n4, children: i })] });
}), Ba = ze__default.forwardRef((e2, o2) => {
  let { address: t, ...r3 } = e2, i = useMemo(() => uc(t), [e2.address]);
  return jsx(xe$2, { ...r3, src: i });
});
var Fr$1 = (e2) => {
  let o2 = useMemo(() => `https://oss.orderly.network/static/network_logo/${e2.chainId}.png`, [e2.chainId]);
  return jsx(xe$2, { size: e2.size, src: o2, alt: `${e2.chainId}`, className: e2.className });
};
var Te$4 = (e2) => {
  let o2 = useMemo(() => {
    var _a3;
    let t = e2.name;
    return typeof e2.symbol == "string" && (t = ((_a3 = e2.symbol) == null ? void 0 : _a3.split("_"))[1]), `https://oss.orderly.network/static/symbol_logo/${t}.png`;
  }, [e2.name, e2.symbol]);
  return jsx(xe$2, { size: e2.size, src: o2, alt: e2.name, className: e2.className });
};
var La = (e2) => {
  let { secondary: o2 } = e2, t = useMemo(() => {
    let r3 = "oui-bg-base-6 oui-absolute oui-bottom-0 oui-right-0 oui-outline oui-outline-2 oui-outline-base-1 oui-z-10";
    return o2.component ? jsx("div", { className: cnBase(r3, o2 == null ? void 0 : o2.className), children: o2.component }) : "chainId" in o2 ? jsx(Fr$1, { ...o2, className: cnBase(r3, o2 == null ? void 0 : o2.className) }) : jsx(Te$4, { ...o2, className: cnBase(r3, o2 == null ? void 0 : o2.className) });
  }, [o2]);
  return jsxs("div", { className: "oui-relative", children: [e2.children, t] });
};
var De$4 = ze__default__default.forwardRef((e2, o2) => {
  let { opacity: t = 0.54, ...r3 } = e2;
  return jsx(d$1, { ref: o2, ...r3, children: jsx("path", { fill: "currentcolor", fillOpacity: t, d: "M4.994 3.906c-.256 0-.523.086-.718.281a1.029 1.029 0 0 0 0 1.438l6.28 6.281-6.28 6.281a1.029 1.029 0 0 0 0 1.438c.39.39 1.047.39 1.437 0l6.281-6.28 6.282 6.28c.39.39 1.047.39 1.437 0 .39-.39.39-1.047 0-1.438l-6.281-6.28 6.281-6.282c.39-.39.39-1.047 0-1.438a1.013 1.013 0 0 0-.719-.28c-.256 0-.523.085-.718.28l-6.282 6.281-6.28-6.28a1.013 1.013 0 0 0-.72-.282Z" }) });
});
De$4.displayName = "CloseIcon";
var Fa$1 = ze__default__default.forwardRef((e2, o2) => {
  let { opacity: t = 0.54, ...r3 } = e2;
  return jsx(S$2, { d: "M19.018 5.997c-.256 0-.523.084-.718.276l-8.707 8.594c-.257.253-.515.206-.717-.092l-2.996-4.42a1.034 1.034 0 0 0-1.405-.276.996.996 0 0 0-.28 1.38l2.995 4.42c.902 1.33 2.659 1.499 3.808.369l8.738-8.563a1 1 0 0 0 0-1.412 1.02 1.02 0 0 0-.718-.276Z", ref: o2, ...e2 });
});
Fa$1.displayName = "CheckIcon";
var ht$4 = ze__default__default.forwardRef((e2, o2) => {
  let { opacity: t = 0.54, ...r3 } = e2;
  return jsx(d$1, { ref: o2, ...r3, children: jsx("path", { fill: "currentcolor", fillOpacity: t, d: "M5.827 9.03c-.25.05-.502.175-.655.404a1.019 1.019 0 0 0 .28 1.401l5.992 3.985c.334.223.787.223 1.122 0l5.992-3.985c.459-.305.587-.943.28-1.4a1.023 1.023 0 0 0-1.404-.28l-5.43 3.61-5.428-3.61c-.23-.154-.498-.176-.75-.126Z" }) });
});
ht$4.displayName = "ChevronDownIcon";
var wt$4 = ze__default__default.forwardRef((e2, o2) => {
  let { opacity: t = 0.54, ...r3 } = e2;
  return jsx(d$1, { ref: o2, ...r3, children: jsx("path", { fill: "currentcolor", fillOpacity: t, d: "m11.443 9.17-5.991 3.986a1.02 1.02 0 0 0-.28 1.4c.305.458.945.586 1.404.281l5.429-3.612 5.428 3.612a1.025 1.025 0 0 0 1.404-.28 1.02 1.02 0 0 0-.28-1.401l-5.99-3.986a1.028 1.028 0 0 0-1.124 0Z" }) });
});
wt$4.displayName = "ChevronUpIcon";
var vt$4 = ze__default__default.forwardRef((e2, o2) => {
  let { opacity: t = 0.54, ...r3 } = e2;
  return jsx(d$1, { ref: o2, ...r3, children: jsx("path", { fill: "currentcolor", fillOpacity: t, d: "M12.017 5.997c-.3 0-.612.14-.812.406l-6 8c-.495.66-.012 1.594.812 1.594h12c.824 0 1.307-.935.812-1.594l-6-8a1.022 1.022 0 0 0-.812-.406Z" }) });
});
vt$4.displayName = "CaretUpIcon";
var oe$7 = ze__default__default.forwardRef((e2, o2) => jsx(S$2, { ref: o2, ...e2, d: "M6.007 7.996c-.824 0-1.276.935-.781 1.594l6 8a.994.994 0 0 0 1.593 0l6-8c.495-.66.012-1.594-.812-1.594h-12Z" }));
oe$7.displayName = "CaretDownIcon";
var Ga = ze__default__default.forwardRef((e2, o2) => {
  let { opacity: t = 0.54, ...r3 } = e2;
  return jsx(d$1, { ref: o2, ...r3, children: jsx("path", { fill: "currentcolor", fillOpacity: t, d: "M15.475 5.113a1.014 1.014 0 0 0-1.063.094l-8 6a1.025 1.025 0 0 0 0 1.624l8 6c.659.495 1.594.012 1.594-.812v-12c0-.412-.214-.747-.531-.906Z" }) });
});
Ga.displayName = "CaretLeftIcon";
var Za = ze__default__default.forwardRef((e2, o2) => {
  let { opacity: t = 0.54, ...r3 } = e2;
  return jsx(d$1, { ref: o2, ...r3, children: jsx("path", { fill: "currentcolor", fillOpacity: t, d: "M8.558 5.113a1.015 1.015 0 0 0-.562.906v12c0 .824.966 1.307 1.625.812l8-6c.533-.4.533-1.224 0-1.624l-8-6a1.014 1.014 0 0 0-1.063-.094Z" }) });
});
Za.displayName = "CaretRightIcon";
var Je$6 = ze__default__default.forwardRef((e2, o2) => jsx(S$2, { ref: o2, ...e2, d: "M13.778 5.022c-.25.05-.5.176-.653.406l-3.986 6a1.03 1.03 0 0 0 0 1.125l3.986 6c.305.459.943.588 1.401.28.457-.305.585-.946.28-1.405l-3.612-5.438 3.612-5.437c.305-.46.177-1.1-.28-1.406-.229-.154-.498-.176-.748-.125Z" }));
Je$6.displayName = "ChevronLeftIcon";
var eo$4 = ze__default__default.forwardRef((e2, o2) => {
  let { opacity: t = 0.54, ...r3 } = e2;
  return jsx(d$1, { ref: o2, ...r3, children: jsx("path", { fill: "currentcolor", fillOpacity: t, d: "M10.166 5.022c-.25-.051-.519-.03-.748.125a1.027 1.027 0 0 0-.28 1.406l3.612 5.437-3.612 5.438c-.305.459-.177 1.1.28 1.406a1.019 1.019 0 0 0 1.401-.281l3.986-6a1.03 1.03 0 0 0 0-1.125l-3.986-6c-.152-.23-.403-.356-.653-.406Z" }) });
});
eo$4.displayName = "ChevronRightIcon";
var Ya$1 = ze__default__default.forwardRef((e2, o2) => jsx(S$2, { d: "M9.67364 2.34985C9.02964 2.34985 8.50697 2.87252 8.50697 3.51652C5.9298 3.51652 3.8403 5.60602 3.8403 8.18319V19.8499C3.8403 22.427 5.9298 24.5165 8.50697 24.5165H20.1736C22.7508 24.5165 24.8403 22.427 24.8403 19.8499V8.18319C24.8403 5.60602 22.7508 3.51652 20.1736 3.51652C20.1736 2.87252 19.651 2.34985 19.007 2.34985C18.363 2.34985 17.8403 2.87252 17.8403 3.51652H10.8403C10.8403 2.87252 10.3176 2.34985 9.67364 2.34985ZM8.50697 5.84985H20.1736C21.4628 5.84985 22.507 6.89402 22.507 8.18319V19.8499C22.507 21.139 21.4628 22.1832 20.1736 22.1832H8.50697C7.2178 22.1832 6.17364 21.139 6.17364 19.8499V8.18319C6.17364 6.89402 7.2178 5.84985 8.50697 5.84985ZM9.67364 8.18319C9.02964 8.18319 8.50697 8.70585 8.50697 9.34985C8.50697 9.99385 9.02964 10.5165 9.67364 10.5165H19.007C19.651 10.5165 20.1736 9.99385 20.1736 9.34985C20.1736 8.70585 19.651 8.18319 19.007 8.18319H9.67364ZM12.007 15.1832C11.363 15.1832 10.8403 15.7059 10.8403 16.3499C10.8403 16.9939 11.363 17.5165 12.007 17.5165H16.6736C17.3176 17.5165 17.8403 16.9939 17.8403 16.3499C17.8403 15.7059 17.3176 15.1832 16.6736 15.1832H12.007Z", ref: o2, ...e2 }));
Ya$1.displayName = "CalendarMinusIcon";
var ja$1 = ze__default__default.forwardRef((e2, o2) => {
  let { opacity: t = 0.54, ...r3 } = e2;
  return jsx(d$1, { ref: o2, ...r3, children: jsx("path", { fill: "currentcolor", fillOpacity: t, d: "M8.968 2.455a9.671 9.671 0 0 0-3.72 2.188c-.332.31-.434.818-.218 1.218.8 1.481-.037 3.066-1.844 3.157-.442.022-.833.35-.937.781a8.71 8.71 0 0 0-.25 2.188c0 .687.074 1.464.219 2.156.09.432.466.743.906.781 1.818.158 2.718 1.544 1.906 3.313-.18.393-.098.863.219 1.157 1.062.982 2.282 1.675 3.719 2.125.41.128.873-.027 1.125-.375 1.112-1.54 2.725-1.544 3.78 0 .25.363.706.538 1.126.405a10.1 10.1 0 0 0 3.75-2.155c.33-.301.417-.788.219-1.188-.832-1.68.125-3.22 1.843-3.25.456-.008.862-.307.969-.75.173-.717.219-1.341.219-2.22 0-.754-.09-1.497-.25-2.218a.994.994 0 0 0-.97-.782c-1.69-.003-2.638-1.665-1.811-3.125a.977.977 0 0 0-.188-1.218c-1.09-.99-2.42-1.764-3.812-2.188a.986.986 0 0 0-1.125.406c-.966 1.501-2.77 1.527-3.72.032a1.023 1.023 0 0 0-1.155-.438Zm6.078 2.124a7.904 7.904 0 0 1 1.84 1.054c-.725 2.297.506 4.683 3.056 5.265.063.412.057.662.057 1.088 0 .51.007.688-.051 1.056-2.54.527-3.795 2.845-3.088 5.296-.608.441-1.043.747-1.806 1.043-1.792-1.825-4.28-1.904-6.11.011-.714-.314-1.263-.593-1.818-1.061.688-2.49-.475-4.638-3.057-5.29-.115-.457-.07-1.745-.003-2.136 2.67-.64 3.722-3.003 3.059-5.279.586-.44 1.113-.762 1.798-1.04 1.725 1.755 4.315 1.93 6.123-.007Zm-3.047 3.407a4 4 0 1 0 0 8 4 4 0 0 0 0-8Zm0 2a2 2 0 1 1 0 4 2 2 0 0 1 0-4Z" }) });
});
ja$1.displayName = "SettingIcon";
var qa = ze__default__default.forwardRef((e2, o2) => {
  let { opacity: t = 0.54, ...r3 } = e2;
  return jsx(d$1, { ref: o2, ...r3, children: jsx("path", { fill: "currentcolor", fillOpacity: t, d: "M8.968 2.456a9.669 9.669 0 0 0-3.72 2.187c-.332.31-.434.818-.218 1.219.8 1.48-.037 3.065-1.843 3.156-.443.023-.834.35-.938.78a8.712 8.712 0 0 0-.25 2.188c0 .688.074 1.464.219 2.156.09.433.466.744.906.783 1.818.156 2.718 1.543 1.906 3.311-.18.393-.098.863.219 1.156 1.062.983 2.282 1.675 3.719 2.125.41.13.873-.026 1.125-.375 1.112-1.537 2.725-1.543 3.78 0 .25.364.706.54 1.126.407a10.072 10.072 0 0 0 3.75-2.157c.33-.3.417-.787.219-1.186-.832-1.68.125-3.221 1.843-3.25.456-.008.862-.308.969-.75.173-.717.219-1.342.219-2.22 0-.754-.09-1.497-.25-2.218a.994.994 0 0 0-.97-.781c-1.69-.003-2.638-1.665-1.811-3.125a.979.979 0 0 0-.188-1.22 10.153 10.153 0 0 0-3.812-2.186.986.986 0 0 0-1.125.406c-.966 1.5-2.77 1.527-3.72.03-.242-.382-.723-.574-1.155-.436Zm3.03 5.53a4 4 0 1 1 0 8 4 4 0 0 1 0-8Z" }) });
});
qa.displayName = "SettingFillIcon";
var Qa = ze__default__default.forwardRef((e2, o2) => {
  let { opacity: t = 0.54, ...r3 } = e2;
  return jsx(d$1, { ref: o2, ...r3, children: jsx("path", { fill: "currentcolor", fillOpacity: t, d: "M7.006 2.93a4 4 0 0 0-4 4v10a4 4 0 0 0 4 4h10a4 4 0 0 0 4-4v-10a4 4 0 0 0-4-4h-10Zm2 5c.256 0 .523.086.719.28l2.28 2.282 2.282-2.281c.195-.195.463-.281.719-.281.256 0 .523.086.719.28a1.03 1.03 0 0 1 0 1.439l-2.281 2.28 2.28 2.282a1.03 1.03 0 0 1 0 1.438 1.03 1.03 0 0 1-1.437 0l-2.281-2.281-2.281 2.28a1.03 1.03 0 0 1-1.438 0 1.03 1.03 0 0 1 0-1.437l2.28-2.281-2.28-2.281a1.03 1.03 0 0 1 0-1.438c.195-.195.463-.281.719-.281Z" }) });
});
Qa.displayName = "CloseSquareFillIcon";
var en$2 = ze__default__default.forwardRef((e2, o2) => {
  let { opacity: t = 0.54, ...r3 } = e2;
  return jsx(d$1, { ref: o2, ...r3, children: jsx("path", { fill: "currentcolor", fillOpacity: t, d: "M11.999 1.953c-5.523 0-10 4.477-10 10s4.477 10 10 10 10-4.477 10-10-4.477-10-10-10Zm-3 6c.256 0 .523.086.719.281l2.28 2.281 2.282-2.28c.196-.196.463-.282.719-.282.256 0 .523.086.719.281a1.03 1.03 0 0 1 0 1.438l-2.281 2.281 2.28 2.281a1.03 1.03 0 0 1 0 1.438 1.03 1.03 0 0 1-1.437 0l-2.281-2.28-2.281 2.28a1.03 1.03 0 0 1-1.438 0 1.029 1.029 0 0 1 0-1.438l2.28-2.28-2.28-2.282a1.029 1.029 0 0 1 0-1.438c.196-.195.463-.28.719-.28Z" }) });
});
en$2.displayName = "CloseCircleFillIcon";
var on$1 = ze__default__default.forwardRef((e2, o2) => jsx(S$2, { ref: o2, ...e2, d: "M2.014 11.999c0-5.523 4.477-10 10-10s10 4.477 10 10-4.477 10-10 10-10-4.477-10-10Zm14.971-4.687c.227-.217.539-.312.837-.312.298 0 .61.095.836.312a1.102 1.102 0 0 1 0 1.595l-8.15 7.768a1.24 1.24 0 0 1-1.673 0l-3.494-3.33a1.104 1.104 0 0 1 0-1.594 1.24 1.24 0 0 1 1.674 0l2.656 2.531 7.314-6.97Z" }));
on$1.displayName = "CheckedCircleFillIcon";
var rn$1 = ze__default__default.forwardRef((e2, o2) => {
  let { opacity: t = 0.54, ...r3 } = e2;
  return jsx(d$1, { ref: o2, ...r3, children: jsx("path", { fill: "currentcolor", fillOpacity: t, fillRule: "evenodd", clipRule: "evenodd", d: "M6.99 2.93a4 4 0 0 0-4 4v10a4 4 0 0 0 4 4h10a4 4 0 0 0 4-4v-10a4 4 0 0 0-4-4h-10Zm9.995 4.382c.227-.217.539-.312.837-.312.298 0 .61.095.836.312a1.102 1.102 0 0 1 0 1.595l-8.15 7.768a1.24 1.24 0 0 1-1.673 0l-3.494-3.33a1.104 1.104 0 0 1 0-1.594 1.24 1.24 0 0 1 1.674 0l2.656 2.531 7.314-6.97Z" }) });
});
rn$1.displayName = "CheckSquareFillIcon";
var nn$1 = ze__default__default.forwardRef((e2, o2) => {
  let { opacity: t = 0.54, ...r3 } = e2;
  return jsx(d$1, { ref: o2, ...r3, children: jsx("path", { fill: "currentcolor", fillOpacity: t, fillRule: "evenodd", clipRule: "evenodd", d: "M6.99 2.93a4 4 0 0 0-4 4v10a4 4 0 0 0 4 4h10a4 4 0 0 0 4-4v-10a4 4 0 0 0-4-4h-10Zm0 2h10a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-10a2 2 0 0 1-2-2v-10a2 2 0 0 1 2-2Z" }) });
});
nn$1.displayName = "CheckSquareEmptyIcon";
var ln$1 = ze__default__default.forwardRef((e2, o2) => {
  let { opacity: t = 0.54, ...r3 } = e2;
  return jsx(d$1, { ref: o2, ...r3, children: jsx("path", { fill: "currentcolor", fillOpacity: t, d: "M11.99 2.93a1 1 0 0 0-1 1v7h-7a1 1 0 0 0 0 2h7v7a1 1 0 0 0 2 0v-7h7a1 1 0 0 0 0-2h-7v-7a1 1 0 0 0-1-1Z" }) });
});
ln$1.displayName = "PlusIcon";
var cn = ze__default__default.forwardRef((e2, o2) => {
  let { opacity: t = 0.54, ...r3 } = e2;
  return jsx(d$1, { ref: o2, ...r3, children: jsx("rect", { x: "4", y: "11", width: "16", height: "1.5", rx: "0.666667", fill: "currentcolor", fillOpacity: t }) });
});
cn.displayName = "ReduceIcon";
var dn$1 = ze__default__default.forwardRef((e2, o2) => {
  let { opacity: t = 0.54, ...r3 } = e2;
  return jsx(d$1, { ref: o2, ...r3, children: jsx("path", { fill: "currentcolor", fillOpacity: t, d: "M12.014 1.999c-5.523 0-10 4.477-10 10s4.477 10 10 10 10-4.477 10-10-4.477-10-10-10Zm0 2a8 8 0 1 1 0 16 8 8 0 0 1 0-16Z" }) });
});
dn$1.displayName = "CircleOutlinedIcon";
var gn = ze__default__default.forwardRef((e2, o2) => {
  let { opacity: t = 0.54, ...r3 } = e2;
  return jsx(d$1, { ref: o2, ...r3, children: jsx("path", { fill: "currentcolor", fillOpacity: t, d: "M6.99 2.93a4 4 0 0 0-4 4v10a4 4 0 0 0 4 4h10a4 4 0 0 0 4-4v-10a4 4 0 0 0-4-4h-10Zm0 2h10a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-10a2 2 0 0 1-2-2v-10a2 2 0 0 1 2-2Z" }) });
});
gn.displayName = "SquareOutlinedIcon";
var xn = ze__default__default.forwardRef((e2, o2) => {
  let { ...t } = e2;
  return jsx(d$1, { ref: o2, ...t, children: jsx("path", { fill: "currentcolor", d: "M12.014 1.999c-5.523 0-10 4.477-10 10s4.477 10 10 10 10-4.477 10-10-4.477-10-10-10Zm0 5a1 1 0 0 1 1 1v5a1 1 0 0 1-2 0v-5a1 1 0 0 1 1-1Zm0 8a1 1 0 1 1 0 2 1 1 0 0 1 0-2Z" }) });
});
xn.displayName = "ExclamationFillIcon";
var hn$1 = ze__default__default.forwardRef((e2, o2) => {
  let { opacity: t = 0.54, ...r3 } = e2;
  return jsx(d$1, { ref: o2, ...r3, children: jsx("path", { fill: "currentcolor", fillOpacity: t, d: "M12.014 1.953c-5.523 0-10 4.477-10 10s4.477 10 10 10 10-4.477 10-10-4.477-10-10-10Zm0 5a3.006 3.006 0 0 1 3 3c.004 1.11-.516 2.044-1.375 2.906-.18.181-.353.355-.563.532-.099.084-.376.287-.406.312-.422.356-1.05.33-1.406-.094a1.035 1.035 0 0 1 .125-1.437l.375-.313c.168-.14.335-.272.47-.406.518-.522.782-1.022.78-1.5a1 1 0 0 0-1.969-.25c-.14.534-.685.86-1.219.72a1.034 1.034 0 0 1-.718-1.25 2.995 2.995 0 0 1 2.906-2.22Zm0 8a1 1 0 1 1 0 2 1 1 0 0 1 0-2Z" }) });
});
hn$1.displayName = "ExclamationFillIcon";
var wn$2 = ze__default__default.forwardRef((e2, o2) => jsx(S$2, { d: "M21.995 16.007c0-.256-.086-.523-.28-.719l-3.72-3.687-1.406 1.406 1.968 2H3.995a1 1 0 000 2h14.562l-1.968 2 1.406 1.406 3.72-3.687c.194-.196.28-.463.28-.719zm-1-8a1 1 0 00-1-1H5.432l1.97-2-1.407-1.406-3.719 3.687a1.03 1.03 0 000 1.438l3.72 3.687L7.4 11.007l-1.969-2h14.563a1 1 0 001-1z", ref: o2, ...e2 }));
wn$2.displayName = "ArrowLeftRightIcon";
var vn$1 = ze__default__default.forwardRef((e2, o2) => jsx(S$2, { d: "M16.007 2.014c-.256 0-.523.086-.718.281L11.6 6.015l1.406 1.405 2-1.968v14.562a1 1 0 002 0V5.452l2 1.968 1.407-1.406-3.688-3.719a1.012 1.012 0 00-.719-.28zm-8 1a1 1 0 00-1 1v14.562l-2-1.968-1.406 1.406 3.688 3.72c.39.39 1.047.39 1.437 0l3.688-3.72-1.407-1.406-2 1.968V4.014a1 1 0 00-1-1z", ref: o2, ...e2 }));
vn$1.displayName = "ArrowDownUpIconIcon";
var yn$1 = ze__default__default.forwardRef((e2, o2) => jsx(S$2, { ref: o2, ...e2, d: "M6.99 20.99a4 4 0 01-4-4v-10a4 4 0 014-4h10a4 4 0 014 4v10a4 4 0 01-4 4h-10zm5-4a1 1 0 001-1v-5h3l-4-4-4 4h3v5a1 1 0 001 1z" }));
yn$1.displayName = "ArrowUpSquareFillIconIcon";
var Pn$1 = ze__default__default.forwardRef((e2, o2) => {
  let { opacity: t = 0.54, ...r3 } = e2;
  return jsx(d$1, { ref: o2, ...r3, children: jsx("path", { fill: "currentcolor", fillOpacity: t, d: "M6.99 2.99a4 4 0 00-4 4v10a4 4 0 004 4h10a4 4 0 004-4v-10a4 4 0 00-4-4h-10zm5 4a1 1 0 011 1v5h3l-4 4-4-4h3v-5a1 1 0 011-1z" }) });
});
Pn$1.displayName = "ArrowDownSquareFillIconIcon";
var Sn$2 = ze__default__default.forwardRef((e2, o2) => jsx(S$2, { d: "M7.998 2.014a4 4 0 00-4 4v12a4 4 0 004 4h8a4 4 0 004-4v-12a4 4 0 00-4-4h-8zm0 2h8a2 2 0 012 2v12a2 2 0 01-2 2h-8a2 2 0 01-2-2v-12a2 2 0 012-2zm1 2a1 1 0 00-1 1v1a1 1 0 001 1h6a1 1 0 001-1v-1a1 1 0 00-1-1h-6zm0 4a1 1 0 100 2 1 1 0 000-2zm3 0a1 1 0 100 2 1 1 0 000-2zm3 0a1 1 0 100 2 1 1 0 000-2zm-6 3a1 1 0 100 2 1 1 0 000-2zm3 0a1 1 0 100 2 1 1 0 000-2zm3 0a1 1 0 00-1 1v3a1 1 0 002 0v-3a1 1 0 00-1-1zm-6 3a1 1 0 100 2 1 1 0 000-2zm3 0a1 1 0 100 2 1 1 0 000-2z", ref: o2, ...e2 }));
Sn$2.displayName = "FeeTierIconIcon";
var Rn$1 = ze__default__default.forwardRef((e2, o2) => {
  let { opacity: t = 0.54, ...r3 } = e2;
  return jsx(d$1, { ref: o2, ...r3, children: jsx("path", { fill: "currentcolor", fillOpacity: t, d: "M16.995 1.953a1.02 1.02 0 00-.719.281l-3 3.002-9.006 9.005-1 1c-.14.14-.212.338-.25.532l-1 5.003a.974.974 0 001.155 1.157l5.003-1c.194-.04.392-.112.532-.25l1-1.002 9.005-9.005c.445-.444 2.447-2.446 3.003-3a1.02 1.02 0 00.28-.72c0-1.637-.417-2.807-1.282-3.69-.873-.89-2.039-1.313-3.72-1.313zm.395 2.02c.902.052 1.488.26 1.889.67.41.417.669.997.724 1.882-.547.547-1.35 1.337-2.006 1.994l-2.565-2.564c.658-.657 1.41-1.436 1.958-1.983zm-3.396 3.42l2.564 2.564-7.567 7.567-2.564-2.564 7.568-7.567zM4.99 16.398l2.564 2.564-.094.094c-.66.132-1.993.411-3.22.657l.656-3.22.094-.095z" }) });
});
Rn$1.displayName = "EditIcon";
var Nn$2 = ze__default__default.forwardRef((e2, o2) => {
  let { opacity: t = 0.54, ...r3 } = e2;
  return jsx(d$1, { ref: o2, ...r3, children: jsx("path", { fill: "currentcolor", fillOpacity: t, d: "M12.001 3.998c-2.959 0-5.452 1.454-7.5 3.844a16.652 16.652 0 00-1.812 2.562c-.302.528-.486.936-.594 1.188a1.058 1.058 0 000 .812c.108.252.292.66.594 1.188a16.652 16.652 0 001.812 2.562c2.048 2.39 4.541 3.844 7.5 3.844 2.96 0 5.452-1.454 7.5-3.844a16.652 16.652 0 001.812-2.562c.302-.528.486-.936.594-1.188a1.058 1.058 0 000-.812c-.108-.252-.292-.66-.594-1.188a16.652 16.652 0 00-1.812-2.562c-2.048-2.39-4.54-3.844-7.5-3.844zm0 4a4 4 0 110 8 4 4 0 010-8zm0 2a2 2 0 100 3.999 2 2 0 000-4z" }) });
});
Nn$2.displayName = "EyeIcon";
var Dn = ze__default__default.forwardRef((e2, o2) => {
  let { opacity: t = 0.54, ...r3 } = e2;
  return jsx(d$1, { ref: o2, ...r3, children: jsx("path", { fill: "currentcolor", fillOpacity: t, d: "M16.998 1.953a3 3 0 0 0-3 3c0 .257.04.577.102.815L8.747 9.504a3.25 3.25 0 0 0-1.75-.55 3 3 0 1 0 0 6c.633 0 1.257-.236 1.74-.569l5.365 3.766a3.2 3.2 0 0 0-.104.802 3 3 0 1 0 3-3c-.632 0-1.248.228-1.731.562l-5.378-3.763a3.2 3.2 0 0 0 .109-.799c0-.268-.038-.557-.104-.804l5.365-3.752c.479.323 1.118.556 1.739.556a3 3 0 1 0 0-6" }) });
});
Dn.displayName = "ShareIcon";
var zn$1 = ze__default__default.forwardRef((e2, o2) => {
  let { opacity: t = 0.54, ...r3 } = e2;
  return jsx(d$1, { ref: o2, ...r3, children: jsx("path", { fill: "currentcolor", fillOpacity: t, d: "M12.001 3.998c-2.959-.007-5.452 1.454-7.5 3.844a16.654 16.654 0 00-1.812 2.562c-.302.528-.486.936-.594 1.188a1.058 1.058 0 000 .812c.108.252.292.66.594 1.188.401.703.87 1.419 1.406 2.094.085.107.76.873 1.344 1.468l-1.157 1.125a1.03 1.03 0 000 1.438 1.03 1.03 0 001.438 0l14-14a1.03 1.03 0 000-1.438 1.014 1.014 0 00-.719-.281c-.256 0-.523.086-.719.28l-1.28 1.314c-1.654-1.106-3.298-1.59-5-1.594zm0 4c.518 0 1.31.137 2.031.562l-1.53 1.532c-.158-.082-.457-.094-.5-.094a2 2 0 00-2 2c0 .044-.015.347.03.53-.192.234-1.5 1.5-1.5 1.5a4.204 4.204 0 01-.53-2.03c-.012-2.21 1.79-4 4-4zm7.938.344s-9.755 9.718-11.063 11.03c1.44.572 2.918.626 3.125.626 2.96 0 5.452-1.454 7.5-3.844a16.652 16.652 0 001.812-2.562c.302-.528.486-.936.594-1.188a1.04 1.04 0 000-.812c-.227-.52-.654-1.347-1.312-2.313-.177-.26-.656-.937-.656-.937z" }) });
});
zn$1.displayName = "EyeCloseIcon";
var Bn$1 = ze__default__default.forwardRef((e2, o2) => {
  let { opacity: t = 0.54, ...r3 } = e2;
  return jsx(d$1, { ref: o2, ...r3, children: jsx("path", { fill: "currentcolor", fillOpacity: t, d: "M12.007 2.99a9 9 0 0 0-5.594 1.94 1 1 0 1 0 1.25 1.562 6.97 6.97 0 0 1 4.344-1.5 7 7 0 0 1 7 7h-2l3 4 3-4h-2a9 9 0 0 0-9-9m-8 5-3 4h2a9 9 0 0 0 9 9 9 9 0 0 0 5.594-1.937 1 1 0 1 0-1.25-1.562 6.96 6.96 0 0 1-4.344 1.5 7 7 0 0 1-7-7h2z" }) });
});
Bn$1.displayName = "RefreshIcon";
var sp = (e2) => jsxs("svg", { width: "20", height: "20", viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg", className: e2.className, children: [jsxs("g", { clipPath: "url(#clip0_862_2443)", children: [jsx("path", { d: "M10.0249 19.9491C15.5202 19.9491 19.9751 15.4942 19.9751 9.99883C19.9751 4.50346 15.5202 0.048584 10.0249 0.048584C4.52949 0.048584 0.0746155 4.50346 0.0746155 9.99883C0.0746155 15.4942 4.52949 19.9491 10.0249 19.9491Z", fill: "url(#paint0_linear_862_2443)" }), jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M14.1556 4.8931C14.2202 4.94547 14.1824 5.04764 14.0992 5.04764H5.95063C5.86743 5.04764 5.82963 4.94547 5.89428 4.8931C7.02258 3.97918 8.4598 3.4317 10.0249 3.4317C11.59 3.4317 13.0272 3.97918 14.1556 4.8931Z", fill: "white" }), jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M7.47028 11.7869C7.4233 11.7199 7.34764 11.6777 7.26581 11.6777H3.83C3.75128 11.6777 3.69391 11.7525 3.71579 11.8281C4.50796 14.565 7.03275 16.566 10.0249 16.566C13.0171 16.566 15.5419 14.565 16.334 11.8281C16.3559 11.7525 16.2985 11.6777 16.2198 11.6777H12.7841C12.7022 11.6777 12.6266 11.7199 12.5796 11.7869C12.0156 12.5911 11.0817 13.1167 10.025 13.1167C8.96818 13.1167 8.03421 12.5911 7.47028 11.7869Z", fill: "white" }), jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12.335 7.90476C12.3825 7.95713 12.4493 7.98867 12.5199 7.98867H16.114C16.1955 7.98867 16.2533 7.9094 16.2264 7.83259C15.9727 7.10647 15.5951 6.43851 15.119 5.85405C15.0743 5.79918 15.007 5.76813 14.9361 5.76813H5.11354C5.04278 5.76813 4.97543 5.79918 4.93074 5.85405C4.45459 6.43851 4.07701 7.10647 3.82337 7.83259C3.79652 7.9094 3.85428 7.98867 3.93567 7.98867H7.52982C7.60052 7.98867 7.66725 7.95713 7.71475 7.90476C8.28522 7.27587 9.10892 6.88093 10.0249 6.88093C10.9408 6.88093 11.7646 7.27587 12.335 7.90476Z", fill: "white" }), jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M13.116 10.9587C13.0549 10.9587 13.0114 10.8991 13.028 10.8402C13.1029 10.5723 13.1429 10.29 13.1429 9.99822C13.1429 9.5877 13.0636 9.19568 12.9195 8.83669C12.895 8.77593 12.9388 8.70813 13.0042 8.70813H16.3916C16.4345 8.70813 16.4716 8.73843 16.4795 8.78064C16.5534 9.17523 16.5921 9.58228 16.5921 9.99832C16.5921 10.2979 16.572 10.5927 16.5333 10.8816C16.5273 10.9259 16.4894 10.9587 16.4447 10.9587H13.116ZM7.02183 10.8402C7.03829 10.8991 6.99492 10.9587 6.93381 10.9587H3.60511C3.56045 10.9587 3.52246 10.9259 3.51651 10.8816C3.47767 10.5927 3.45761 10.2979 3.45761 9.99832C3.45761 9.58228 3.49631 9.17523 3.5703 8.78064C3.5782 8.73843 3.61523 8.70813 3.65817 8.70813H7.04553C7.11101 8.70813 7.15477 8.77593 7.13037 8.83669C6.98617 9.19568 6.90682 9.5877 6.90682 9.99822C6.90682 10.29 6.94688 10.5723 7.02183 10.8402Z", fill: "white" })] }), jsxs("defs", { children: [jsxs("linearGradient", { id: "paint0_linear_862_2443", x1: "10.0249", y1: "0.0486119", x2: "10.0249", y2: "19.9491", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "#C750FF" }), jsx("stop", { offset: "1", stopColor: "#5800E8" })] }), jsx("clipPath", { id: "clip0_862_2443", children: jsx("rect", { width: "20", height: "20", fill: "white" }) })] })] });
var lp = (e2) => jsxs("svg", { width: "20", height: "20", viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg", className: e2.className, children: [jsxs("g", { clipPath: "url(#clip0_862_2449)", children: [jsx("path", { d: "M10.0249 19.9361C15.5202 19.9361 19.9751 15.4813 19.9751 9.98589C19.9751 4.49052 15.5202 0.0356445 10.0249 0.0356445C4.52949 0.0356445 0.0746155 4.49052 0.0746155 9.98589C0.0746155 15.4813 4.52949 19.9361 10.0249 19.9361Z", fill: "url(#paint0_linear_862_2449)" }), jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M14.0992 5.0347C14.1824 5.0347 14.2202 4.93253 14.1556 4.88017C13.0272 3.96625 11.59 3.41876 10.0249 3.41876C8.4598 3.41876 7.02258 3.96625 5.89428 4.88017C5.82963 4.93253 5.86743 5.0347 5.95063 5.0347H14.0992ZM7.2658 11.6648C7.34763 11.6648 7.42329 11.707 7.47028 11.7739C8.03421 12.5781 8.96819 13.1038 10.025 13.1038C11.0817 13.1038 12.0156 12.5781 12.5796 11.7739C12.6266 11.707 12.7022 11.6648 12.7841 11.6648H16.2198C16.2985 11.6648 16.3559 11.7395 16.334 11.8151C15.5419 14.5521 13.0171 16.5531 10.0249 16.5531C7.03275 16.5531 4.50795 14.5521 3.71578 11.8151C3.6939 11.7395 3.75127 11.6648 3.83 11.6648H7.2658ZM12.335 7.8919C12.3825 7.94426 12.4493 7.97581 12.5199 7.97581H16.114C16.1955 7.97581 16.2533 7.89653 16.2264 7.81972C15.9727 7.0936 15.5951 6.42564 15.119 5.84118C15.0743 5.78631 15.007 5.75526 14.9361 5.75526H5.11354C5.04279 5.75526 4.97543 5.78631 4.93075 5.84118C4.4546 6.42564 4.07701 7.0936 3.82337 7.81972C3.79653 7.89653 3.8543 7.97581 3.93567 7.97581H7.52983C7.60053 7.97581 7.66725 7.94426 7.71477 7.8919C8.28522 7.263 9.10892 6.86807 10.0249 6.86807C10.9408 6.86807 11.7646 7.263 12.335 7.8919ZM13.028 10.8273C13.0114 10.8862 13.0549 10.9458 13.116 10.9458H16.4447C16.4894 10.9458 16.5273 10.913 16.5333 10.8688C16.572 10.5798 16.5921 10.285 16.5921 9.98539C16.5921 9.56935 16.5534 9.1623 16.4795 8.76771C16.4716 8.72551 16.4345 8.6952 16.3916 8.6952H13.0042C12.9388 8.6952 12.895 8.763 12.9195 8.82377C13.0636 9.18276 13.1429 9.57477 13.1429 9.98529C13.1429 10.277 13.1029 10.5595 13.028 10.8273ZM6.9338 10.9458C6.99492 10.9458 7.03829 10.8862 7.02183 10.8273C6.94688 10.5595 6.90682 10.277 6.90682 9.98529C6.90682 9.57477 6.98617 9.18276 7.13037 8.82377C7.15477 8.763 7.11101 8.6952 7.04553 8.6952H3.65817C3.61522 8.6952 3.5782 8.72551 3.5703 8.76771C3.49631 9.1623 3.45761 9.56935 3.45761 9.98539C3.45761 10.285 3.47767 10.5798 3.51651 10.8688C3.52246 10.913 3.56045 10.9458 3.60511 10.9458H6.9338Z", fill: "url(#paint1_linear_862_2449)" })] }), jsxs("defs", { children: [jsxs("linearGradient", { id: "paint0_linear_862_2449", x1: "10.0249", y1: "-2.24058", x2: "10.0249", y2: "21.2774", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "white" }), jsx("stop", { offset: "1", stopColor: "#EDE9F4" })] }), jsxs("linearGradient", { id: "paint1_linear_862_2449", x1: "10.0249", y1: "3.41876", x2: "10.0249", y2: "16.5531", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "#C750FF" }), jsx("stop", { offset: "1", stopColor: "#5800E8" })] }), jsx("clipPath", { id: "clip0_862_2449", children: jsx("rect", { width: "20", height: "20", fill: "white" }) })] })] });
var cp = (e2) => {
  let o2 = useMemo(() => {
    var _a3, _b2, _c2;
    return `https://oss.orderly.network/static/wallet_icon/${(_c2 = (_b2 = (_a3 = e2.name) == null ? void 0 : _a3.split(" ")) == null ? void 0 : _b2[0]) == null ? void 0 : _c2.toLowerCase()}.png`;
  }, [e2.name]);
  return jsx(xe$2, { size: e2.size, src: o2, alt: `${e2.name}` });
};
var oo$2 = ze__default__default.forwardRef((e2, o2) => jsx(S$2, { d: "M8.006 2.014a1 1 0 0 0-1 1 4 4 0 0 0-4 4v10a4 4 0 0 0 4 4h10a4 4 0 0 0 4-4v-10c0-2.205-1.792-4-4-4a1 1 0 0 0-2 0h-6a1 1 0 0 0-1-1Zm-1 3a1 1 0 0 0 2 0h6a1 1 0 0 0 2 0 2 2 0 0 1 2 2v1h-14v-1a2 2 0 0 1 2-2Zm-2 5h14v7a2 2 0 0 1-2 2h-10a2 2 0 0 1-2-2v-7Zm3 2a1 1 0 1 0 0 2 1 1 0 0 0 0-2Zm4 0a1 1 0 1 0 0 2 1 1 0 0 0 0-2Zm4 0a1 1 0 1 0 0 2 1 1 0 0 0 0-2Zm-8 3a1 1 0 1 0 0 2 1 1 0 0 0 0-2Zm4 0a1 1 0 1 0 0 2 1 1 0 0 0 0-2Zm4 0a1 1 0 1 0 0 2 1 1 0 0 0 0-2Z", ref: o2, ...e2 }));
oo$2.displayName = "CaretLeftIcon";
var Ln = ze__default__default.forwardRef((e2, o2) => jsx(S$2, { d: "M11.998 1.953c-4.362 0-8 1.56-8 4s3.638 4 8 4 8-1.559 8-4-3.638-4-8-4m-8 7.625v2.375c0 2.441 3.638 4 8 4s8-1.559 8-4V9.578c-1.814 1.49-4.642 2.375-8 2.375s-6.186-.885-8-2.375m0 6v2.375c0 2.441 3.638 4 8 4s8-1.559 8-4v-2.375c-1.814 1.49-4.642 2.375-8 2.375s-6.186-.885-8-2.375", ref: o2, ...e2 }));
Ln.displayName = "ServerFillIcon";
var Fn = ze__default__default.forwardRef((e2, o2) => {
  let { opacity: t = 0.54, ...r3 } = e2;
  return jsxs(d$1, { ref: o2, ...r3, children: [jsx("path", { d: "M12 2.5c-.3 0-.611.112-.81.325l-5.99 6.4c-.495.527-.013 1.275.81 1.275h11.98c.823 0 1.305-.748.81-1.275l-5.99-6.4c-.198-.213-.51-.325-.81-.325", fill: "currentcolor", fillOpacity: ".98" }), jsx("path", { d: "M12 21.5c-.3 0-.611-.112-.81-.325l-5.99-6.4c-.495-.527-.013-1.275.81-1.275h11.98c.823 0 1.305.748.81 1.275l-5.99 6.4c-.198.213-.51.325-.81.325", fill: "currentcolor", fillOpacity: ".36" })] });
});
Fn.displayName = "SortingAscIcon";
var An$2 = ze__default__default.forwardRef((e2, o2) => {
  let { opacity: t = 0.54, ...r3 } = e2;
  return jsxs(d$1, { ref: o2, ...r3, children: [jsx("path", { d: "M12 2.5c-.3 0-.611.112-.81.325l-5.99 6.4c-.495.527-.013 1.275.81 1.275h11.98c.823 0 1.305-.748.81-1.275l-5.99-6.4c-.198-.213-.51-.325-.81-.325", fill: "currentcolor", fillOpacity: ".36" }), jsx("path", { d: "M12 21.5c-.3 0-.611-.112-.81-.325l-5.99-6.4c-.495-.527-.013-1.275.81-1.275h11.98c.823 0 1.305.748.81 1.275l-5.99 6.4c-.198.213-.51.325-.81.325", fill: "currentcolor", fillOpacity: ".98" })] });
});
An$2.displayName = "SortingDescIcon";
var On = ze__default__default.forwardRef((e2, o2) => jsx(S$2, { d: "M11.993 18.012a1 1 0 0 1-.999-.999V9.458l-2.997 2.966-1.405-1.405 4.683-4.714a1 1 0 0 1 .72-.293c.26 0 .521.098.716.293l4.683 4.714-1.405 1.405-2.997-2.966v7.555a1 1 0 0 1-.999.999", ref: o2, ...e2 })), Hn = ze__default__default.forwardRef((e2, o2) => jsx(S$2, { d: "M11.993 6.012a1 1 0 0 0-1 .999v7.555L7.998 11.6l-1.405 1.405 4.683 4.714c.195.196.457.293.719.293.26 0 .522-.098.717-.293l4.683-4.714L15.99 11.6l-2.997 2.966V7.011a1 1 0 0 0-1-.999", ref: o2, ...e2 })), Gn$1 = ze__default__default.forwardRef((e2, o2) => jsx(S$2, { d: "M18.012 11.993a1 1 0 0 0-.999-1H9.458l2.966-2.996-1.405-1.405-4.714 4.683a1 1 0 0 0-.293.719c0 .26.098.522.293.717l4.714 4.683 1.405-1.405-2.966-2.997h7.555a1 1 0 0 0 .999-1", ref: o2, ...e2 })), Wn$4 = ze__default__default.forwardRef((e2, o2) => jsx(S$2, { d: "M6.012 11.993a1 1 0 0 1 .999-1h7.555L11.6 7.998l1.405-1.405 4.714 4.683c.196.195.293.457.293.719 0 .26-.098.522-.293.717l-4.714 4.683L11.6 15.99l2.966-2.997H7.011a1 1 0 0 1-.999-1", ref: o2, ...e2 }));
On.displayName = "ArrowUpShortIcon";
Hn.displayName = "ArrowDownShortIcon";
Gn$1.displayName = "ArrowLeftShortIcon";
Wn$4.displayName = "ArrowRightShortIcon";
var Un$1 = ze__default__default.forwardRef((e2, o2) => {
  let { opacity: t = 0.54, ...r3 } = e2;
  return jsx(d$1, { ref: o2, ...r3, children: jsx("path", { fill: "currentcolor", fillOpacity: t, d: "M12 2.5c-.3 0-.611.112-.81.325l-5.99 6.4c-.495.527-.013 1.275.81 1.275h11.98c.823 0 1.305-.748.81-1.275l-5.99-6.4c-.198-.213-.51-.325-.81-.325m0 19c-.3 0-.611-.112-.81-.325l-5.99-6.4c-.495-.527-.013-1.275.81-1.275h11.98c.823 0 1.305.748.81 1.275l-5.99 6.4c-.198.213-.51.325-.81.325" }) });
});
Un$1.displayName = "SortingIconIcon";
var yp = () => jsxs("svg", { width: "32", height: "32", viewBox: "0 0 32 32", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsx("g", { children: jsx("path", { d: "M1.33301 18.6668C1.33301 17.9304 1.92996 17.3335 2.66634 17.3335H5.33301C6.06939 17.3335 6.66634 17.9304 6.66634 18.6668V28.0002C6.66634 28.7365 6.06939 29.3335 5.33301 29.3335H2.66634C1.92996 29.3335 1.33301 28.7365 1.33301 28.0002V18.6668Z", fill: "url(#paint0_linear_1609_10673)" }) }), jsx("g", { children: jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M5.33301 18.0002H2.66634C2.29815 18.0002 1.99967 18.2986 1.99967 18.6668V28.0002C1.99967 28.3684 2.29815 28.6668 2.66634 28.6668H5.33301C5.7012 28.6668 5.99967 28.3684 5.99967 28.0002V18.6668C5.99967 18.2986 5.7012 18.0002 5.33301 18.0002ZM2.66634 17.3335C1.92996 17.3335 1.33301 17.9304 1.33301 18.6668V28.0002C1.33301 28.7365 1.92996 29.3335 2.66634 29.3335H5.33301C6.06939 29.3335 6.66634 28.7365 6.66634 28.0002V18.6668C6.66634 17.9304 6.06939 17.3335 5.33301 17.3335H2.66634Z", fill: "url(#paint1_linear_1609_10673)" }) }), jsx("g", { children: jsx("path", { d: "M9.33301 12.0001C9.33301 11.2637 9.92996 10.6667 10.6663 10.6667H13.333C14.0694 10.6667 14.6663 11.2637 14.6663 12.0001V28.0001C14.6663 28.7365 14.0694 29.3334 13.333 29.3334H10.6663C9.92996 29.3334 9.33301 28.7365 9.33301 28.0001V12.0001Z", fill: "url(#paint2_linear_1609_10673)" }) }), jsx("g", { children: jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M13.333 11.3334H10.6663C10.2982 11.3334 9.99967 11.6319 9.99967 12.0001V28.0001C9.99967 28.3683 10.2982 28.6667 10.6663 28.6667H13.333C13.7012 28.6667 13.9997 28.3683 13.9997 28.0001V12.0001C13.9997 11.6319 13.7012 11.3334 13.333 11.3334ZM10.6663 10.6667C9.92996 10.6667 9.33301 11.2637 9.33301 12.0001V28.0001C9.33301 28.7365 9.92996 29.3334 10.6663 29.3334H13.333C14.0694 29.3334 14.6663 28.7365 14.6663 28.0001V12.0001C14.6663 11.2637 14.0694 10.6667 13.333 10.6667H10.6663Z", fill: "url(#paint3_linear_1609_10673)" }) }), jsx("g", { children: jsx("path", { d: "M17.333 16.0001C17.333 15.2637 17.93 14.6667 18.6663 14.6667H21.333C22.0694 14.6667 22.6663 15.2637 22.6663 16.0001V28.0001C22.6663 28.7365 22.0694 29.3334 21.333 29.3334H18.6663C17.93 29.3334 17.333 28.7365 17.333 28.0001V16.0001Z", fill: "url(#paint4_linear_1609_10673)" }) }), jsx("g", { children: jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M21.333 15.3334H18.6663C18.2982 15.3334 17.9997 15.6319 17.9997 16.0001V28.0001C17.9997 28.3683 18.2982 28.6667 18.6663 28.6667H21.333C21.7012 28.6667 21.9997 28.3683 21.9997 28.0001V16.0001C21.9997 15.6319 21.7012 15.3334 21.333 15.3334ZM18.6663 14.6667C17.93 14.6667 17.333 15.2637 17.333 16.0001V28.0001C17.333 28.7365 17.93 29.3334 18.6663 29.3334H21.333C22.0694 29.3334 22.6663 28.7365 22.6663 28.0001V16.0001C22.6663 15.2637 22.0694 14.6667 21.333 14.6667H18.6663Z", fill: "url(#paint5_linear_1609_10673)" }) }), jsx("g", { children: jsx("path", { d: "M25.333 22.6668C25.333 21.9304 25.93 21.3335 26.6663 21.3335H29.333C30.0694 21.3335 30.6663 21.9304 30.6663 22.6668V28.0002C30.6663 28.7365 30.0694 29.3335 29.333 29.3335H26.6663C25.93 29.3335 25.333 28.7365 25.333 28.0002V22.6668Z", fill: "url(#paint6_linear_1609_10673)" }) }), jsx("g", { children: jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M29.333 22.0002H26.6663C26.2982 22.0002 25.9997 22.2986 25.9997 22.6668V28.0002C25.9997 28.3684 26.2982 28.6668 26.6663 28.6668H29.333C29.7012 28.6668 29.9997 28.3684 29.9997 28.0002V22.6668C29.9997 22.2986 29.7012 22.0002 29.333 22.0002ZM26.6663 21.3335C25.93 21.3335 25.333 21.9304 25.333 22.6668V28.0002C25.333 28.7365 25.93 29.3335 26.6663 29.3335H29.333C30.0694 29.3335 30.6663 28.7365 30.6663 28.0002V22.6668C30.6663 21.9304 30.0694 21.3335 29.333 21.3335H26.6663Z", fill: "url(#paint7_linear_1609_10673)" }) }), jsx("g", { children: jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M23.9997 3.33341C23.9997 2.96522 24.2981 2.66675 24.6663 2.66675H27.9997C28.3679 2.66675 28.6663 2.96522 28.6663 3.33341V6.66675C28.6663 7.03494 28.3679 7.33341 27.9997 7.33341C27.6315 7.33341 27.333 7.03494 27.333 6.66675V4.94289L20.9425 11.3334C20.4218 11.8541 19.5776 11.8541 19.0569 11.3334L11.9997 4.27622L4.47108 11.8048C4.21073 12.0652 3.78862 12.0652 3.52827 11.8048C3.26792 11.5445 3.26792 11.1224 3.52827 10.862L11.0569 3.33341C11.5776 2.81272 12.4218 2.81272 12.9425 3.33341L19.9997 10.3906L26.3902 4.00008H24.6663C24.2981 4.00008 23.9997 3.7016 23.9997 3.33341Z", fill: "url(#paint8_linear_1609_10673)" }) }), jsxs("defs", { children: [jsxs("linearGradient", { id: "paint0_linear_1609_10673", x1: "5.99967", y1: "23.3335", x2: "1.99967", y2: "23.3335", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "#181C23" }), jsx("stop", { offset: "1", stopColor: "#333948" })] }), jsxs("linearGradient", { id: "paint1_linear_1609_10673", x1: "3.99967", y1: "17.3335", x2: "3.99967", y2: "29.3335", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "#4A5369" }), jsx("stop", { offset: "1", stopColor: "#1B2028" })] }), jsxs("linearGradient", { id: "paint2_linear_1609_10673", x1: "13.9997", y1: "19.3334", x2: "9.92665", y2: "19.3783", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "#015B50" }), jsx("stop", { offset: "1", stopColor: "#01B49E" })] }), jsxs("linearGradient", { id: "paint3_linear_1609_10673", x1: "11.9997", y1: "10.6667", x2: "11.9997", y2: "29.3334", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "#01B49E" }), jsx("stop", { offset: "1", stopColor: "#01B49E" })] }), jsxs("linearGradient", { id: "paint4_linear_1609_10673", x1: "21.9997", y1: "22.0001", x2: "17.9997", y2: "22.0001", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "#181C23" }), jsx("stop", { offset: "1", stopColor: "#333948" })] }), jsxs("linearGradient", { id: "paint5_linear_1609_10673", x1: "19.9997", y1: "14.6667", x2: "19.9997", y2: "29.3334", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "#4A5369" }), jsx("stop", { offset: "1", stopColor: "#1B2028" })] }), jsxs("linearGradient", { id: "paint6_linear_1609_10673", x1: "29.9997", y1: "25.3335", x2: "25.9997", y2: "25.3335", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "#181C23" }), jsx("stop", { offset: "1", stopColor: "#333948" })] }), jsxs("linearGradient", { id: "paint7_linear_1609_10673", x1: "27.9997", y1: "21.3335", x2: "27.9997", y2: "29.3335", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "#4A5369" }), jsx("stop", { offset: "1", stopColor: "#1B2028" })] }), jsxs("linearGradient", { id: "paint8_linear_1609_10673", x1: "3.66634", y1: "12.0001", x2: "21.262", y2: "-4.99792", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "#01B49E", stopOpacity: "0.36" }), jsx("stop", { offset: "1", stopColor: "#01B49E" })] })] })] });
var Cp = () => jsxs("svg", { width: "32", height: "32", viewBox: "0 0 32 32", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsx("path", { d: "M1.6001 14.3967C1.6001 13.86 1.86916 13.359 2.31661 13.0627L15.1166 4.58513C15.6522 4.23041 16.348 4.23041 16.8836 4.58513L29.6836 13.0627C30.131 13.359 30.4001 13.86 30.4001 14.3967V28C30.4001 28.8836 29.6838 29.6 28.8001 29.6H3.2001C2.31644 29.6 1.6001 28.8836 1.6001 28V14.3967Z", fill: "url(#paint0_linear_1609_7317)" }), jsx("path", { d: "M28.8001 28.8V29.6H3.2001V28.8H28.8001ZM29.6001 28V14.3969C29.6001 14.1285 29.4652 13.8778 29.2415 13.7297L16.4415 5.25232C16.2073 5.09729 15.9121 5.07755 15.6626 5.19373L15.5587 5.25232L2.75869 13.7297C2.53497 13.8778 2.4001 14.1285 2.4001 14.3969V28C2.4001 28.4418 2.75827 28.8 3.2001 28.8V29.6L3.03682 29.5914C2.28357 29.515 1.68506 28.9165 1.60869 28.1633L1.6001 28V14.3969C1.6001 13.8937 1.83627 13.4215 2.23447 13.1203L2.3165 13.0625L15.1165 4.58513C15.6521 4.23041 16.3481 4.23041 16.8837 4.58513L29.6837 13.0625C30.1311 13.3588 30.4001 13.8602 30.4001 14.3969V28L30.3915 28.1633C30.3151 28.9165 29.7166 29.515 28.9634 29.5914L28.8001 29.6V28.8C29.2419 28.8 29.6001 28.4418 29.6001 28Z", fill: "url(#paint1_linear_1609_7317)" }), jsx("path", { d: "M5.6001 4.7999C5.6001 3.47442 6.67461 2.3999 8.0001 2.3999H20.1374C20.5617 2.3999 20.9687 2.56847 21.2687 2.86853L25.9315 7.53127C26.2315 7.83133 26.4001 8.2383 26.4001 8.66264V17.2121C26.4001 17.7088 26.1694 18.1774 25.7756 18.4803L16.9998 25.2309C16.4135 25.6819 15.5944 25.6722 15.0189 25.2074L6.19476 18.0802C5.81868 17.7764 5.6001 17.3189 5.6001 16.8355V4.7999Z", fill: "url(#paint2_linear_1609_7317)" }), jsx("path", { d: "M5.6001 16.8358V4.7999C5.6001 3.51582 6.60854 2.46727 7.87666 2.40303L8.0001 2.3999H20.1376L20.2954 2.40771C20.6617 2.44407 21.0063 2.60608 21.2688 2.86865L25.9313 7.53115C26.2313 7.83115 26.4 8.23814 26.4001 8.6624V17.2124L26.3892 17.3968C26.3396 17.8233 26.1203 18.2154 25.7759 18.4804L17.0001 25.2312L16.8876 25.3101C16.3507 25.6545 15.6584 25.6459 15.1298 25.289L15.0188 25.2077L6.19463 18.0804C5.86561 17.8146 5.65728 17.431 5.61025 17.0155L5.6001 16.8358ZM6.4001 16.8358C6.4002 17.0774 6.5098 17.3059 6.69775 17.4577L15.522 24.5851C15.8097 24.8172 16.2187 24.8221 16.5118 24.5968L25.2876 17.846L25.3579 17.7858C25.5118 17.6362 25.6 17.4296 25.6001 17.2124V8.6624C25.6 8.47675 25.5355 8.2977 25.4188 8.15537L25.3657 8.09678L20.7032 3.43428C20.5532 3.2843 20.3497 3.19997 20.1376 3.1999H8.0001C7.11644 3.1999 6.4001 3.91625 6.4001 4.7999V16.8358Z", fill: "url(#paint3_linear_1609_7317)" }), jsx("path", { d: "M1.68437 14.1546C1.80314 14.0019 2.0105 13.9586 2.17734 14.0413L2.24531 14.0843L16.3922 25.0874L29.7461 14.0913C29.9166 13.951 30.1682 13.9755 30.3086 14.146C30.4489 14.3166 30.4244 14.5681 30.2539 14.7085L16.6539 25.9085L16.407 26.1124L16.1547 25.9156L1.75469 14.7156L1.69609 14.6601C1.57487 14.5188 1.56569 14.3073 1.68437 14.1546Z", fill: "url(#paint4_linear_1609_7317)" }), jsx("path", { d: "M15.063 19.8766C15.6222 19.4728 16.3773 19.4728 16.9366 19.8766L29.3969 28.8758C29.7115 29.103 29.5508 29.6001 29.1627 29.6001H2.8368C2.44873 29.6001 2.28801 29.103 2.6026 28.8758L15.063 19.8766Z", fill: "url(#paint5_linear_1609_7317)" }), jsx("path", { d: "M15.0634 19.8766C15.6226 19.4728 16.3776 19.4728 16.9368 19.8766L29.3969 28.8758C29.6919 29.0889 29.5693 29.5393 29.2329 29.5946L29.1634 29.6H2.83679L2.76726 29.5946C2.43083 29.5393 2.3082 29.0889 2.6032 28.8758L15.0634 19.8766ZM16.4688 20.525C16.2242 20.3484 15.9041 20.3262 15.6407 20.4586L15.5313 20.525L4.07429 28.8H27.9259L16.4688 20.525Z", fill: "url(#paint6_linear_1609_7317)" }), jsx("path", { d: "M16.2198 10.2711L15.999 10.4993L15.7783 10.2701C14.9185 9.38023 13.5199 9.37627 12.6562 10.2622L12.6485 10.2701C11.7838 11.164 11.7838 12.6095 12.6485 13.5044L15.6424 16.6463C15.8361 16.8487 16.1523 16.8517 16.3499 16.6532L16.3566 16.6463L19.3515 13.5044C20.2162 12.6105 20.2162 11.165 19.3515 10.2701C18.4917 9.38023 17.0931 9.37627 16.2294 10.2612L16.2198 10.2711Z", fill: "#B9D1FF" }), jsx("path", { d: "M15.9992 9.92654C17.0243 8.93604 18.641 8.95922 19.6391 9.99217L19.7312 10.0922C20.6519 11.146 20.6216 12.7633 19.6406 13.7797L19.6414 13.7804L16.6461 16.9219L16.6437 16.925L16.6336 16.9351C16.2776 17.2926 15.7023 17.2874 15.3531 16.9226V16.9219L12.3586 13.7804V13.7797C11.3466 12.7297 11.3471 11.0404 12.3609 9.99217L12.3695 9.98357V9.98279L12.4672 9.88748C13.4713 8.95732 15.0109 8.97251 15.9992 9.92654ZM19.0641 10.5476C18.3608 9.81979 17.2216 9.81726 16.5156 10.5406L16.507 10.55L16.5062 10.5492L16.2867 10.7773L15.9984 11.075L15.7109 10.7765L15.4898 10.5476V10.5469C14.7865 9.81999 13.6486 9.81767 12.943 10.5414L12.9422 10.5406L12.9351 10.5476L12.9359 10.5484C12.2663 11.2409 12.2241 12.3379 12.8101 13.082L12.9359 13.2265L12.9383 13.2281L15.9312 16.3695L15.9633 16.3922C15.9974 16.4073 16.0371 16.4004 16.0664 16.3711L16.0695 16.3672L19.0617 13.2281L19.0641 13.2258L19.1898 13.0828C19.7369 12.3893 19.7369 11.3867 19.1898 10.6922L19.0641 10.5476Z", fill: "#B9D1FF" }), jsx("path", { d: "M20 7.19997V3.53134C20 2.81862 20.8617 2.46168 21.3657 2.96565L25.8343 7.43428C26.3383 7.93826 25.9814 8.79997 25.2686 8.79997H21.6C20.7163 8.79997 20 8.08363 20 7.19997Z", fill: "#1F2D94" }), jsx("path", { d: "M20 7.19997V3.53122C20.0001 2.8186 20.8617 2.46174 21.3656 2.9656L25.8344 7.43435C26.3068 7.90689 26.0224 8.69348 25.3977 8.78981L25.2688 8.79997V7.99997L20.8 3.53122V7.19997C20.8 7.6418 21.1582 7.99997 21.6 7.99997V8.79997C20.7163 8.79997 20 8.08363 20 7.19997ZM25.2688 7.99997V8.79997H21.6V7.99997H25.2688Z", fill: "url(#paint7_linear_1609_7317)" }), jsxs("defs", { children: [jsxs("linearGradient", { id: "paint0_linear_1609_7317", x1: "2.8001", y1: "15.5451", x2: "29.6001", y2: "15.5451", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "#333948" }), jsx("stop", { offset: "1", stopColor: "#181C23" })] }), jsxs("linearGradient", { id: "paint1_linear_1609_7317", x1: "16.0001", y1: "3.99998", x2: "16.0001", y2: "29.6", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "#4A5369" }), jsx("stop", { offset: "1", stopColor: "#222832" })] }), jsxs("linearGradient", { id: "paint2_linear_1609_7317", x1: "25.6001", y1: "14.3999", x2: "9.46705", y2: "7.84048", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "#1828C3" }), jsx("stop", { offset: "1", stopColor: "#608CFF" })] }), jsxs("linearGradient", { id: "paint3_linear_1609_7317", x1: "15.2001", y1: "25.9999", x2: "23.4343", y2: "5.74778", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "#1828C3" }), jsx("stop", { offset: "1", stopColor: "#608CFF" })] }), jsxs("linearGradient", { id: "paint4_linear_1609_7317", x1: "30", y1: "14.3999", x2: "2", y2: "14.3999", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "#3B4355" }), jsx("stop", { offset: "0.483985", stopColor: "#6A7387" }), jsx("stop", { offset: "1", stopColor: "#3B4355" })] }), jsxs("linearGradient", { id: "paint5_linear_1609_7317", x1: "1.59977", y1: "24.4001", x2: "30.3998", y2: "24.4001", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "#333948" }), jsx("stop", { offset: "1", stopColor: "#181C23" })] }), jsxs("linearGradient", { id: "paint6_linear_1609_7317", x1: "16.0001", y1: "19.2", x2: "16.0001", y2: "29.6", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "#656D83" }), jsx("stop", { offset: "1", stopColor: "#222832" })] }), jsxs("linearGradient", { id: "paint7_linear_1609_7317", x1: "23.6", y1: "5.19997", x2: "20", y2: "8.79997", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "#5D86FC" }), jsx("stop", { offset: "1", stopColor: "#4667E8" })] })] })] });
var Pp = () => jsxs("svg", { width: "32", height: "32", viewBox: "0 0 32 32", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsx("path", { d: "M7.38623 9.2336C7.38623 4.46801 11.2495 0.604736 16.0151 0.604736C20.7807 0.604736 24.644 4.46801 24.644 9.2336C24.644 13.9992 20.7807 17.8625 16.0151 17.8625C11.2495 17.8625 7.38623 13.9992 7.38623 9.2336Z", fill: "url(#paint0_linear_1609_7349)" }), jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M19.3296 5.18278C19.3806 5.22417 19.3507 5.30493 19.285 5.30493H12.8438C12.778 5.30493 12.7482 5.22417 12.7993 5.18278C13.6911 4.46035 14.8272 4.02759 16.0643 4.02759C17.3016 4.02759 18.4376 4.46035 19.3296 5.18278Z", fill: "white" }), jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M14.0452 10.6322C14.0081 10.5792 13.9483 10.5459 13.8836 10.5459H11.1677C11.1055 10.5459 11.0601 10.605 11.0774 10.6647C11.7036 12.8282 13.6994 14.4099 16.0646 14.4099C18.4298 14.4099 20.4256 12.8282 21.0517 10.6647C21.069 10.605 21.0236 10.5459 20.9614 10.5459H18.2456C18.1809 10.5459 18.1211 10.5792 18.084 10.6322C17.6382 11.2679 16.8999 11.6834 16.0646 11.6834C15.2293 11.6834 14.491 11.2679 14.0452 10.6322Z", fill: "white" }), jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M17.8902 7.56345C17.9277 7.60484 17.9805 7.62978 18.0363 7.62978H20.8773C20.9418 7.62978 20.9874 7.56711 20.9661 7.50639C20.7656 6.93242 20.4672 6.40442 20.0908 5.94243C20.0555 5.89906 20.0022 5.87451 19.9462 5.87451H12.1818C12.1259 5.87451 12.0727 5.89906 12.0373 5.94243C11.661 6.40442 11.3625 6.93242 11.162 7.50639C11.1408 7.56711 11.1864 7.62978 11.2508 7.62978H14.0918C14.1477 7.62978 14.2005 7.60484 14.238 7.56345C14.6889 7.06633 15.34 6.75415 16.0641 6.75415C16.7881 6.75415 17.4392 7.06633 17.8902 7.56345Z", fill: "white" }), jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M18.5077 9.9775C18.4594 9.9775 18.425 9.93038 18.4381 9.88382C18.4973 9.67209 18.5289 9.44887 18.5289 9.21826C18.5289 8.89376 18.4662 8.58388 18.3523 8.30011C18.333 8.25208 18.3676 8.19849 18.4193 8.19849H21.0969C21.1308 8.19849 21.1602 8.22244 21.1664 8.2558C21.2248 8.56772 21.2554 8.88947 21.2554 9.21834C21.2554 9.45516 21.2395 9.68821 21.2089 9.91654C21.2041 9.95154 21.1742 9.9775 21.1389 9.9775H18.5077ZM13.6904 9.88382C13.7034 9.93038 13.6692 9.9775 13.6209 9.9775H10.9896C10.9543 9.9775 10.9243 9.95154 10.9196 9.91654C10.8889 9.68821 10.873 9.45516 10.873 9.21834C10.873 8.88947 10.9036 8.56772 10.9621 8.2558C10.9684 8.22244 10.9976 8.19849 11.0316 8.19849H13.7092C13.7609 8.19849 13.7955 8.25208 13.7762 8.30011C13.6622 8.58388 13.5995 8.89376 13.5995 9.21826C13.5995 9.44887 13.6312 9.67209 13.6904 9.88382Z", fill: "white" }), jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M8.00258 9.2336C8.00258 13.6588 11.5899 17.2461 16.0151 17.2461C20.4403 17.2461 24.0276 13.6588 24.0276 9.2336C24.0276 4.80841 20.4403 1.22108 16.0151 1.22108C11.5899 1.22108 8.00258 4.80841 8.00258 9.2336ZM16.0151 0.604736C11.2495 0.604736 7.38623 4.46801 7.38623 9.2336C7.38623 13.9992 11.2495 17.8625 16.0151 17.8625C20.7807 17.8625 24.644 13.9992 24.644 9.2336C24.644 4.46801 20.7807 0.604736 16.0151 0.604736Z", fill: "url(#paint1_linear_1609_7349)" }), jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M16.4248 19.2514C16.1912 19.0438 15.8393 19.0438 15.6058 19.2514L11.6798 22.7412C11.2562 23.1177 11.5225 23.8182 12.0893 23.8182H13.5494V25.6673C13.5494 26.3481 14.1013 26.9 14.7821 26.9H17.2475C17.9283 26.9 18.4802 26.3481 18.4802 25.6673V23.8182H19.9413C20.508 23.8182 20.7744 23.1177 20.3508 22.7412L16.4248 19.2514ZM14.474 27.5163C13.9634 27.5163 13.5494 27.9302 13.5494 28.4408C13.5494 28.9514 13.9634 29.3654 14.474 29.3654H17.5557C18.0663 29.3654 18.4802 28.9514 18.4802 28.4408C18.4802 27.9302 18.0663 27.5163 17.5557 27.5163H14.474ZM13.5494 30.5981C13.5494 30.2577 13.8254 29.9817 14.1658 29.9817H17.8639C18.2043 29.9817 18.4802 30.2577 18.4802 30.5981C18.4802 30.9385 18.2043 31.2144 17.8639 31.2144H14.1658C13.8254 31.2144 13.5494 30.9385 13.5494 30.5981Z", fill: "url(#paint2_linear_1609_7349)" }), jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M14.1658 23.2018V25.6673C14.1658 26.0077 14.4417 26.2836 14.7821 26.2836H17.2475C17.5879 26.2836 17.8639 26.0077 17.8639 25.6673V23.2018H19.9413L16.0153 19.7121L12.0893 23.2018H14.1658ZM12.0893 23.8182C11.5225 23.8182 11.2562 23.1177 11.6798 22.7412L15.6058 19.2514C15.8393 19.0438 16.1912 19.0438 16.4248 19.2514L20.3508 22.7412C20.7744 23.1177 20.508 23.8182 19.9413 23.8182H18.4802V25.6673C18.4802 26.3481 17.9283 26.9 17.2475 26.9H14.7821C14.1013 26.9 13.5494 26.3481 13.5494 25.6673V23.8182H12.0893ZM14.1658 29.9817C13.8254 29.9817 13.5494 30.2577 13.5494 30.5981C13.5494 30.9385 13.8254 31.2144 14.1658 31.2144H17.8639C18.2043 31.2144 18.4802 30.9385 18.4802 30.5981C18.4802 30.2577 18.2043 29.9817 17.8639 29.9817H14.1658ZM14.474 27.5163C13.9634 27.5163 13.5494 27.9302 13.5494 28.4408C13.5494 28.9514 13.9634 29.3654 14.474 29.3654H17.5557C18.0663 29.3654 18.4802 28.9514 18.4802 28.4408C18.4802 27.9302 18.0663 27.5163 17.5557 27.5163H14.474ZM14.474 28.1327C14.3038 28.1327 14.1658 28.2706 14.1658 28.4408C14.1658 28.611 14.3038 28.749 14.474 28.749H17.5557C17.7259 28.749 17.8639 28.611 17.8639 28.4408C17.8639 28.2706 17.7259 28.1327 17.5557 28.1327H14.474Z", fill: "url(#paint3_linear_1609_7349)" }), jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M8.88568 17.3473C8.87284 17.0263 8.61551 16.7689 8.29446 16.7561L4.99029 16.6239C4.42967 16.6015 4.1331 17.2789 4.52983 17.6756L5.15844 18.3042L3.85097 19.6117C3.36957 20.0931 3.36957 20.8736 3.85097 21.355L4.2868 21.7908C4.76819 22.2722 5.54869 22.2722 6.03009 21.7908L7.33756 20.4833L7.96617 21.1119C8.36291 21.5087 9.04027 21.2121 9.01785 20.6515L8.88568 17.3473ZM2.10768 21.355C2.34838 21.1143 2.73863 21.1143 2.97932 21.355L4.2868 22.6624C4.52749 22.9031 4.52749 23.2934 4.2868 23.5341C4.0461 23.7748 3.65585 23.7748 3.41515 23.5341L2.10768 22.2266C1.86698 21.9859 1.86698 21.5957 2.10768 21.355Z", fill: "url(#paint4_linear_1609_7349)" }), jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M6.03009 18.3042L4.2868 20.0475C4.0461 20.2882 4.0461 20.6785 4.2868 20.9192L4.72262 21.355C4.96332 21.5957 5.35357 21.5957 5.59427 21.355L7.33756 19.6117L8.40199 20.6761L8.26983 17.3719L4.96566 17.2398L6.03009 18.3042ZM8.29446 16.7561L4.99029 16.6239C4.42967 16.6015 4.1331 17.2789 4.52983 17.6756L5.15844 18.3042L3.85097 19.6117C3.36957 20.0931 3.36957 20.8736 3.85097 21.355L4.2868 21.7908C4.76819 22.2722 5.54869 22.2722 6.03009 21.7908L7.33756 20.4833L7.96617 21.1119C8.36291 21.5087 9.04027 21.2121 9.01785 20.6515L8.88568 17.3473C8.87284 17.0263 8.61551 16.7689 8.29446 16.7561ZM2.97932 21.355C2.73863 21.1143 2.34838 21.1143 2.10768 21.355C1.86698 21.5957 1.86698 21.9859 2.10768 22.2266L3.41515 23.5341C3.65585 23.7748 4.0461 23.7748 4.2868 23.5341C4.52749 23.2934 4.52749 22.9031 4.2868 22.6624L2.97932 21.355Z", fill: "url(#paint5_linear_1609_7349)" }), jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M22.921 17.3473C22.9338 17.0263 23.1911 16.7689 23.5122 16.7561L26.8164 16.6239C27.377 16.6015 27.6735 17.2789 27.2768 17.6756L26.6482 18.3042L27.9557 19.6117C28.4371 20.0931 28.4371 20.8736 27.9557 21.355L27.5198 21.7908C27.0384 22.2722 26.2579 22.2722 25.7766 21.7908L24.4691 20.4833L23.8405 21.1119C23.4437 21.5087 22.7664 21.2121 22.7888 20.6515L22.921 17.3473ZM29.699 21.355C29.4583 21.1143 29.068 21.1143 28.8273 21.355L27.5198 22.6624C27.2791 22.9031 27.2791 23.2934 27.5198 23.5341C27.7605 23.7748 28.1508 23.7748 28.3915 23.5341L29.699 22.2266C29.9397 21.9859 29.9397 21.5957 29.699 21.355Z", fill: "url(#paint6_linear_1609_7349)" }), jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M25.7766 18.3042L27.5198 20.0475C27.7605 20.2882 27.7605 20.6785 27.5198 20.9192L27.084 21.355C26.8433 21.5957 26.4531 21.5957 26.2124 21.355L24.4691 19.6117L23.4046 20.6761L23.5368 17.3719L26.841 17.2398L25.7766 18.3042ZM23.5122 16.7561L26.8164 16.6239C27.377 16.6015 27.6735 17.2789 27.2768 17.6756L26.6482 18.3042L27.9557 19.6117C28.4371 20.0931 28.4371 20.8736 27.9557 21.355L27.5198 21.7908C27.0384 22.2722 26.2579 22.2722 25.7766 21.7908L24.4691 20.4833L23.8405 21.1119C23.4437 21.5087 22.7664 21.2121 22.7888 20.6515L22.921 17.3473C22.9338 17.0263 23.1911 16.7689 23.5122 16.7561ZM28.8273 21.355C29.068 21.1143 29.4583 21.1143 29.699 21.355C29.9397 21.5957 29.9397 21.9859 29.699 22.2266L28.3915 23.5341C28.1508 23.7748 27.7605 23.7748 27.5198 23.5341C27.2791 23.2934 27.2791 22.9031 27.5198 22.6624L28.8273 21.355Z", fill: "url(#paint7_linear_1609_7349)" }), jsxs("defs", { children: [jsxs("linearGradient", { id: "paint0_linear_1609_7349", x1: "22.4867", y1: "8.61726", x2: "9.32517", y2: "9.12524", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "#5806D4" }), jsx("stop", { offset: "1", stopColor: "#BB6CED" })] }), jsxs("linearGradient", { id: "paint1_linear_1609_7349", x1: "16.0151", y1: "0.604736", x2: "16.0151", y2: "17.8625", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "#BD6CED" }), jsx("stop", { offset: "1", stopColor: "#5A08DD" })] }), jsxs("linearGradient", { id: "paint2_linear_1609_7349", x1: "20.1752", y1: "20.7365", x2: "11.8545", y2: "20.7365", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "#28303B" }), jsx("stop", { offset: "1", stopColor: "#333948" })] }), jsxs("linearGradient", { id: "paint3_linear_1609_7349", x1: "16.0069", y1: "19.4285", x2: "16.0069", y2: "30.9792", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "#636D85" }), jsx("stop", { offset: "1", stopColor: "#1B2028" })] }), jsxs("linearGradient", { id: "paint4_linear_1609_7349", x1: "11.0242", y1: "20.3888", x2: "5.14058", y2: "14.5052", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "#181C23" }), jsx("stop", { offset: "1", stopColor: "#333948" })] }), jsxs("linearGradient", { id: "paint5_linear_1609_7349", x1: "8.7345", y1: "16.8618", x2: "2.74525", y2: "22.8511", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "#636D85" }), jsx("stop", { offset: "1", stopColor: "#1B2028" })] }), jsxs("linearGradient", { id: "paint6_linear_1609_7349", x1: "20.7824", y1: "20.3888", x2: "26.6661", y2: "14.5052", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "#181C23" }), jsx("stop", { offset: "1", stopColor: "#333948" })] }), jsxs("linearGradient", { id: "paint7_linear_1609_7349", x1: "23.2796", y1: "16.8618", x2: "29.2688", y2: "22.8511", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "#636D85", stopOpacity: "0.411765" }), jsx("stop", { offset: "1", stopColor: "#1B2028" })] })] })] });
var Sp = (e2) => jsxs(d$1, { ...e2, children: [jsxs("g", { id: "Portfolio", children: [jsx("path", { id: "Vector", d: "M8.9688 13.3124C6.3545 14.0269 4.5 16.3001 4.5 18.9999V20.9999C4.5 21.5522 4.9477 21.9999 5.5 21.9999H19.5C20.0523 21.9999 20.5 21.5522 20.5 20.9999V18.9999C20.5 16.3001 18.6455 14.0269 16.0312 13.3124C15.8071 13.2511 15.5869 13.2794 15.375 13.3749C14.4595 13.7875 13.4849 13.9999 12.5 13.9999C11.5151 13.9999 10.5405 13.7875 9.625 13.3749C9.4131 13.2794 9.1929 13.2511 8.9688 13.3124Z", fill: "white", fillOpacity: "0.36" }), jsx("path", { id: "Vector_2", d: "M12.5 2C9.7386 2 7.5 4.2386 7.5 7C7.5 9.7614 9.7386 12 12.5 12C15.2614 12 17.5 9.7614 17.5 7C17.5 4.2386 15.2614 2 12.5 2Z", fill: "url(#paint0_linear_148_26239)" })] }), jsx("defs", { children: jsxs("linearGradient", { id: "paint0_linear_148_26239", x1: "17.5", y1: "7", x2: "7.5", y2: "7", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "#59B0FE" }), jsx("stop", { offset: "1", stopColor: "#26FEFE" })] }) })] });
var kp = (e2) => jsx(d$1, { ...e2, children: jsxs("g", { id: "Portfolio", children: [jsx("path", { id: "Vector", d: "M8.9688 13.3124C6.3545 14.0269 4.5 16.3001 4.5 18.9999V20.9999C4.5 21.5522 4.9477 21.9999 5.5 21.9999H19.5C20.0523 21.9999 20.5 21.5522 20.5 20.9999V18.9999C20.5 16.3001 18.6455 14.0269 16.0312 13.3124C15.8071 13.2511 15.5869 13.2794 15.375 13.3749C14.4595 13.7875 13.4849 13.9999 12.5 13.9999C11.5151 13.9999 10.5405 13.7875 9.625 13.3749C9.4131 13.2794 9.1929 13.2511 8.9688 13.3124Z", fill: "white", fillOpacity: "0.12" }), jsx("path", { id: "Vector_2", d: "M12.5 2C9.7386 2 7.5 4.2386 7.5 7C7.5 9.7614 9.7386 12 12.5 12C15.2614 12 17.5 9.7614 17.5 7C17.5 4.2386 15.2614 2 12.5 2Z", fill: "white", fillOpacity: "0.36" })] }) });
var Ip = (e2) => jsxs(d$1, { ...e2, children: [jsxs("g", { id: "Trading", children: [jsx("path", { id: "Vector 646 (Stroke)", fillRule: "evenodd", clipRule: "evenodd", d: "M2.5 7C2.5 6.44772 2.94772 6 3.5 6H5.66905C7.77663 6 9.72966 7.10579 10.814 8.91303L13.901 14.058C14.6239 15.2628 15.9259 16 17.3309 16H19.5V14L22.5 17L19.5 20V18H17.3309C15.2234 18 13.2703 16.8942 12.186 15.087L9.09902 9.94202C8.37613 8.7372 7.0741 8 5.66905 8H3.5C2.94772 8 2.5 7.55228 2.5 7Z", fill: "url(#paint0_linear_134_17004)" }), jsx("path", { id: "Subtract", fillRule: "evenodd", clipRule: "evenodd", d: "M3.5 18C2.94772 18 2.5 17.5523 2.5 17C2.5 16.4477 2.94772 16 3.5 16H5.66905C7.0741 16 8.37613 15.2628 9.09902 14.058L10.3338 12L11.5 13.9436L10.814 15.087C9.72966 16.8942 7.77663 18 5.66905 18H3.5ZM12.6662 12L13.901 9.94202C14.6239 8.7372 15.9259 8 17.3309 8H19.5V10L22.5 7L19.5 4V6H17.3309C15.2234 6 13.2703 7.10579 12.186 8.91303L11.5 10.0563L12.6662 12Z", fill: "white", fillOpacity: "0.36" })] }), jsx("defs", { children: jsxs("linearGradient", { id: "paint0_linear_134_17004", x1: "22.5", y1: "13", x2: "2.5", y2: "13", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "#59B0FE" }), jsx("stop", { offset: "1", stopColor: "#26FEFE" })] }) })] });
var Np = (e2) => jsx(d$1, { ...e2, children: jsxs("g", { id: "Trading", children: [jsx("path", { id: "Vector 646 (Stroke)", fillRule: "evenodd", clipRule: "evenodd", d: "M2.5 7C2.5 6.44772 2.94772 6 3.5 6H5.66905C7.77663 6 9.72967 7.10579 10.814 8.91303L13.901 14.058C14.6239 15.2628 15.9259 16 17.331 16H19.5V14L22.5 17L19.5 20V18H17.331C15.2234 18 13.2703 16.8942 12.186 15.087L9.09902 9.94202C8.37613 8.7372 7.0741 8 5.66905 8H3.5C2.94772 8 2.5 7.55228 2.5 7Z", fill: "white", fillOpacity: "0.12" }), jsx("path", { id: "Subtract", fillRule: "evenodd", clipRule: "evenodd", d: "M3.5 18C2.94772 18 2.5 17.5523 2.5 17C2.5 16.4477 2.94772 16 3.5 16H5.66905C7.0741 16 8.37613 15.2628 9.09902 14.058L10.3338 12L11.5 13.9437L10.814 15.087C9.72967 16.8942 7.77663 18 5.66905 18H3.5ZM12.6662 12L13.901 9.94202C14.6239 8.7372 15.9259 8 17.331 8H19.5V10L22.5 7L19.5 4V6H17.331C15.2234 6 13.2703 7.10579 12.186 8.91303L11.5 10.0563L12.6662 12Z", fill: "white", fillOpacity: "0.36" })] }) });
var Mp = (e2) => jsxs(d$1, { ...e2, children: [jsx("path", { d: "M18 11H21C22.103 11 23 11.897 23 13V17C23 18.103 22.103 19 21 19H18V17V11Z", fill: "white", fillOpacity: "0.12" }), jsx("path", { d: "M6 9V17V19H3C1.897 19 1 18.103 1 17V11C1 9.897 1.897 9 3 9H6Z", fill: "white", fillOpacity: "0.12" }), jsx("path", { d: "M16 7V17V19H8V17V7C8 5.897 8.897 5 10 5H14C15.103 5 16 5.897 16 7Z", fill: "white", fillOpacity: "0.36" })] });
var Vp = d$1;
Vp.combine = La;
var Xn$1 = (e2) => ["date", "address", "symbol", "status", "txId"].includes(e2), Fp = "base-quote", _p = "yyyy-MM-dd HH:mm:ss", zo$3 = ze__default__default.forwardRef((e2, o2) => {
  let { rule: t, children: r3, prefix: i, symbolElement: n4, formatString: a2, range: s2, capitalize: l2, copyable: u2, copyIconSize: p2, onCopy: g2, showIcon: m2, iconSize: c = "xs", copyIconTestid: x2, isIcon: b2, ...k2 } = e2, f2 = useMemo(() => t === "symbol" && m2 ? jsx(Te$4, { symbol: r3, size: c }) : i, [i, m2, t, c, r3]), T2 = useMemo(() => {
    if (typeof e2.suffix < "u") return e2.suffix;
    if (u2) return jsx("button", { className: "oui-cursor-pointer oui-text-sm", "data-testid": x2, onClick: (M2) => {
      navigator.clipboard.writeText(r3), g2 == null ? void 0 : g2(M2);
    }, children: jsx(bt$5, { size: p2 ?? 12, color: "white" }) });
  }, [e2.suffix, u2, r3]), N2 = useMemo(() => {
    if (typeof r3 > "u") return "--";
    if (typeof t > "u") return r3;
    if (t === "address" || t === "txId") {
      let M2 = r3, [y2, B2] = s2 ?? (t === "address" ? [6, 4] : [6, 6]), U2 = new RegExp(`^(.{${y2}})(.*)(.{${B2}})$`);
      return `${M2.replace(U2, "$1...$3")}`;
    }
    if (t === "date") {
      let M2 = new Date(r3);
      return isValid(M2) ? format(new Date(r3), a2 ?? _p) : "Error: Invalid Date";
    }
    if (t === "symbol") {
      let M2 = r3.split("_"), y2 = M2[0], B2 = M2[1], U2 = M2[2];
      return (a2 ?? Fp).replace("type", y2).replace("base", B2).replace("quote", U2);
    }
    return r3;
  }, [r3, t, a2, s2, n4]), v3 = useMemo(() => typeof T2 > "u" && typeof f2 > "u" ? N2 : jsxs("span", { className: "oui-flex oui-gap-1 oui-items-center", children: [f2, N2, T2] }), [N2, T2, f2]);
  return jsx(ee$3, { ...k2, ref: o2, children: v3 });
});
zo$3.displayName = "FormattedText";
var jn$2 = h$2({ base: "oui-text-transparent oui-bg-clip-text", variants: { color: { primary: "oui-gradient-primary", brand: "oui-gradient-brand", success: "oui-gradient-success", warning: "oui-gradient-warning", danger: "oui-gradient-danger", neutral: "oui-gradient-neutral", inherit: "oui-text-inherit" } } }), Ur$2 = ze__default__default.forwardRef((e2, o2) => {
  let { color: t, className: r3, angle: i, ...n4 } = e2, a2 = pt$6({ angle: i });
  return jsx(ee$3, { ...n4, ref: o2, className: jn$2({ color: t, className: r3 }), style: a2 });
});
Ur$2.displayName = "GradientText";
var Q$1 = ee$3;
Q$1.formatted = zo$3;
Q$1.numeral = qe$6;
Q$1.gradient = Ur$2;
var Xr$2 = forwardRef((e2, o2) => {
  let { clearable: t, onClean: r3, fixClassName: i, helpText: n4, loading: a2, inputMode: s2, containerClassName: l2, onValueChange: u2, onChange: p2, id: g2, formatters: m2, value: c, ...x2 } = e2, [b2, k2] = useState(null), f2 = useRef(null), T2 = useRef(null), N2 = useRef(false), v3 = useMemo(() => m2 ?? [], [m2]);
  useEffect(() => {
    o2 && (typeof o2 == "function" ? o2(f2.current) : o2.current = f2.current);
  }, [f2, o2]);
  let M2 = useCallback((w4) => {
    if (!Array.isArray(v3) || v3.length === 0) return w4;
    if (w4 == null) return "";
    let V2 = 0;
    for (; V2 < v3.length; ) w4 = v3[V2].onRenderBefore(w4, { isFocused: N2.current }), V2++;
    return w4;
  }, [v3]), y2 = useCallback((w4, V2) => {
    if (!Array.isArray(v3) || v3.length === 0) return w4;
    if (w4 == null) return "";
    let O2 = v3.length - 1;
    for (; O2 > -1; ) w4 = v3[O2].onSendBefore(w4, { isFocused: N2.current, originValue: V2 }), O2--;
    return w4;
  }, [v3]), B2 = useMemo(() => typeof c > "u" ? c : M2(c), [c]);
  return useEffect(() => {
    var _a3, _b2;
    if (document.activeElement !== f2.current) return;
    let w4 = `${B2}`.length, V2 = ((_a3 = T2.current) == null ? void 0 : _a3.length) || 0, O2 = b2 ? b2 + (w4 - V2) : 0;
    (_b2 = f2.current) == null ? void 0 : _b2.setSelectionRange(O2, O2);
  }, [B2]), jsx("input", { type: "text", ...x2, ref: f2, onBlur: (w4) => {
    var _a3;
    N2.current = false, (_a3 = x2.onBlur) == null ? void 0 : _a3.call(x2, w4);
  }, onFocus: (w4) => {
    var _a3;
    N2.current = true, (_a3 = x2.onFocus) == null ? void 0 : _a3.call(x2, w4);
  }, onChange: (w4) => {
    var _a3;
    if (w4.target.value.length < ((_a3 = e2.value) == null ? void 0 : _a3.length)) {
      let V2 = w4.target.selectionStart, O2 = K$5(`${e2.value}`, w4.target.value);
      O2 > -1 && `${e2.value}`.at(O2) === "," && (w4.target.value = `${w4.target.value.substring(0, O2 - 1)}${w4.target.value.substring(O2)}`, w4.target.selectionStart = V2 ? V2 - 1 : 0);
    }
    if (typeof p2 == "function" && p2(w4), typeof u2 == "function") {
      let V2 = w4.target.value;
      V2 = y2(V2, String(e2.value)), u2(V2);
    }
    T2.current = w4.target.value, k2(w4.target.selectionStart);
  }, value: B2, id: g2 });
});
Xr$2.displayName = "BaseInput";
var ro$2 = (e2) => {
  let { asChild: o2, as: t = "label" } = e2;
  return jsx(o2 ? Slot : "label", { htmlFor: e2.name, className: e2.className, children: e2.children });
};
var Qn = (e2) => {
  let { prefix: o2, id: t } = e2;
  return typeof o2 > "u" ? null : typeof o2 == "string" ? jsx(ro$2, { name: t, className: e2.className, children: o2 }) : o2;
};
var Jn = (e2) => {
  let { suffix: o2, id: t } = e2;
  return typeof o2 > "u" ? null : typeof o2 == "string" ? jsx(ro$2, { name: t, className: e2.className, children: o2 }) : o2;
};
var os = h$2({ slots: { input: ["oui-w-full oui-bg-transparent", "oui-bg-transparent", "oui-flex-1", "focus-visible:oui-outline-none", "oui-flex", "placeholder:oui-text-base-contrast-20", "placeholder:oui-text-xs", "oui-tabular-nums", "oui-text-white", "autofill:oui-bg-transparent", "oui-input-input", "disabled:oui-cursor-not-allowed", "oui-peer"], box: ["oui-rounded", "oui-bg-base-6", "oui-flex", "oui-items-center", "oui-outline", "oui-outline-offset-0", "oui-outline-1", "oui-outline-transparent", "focus-within:oui-outline-primary-light", "oui-input-root"], additional: ["oui-h-full oui-flex oui-flex-col oui-justify-center oui-px-2 oui-text-base-contrast"], closeButton: ["oui-cursor-pointer", "oui-invisible", "peer-focus:oui-visible"] }, variants: { size: { xs: { input: ["oui-h-6", "oui-text-2xs", "placeholder:oui-text-2xs"], box: ["oui-h-6"], additional: ["oui-text-2xs"] }, sm: { input: ["oui-h-7", "oui-text-2xs", "placeholder:oui-text-2xs"], box: ["oui-h-7"], additional: ["oui-text-2xs"] }, md: { input: ["oui-h-8", "oui-text-2xs", "placeholder:oui-text-2xs"], box: ["oui-h-8"], additional: ["oui-text-2xs"] }, lg: { input: ["oui-h-10", "oui-text-sm", "placeholder:oui-text-sm"], box: ["oui-h-10 oui-rounded-md"], additional: ["oui-text-sm"] }, xl: { input: ["oui-h-12", "oui-text-base", "placeholder:oui-text-base"], box: ["oui-h-12 oui-rounded-md"], additional: ["oui-text-sm"] } }, color: { success: { box: ["oui-outline-success", "focus-within:oui-outline-success"], input: ["oui-text-success"] }, danger: { box: ["oui-outline-danger", "focus-within:oui-outline-danger"], input: ["oui-text-danger"] }, warning: { box: ["oui-outline-warning-darken", "focus-within:oui-outline-warning-darken"], input: ["oui-text-warning-darken"] }, default: { box: ["oui-outline-transparent"] } }, disabled: { true: { input: ["oui-cursor-not-allowed", "oui-text-base-contrast-20"], box: ["oui-bg-base-5"] } }, pl: { true: { box: "oui-pl-3" }, false: { box: "oui-pl-0" } }, pr: { true: { box: "oui-pr-3" }, false: { box: "oui-pr-0" } }, fullWidth: { true: { box: "oui-w-full" } }, align: { center: { input: "oui-text-center" }, left: { input: "oui-text-left" }, right: { input: "oui-text-right" } } }, defaultVariants: { size: "lg" } }, { responsiveVariants: ["md", "lg"] }), he$4 = ze__default__default.forwardRef((e2, o2) => {
  let { size: t, disabled: r3, color: i, suffix: n4, prefix: a2, id: s2, pl: l2, pr: u2, fullWidth: p2, className: g2, classNames: m2, onClear: c, align: x2, ...b2 } = e2, { input: k2, box: f2, additional: T2, closeButton: N2 } = os({ size: t, disabled: r3, color: i, fullWidth: p2, align: x2, pl: typeof a2 > "u" || l2, pr: typeof n4 > "u" || u2 }), v3 = useId(), M2 = typeof c < "u" ? jsx(ts$1, { className: N2({ className: m2 == null ? void 0 : m2.clearButton }), onClick: () => {
    c == null ? void 0 : c();
  }, value: b2.value }) : n4;
  return jsxs("div", { className: f2({ className: cnBase(g2, m2 == null ? void 0 : m2.root) }), children: [jsx(Qn, { id: s2 || v3, prefix: a2, className: T2({ className: cnBase(m2 == null ? void 0 : m2.additional, m2 == null ? void 0 : m2.prefix) }) }), jsx(Xr$2, { ...b2, id: s2 || v3, disabled: r3, ref: o2, className: k2({ align: x2, className: m2 == null ? void 0 : m2.input }) }), jsx(Jn, { id: s2 || v3, suffix: M2, className: T2({ className: cnBase(m2 == null ? void 0 : m2.additional, m2 == null ? void 0 : m2.suffix) }) })] });
}), ts$1 = ze__default__default.forwardRef((e2, o2) => jsx("button", { onMouseDown: (t) => {
  t.preventDefault(), e2.onClick();
}, ref: o2, className: e2.className, children: jsx("svg", { width: "16", height: "16", viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: jsx("path", { d: "M8 1.302a6.667 6.667 0 1 0 0 13.333A6.667 6.667 0 0 0 8 1.302m-2 4c.17 0 .349.057.479.187l1.52 1.521L9.52 5.49a.68.68 0 0 1 .48-.188c.17 0 .348.057.479.187.26.261.26.698 0 .96l-1.52 1.52 1.52 1.52c.26.261.26.698 0 .96a.687.687 0 0 1-.959 0L8 8.926l-1.521 1.521a.686.686 0 0 1-.959 0 .686.686 0 0 1 0-.959l1.521-1.52-1.52-1.52a.686.686 0 0 1 0-.96A.68.68 0 0 1 6 5.302", fill: "#fff", fillOpacity: ".2" }) }) }));
ts$1.displayName = "ClearButton";
he$4.displayName = "Input";
var Qp = h$2({ base: ["oui-z-50", "oui-w-72", "oui-rounded-md", "oui-border", "oui-border-line-6", "oui-p-4", "oui-bg-base-8", "oui-shadow-md", "oui-outline-none", "data-[state=open]:oui-animate-in", "data-[state=closed]:oui-animate-out", "data-[state=closed]:oui-fade-out-0", "data-[state=open]:oui-fade-in-0", "data-[state=closed]:oui-zoom-out-95", "data-[state=open]:oui-zoom-in-95", "data-[side=bottom]:oui-slide-in-from-top-2", "data-[side=left]:oui-slide-in-from-right-2", "data-[side=right]:oui-slide-in-from-left-2", "data-[side=top]:oui-slide-in-from-bottom-2"] }), It$3 = q$4.Root, as$1 = q$4.Trigger, $r$3 = q$4.Anchor, Vo$3 = ze__default.forwardRef(({ className: e2, align: o2 = "center", sideOffset: t = 4, ...r3 }, i) => jsx(q$4.Portal, { children: jsx(q$4.Content, { ref: i, align: o2, sideOffset: t, className: Qp({ className: e2 }), ...r3 }) }));
Vo$3.displayName = q$4.Content.displayName;
var Bo$3 = (e2) => {
  let { arrow: o2, content: t, contentProps: r3, ...i } = e2;
  return jsxs(It$3, { ...i, children: [jsx(as$1, { asChild: true, children: e2.children }), jsxs(Vo$3, { ...r3, children: [t, o2 && jsx(q$4.Arrow, { className: "oui-fill-base-8", width: 10, height: 6 })] })] });
};
var Z$5 = h$2({ slots: { trigger: ["oui-flex", "oui-group", "oui-w-full", "oui-items-center", "oui-justify-between", "oui-whitespace-nowrap", "oui-rounded-md", "oui-px-2", "oui-space-x-2", "oui-shadow-sm", "oui-text-base-contrast-54", "placeholder:oui-text-base-contrast-54", "data-[state=open]:oui-text-base-contrast-80", "focus:oui-outline-none", "focus:oui-ring-1", "focus:oui-ring-ring", "disabled:oui-cursor-not-allowed", "disabled:oui-opacity-50", "[&>span]:oui-line-clamp-1"], scrollUpButton: "oui-flex oui-cursor-default oui-items-center oui-justify-center oui-py-1", scrollDownButton: "oui-flex oui-cursor-default oui-items-center oui-justify-center oui-py-1", content: ["oui-relative", "oui-z-50", "oui-max-h-96", "oui-overflow-hidden", "oui-rounded-md", "oui-bg-base-8", "oui-text-base-contrast", "oui-shadow-md", "data-[state=open]:oui-animate-in", "data-[state=closed]:aoui-nimate-out", "data-[state=closed]:oui-fade-out-0", "data-[state=open]:oui-fade-in-0", "data-[state=closed]:oui-zoom-out-95", "data-[state=open]:oui-zoom-in-95", "data-[side=bottom]:oui-slide-in-from-top-2", "data-[side=left]:oui-slide-in-from-right-2", "data-[side=right]:oui-slide-in-from-left-2", "data-[side=top]:oui-slide-in-from-bottom-2"], viewport: ["oui-p-1"], label: "oui-px-2 oui-py-1.5 oui-text-sm oui-font-semibold", item: ["oui-option-item", "oui-relative", "oui-flex", "oui-cursor-default", "oui-select-none", "oui-items-center", "oui-rounded-sm", "oui-py-1", "oui-pl-2", "oui-pr-8", "oui-text-sm", "oui-text-base-contrast-54", "oui-outline-none", "hover:oui-bg-base-6", "hover:oui-rounded", "focus:oui-bg-accent", "focus:oui-text-accent-foreground", "data-[state=checked]:oui-bg-base-5", "data-[state=checked]:oui-text-base-contrast-80", "data-[disabled]:oui-pointer-events-none", "data-[disabled]:oui-opacity-50"], separator: "-oui-mx-1 oui-my-1 oui-h-px oui-bg-muted", icon: "" }, variants: { variant: { outlined: { trigger: ["oui-border oui-border-line-6 oui-bg-line-4"] }, contained: { trigger: ["oui-bg-base-4"] }, text: { trigger: [] } }, position: { popper: { content: ["data-[side=bottom]:oui-translate-y-1", "data-[side=left]:-oui-translate-x-1", "data-[side=right]:oui-translate-x-1", "data-[side=top]:-oui-translate-y-1"], viewport: "oui-h-[var(--radix-select-trigger-height)] oui-w-full oui-min-w-[var(--radix-select-trigger-width)]" }, "item-aligned": { content: "", viewport: "" } }, size: { xs: { trigger: ["oui-h-6", "oui-text-2xs"], item: ["oui-h-6", "oui-text-2xs"], icon: ["oui-w-3", "oui-h-3"] }, sm: { trigger: ["oui-h-7", "oui-text-2xs"], item: ["oui-h-7", "oui-text-2xs"], icon: ["oui-w-4", "oui-h-4"] }, md: { trigger: ["oui-h-8", "oui-text-xs"], item: ["oui-h-7", "oui-text-xs"], icon: ["oui-w-4", "oui-h-4"] }, lg: { trigger: ["oui-h-10", "oui-text-sm", "oui-px-3"], item: ["oui-h-8", "oui-text-2xs"], icon: ["oui-w-5", "oui-h-5"] }, xl: { trigger: ["oui-h-12", "oui-text-2xs", "oui-px-3"], item: ["oui-h-12", "oui-text-2xs"], icon: ["oui-w-6", "oui-h-6"] } }, error: { true: { trigger: ["oui-border-danger", "focus:oui-ring-danger", "focus:oui-ring-ring-danger"] } } }, defaultVariants: { size: "lg", variant: "outlined" } }, { responsiveVariants: ["md", "lg"] }), qr = P$5.Root, Kr$4 = P$5.Group, Qr$3 = P$5.Value, Nt$1 = ze__default.forwardRef(({ className: e2, children: o2, size: t, error: r3, variant: i, asChild: n4, showCaret: a2 = true, ...s2 }, l2) => {
  let { trigger: u2 } = Z$5({ size: t, error: r3, variant: i });
  return n4 ? jsx(P$5.Trigger, { ref: l2, className: u2({ className: e2 }), asChild: n4, ...s2, children: o2 }) : jsxs(P$5.Trigger, { ref: l2, className: u2({ className: e2 }), asChild: n4, ...s2, children: [o2, jsx(Fragment$1, { children: a2 && jsx(P$5.Icon, { asChild: true, className: "oui-transition-transform group-data-[state=open]:oui-rotate-180 group-data-[state=closed]:oui-rotate-0", children: jsx(oe$7, { size: 12, className: "oui-text-inherit", opacity: 1 }) }) })] });
});
Nt$1.displayName = P$5.Trigger.displayName;
var ns$1 = ze__default.forwardRef(({ className: e2, ...o2 }, t) => {
  let { scrollUpButton: r3 } = Z$5();
  return jsx(P$5.ScrollUpButton, { ref: t, className: r3({ className: e2 }), ...o2, children: jsx(vt$4, { size: 16, color: "white" }) });
});
ns$1.displayName = P$5.ScrollUpButton.displayName;
var ss = ze__default.forwardRef(({ className: e2, ...o2 }, t) => {
  let { scrollDownButton: r3 } = Z$5();
  return jsx(P$5.ScrollDownButton, { ref: t, className: r3({ className: e2 }), ...o2, children: jsx(oe$7, { size: 16, color: "white" }) });
});
ss.displayName = P$5.ScrollDownButton.displayName;
var Tt$2 = ze__default.forwardRef(({ className: e2, children: o2, position: t = "popper", ...r3 }, i) => {
  let { content: n4, viewport: a2 } = Z$5({ position: t, className: e2 });
  return jsx(P$5.Portal, { children: jsx(P$5.Content, { ref: i, className: n4({ className: e2 }), position: t, ...r3, children: jsx(P$5.Viewport, { className: a2(), children: o2 }) }) });
});
Tt$2.displayName = P$5.Content.displayName;
var ls$1 = ze__default.forwardRef(({ className: e2, ...o2 }, t) => {
  let { label: r3 } = Z$5();
  return jsx(P$5.Label, { ref: t, className: r3({ className: e2 }), ...o2 });
});
ls$1.displayName = P$5.Label.displayName;
var Lo$2 = ze__default.forwardRef(({ className: e2, children: o2, size: t, ...r3 }, i) => {
  let { item: n4 } = Z$5({ size: t });
  return jsx(P$5.Item, { ref: i, className: n4({ className: e2 }), ...r3, children: jsx(P$5.ItemText, { children: o2 }) });
});
Lo$2.displayName = P$5.Item.displayName;
var us$2 = ze__default.forwardRef(({ className: e2, ...o2 }, t) => {
  let { separator: r3 } = Z$5();
  return jsx(P$5.Separator, { ref: t, className: r3({ className: e2 }), ...o2 });
});
us$2.displayName = P$5.Separator.displayName;
var Jr$2 = h$2({ slots: { root: "oui-relative oui-overflow-hidden oui-scroll-area-root", viewport: "oui-h-full oui-w-full oui-rounded-[inherit]", bar: ["oui-flex", "oui-touch-none", "oui-select-none", "oui-transition-colors"], tumb: "oui-relative oui-flex-1 oui-rounded-full oui-bg-base-10" }, variants: { orientation: { vertical: { bar: "oui-h-full oui-w-2 oui-border-l oui-border-l-transparent oui-p-[1px]" }, horizontal: { bar: "oui-h-2 oui-flex-col oui-border-t oui-border-t-transparent oui-p-[1px]" } } } }), io$3 = ze__default__default.forwardRef(({ className: e2, children: o2, orientation: t = "vertical", ...r3 }, i) => {
  let { root: n4, viewport: a2, bar: s2 } = Jr$2({ orientation: t });
  return jsxs(J$3.Root, { ref: i, className: n4({ className: e2 }), ...r3, children: [jsx(J$3.Viewport, { className: a2(), children: o2 }), jsx(ei$3, { orientation: t }), jsx(J$3.Corner, {})] });
});
io$3.displayName = J$3.Root.displayName;
var ei$3 = ze__default__default.forwardRef(({ className: e2, orientation: o2 = "vertical", ...t }, r3) => {
  let { bar: i, tumb: n4 } = Jr$2({ className: e2, orientation: o2 });
  return jsx(J$3.ScrollAreaScrollbar, { ref: r3, orientation: o2, className: i({ className: e2 }), ...t, children: jsx(J$3.ScrollAreaThumb, { className: n4() }) });
});
ei$3.displayName = J$3.ScrollAreaScrollbar.displayName;
var Mt$4 = (e2) => {
  let { options: o2, variant: t, valueFormatter: r3, ...i } = e2, [n4, a2] = useState(""), [s2, l2] = useState(e2.value ?? ""), { trigger: u2 } = Z$5({ size: e2.size, variant: t }), [p2, g2] = useState(() => typeof e2.value > "u" ? -1 : o2.findIndex((f2) => f2.value === e2.value)), [m2, c] = useState(false), x2 = useRef(null), b2 = () => {
    c(true);
  }, k2 = n4 ? o2.filter((f2) => {
    if (f2.value.toLowerCase().includes(n4.toLowerCase())) return true;
  }) : o2;
  return jsxs(It$3, { open: m2, children: [jsx($r$3, { children: jsx(Fo$3, { ref: x2, size: e2.size, autoComplete: "off", onFocus: b2, onBlur: () => {
    c(false);
  }, placeholder: e2.placeholder ?? "All", value: m2 ? n4 : typeof r3 == "function" ? r3(s2 ?? "", { placeholder: e2.placeholder }) : s2, onValueChange: (f2) => {
    a2(f2);
  }, classNames: { root: u2({ className: "oui-w-24 oui-peer" }), input: "oui-text-base-contrast-54 oui-font-semibold" }, "data-state": m2 ? "open" : "closed", suffix: jsx(P$5.Icon, { onMouseDown: (f2) => {
    var _a3, _b2;
    f2.preventDefault(), m2 ? (_a3 = x2.current) == null ? void 0 : _a3.blur() : (_b2 = x2.current) == null ? void 0 : _b2.focus();
  }, asChild: true, className: "oui-transition-transform peer-data-[state=open]:oui-rotate-180 peer-data-[state=closed]:oui-rotate-0 oui-mx-2", children: jsx(oe$7, { size: 12, className: "oui-text-inherit" }) }) }) }), jsx(Vo$3, { onOpenAutoFocus: (f2) => {
    f2.preventDefault(), a2("");
  }, className: "oui-w-[var(_--radix-popover-trigger-width)] oui-p-1", children: jsx(io$3, { className: "oui-h-[200px]", children: k2.map((f2, T2) => jsx(rd, { option: f2, size: e2.size, activated: p2 === T2, onClick: (N2) => {
    var _a3, _b2;
    l2(N2.value), g2(T2), (_a3 = e2.onValueChange) == null ? void 0 : _a3.call(e2, N2.value), (_b2 = x2.current) == null ? void 0 : _b2.blur();
  } }, T2)) }) })] });
}, rd = (e2) => {
  let { item: o2 } = Z$5({ size: e2.size });
  return jsx("button", { className: o2({ className: `oui-text-base-contrast-54 oui-w-full ${e2.activated ? "oui-bg-base-7" : ""}` }), onMouseDown: (t) => {
    t.preventDefault(), e2.onClick(e2.option);
  }, children: e2.option.label });
};
var Vt$4 = (e2) => {
  let { children: o2, size: t, error: r3, placeholder: i, variant: n4, contentProps: a2, valueFormatter: s2, showCaret: l2, maxHeight: u2, testid: p2, classNames: g2, ...m2 } = e2;
  return jsxs(qr, { ...m2, children: [jsx(Nt$1, { size: t, error: r3, variant: n4, showCaret: l2, className: cnBase("oui-font-semibold focus:oui-ring-transparent oui-cursor-pointer", g2 == null ? void 0 : g2.trigger), "data-testid": p2, children: typeof s2 == "function" ? s2(e2.value || e2.defaultValue, { placeholder: i }) : jsx(Qr$3, { placeholder: i }) }), jsx(Tt$2, { ...a2, children: jsx(io$3, { children: jsxs("div", { style: { maxHeight: u2 }, children: [" ", o2] }) }) })] });
};
var sd = (e2, o2) => jsxs(Lo$2, { value: e2.value, className: cnBase("oui-relative oui-cursor-pointer"), "data-testid": `oui-testid-selectItem-${e2.value.toLowerCase().replace(" ", "_")}`, children: [e2.label, o2 == e2.value && jsx(W$2, { width: 4, height: 4, gradient: "brand", r: "full", className: "oui-absolute oui-right-2 oui-top-1/2 -oui-translate-y-1/2" })] }, e2.value), ao$3 = (e2) => {
  let { children: o2, options: t, optionRenderer: r3 = sd, currentValue: i, ...n4 } = e2;
  return jsx(Vt$4, { ...n4, children: jsx(Kr$4, { children: t.map((a2, s2) => ze__default__default.cloneElement(r3(a2, i), { size: e2.size, key: s2, index: s2 })) }) });
};
var ms = (e2) => {
  let { tokens: o2, showIcon: t = true, ...r3 } = e2, { icon: i } = Z$5(), n4 = useMemo(() => o2.map((u2) => ({ ...u2, label: u2.name, value: u2.name })), [o2]), a2 = n4.length > 1;
  return jsx(ao$3, { ...r3, showCaret: a2, options: n4, valueFormatter: t ? (u2) => typeof e2.valueFormatter == "function" ? e2.valueFormatter(u2, {}) : jsxs(z$3, { gapX: 1, children: [jsx(Te$4, { name: u2, className: i({ size: e2.size }) }), jsx(Q$1, { weight: "semibold", intensity: 54, children: u2 })] }) : void 0, optionRenderer: (u2) => typeof e2.optionRenderer == "function" ? e2.optionRenderer(u2) : jsx(md, { ...u2 }), maxHeight: 254 });
}, md = (e2) => {
  let { size: o2, label: t, value: r3 } = e2, { item: i, icon: n4 } = Z$5();
  return jsxs(SelectItem, { value: r3, className: i({ size: o2, className: "oui-space-x-1 oui-flex oui-flex-row oui-items-center" }), children: [jsx(Te$4, { name: r3, className: n4({ size: o2 }) }), jsx(SelectItemText, { children: t }), jsx(ItemIndicator, {})] });
};
var Be$6 = Vt$4;
Be$6.options = ao$3;
Be$6.combine = Mt$4;
Be$6.tokens = ms;
var ri$4 = forwardRef((e2, o2) => {
  let { tokens: t, ...r3 } = e2, [i, n4] = useState(t[0]), a2 = useMemo(() => e2.tokens.map((l2) => ({ name: l2 })), [e2.tokens]), s2 = useRef(null);
  return jsx(he$4, { ref: (l2) => {
    s2.current = l2, o2 && (typeof o2 == "function" ? o2(l2) : o2.current = l2);
  }, autoComplete: "off", ...r3, suffix: jsx("div", { className: "oui-max-w-fit", children: jsx(Be$6.tokens, { disabled: r3.disabled, variant: "text", tokens: a2, value: i, size: r3.size, onValueChange: (l2) => n4(l2), showIcon: r3.align !== "right", contentProps: { align: "end", onCloseAutoFocus: (l2) => {
    var _a3;
    l2.preventDefault(), (_a3 = s2.current) == null ? void 0 : _a3.focus();
  } } }) }) });
});
ri$4.displayName = "QuantityInput";
var wd = X$3.Provider, ai$1 = X$3.Root, ni$3 = X$3.Trigger, Bt$4 = X$3.Portal, vd = h$2({ base: ["oui-z-50", "oui-overflow-hidden", "oui-rounded-md", "oui-bg-base-8", "oui-px-2", "oui-py-1", "oui-text-xs", "oui-text-base-contrast", "oui-animate-in", "oui-fade-in-0", "oui-zoom-in-95", "data-[state=closed]:oui-animate-out", "data-[state=closed]:oui-fade-out-0", "data-[state=closed]:oui-zoom-out-95", "data-[side=bottom]:oui-slide-in-from-top-2", "data-[side=left]:oui-slide-in-from-right-2", "data-[side=right]:oui-slide-in-from-left-2", "data-[side=top]:oui-slide-in-from-bottom-2"] }), Ao$5 = ze__default.forwardRef(({ className: e2, sideOffset: o2 = 4, ...t }, r3) => jsx(X$3.Content, { ref: r3, sideOffset: o2, className: vd({ className: e2 }), ...t }));
Ao$5.displayName = X$3.Content.displayName;
var Lt$3 = (e2) => {
  let { className: o2, ...t } = e2;
  return jsx(X$3.Arrow, { width: 12, height: 6, ...t, className: cn$2("oui-fill-base-8", o2)({ twMerge: true }) });
}, xs = ze__default.forwardRef(({ children: e2, content: o2, defaultOpen: t, open: r3, onOpenChange: i, delayDuration: n4, disableHoverableContent: a2, arrow: s2, ...l2 }, u2) => {
  let { className: p2, ...g2 } = s2 || {};
  return jsxs(X$3.Root, { defaultOpen: t, open: r3, onOpenChange: i, delayDuration: n4, disableHoverableContent: a2, children: [jsx(X$3.Trigger, { asChild: true, children: e2 }), jsx(Bt$4, { children: jsxs(Ao$5, { ref: u2, ...l2, children: [o2, jsx(Lt$3, { ...s2 })] }) })] });
});
xs.displayName = "Tooltip";
var si$3 = forwardRef((e2, o2) => {
  let { tooltip: t, tooltipProps: r3, triggerClassName: i, ...n4 } = e2, [a2, s2] = useState(false);
  return useEffect(() => {
    s2(typeof t < "u" && t !== "" && t !== null);
  }, [t]), jsxs(ai$1, { open: a2, children: [jsx(ni$3, { asChild: true, children: jsx("div", { className: i, children: jsx(he$4, { ...n4, ref: o2 }) }) }), jsx(Bt$4, { children: jsxs(Ao$5, { ...r3 == null ? void 0 : r3.content, children: [e2.tooltip, jsx(Lt$3, { ...r3 == null ? void 0 : r3.arrow })] }) })] });
});
si$3.displayName = "InputWithTooltip";
var li$3 = {};
vr$4(li$3, { createRegexInputFormatter: () => vs$1, currencyFormatter: () => hs$1, decimalPointFormatter: () => Ss$1, dpFormatter: () => ys, identifierFormatter: () => Ps$2, numberFormatter: () => ws$1, rangeFormatter: () => Cs$1 });
var hs$1 = { onRenderBefore: function(e2, o2) {
  return e2 == null ? "" : d$2(e2);
}, onSendBefore: function(e2, o2) {
  return e2 == null ? "" : (e2 = e2.replace(/,/g, ""), e2);
} };
var ws$1 = { onRenderBefore: function(e2, o2) {
  return "" + e2;
}, onSendBefore: function(e2, o2) {
  return e2.startsWith(".") ? `0${e2}` : e2 === "00" ? "0" : (e2 = e2.replace(/[^\d.]/g, "").replace(".", "$#$").replace(/\./g, "").replace("$#$", "."), e2);
} };
var vs$1 = (e2, o2) => ({ onRenderBefore: (t, r3) => typeof e2 == "function" ? e2(String(t)) : `${t}`.replace(e2, ""), onSendBefore: (t, r3) => (o2 == null ? void 0 : o2(t, r3)) || t });
var ys = (e2, o2) => {
  let t = (r3, i) => (typeof r3 == "number" && (r3 = r3.toString()), !r3 || r3.endsWith(".") ? r3 : kd(r3, e2));
  return { onRenderBefore: t, onSendBefore: t };
};
function kd(e2, o2) {
  let t = e2.indexOf(".");
  if (t === -1 || o2 <= 0) return e2.split(".")[0];
  let r3 = t + o2 + 1;
  return e2.substring(0, r3);
}
var Cs$1 = (e2) => {
  let o2 = (t, r3) => {
    if (typeof t == "number" && (t = t.toString()), !t || t.endsWith(".")) return t;
    let i = e2.max ?? Number(t), n4 = e2.min ?? Number(t), a2 = Number(t);
    return `${a2 < n4 ? n4 : a2 > i ? i : a2}`;
  };
  return { onRenderBefore: o2, onSendBefore: o2 };
};
var Ps$2 = () => {
  let e2 = "+", o2 = "-";
  return { onRenderBefore: (t, r3) => {
    if (typeof t == "number" && (t = t.toString()), !t || t.endsWith(".")) return t;
    let i = Number(t);
    if (i) {
      if (i > 0 && !t.startsWith(e2)) return e2 + t;
      if (i < 0 && !t.startsWith(o2)) return o2 + t;
    }
    return t;
  }, onSendBefore: (t, r3) => {
    if (typeof t == "number" && (t = t.toString()), !t || t.endsWith(".")) return t;
    let i = Number(t);
    return i && i > 0 ? t.replace(e2, "") : t;
  } };
};
var Ss$1 = { onRenderBefore: function(e2, o2) {
  return String(e2);
}, onSendBefore: function(e2, o2) {
  return e2 == null ? "" : Id(e2, o2 == null ? void 0 : o2.originValue);
} }, Id = (e2, o2) => {
  if (e2 == null) return "";
  if (e2.endsWith(",")) return e2.slice(0, -1) + ".";
  if (e2.startsWith(",")) return e2.slice(0, 1) + ".";
  let t = d$2(o2);
  return o2 && e2.length > t.length && e2.length - t.length === 1 ? Nd(e2, t) : e2;
}, Nd = (e2, o2) => {
  if (e2.length <= o2.length) return e2;
  for (let t = 0; t < o2.length; t++) if (e2[t] !== o2[t]) {
    let r3 = e2[t], i = r3 === "," ? "." : r3;
    return e2.slice(0, t) + i + e2.slice(t + 1);
  }
  return e2;
};
var zd = tv({ base: ["oui-text-xs", "oui-text-base-contrast-36", "oui-mt-1", "oui-list-disc", "oui-list-inside", "oui-list-item"], variants: { color: { success: ["oui-text-success"], danger: ["oui-text-danger"], warning: ["oui-text-warning-darken"], default: ["oui-text-base-contrast-54"] } } }), Et$3 = ze__default__default.forwardRef((e2, o2) => {
  let { className: t, asChild: r3, color: i, ...n4 } = e2;
  return jsx(r3 ? Slot : "div", { ref: o2, className: zd({ className: t, color: i }), ...n4 });
});
Et$3.displayName = "InputHelpText";
var Ld = h$2({ slots: { root: "oui-flex", label: "oui-text-sm oui-font-semibold", input: [] }, variants: { direction: { column: { root: "oui-flex-col oui-space-y-1" }, row: { root: "oui-flex-row oui-space-x-3 " } } }, defaultVariants: { direction: "column" } }), ui$3 = ze__default__default.forwardRef((e2, o2) => {
  var _a3;
  let { label: t, helpText: r3, direction: i, className: n4, ...a2 } = e2, { root: s2, label: l2 } = Ld({ direction: i });
  return jsxs("div", { className: s2({ className: n4, direction: i }), children: [jsx(Is$1, { className: cnBase((_a3 = e2.classNames) == null ? void 0 : _a3.label) || l2(), children: t }), jsxs("div", { children: [jsx(he$4, { ...a2 }), ((r3 == null ? void 0 : r3.length) || 0 > 0) && jsx(Et$3, { color: a2.color, children: r3 })] })] });
});
ui$3.displayName = "TextField";
var Is$1 = ze__default__default.forwardRef((e2, o2) => {
  let { asChild: t = false, className: r3, ...i } = e2;
  return jsx(t ? Slot : "label", { className: r3, ref: o2, ...i, children: e2.children });
});
Is$1.displayName = "InputLabel";
var Fo$3 = he$4;
Fo$3.token = ri$4;
Fo$3.tooltip = si$3;
var Fd = tv({ base: ["peer", "oui-h-3", "oui-w-3", "oui-shrink-0", "oui-rounded-sm", "oui-border", "focus-visible:oui-outline-none", "disabled:oui-cursor-not-allowed", "disabled:oui-opacity-50"], variants: { color: { primary: "oui-border-primary data-[state=checked]:oui-text-base-contrast", white: "oui-border-base-contrast-54 " }, variant: { checkBox: "data-[state=checked]:oui-border-none", radio: "oui-rounded-full data-[state=checked]:oui-border-base-contrast-20 data-[state=checked]:oui-bg-transparent" } }, compoundVariants: [{ color: "primary", variant: "radio", className: "data-[state=checked]:oui-border-parimary data-[state=checked]:!oui-text-parimary" }], defaultVariants: { color: "white" } }), pi$1 = ze__default.forwardRef(({ className: e2, color: o2 = "white", variant: t = "checkBox", ...r3 }, i) => jsx(Ho$4.Root, { ref: i, className: Fd({ color: o2, className: e2, variant: t }), ...r3, children: jsx(Ho$4.Indicator, { className: cnBase("oui-flex oui-items-center oui-justify-center oui-text-current", r3.indicatorClassName), children: t === "checkBox" ? jsx(_d$1, { className: cnBase(o2 === "primary" ? "oui-text-primary" : "oui-text-white") }) : jsx("div", { className: cnBase("oui-w-[6px] oui-h-[6px] oui-rounded-full", o2 === "primary" ? "oui-bg-primary" : "oui-bg-base-contrast-80") }) }) }));
pi$1.displayName = Ho$4.Root.displayName;
var _d$1 = (e2) => jsx("svg", { width: "12", height: "12", viewBox: "0 0 12 12", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...e2, children: jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M3.078.71A2.333 2.333 0 0 0 .745 3.041v5.834a2.333 2.333 0 0 0 2.333 2.333H8.91a2.333 2.333 0 0 0 2.334-2.333V3.042A2.333 2.333 0 0 0 8.91.71zm5.83 2.555a.7.7 0 0 1 .488-.182c.174 0 .355.056.488.182a.643.643 0 0 1 0 .93L5.129 8.728a.723.723 0 0 1-.975 0L2.115 6.785a.644.644 0 0 1 0-.93.724.724 0 0 1 .977 0l1.55 1.476z", fillOpacity: ".8" }) });
var Hd$1 = tv({ slots: { root: ["peer", "oui-inline-flex", "oui-h-[16px]", "oui-w-[28px]", "oui-shrink-0", "oui-cursor-pointer", "oui-items-center", "oui-rounded-full", "oui-border-transparent", "oui-shadow-sm", "oui-transition-colors", "focus-visible:oui-outline-none", "focus-visible:oui-ring-2", "focus-visible:oui-ring-ring", "focus-visible:oui-ring-offset-2", "focus-visible:oui-ring-offset-background", "disabled:oui-cursor-not-allowed", "disabled:oui-opacity-50", "data-[state=checked]:oui-bg-primary-darken", "data-[state=unchecked]:oui-bg-input"], thumb: ["oui-pointer-events-none", "oui-block", "oui-h-[10px]", "oui-w-[10px]", "oui-rounded-full", "oui-bg-white/80", "oui-shadow-lg", "oui-ring-0", "oui-transition-transform", "data-[state=checked]:oui-translate-x-[15px]", "data-[state=unchecked]:oui-translate-x-[3px]"] }, variants: { color: { primary: { root: ["data-[state=checked]:oui-bg-primary-darken", "data-[state=unchecked]:oui-bg-base-1"] }, success: { root: ["data-[state=checked]:oui-bg-success", "data-[state=unchecked]:oui-bg-success"] }, danger: { root: ["data-[state=checked]:oui-bg-danger", "data-[state=unchecked]:oui-bg-danger"] }, warning: { root: ["data-[state=checked]:oui-bg-warning-darken", "data-[state=unchecked]:oui-bg-warning-darken"] } } }, defaultVariants: { color: "primary" } }), di$2 = ze__default__default.forwardRef(({ className: e2, color: o2, ...t }, r3) => {
  let { root: i, thumb: n4 } = Hd$1({ className: e2, color: o2 });
  return jsx(Go$2.Root, { className: i({ className: e2 }), ...t, ref: r3, children: jsx(Go$2.Thumb, { className: n4() }) });
});
di$2.displayName = Go$2.Root.displayName;
var Gd = h$2({ base: "oui-inline-flex oui-items-center oui-rounded-md oui-font-semibold oui-transition-colors focus:oui-outline-none focus:oui-ring-2 focus:oui-ring-ring focus:oui-ring-offset-2", variants: { variant: { contained: "", text: "" }, color: { primary: "", primaryLight: "", secondary: "", danger: "", buy: "", success: "", warning: "", sell: "", neutral: "" }, size: { xs: "oui-px-2 oui-py-0.5 oui-text-2xs oui-rounded oui-h-[18px]", sm: "oui-px-2 oui-py-0.5 oui-text-2xs oui-rounded", md: "oui-px-2 oui-py-0.5 oui-text-sm", lg: "oui-px-2 oui-py-1 oui-text-base" } }, compoundVariants: [{ variant: "contained", color: "primary", className: ["oui-bg-primary/15", "oui-text-primary"] }, { variant: "contained", color: "primaryLight", className: ["oui-bg-primary-light/15", "oui-text-primary-light"] }, { variant: "contained", color: "danger", className: ["oui-bg-danger/15", "oui-text-danger"] }, { variant: "contained", color: "sell", className: ["oui-bg-danger/15", "oui-text-danger"] }, { variant: "contained", color: "success", className: ["oui-bg-success/15", "oui-text-success"] }, { variant: "contained", color: "buy", className: ["oui-bg-success/15", "oui-text-success"] }, { variant: "contained", color: "warning", className: ["oui-bg-warning-darken/15", "oui-text-warning-darken"] }, { variant: "contained", color: "neutral", className: ["oui-bg-line", "oui-text-base-contrast-36"] }, { variant: "text", color: "primary", className: ["oui-text-primary"] }, { variant: "text", color: "danger", className: ["oui-text-danger"] }, { variant: "text", color: "success", className: ["oui-text-success"] }, { variant: "text", color: "warning", className: ["oui-text-warning-darken"] }, { variant: "text", color: "neutral", className: ["oui-text-base-contrast-36"] }], defaultVariants: { variant: "contained", color: "primary", size: "md" } });
function Wd({ className: e2, variant: o2, color: t, size: r3, ...i }) {
  return jsx("div", { className: Gd({ variant: o2, className: e2, color: t, size: r3 }), ...i });
}
var Ds = ze__default__default.forwardRef(({ src: e2, alt: o2, href: t }, r3) => jsx("div", { className: "logo oui-px-3", ref: r3, children: jsx("a", { href: t ?? "/", children: jsx("img", { src: e2, alt: o2, className: "oui-object-contain oui-h-8 oui-py-2" }) }) }));
Ds.displayName = "LogoElement";
function Ms$1(e2) {
  let { dataSource: o2, loading: t, ignoreLoadingCheck: r3 } = e2, [i, n4] = useState(false);
  return useEffect(() => {
    i || (r3 || t || Array.isArray(o2)) && n4(true);
  }, [t, r3, o2, i]), i;
}
function Ls$2(e2) {
  let o2 = useRef(null), [t, r3] = useState(false), [i, n4] = useState(false);
  return useEffect(() => {
    o2.current && o2.current.addEventListener("scroll", function(a2) {
      r3(o2.current.scrollLeft > 0), n4(!Bs(o2.current));
    });
  }, [o2]), useEffect(() => {
    if (!o2.current) return;
    let a2 = $d(o2.current), s2 = Bs(o2.current);
    n4(a2 && !s2);
  }, [o2, ...e2]), { scrollRef: o2, showLeftShadow: t, showRightShadow: i };
}
function Bs(e2) {
  return e2.scrollLeft + e2.clientWidth >= e2.scrollWidth;
}
function $d(e2) {
  return e2.scrollWidth > e2.clientWidth;
}
function Es(e2) {
  let { dataSource: o2, loading: t } = e2, r3 = useRef(false), i = useMemo(() => t && !(o2 == null ? void 0 : o2.length) ? r3.current : !!(o2 == null ? void 0 : o2.length), [t, o2]);
  return useEffect(() => {
    i && (r3.current = true);
  }, [i]), i;
}
function Fs(e2) {
  let { loading: o2, dataSource: t, pagination: r3, rows: i } = e2, n4 = useRef(false), a2 = useMemo(() => o2 && !(t == null ? void 0 : t.length) ? n4.current : !!(r3 && (t == null ? void 0 : t.length) && (i == null ? void 0 : i.length)), [o2, r3, t, i]);
  return useEffect(() => {
    a2 && (n4.current = true);
  }, [a2]), a2;
}
function _s$1(e2) {
  let { onSort: o2, initialSort: t } = e2, [r3, i] = useState(t ? [{ id: t.sortKey, desc: t.sort === "desc" }] : []);
  return useEffect(() => {
    let { id: n4, desc: a2 } = r3[0] || {};
    o2 == null ? void 0 : o2(n4 ? { sortKey: n4, sort: a2 ? "desc" : "asc" } : void 0);
  }, [r3, o2]), [r3, i];
}
function As$1(e2) {
  let o2 = useRef(null);
  return useEffect(() => {
    if (!o2.current) return;
    let t = window.getComputedStyle(o2.current).backgroundColor;
    o2.current.style.setProperty("--oui-table-background-color", t);
  }, e2), o2;
}
var _t$2 = tv({ variants: { align: { left: "oui-text-left", center: "oui-text-center", right: "oui-text-right" } }, defaultVariants: { align: "left" } });
var Hs$1 = (e2) => {
  let { cell: o2 } = e2, { original: t, index: r3 } = o2.row, { formatter: i, render: n4, rule: a2, textProps: s2, numeralProps: l2 } = o2.column.columnDef.meta || {}, u2 = o2.getValue();
  if (typeof i == "function" && (u2 = i(u2, t, r3)), typeof n4 == "function") return n4(u2, t, r3);
  if (typeof a2 < "u") {
    if (Xn$1(a2)) {
      let p2 = typeof s2 == "function" ? s2(u2, t, r3) : s2;
      return jsx(zo$3, { rule: a2, ...p2, children: u2 });
    }
    if (Da$1(a2)) {
      let p2 = typeof l2 == "function" ? l2(u2, t, r3) : l2;
      return jsx(qe$6, { rule: a2, ...p2, children: u2 });
    }
  }
  return flexRender(o2.column.columnDef.cell, o2.getContext());
};
function Ot$4(e2, o2) {
  let t = e2.getIsPinned(), r3 = t === "left" && e2.getIsLastColumn("left"), i = t === "right" && e2.getIsFirstColumn("right"), n4 = { left: t === "left" ? `${e2.getStart("left")}px` : void 0, right: t === "right" ? `${e2.getAfter("right")}px` : void 0, width: e2.getSize() }, a2 = cnBase(t ? "oui-sticky" : "oui-relative", t ? "oui-z-[1]" : "oui-z-0", t && "oui-bg-[var(--oui-table-background-color)]"), s2 = cnBase("before:oui-block before:oui-absolute", "before:oui-w-[32px] before:oui-h-full", "before:oui-top-0 before:oui-z-[-1]", "before:oui-bg-[linear-gradient(90deg,rgba(var(--oui-color-base-10)_/_0.80)_0%,rgba(var(--oui-color-base-10)_/_0.36)_65%,rgba(var(--oui-color-base-10)_/_0.00)_100%)]"), l2 = r3 && cnBase(s2, "before:oui-right-[-32px]"), u2 = i && cnBase(s2, "before:oui-left-[-32px] before:oui-rotate-180");
  return { style: n4, classNames: { content: a2, leftShadow: l2, rightShadow: u2 } };
}
var Zs$1 = (e2) => jsx("tbody", { className: cnBase("oui-table-tbody oui-relative", "oui-text-base-contrast-80", e2.className), "data-testid": e2.testId, children: e2.rows.map((o2) => {
  var _a3;
  let { className: t, onClick: r3, ...i } = typeof e2.onRow == "function" ? e2.onRow(o2.original, o2.index) || {} : {}, n4 = o2.getIsExpanded() && jsx("tr", { className: "oui-table-expand-tr oui-z-0", children: jsx("td", { className: "oui-table-expand-td", colSpan: o2.getVisibleCells().length, children: (_a3 = e2.expandRowRender) == null ? void 0 : _a3.call(e2, o2, o2.index) }) }), a2 = jsxs(Fragment$2, { children: [jsx("tr", { className: cnBase("oui-table-tbody-tr oui-group oui-h-10", typeof r3 == "function" && "oui-cursor-pointer", e2.bordered && "oui-border-b oui-border-b-line-4", t), onClick: () => {
    o2.getCanExpand() && o2.getToggleExpandedHandler(), r3 == null ? void 0 : r3();
  }, ...i, children: o2.getVisibleCells().map((s2) => {
    let l2 = s2.column, { style: u2, classNames: p2 } = Ot$4(l2), { align: g2, className: m2 } = l2.columnDef.meta || {}, { style: c, className: x2, children: b2, ...k2 } = typeof e2.onCell == "function" ? e2.onCell(s2.column, o2.original, o2.index) || {} : {}, f2 = b2 !== void 0 ? b2 : jsxs(Fragment$1, { children: [jsx(Hs$1, { cell: s2 }), jsx(l1, { selected: o2.getIsSelected(), isFirst: l2.getIsFirstColumn(), isLast: l2.getIsLastColumn() })] });
    return jsx("td", { style: { ...u2, ...c }, className: cnBase("oui-table-tbody-td oui-relative", "oui-px-3", _t$2({ align: g2 }), m2, p2.content, e2.showLeftShadow && p2.leftShadow, e2.showRightShadow && p2.rightShadow, x2), ...k2, children: f2 }, s2.id);
  }) }, o2.id), n4] }, o2.id);
  return typeof e2.renderRowContainer == "function" ? jsx(Fragment$2, { children: e2.renderRowContainer(o2.original, o2.index, a2) }, o2.id) : a2;
}) }), l1 = ({ selected: e2, isFirst: o2, isLast: t }) => jsx("div", { className: cnBase("oui-absolute oui-left-0 oui-top-0 oui-z-[-1]", "oui-size-full", "group-hover:oui-bg-line-4", e2 && "oui-bg-line-6 group-hover:oui-bg-line-6", o2 && "oui-rounded-l", t && "oui-rounded-r") });
var gi$3 = (e2) => jsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: "10", height: "10", viewBox: "0 0 10 10", fill: "none", children: e2.children }), Us = () => jsx(gi$3, { children: jsx("path", { d: "M5 1.042a.47.47 0 0 0-.338.135L2.166 3.844c-.206.22-.005.531.338.531h4.992c.342 0 .543-.311.337-.531L5.338 1.177A.47.47 0 0 0 5 1.042m0 7.916a.47.47 0 0 1-.338-.135L2.166 6.156c-.206-.22-.005-.531.338-.531h4.992c.342 0 .543.311.337.531L5.338 8.823A.47.47 0 0 1 5 8.958", fill: "#fff", fillOpacity: ".2" }) }), Ys$1 = () => jsxs(gi$3, { children: [jsx("path", { d: "M5 1.042a.47.47 0 0 0-.338.135L2.166 3.844c-.206.22-.005.531.338.531h4.992c.342 0 .543-.311.337-.531L5.338 1.177A.47.47 0 0 0 5 1.042", fill: "#fff", fillOpacity: ".8" }), jsx("path", { d: "M5 8.958a.47.47 0 0 1-.338-.135L2.166 6.156c-.206-.22-.005-.531.338-.531h4.992c.342 0 .543.311.337.531L5.338 8.823A.47.47 0 0 1 5 8.958", fill: "#fff", fillOpacity: ".2" })] }), Xs = () => jsxs(gi$3, { children: [jsx("path", { d: "M5 1.042a.47.47 0 0 0-.338.135L2.166 3.844c-.206.22-.005.531.338.531h4.992c.342 0 .543-.311.337-.531L5.338 1.177A.47.47 0 0 0 5 1.042", fill: "#fff", fillOpacity: ".2" }), jsx("path", { d: "M5 8.958a.47.47 0 0 1-.338-.135L2.166 6.156c-.206-.22-.005-.531.338-.531h4.992c.342 0 .543.311.337.531L5.338 8.823A.47.47 0 0 1 5 8.958", fill: "#fff", fillOpacity: ".8" })] });
var $s = (e2) => jsx("thead", { className: cnBase("oui-table-thead", "oui-sticky oui-top-0 oui-z-[2]", "oui-bg-[var(--oui-table-background-color)]", "oui-text-base-contrast-36"), children: e2.headerGroups.map((o2) => jsx("tr", { className: cnBase("oui-table-thead-tr", "oui-h-10", e2.className), children: o2.headers.map((t) => {
  let r3 = t.column, { align: i, className: n4, title: a2 } = r3.columnDef.meta || {}, { style: s2, classNames: l2 } = Ot$4(r3), u2 = r3.getCanSort(), p2 = r3.getIsSorted();
  return jsx("th", { style: s2, className: cnBase("oui-table-thead-th", "oui-whitespace-nowrap", "oui-px-3", e2.bordered && "after:oui-block after:oui-absolute after:oui-w-full after:oui-h-full after:oui-top-0 after:oui-left-0 after:oui-z-[-1] after:oui-border-b after:oui-border-line", _t$2({ align: i }), n4, l2.content, e2.showLeftShadow && l2.leftShadow, e2.showRightShadow && l2.rightShadow), children: t.isPlaceholder ? null : jsxs("div", { className: cnBase("oui-inline-flex oui-items-center oui-gap-x-1", u2 && "oui-cursor-pointer oui-select-none hover:oui-text-base-contrast-80"), onClick: r3.getToggleSortingHandler(), children: [a2, u2 && jsx(c1, { isSorted: p2 })] }) }, t.id);
}) }, o2.id)) }), c1 = ({ isSorted: e2 }) => ({ asc: jsx(Ys$1, {}), desc: jsx(Xs, {}) })[e2] || jsx(Us, {});
var Wo$4 = createContext(void 0);
var g1 = (e2) => {
  let o2 = useMemo(() => ({ ...e2.locale, exist: true }), [e2.locale]);
  return jsx(Wo$4.Provider, { value: o2, children: e2.children });
};
var fi$3 = { locale: "en", dialog: { ok: "OK", cancel: "Cancel" }, modal: { confirm: "Confirm", cancel: "Cancel" }, pagination: { morePages: "More pages", rowsPerPage: "Rows per page" }, picker: { selectDate: "Select Date", dayPicker: enUS }, empty: { description: "No results found." } };
var H$1 = (e2, o2) => {
  let t = useContext(Wo$4), r3 = useMemo(() => {
    let n4 = fi$3[e2], a2 = (t == null ? void 0 : t[e2]) || {};
    return { ...typeof n4 == "function" ? n4() : n4, ...a2 };
  }, [e2, o2, t]), i = useMemo(() => {
    let n4 = t == null ? void 0 : t.locale, a2 = fi$3.locale;
    return n4 || a2;
  }, [t]);
  return [r3, i];
};
var Qs = ({ className: e2, ...o2 }) => jsx("nav", { role: "navigation", "aria-label": "pagination", className: cnBase("oui-flex oui-justify-between oui-items-center oui-w-full oui-text-xs", e2), ...o2 });
Qs.displayName = "Pagination";
var Js$1 = ze__default__default.forwardRef(({ className: e2, ...o2 }, t) => jsx("ul", { ref: t, className: cnBase("oui-flex oui-flex-row oui-items-center oui-gap-x-2", e2), ...o2 }));
Js$1.displayName = "PaginationContent";
var Wt$2 = ze__default__default.forwardRef(({ className: e2, ...o2 }, t) => jsx("li", { ref: t, className: cnBase("oui-leading-[0px]", e2), ...o2 }));
Wt$2.displayName = "PaginationItem";
var Zt$5 = ({ className: e2, isActive: o2, ...t }) => jsx("button", { "aria-current": o2 ? "page" : void 0, "data-active": o2, className: ft$3({ size: "xs", variant: o2 ? "contained" : "text", className: "oui-min-w-6 oui-text-base-contrast-80 oui-font-semibold data-[active=false]:hover:oui-bg-base-6 disabled:oui-bg-transparent disabled:hover:oui-bg-transparent" }), ...t });
Zt$5.displayName = "PaginationLink";
var el$1 = ({ className: e2, ...o2 }) => jsx(Zt$5, { "aria-label": "Go to previous page", className: cnBase("oui-gap-1 oui-pl-2.5", e2), ...o2, children: jsx(Je$6, { className: "oui-h-4 oui-w-4", color: "white" }) });
el$1.displayName = "PaginationPrevious";
var ol = ({ className: e2, ...o2 }) => jsx(Zt$5, { "aria-label": "Go to next page", className: cnBase("oui-gap-1 oui-pr-2.5", e2), ...o2, children: jsx(eo$4, { className: "oui-h-4 oui-w-4", color: "white" }) });
ol.displayName = "PaginationNext";
var tl$1 = (e2) => {
  let { classNames: o2, className: t, pageTotal: r3, page: i } = e2, [n4] = H$1("pagination");
  return jsxs(Qs, { className: cnBase(o2 == null ? void 0 : o2.pagination, t), children: [jsxs(z$3, { mr: 4, children: [jsx(ee$3, { as: "div", size: "2xs", intensity: 54, className: "oui-text-nowrap oui-mr-2", children: n4.rowsPerPage }), jsx("div", { className: "oui-w-15", children: jsx(Be$6.options, { options: [{ value: "10", label: "10" }, { value: "20", label: "20" }, { value: "50", label: "50" }, { value: "100", label: "100" }], value: `${e2.pageSize ?? 5}`, size: "xs", onValueChange: (a2) => {
    var _a3;
    return (_a3 = e2.onPageSizeChange) == null ? void 0 : _a3.call(e2, parseInt(a2));
  } }) })] }), jsx(rl, { ...e2 })] });
};
function v1(e2, o2) {
  let t = [], r3 = "...";
  if (o2 <= 5) for (let n4 = 1; n4 <= o2; n4++) t.push(n4);
  else e2 <= 3 ? t.push(1, 2, 3, 4, r3, o2) : e2 >= o2 - 2 ? t.push(1, r3, o2 - 3, o2 - 2, o2 - 1, o2) : t.push(1, r3, e2 - 1, e2, e2 + 1, r3, o2);
  return t;
}
var rl = (e2) => {
  let { classNames: o2, className: t, pageTotal: r3, page: i } = e2;
  if (r3 <= 1) return null;
  let n4 = useMemo(() => v1(i, r3), [i, r3]);
  return jsxs(Js$1, { children: [jsx(Wt$2, { children: jsx(el$1, { disabled: e2.page === 1, onClick: (a2) => {
    var _a3;
    a2.preventDefault(), (_a3 = e2.onPageChange) == null ? void 0 : _a3.call(e2, e2.page - 1);
  } }) }), n4.map((a2, s2) => jsx(Wt$2, { children: jsx(Zt$5, { isActive: a2 === e2.page, onClick: (l2) => {
    var _a3, _b2;
    l2.preventDefault(), a2 !== "..." ? (_a3 = e2.onPageChange) == null ? void 0 : _a3.call(e2, Number(a2)) : (_b2 = e2.onPageChange) == null ? void 0 : _b2.call(e2, Number(n4[s2 + 1] - 1));
  }, children: a2 }) }, s2)), jsx(Wt$2, { children: jsx(ol, { disabled: e2.page === e2.pageTotal, onClick: (a2) => {
    var _a3;
    a2.preventDefault(), (_a3 = e2.onPageChange) == null ? void 0 : _a3.call(e2, e2.page + 1);
  } }) })] });
};
var al = (e2) => e2.pageTotal === 0 ? null : jsx(z$3, { justify: "end", py: 2, mx: 3, className: "oui-h-10 oui-w-full", children: jsx(tl$1, { ...e2, className: "oui-table-pagination oui-justify-between oui-w-full" }) });
var ve$5 = class e {
  constructor() {
    __publicField(this, "extensionMap", /* @__PURE__ */ new Map());
  }
  static getInstance() {
    let o2 = l$1();
    return o2.__ORDERLY_EXTENSION_REGISTRY__ || (o2.__ORDERLY_EXTENSION_REGISTRY__ = new e()), o2.__ORDERLY_EXTENSION_REGISTRY__;
  }
  register(o2) {
    var _a3;
    o2.builder;
    for (let t = 0; t < o2.positions.length; t++) {
      if (typeof o2.builder != "function") {
        let i = (_a3 = this.extensionMap.get(o2.positions[t])) == null ? void 0 : _a3.builder;
        o2.builder = typeof i > "u" ? void 0 : i;
      }
      let r3 = o2.positions[t];
      this.registerToPosition(r3, o2);
    }
  }
  registerToPosition(o2, t) {
    if (this.extensionMap.has(o2)) {
      let r3 = this.extensionMap.get(o2);
      if (!(r3 == null ? void 0 : r3.__isInternal)) {
        !(r3 == null ? void 0 : r3.builder) && t.__isInternal && this.setBuilder(o2, t.builder);
        return;
      }
      t.builder || (t.builder = r3.builder);
    }
    this.extensionMap.set(o2, t);
  }
  setBuilder(o2, t) {
    let r3 = this.extensionMap.get(o2);
    r3 && (r3.builder = t);
  }
  unregister(o2) {
    for (let t = 0; t < o2.positions.length; t++) {
      let r3 = o2.positions[t];
      this.unregisterFromPosition(r3);
    }
  }
  unregisterFromPosition(o2) {
    this.extensionMap.delete(o2);
  }
  getPluginsByPosition(o2) {
    return this.extensionMap.get(o2);
  }
  getFormatterByPosition(o2) {
    return this.extensionMap.get(o2);
  }
};
var Zo = (e2) => (o2) => {
  ve$5.getInstance().register({ name: e2.name, positions: e2.positions, __isInternal: !!e2.__isInternal, builder: e2.builder, render: o2 });
};
var nl = (e2, o2) => {
  let r3 = ve$5.getInstance().getPluginsByPosition(e2);
  return () => {
    var _a3;
    return ((_a3 = r3 == null ? void 0 : r3.builder) == null ? void 0 : _a3.call(r3, o2)) || o2;
  };
};
var sl = (e2, o2) => nl(e2, o2)();
var ul = (e2) => {
  let { position: o2 } = e2;
  return jsxs("div", { className: "oui-text-danger", children: [jsx("strong", { children: `[${o2}] ` }), jsx("span", { children: "Not found!" })] });
};
var bi$2 = (e2) => {
  let { position: o2, scope: t, defaultWidget: r3, ...i } = e2, n4 = sl(o2, i), a2 = useMemo(() => {
    var _a3;
    return ((_a3 = ve$5.getInstance().getPluginsByPosition(o2)) == null ? void 0 : _a3.render) ?? r3 ?? ul;
  }, []);
  return jsx(ErrorBoundary, { fallback: jsx("div", { children: `Component: [${o2}] went wrong` }), children: jsx(Slot, { ...n4, position: o2, children: jsx(a2, {}) }) });
};
var Yt$1 = ((a2) => (a2.DepositForm = "depositForm", a2.WithdrawForm = "withdrawForm", a2.AccountMenu = "accountMenu", a2.MobileAccountMenu = "mobileAccountMenu", a2.MainMenus = "mainMenus", a2.EmptyDataIdentifier = "emptyDataIdentifier", a2))(Yt$1 || {});
var cl = (e2) => {
  let { visible: o2, loading: t, emptyView: r3 } = e2;
  return o2 ? jsx(W$2, { position: "absolute", left: 0, top: 0, right: 0, bottom: 0, className: "oui-flex oui-justify-center oui-items-center", children: t ? jsx(Ie$4, {}) : r3 || jsx(bi$2, { position: "emptyDataIdentifier" }) }) : null;
};
var Xt$4 = { columns: (e2) => {
  let o2 = createColumnHelper();
  return e2 == null ? void 0 : e2.map((t, r3) => {
    let i = { meta: t, size: t.width || 100 }, { dataIndex: n4, onSort: a2 } = t;
    return o2.accessor(n4, { header: () => t.title, enableSorting: !!a2, sortingFn: typeof a2 == "function" ? (s2, l2, u2) => a2 == null ? void 0 : a2(s2.original, l2.original) : "alphanumeric", ...i });
  });
}, columnPinning: (e2) => {
  let o2 = [], t = [];
  return e2 == null ? void 0 : e2.map((r3) => {
    r3.fixed === "left" ? o2.push(r3.dataIndex) : r3.fixed === "right" && t.push(r3.dataIndex);
  }), { left: o2, right: t };
}, pagination: (e2) => {
  let o2 = {}, t = {};
  return e2 && (o2 = { pagination: { pageIndex: e2.page - 1, pageSize: e2.pageSize } }, t = { getPaginationRowModel: getPaginationRowModel() }), { state: o2, config: t };
} };
function L1(e2) {
  var _a3;
  let { columns: o2, className: t, classNames: r3, pagination: i, getRowCanExpand: n4, manualPagination: a2, loading: s2, ignoreLoadingCheck: l2, emptyView: u2, initialSort: p2, manualSorting: g2, onSort: m2, expanded: c, onExpandedChange: x2 } = e2, b2 = useMemo(() => e2.dataSource ? e2.dataSource : [], [e2.dataSource]), k2 = useMemo(() => Xt$4.columns(o2), [o2]), f2 = useMemo(() => Xt$4.columnPinning(o2), [o2]), T2 = useMemo(() => e2.rowSelection || {}, [e2.rowSelection]), { state: N2, config: v3 } = useMemo(() => Xt$4.pagination(i), [i]), [M2, y2] = _s$1({ onSort: m2, initialSort: p2 }), B2 = Ms$1({ dataSource: b2, loading: s2, ignoreLoadingCheck: l2 }), U2 = useMemo(() => Array.isArray(e2.columnFilters) ? e2.columnFilters : e2.columnFilters ? [e2.columnFilters] : [], [e2.columnFilters]), K2 = useReactTable({ _features: e2.features, data: b2, columns: k2, state: { columnPinning: f2, columnFilters: U2, rowSelection: T2, sorting: M2, expanded: c, ...N2 }, onSortingChange: y2, getRowId: e2.generatedRowKey, getCoreRowModel: getCoreRowModel(), getExpandedRowModel: getExpandedRowModel(), getRowCanExpand: n4, onExpandedChange: x2, getSubRows: e2.getSubRows, getSortedRowModel: getSortedRowModel(), getFilteredRowModel: getFilteredRowModel(), manualSorting: g2, manualPagination: a2, enableMultiRowSelection: false, enableExpanding: true, ...v3 });
  useEffect(() => {
    var _a4;
    (_a4 = e2.getTableInstance) == null ? void 0 : _a4.call(e2, K2);
  }, [K2]);
  let ne2 = As$1([t, r3 == null ? void 0 : r3.root]), { scrollRef: w4, showLeftShadow: V2, showRightShadow: O2 } = Ls$2([b2 == null ? void 0 : b2.length]), Le2 = K2.getRowModel().rows, pa2 = B2 && (Le2.length === 0 || s2), vu2 = Es({ loading: s2, dataSource: b2 }), da2 = Fs({ loading: s2, dataSource: b2, rows: Le2, pagination: i });
  return jsxs("div", { ref: ne2, id: e2.id, className: cnBase("oui-table-root oui-size-full", "oui-bg-base-9", t, r3 == null ? void 0 : r3.root), children: [jsxs("div", { ref: w4, className: cnBase("oui-table-scroll oui-relative", "oui-min-h-[162px] oui-w-full", "oui-text-xs oui-font-semibold", "oui-custom-scrollbar oui-overflow-auto", da2 ? "oui-h-[calc(100%_-_40px)]" : "oui-h-full", r3 == null ? void 0 : r3.scroll), children: [jsxs("table", { className: cnBase("oui-w-full", "oui-table-fixed oui-border-collapse"), children: [vu2 && jsx($s, { className: r3 == null ? void 0 : r3.header, headerGroups: K2.getHeaderGroups(), bordered: e2.bordered, showLeftShadow: V2, showRightShadow: O2 }), jsx(Zs$1, { className: r3 == null ? void 0 : r3.body, rows: Le2, bordered: e2.bordered, renderRowContainer: e2.renderRowContainer, expandRowRender: e2.expandRowRender, onRow: e2.onRow, onCell: e2.onCell, showLeftShadow: V2, showRightShadow: O2, testId: (_a3 = e2.testIds) == null ? void 0 : _a3.body })] }), jsx(cl, { visible: pa2, loading: s2, emptyView: u2 })] }), da2 && jsx(al, { className: r3 == null ? void 0 : r3.pagination, count: (i == null ? void 0 : i.count) || (Le2 == null ? void 0 : Le2.length), pageTotal: (i == null ? void 0 : i.pageTotal) || K2.getPageCount(), page: i == null ? void 0 : i.page, pageSize: i == null ? void 0 : i.pageSize, onPageChange: i == null ? void 0 : i.onPageChange, onPageSizeChange: i == null ? void 0 : i.onPageSizeChange })] });
}
function lo$3({ className: e2, classNames: o2, showOutsideDays: t = true, ...r3 }) {
  let [i] = H$1("picker");
  return jsx(DayPicker, { locale: i.dayPicker, showOutsideDays: t, className: cnBase("oui-p-3 oui-bg-base-7 oui-rounded", e2), classNames: { months: "oui-flex oui-flex-col sm:oui-flex-row oui-space-y-4 sm:oui-space-x-4 sm:oui-space-y-0", month: "oui-space-y-4", caption: "oui-flex oui-justify-center oui-pt-1 oui-relative oui-items-center", caption_label: "oui-text-sm oui-font-medium ", nav: "oui-space-x-1 oui-flex oui-items-center", nav_button: cnBase("oui-h-7 oui-w-7 oui-bg-transparent oui-p-0 oui-opacity-50 hover:oui-opacity-100"), nav_button_previous: "oui-absolute oui-left-1", nav_button_next: "oui-absolute oui-right-1", table: "oui-w-full oui-border-collapse oui-space-y-1", head_row: "oui-flex", head_cell: "oui-text-base-contrast-80 oui-rounded-md oui-w-7 oui-font-normal oui-text-[0.8rem] oui-opacity-30", row: "oui-flex oui-w-full oui-mt-2", cell: cnBase("oui-relative oui-day-cell oui-p-0 oui-text-center oui-text-2xs focus-within:oui-relative focus-within:oui-z-20 [&:has([aria-selected])]:oui-bg-base-4 [&:has([aria-selected].day-outside)]:oui-bg-base-4/50 [&:has([aria-selected].day-range-end)]:oui-rounded-r-md", r3.mode === "range" ? "[&:has(>.oui-day-range-end)]:oui-rounded-r-md [&:has(>.oui-day-range-start)]:oui-rounded-l-md first:[&:has([aria-selected])]:oui-rounded-l-md last:[&:has([aria-selected])]:oui-rounded-r-md" : "[&:has([aria-selected])]:oui-rounded-md"), day: cnBase("oui-h-7 oui-w-7 oui-p-0 oui-rounded-md oui-font-normal aria-selected:oui-opacity-100 oui-text-base-contrast-80 hover:oui-bg-base-5"), day_range_start: "day-range-start  oui-bg-primary-darken oui-text-base-contrast-80 hover:oui-bg-primary-darken", day_range_end: "day-range-end oui-bg-primary-darken oui-text-base-contrast-80 hover:oui-bg-primary-darken", day_selected: "oui-bg-base-4 ", day_today: "oui-bg-accent ", day_outside: "oui-day-outside oui-text-muted-foreground oui-opacity-50 aria-selected:oui-bg-accent/50 aria-selected:oui-text-muted-foreground aria-selected:oui-opacity-30", day_disabled: "oui-text-muted-foreground oui-opacity-50", day_range_middle: "aria-selected:oui-bg-accent aria-selected:oui-text-accent-foreground", day_hidden: "oui-invisible", ...o2 }, components: { IconLeft: ({ ...n4 }) => jsx(Je$6, { size: 16, className: "oui-text-inherit", opacity: 1 }), IconRight: ({ ...n4 }) => jsx(eo$4, { size: 16, className: "oui-text-inherit", opacity: 1 }) }, ...r3 });
}
lo$3.displayName = "Calendar";
var O1 = "yyyy/MM/dd", Uo$1 = (e2) => {
  let { placeholder: o2, dateFormat: t, onChange: r3, value: i, initialValue: n4, size: a2, className: s2, formatString: l2 = O1, ...u2 } = e2, [p2] = H$1("picker"), [g2, m2] = useState(false), [c, x2] = useState(i || n4 || null), [b2, k2] = useState(false), f2 = H1((y2) => {
    k2(y2 <= 768);
  }, 100);
  useEffect(() => {
    let y2 = () => {
      f2(window.innerWidth);
    };
    return k2(window.innerWidth <= 768), window.addEventListener("resize", y2), () => {
      window.removeEventListener("resize", y2);
    };
  }, []), useEffect(() => {
    (i == null ? void 0 : i.from) && (i == null ? void 0 : i.to) && (c == null ? void 0 : c.from) && (c == null ? void 0 : c.to) && !G1(i, c) && x2(i);
  }, [i]);
  let { trigger: T2 } = Z$5({ size: a2, className: s2 }), N2 = useMemo(() => {
    if (!c || !c.from || !c.to) return o2 ?? p2.selectDate;
    let y2 = [];
    return c.from && y2.push(format(c.from, l2)), c.to && y2.push(format(c.to, l2)), `${y2.join(" - ")}`;
  }, [c, o2, p2]);
  return jsx(Bo$3, { open: g2, onOpenChange: (y2) => {
    typeof (c == null ? void 0 : c.to) > "u" && typeof (c == null ? void 0 : c.from) < "u" && x2({ ...c, to: c.from }), !y2 && c && (r3 == null ? void 0 : r3(c)), m2(y2);
  }, contentProps: { className: "oui-w-auto oui-p-0", align: "start" }, content: jsx(lo$3, { numberOfMonths: b2 ? 1 : 2, ...u2, mode: "range", selected: c, onSelect: (y2, B2) => {
    (c == null ? void 0 : c.from) && (c == null ? void 0 : c.to) ? x2({ from: B2 }) : x2(y2);
  } }), children: jsxs("button", { className: T2({ className: "oui-datepicker-trigger oui-group" }), children: [jsx("span", { className: "oui-datepicker-trigger-icon", children: jsx(oo$2, { size: 14, className: "oui-text-inherit", opacity: 1 }) }), jsx("span", { children: N2 }), jsx(oe$7, { size: 12, className: "oui-datepicker-trigger-arrow oui-text-inherit oui-transition-transform group-data-[state=open]:oui-rotate-180 group-data-[state=closed]:oui-rotate-0", opacity: 1 })] }) });
};
Uo$1.displayName = "DateRangePicker";
function H1(e2, o2) {
  let t = useRef(null);
  return useCallback((i) => {
    t.current && clearTimeout(t.current), t.current = setTimeout(() => {
      e2(i);
    }, o2);
  }, [e2, o2]);
}
function G1(e2, o2) {
  let t = (s2) => ({ year: s2.getFullYear(), month: s2.getMonth(), day: s2.getDate() }), r3 = t(e2.from), i = t(e2.to), n4 = t(o2.from), a2 = t(o2.to);
  return r3.year === n4.year && r3.month === n4.month && r3.day === n4.day && i.year === a2.year && i.month === a2.month && i.day === a2.day;
}
var Yo$4 = (e2) => {
  let { placeholder: o2, dateFormat: t, onChange: r3, value: i, size: n4, className: a2, ...s2 } = e2, [l2] = H$1("picker"), { trigger: u2 } = Z$5({ size: n4, className: a2 }), [p2, g2] = useState(false), m2 = useMemo(() => {
    if (typeof i > "u") return o2 ?? l2.selectDate;
  }, [i, o2, l2]);
  return jsx(Bo$3, { open: p2, onOpenChange: g2, contentProps: { className: "oui-w-auto oui-p-0" }, content: jsx(lo$3, { onSelect: (x2, b2, k2, f2) => {
    var _a3;
    (_a3 = s2.onSelect) == null ? void 0 : _a3.call(s2, x2, b2, k2, f2), x2 && (r3 == null ? void 0 : r3(x2), g2(false));
  }, ...s2 }), children: jsxs("button", { className: u2({ className: "orderly-datepicker-trigger oui-group" }), children: [jsx("span", { className: "orderly-datepicker-trigger-icon", children: jsx(oo$2, { size: 14, className: "oui-text-inherit", opacity: 1 }) }), jsx("span", { children: m2 }), jsx(oe$7, { size: 12, className: "orderly-datepicker-trigger-arrow oui-text-inherit oui-transition-transform group-data-[state=open]:oui-rotate-180 group-data-[state=closed]:oui-rotate-0", opacity: 1 })] }) });
};
Yo$4.displayName = "DatePicker";
var $o$1 = E$5.Root, Pi$1 = E$5.Trigger, ml = E$5.Portal, Si$3 = ze__default.forwardRef(({ className: e2, ...o2 }, t) => jsx(E$5.Overlay, { className: cnBase("oui-fixed oui-inset-0 oui-z-50 oui-bg-black/80  data-[state=open]:oui-animate-in data-[state=closed]:oui-animate-out data-[state=closed]:oui-fade-out-0 data-[state=open]:oui-fade-in-0", e2), ...o2, ref: t }));
Si$3.displayName = E$5.Overlay.displayName;
var $1 = tv({ base: "oui-fixed oui-z-50 oui-gap-4 oui-bg-base-8 oui-px-4 oui-shadow-lg oui-transition oui-ease-in-out data-[state=closed]:oui-duration-260 data-[state=open]:oui-duration-300 data-[state=open]:oui-animate-in data-[state=closed]:oui-animate-out", variants: { side: { top: "oui-inset-x-0 oui-top-0 oui-border-b data-[state=closed]:oui-slide-out-to-top data-[state=open]:oui-slide-in-from-top", bottom: "oui-inset-x-0 oui-bottom-0 oui-rounded-t-2xl data-[state=closed]:oui-slide-out-to-bottom data-[state=open]:oui-slide-in-from-bottom", left: "oui-inset-y-0 oui-left-0 oui-h-full oui-w-3/4 data-[state=closed]:oui-slide-out-to-left data-[state=open]:oui-slide-in-from-left sm:oui-max-w-sm", right: "oui-inset-y-0 oui-right-0 oui-h-full oui-w-3/4 oui-border-l data-[state=closed]:oui-slide-out-to-right data-[state=open]:oui-slide-in-from-right sm:oui-max-w-sm" } }, defaultVariants: { side: "bottom" } }), po$6 = ze__default.forwardRef(({ side: e2 = "bottom", closeable: o2 = true, className: t, children: r3, ...i }, n4) => jsxs(ml, { children: [jsx(Si$3, {}), jsxs(E$5.Content, { ref: n4, className: cnBase($1({ side: e2 }), t), onOpenAutoFocus: (a2) => a2.preventDefault(), onCloseAutoFocus: (a2) => a2.preventDefault(), ...i, children: [o2 && jsxs(E$5.Close, { className: cnBase("oui-absolute oui-right-4 oui-top-4 oui-rounded-sm oui-ring-offset-base-700 oui-transition-opacity  focus:oui-outline-none focus:oui-ring-2 focus:oui-ring-ring focus:oui-ring-offset-2 disabled:oui-pointer-events-none data-[state=open]:oui-bg-secondary"), children: [jsx(De$4, { size: 16, color: "white", opacity: 0.98 }), jsx("span", { className: "oui-sr-only", children: "Close" })] }), r3] })] }));
po$6.displayName = E$5.Content.displayName;
var qt$6 = ({ className: e2, leading: o2, ...t }) => jsxs("div", { className: cnBase("oui-sheet-header oui-grid oui-grid-cols-[40px_1fr_40px] oui-items-center oui-min-h-12"), children: [jsx("div", { children: o2 }), jsx("div", { ...t, className: cnBase("oui-flex oui-flex-col oui-space-y-2 oui-text-center oui-text-lg oui-text-base-contrast", e2) })] });
qt$6.displayName = "SheetHeader";
var ki$1 = ({ className: e2, ...o2 }) => jsx("div", { className: cnBase("oui-py-4", e2), ...o2 });
ki$1.displayName = "DialogBody";
var Kt$4 = ze__default.forwardRef(({ className: e2, leading: o2, ...t }, r3) => jsxs("div", { className: "oui-sheet-header oui-grid oui-grid-cols-[40px_1fr_40px] oui-items-center", ref: r3, children: [jsx("div", { children: o2 }), jsx("div", { className: cnBase("oui-flex oui-flex-col oui-space-y-2 oui-text-center oui-text-lg oui-text-base-contrast", e2), ...t })] }));
Kt$4.displayName = E$5.Title.displayName;
var fl = ze__default.forwardRef(({ className: e2, ...o2 }, t) => jsx(E$5.Description, { ref: t, className: cnBase("oui-sheet-description oui-text-2xs oui-text-base-contrast-54", e2), ...o2 }));
fl.displayName = E$5.Description.displayName;
var Ri$2 = Symbol("modalId"), q1 = 0, K1 = () => `__modal_${q1++}`, qo$5 = (e2) => typeof e2 == "string" ? e2 : (e2[Ri$2] || (e2[Ri$2] = K1()), e2[Ri$2]);
function j$3(e2, o2) {
  let t = useContext(Ge$2), r3 = useContext(Ko$1), i, n4 = e2 && typeof e2 != "string";
  if (e2 ? i = qo$5(e2) : i = r3, !i) throw new Error("modalId is required");
  let a2 = i;
  useEffect(() => {
    n4 && mo$3(a2, e2, o2);
  }, [n4, i, e2, o2]);
  let s2 = t[a2], l2 = useCallback((f2) => G$5.show(a2, f2), [a2]), u2 = useCallback(() => G$5.hide(a2), [a2]), p2 = useCallback(() => G$5.remove(a2), [a2]), g2 = useCallback((f2) => {
    f2 || (b2("cancel"), u2());
  }, [a2]), m2 = useCallback((f2) => {
    G$5.setStates(a2, f2);
  }, [a2]), c = useCallback((f2) => {
    G$5.updateArgs(a2, f2);
  }, [a2]), x2 = useCallback((f2) => {
    var _a3;
    (_a3 = ue$6[a2]) == null ? void 0 : _a3.resolve(f2), delete ue$6[a2];
  }, [a2]), b2 = useCallback((f2) => {
    var _a3;
    (_a3 = ue$6[a2]) == null ? void 0 : _a3.reject(f2), delete ue$6[a2];
  }, [a2]), k2 = useCallback((f2) => {
    var _a3;
    (_a3 = He$4[a2]) == null ? void 0 : _a3.resolve(f2), delete He$4[a2];
  }, []);
  return { id: a2, args: s2 == null ? void 0 : s2.args, states: s2 == null ? void 0 : s2.states, visible: !!(s2 == null ? void 0 : s2.visible), keepMounted: !!(s2 == null ? void 0 : s2.keepMounted), show: l2, hide: u2, onOpenChange: g2, setStates: m2, updateArgs: c, remove: p2, resolve: x2, reject: b2, resolveHide: k2 };
}
var ce$9 = /* @__PURE__ */ new Map(), pe$3 = (e2) => ({ id: o2, defaultVisible: t, keepMounted: r3, ...i }) => {
  var _a3;
  let { args: n4, show: a2 } = j$3(o2), s2 = useContext(Ge$2), l2 = !!s2[o2];
  useEffect(() => (t && a2(), go$4[o2] = true, () => {
    r3 || delete go$4[o2];
  }), [o2, a2, t]), useEffect(() => {
    r3 && G$5.setStates(o2, { keepMounted: true });
  }, [o2, r3]);
  let u2 = (_a3 = s2[o2]) == null ? void 0 : _a3.delayVisible;
  return useEffect(() => {
    u2 && a2(n4);
  }, [u2, n4, a2]), l2 ? jsx(Ko$1.Provider, { value: o2, children: jsx(e2, { ...i, ...n4 }) }) : null;
};
function mo$3(e2, o2, t) {
  ce$9.has(e2) ? ce$9.set(e2, { comp: ce$9.get(e2).comp, props: t }) : ce$9.set(e2, { comp: o2, props: t });
}
var hl = (e2) => {
  ce$9.delete(e2);
};
var vl = {}, go$4 = {}, Ge$2 = createContext(vl), Ko$1 = createContext(null), ue$6 = {}, He$4 = {}, fo$3 = () => {
  throw new Error("No dispatch method detected, did you embed your app with Modal.Provider?");
};
function tm(e2, o2) {
  return { type: "SHOW_MODAL", payload: { id: e2, args: o2 } };
}
function rm(e2) {
  return { type: "HIDE_MODAL", payload: { id: e2 } };
}
function im(e2) {
  return { type: "DESTROY_MODAL", payload: { id: e2 } };
}
function am(e2, o2) {
  return { type: "UPDATE_ARGS", payload: { id: e2, args: o2 } };
}
function nm(e2, o2) {
  return { type: "SET_MODAL_STATES", payload: { id: e2, states: o2 } };
}
var sm = (e2, o2) => {
  let { id: t, args: r3 } = o2.payload;
  switch (o2.type) {
    case "SHOW_MODAL":
      return { ...e2, [t]: { ...e2[t], id: t, args: r3, visible: !!go$4[t], delayVisible: !go$4[t] } };
    case "HIDE_MODAL":
      return { ...e2, [t]: { ...e2[t], visible: false } };
    case "DESTROY_MODAL": {
      let i = { ...e2 };
      return delete i[t], i;
    }
    case "UPDATE_ARGS":
      return { ...e2, [t]: { ...e2[t], args: { ...e2[t].args, ...r3 } } };
    case "SET_MODAL_STATES":
      return { ...e2, [t]: { ...e2[t], states: { ...e2.states, ...o2.payload.states } } };
    default:
      return e2;
  }
}, lm = () => {
  let e2 = useContext(Ge$2), o2 = Object.keys(e2).filter((r3) => !!e2[r3]);
  o2.forEach((r3) => {
    !ce$9.has(r3) && go$4[r3];
  });
  let t = o2.filter((r3) => ce$9.has(r3)).map((r3) => ({ id: r3, ...ce$9.get(r3) }));
  return jsx(Fragment$1, { children: t.map((r3) => {
    let i = r3.comp;
    return jsx(i, { id: r3.id, ...r3.props }, r3.id);
  }) });
}, um = (e2) => {
  let [o2, t] = useReducer(sm, vl);
  return fo$3 = t, jsxs(Ge$2.Provider, { value: o2, children: [e2.children, jsx(lm, {})] });
};
function cm$1(e2, o2) {
  let t = qo$5(e2);
  if (typeof e2 != "string" && !ce$9.has(t) && mo$3(t, e2), fo$3(tm(t, o2)), !ue$6[t]) {
    let r3, i, n4 = new Promise((a2, s2) => {
      r3 = a2, i = s2;
    });
    ue$6[t] = { resolve: r3, reject: i, promise: n4 };
  }
  return ue$6[t].promise;
}
function pm(e2) {
  let o2 = qo$5(e2);
  if (fo$3(rm(o2)), delete ue$6[o2], !He$4[o2]) {
    let t, r3, i = new Promise((n4, a2) => {
      t = n4, r3 = a2;
    });
    He$4[o2] = { resolve: t, reject: r3, promise: i };
  }
  return He$4[o2].promise;
}
function dm$1(e2) {
  fo$3(im(e2)), delete ue$6[e2], delete He$4[e2];
}
function mm$1(e2, o2) {
  fo$3(nm(e2, o2));
}
function gm(e2, o2) {
  fo$3(am(e2, o2));
}
var G$5 = { show: cm$1, hide: pm, remove: dm$1, setStates: mm$1, updateArgs: gm };
var hm = h$2({ base: ["oui-pointer-events-none oui-box-content"], variants: { intensity: { 4: "oui-border-line-4", 6: "oui-border-line-6", 8: "oui-border-line", 12: "oui-border-line-12", 16: "oui-border-line-16" }, direction: { horizontal: ["oui-border-b"], vertical: ["oui-border-l"] }, lineStyle: { dashed: "oui-border-dashed", dotted: "oui-border-dotted" }, mx: { 2: "oui-mx-2", 4: "oui-mx-4", 6: "oui-mx-6", 8: "oui-mx-8", 10: "oui-mx-10" }, my: { 2: "oui-my-2", 4: "oui-my-4", 6: "oui-my-6", 8: "oui-my-8", 10: "oui-my-10" } }, defaultVariants: { direction: "horizontal", intensity: 4 } }), de$5 = ze__default__default.forwardRef((e2, o2) => {
  let { className: t, intensity: r3, direction: i, lineStyle: n4, mx: a2, my: s2, ...l2 } = e2;
  return jsx("div", { ref: o2, ...l2, className: hm({ direction: i, intensity: r3, className: t, lineStyle: n4, mx: a2, my: s2 }) });
});
de$5.displayName = "Divider";
var Jo = (e2) => {
  let { open: o2, onOpenChange: t, classNames: r3, contentProps: i, closable: n4 = true } = e2, a2 = typeof e2.title == "function" ? e2.title() : e2.title;
  return jsx($o$1, { open: o2, onOpenChange: t, children: jsxs(po$6, { onOpenAutoFocus: (s2) => s2.preventDefault(), className: r3 == null ? void 0 : r3.content, closeable: n4, ...i, children: [a2 && jsxs(Fragment$1, { children: [jsx(qt$6, { leading: e2.leading, children: jsx(Kt$4, { children: a2 }) }), jsx(de$5, {})] }), jsx(ki$1, { className: r3 == null ? void 0 : r3.body, children: e2.children })] }) });
};
var ym = pe$3((e2) => {
  let { visible: o2, onOpenChange: i } = j$3();
  return jsx(Jo, { open: o2, onOpenChange: i, ...e2, children: e2.content });
}), Cl = (e2) => G$5.show(ym, e2);
var We$7 = tv({ slots: { overlay: ["oui-dialog-overlay", "oui-fixed", "oui-inset-0", "oui-z-50", "oui-bg-black/80", "data-[state=open]:oui-animate-in", "data-[state=closed]:oui-animate-out", "data-[state=closed]:oui-fade-out-0", "data-[state=open]:oui-fade-in-0"], content: ["oui-dialog-content", "oui-fixed", "oui-left-[50%]", "oui-top-[50%]", "oui-z-50", "oui-w-full", "oui-max-w-lg", "oui-translate-x-[-50%]", "oui-translate-y-[-50%]", "oui-text-base-contrast-54", "oui-px-4 lg:oui-px-5", "oui-shadow-lg", "oui-duration-200", "data-[state=open]:oui-animate-in", "data-[state=closed]:oui-animate-out", "data-[state=closed]:oui-fade-out-0", "data-[state=open]:oui-fade-in-0", "data-[state=closed]:oui-zoom-out-95", "data-[state=open]:oui-zoom-in-95", "data-[state=closed]:oui-slide-out-to-left-1/2", "data-[state=closed]:oui-slide-out-to-top-[48%]", "data-[state=open]:oui-slide-in-from-left-1/2", "data-[state=open]:oui-slide-in-from-top-[48%]", "sm:oui-rounded-xl"], body: ["oui-dialog-body", "oui-py-4 lg:oui-py-5", "oui-text-xs"], close: ["oui-dialog-close-btn", "oui-absolute", "oui-right-4", "oui-top-4", "oui-ring-offset-background", "oui-transition-opacity", "hover:oui-opacity-100", "disabled:oui-pointer-events-none"], header: ["oui-dialog-header", "oui-flex", "oui-flex-col"], footer: ["oui-dialog-footer", "oui-flex", "oui-flex-row", "oui-justify-end", "oui-space-x-2", "oui-pb-5", "oui-pt-2 lg:oui-pt-3"], title: ["oui-dialog-title", "oui-text-base", "oui-min-h-11 lg:oui-min-h-[46px]", "oui-flex", "oui-items-center", "oui-text-base-contrast"], desc: ["oui-dialog-desc", "oui-text-xs", "oui-text-warning-darken", "oui-pt-2", "oui-text-center", "oui-pb-3"] }, variants: { size: { xs: { content: ["oui-max-w-xs"] }, sm: { content: ["oui-max-w-sm"] }, md: { content: ["oui-max-w-md"] }, lg: { content: ["oui-max-w-lg"] }, xl: { content: ["oui-max-w-xl"] } }, intensity: { 100: { content: ["oui-bg-base-1"] }, 200: { content: ["oui-bg-base-2"] }, 300: { content: ["oui-bg-base-3"] }, 400: { content: ["oui-bg-base-4"] }, 500: { content: ["oui-bg-base-5"] }, 600: { content: ["oui-bg-base-6"] }, 700: { content: ["oui-bg-base-7"] }, 800: { content: ["oui-bg-base-8"] }, 900: { content: ["oui-bg-base-9"] } } }, defaultVariants: { intensity: 800 } }), ot$4 = E$5.Root, Pl = E$5.Portal, Mi = ze__default.forwardRef(({ className: e2, ...o2 }, t) => {
  let { overlay: r3 } = We$7();
  return jsx(E$5.Overlay, { ref: t, className: r3({ className: e2 }), ...o2 });
});
Mi.displayName = E$5.Overlay.displayName;
var xo$3 = ze__default.forwardRef(({ overlyClassName: e2, className: o2, children: t, size: r3, closable: i = true, intensity: n4, ...a2 }, s2) => {
  let { content: l2, close: u2 } = We$7({ className: o2, size: r3, intensity: n4 });
  return jsxs(Pl, { children: [jsx(Mi, { className: e2 }), jsxs(E$5.Content, { ref: s2, className: l2({ className: o2 }), ...a2, children: [t, i && jsxs(E$5.Close, { className: u2(), "data-testid": "oui-testid-dialog-content-close-btn", children: [jsx(De$4, { size: 16, color: "white", opacity: 0.98 }), jsx("span", { className: "oui-sr-only", children: "Close" })] })] })] });
});
xo$3.displayName = E$5.Content.displayName;
var bo$3 = ({ className: e2, ...o2 }) => {
  let { header: t } = We$7();
  return jsx("div", { className: t({ className: e2 }), ...o2 });
};
bo$3.displayName = "DialogHeader";
var tt$3 = ({ className: e2, ...o2 }) => {
  let { body: t } = We$7();
  return jsx("div", { className: t({ className: e2 }), ...o2 });
}, Qt$5 = ({ className: e2, ...o2 }) => {
  let { footer: t } = We$7();
  return jsx("div", { className: t({ className: e2 }), ...o2 });
};
Qt$5.displayName = "DialogFooter";
var ho$5 = ze__default.forwardRef(({ className: e2, ...o2 }, t) => {
  let { title: r3 } = We$7();
  return jsx(E$5.Title, { ref: t, className: r3({ className: e2 }), ...o2 });
});
ho$5.displayName = E$5.Title.displayName;
var wo$4 = ze__default.forwardRef(({ className: e2, ...o2 }, t) => {
  let { desc: r3 } = We$7();
  return jsx(E$5.Description, { ref: t, className: r3({ className: e2 }), ...o2 });
});
wo$4.displayName = E$5.Description.displayName;
var rt$2 = (e2) => {
  var _a3, _b2;
  let { actions: o2 } = e2, [t, r3] = useState(((_a3 = o2 == null ? void 0 : o2.primary) == null ? void 0 : _a3.loading) ?? false);
  if (useEffect(() => {
    var _a4, _b3;
    return ((_a4 = o2 == null ? void 0 : o2.primary) == null ? void 0 : _a4.loading) && r3((_b3 = o2 == null ? void 0 : o2.primary) == null ? void 0 : _b3.loading), () => {
      r3(false);
    };
  }, [(_b2 = o2 == null ? void 0 : o2.primary) == null ? void 0 : _b2.loading]), !o2) return null;
  let i = useMemo(() => {
    var _a4, _b3;
    let n4 = [];
    if (o2.secondary && typeof o2.secondary.onClick == "function") {
      let { fullWidth: a2 = true, color: s2 = "gray", label: l2, ...u2 } = o2.secondary;
      n4.push(jsx($e$6, { ...u2, "data-testid": (_a4 = o2.secondary) == null ? void 0 : _a4["data-testid"], color: s2, fullWidth: a2, children: l2 }, "secondary"));
    }
    if (o2.primary && typeof o2.primary.onClick == "function") {
      let { fullWidth: a2 = true, color: s2, disabled: l2, label: u2, onClick: p2, ...g2 } = o2.primary;
      n4.push(jsx(Sr$2, { ...g2, "data-testid": (_b3 = o2.primary) == null ? void 0 : _b3["data-testid"], onClick: async (m2) => {
        if (!t) try {
          r3(true), await p2(m2);
        } catch {
        } finally {
          r3(false);
        }
      }, disabled: l2 || t, loading: t, fullWidth: a2, color: s2, children: u2 }, "primary"));
    }
    return n4;
  }, [o2, t]);
  return jsx(Qt$5, { className: e2.className, children: i });
};
var Se$5 = (e2) => {
  var _a3, _b2, _c2, _d3;
  let o2 = typeof e2.title == "function" ? e2.title() : e2.title;
  return jsx(ot$4, { open: e2.open, onOpenChange: e2.onOpenChange, children: jsxs(xo$3, { size: e2.size, closable: e2.closable, onOpenAutoFocus: (t) => t.preventDefault(), onCloseAutoFocus: (t) => t.preventDefault(), className: (_a3 = e2.classNames) == null ? void 0 : _a3.content, overlyClassName: (_b2 = e2.classNames) == null ? void 0 : _b2.overlay, ...e2.contentProps, children: [o2 && jsxs(Fragment$1, { children: [jsx(bo$3, { children: jsx(ho$5, { children: o2 }) }), jsx(de$5, {})] }), jsx(tt$3, { className: (_c2 = e2.classNames) == null ? void 0 : _c2.body, children: e2.children }), typeof e2.description < "u" && jsx(wo$4, { children: e2.description }), jsx(rt$2, { actions: e2.actions, className: (_d3 = e2.classNames) == null ? void 0 : _d3.footer })] }) });
};
function Vi$2(e2) {
  let o2 = (n4) => typeof window < "u" ? window.matchMedia(n4).matches : false, [t, r3] = useState(o2(e2));
  function i() {
    r3(o2(e2));
  }
  return useEffect(() => {
    var _a3;
    let n4 = window == null ? void 0 : window.matchMedia(e2);
    return i(), (n4 == null ? void 0 : n4.addListener) ? n4 == null ? void 0 : n4.addListener(i) : (_a3 = n4 == null ? void 0 : n4.addEventListener) == null ? void 0 : _a3.call(n4, "change", i), () => {
      var _a4;
      (n4 == null ? void 0 : n4.removeListener) ? n4 == null ? void 0 : n4.removeListener(i) : (_a4 = n4 == null ? void 0 : n4.removeEventListener) == null ? void 0 : _a4.call(n4, "change", i);
    };
  }, [e2]), t;
}
function it$6() {
  let e2 = Vi$2("(max-width: 768px)");
  return { isMobile: e2, isDesktop: !e2 };
}
function zm(e2, o2) {
  useEffect(() => {
    if (!e2) return;
    let t = new ResizeObserver((r3) => {
      for (let i of r3) o2(i);
    });
    return t.observe(e2), () => {
      t.unobserve(e2);
    };
  }, [e2]);
}
var Li = (e2) => {
  let [o2] = H$1("dialog"), { title: t, message: r3, open: i, onOpenChange: n4, onOk: a2, onCancel: s2, okLabel: l2 = o2.ok, cancelLabel: u2 = o2.cancel, size: p2, classNames: g2 } = e2, { isMobile: m2 } = it$6(), c = useMemo(() => {
    var _a3, _b2;
    if (typeof a2 != "function" && typeof s2 != "function") return;
    let b2 = {};
    return typeof s2 == "function" && (b2.secondary = { label: u2, onClick: s2, size: "md", fullWidth: true, ...(_a3 = e2.actions) == null ? void 0 : _a3.secondary }), typeof a2 == "function" && (b2.primary = { label: l2, size: "md", fullWidth: true, className: "oui-w-full lg:oui-w-[154px]", onClick: a2, ...(_b2 = e2.actions) == null ? void 0 : _b2.primary }), b2;
  }, [a2, s2, l2, u2, e2.actions]);
  return jsx(Se$5, { open: i, title: t, size: p2 || (m2 ? "xs" : "sm"), actions: c, onOpenChange: n4, classNames: { content: cnBase("oui-bg-base-8 oui-font-semibold oui-border oui-border-line-6", "oui-p-4 oui-pt-0 lg:oui-p-5 lg:oui-pt-0", g2 == null ? void 0 : g2.content), body: cnBase("oui-py-4 lg:oui-py-5", g2 == null ? void 0 : g2.body), footer: cnBase("oui-justify-center oui-pb-0 oui-pt-2 lg:oui-pt-3", g2 == null ? void 0 : g2.footer) }, children: r3 });
};
var Em = pe$3((e2) => {
  let { onOk: o2 } = e2, { visible: t, hide: r3, onOpenChange: a2 } = j$3(), s2 = useCallback(() => Promise.resolve().then(o2).then(r3), [o2]);
  return jsx(Li, { open: t, onOpenChange: a2, ...e2, onOk: s2 });
}), kl = (e2) => G$5.show(Em, e2);
var _m = pe$3((e2) => {
  let { visible: o2, onOpenChange: n4 } = j$3();
  return jsx(Se$5, { title: e2.title, open: o2, onOpenChange: n4, size: e2.size, closable: e2.closable, children: e2.content });
}), Rl = (e2) => G$5.show(_m, e2);
function Gm$1(e2) {
  return vo$4.create((o2) => {
    let { visible: t, hide: r3, resolve: i, reject: n4, onOpenChange: a2 } = j$3(), { title: s2, size: l2, contentClassName: u2, bodyClassName: p2, closable: g2, classNames: m2, ...c } = o2;
    return jsx(Se$5, { open: t, onOpenChange: a2, size: l2, title: s2, closable: g2, classNames: { content: u2, body: p2, ...m2 }, contentProps: { onInteractOutside: (x2) => {
      document.querySelector("#privy-dialog") && x2.preventDefault();
    } }, children: jsx(e2, { ...c, close: r3, resolve: i, reject: n4 }) });
  });
}
function Wm(e2, o2, t) {
  vo$4.register(e2, Gm$1(o2), t);
}
var Nl = pe$3((e2) => {
  let { size: o2 } = e2, { visible: t, hide: r3, resolve: i, reject: n4, onOpenChange: a2 } = j$3(), [s2] = H$1("modal"), { isMobile: l2 } = it$6(), u2 = l2 ? "xs" : "sm", p2 = typeof e2.title == "function" ? e2.title() : e2.title;
  return jsx(Se$5, { open: t, title: jsx(Q$1, { size: "base", weight: "semibold", children: p2 }), size: o2 || u2, classNames: { content: e2.contentClassName, body: e2.bodyClassName, ...e2.classNames }, closable: true, onOpenChange: (g2) => {
    g2 || n4(), a2(g2);
  }, actions: { primary: { label: e2.okLabel ?? s2.confirm, className: "oui-text-sm oui-font-semibold oui-w-[100%] oui-h-8", "data-testid": "oui-testid-confirm-dialog-confirm-btn", onClick: () => Promise.resolve().then(() => typeof e2.onOk == "function" ? e2.onOk() : true).then((g2) => {
    i(g2), r3();
  }, (g2) => {
    n4(g2), r3();
  }) }, secondary: { label: e2.cancelLabel ?? s2.cancel, className: "oui-text-sm oui-font-semibold oui-w-[100%] oui-h-8", "data-testid": "oui-testid-confirm-dialog-cancel-btn", onClick: () => Promise.resolve().then(() => typeof e2.onCancel == "function" ? e2.onCancel() : Promise.reject("cancel")).then((g2) => {
    i(g2), r3();
  }, (g2) => {
    n4(g2), r3();
  }) } }, children: jsx("div", { className: "oui-text-2xs lg:oui-text-sm", children: e2.content }) });
}), Tl = (e2) => G$5.show(Nl, e2);
var vo$4 = { create: pe$3, register: mo$3, unregister: hl, ...G$5, confirm: Tl, alert: kl, sheet: Cl, dialog: Rl };
function Zm(e2) {
  return vo$4.create((o2) => {
    let { title: t, leading: r3, classNames: i, contentProps: n4, closable: a2, ...s2 } = o2, { visible: l2, hide: u2, resolve: p2, reject: g2, onOpenChange: m2 } = j$3();
    return jsx(Jo, { open: l2, onOpenChange: m2, title: t, leading: r3, classNames: i, closable: a2, contentProps: n4, children: jsx(e2, { ...s2, close: u2, resolve: p2, reject: g2 }) });
  });
}
function Um(e2, o2, t) {
  vo$4.register(e2, Zm(o2), t);
}
var jm$1 = (e2) => {
  let { action: o2 } = e2, t = useCallback(() => {
    var _a3;
    typeof o2.onClick == "function" ? o2.onClick(o2) : (_a3 = e2.onClick) == null ? void 0 : _a3.call(e2, { ...o2, index: e2.index });
  }, [o2]), r3 = useMemo(() => o2.label, [o2.label]);
  return jsx("div", { className: cnBase("oui-flex oui-justify-center oui-items-center oui-text-lg oui-h-[52px] oui-cursor-pointer", e2.active && "oui-text-primary-darken"), onClick: t, children: r3 });
}, $m = (e2) => jsx("div", { className: "oui-relative oui-h-[1px] oui-bg-base-300 oui-mt-[-1px]" }), qm = (e2) => jsx(Fragment$1, { children: e2.actionSheets.map((o2, t) => o2.type === "division" ? jsx($m, {}, t) : jsxs(Fragment$2, { children: [o2.value === "cancel" && jsx("div", { className: "oui-h-2 oui-bg-base-10" }), jsx(jm$1, { onClick: (r3) => {
  var _a3, _b2;
  r3.value !== "cancel" && (typeof o2.onClick == "function" ? o2.onClick(o2) : ((_a3 = e2.onValueChange) == null ? void 0 : _a3.call(e2, r3.value), (_b2 = e2.onClose) == null ? void 0 : _b2.call(e2)));
}, index: t, action: o2, active: typeof e2.value < "u" && e2.value.value === o2.value }), t < e2.actionSheets.length - 1 && jsx(de$5, { className: "oui-border-base-contrast/10" })] }, o2.value || t)) }), _i$3 = (e2) => {
  let [o2] = H$1("modal"), t = useMemo(() => {
    let r3 = [];
    if (Array.isArray(e2.actionSheets)) for (let i of e2.actionSheets) typeof i == "string" ? i === "Cancel" ? r3.push({ label: o2.cancel, value: "cancel", onClick: () => {
      var _a3;
      (_a3 = e2.onClose) == null ? void 0 : _a3.call(e2);
    } }) : i === "Confirm" ? r3.push({ label: o2.confirm, value: "confirm" }) : i.startsWith("---") && r3.push({ label: "---", value: "---", type: "division" }) : r3.push(i);
    return r3;
  }, [e2.actionSheets]);
  return jsxs($o$1, { open: e2.open, onOpenChange: e2.onOpenChange, children: [typeof e2.children < "u" && jsx(Pi$1, { asChild: true, children: e2.children }), jsx(po$6, { closeable: false, className: "oui-action-sheet-content !oui-p-0 oui-pb-[env(safe-area-inset-bottom)]", onOpenAutoFocus: (r3) => r3.preventDefault(), children: jsx(qm, { actionSheets: t, onClose: e2.onClose, onValueChange: e2.onValueChange, value: e2.value }) })] });
};
var e0 = h$2({ base: "oui-flex oui-flex-row oui-items-stretch oui-rounded-md oui-cursor-pointer oui-border oui-border-line-6 oui-bg-line-4 oui-text-base-contrast-54", variants: { size: { sm: "oui-px-2 oui-h-[22px] oui-text-2xs", md: "oui-px-2 oui-h-[24px] oui-text-2xs", base: "oui-px-3 oui-h-[40px]", lg: "oui-px-6 oui-py-3" }, fullWidth: { true: "oui-w-full" }, disabled: { true: "oui-opacity-50 oui-cursor-not-allowed" }, color: { base: "oui-text-base-contract", buy: "oui-text-trade-profit", sell: "oui-text-trade-loss" } }, defaultVariants: { size: "base", color: "base" } }), Oi$2 = forwardRef(({ size: e2, color: o2, value: t, label: r3, placeholder: i, className: n4, options: a2, fullWidth: s2, disabled: l2, ...u2 }, p2) => {
  let [g2, m2] = useState(false), c = useMemo(() => {
    if (t && t.value) return t;
    if (typeof t == "number" || typeof t == "string") {
      let k2 = a2.find((f2) => f2.value === t);
      if (k2) return k2;
    }
  }, [t, a2]), x2 = useMemo(() => c ? c.label : i || r3 || "", [c, r3, i]), b2 = useMemo(() => [...a2, "---", "Cancel"], [a2]);
  return jsx(_i$3, { actionSheets: b2, onOpenChange: m2, open: g2, onClose: () => m2(false), value: c, onValueChange: u2.onValueChange, children: jsxs("div", { className: cnBase("oui-space-x-1 oui-text-base-contrast-54 ", "oui-rounded-md", "oui-bg-base-8", e0({ size: e2, color: o2, fullWidth: s2, disabled: l2 || a2.length === 0, className: n4 })), children: [jsx("div", { className: "oui-flex-1 oui-flex oui-justify-start oui-items-center oui-text-inherit oui-text-2xs", children: x2 }), jsx("div", { className: "oui-flex oui-items-center", children: g2 ? jsx(wt$4, { size: 14, color: "white" }) : jsx(ht$4, { size: 14, color: "white" }) })] }) });
});
var r0 = (e2) => jsx("div", { children: jsx(Yo$4, { size: "xs", ...e2, mode: "single", onChange: (o2) => {
} }) }), i0 = (e2) => {
  let { onChange: o2, ...t } = e2;
  return jsx("div", { className: "oui-min-w-[180px]", children: jsx(Uo$1, { size: "xs", ...t, onChange: (i) => {
    typeof o2 == "function" && o2(i);
  } }) });
}, a0 = (e2) => {
  let { onChange: o2, type: t, isCombine: r3, ...i } = e2;
  switch (t) {
    case "select":
      return jsx("div", { className: "oui-min-w-24", children: r3 ? jsx(Mt$4, { size: "xs", ...i, onValueChange: o2 }) : jsx(ao$3, { size: "xs", ...i, onValueChange: o2 }) });
    case "date":
      return jsx(r0, { ...i });
    case "range":
      return jsx(i0, { ...i, onChange: o2 });
    case "symbol":
      return jsx("div", {});
    case "picker":
      return jsx(Oi$2, { ...i, onValueChange: o2 });
    case "input":
    default:
      return jsx("div", { children: "No Component" });
  }
}, n0 = (e2) => jsxs(z$3, { justify: "start", gapX: 3, py: 3, width: "100%", className: cnBase("oui-data-filter-bar oui-border-b oui-border-line", e2.className), children: [e2.items.map((o2, t) => (o2.type === "date" && (o2.mode = "range"), jsx(a0, { ...o2, onChange: (r3) => {
  e2.onFilter({ name: o2.name ?? o2.type, value: r3 });
} }, t))), e2.trailing && jsx("div", { className: "oui-flex-1 oui-flex oui-justify-end", children: e2.trailing })] });
var p0 = (e2) => {
  let o2 = useRef(0), [t, r3] = useState((e2 == null ? void 0 : e2.page) ?? 1), [i, n4] = useState((e2 == null ? void 0 : e2.pageSize) ?? 10), a2 = useCallback((p2) => {
    if (n4(p2), o2.current > 0) {
      let g2 = Math.ceil(o2.current / p2);
      t > g2 && r3(g2);
    }
  }, [t]), s2 = (p2) => {
    let g2 = (p2 == null ? void 0 : p2.total) ?? o2.current;
    o2.current = g2;
    let m2 = (p2 == null ? void 0 : p2.records_per_page) ?? i, c = g2 ? Math.ceil(g2 / m2) : 0, x2 = Math.min((p2 == null ? void 0 : p2.current_page) ?? t, c);
    return { count: g2, page: x2, pageSize: m2, pageTotal: c };
  }, l2 = useCallback((p2) => ({ ...s2(p2), onPageChange: r3, onPageSizeChange: a2 }), [t, i]), u2 = useMemo(() => ({ page: t, pageSize: i, onPageChange: r3, onPageSizeChange: a2 }), [l2]);
  return useEffect(() => {
    (e2 == null ? void 0 : e2.resetPageWhenPageSizeChange) !== false && r3(1);
  }, [i, e2 == null ? void 0 : e2.resetPageWhenPageSizeChange]), { page: t, pageSize: i, setPage: r3, setPageSize: a2, parseMeta: s2, pagination: u2, parsePagination: l2 };
};
function d0() {
  return jsxs("svg", { xmlns: "http://www.w3.org/2000/svg", width: "64", height: "64", fill: "none", viewBox: "0 0 64 64", children: [jsx("rect", { width: "36", height: "48", x: "18", y: "5", fill: "#07080A", rx: "4" }), jsx("rect", { width: "36", height: "48", x: "11", y: "12", fill: "url(#paint0_linear_309_13641)", rx: "4" }), jsx("rect", { width: "36", height: "48", x: "9", y: "10", fill: "url(#paint1_linear_309_13641)", rx: "4" }), jsx("path", { fill: "#303237", d: "M36.636 53.323V50H6v3.323C6 55.91 7.943 58 10.462 58H41c-2.392 0-4.364-2.168-4.364-4.663" }), jsx("rect", { width: "9", height: "2", x: "15", y: "16", fill: "#3F4146", rx: "1" }), jsx("rect", { width: "16", height: "2", x: "15", y: "24", fill: "#3F4146", rx: "1" }), jsx("rect", { width: "12", height: "3", x: "28", y: "29", fill: "#45484E", rx: "1.5" }), jsx("path", { fill: "#45484E", d: "M33 23a2 2 0 012-2h1.5a1.5 1.5 0 010 3H34a1 1 0 01-1-1z" }), jsx("rect", { width: "9", height: "3", x: "29", y: "37", fill: "#45484E", rx: "1.5" }), jsx("rect", { width: "13", height: "2", x: "15", y: "30", fill: "#3F4146", rx: "1" }), jsx("rect", { width: "15", height: "2", x: "15", y: "36", fill: "#3F4146", rx: "1" }), jsx("rect", { width: "24", height: "2", x: "15", y: "42", fill: "#3F4146", rx: "1" }), jsx("path", { fill: "#181A1D", fillRule: "evenodd", d: "M27.24 30.022a12.451 12.451 0 1122.195 9.87l5.328 5.328-1.58 1.58-5.241-5.24a12.452 12.452 0 01-20.703-11.537zm14.193 12.39A10.156 10.156 0 1037.47 22.49a10.156 10.156 0 003.963 19.92z", clipRule: "evenodd" }), jsx("path", { fill: "#54565B", fillRule: "evenodd", d: "M27.24 29.022a12.451 12.451 0 1122.195 9.87l5.328 5.328-1.58 1.58-5.241-5.24a12.452 12.452 0 01-20.703-11.537zm14.193 12.39A10.156 10.156 0 1037.47 21.49a10.156 10.156 0 003.963 19.92z", clipRule: "evenodd" }), jsx("path", { fill: "#16181B", d: "M51.755 43.867c-.99.99-.99 2.596 0 3.586l3.754 3.754a2.536 2.536 0 103.586-3.586l-3.754-3.754a2.536 2.536 0 00-3.586 0z" }), jsx("path", { fill: "#4E525C", d: "M51.755 42.867c-.99.99-.99 2.596 0 3.586l3.754 3.754a2.536 2.536 0 103.586-3.586l-3.754-3.754a2.536 2.536 0 00-3.586 0z" }), jsxs("defs", { children: [jsxs("linearGradient", { id: "paint0_linear_309_13641", x1: "27.286", x2: "48.844", y1: "55.742", y2: "25.703", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "#0C0D10" }), jsx("stop", { offset: "1", stopColor: "#121418" })] }), jsxs("linearGradient", { id: "paint1_linear_309_13641", x1: "25.286", x2: "46.844", y1: "53.742", y2: "23.703", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "#1B1D22" }), jsx("stop", { offset: "1", stopColor: "#26292E" })] })] })] });
}
var Ll = d0;
var er$1 = (e2) => {
  let [o2] = H$1("empty");
  return jsxs(z$3, { itemAlign: "center", direction: "column", gapY: 4, className: e2.className, children: [jsx(W$2, { children: jsx(Ll, {}) }), jsx(Q$1, { as: "div", intensity: 36, size: "2xs", children: e2.title ?? o2.description })] });
};
Zo({ name: "emptyDataIdentifier", positions: ["emptyDataIdentifier"] })(er$1);
var Fl = {};
vr$4(Fl, { DownloadFeature: () => El$1 });
var El$1 = { createTable: (e2) => {
  e2.getPlainTextData = () => {
    let o2 = e2.getAllColumns().filter((i) => i.columnDef.meta.type !== "action").map((i) => {
      let { title: n4, plantTextTitle: a2 } = i.columnDef.meta;
      return a2 || n4;
    }), t = e2.getRowModel().rows.map((i) => i.getVisibleCells().filter((n4) => n4.column.columnDef.meta.type !== "action").map((n4) => {
      let { original: a2, index: s2 } = n4.row, { renderPlantText: l2 } = n4.column.columnDef.meta || {}, u2 = n4.getValue();
      return typeof l2 == "function" && (u2 = l2(u2, a2, s2)), `"${u2}"`;
    }));
    return [o2, ...t];
  }, e2.download = (o2) => {
    let t = e2.getPlainTextData();
    f0(t, o2);
  };
} };
function g0(e2) {
  return e2.map((o2) => o2.join(",")).join(`
`);
}
function f0(e2, o2 = `${Date.now()}.csv`) {
  let t = g0(e2), r3 = new Blob([t], { type: "text/csv;charset=utf-8;" }), i = URL.createObjectURL(r3), n4 = document.createElement("a");
  n4.href = i, n4.setAttribute("download", o2), n4.click(), URL.revokeObjectURL(i);
}
var Gi$2 = h$2({ slots: { list: ["oui-header-list", "oui-flex", "oui-items-center"], content: ["oui-ring-offset-background", "focus-visible:oui-outline-none", "focus-visible:oui-ring-2", "focus-visible:oui-ring-ring", "focus-visible:oui-ring-offset-2"], trigger: ["oui-tab-trigger", "oui-inline-flex", "oui-items-center", "oui-justify-center", "oui-whitespace-nowrap", "oui-box-content", "oui-font-medium", "oui-text-base-contrast-36 hover:oui-text-base-contrast-54", "oui-ring-offset-background", "oui-transition-all", "oui-space-x-1", "focus-visible:oui-outline-none", "focus-visible:oui-ring-2", "focus-visible:oui-ring-ring", "focus-visible:oui-ring-offset-2", "disabled:oui-pointer-events-none", "disabled:oui-opacity-50"], icon: ["oui-text-inherit"] }, variants: { variant: { text: { list: ["oui-space-x-6", "oui-border-b", "oui-border-line-6", "oui-px-1"], trigger: ["oui-pb-2", "oui-relative", "data-[state=active]:oui-text-base-contrast", "data-[state=active]:after:oui-content-['']", "data-[state=active]:after:oui-block", "data-[state=active]:after:oui-h-[3px]", "data-[state=active]:after:oui-bg-white", "data-[state=active]:after:oui-absolute", "data-[state=active]:after:oui-rounded-full", "data-[state=active]:after:-oui-bottom-0", "data-[state=active]:after:oui-left-0", "data-[state=active]:after:oui-right-0"] }, contained: { list: ["oui-space-x-[6px]"], trigger: ["oui-rounded", "oui-px-3", "oui-bg-base-7 hover:oui-bg-base-5", "oui-text-base-contrast-36", "data-[state=active]:oui-bg-base-5", "data-[state=active]:oui-text-base-contrast"], icon: ["oui-text-inherit"] } }, size: { sm: {}, md: {}, lg: {}, xl: {} } }, compoundVariants: [{ size: "sm", variant: "text", className: { trigger: ["oui-text-sm", "oui-h-5"], icon: ["oui-w-[10px]", "oui-h-[10px]"] } }, { size: "md", variant: "text", className: { trigger: ["oui-text-base", "oui-h-6"], icon: ["oui-w-3", "oui-h-3"] } }, { size: "lg", variant: "text", className: { trigger: ["oui-text-lg", "oui-h-7"], icon: ["oui-w-[14px]", "oui-h-[14px]"] } }, { size: "xl", variant: "text", className: { trigger: ["oui-text-lg", "oui-h-7"], icon: ["oui-w-4", "oui-h-4"] } }, { size: "sm", variant: "contained", className: { list: ["oui-space-x-1"], trigger: ["oui-text-2xs", "oui-h-6"], icon: ["oui-w-[10px]", "oui-h-[10px]"] } }, { size: "md", variant: "contained", className: { trigger: ["oui-text-2xs", "oui-h-7"], icon: ["oui-w-3", "oui-h-3"] } }, { size: "lg", variant: "contained", className: { trigger: ["oui-text-sm", "oui-h-8", "oui-rounded-md"], icon: ["oui-w-[14px]", "oui-h-[14px]"] } }, { size: "xl", variant: "contained", className: { trigger: ["oui-text-base", "oui-h-9", "oui-rounded-md"], icon: ["oui-w-4", "oui-h-4"] } }], defaultVariants: { size: "md", variant: "text" } }), Wi$2 = ie$2.Root, or$4 = ze__default.forwardRef(({ className: e2, size: o2, variant: t, ...r3 }, i) => {
  let { list: n4 } = Gi$2({ size: o2, variant: t });
  return jsx(ie$2.List, { ref: i, className: n4({ className: e2 }), ...r3 });
});
or$4.displayName = ie$2.List.displayName;
var tr$2 = ze__default.forwardRef(({ className: e2, size: o2, children: t, icon: r3, variant: i, ...n4 }, a2) => {
  let { trigger: s2, icon: l2 } = Gi$2({ size: o2, variant: i });
  return jsxs(ie$2.Trigger, { ref: a2, className: s2({ className: e2 }), ...n4, children: [typeof r3 < "u" ? ze__default.cloneElement(r3, { className: l2(), opacity: 1 }) : null, jsx("span", { children: t })] });
});
tr$2.displayName = ie$2.Trigger.displayName;
var rr$2 = ze__default.forwardRef(({ className: e2, size: o2, ...t }, r3) => {
  let { content: i } = Gi$2({ size: o2 });
  return jsx(ie$2.Content, { ref: r3, className: i({ className: e2 }), ...t });
});
rr$2.displayName = ie$2.Content.displayName;
var _l = (e2) => (useEffect(() => {
  if (e2.components && Object.keys(e2.components).length) for (let o2 in e2.components) {
    let t = e2.components[o2];
    Zo({ name: t.displayName ?? `custom-component-${o2}`, positions: [o2], __isInternal: false })((r3) => jsx(t, { ...r3 }));
  }
}, [e2.components]), e2.children);
var Ol = createContext({}), Ui$1 = () => useContext(Ol), y0 = (e2) => {
  let o2 = (t, r3) => {
    var _a3;
    return ((_a3 = e2.overrides) == null ? void 0 : _a3[t]) || r3;
  };
  return jsx(Ol.Provider, { value: { getComponentTheme: o2 }, children: jsx(_l, { components: e2.components, children: e2.children }) });
};
function Hl(e2) {
  let [o2, t] = useState(false), [r3, i] = useState(0), [n4, a2] = useState(0);
  return { handleMouseDown: (p2) => {
    e2.current && (t(true), i(p2.pageX - e2.current.offsetLeft), a2(e2.current.scrollLeft));
  }, handleMouseMove: (p2) => {
    if (!o2 || !e2.current) return;
    p2.preventDefault();
    let m2 = p2.pageX - e2.current.offsetLeft - r3;
    e2.current.scrollLeft = n4 - m2;
  }, handleMouseUp: () => {
    t(false);
  }, isDragging: o2 };
}
function Zl$1() {
  let [e2, o2] = useState(false), [t, r3] = useState(false), i = useRef(null);
  return useEffect(() => {
    if (!i.current) return;
    let a2 = () => {
      let u2 = i.current;
      u2 && (o2(u2.scrollLeft > 0), r3(u2.scrollLeft + u2.clientWidth < u2.scrollWidth));
    }, s2 = new IntersectionObserver((u2) => {
      u2.forEach((p2) => {
        p2.isIntersecting && a2();
      });
    }), l2 = i.current;
    return l2.addEventListener("scroll", a2), s2.observe(l2), () => {
      l2.removeEventListener("scroll", a2), s2.disconnect();
    };
  }, []), useEffect(() => {
    if (!i.current) return;
    let a2 = new IntersectionObserver((s2) => {
      s2.forEach((l2) => {
        l2.isIntersecting;
      });
    });
    return a2.observe(i.current), () => {
      a2.disconnect();
    };
  }, []), { containerRef: i, leadingVisible: e2, tailingVisible: t, onScoll: (a2) => {
    var _a3, _b2;
    a2 === "left" ? (_a3 = i.current) == null ? void 0 : _a3.scrollBy({ left: -100, behavior: "smooth" }) : (_b2 = i.current) == null ? void 0 : _b2.scrollBy({ left: 100, behavior: "smooth" });
  } };
}
var Xi = (e2) => {
  let { visible: o2, leading: t, tailing: r3, onClick: i } = e2;
  return o2 ? jsxs("button", { onClick: () => {
    i == null ? void 0 : i(t ? "left" : "right");
  }, className: cnBase(t ? "oui-scroll-indicator-leading" : "oui-scroll-indicator-tailing", "oui-group oui-flex", "oui-absolute oui-top-0 oui-bottom-0", t && "oui-left-0 oui-flex-row-reverse", r3 && "oui-right-0"), children: [jsx("div", { className: cnBase("oui-w-6 oui-h-full", "oui-bg-[linear-gradient(90deg,rgba(var(--oui-color-base-9)_/_0)_0%,rgba(var(--oui-color-base-9)_/_1)_100%)]", t && "oui-rotate-180") }), jsx("div", { className: cnBase("oui-flex oui-justify-center oui-items-center", "oui-w-3 oui-bg-base-9 oui-h-full"), children: jsx(P0, { className: cnBase("oui-text-base-contrast-54 group-hover:oui-text-base-contrast", t && "oui-rotate-180") }) })] }) : null;
}, P0 = (e2) => jsx("svg", { width: "6", height: "14", viewBox: "0 0 6 14", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...e2, children: jsx("path", { d: "M1.194.025C.944-.026.675-.005.446.15a1.027 1.027 0 0 0-.28 1.406l3.612 5.437L.166 12.43c-.305.459-.177 1.1.28 1.406a1.02 1.02 0 0 0 1.401-.281l3.986-6a1.03 1.03 0 0 0 0-1.125l-3.986-6C1.695.2 1.444.075 1.194.025" }) });
var $i = (e2) => {
  let { containerRef: o2, leadingVisible: t, tailingVisible: r3, onScoll: i } = Zl$1(), { handleMouseDown: n4, handleMouseMove: a2, handleMouseUp: s2, isDragging: l2 } = Hl(o2);
  return jsxs("div", { className: cnBase("oui-scroll-indicator", "oui-relative oui-overflow-hidden oui-select-none", e2.className), children: [jsx("div", { ref: o2, className: cnBase("oui-overflow-x-scroll oui-hide-scrollbar", l2 ? "oui-cursor-grabbing" : "oui-cursor-grab"), onMouseDown: n4, onMouseMove: a2, onMouseUp: s2, onMouseLeave: s2, children: e2.children }), jsx(Xi, { leading: true, onClick: i, visible: t }), jsx(Xi, { tailing: true, onClick: i, visible: r3 })] });
};
var Xl = createContext({}), jl = (e2) => {
  let { getComponentTheme: o2 } = Ui$1(), { classNames: t, contentVisible: r3 = true, variant: i, showScrollIndicator: n4, ...a2 } = e2, s2 = o2("tabs", { variant: "contained" }), [l2, u2] = useState({}), p2 = (m2) => {
    u2((c) => ({ ...c, [m2.value]: m2 }));
  }, g2 = () => {
    var _a3, _b2;
    let m2 = jsx(or$4, { variant: s2.variant, size: a2.size, className: cnBase("oui-flex-1 oui-border-0", (_a3 = e2.classNames) == null ? void 0 : _a3.tabsList), children: Object.keys(l2).map((c) => {
      let x2 = l2[c];
      return jsx(tr$2, { value: x2.value, icon: x2.icon, variant: s2.variant, size: a2.size, "data-testid": x2.testid, children: x2.title }, c);
    }) });
    return n4 ? jsx($i, { className: (_b2 = e2.classNames) == null ? void 0 : _b2.scrollIndicator, children: m2 }) : m2;
  };
  return jsxs(Xl.Provider, { value: { registerTab: p2 }, children: [e2.children, jsxs(Wi$2, { ...a2, children: [jsxs(z$3, { justify: "between", itemAlign: "center", width: "100%", className: cnBase(s2.variant !== "contained" && "oui-border-b oui-border-b-line-6"), children: [e2.leading, g2(), e2.trailing] }), r3 && Object.keys(l2).map((m2) => {
    var _a3;
    let c = l2[m2];
    return jsx(rr$2, { value: c.value, className: (_a3 = e2.classNames) == null ? void 0 : _a3.tabsContent, children: c.content }, m2);
  })] })] });
};
jl.displayName = "Tabs";
var $l = (e2) => {
  let { title: o2, value: t, icon: r3, testid: i } = e2, { registerTab: n4 } = useContext(Xl);
  return useEffect(() => {
    let a2 = { title: o2, value: t, icon: r3, testid: i, content: e2.children };
    n4(a2);
  }, [e2.children, o2, t]), null;
};
$l.displayName = "TabPanel";
var D0 = h$2({ base: ["oui-card-root", "oui-card", "oui-rounded-xl", "oui-shadow", "oui-text-base-contrast", "oui-p-6"], variants: { ...mt$3.variants }, defaultVariants: { intensity: 900 } }), sr$3 = ze__default__default.forwardRef(({ className: e2, intensity: o2, ...t }, r3) => jsx("div", { ref: r3, className: D0({ intensity: o2, className: e2 }), ...t }));
sr$3.displayName = "CardBase";
var lr$2 = ze__default__default.forwardRef(({ className: e2, ...o2 }, t) => jsx("div", { ref: t, className: cnBase("oui-card-header oui-flex oui-flex-col oui-space-y-1.5", e2), ...o2 }));
lr$2.displayName = "CardHeader";
var ur$4 = ze__default__default.forwardRef(({ className: e2, ...o2 }, t) => jsx("h3", { ref: t, className: cnBase("oui-card-header-title oui-font-semibold oui-leading-none oui-tracking-tight oui-text-lg", e2), ...o2 }));
ur$4.displayName = "CardTitle";
var ql = ze__default__default.forwardRef(({ className: e2, ...o2 }, t) => jsx("p", { ref: t, className: cnBase("oui-text-sm oui-text-muted-foreground", e2), ...o2 }));
ql.displayName = "CardDescription";
var cr$3 = ze__default__default.forwardRef(({ className: e2, ...o2 }, t) => jsx("div", { ref: t, className: cnBase("oui-card-content oui-pt-4", e2), ...o2 }));
cr$3.displayName = "CardContent";
var pr$2 = ze__default__default.forwardRef(({ className: e2, ...o2 }, t) => jsx("div", { ref: t, className: e2, ...o2 }));
pr$2.displayName = "CardFooter";
var Kl = forwardRef((e2, o2) => {
  let { title: t, children: r3, footer: i, classNames: n4, ...a2 } = e2;
  return jsxs(sr$3, { ...a2, className: n4 == null ? void 0 : n4.root, ref: o2, children: [jsx(lr$2, { className: n4 == null ? void 0 : n4.header, children: typeof e2.title == "string" ? jsx(ur$4, { children: t }) : t }), jsx(cr$3, { className: n4 == null ? void 0 : n4.content, children: r3 }), i && jsx(pr$2, { className: n4 == null ? void 0 : n4.footer, children: i })] });
});
Kl.displayName = "Card";
var V0 = ae$4.Root, B0 = ae$4.Trigger, eu = ze__default.forwardRef(({ className: e2, align: o2 = "center", sideOffset: t = 4, ...r3 }, i) => jsx(ae$4.Content, { ref: i, align: o2, sideOffset: t, className: cnBase("oui-z-[100] oui-w-64 oui-rounded-md oui-bg-base-8 oui-p-3 oui-text-base-contrast oui-shadow-md oui-outline-none data-[state=open]:oui-animate-in data-[state=closed]:oui-animate-out data-[state=closed]:oui-fade-out-0 data-[state=open]:oui-fade-in-0 data-[state=closed]:oui-zoom-out-95 data-[state=open]:oui-zoom-in-95 data-[side=bottom]:oui-slide-in-from-top-2 data-[side=left]:oui-slide-in-from-right-2 data-[side=right]:oui-slide-in-from-left-2 data-[side=top]:oui-slide-in-from-bottom-2", e2), ...r3 }));
eu.displayName = ae$4.Content.displayName;
var L0 = (e2) => {
  let { content: o2, open: t, defaultOpen: r3, onOpenChange: i, children: n4, ...a2 } = e2;
  return jsxs(V0, { open: t, defaultOpen: r3, onOpenChange: i, children: [jsx(B0, { asChild: true, children: n4 }), jsx(ae$4.Portal, { children: jsxs(eu, { ...a2, children: [o2, jsx(ae$4.Arrow, { width: 11, height: 5, className: "oui-fill-base-4" })] }) })] });
};
L0.displayName = "HoverCard";
var E0 = Yo$4;
E0.range = Uo$1;
function ou$1(e2, [o2, t]) {
  return Math.min(t, Math.max(o2, e2));
}
function gr$2(e2, o2, t) {
  let r3 = t - o2;
  if (r3 === 0) return ou$1(0, [0, 100]);
  let n4 = 100 / r3 * (e2 - o2);
  return ou$1(n4, [0, 100]);
}
function F0(e2, o2) {
  return (t) => {
    let r3 = (o2[1] - o2[0]) / (e2[1] - e2[0]);
    return o2[0] + r3 * (t - e2[0]);
  };
}
function tu$1(e2, o2, t) {
  let r3 = e2 / 2, n4 = F0([0, 50], [0, r3]);
  return (r3 - n4(o2) * t) * t;
}
var O0 = h$2({ slots: { root: "oui-relative oui-flex oui-w-full oui-touch-none oui-select-none oui-items-center", thumb: ["oui-block", "oui-h-[10px]", "oui-w-[10px]", "oui-rounded-full", "oui-border-[2px]", "oui-border-primary", "oui-bg-base-6", "oui-shadow", "oui-group", "oui-transition-colors", "focus-visible:oui-outline-none", "focus:oui-shadow-[0_0_0_8px]", "focus:oui-shadow-base-contrast/20", "focus:oui-h-[14px]", "focus:oui-w-[14px]", "data-[disabled]:oui-pointer-events-none", "data-[disabled]:oui-border-base-2", "data-[disabled]:oui-hidden"], track: "oui-relative oui-h-[8px] oui-w-full oui-grow oui-overflow-hidden oui-rounded-full", trackInner: "oui-absolute oui-left-0 oui-right-0 oui-h-[2px] oui-top-[3px]  oui-pointer-events-none oui-bg-base-2", range: "oui-absolute oui-h-[2px] oui-top-[3px] oui-bg-primary data-[disabled]:oui-bg-base-2", mark: "oui-absolute oui-top-[1px] oui-w-[6px] oui-h-[6px] oui-rounded oui-border oui-border-base-2 oui-bg-base-6 oui-pointer-events-none oui-translate-x-[-50%]", tips: ["oui-absolute", "oui-hidden", "oui-rounded", "oui-drop-shadow", "oui-w-[36px]", "oui-h-[19px]", "oui-translate-x-[-12px]", "oui-top-[-28px]", "oui-font-semibold", "oui-text-center", "group-focus:oui-inline-block", "after:oui-block", "after:oui-absolute", "after:oui-bottom-[-8px]", "after:oui-w-0", "after:oui-h-0", "after:oui-border-4", "after:oui-left-1/2", "after:oui-translate-x-[-50%]", "after:oui-border-solid", "after:oui-border-transparent", "after:oui-border-t-inherit", "oui-text-base-5", "oui-text-2xs"] }, variants: { color: { primary: { thumb: ["oui-border-primary", "oui-bg-base-5"], range: "oui-bg-primary", tips: "oui-bg-primary after:oui-border-t-primary" }, primaryLight: { thumb: ["oui-border-primary-light", "oui-bg-base-5"], range: "oui-bg-primary-light", tips: "oui-bg-primary-light after:oui-border-t-primary-light" }, buy: { thumb: ["oui-border-success", "oui-bg-base-5"], range: "oui-bg-success", tips: ["oui-bg-success after:oui-border-t-success"] }, sell: { thumb: ["oui-border-danger", "oui-bg-base-5"], range: "oui-bg-danger", tips: ["oui-bg-danger after:oui-border-t-danger"] } } } }), Qi$1 = ze__default.forwardRef(({ className: e2, color: o2, marks: t, markCount: r3, classNames: i, markLabelVisible: n4, showTip: a2, onValueChange: s2, value: l2, ...u2 }, p2) => {
  let { track: g2, range: m2, thumb: c, root: x2, trackInner: b2, mark: k2, tips: f2 } = O0({ color: o2 }), [T2, N2] = ze__default.useState(l2);
  ze__default.useEffect(() => {
    N2((y2) => !y2 || (l2 == null ? void 0 : l2.some((B2, U2) => B2 !== y2[U2])) ? l2 : y2);
  }, [l2]);
  let v3 = useMemo(() => {
    if (Array.isArray(t) && t.length > 0) return t;
    let y2 = u2.max;
    if (y2 || (y2 = 100), typeof r3 < "u") {
      let B2 = [], U2 = y2 / r3, K2 = r3 - 1;
      for (let ne2 = 0; ne2 <= K2; ne2++) {
        let w4 = ne2 * U2;
        B2.push({ value: w4, label: `${w4}` });
      }
      return B2.push({ value: y2, label: "100" }), B2;
    }
    return [];
  }, [t, r3, u2.max]), M2 = (y2) => {
    N2(y2), s2 == null ? void 0 : s2(y2);
  };
  return jsxs(ke$6.Root, { ref: p2, className: x2({ className: e2 }), value: s2 ? l2 : T2, onValueChange: s2 || M2, ...u2, children: [jsxs(ke$6.Track, { className: g2({ className: i == null ? void 0 : i.track }), children: [jsx("div", { className: b2() }), jsx(ke$6.Range, { className: m2({ className: i == null ? void 0 : i.range }) })] }), Array.isArray(v3) && v3.length > 0 && jsx(H0, { value: T2, color: o2, marks: v3, isInnerMask: !Array.isArray(t) || t.length === 0, markLabelVisible: n4, disabled: u2.disabled, className: k2(), step: u2.step }), jsx(ke$6.Thumb, { className: c({ className: cnBase(i == null ? void 0 : i.thumb, "oui-slider-thumb") }), children: a2 && jsx(G0, { value: T2, className: f2({ color: o2 }), max: u2.max ?? 100, min: 0, tipFormatter: u2.tipFormatter }) })] });
});
Qi$1.displayName = ke$6.Root.displayName;
var H0 = (e2) => {
  let { marks: o2, value: t, isInnerMask: r3, markLabelVisible: i, className: n4, color: a2 = "primary" } = e2, s2 = useMemo(() => (t == null ? void 0 : t[0]) ?? 0, [t]), l2 = useMemo(() => {
    if (!(typeof e2.step > "u")) return Math.floor(s2 / e2.step);
  }, [s2, e2.step]), u2 = useMemo(() => {
    switch (a2) {
      case "primary":
        return "oui-border-primary oui-bg-primary";
      case "buy":
        return "oui-border-trade-profit oui-bg-trade-profit";
      case "sell":
        return "oui-border-trade-loss oui-bg-trade-loss";
      case "primaryLight":
        return "oui-border-primary-light oui-bg-primary-light";
    }
  }, [a2]), p2 = useMemo(() => {
    switch (a2) {
      case "primary":
        return "oui-text-primary";
      case "buy":
        return "oui-texttrade-profit";
      case "sell":
        return "oui-text-trade-loss";
      case "primaryLight":
        return "oui-text-primary-light";
    }
  }, [a2]);
  return jsx(Fragment$1, { children: o2 == null ? void 0 : o2.map((g2, m2) => {
    let c = gr$2(m2, 0, o2.length - 1), x2 = tu$1(6, c, 1), b2 = r3 ? g2.value : m2, f2 = (r3 ? s2 >= b2 : (l2 ?? 0) >= b2) && s2 >= 0 && !e2.disabled ? u2 : "";
    return jsxs(Fragment$2, { children: [jsx("span", { className: cnBase(n4, f2), style: { left: `calc(${c}% + ${x2}px)` } }), !e2.disabled && i && jsx("span", { "data-testid": `oui-testid-slider-mark-label-${g2.label}`, className: cnBase("oui-absolute oui-top-[16px] oui-text-2xs xl:oui-text-xs oui-text-base-contrast-54 oui-cursor-pointer oui-translate-x-[-50%]", l2 === m2 && p2), style: { left: `calc(${c}% + ${x2}px)` }, children: g2.label }, m2)] }, m2);
  }) });
}, G0 = (e2) => {
  var _a3, _b2;
  let { className: o2, min: t, max: r3 } = e2, i = ((_a3 = e2.value) == null ? void 0 : _a3[0]) ?? 0, n4 = gr$2(i, t, r3);
  return jsx("span", { className: o2, style: { lineHeight: "19px" }, children: ((_b2 = e2.tipFormatter) == null ? void 0 : _b2.call(e2, i, t, r3, n4)) ?? `${n4.toFixed()}%` });
}, ru = ze__default.forwardRef((e2, o2) => {
  let t = useMemo(() => [e2.value], [e2.value]);
  return jsx(Qi$1, { ...e2, value: t, ref: o2, onValueChange: typeof e2.onValueChange == "function" ? (r3) => {
    e2.onValueChange(r3[0]);
  } : void 0, onValueCommit: typeof e2.onValueCommit == "function" ? (r3) => {
    e2.onValueCommit(r3[0]);
  } : void 0 });
});
ru.displayName = "SingleSlider";
var iu = Qi$1;
iu.single = ru;
var ea$2 = ze__default__default.forwardRef((e2, o2) => {
  let { opacity: t = 1, viewBox: r3 = "0 0 20 20", ...i } = e2;
  return jsx(d$1, { ref: o2, viewBox: r3, ...i, children: jsx("path", { d: "M10 1.628a8.333 8.333 0 1 0-.001 16.666 8.333 8.333 0 0 0 0-16.666m-2.5 5c.212 0 .435.071.598.234L10 8.762l1.9-1.9a.85.85 0 0 1 .6-.234c.213 0 .436.071.6.234a.86.86 0 0 1 0 1.198l-1.902 1.901 1.901 1.9a.86.86 0 0 1 0 1.2.86.86 0 0 1-1.198 0L10 11.158 8.097 13.06a.86.86 0 0 1-1.198 0 .857.857 0 0 1 0-1.198L8.8 9.96l-1.9-1.9a.857.857 0 0 1 0-1.2.84.84 0 0 1 .6-.233", fill: "#FF447C", fillOpacity: t }) });
}), oa$2 = ze__default__default.forwardRef((e2, o2) => {
  let { opacity: t = 1, viewBox: r3 = "0 0 20 20", ...i } = e2;
  return jsx(d$1, { ref: o2, viewBox: r3, ...i, children: jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M1.678 10a8.333 8.333 0 1 1 16.667-.001 8.333 8.333 0 0 1-16.667 0m12.477-3.907c.189-.18.448-.26.697-.26s.507.08.697.26c.38.362.38.969 0 1.33l-6.793 6.473a1.033 1.033 0 0 1-1.394 0l-2.911-2.774a.92.92 0 0 1 0-1.33 1.034 1.034 0 0 1 1.395 0l2.213 2.11z", fill: "#00B49E" }) });
}), ta$3 = ze__default__default.forwardRef((e2, o2) => {
  let { opacity: t = 1, viewBox: r3 = "0 0 20 20", ...i } = e2;
  return jsx(d$1, { ref: o2, viewBox: r3, ...i, children: jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M9.167 3.333c0-.46.373-.833.833-.833A7.5 7.5 0 1 1 2.5 10a.833.833 0 0 1 1.667 0A5.834 5.834 0 1 0 10 4.167a.833.833 0 0 1-.833-.834", fill: "#4774F6", fillOpacity: t }) });
});
ea$2.displayName = "ToasterErrorIcon";
oa$2.displayName = "ToastSuccessIcon";
ta$3.displayName = "ToastLoadingIcon";
var X0 = (e2) => jsx(Toaster, { toastOptions: { duration: 3e3, success: { iconTheme: { primary: "rgba(123, 220, 138, 1)", secondary: "rgba(25, 14, 44, 1)" }, style: { background: "rgba(40, 46, 58, 1)" } }, loading: { duration: 5e3, style: { background: "rgba(40, 46, 58, 1)" } }, error: { iconTheme: { primary: "rgba(217, 91, 129, 1)", secondary: "rgba(25, 14, 44, 1)" }, style: { background: "rgba(40, 46, 58, 1)" } } }, ...e2, containerClassName: cnBase("!top-[62px] md:!top-[80px] oui-font-semibold", e2.className), children: (o2) => jsx(ToastBar, { toast: o2, style: { ...o2.style, color: "rgba(255, 255, 255, 0.8)", borderRadius: "6px", wordBreak: "break-all", maxWidth: 800, boxShadow: "0px 4px 8px 0px rgba(0, 0, 0, 0.36)" }, children: ({ icon: t, message: r3 }) => {
  let i = t;
  return o2.type === "error" ? i = jsx(ea$2, { className: "w-[16px] h-[16px] md:w-[24px] md:h-[24px]" }) : o2.type === "success" ? i = jsx(oa$2, { size: 20 }) : o2.type === "loading" && (i = jsx("div", { className: "oui-animate-rotate-360 oui-rounded-full", children: jsx(ta$3, { className: "w-[16px] h-[16px] md:w-[24px] md:h-[24px]" }) })), jsxs("div", { className: "oui-flex oui-items-center oui-padding-[12px] md:oui-padding-[16px]", children: [i, jsx("div", { className: "oui-text-base oui-px-[2px]", children: r3 }), jsx("button", { onClick: () => toast$1.dismiss(o2.id), className: "oui-hidden md:oui-block", children: jsx(De$4, { size: 16, className: " oui-text-base-contrast-54" }) })] });
} }) });
function lu(e2, o2) {
  let t = useRef(), r3 = useRef(o2);
  r3.current = o2, useEffect(() => {
    let i = { root: null, rootMargin: "0px", threshold: 0 }, n4 = (a2) => {
      a2.forEach((s2) => {
        var _a3;
        s2.isIntersecting && ((_a3 = r3.current) == null ? void 0 : _a3.call(r3));
      });
    };
    return t.current = new IntersectionObserver(n4, i), () => {
      var _a3;
      (_a3 = t.current) == null ? void 0 : _a3.disconnect();
    };
  }, []), useEffect(() => {
    var _a3;
    (_a3 = t.current) == null ? void 0 : _a3.observe(e2.current);
  }, []);
}
var eg$1 = (e2, o2) => {
  let t = useRef(null), r3 = useRef(null);
  lu(t, () => {
    var _a3;
    e2.isLoading || ((_a3 = e2.loadMore) == null ? void 0 : _a3.call(e2));
  });
  let i = useMemo(() => Array.isArray(e2.dataSource) && e2.dataSource.length <= 0, [e2.dataSource]), n4 = useMemo(() => e2.dataSource ? i ? e2.emptyView || jsx(z$3, { direction: "column", height: "100%", itemAlign: "center", justify: "center", mt: 3, children: jsx(er$1, {}) }) : e2.dataSource.map((s2, l2) => jsx(ze__default__default.Fragment, { children: e2.renderItem(s2, l2, e2.extraData) }, l2)) : null, [i, e2.dataSource, e2.extraData, e2.emptyView]), a2 = useMemo(() => {
    var _a3;
    return (((_a3 = e2.dataSource) == null ? void 0 : _a3.length) || 0) === 0 || !e2.isLoading ? null : jsx("div", { className: "oui-flex oui-py-2 oui-justify-center oui-items-center", children: jsx(Ie$4, {}) });
  }, [e2.isLoading, e2.dataSource]);
  return useImperativeHandle(o2, () => ({ scroll: (s2) => {
    var _a3;
    (_a3 = r3.current) == null ? void 0 : _a3.scroll({ left: s2.x, top: s2.y, behavior: "smooth" });
  } })), jsxs("div", { style: e2.style, ref: r3, className: cnBase("oui-relative oui-min-h-[180px] oui-custom-scrollbar oui-overflow-auto", e2.className), children: [jsx("div", { className: cnBase("oui-space-y-3 oui-h-full oui-w-full", i && "oui-absolute oui-left-0 oui-right-0 oui-top-0 oui-bottom-0", e2.contentClassName), children: n4 }), jsx("div", { ref: t, className: "oui-relative oui-invisible oui-h-[1px] oui-top-[-300px]" }), a2] });
}, og$1 = forwardRef(eg$1);
createContext({});
var la$1 = D$3.Root, ua$2 = D$3.Trigger, dg = D$3.Group, ca$1 = D$3.Portal, lt$5 = tv({ slots: { content: ["oui-z-50", "oui-min-w-[8rem]", "oui-overflow-hidden", "oui-rounded-xl", "oui-p-1", "oui-bg-base-8", "oui-text-base-contrast", "oui-shadow-md", "oui-border", "oui-border-line-6", "data-[state=open]:oui-animate-in", "data-[state=closed]:oui-animate-out", "data-[state=closed]:oui-fade-out-0", "data-[state=open]:oui-fade-in-0", "data-[state=closed]:oui-zoom-out-95", "data-[state=open]:oui-zoom-in-95", "data-[side=bottom]:oui-slide-in-from-top-2", "data-[side=left]:oui-slide-in-from-right-2", "data-[side=right]:oui-slide-in-from-left-2", "data-[side=top]:oui-slide-in-from-bottom-2"], item: ["oui-relative", "oui-flex", "oui-cursor-default", "oui-select-none", "oui-items-center", "oui-px-2", "oui-py-1.5", "oui-text-sm", "oui-outline-none", "oui-transition-colors", "hover:oui-bg-base-5", "focus:oui-bg-accent", "focus:oui-text-accent-foreground", "data-[disabled]:oui-pointer-events-none", "data-[disabled]:oui-opacity-50"], label: "oui-px-2 oui-py-1.5 oui-text-sm oui-font-semibold", separator: "-oui-mx-1 oui-my-1 oui-h-px oui-bg-muted", shortcut: "oui-ml-auto oui-text-xs oui-tracking-widest oui-opacity-60" }, variants: { size: { xs: { content: "oui-rounded", item: ["oui-px-2", "oui-py-1.5", "oui-h-6", "oui-rounded", "oui-text-2xs"] }, sm: { content: "oui-rounded", item: ["oui-px-2", "oui-py-1.5", "oui-h-6", "oui-rounded", "oui-text-2xs"] }, md: { content: "oui-rounded-md", item: ["oui-px-4", "oui-py-3", "oui-h-6", "oui-rounded"] }, lg: { content: "oui-rounded-lg", item: ["oui-px-4", "oui-py-3", "oui-h-6", "oui-rounded-md"] }, xl: { content: "oui-rounded-xl", item: ["oui-px-4", "oui-py-3", "oui-h-10", "oui-rounded-lg", "oui-text-base"] } }, inset: { true: { item: ["oui-pl-8"], label: ["oui-pl-8"] } } }, defaultVariants: { inset: false, size: "lg" } }), xr$3 = ze__default.forwardRef(({ className: e2, sideOffset: o2 = 4, size: t, ...r3 }, i) => {
  let { content: n4 } = lt$5({ size: t });
  return jsx(D$3.Portal, { children: jsx(D$3.Content, { ref: i, sideOffset: o2, className: n4({ className: e2 }), ...r3 }) });
});
xr$3.displayName = D$3.Content.displayName;
var br$5 = ze__default.forwardRef(({ className: e2, inset: o2, size: t, ...r3 }, i) => {
  let { item: n4 } = lt$5({ size: t });
  return jsx(D$3.Item, { ref: i, className: n4({ className: e2, inset: o2 }), ...r3 });
});
br$5.displayName = D$3.Item.displayName;
var fu = ze__default.forwardRef(({ className: e2, inset: o2, ...t }, r3) => {
  let { label: i } = lt$5({ inset: o2 });
  return jsx(D$3.Label, { ref: r3, className: i({ className: e2 }), ...t });
});
fu.displayName = D$3.Label.displayName;
var xu$1 = ze__default.forwardRef(({ className: e2, ...o2 }, t) => {
  let { separator: r3 } = lt$5();
  return jsx(D$3.Separator, { ref: t, className: r3({ className: e2 }), ...o2 });
});
xu$1.displayName = D$3.Separator.displayName;
var xg = (e2) => {
  let { currentValue: o2, menu: t, render: r3, size: i, children: n4, ...a2 } = e2, s2 = useMemo(() => typeof e2.render == "function" ? e2.menu.map((l2, u2) => {
    var _a3;
    return (_a3 = e2.render) == null ? void 0 : _a3.call(e2, l2, u2);
  }) : e2.menu.map((l2) => jsx(br$5, { textValue: l2.value, onSelect: (u2) => {
    var _a3;
    (_a3 = e2.onSelect) == null ? void 0 : _a3.call(e2, l2);
  }, size: i, "data-testid": l2.testId, children: jsxs(z$3, { justify: "between", width: "100%", children: [l2.label, o2 == l2.value && jsx(W$2, { width: 4, height: 4, gradient: "primary", r: "full" })] }) }, l2.value)), [e2.menu, e2.render, o2]);
  return jsxs(la$1, { children: [jsx(ua$2, { asChild: true, children: n4 }), jsx(ca$1, { children: jsx(xr$3, { onCloseAutoFocus: (l2) => {
    l2.preventDefault();
  }, size: i, ...a2, children: s2 }) })] });
};
var wg$1 = memo((e2) => {
  let { value: o2, children: t, left: r3 } = e2;
  return useMemo(() => !!(typeof o2 == "function" ? o2() : o2), [o2]) ? t : r3;
});
var vg$1 = (e2) => {
  let { value: o2, case: t, default: r3, ...i } = e2, n4 = typeof o2 == "function" ? o2() : o2;
  if (typeof t == "function") {
    let s2 = t(n4);
    return s2 ? jsx(Slot, { children: s2, ...i }) : typeof r3 > "u" ? void 0 : jsx(Slot, { children: r3, ...i });
  }
  let a2 = Object.keys(t);
  for (; a2.length; ) {
    let s2 = a2.pop();
    if (s2 === n4.toString()) return jsx(Slot, { children: t[s2], ...i });
  }
  return jsx(Slot, { children: r3, ...i });
};
var yg = (e2, o2) => typeof e2 > "u" || e2 === null ? o2 ?? void 0 : e2.charAt(0).toUpperCase() + e2.slice(1);
var wu$1 = {};
vr$4(wu$1, { default: () => Pg });
var Pg = {};
const { merge } = ((_m2 = (_l2 = __cjsInterop1__$2) == null ? void 0 : _l2.default) == null ? void 0 : _m2.__esModule) ? __cjsInterop1__$2.default : __cjsInterop1__$2;
var binance = binanceModule({ options: { lng: "en" } });
var initConfig = (apiKey, options) => {
  const defaultOptions2 = {
    apiKey,
    connect: {
      // autoConnectAllPreviousWallet: true,
      autoConnectLastWallet: true
    },
    wallets: [injectedModule(), binance],
    chains: [],
    appMetadata: {
      name: "Orderly",
      // icon: blocknativeIcon,
      description: "Orderly",
      recommendedInjectedWallets: [
        { name: "Coinbase", url: "https://wallet.coinbase.com/" },
        { name: "MetaMask", url: "https://metamask.io" },
        { name: "Trezor", url: "https://trezor.io/" },
        { name: "Walletconnect", url: "https://walletconnect.com/" },
        { name: "Ledger", url: "https://www.ledger.com/" }
      ],
      agreement: {
        version: "1.0.0",
        termsUrl: "https://www.blocknative.com/terms-conditions",
        privacyUrl: "https://www.blocknative.com/privacy-policy"
      },
      gettingStartedGuide: "https://blocknative.com",
      explore: "https://blocknative.com"
    },
    accountCenter: {
      desktop: {
        enabled: false
      },
      mobile: {
        enabled: false
      }
    },
    theme: "dark"
  };
  const mergedOptions = merge(defaultOptions2, options);
  return init(mergedOptions);
};
var SolanaChains = /* @__PURE__ */ new Map([[WalletAdapterNetwork.Devnet, 901901901], [WalletAdapterNetwork.Mainnet, 900900900]]);
var SolanaContext = createContext({
  network: WalletAdapterNetwork.Devnet,
  endpoint: ""
});
var useSolanaContext = () => {
  const context = useContext(SolanaContext);
  if (context === void 0) {
    throw new Error("useSolanaContext must be used within a SolanaProvider");
  }
  return context;
};
function SolanaProvider({ children, ...props }) {
  const { isMobile } = it$6();
  const network = useMemo(() => props.network ?? WalletAdapterNetwork.Devnet, [props.network]);
  const endpoint = useMemo(() => {
    if (network === WalletAdapterNetwork.Mainnet) {
      return props.mainnetRpc ?? "";
    }
    if (network === WalletAdapterNetwork.Devnet) {
      return props.devnetRpc ?? "";
    }
    return "";
  }, [network, props.mainnetRpc, props.devnetRpc]);
  const mobileWalletNotFoundHanlder = (adapter) => {
    console.log("-- mobile wallet adapter", adapter);
    return Promise.reject(new WalletNotReadyError("wallet not ready"));
  };
  const handleSolanaError = (error, adapter) => {
    console.log("-- solanan error", error);
    console.log("-- solana adapter", adapter);
    if (!isMobile && error instanceof WalletNotReadyError) {
      window.open(adapter == null ? void 0 : adapter.url, "_blank");
    }
  };
  const wallets = useMemo(() => {
    let uri = "";
    if (typeof window !== "undefined") {
      const location = l$1().location;
      uri = `${location.protocol}//${location.host}`;
    }
    return props.wallets ?? [
      new PhantomWalletAdapter(),
      new SolanaMobileWalletAdapter({
        addressSelector: createDefaultAddressSelector(),
        appIdentity: {
          uri
        },
        authorizationResultCache: createDefaultAuthorizationResultCache(),
        chain: network,
        onWalletNotFound: mobileWalletNotFoundHanlder
      })
    ];
  }, [props.wallets, network]);
  const contextValue = useMemo(() => ({
    network,
    endpoint
  }), [network, endpoint]);
  return /* @__PURE__ */ ze__default__default.createElement(SolanaContext.Provider, { value: contextValue }, /* @__PURE__ */ ze__default__default.createElement(WalletProvider, { wallets, onError: props.onError ?? handleSolanaError }, /* @__PURE__ */ ze__default__default.createElement(WalletModalProvider, { className: "oui-pointer-events-auto" }, children)));
}
function useSOL() {
  const [wallet, setWallet] = useState(null);
  const { isMobile } = it$6();
  const { endpoint, network } = useSolanaContext();
  const { setVisible: setModalVisible, visible } = useWalletModal();
  const { setLedgerAddress } = useStorageLedgerAddress();
  const {
    signMessage,
    signTransaction,
    sendTransaction,
    publicKey,
    wallet: solanaWallet,
    connect: solanaConnect,
    disconnect: solanaDisconnect,
    connecting
  } = useWallet();
  const selectModalVisibleRef = useRef(false);
  const [connected, setConnected] = useState(false);
  const isManual = useRef(false);
  const solanaPromiseRef = useRef({
    walletSelect: null,
    connect: null,
    walletSelectResolve: () => {
    },
    walletSelectReject: () => {
    },
    connectReject: () => {
    },
    connectResolve: () => {
    }
  });
  const ee2 = useEventEmitter();
  const initPromiseRef = () => {
    console.log("-- init solana promise");
    solanaPromiseRef.current.walletSelectResolve = () => {
    };
    solanaPromiseRef.current.walletSelectReject = () => {
    };
    solanaPromiseRef.current.connectReject = () => {
    };
    solanaPromiseRef.current.connectReject = () => {
    };
    solanaPromiseRef.current.connect = null;
    solanaPromiseRef.current.walletSelect = null;
    solanaPromiseRef.current.walletSelect = new Promise((resolve, reject) => {
      solanaPromiseRef.current.walletSelectResolve = resolve;
      solanaPromiseRef.current.walletSelectReject = reject;
    });
    solanaPromiseRef.current.connect = new Promise((resolve, reject) => {
      solanaPromiseRef.current.connectResolve = resolve;
      solanaPromiseRef.current.connectReject = reject;
    });
  };
  const handleSolanaError = (e2) => {
    console.log("solan connect error", e2);
    if (e2 instanceof WalletNotReadyError) {
      if (isMobile) {
        console.log("-- need toast wallet not ready", e2);
        ee2.emit("wallet:connect-error", {
          message: "Please open the wallet app and use the in-app browser."
        });
      }
    }
    solanaDisconnect().then();
  };
  const connect = async () => {
    initPromiseRef();
    isManual.current = true;
    if (!solanaPromiseRef.current) {
      return;
    }
    if (!solanaWallet) {
      setModalVisible(true);
      selectModalVisibleRef.current = true;
    } else {
      solanaPromiseRef.current.walletSelectResolve(solanaWallet);
      if (!publicKey) {
        try {
          await solanaConnect();
        } catch (e2) {
          solanaPromiseRef.current.connectReject(e2);
        }
      } else {
        solanaPromiseRef.current.connectResolve({
          userAddress: publicKey.toBase58(),
          signMessage,
          signTransaction,
          sendTransaction
        });
      }
    }
    console.log("-- connect fn", solanaWallet, publicKey);
    return Promise.all([
      solanaPromiseRef.current.walletSelect,
      solanaPromiseRef.current.connect
    ]).then(([wallet2, { userAddress, signMessage: signMessage2, signTransaction: signTransaction2, sendTransaction: sendTransaction2 }]) => {
      const tempWallet = {
        label: wallet2.adapter.name,
        icon: "",
        provider: {
          rpcUrl: endpoint,
          network,
          signMessage: signMessage2,
          signTransaction: signTransaction2,
          sendTransaction: sendTransaction2
        },
        accounts: [
          {
            address: userAddress
          }
        ],
        chains: [
          {
            id: SolanaChains.get(network),
            namespace: ChainNamespace.solana
          }
        ]
      };
      if (wallet2.adapter.name === "Ledger") {
        setLedgerAddress(userAddress);
      }
      setWallet(tempWallet);
      setConnected(true);
      return [tempWallet];
    }).catch((e2) => {
      console.log("connect solana error", e2);
      handleSolanaError(e2);
      return Promise.reject(e2);
    }).finally(() => {
      isManual.current = false;
    });
  };
  const disconnect = async () => {
    console.log("--- discconnect sol");
    await solanaDisconnect();
    setWallet(null);
    setConnected(false);
    return [];
  };
  const connectedChain = useMemo(() => {
    if (!publicKey) {
      return null;
    }
    return {
      id: network === WalletAdapterNetwork.Mainnet ? 900900900 : 901901901,
      namespace: ChainNamespace.solana
    };
  }, [publicKey]);
  useEffect(() => {
    if (selectModalVisibleRef.current) {
      if (!visible && !solanaWallet && solanaPromiseRef.current) {
        console.log(
          "-- select modal visible ref",
          selectModalVisibleRef.current
        );
        console.log("-- use reject solana select modal");
        solanaPromiseRef.current.walletSelectReject("user reject");
        selectModalVisibleRef.current = false;
      } else if (solanaWallet) {
        selectModalVisibleRef.current = false;
      }
    }
  }, [
    visible,
    solanaWallet,
    solanaPromiseRef.current,
    selectModalVisibleRef.current
  ]);
  useEffect(() => {
    if (!solanaWallet || !publicKey) {
      console.log("--- not connect sol", solanaWallet, publicKey);
      setConnected(false);
      return;
    }
    console.log("-- publick", {
      publicKey: publicKey.toBase58(),
      isManual: isManual.current
    });
    if (isManual.current) {
      if (solanaPromiseRef.current) {
        solanaPromiseRef.current.connectResolve({
          userAddress: publicKey == null ? void 0 : publicKey.toBase58(),
          signMessage,
          signTransaction,
          sendTransaction
        });
      }
      return;
    }
    const userAddress = publicKey.toBase58();
    setWallet({
      label: solanaWallet.adapter.name,
      icon: "",
      provider: {
        signMessage,
        signTransaction,
        sendTransaction,
        rpcUrl: endpoint,
        network
      },
      accounts: [
        {
          address: userAddress
        }
      ],
      chains: [
        {
          id: SolanaChains.get(network),
          namespace: ChainNamespace.solana
        }
      ]
    });
    if (solanaWallet.adapter.name === "Ledger") {
      setLedgerAddress(userAddress);
    }
    setConnected(true);
  }, [
    publicKey,
    solanaWallet,
    signMessage,
    signTransaction,
    isManual,
    sendTransaction,
    endpoint,
    network
  ]);
  useEffect(() => {
    if (!solanaWallet) {
      return;
    }
    console.log("-- public key", publicKey, { isMobile });
    if (isMobile && solanaWallet.readyState === WalletReadyState.Loadable && !isManual.current) {
      solanaDisconnect().then();
      return;
    }
    console.log("-- solana refresh auto connect", solanaWallet);
    if (solanaPromiseRef.current) {
      solanaPromiseRef.current.walletSelectResolve(solanaWallet);
    }
    solanaConnect().then((res) => {
      console.log("-- connect res", res);
    }).catch((e2) => {
      solanaPromiseRef.current.connectReject(e2);
      handleSolanaError(e2);
    });
  }, [
    solanaWallet,
    solanaConnect,
    publicKey,
    solanaDisconnect,
    handleSolanaError,
    isMobile
  ]);
  return {
    connected,
    connect,
    disconnect,
    connecting,
    wallet,
    connectedChain
  };
}
function useEvm() {
  const [
    {
      wallet,
      // the wallet that has been connected or null if not yet connected
      connecting
      // boolean indicating if connection is in progress
    },
    connect,
    // function to call to initiate user to connect wallet
    evmDisconnect,
    // function to call with wallet<DisconnectOptions> to disconnect wallet
    updateBalances,
    // function to be called with an optional array of wallet addresses connected through Onboard to update balance or empty/no params to update all connected wallets
    setWalletModules,
    // function to be called with an array of wallet modules to conditionally allow connection of wallet types i.e. setWalletModules([ledger, trezor, injected])
    setPrimaryWallet
    // function that can set the primary wallet and/or primary account within that wallet. The wallet that is set needs to be passed in for the first parameter and if you would like to set the primary account, the address of that account also needs to be passed in
  ] = useConnectWallet();
  const [
    {
      chains,
      // the list of chains that web3-onboard was initialized with
      connectedChain: evmConnectChain,
      // the current chain the user's wallet is connected to
      settingChain
      // boolean indicating if the chain is in the process of being set
    },
    setChain
    // function to call to initiate user to switch chains in their wallet
  ] = useSetChain();
  const connected = useMemo(() => {
    return !!(wallet && wallet.accounts && wallet.accounts[0] && wallet.accounts[0].address);
  }, [wallet]);
  const disconnect = async () => {
    console.log("-- disconnect evm xxxxxxxxxxxx");
    if (!wallet) {
      return;
    }
    return evmDisconnect({
      label: wallet.label
    });
  };
  const connectedChain = useMemo(() => {
    return evmConnectChain ? { ...evmConnectChain, id: parseInt(evmConnectChain.id) } : null;
  }, [evmConnectChain]);
  const changeChain = (chain) => {
    return setChain(chain);
  };
  return {
    connect,
    connected,
    disconnect,
    connecting,
    wallet,
    connectedChain,
    changeChain
  };
}
function Main(props) {
  const sol = useSOL();
  const evm = useEvm();
  const [namespace, setNamespace] = useState(null);
  const newNamespace = useRef();
  const connect = async (options) => {
    if (Array.from(SolanaChains.values()).includes(options.chainId)) {
      newNamespace.current = ChainNamespace.solana;
      return sol.connect().then((res) => {
        console.log("-- connect sol", res);
        if (res) {
          return res;
        }
      });
    }
    newNamespace.current = ChainNamespace.evm;
    const evmOption = options.autoSelect ? {
      autoSelect: options.autoSelect
    } : void 0;
    return evm.connect(evmOption).then((res) => {
      console.log("-- connect evm", res);
      if (!res.length) {
        return Promise.reject({ message: "user reject" });
      }
      return res;
    }).catch((e2) => {
      console.log("-- connect evm error", e2);
      return Promise.reject(e2);
    });
  };
  const disconnect = async () => {
    if (namespace === ChainNamespace.evm) {
      return evm.disconnect();
    }
    if (namespace === ChainNamespace.solana) {
      return sol.disconnect();
    }
  };
  const connecting = newNamespace.current == ChainNamespace.solana ? sol.connecting : evm.connecting;
  const wallet = namespace === ChainNamespace.solana && sol.connected ? sol.wallet : namespace === ChainNamespace.evm && evm.connected ? evm.wallet : null;
  const connectedChain = namespace === ChainNamespace.solana ? sol.connectedChain : evm.connectedChain;
  const setChain = (chain) => {
    const chainId = typeof chain.chainId === "number" ? chain.chainId : f$3(chain.chainId);
    let tempNamespace = ChainNamespace.evm;
    if (Array.from(SolanaChains.values()).includes(chainId)) {
      tempNamespace = ChainNamespace.solana;
    }
    console.log("--- namespace", {
      namespace,
      tempNamespace
    });
    if (namespace === tempNamespace && namespace === ChainNamespace.evm) {
      return evm.changeChain(chain);
    }
    if (namespace !== tempNamespace) {
      return connect({ chainId }).then();
    }
  };
  useEffect(() => {
    if (sol.connected && evm.connected) {
      if (newNamespace.current === ChainNamespace.solana) {
        evm.disconnect().then();
        setNamespace(ChainNamespace.solana);
        return;
      } else {
        setNamespace(ChainNamespace.evm);
        sol.disconnect().then();
        return;
      }
    }
    if (sol.connected) {
      setNamespace(ChainNamespace.solana);
      return;
    }
    if (evm.connected) {
      setNamespace(ChainNamespace.evm);
      return;
    }
  }, [newNamespace.current, sol.connected, evm.connected]);
  return /* @__PURE__ */ ze__default__default.createElement(
    WalletConnectorContext.Provider,
    {
      value: {
        connect,
        disconnect,
        connecting,
        wallet,
        setChain,
        connectedChain,
        namespace
      }
    },
    props.children
  );
}
function InitEvm(props) {
  const [initialized, setInitialized] = useState(!!props.skipInit);
  const { get: get2, register } = useSimpleDI();
  useEffect(() => {
    document.body.style.setProperty("--onboard-modal-z-index", "88");
  }, []);
  useEffect(() => {
    if (props.skipInit) {
      return;
    }
    let onboardAPI = get2("onboardAPI");
    if (onboardAPI) {
      console.log("[Orderly SDK]:onboardAPI already initialized");
      setInitialized(true);
      return;
    }
    Promise.all([
      fetchChainInfo("https://testnet-api.orderly.org/v1/public/chain_info"),
      fetchChainInfo("https://api.orderly.org/v1/public/chain_info")
    ]).then(([testChainInfo, mainnetChainInfo]) => {
      const testChains = processChainInfo(testChainInfo);
      const mainnetChains = processChainInfo(mainnetChainInfo);
      let options = props.options || {};
      options = merge({ chains: [...testChains, ...mainnetChains] }, options);
      onboardAPI = initConfig(props.apiKey, options);
      register("onboardAPI", onboardAPI);
      setInitialized(true);
    }).catch((error) => {
      console.error("Error fetching data:", error);
    });
  }, []);
  if (!initialized)
    return null;
  return props.children;
}
var fetchChainInfo = async (url) => {
  const response = await fetch(url);
  if (!response.ok) {
    throw new Error(`Failed to fetch data from ${url}`);
  }
  return response.json();
};
var processChainInfo = (chainInfo) => {
  var _a3, _b2;
  return ((_b2 = (_a3 = chainInfo == null ? void 0 : chainInfo.data) == null ? void 0 : _a3.rows) == null ? void 0 : _b2.map((row) => ({
    id: Number(row.chain_id),
    token: row.currency_symbol,
    label: row.name,
    rpcUrl: row.public_rpc_url,
    blockExplorerUrl: row.explorer_base_url
  }))) || [];
};
function WalletConnectorProvider(props) {
  var _a3;
  return /* @__PURE__ */ ze__default__default.createElement(SolanaProvider, { ...props.solanaInitial ?? {} }, /* @__PURE__ */ ze__default__default.createElement(InitEvm, { ...props.evmInitial ?? {} }, /* @__PURE__ */ ze__default__default.createElement(Main, { solanaNetwork: ((_a3 = props.solanaInitial) == null ? void 0 : _a3.network) ?? WalletAdapterNetwork.Devnet }, props.children)));
}
var u$1 = ((i) => (i.en = "en", i.zh = "zh", i.ja = "ja", i.es = "es", i.ko = "ko", i.vi = "vi", i.de = "de", i.fr = "fr", i.ru = "ru", i.id = "id", i.tr = "tr", i.it = "it", i.pt = "pt", i.uk = "uk", i.pl = "pl", i.nl = "nl", i))(u$1 || {}), h$1 = "en", s = "translation", k$2 = "orderly_i18nLng", b$2 = "orderly_i18nLng";
var L$4 = { "affiliate.referral": "Referral", "affiliate.trader": "Trader", "affiliate.enter": "Enter", "affiliate.statistics": "Statistics", "affiliate.connectWallet.tooltip": "Please connect your wallet to use this function", "affiliate.page.title": "Earn more as a <0>{{shortBrokerName}}</0> affiliate", "affiliate.page.subTitle": "Grow your brand | Get 40% commission | Unlock exclusive perks", "affiliate.page.learnMore": "Learn how it works", "affiliate.asAffiliate.affilates": "Affiliates", "affiliate.asAffiliate.title": "As an affiliate", "affiliate.asAffiliate.description": "Onboard traders to earn passive income", "affiliate.asAffiliate.button": "Become an affiliate", "affiliate.asTrader.title": "As a trader", "affiliate.asTrader.description": "Onboard traders to earn passive income", "affiliate.asTrader.button": "Enter code", "affiliate.referralCode": "Referral code", "affiliate.referralCode.dialog.title": "Bind a referral code", "affiliate.referralCode.dialog.description": "Bind a referral code to earn trading fee rebates.", "affiliate.referralCode.label": "Enter referral code", "affiliate.referralCode.bound": "Referral code bound", "affiliate.referralCode.notExist": "This referral code does not exist.", "affiliate.process.title": "Becoming an affiliate is easy", "affiliate.process.step1.title": "Apply", "affiliate.process.step1.description": "Fill out the application form", "affiliate.process.step2.title": "Share", "affiliate.process.step2.description": "Unlock your affiliate link and share it with your community", "affiliate.process.step3.title": "Earn", "affiliate.process.step3.description": "Get paid and receive special treatment 24/7, 365", "affiliate.summary": "Summary", "affiliate.summary.refereesTraded": "Referees that traded", "affiliate.referralLink": "Referral link", "affiliate.referralLink.earn": "Earn", "affiliate.referralLink.earn.tooltip": "{{brokerName}} net fee that deduct Orderly fee.", "affiliate.referralLink.share": "Share", "affiliate.referralLink.share.tooltip": "Your referees get <0>{{value}}</0> of their {{brokerName}} net fee", "affiliate.referralVol": "Referral vol.", "affiliate.referralCodes": "Referral codes", "affiliate.referralCodes.remaining": "Remaining referral codes", "affiliate.referralCodes.column.you&Referee": "You / Referee", "affiliate.referralCodes.column.traders": "Traders", "affiliate.referralCodes.column.referees&Traders": "Referees / Traders", "affiliate.referralCodes.copyLink": "Copy link", "affiliate.commission": "Commission", "affiliate.commission.30d": "30d commission", "affiliate.commission.column.activeUsers": "Referral active users", "affiliate.myReferees": "My referees", "affiliate.referees": "Referees", "affiliate.referees.column.refereeAddress": "Referee address", "affiliate.referees.column.totalCommission": "Total commission", "affiliate.referees.column.totalVol": "Total vol.", "affiliate.referees.column.invitationTime": "Invitation time", "affiliate.trader.yourReferrer": "Your referrer", "affiliate.trader.rebate": "Rebate", "affiliate.trader.rebates": "Rebates", "affiliate.trader.rebate.30d": "30d trading rebates", "affiliate.trader.tradingRebates": "Trading rebates", "affiliate.trader.myRebates": "My rebates", "affiliate.trader.tradingVol": "Trading vol." };
var C$1 = { "chart.now": "Now" };
var T = { "connector.testnet": "Testnet", "connector.mainnet": "Mainnet", "connector.disconnect": "Disconnect", "connector.connectWallet": "Connect wallet", "connector.signIn": "Sign in", "connector.signIn.description": "Confirm you are the owner of this wallet", "connector.enableTrading": "Enable trading", "connector.enableTrading.description": "Enable secure access to our API for lightning fast trading", "connector.switchNetwork": "Switch Network", "connector.wrongNetwork": "Wrong network", "connector.wrongNetwork.tooltip": "Please switch to a supported network to continue.", "connector.expired": "Your previous access has expired, you will receive a signature request to enable trading. Signing is free and will not send a transaction.", "connector.rememberMe": "Remember me", "connector.rememberMe.description": "Toggle this option to skip these steps next time you want to trade.", "connector.referralCode.placeholder": "Referral code (Optional)", "connector.referralCode.invalid": "The referral_code must be 4 to 10 characters long, only accept upper case roman characters and numbers", "connector.referralCode.notExist": "This referral code does not exist.", "connector.somethingWentWrong": "Something went wrong", "connector.userRejected": "User rejected the request.", "connector.walletConnected": "Wallet connected", "connector.networkSwitched": "Network switched", "connector.switchChain.failed": "Switch chain failed", "connector.trade.connectWallet.tooltip": "Please connect wallet before starting to trade", "connector.trade.signIn.tooltip": "Please sign in before starting to trade", "connector.trade.enableTrading.tooltip": "Please enable trading before starting to trade", "connector.setUp.connectWallet.tooltip": "Please connect wallet before set up", "connector.setUp.signIn.tooltip": "Please sign in before set up", "connector.setUp.enableTrading.tooltip": "Please enable trading before set up", "connector.ledger.signMessageFailed": "Sign Message Failed", "connector.ledger.signMessageFailed.description": "Are you using Ledger Wallet?", "connector.privy.loginIn": "Login in", "connector.privy.logout": "Log out", "connector.privy.email": "Email", "connector.privy.google": "Google", "connector.privy.twitter": "X / Twitter", "connector.privy.myWallet": "My wallet", "connector.privy.addEvmWallet": "Add Evm wallet", "connector.privy.addSolanaWallet": "Add Solana wallet", "connector.privy.addAbstractWallet": "Add Abstract wallet", "connector.privy.createEvmWallet": "Create Evm wallet", "connector.privy.createSolanaWallet": "Create Solana wallet", "connector.privy.termsOfUse": "By connecting your wallet, you acknowledge and agree to the <0>terms of use</0>.", "connector.privy.supportedEvmChain": "Supported Evm chain", "connector.privy.supportedSolanaChain": "Supported Solana chain", "connector.privy.noWallet": "No wallet", "connector.privy.noWallet.description": "Please create a wallet to proceed. Only you can access the private key. You can export the private key and import your wallet into another wallet client, such as MetaMask or Phantom, at any time.", "connector.privy.switchNetwork.tips": "Switch to {{chainName}} to continue.", "connector.privy.addEvmWallet.tips": "Connect an EVM-compatible wallet to continue using the EVM network.", "connector.privy.addSolanaWallet.tips": "Connect an Solana-compatible wallet to continue using the Solana network.", "connector.privy.addAbstractWallet.tips": "Connect an Abstract-compatible wallet to continue using the Abstract network." };
var x$2 = { "leverage.maxAccountLeverage": "Max account leverage", "leverage.accountLeverage": "Account leverage", "leverage.currentLeverage": "Current leverage", "leverage.maxLeverage": "Max leverage", "leverage.updated": "Leverage updated" };
var R$2 = { "markets.favorites": "Favorites", "markets.recent": "Recent", "markets.newListings": "New listings", "markets.allMarkets": "All markets", "markets.openInterest": "Open interest", "markets.openInterest.tooltip": "Total size of positions per side.", "markets.topGainers": "Top gainers", "markets.topLosers": "Top losers", "markets.search.placeholder": "Search market", "markets.dataList.favorites.empty": "Click on the <0/> icon next to a market to add it to your list.", "markets.dataList.column.8hFunding": "8h funding", "markets.dataList.column.moveTop": "Move to top", "markets.favorites.dropdown.title": "Select lists for", "markets.favorites.dropdown.addPlaceholder": "Add a new watchlist", "markets.favorites.tabs.maxList": "Maximum 10 groups in the favorite list", "markets.favorites.tabs.maxName": "List name cannot exceed 15 characters", "markets.favorites.tabs.delete.dialog.title": "Delete list", "markets.favorites.tabs.delete.dialog.description": "Are you sure you want to delete {{name}}?", "markets.column.market": "Market", "markets.column.24hChange": "24h change", "markets.column.24hVolume": "24h volume", "markets.column.market&Volume": "Market / Volume", "markets.column.price&Change": "Price / change", "markets.column.last": "Last", "markets.column.24hPercentage": "24h%", "markets.funding.comparison": "Comparison", "markets.funding.column.estFunding": "Est. funding", "markets.funding.column.lastFunding": "Last funding", "markets.funding.column.1dAvg": "1D avg.", "markets.funding.column.3dAvg": "3D avg.", "markets.funding.column.7dAvg": "7D avg.", "markets.funding.column.14dAvg": "14D avg.", "markets.funding.column.30dAvg": "30D avg.", "markets.funding.column.90dAvg": "90D avg.", "markets.funding.column.positiveRate": "Positive rate", "markets.symbolInfoBar.Mark": "Mark", "markets.symbolInfoBar.Mark.tooltip": "Price for the computation of unrealized PnL and liquidation.", "markets.symbolInfoBar.Index": "Index", "markets.symbolInfoBar.Index.tooltip": "Average of the last prices across other exchanges.", "markets.symbolInfoBar.24hVolume": "24h volume", "markets.symbolInfoBar.24hVolume.tooltip": "24 hour total trading volume on the Orderly Network.", "markets.symbolInfoBar.predFundingRate": "Pred. funding rate", "markets.symbolInfoBar.predFundingRate.tooltip": "Funding rates are payments between traders who are long and short. When positive, long positions pay short positions funding. When negative, short positions pay long positions." };
var S$1 = { "orderEntry.buyLong": "Buy / Long", "orderEntry.sellShort": "Sell / Short", "orderEntry.reduceOnly": "Reduce only", "orderEntry.orderType.limit": "Limit", "orderEntry.orderType.market": "Market", "orderEntry.orderType.limitOrder": "Limit order", "orderEntry.orderType.marketOrder": "Market order", "orderEntry.orderType.stopLimit": "Stop limit", "orderEntry.orderType.stopMarket": "Stop market", "orderEntry.orderType.postOnly": "Post only", "orderEntry.orderType.ioc": "IOC", "orderEntry.orderType.fok": "FOK", "orderEntry.bbo": "BBO", "orderEntry.bbo.counterparty1": "Counterparty 1", "orderEntry.bbo.counterparty5": "Counterparty 5", "orderEntry.bbo.queue1": "Queue 1", "orderEntry.bbo.queue5": "Queue 5", "orderEntry.bbo.disabled.tips": "BBO is not supported when TP/SL, Post-Only, IOC, or FOK is selected.", "orderEntry.estLiqPrice": "Est. liq. price", "orderEntry.disableOrderConfirm": "Disable order confirmation", "orderEntry.orderConfirm": "Order confirm", "orderEntry.hidden": "Hidden", "orderEntry.keepVisible": "Keep visible", "orderEntry.maxBuy": "Max buy", "orderEntry.maxSell": "Max sell", "orderEntry.tpMarkPrice": "TP price (Mark)", "orderEntry.slMarkPrice": "SL price (Mark)", "orderEntry.tpsl.trigger.description": "TP/SL triggers at the specified mark price and executes as a market order.", "orderEntry.estRoi": "Est.ROI", "orderEntry.estPnL": "Est.PnL", "orderEntry.tpsl.tips": "TP/SL triggers at the specified mark price and executes as a market order. By default, it applies to the entire position. Adjust settings in open positions for partial TP/SL.", "orderEntry.orderQuantity.error.required": "Quantity is required", "orderEntry.orderQuantity.error.min": "Quantity must be greater than {{value}}", "orderEntry.orderQuantity.error.max": "Quantity must be less than {{value}}", "orderEntry.orderPrice.error.required": "Price is required", "orderEntry.orderPrice.error.min": "Price must be greater than {{value}}", "orderEntry.orderPrice.error.max": "Price must be less than {{value}}", "orderEntry.triggerPrice.error.required": "Trigger price is required", "orderEntry.triggerPrice.error.min": "Trigger price must be greater than {{value}}", "orderEntry.triggerPrice.error.max": "Trigger price must be less than {{value}}", "orderEntry.tpTriggerPrice.error.min": "TP Price must be greater than {{value}}", "orderEntry.tpTriggerPrice.error.max": "TP Price must be less than {{value}}", "orderEntry.slTriggerPrice.error.min": "SL Price must be greater than {{value}}", "orderEntry.slTriggerPrice.error.max": "SL Price must be less than {{value}}", "orderEntry.total.error.min": "The order value should be greater or equal to {{value}} USDC" };
var I$3 = { "orders.orderHistory": "Order history", "orders.status.pending": "Pending", "orders.status.filled": "Filled", "orders.status.partialFilled": "Partial filled", "orders.status.canceled": "Canceled", "orders.status.rejected": "Rejected", "orders.status.incomplete": "Incomplete", "orders.status.completed": "Completed", "orders.status.opened.toast.title": "Order opened", "orders.status.filled.toast.title": "Order filled", "orders.status.canceled.toast.title": "Order canceled", "orders.status.rejected.toast.title": "Order rejected", "orders.status.replaced.toast.title": "Order edited", "orders.column.orderPrice": "Order price", "orders.column.fill&Quantity": "Filled / Quantity", "orders.column.triggerPrice": "Trigger price", "orders.column.orderTime": "Order time", "orders.column.hidden": "Hidden", "orders.editOrder": "Edit order", "order.edit.confirm.quantity": "You agree changing the quantity of {{base}}-PERP order to <0>{{value}}</0>.", "order.edit.confirm.price": "You agree changing the price of {{base}}-PERP order to <0>{{value}}</0>.", "order.edit.confirm.triggerPrice": "You agree changing the trigger price of {{base}}-PERP order to <0>{{value}}</0>.", "orders.cancelOrder": "Cancel order", "orders.cancelOrder.description": "Are you sure you want to cancel your pending order.", "orders.cancelAll": "Cancel all", "orders.pending.cancelAll": "Cancel all pending orders", "orders.pending.cancelAll.description": "Are you sure you want to cancel all of your pending orders?", "orders.tpsl.cancelAll": "Cancel all TP/SL orders", "orders.tpsl.cancelAll.description": "Are you sure you want to cancel all of your TP/SL orders?", "orders.price.greaterThan": "Price can not be greater than {{max}} USDC.", "orders.price.lessThan": "Price can not be less than {{min}} USDC.", "orders.quantity.lessThan": "Quantity should be less than {{quantity}}", "orders.quantity.lessThanPosition": "Quantity should be less than position quantity : {{quantity}}", "orders.history.renew": "Renew", "orders.download.tooltip": "The downloaded data will reflect only the applied filters (e.g., status, time, side, and pagination) and may not include all records." };
var A$3 = { "portfolio.feeTier": "Fee tier", "portfolio.apiKeys": "API Keys", "portfolio.setting": "Settings", "portfolio.overview.availableWithdraw": "Available to withdraw", "portfolio.overview.performance": "Performance", "portfolio.overview.performance.roi": "{{period}} ROI", "portfolio.overview.performance.pnl": "{{period}} PnL", "portfolio.overview.performance.volume": "{{period}} Volume (USDC)", "portfolio.overview.performance.dailyPnl": "Daily PnL", "portfolio.overview.performance.cumulativePnl": "Cumulative PnL", "portfolio.overview.deposits&Withdrawals": "Deposits & Withdrawals", "portfolio.overview.distribution": "Distribution", "portfolio.overview.column.txId": "TxID", "portfolio.overview.column.funding&AnnualRate": "Funding rate / Annual rate", "portfolio.overview.column.paymentType": "Payment type", "portfolio.overview.column.paymentType.paid": "Paid", "portfolio.overview.column.paymentType.received": "Received", "portfolio.overview.column.fundingFee": "Funding fee", "portfolio.overview.distribution.type.referralCommission": "Referral commission", "portfolio.overview.distribution.type.refereeRebate": "Referee rebate", "portfolio.overview.distribution.type.brokerFee": "Broker fee", "portfolio.feeTier.updatedDailyBy": "Updated daily by", "portfolio.feeTier.header.yourTier": "Your tier", "portfolio.feeTier.header.30dVolume": "30D trading volume", "portfolio.feeTier.header.takerFeeRate": "Taker fee rate", "portfolio.feeTier.header.makerFeeRate": "Maker fee rate", "portfolio.feeTier.column.tier": "Tier", "portfolio.feeTier.column.30dVolume": "30 day volume", "portfolio.feeTier.column.30dVolume.above": "Above {{volume}}", "portfolio.feeTier.column.maker": "Maker", "portfolio.feeTier.column.taker": "Taker", "portfolio.apiKey.accountId": "Account ID", "portfolio.apiKey.accountId.copied": "Account id copied", "portfolio.apiKey.uid": "UID", "portfolio.apiKey.secretKey": "Secret key", "portfolio.apiKey.secretKey.copied": "Secret key copied", "portfolio.apiKey.ip": "IP", "portfolio.apiKey.permissions": "Permissions", "portfolio.apiKey.permissions.read": "Read", "portfolio.apiKey.permissions.trading": "Trading", "portfolio.apiKey.description": "Create API keys to suit your trading needs. For your security, don't share your API keys with anyone.", "portfolio.apiKey.readApiGuide": "Read API guide", "portfolio.apiKey.column.apiKey": "API key", "portfolio.apiKey.column.apiKey.copy": "API key copied", "portfolio.apiKey.column.permissionType": "Permission type", "portfolio.apiKey.column.restrictedIP": "Restricted IP", "portfolio.apiKey.column.restrictedIP.copy": "Restricted IP copied", "portfolio.apiKey.column.expirationDate": "Expiration date", "portfolio.apiKey.create.dialog.title": "Create API key", "portfolio.apiKey.create.connectWallet.tooltip": "Please connect wallet before create API key", "portfolio.apiKey.create.signIn.tooltip": "Please sign in before create API key", "portfolio.apiKey.create.enableTrading.tooltip": "Please enable trading before create API key", "portfolio.apiKey.create.wrongNetwork.tooltip": "Please switch to a supported network to create API key", "portfolio.apiKey.create.ipRestriction": "IP restriction (optional)", "portfolio.apiKey.create.ipRestriction.placeholder": "Add IP addresses, separated by commas.", "portfolio.apiKey.created.warning": "Please copy the API secret. Once you close this pop-up, the API secret will be encrypted.", "portfolio.apiKey.created.button.copyApiInfo": "Copy API info", "portfolio.apiKey.apiInfo.copied": "API info copied", "portfolio.apiKey.created": "API key created", "portfolio.apiKey.deleted": "API key deleted", "portfolio.apiKey.updated": "API key updated", "portfolio.apiKey.edit.dialog.title": "Edit API key", "portfolio.apiKey.delete.dialog.title": "Delete API key", "portfolio.apiKey.delete.dialog.description": "Delete your API key <0>{{apiKey}}</0>?", "portfolio.setting.systemUpgrade": "System upgrade", "portfolio.setting.cancelOpenOrders": "Cancel open orders during system upgrade", "portfolio.setting.cancelOpenOrders.description": "During the upgrade period, all open orders will be cancelled to manage your risk in case of high market volatility." };
var E$2 = { "positions.positionHistory": "Position history", "positions.liquidation": "Liquidation", "positions.closePosition": "Close Position", "positions.column.liqPrice": "Liq. price", "positions.column.liqPrice.tooltip": "Estimated price at which your position will be liquidated. Prices are estimated and depend on multiple factors across all positions.", "positions.column.unrealPnl.tooltip": "Current unrealized profit or loss on your open positions across all widgets calculated using Mark Price.", "positions.column.unrealPnl.priceBasis": "Unrealized PnL Price Basis", "positions.column.margin": "Margin", "positions.column.margin.tooltip": "The minimum equity to keep your position.", "positions.column.margin.formula": "Margin = Position size * Mark price * MMR", "positions.column.close": "Close", "positions.limitClose": "Limit close", "positions.limitClose.description": "You agree closing {{quantity}} {{base}} position at limit price.", "positions.marketClose": "Market close", "positions.marketClose.description": "You agree closing {{quantity}} {{base}} position at market price.", "positions.history.status.closed": "Closed", "positions.history.status.partialClosed": "Partially closed", "positions.history.type.adl": "Adl", "positions.history.type.liquidated": "Liquidated", "positions.history.liquidated.liquidationId": "Liquidation id", "positions.history.liquidated.liquidatorFee": "Liquidator fee", "positions.history.liquidated.insFundFee": "Ins. Fund fee", "positions.history.column.closed": "Closed", "positions.history.column.maxClosed": "Max closed", "positions.history.column.closed&maxClosed": "Closed / Max closed", "positions.history.column.netPnl": "Net PnL", "positions.history.column.timeOpened": "Time opened", "positions.history.column.timeClosed": "Time closed", "positions.history.column.updatedTime": "Updated time", "positions.history.netPnl.fundingFee": "Funding fee", "positions.history.netPnl.tradingFee": "Trading fee", "positions.Liquidation.column.liquidationId": "Liquidation id", "positions.Liquidation.column.insFundTransfer": "Ins. fund transfer", "positions.Liquidation.column.liquidationFee": "Liquidation fee" };
var D$1 = { "scaffold.footer.operational": "Operational", "scaffold.footer.joinCommunity": "Join our community", "scaffold.footer.poweredBy": "Powered by" };
var M$3 = { "share.pnl.sharePnl": "Share PnL", "share.pnl.share.long": "LONG", "share.pnl.share.short": "SHORT", "share.pnl.displayFormat": "PnL display format", "share.pnl.displayFormat.roi&Pnl": "ROI & PnL", "share.pnl.displayFormat.roi": "ROI", "share.pnl.displayFormat.pnl": "PnL", "share.pnl.optionalInfo": "Optional information to share", "share.pnl.optionalInfo.openPrice": "Open price", "share.pnl.optionalInfo.closePrice": "Close price", "share.pnl.optionalInfo.openTime": "Opened at", "share.pnl.optionalInfo.closeTime": "Closed at", "share.pnl.optionalInfo.message": "Your message", "share.pnl.optionalInfo.message.placeholder": "Max 25 characters", "share.pnl.optionalInfo.message.maxLength": "Maximum support of 25 characters", "share.pnl.image.copied": "Image copied", "share.pnl.copy.failed.description": "Browser version outdated, please update in order to copy image to clipboard." };
var O$4 = { "tpsl.tp": "TP", "tpsl.sl": "SL", "tpsl.tpPrice": "TP Price", "tpsl.slPrice": "SL Price", "tpsl.tpPnl": "TP PnL", "tpsl.slPnl": "SL PnL", "tpsl.tpTrigger": "TP trigger", "tpsl.slTrigger": "SL trigger", "tpsl.pnl": "PnL", "tpsl.offset": "Offset", "tpsl.positionTpsl": "Position TP/SL", "tpsl.entirePosition": "Entire position", "tpsl.estPnl": "Est. PNL", "tpsl.takeProfit": "Take profit", "tpsl.stopLoss": "Stop loss", "tpsl.cancelOrder.description": "Are you sure you want to cancel this TP/SL order?", "tpsl.confirmOrder": "Confirm Order" };
var N$3 = { "trading.layout": "Layout", "trading.layout.right": "Advanced (right)", "trading.layout.left": "Advanced (left)", "trading.orders.closeAll": "Close All", "trading.hideOtherSymbols": "Hide other symbols", "trading.history": "History", "trading.portfolioSettings": "Portfolio Settings", "trading.portfolioSettings.decimalPrecision": "Decimal Precision for PnL & Notional", "trading.portfolioSettings.unrealPnlPriceBasis": "Unrealized PnL Price Basis", "trading.orderBook": "Order book", "trading.lastTrades": "Last trades", "trading.orderBook.column.value": "Value", "trading.tabs.chart": "Chart", "trading.tabs.trades": "Trades", "trading.tabs.data": "Data", "trading.column.24High": "24h high", "trading.column.24Low": "24h low", "trading.orderBook.sum": "Sum", "trading.orderBook.markPrice.tooltip": "Obtained from a third-party oracle, the mark price is calculated as the median of three prices: the last price, the fair price based on the funding rate basis, and the fair price based on the order books.", "trading.orderBook.spreadRatio.tooltip": "Spread Ratio of the ask1 and bid1.", "trading.faucet.getTestUSDC": "Get test USDC", "trading.faucet.getTestUSDC.success": "{{quantity}} USDC will be added to your balance. Please note this may take up to 3 minutes. Please check back later.", "trading.asset.startTrading": "Start trading", "trading.asset.startTrading.description": "You can deposit assets from various networks", "trading.asset.myAssets": "My Assets", "trading.asset.freeCollateral": "Free collateral", "trading.asset.freeCollateral.tooltip": "Free collateral for placing new orders.", "trading.asset.freeCollateral.formula": "Free collateral = Total balance + Total unsettlement PnL - Total position initial margin", "trading.asset.marginRatio": "Margin ratio", "trading.asset.marginRatio.tooltip": "The margin ratio represents the proportion of collateral relative to the total position value.", "trading.asset.marginRatio.formula": "Account margin ratio = (Total collateral value / Total position notional) * 100%", "trading.asset.unsettledPnl": "Unsettled PnL", "trading.asset.free&TotalCollateral": "Free / Total Collateral", "trading.asset.availableBalance": "Available Balance", "trading.asset.maintenanceMarginRatio": "Maintenance margin ratio", "trading.asset.maintenanceMarginRatio.tooltip": "The minimum margin ratio required to protect your positions from being liquidated. If the Margin ratio falls below the Maintenance margin ratio, the account will be liquidated.", "trading.asset.maintenanceMarginRatio.formula": "Account maintenance margin ratio = Sum(Position notional * Symbol maintenance Margin Ratio)  / Total position notional * 100%", "trading.riskRate": "Risk rate", "trading.riskRate.tooltip": "The Risk rate is used to assess the risk level of an account. When the Risk rate reaches 100%, the account will be liquidated", "trading.riskRate.formula": "Risk rate = Maintenance margin ratio / Margin ratio * 100%", "trading.asset&Margin": "Asset & Margin", "trading.fundingRate.predFundingRate": "Pred. funding rate" };
var q$2 = { "tradingLeaderboard.leaderboard": "Leaderboard", "tradingLeaderboard.campaigns": "Campaigns", "tradingLeaderboard.ongoing": "Ongoing", "tradingLeaderboard.past": "Past", "tradingLeaderboard.future": "Future", "tradingLeaderboard.learnMore": "Learn more", "tradingLeaderboard.tradeNow": "Trade now", "tradingLeaderboard.tradingVolume": "Trading volume", "tradingLeaderboard.rank": "Rank" };
var F$3 = { "tradingRewards.rewards": "Rewards", "tradingRewards.subtitle": "Trade with {{brokerName}} to earn esORDER.", "tradingRewards.subtitle.mm": "Trade to earn $ORDER", "tradingRewards.learnMore": "Learn more here", "tradingRewards.myEstRewards": "My est. rewards", "tradingRewards.epoch": "Epoch", "tradingRewards.epochRewards": "Epoch rewards", "tradingRewards.otherOrderlyDex": "Other Orderly DEX", "tradingRewards.claim": "Claim", "tradingRewards.availableClaim": "Available to claim", "tradingRewards.stake": "Stake", "tradingRewards.booster": "Booster", "tradingRewards.stakeBooster": "Stake booster", "tradingRewards.avgStakedAmount": "Avg. staked amount", "tradingRewards.rewardHistory": "Reward history", "tradingRewards.rewardsEarned": "Rewards earned", "tradingRewards.rewardHistory.column.start&EndDate": "Start / End date", "tradingRewards.rewardHistory.column.startDate": "Start", "tradingRewards.rewardHistory.column.endDate": "End date" };
var B$5 = { "tradingView.timeInterval.1m": "1m", "tradingView.timeInterval.3m": "3m", "tradingView.timeInterval.5m": "5m", "tradingView.timeInterval.15m": "15m", "tradingView.timeInterval.30m": "30m", "tradingView.timeInterval.1h": "1h", "tradingView.timeInterval.2h": "2h", "tradingView.timeInterval.4h": "4h", "tradingView.timeInterval.6h": "6h", "tradingView.timeInterval.12h": "12h", "tradingView.timeInterval.1d": "1D", "tradingView.timeInterval.3d": "3D", "tradingView.timeInterval.1w": "1W", "tradingView.timeInterval.1M": "1M", "tradingView.timeInterval.more": "More", "tradingView.lineType.bars": "Bars", "tradingView.lineType.candles": "Candles", "tradingView.lineType.hollowCandles": "Hollow candles", "tradingView.lineType.line": "Line", "tradingView.lineType.area": "Area", "tradingView.lineType.baseline": "Baseline", "tradingView.displayControl.buySell": "Buy/Sell", "tradingView.displayControl.limitOrders": "Limit orders", "tradingView.displayControl.stopOrders": "Stop orders", "tradingView.noScriptSrc": "Due to TradingView's policy, you will need to apply for your own license.", "tradingView.noScriptSrc.1": "1. Please apply for your TradingView Advanced Chart license <0>here</0>", "tradingView.noScriptSrc.2": "2. Follow the instructions on <0>orderly.network</0> to set up." };
var V$4 = { "transfer.network": "Network", "transfer.lowestFee": "lowest fee", "transfer.web3Wallet": "Your Web3 Wallet", "transfer.brokerAccount": "Your {{brokerName}} account", "transfer.quantity.invalid": "Please input a valid number", "transfer.insufficientBalance": "Insufficient balance", "transfer.insufficientAllowance": "Insufficient allowance", "transfer.rejectTransaction": "Rejected transaction", "transfer.deposit.approve.symbol": "Approve {{symbol}}", "transfer.deposit.approve.success": "Approve success", "transfer.deposit.approve.failed": "Approve failed", "transfer.deposit.increase.symbol": "Increase {{symbol}} authorized amount", "transfer.deposit.requested": "Deposit requested", "transfer.deposit.completed": "Deposit completed", "transfer.deposit.failed": "Deposit failed", "transfer.deposit.destinationGasFee": "Destination gas fee", "transfer.deposit.destinationGasFee.description": "Additional gas tokens are required to cover operations on the destination chain.", "transfer.withdraw.unsupported.chain": "Withdrawals are not supported on this chain. Please switch to any of the bridgeless networks.", "transfer.withdraw.unsupported.networkName": "Withdrawals are not supported on {{networkName}}. Please switch to any of the bridgeless networks.", "transfer.withdraw.crossChain.confirmWithdraw": "Confirm to withdraw", "transfer.withdraw.crossChain.recipientAddress": "Recipient address", "transfer.withdraw.crossChain.recipientNetwork": "Recipient network", "transfer.withdraw.crossChain.withdrawAmount": "Withdraw amount", "transfer.withdraw.crossChain.process": "Your cross-chain withdrawal is being processed...", "transfer.withdraw.crossChain.warning": "Withdrawals that require cross-chain rebalancing can't be cancelled or followed up with more withdrawals until they've been processed.", "transfer.withdraw.crossChain.vaultWarning": "Withdrawal exceeds the balance of the {{networkName}} vault ( {{chainVaultBalance}} USDC ). Cross-chain rebalancing fee will be charged for withdrawal to {{networkName}}.", "transfer.withdraw.minAmount.error": "quantity must large than {{minAmount}}", "transfer.withdraw.requested": "Withdraw requested", "transfer.withdraw.completed": "Withdraw completed", "transfer.withdraw.failed": "Withdraw failed" };
var K$3 = { "ui.pagination.morePages": "More pages", "ui.pagination.rowsPerPage": "Rows per page", "ui.picker.selectDate": "Select Date", "ui.empty.description": "No results found." };
var W$1 = { "common.cancel": "Cancel", "common.confirm": "Confirm", "common.ok": "OK", "common.yes": "Yes", "common.no": "No", "common.all": "All", "common.buy": "Buy", "common.sell": "Sell", "common.long": "Long", "common.short": "Short", "common.edit": "Edit", "common.save": "Save", "common.add": "Add", "common.delete": "Delete", "common.tips": "Tips", "common.max": "Max", "common.download": "Download", "common.copy": "Copy", "common.copy.failed": "Copy failed", "common.copy.copied": "Copied", "common.share": "Share", "common.export": "Export", "common.select.1d": "1D", "common.select.3d": "3D", "common.select.7d": "7D", "common.select.14d": "14D", "common.select.30d": "30D", "common.select.90d": "90D", "common.price": "Price", "common.quantity": "Quantity", "common.qty": "Qty", "common.status": "Status", "common.status.all": "All status", "common.date": "Date", "common.time": "Time", "common.volume": "Volume", "common.total": "Total", "common.symbol": "Symbol", "common.token": "Token", "common.amount": "Amount", "common.side": "Side", "common.side.all": "All sides", "common.type": "Type", "common.notional": "Notional", "common.fee": "Fee", "common.avgPrice": "Avg. price", "common.avgOpen": "Avg. open", "common.avgClose": "Avg. close", "common.trigger": "Trigger", "common.lastPrice": "Last price", "common.indexPrice": "Index price", "common.markPrice": "Mark price", "common.limitPrice": "Limit price", "common.marketPrice": "Market", "common.unrealizedPnl": "Unrealized PnL", "common.realizedPnl": "Realized PnL", "common.totalValue": "Total value", "common.address": "Address", "common.address.search.placeholder": "Search address", "common.available": "Available", "common.overview": "Overview", "common.funding": "Funding", "common.assets": "Assets", "common.countdown": "Countdown", "common.current": "Current", "common.account": "Account", "common.deposit": "Deposit", "common.withdraw": "Withdraw", "common.settle": "Settle", "common.markets": "Markets", "common.portfolio": "Portfolio", "common.positions": "Positions", "common.position": "Position", "common.orders": "Orders", "common.tpsl": "TP/SL", "common.leverage": "Leverage", "common.affiliate": "Affiliate", "common.tradingRewards": "Trading rewards", "common.trading": "Trading", "assetHistory.status.pending": "Pending", "assetHistory.status.confirm": "Confirm", "assetHistory.status.processing": "Processing", "assetHistory.status.completed": "Completed", "assetHistory.status.failed": "Failed", "assetHistory.status.pendingRebalance": "Pending rebalance", "linkDevice.createQRCode.loading.description": "Approve QR code with wallet...", "linkDevice.createQRCode.linkMobileDevice": "Link Mobile Device", "linkDevice.createQRCode.linkMobileDevice.description": "Open {{hostname}} on your mobile device and scan the QR code to link this wallet. For security, the QR code will expire in 60 seconds. <br/> The QR code allows mobile trading but does not enable withdrawals. Ensure you are not sharing your screen or any screenshots of the QR code.", "linkDevice.createQRCode.success.description": "Scan the QR code or paste the URL into another browser/<br/>device to continue.", "linkDevice.createQRCode.success.copyUrl": "Copy URL", "linkDevice.scanQRCode": "Scan QR Code", "linkDevice.scanQRCode.description": "Click the <0/> icon in the top right corner on desktop to generate a QR code to scan.", "linkDevice.scanQRCode.tooltip": "Link to Desktop via QR Code", "linkDevice.scanQRCode.connected.description": "You are connected via another device. This mode is for trading only. To switch networks, deposit or withdraw assets, please disconnect and reconnect your wallet on this device.", "settle.settlePnl": "Settle PnL", "settle.settlePnl.warning": "Please settle your balance", "settle.settlePnl.description": "Are you sure you want to settle your PnL? <br/> Settlement will take up to 1 minute before you can withdraw your available balance.", "settle.unsettled": "Unsettled", "settle.unsettled.tooltip": "Unsettled balance can not be withdrawn. In order to withdraw, please settle your balance first.", "settle.settlement.requested": "Settlement requested", "settle.settlement.completed": "Settlement completed", "settle.settlement.failed": "Settlement failed", "settle.settlement.error": "Settlement is only allowed once every 10 minutes. Please try again later.", "languageSwitcher.language": "Language", "languageSwitcher.tips": "AI-generated translations may not be fully accurate.", "announcement.type.listing": "Listing", "announcement.type.maintenance": "Maintenance", "announcement.type.delisting": "Delisting", "maintenance.dialog.title": "System upgrade in progress", "maintenance.dialog.description": "Sorry, {{brokerName}} is temporarily unavailable due to a scheduled upgrade. The service is expected to be back by {{endDate}}.", "maintenance.tips.description": "{{brokerName}} will be temporarily unavailable for a scheduled upgrade from {{startDate}} to {{endDate}}.", "restrictedInfo.description.default": " You are accessing {{brokerName}} from an IP address ({{ip}}) associated with a restricted country.", ...R$2, ...A$3, ...N$3, ...C$1, ...E$2, ...I$3, ...O$4, ...M$3, ...S$1, ...x$2, ...D$1, ...F$3, ...B$5, ...T, ...V$4, ...L$4, ...K$3, ...q$2 };
var $$3 = { [h$1]: { [s]: W$1 } }, _$1 = new G$8(null, { lookupLocalStorage: k$2, lookupCookie: b$2, caches: ["localStorage", "cookie"] }), U$4 = createInstance({ fallbackLng: h$1, interpolation: { escapeValue: false }, resources: $$3 }).use(_$1);
U$4.init();
var o = U$4;
var w$2 = createContext({ languages: [], onLanguageBeforeChanged: () => Promise.resolve(), onLanguageChanged: () => Promise.resolve() }), ot$3 = () => useContext(w$2);
function ne$6(t, e2) {
  let r3 = useContext(I18nContext);
  return useTranslation(t, { i18n: (r3 == null ? void 0 : r3.i18n) || o, ...e2 });
}
function de$4() {
  let [t, e2] = useState(o.language);
  return useEffect(() => {
    let r3 = (a2) => {
      e2(a2);
    };
    return o.on("languageChanged", r3), () => {
      o.off("languageChanged", r3);
    };
  }, [o]), t;
}
var O$3 = () => {
  useEffect(() => {
    let r3 = new URLSearchParams(window.location.search).get("ref");
    r3 && localStorage.setItem("referral_code", r3);
  }, []);
};
var N$2 = "orderly:wallet-info";
function _() {
  let { connectedChain: e2, disconnect: r3 } = useWalletConnector(), [s2, o2] = useLocalStorage("orderly_link_device", {}), { account: n4 } = useAccount(), { isMobile: t } = it$6(), d2 = useConfig(), c = async (a2) => {
    localStorage.removeItem(N$2), await n4.disconnect(), await r3({ label: a2 });
  };
  useEffect(() => {
    let a2 = b$1(), m2 = JSON.parse(localStorage.getItem(N$2) ?? "{}");
    a2 && m2 && c(m2.label);
  }, []);
  let l2 = async () => {
    let a2 = b$1();
    if (!a2) return;
    let { address: m2, secretKey: p2, chainId: g2, chainNamespace: h2 } = a2;
    if (!await n4.importOrderlyKey({ address: m2, secretKey: p2, chainNamespace: h2 })) return;
    o2({ chainId: g2, chainNamespace: h2 });
    let I2 = new URL(window.location.href);
    I2.searchParams.delete("link"), I2.searchParams.append("utm_medium", "qrcode");
    let w4 = decodeURIComponent(I2.toString());
    history.replaceState(null, "", w4);
  };
  useEffect(() => {
    t && !e2 && l2();
  }, [n4, e2, t]);
  let i = async () => {
    let { chainId: a2, chainNamespace: m2 } = he$3() || {};
    if (t && !e2 && a2 && m2) {
      let p2 = n4.keyStore.getAddress(), g2 = n4.keyStore.getOrderlyKey(), h2 = n4.keyStore.getAccountId(p2);
      await n4.checkOrderlyKey(p2, g2, h2) && d2.set("chainNamespace", m2);
    }
  };
  return useEffect(() => {
    i();
  }, [n4, t, e2]), { linkDevice: l2 };
}
function he$3() {
  try {
    let e2 = localStorage.getItem("orderly_link_device");
    return e2 ? parseJSON(e2) : null;
  } catch {
  }
}
function b$1() {
  let r3 = new URL(window.location.href).searchParams.get("link");
  if (!r3) return;
  let { a: s2, k: o2, i: n4, n: t } = ye$3(r3) || {};
  if (s2 && o2 && n4 && t) return { address: s2, secretKey: o2, chainId: n4, chainNamespace: t };
}
function ye$3(e2) {
  try {
    let r3 = JSON.parse(window.atob(e2)), s2 = Math.floor(Date.now() / 1e3), o2 = r3.t;
    return !o2 || s2 > o2 ? void 0 : r3;
  } catch {
  }
}
var q$1 = "orderly:wallet-info";
var U$3 = (e2) => {
  let { wallet: r3, connect: s2, connectedChain: o2, disconnect: n4, namespace: t } = useWalletConnector();
  if (typeof s2 != "function") throw new SDKError("Please provide a wallet connector provider");
  useEventEmitter();
  let c = useRef(false);
  useConfig("brokerId");
  let { account: i, state: a2 } = useAccount(), m2 = useKeyStore(), p2 = useConfig("networkId"), [g2, { checkChainSupport: h2 }] = useChains(), [k2, I2] = useState(false), { track: w4, setTrackUserId: ie2 } = useTrack(), A2 = useMemo(() => {
    var _a3, _b2;
    return (_b2 = (_a3 = r3 == null ? void 0 : r3.accounts) == null ? void 0 : _a3[0]) == null ? void 0 : _b2.address;
  }, [r3]), P2 = useMemo(() => {
    var _a3, _b2, _c2, _d3;
    let u2 = (_b2 = (_a3 = r3 == null ? void 0 : r3.chains) == null ? void 0 : _a3[0]) == null ? void 0 : _b2.id, f2 = (_d3 = (_c2 = r3 == null ? void 0 : r3.chains) == null ? void 0 : _c2[0]) == null ? void 0 : _d3.namespace;
    if (!(typeof u2 > "u")) return { id: z$4(u2), namespace: f2 };
  }, [r3]);
  return useEffect(() => {
    a2.status >= AccountStatusEnum.EnableTrading && i.accountId && ie2(i.accountId);
  }, [i, a2]), useEffect(() => {
    if (!o2) {
      I2(false);
      return;
    }
    let u2 = h2(o2.id, p2);
    ABSTRACT_CHAIN_ID_MAP.has(parseInt(o2.id)) && (r3 == null ? void 0 : r3.label) !== "AGW" && (u2 = false), I2(!u2);
  }, [o2, g2, h2, p2, r3]), useEffect(() => {
    w$4(() => {
      let u2 = m2.getAddress(), f2 = JSON.parse(localStorage.getItem(q$1) ?? "{}");
      (o2 == null ? void 0 : o2.namespace) !== ChainNamespace.solana && u2 && i.address !== u2 && f2.label && s2({ autoSelect: { label: f2.label, disableModals: true } }).then((x2) => {
      }, (x2) => {
      });
    });
  }, [r3, i.address]), useEffect(() => {
    if (r3 === null && a2.status > AccountStatusEnum.NotConnected && !a2.validating) {
      i.disconnect();
      return;
    }
    if (k2 || !o2 || c.current) return;
    let u2 = b$1();
    A2 && A2 !== i.address && !u2 && (i.setAddress(A2, { provider: r3 == null ? void 0 : r3.provider, chain: { id: N$5(P2.id), namespace: P2.namespace.toUpperCase() }, wallet: { name: (r3 == null ? void 0 : r3.label) ?? "" }, additionalInfo: (r3 == null ? void 0 : r3.additionalInfo) ?? {} }), w4(TrackerEventName.walletConnect, { wallet: (r3 == null ? void 0 : r3.label) ?? "", network: P2.namespace.toUpperCase() }), w$4(() => {
      localStorage.setItem(q$1, JSON.stringify({ label: (r3 == null ? void 0 : r3.label) ?? "" }));
    })), (P2 == null ? void 0 : P2.id) !== i.chainId && i.switchChainId(P2 == null ? void 0 : P2.id);
  }, [r3, o2, A2, P2, i.address, a2, i.chainId, k2]), { connectWallet: async () => (c.current = true, s2({ chainId: e2.currentChainId }).then(async (u2) => {
    if (Array.isArray(u2) && u2.length > 0 && u2[0] && u2[0].accounts.length > 0) {
      let f2 = u2[0], x2 = N$5(f2.chains[0].id);
      if (!h2(x2, p2)) return { wrongNetwork: true };
      if (!i) throw new Error("account is not initialized");
      a2.status === AccountStatusEnum.EnableTradingWithoutConnected && (localStorage.removeItem("orderly_link_device"), await i.disconnect());
      let ce2 = await i.setAddress(f2.accounts[0].address, { provider: f2.provider, chain: { id: N$5(f2.chains[0].id), namespace: f2.chains[0].namespace.toUpperCase() }, wallet: { name: f2.label } });
      return w4(TrackerEventName.walletConnect, { wallet: f2.label, network: f2.chains[0].namespace.toUpperCase() }), { wallet: f2, status: ce2, wrongNetwork: false };
    }
    return null;
  }).finally(() => {
    c.current = false;
  })), wrongNetwork: k2 };
};
function H() {
  let { t: e2 } = ne$6(), r3 = useEventEmitter(), s2 = useRef({}), [o2, n4] = useSessionStorage("orderly_wallet_change_id", {});
  s2.current = o2, useWalletSubscription({ onMessage: (t) => {
    let { id: d2, side: c, transStatus: l2 } = t, i = true;
    if (["DEPOSIT", "WITHDRAW"].includes(c) && ["COMPLETED", "FAILED"].includes(l2)) {
      let a2 = s2.current[d2];
      n4({ ...o2, [d2]: a2 ? void 0 : true }), i = !a2;
    }
    if (l2 === "COMPLETED" && i) {
      let a2 = `${j$4(c)} completed`;
      c === "DEPOSIT" ? a2 = e2("transfer.deposit.completed") : c === "WITHDRAW" && (a2 = e2("transfer.withdraw.completed")), toast$2.success(a2);
    } else if (l2 === "FAILED" && i) {
      let a2 = `${j$4(c)} failed`;
      c === "DEPOSIT" ? a2 = e2("transfer.deposit.failed") : c === "WITHDRAW" && (a2 = e2("transfer.withdraw.failed")), toast$2.error(a2);
    }
    r3.emit("wallet:changed", t);
  } });
}
function z$2() {
  let { t: e2 } = ne$6();
  useSettleSubscription({ onMessage: (r3) => {
    let { status: s2 } = r3;
    switch (s2) {
      case "COMPLETED":
        toast$2.success(e2("settle.settlement.completed"));
        break;
      case "FAILED":
        toast$2.error(e2("settle.settlement.failed"));
        break;
    }
  } });
}
function J$2() {
  let { t: e2 } = ne$6(), r3 = useEventEmitter(), { setLedgerAddress: s2 } = useStorageLedgerAddress();
  return useEffect(() => {
    r3.on("wallet:connect-error", (o2) => {
      toast$2.error(o2.message);
    }), r3.on("wallet:sign-message-with-ledger-error", (o2) => {
      window.setTimeout(() => {
        vo$4.confirm({ title: e2("connector.ledger.signMessageFailed"), content: e2("connector.ledger.signMessageFailed.description"), size: "sm", onOk: async () => (s2(o2.userAddress), Promise.resolve()), okLabel: e2("common.ok"), onCancel: async () => (toast$2.error(o2.message), Promise.resolve()), cancelLabel: e2("common.no") }).then((n4) => {
        });
      });
    });
  }, [r3, e2]), {};
}
function V$3(e2) {
  let { storageChain: r3, setStorageChain: s2 } = useStorageChain(), [o2, n4] = useState(), [t] = useChains(), d2 = useConfig("networkId"), { connectedChain: c } = useWalletConnector();
  return useEffect(() => {
    var _a3, _b2, _c2;
    if (c) n4 == null ? void 0 : n4(typeof c.id == "number" ? c.id : parseInt(c.id));
    else {
      if (o2) return;
      let l2, i = d2 === "mainnet" ? (_a3 = t.mainnet) == null ? void 0 : _a3[0] : (_b2 = t.testnet) == null ? void 0 : _b2[0];
      typeof e2 == "function" ? l2 = e2(d2, t) : typeof e2 == "object" && (l2 = d2 === "mainnet" ? e2 == null ? void 0 : e2.mainnet : e2 == null ? void 0 : e2.testnet);
      let a2 = (l2 == null ? void 0 : l2.id) || ((_c2 = i == null ? void 0 : i.network_infos) == null ? void 0 : _c2.chain_id);
      if (!a2) return;
      r3 ? n4 == null ? void 0 : n4(r3.chainId) : (s2(a2), n4 == null ? void 0 : n4(a2));
    }
  }, [c, t, o2, d2, n4, e2]), [o2, n4];
}
var Y$3 = createContext({ setCurrentChainId: (e2) => {
}, restrictedInfo: {}, setShowAnnouncement: (e2) => {
} }), L$3 = () => useContext(Y$3), G$4 = (e2) => {
  let [r3, s2] = useState(false), [o2, n4] = V$3(e2.defaultChain);
  _(), useTrackingInstance();
  let { connectWallet: t, wrongNetwork: d2 } = U$3({ currentChainId: o2 });
  H(), z$2(), J$2();
  let c = useRestrictedInfo(e2.restrictedInfo), l2 = c.restrictedOpen, i = useMemo(() => ({ connectWallet: t, wrongNetwork: d2, currentChainId: o2, setCurrentChainId: n4, onChainChanged: e2.onChainChanged, disabledConnect: l2, restrictedInfo: c, showAnnouncement: r3, setShowAnnouncement: s2 }), [t, o2, l2, e2.onChainChanged, c, n4, r3, d2]);
  return jsx(Y$3.Provider, { value: i, children: e2.children });
};
var j$2 = createContext({}), or$3 = () => useContext(j$2), X$2 = (e2) => jsx(j$2.Provider, { value: e2, children: e2.children });
function cr$2(e2) {
  return e2 === "BUY" ? o.t("common.buy") : e2 === "SELL" ? o.t("common.sell") : j$4(e2);
}
function ee$2(e2, r3) {
  let { symbol: s2, side: o$1, quantity: n4 } = e2, t = "total_executed_quantity" in e2 ? e2.total_executed_quantity : 0, d2 = "status" in e2 ? e2.status : e2.algo_status, c = r3[s2], l2 = c("base_dp"), i = cr$2(o$1), a2 = G$7(s2), m2 = "algo_type" in e2 && e2.algo_type === AlgoOrderRootType.POSITIONAL_TP_SL ? o.t("tpsl.entirePosition") : l2 === void 0 ? n4 : Ir$1(n4, { dp: l2 }), p2 = "", g2 = "";
  switch (d2) {
    case OrderStatus.NEW:
      p2 = o.t("orders.status.opened.toast.title"), g2 = `${i} ${a2} ${m2}`;
      break;
    case OrderStatus.FILLED:
    case OrderStatus.PARTIAL_FILLED:
      let h2 = l2 === void 0 ? t : Ir$1(t, { dp: l2 });
      p2 = o.t("orders.status.filled.toast.title"), g2 = `${i} ${a2} ${h2} / ${m2}`;
      break;
    case OrderStatus.CANCELLED:
      p2 = o.t("orders.status.canceled.toast.title"), g2 = `${i} ${a2} ${m2}`;
      break;
    case OrderStatus.REJECTED:
      p2 = o.t("orders.status.rejected.toast.title"), g2 = `${i} ${a2} ${m2}`;
      break;
    case OrderStatus.REPLACED:
      p2 = o.t("orders.status.replaced.toast.title"), g2 = `${o$1} ${a2} ${t} / ${m2}`;
      break;
  }
  return { title: p2, msg: g2 };
}
function oe$6() {
  let e2 = useEventEmitter(), r3 = useSymbolsInfo(), s2 = useRef({});
  useEffect(() => {
    s2.current = r3;
  }, [r3]);
  let o2 = useDebouncedCallback((n4) => {
    ((d2) => {
      let { title: c, msg: l2 } = ee$2(d2, s2.current);
      c && l2 && toast$2.success(jsxs("div", { children: [c, jsx("br", {}), jsx("div", { className: "orderly-text-white/[0.54] orderly-text-xs", children: l2 })] }));
    })(n4);
  }, 100);
  useEffect(() => (e2.on("orders:changed", o2), () => {
    e2.off("orders:changed", o2);
  }), []);
}
function ae$3() {
  let { t: e2 } = ne$6(), r3 = de$4();
  return useMemo(() => {
    let s2 = { [u$1.en]: enUS, [u$1.zh]: zhCN };
    return { locale: r3, dialog: { ok: e2("common.ok"), cancel: e2("common.cancel") }, modal: { confirm: e2("common.confirm"), cancel: e2("common.cancel") }, pagination: { morePages: e2("ui.pagination.morePages"), rowsPerPage: e2("ui.pagination.rowsPerPage") }, picker: { selectDate: e2("ui.picker.selectDate"), dayPicker: s2[r3] }, empty: { description: e2("ui.empty.description") } };
  }, [e2, r3]);
}
var se$2 = (e2) => {
  let { components: r3, appIcons: s2, onChainChanged: o2, defaultChain: n4, ...t } = e2;
  useTrack(), O$3(), oe$6();
  let d2 = ae$3();
  return jsx(X$2, { appIcons: s2, brokerName: e2.brokerName, children: jsx(y0, { components: r3, overrides: e2.overrides, children: jsxs(OrderlyConfigProvider, { ...t, children: [jsx(G$4, { onChainChanged: o2, defaultChain: n4, restrictedInfo: e2.restrictedInfo, children: jsx(g1, { locale: d2, children: jsx(wd, { delayDuration: 300, children: jsx(um, { children: e2.children }) }) }) }), jsx(X0, {})] }) }) });
};
se$2.displayName = "OrderlyAppProvider";
var Tr$2 = (e2, r3) => {
  let { wrongNetwork: s2, disabledConnect: o2 } = L$3(), { state: n4 } = useAccount();
  return (r3 == null ? void 0 : r3.skip) ? e2 : s2 || o2 || typeof (r3 == null ? void 0 : r3.accountStatus) < "u" && n4.status < r3.accountStatus ? typeof (r3 == null ? void 0 : r3.fallbackData) < "u" ? r3.fallbackData : null : e2;
};
function Lr$3(e2) {
  let { t: r3 } = ne$6(), s2 = (n4, t, d2) => {
    var _a3;
    return (_a3 = { quantity: { required: r3("orderEntry.orderQuantity.error.required"), min: r3("orderEntry.orderQuantity.error.min", { value: t }), max: r3("orderEntry.orderQuantity.error.max", { value: t }) }, order_quantity: { required: r3("orderEntry.orderQuantity.error.required"), min: r3("orderEntry.orderQuantity.error.min", { value: t }), max: r3("orderEntry.orderQuantity.error.max", { value: t }) }, order_price: { required: r3("orderEntry.orderPrice.error.required"), min: r3("orderEntry.orderPrice.error.min", { value: t }), max: r3("orderEntry.orderPrice.error.max", { value: t }) }, trigger_price: { required: r3("orderEntry.triggerPrice.error.required"), min: r3("orderEntry.triggerPrice.error.min", { value: t }), max: r3("orderEntry.triggerPrice.error.max", { value: t }) }, tp_trigger_price: { min: r3("orderEntry.tpTriggerPrice.error.min", { value: t }), max: r3("orderEntry.tpTriggerPrice.error.max", { value: t }) }, sl_trigger_price: { min: r3("orderEntry.slTriggerPrice.error.min", { value: t }), max: r3("orderEntry.slTriggerPrice.error.max", { value: t }) }, total: { min: r3("orderEntry.total.error.min", { value: t }) } }[n4]) == null ? void 0 : _a3[d2];
  };
  return { parseErrorMsg: (n4) => {
    let { type: t, value: d2 } = (e2 == null ? void 0 : e2[n4]) || {};
    return t ? s2(n4, d2, t) : "";
  } };
}
const OrderlyIcon = (props) => {
  const { size = 14, ...rest } = props;
  return /* @__PURE__ */ jsx(
    "svg",
    {
      width: size,
      height: size,
      viewBox: "0 0 24 24",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ...rest,
      children: /* @__PURE__ */ jsx("g", { transform: "translate(24, 0) scale(-1, 1)", children: /* @__PURE__ */ jsx(
        "path",
        {
          fillRule: "evenodd",
          clipRule: "evenodd",
          d: "M6 3V21H9L15 9.5V21H18V3H15L9 14.5V3H6Z",
          fill: "white",
          fillOpacity: "0.98"
        }
      ) })
    }
  );
};
const OrderlyActiveIcon = (props) => {
  const { size = 14, ...rest } = props;
  return /* @__PURE__ */ jsx(
    "svg",
    {
      width: size,
      height: size,
      viewBox: "0 0 24 24",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ...rest,
      children: /* @__PURE__ */ jsx("g", { transform: "translate(24, 0) scale(-1, 1)", children: /* @__PURE__ */ jsx(
        "path",
        {
          fillRule: "evenodd",
          clipRule: "evenodd",
          d: "M6 3V21H9L15 9.5V21H18V3H15L9 14.5V3H6Z",
          fill: "coral",
          fillOpacity: "0.98"
        }
      ) })
    }
  );
};
const SwapTradeSwitch = () => /* @__PURE__ */ jsxs("div", { className: "flex items-center bg-[#1A1A1A] p-1 rounded-md", children: [
  /* @__PURE__ */ jsx(
    Link,
    {
      to: "#",
      "aria-disabled": true,
      className: "px-4 py-1 rounded-md text-sm text-gray-500 bg-transparent cursor-not-allowed",
      children: "Swap"
    }
  ),
  /* @__PURE__ */ jsx(
    Link,
    {
      to: "/",
      className: "px-4 py-1 rounded-md text-sm text-white bg-gradient-to-r from-purple-500 to-purple-600",
      children: "Trade"
    }
  )
] });
const config = {
  scaffold: {
    mainNavProps: {
      leading: /* @__PURE__ */ jsx(SwapTradeSwitch, {}),
      initialMenu: "/",
      mainMenus: [
        {
          name: "Trading",
          href: "/"
          // isSubMenuInMobile: true
        },
        { name: "Portfolio", href: "/portfolio" },
        { name: "Markets", href: "/markets" }
      ],
      campaigns: {
        name: "Reward",
        href: "/rewards",
        icon: "/reward-logo.png",
        children: [
          {
            name: "Trading rewards",
            href: "#",
            description: "Coming Soon...",
            icon: /* @__PURE__ */ jsx(OrderlyIcon, { size: 14 }),
            activeIcon: /* @__PURE__ */ jsx(OrderlyActiveIcon, { size: 14 }),
            // target: "_blank",
            disabled: true
          },
          {
            name: "Staking",
            href: "#",
            description: "Coming Soon...",
            icon: /* @__PURE__ */ jsx(OrderlyIcon, { size: 14 }),
            activeIcon: /* @__PURE__ */ jsx(OrderlyActiveIcon, { size: 14 }),
            // target: "_blank",
            disabled: true
          }
        ]
      }
    },
    footerProps: {
      // telegramUrl: "https://t.me",
      discordUrl: "https://discord.gg/Bvar3BRhrY",
      twitterUrl: "https://x.com/ninco_fi",
      trailing: /* @__PURE__ */ jsx(
        "span",
        {
          className: "oui-text-2xs oui-text-base-contrast-54",
          style: { position: "absolute", right: 10 },
          children: "Ninco Finance"
        }
      )
    },
    bottomNavProps: {
      mainMenus: [
        {
          name: "",
          href: "/",
          activeIcon: /* @__PURE__ */ jsx(Ip, { size: 32 }),
          inactiveIcon: /* @__PURE__ */ jsx(Np, { size: 32, style: { cursor: "pointer" } })
        },
        {
          name: "",
          href: "/portfolio",
          activeIcon: /* @__PURE__ */ jsx(Sp, { size: 32 }),
          inactiveIcon: /* @__PURE__ */ jsx(kp, { size: 32, style: { cursor: "pointer" } })
        },
        {
          name: "",
          href: "/markets",
          activeIcon: /* @__PURE__ */ jsx(yp, {}),
          inactiveIcon: /* @__PURE__ */ jsx(
            Mp,
            {
              size: 32,
              style: { cursor: "pointer", marginBottom: "-10px" }
            }
          )
        }
      ],
      current: "/"
    }
  },
  orderlyAppProvider: {
    appIcons: {
      main: {
        img: "/logo.png"
      },
      secondary: {
        img: "/logo-secondary.svg"
      }
    }
  },
  tradingPage: {
    tradingViewConfig: {
      scriptSRC: "/tradingview/charting_library/charting_library.js",
      library_path: "/tradingview/charting_library/",
      customCssUrl: "/tradingview/chart.css"
    },
    sharePnLConfig: {
      backgroundImages: [
        "/pnl/poster_bg_1.png",
        "/pnl/poster_bg_2.png",
        "/pnl/poster_bg_3.png",
        "/pnl/poster_bg_4.png"
      ],
      color: "rgba(255, 255, 255, 0.98)",
      profitColor: "rgba(41, 223, 169, 1)",
      lossColor: "rgba(245, 97, 139, 1)",
      brandColor: "rgba(255, 255, 255, 0.98)"
    }
  }
};
const NimcoProvider = (props) => {
  const networkId = "mainnet";
  const onChainChanged = useCallback(
    (_chainId3, { isTestnet }) => {
      if (isTestnet && networkId === "mainnet" || !isTestnet && networkId === "testnet") {
        setTimeout(() => {
          const href = isTestnet ? "https://broker-template-git-develop-orderly-devrels-projects.vercel.app" : "https://broker-template-seven.vercel.app";
          if (href) {
            window.location.href = href;
          }
        }, 100);
      }
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    []
  );
  return /* @__PURE__ */ jsx(
    WalletConnectorProvider,
    {
      solanaInitial: {
        network: WalletAdapterNetwork.Mainnet
      },
      evmInitial: void 0,
      children: /* @__PURE__ */ jsx(
        se$2,
        {
          brokerId: "ninco_fi",
          brokerName: "NincoFi",
          networkId,
          onChainChanged,
          appIcons: config.orderlyAppProvider.appIcons,
          children: props.children
        }
      )
    }
  );
};
function generatePageTitle(title) {
  return `${title} | ${"NincoFi"}`;
}
function formatSymbol(symbol, format2 = "base-type") {
  const arr = symbol.split("_");
  const type = arr[0];
  const base = arr[1];
  const quote = arr[2];
  return format2.replace("type", type).replace("base", base).replace("quote", quote);
}
const applyCustomInitConfigs = () => {
  setTimeout(() => {
    const isInitialized = localStorage.getItem("init");
    if (isInitialized === "1") {
      return;
    }
    const adapterSettingsJSON = localStorage.getItem("SDK_Tradingview_adapter");
    if (!adapterSettingsJSON) {
      return;
    }
    const adapterSettings = JSON.parse(adapterSettingsJSON);
    if (!adapterSettings) {
      return;
    }
    if (!("ChartDrawingToolbarWidget.visible" in adapterSettings)) {
      adapterSettings["ChartDrawingToolbarWidget.visible"] = "true";
      localStorage.setItem(
        "SDK_Tradingview_adapter",
        JSON.stringify(adapterSettings)
      );
    }
    localStorage.setItem("init", "1");
    window.location.reload();
  }, 5e3);
};
function Layout({ children }) {
  useEffect(() => {
    applyCustomInitConfigs();
  }, []);
  return /* @__PURE__ */ jsxs("html", { lang: "en", children: [
    /* @__PURE__ */ jsxs("head", { children: [
      /* @__PURE__ */ jsx("meta", { charSet: "utf-8" }),
      /* @__PURE__ */ jsx("meta", { name: "viewport", content: "width=device-width, initial-scale=1" }),
      /* @__PURE__ */ jsx("link", { rel: "icon", type: "image/png", href: "/favicon.png" }),
      /* @__PURE__ */ jsx(Meta, {}),
      /* @__PURE__ */ jsx(Links, {})
    ] }),
    /* @__PURE__ */ jsxs("body", { children: [
      /* @__PURE__ */ jsx(NimcoProvider, { children }),
      /* @__PURE__ */ jsx(ScrollRestoration, {}),
      /* @__PURE__ */ jsx(Scripts, {})
    ] })
  ] });
}
function App() {
  return /* @__PURE__ */ jsx(Outlet, {});
}
const route0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Layout,
  default: App
}, Symbol.toStringTag, { value: "Module" }));
var te$4 = "orderly_selected_chains", ne$5 = 6, L$2 = (e2) => {
  let { networkId: o2, bridgeLessOnly: r3 } = e2 || {}, { setStorageChain: l2 } = useStorageChain(), m2 = useConfig(), [n4, { checkChainSupport: c }] = useChains(), { setChain: d2, connectedChain: f2 } = useWalletConnector(), { onChainChanged: u2, currentChainId: T2, setCurrentChainId: s2, wrongNetwork: C2 } = L$3(), [B2, N2] = useState(T2), { getComponentTheme: U2 } = Ui$1(), h2 = useMemo(() => ({ mainnet: (r3 ? n4.mainnet.filter((i) => i.network_infos.bridgeless) : n4.mainnet).map((i) => ({ name: i.network_infos.name, id: i.network_infos.chain_id, lowestFee: i.network_infos.bridgeless, isTestnet: false })), testnet: n4.testnet.map((i) => ({ name: i.network_infos.name, id: i.network_infos.chain_id, lowestFee: i.network_infos.bridgeless, isTestnet: true })) }), [n4, r3]), x2 = useMemo(() => !(U2("chainSelector", { showTestnet: true }).showTestnet === false || !h2.testnet.length), [h2.testnet]), { recentChains: z2, saveRecentChain: D2 } = oe$5(h2), E3 = async (t) => {
    if (f2) {
      let i = await d2({ chainId: t.id });
      return i && { result: i, wrongNetwork: !c(t.id, m2.get("networkId")), chainId: t.id };
    }
    return l2(t.id), s2(t.id), { result: true, wrongNetwork: false, chainId: t.id };
  }, S2 = (t, i) => {
    var _a3;
    let v3 = { isTestnet: t.isTestnet, isWalletConnected: i };
    (_a3 = e2.onChainChangeAfter) == null ? void 0 : _a3.call(e2, t.id, v3), u2 == null ? void 0 : u2(t.id, v3);
  }, V2 = async (t) => {
    var _a3, _b2, _c2;
    N2(t.id), (_a3 = e2.onChainChangeBefore) == null ? void 0 : _a3.call(e2, t.id, { isTestnet: t.isTestnet });
    try {
      let i = await (E3 == null ? void 0 : E3(t));
      i ? ((_b2 = e2.resolve) == null ? void 0 : _b2.call(e2, i), (_c2 = e2.close) == null ? void 0 : _c2.call(e2), D2(t), S2(t, true)) : (N2(void 0), S2(t, false));
    } catch {
      S2(t, false);
    }
  }, { selectedTab: H2, onTabChange: K2 } = ie(h2, T2, C2, x2);
  return { recentChains: z2, chains: h2, selectChainId: B2, onChainClick: V2, selectedTab: H2, onTabChange: K2, showTestnet: x2 };
};
function ie(e2, o2, r3, l2) {
  let [m2, n4] = useState("Mainnet"), c = (d2) => {
    n4(d2);
  };
  return useEffect(() => {
    var _a3, _b2;
    if (!l2) {
      n4("Mainnet");
      return;
    }
    if (o2) {
      if ((_a3 = e2.mainnet) == null ? void 0 : _a3.some((u2) => u2.id === o2)) {
        n4(r3 ? "Testnet" : "Mainnet");
        return;
      }
      if ((_b2 = e2.testnet) == null ? void 0 : _b2.some((u2) => u2.id === o2)) {
        n4(r3 ? "Mainnet" : "Testnet");
        return;
      }
    }
  }, [o2, e2, r3, l2]), { selectedTab: m2, onTabChange: c };
}
function oe$5(e2) {
  let [o2, r3] = useLocalStorage(te$4, []), l2 = useMemo(() => o2 == null ? void 0 : o2.map((n4) => {
    var _a3;
    return (_a3 = e2.mainnet) == null ? void 0 : _a3.find((c) => c.id === parseInt(n4));
  }).filter((n4) => !!n4), [e2, o2]), m2 = useCallback((n4) => {
    if (n4.isTestnet) return;
    let c = o2 == null ? void 0 : o2.filter((d2) => d2 !== n4.id);
    c = [n4.id, ...c].slice(0, ne$5), r3(c);
  }, [o2]);
  return { recentChains: l2, saveRecentChain: m2 };
}
var ce$8 = h$2({ slots: { icon: "", list: "oui-grid oui-grid-cols-1 oui-gap-1", mainnetList: '"', testnetList: '"', recentList: "", item: "oui-w-full oui-rounded-md", tip: "oui-text-center" }, variants: { variant: { compact: { icon: "oui-w-6 oui-h-6", list: "oui-bg-base-9 oui-rounded-lg oui-p-1", mainnetList: "oui-grid-cols-2 oui-mt-4", testnetList: "oui-grid-cols-1 oui-mt-4", recentList: "oui-mt-4", item: "oui-bg-base-6 hover:oui-bg-base-7", tip: "oui-pt-6" }, wide: { icon: "oui-w-[18px] oui-h-[18px]", mainnetList: "oui-grid-cols-3 oui-mt-3", testnetList: "oui-grid-cols-2 oui-mt-3", recentList: "oui-mt-3", item: "oui-bg-base-5 hover:oui-bg-base-6", tip: "oui-pt-8" } }, selected: { true: { item: "" }, false: { item: "oui-bg-transparent" } } }, compoundVariants: [{ variant: "compact", selected: true, className: { item: "hover:oui-bg-base-6" } }, { variant: "wide", selected: true, className: { item: "hover:oui-bg-base-5" } }], defaultVariants: { variant: "wide", selected: false } }), P$1 = (e2) => {
  var _a3, _b2, _c2, _d3;
  let { isWrongNetwork: o2, variant: r3 = "wide" } = e2, { t: l2 } = ne$6(), { list: m2, recentList: n4, mainnetList: c, testnetList: d2, icon: f2, item: u2, tip: T2 } = ce$8({ variant: r3 });
  return jsxs(W$2, { className: cnBase("oui-font-semibold", e2.className), children: [jsxs(jl, { value: e2.selectedTab, variant: "contained", size: r3 === "wide" ? "md" : "lg", onValueChange: (s2) => e2.onTabChange(s2), children: [jsxs($l, { value: "Mainnet", title: l2("connector.mainnet"), children: [!!((_a3 = e2.recentChains) == null ? void 0 : _a3.length) && jsx(z$3, { gap: 2, className: n4(), children: (_b2 = e2.recentChains) == null ? void 0 : _b2.map((s2) => jsx(le$5, { item: s2, onClick: () => e2.onChainClick(s2), iconClassName: f2() }, s2.id)) }), jsx(W$2, { r: "2xl", className: cnBase(m2(), c()), children: (_c2 = e2.chains.mainnet) == null ? void 0 : _c2.map((s2) => {
    let C2 = e2.selectChainId === s2.id;
    return jsx(W, { selected: C2, item: s2, onClick: () => e2.onChainClick(s2), className: u2({ selected: C2 }) }, s2.id);
  }) })] }), e2.showTestnet && jsx($l, { value: "Testnet", title: l2("connector.testnet"), children: jsx(W$2, { r: "2xl", className: cnBase(m2(), d2()), children: (_d3 = e2.chains.testnet) == null ? void 0 : _d3.map((s2) => {
    let C2 = e2.selectChainId === s2.id;
    return jsx(W, { selected: C2, item: s2, onClick: () => e2.onChainClick(s2), className: u2({ selected: C2 }) }, s2.id);
  }) }) })] }), o2 && jsx(W$2, { className: T2(), children: jsx(Q$1, { color: "warning", size: "xs", children: l2("connector.wrongNetwork.tooltip") }) })] });
}, W = (e2) => {
  let { item: o2 } = e2;
  return jsx("button", { className: e2.className, onClick: e2.onClick, children: jsxs(z$3, { justify: "between", className: "oui-py-2.5", px: 3, children: [jsxs(z$3, { itemAlign: "center", width: "100%", className: "oui-gap-x-[6px]", children: [jsx(Fr$1, { chainId: o2.id, size: "xs" }), jsx(Q$1, { size: "2xs", children: o2.name })] }), e2.selected && jsx(W$2, { gradient: "brand", r: "full", width: 4, height: 4 })] }) });
}, le$5 = (e2) => jsx("button", { className: "oui-border oui-border-line-12 oui-rounded-lg hover:oui-border-primary-light", onClick: e2.onClick, children: jsx(z$3, { itemAlign: "center", p: 2, children: jsx(Fr$1, { chainId: e2.item.id, className: e2.iconClassName }) }) });
var I$2 = (e2) => {
  let o2 = L$2(e2);
  return jsx(P$1, { ...o2, variant: e2.variant, isWrongNetwork: e2.isWrongNetwork });
}, F$2 = "ChainSelectorDialogId", A$2 = "ChainSelectorSheetId";
Wm(F$2, I$2, { size: "lg", title: () => o.t("connector.switchNetwork"), variant: "wide", isWrongNetwork: true });
Um(A$2, I$2, { title: () => o.t("connector.switchNetwork"), classNames: { content: "!oui-bg-base-8", body: "!oui-bg-base-8" }, variant: "compact", isWrongNetwork: true });
var Q = (e2) => {
  let { title: t, description: n4 } = e2;
  return jsxs(W$2, { position: "relative", className: "oui-pl-8", children: [jsxs(W$2, { children: [jsx(Q$1, { as: "div", intensity: 98, size: "sm", children: t }), jsx(Q$1, { as: "div", intensity: 54, size: "2xs", children: n4 })] }), jsx(be$4, { ...e2 })] });
}, be$4 = (e2) => {
  let { active: t, isLoading: n4, isCompleted: o2 } = e2;
  return jsx(vg$1, { className: "oui-absolute oui-left-0 oui-top-1 oui-z-10", value: () => o2 ? "completed" : n4 ? "loading" : t ? "active" : "normal", case: { loading: jsx("div", { children: jsx(Ie$4, { size: "sm", className: "oui-ml-1" }) }), completed: jsx("div", { children: jsx(on$1, { opacity: 1, className: "oui-text-primary" }) }) }, default: jsx(Ce$3, { active: !!t }) });
}, Ce$3 = ({ active: e2, className: t }) => jsx("div", { className: cnBase("oui-w-[8.3px] oui-h-[8.3px] oui-rounded-full oui-ml-2 oui-mt-1", t, e2 ? "oui-bg-primary-light" : "oui-bg-base-2") });
var O$2 = (e2) => {
  let { initAccountState: t = AccountStatusEnum.NotConnected } = e2, [n4, o2] = useState(true), r3 = useEventEmitter(), { t: c } = ne$6(), { state: g2, account: d2 } = useAccount(), [m2, a2] = useState(t), [l2, f2] = useState(0), [s2, h2] = useState(false), [I2] = useLocalStorage("orderly-first-show-wallet-connector-dialog", void 0);
  useEffect(() => () => {
    localStorage.setItem("orderly-first-show-wallet-connector-dialog", "1");
  }, []), useEffect(() => {
    a2(g2.status);
  }, [g2]);
  let T2 = useMemo(() => {
    let i = [];
    return t < AccountStatusEnum.SignedIn && i.push({ key: "signIn", title: c("connector.signIn"), description: c("connector.signIn.description") }), t < AccountStatusEnum.EnableTrading && i.push({ key: "enableTrading", title: c("connector.enableTrading"), description: c("connector.enableTrading.description") }), i;
  }, [t, c]), k2 = () => (h2(true), e2.enableTrading(n4).then(async (i) => {
    var _a3;
    h2(false), f2((w4) => w4 + 1);
    try {
      await ((_a3 = e2.enableTradingComplted) == null ? void 0 : _a3.call(e2));
    } catch {
    }
    typeof e2.onCompleted == "function" ? e2.onCompleted() : typeof e2.close == "function" && e2.close();
  }, (i) => {
    if (h2(false), i !== -1) {
      if (i.message.indexOf("Signing off chain messages with Ledger is not yet supported") !== -1) {
        r3.emit("wallet:sign-message-with-ledger-error", { message: i.message, userAddress: d2.address });
        return;
      }
      toast$2.error(Y$2(i));
    }
  }).catch((i) => {
    h2(false);
  })), N2 = () => (h2(true), e2.signIn().then((i) => {
    f2((w4) => w4 + 1), k2();
  }, (i) => {
    if (h2(false), i !== -1) {
      if (i.message.indexOf("Signing off chain messages with Ledger is not yet supported") !== -1) {
        r3.emit("wallet:sign-message-with-ledger-error", { message: i.message, userAddress: d2.address });
        return;
      }
      toast$2.error(Y$2(i));
    }
  }).catch((i) => {
    h2(false);
  }));
  return jsxs(W$2, { id: "oui-wallet-connect-dialog-content", className: "oui-font-semibold", children: [jsx(Q$1, { intensity: 54, size: "xs", children: c("connector.expired") }), jsxs(W$2, { p: 4, my: 6, intensity: 600, r: "lg", className: "oui-space-y-5", position: "relative", children: [T2.map((i, w4) => jsx(Q, { title: i.title, description: i.description, isCompleted: l2 > w4, active: l2 === w4, isLoading: s2 && l2 === w4 }, i.key)), T2.length > 1 && jsx(W$2, { position: "absolute", height: "38px", left: 28, top: 18, zIndex: 0, children: jsx(de$5, { lineStyle: "dashed", direction: "vertical", intensity: 16, className: "oui-h-full" }) })] }), e2.showRefCodeInput && T2.length == 2 && jsx(ve$4, { ...e2 }), I2 && jsxs(z$3, { justify: "between", itemAlign: "center", children: [jsx(Me$5, {}), jsx(di$2, { color: "primary", checked: n4, onCheckedChange: o2, disabled: s2, className: "data-[state=checked]:oui-bg-primary-darken" })] }), jsx(z$3, { justify: "center", mt: 8, children: jsx(W$2, { className: "oui-min-w-[144px]", children: jsx(Ee$2, { state: m2, signIn: N2, enableTrading: k2, loading: s2, disabled: m2 >= AccountStatusEnum.EnableTrading }) }) })] });
}, Ee$2 = ({ state: e2, signIn: t, enableTrading: n4, loading: o2, disabled: r3 }) => {
  let { t: c } = ne$6();
  return jsx(vg$1, { value: () => e2 <= AccountStatusEnum.NotSignedIn ? "signIn" : "enableTrading", case: { signIn: jsx($e$6, { fullWidth: true, onClick: () => t(), loading: o2, disabled: r3, children: c("connector.signIn") }), enableTrading: jsx($e$6, { fullWidth: true, onClick: () => n4(), loading: o2, disabled: r3, children: c("connector.enableTrading") }) } });
}, ve$4 = (e2) => {
  let { t } = ne$6();
  return jsx(ui$3, { placeholder: t("connector.referralCode.placeholder"), fullWidth: true, label: "", value: e2.refCode, onChange: (n4) => {
    e2.setRefCode(n4.target.value);
  }, classNames: { label: "oui-text-base-contrast-54 oui-text-xs", input: "placeholder:oui-text-base-contrast-20 placeholder:oui-text-sm" }, formatters: [li$3.createRegexInputFormatter((n4) => String(n4).replace(/[a-z]/g, (o2) => o2.toUpperCase())), li$3.createRegexInputFormatter(/[^A-Z0-9]/g)], onClear: () => {
    e2.setRefCode("");
  }, autoComplete: "off", helpText: e2.helpText, className: "oui-mb-4", color: e2.helpText ? "danger" : void 0 });
}, Me$5 = () => {
  let { t: e2 } = ne$6(), t = () => {
    window.innerWidth > 768 || vo$4.alert({ title: e2("connector.rememberMe"), message: jsx("span", { className: "oui-text-2xs oui-text-base-contrast/60", children: e2("connector.rememberMe.description") }) });
  };
  return jsx(xs, { content: e2("connector.rememberMe.description"), className: "oui-max-w-[300px]", children: jsx("button", { onClick: t, children: jsx(Q$1, { intensity: 54, size: "xs", className: "oui-underline oui-underline-offset-4 oui-decoration-dashed oui-decoration-base-contrast-36", children: e2("connector.rememberMe") }) }) });
};
function Y$2(e2) {
  Object.keys(e2).forEach((n4) => {
  });
  let t = o.t("connector.somethingWentWrong");
  return e2.toString().includes("rejected") && (t = o.t("connector.userRejected")), yg(t) ?? t;
}
var L$1 = () => {
  let { account: e2, state: t, createOrderlyKey: n4, createAccount: o2 } = useAccount(), [r3, c] = useState(""), [g2, d2] = useState(""), { t: m2 } = ne$6(), { trigger: a2 } = useLazyQuery(`/v1/public/referral/verify_ref_code?referral_code=${r3}`);
  useEffect(() => {
    let y2 = localStorage.getItem("referral_code");
    y2 != null && c(y2);
  }, []);
  let { referral_code: l2, isLoading: f2 } = useGetReferralCode(e2.accountId), [s2, { error: h2, isMutating: I2 }] = useMutation("/v1/referral/bind", "POST");
  useEffect(() => {
    r3.length === 0 && d2("");
  }, [r3]);
  let T2 = () => {
    toast$2.success(m2("connector.walletConnected")), r3.length >= 4 && r3.length <= 10 && s2({ referral_code: r3 }).finally(() => {
      localStorage.removeItem("referral_code");
    });
  }, k2 = async () => {
    if (r3.length === 0) return Promise.resolve(void 0);
    if (r3.length > 0 && (r3.length < 4 || r3.length > 10)) return Promise.resolve(m2("connector.referralCode.invalid"));
    let { exist: y2 } = await a2();
    return y2 === false ? Promise.resolve(m2("connector.referralCode.notExist")) : Promise.resolve(void 0);
  }, N2 = ((l2 == null ? void 0 : l2.length) || 0) === 0 && !f2, i = async () => {
    if (N2) {
      let y2 = await k2();
      if (typeof y2 < "u") return d2(y2), Promise.reject(-1);
    }
    return d2(""), o2();
  };
  return { enableTrading: async (y2) => {
    if (N2) {
      let _2 = await k2();
      if (typeof _2 < "u") return d2(_2), Promise.reject(-1);
    }
    return d2(""), n4(y2);
  }, initAccountState: t.status, signIn: i, enableTradingComplted: T2, refCode: r3, setRefCode: c, helpText: g2, showRefCodeInput: N2 };
};
var R$1 = "walletConnector", B$4 = "walletConnectorSheet", D = (e2) => {
  let t = L$1();
  return jsx(O$2, { ...t, ...e2 });
};
Wm(R$1, D, { size: "sm", title: () => o.t("connector.connectWallet") });
Um(B$4, D, { title: () => o.t("connector.connectWallet") });
var S = (e2) => {
  let { status: t, buttonProps: n4, fallback: o2, descriptions: r3, classNames: c, networkId: g2, id: d2, bridgeLessOnly: m2 } = e2, { t: a2 } = ne$6(), { state: l2 } = useAccount(), { wrongNetwork: f2, disabledConnect: s2 } = L$3(), h2 = useMemo(() => t === void 0 ? l2.status === AccountStatusEnum.EnableTradingWithoutConnected ? AccountStatusEnum.EnableTradingWithoutConnected : AccountStatusEnum.EnableTrading : t, [t, l2.status]), I2 = { connectWallet: a2("connector.connectWallet"), switchChain: a2("connector.wrongNetwork"), enableTrading: a2("connector.enableTrading"), signin: a2("connector.signIn"), ...e2.labels }, T2 = useMemo(() => typeof o2 < "u" ? o2({ validating: l2.validating, status: l2.status, wrongNetwork: f2 }) : l2.validating && !s2 ? jsx(A$1, { angle: 45, disabled: true, loading: true, description: r3 == null ? void 0 : r3.connectWallet, id: d2, type: "button", ...n4, children: I2.connectWallet }) : jsx(je$3, { bridgeLessOnly: m2, status: l2.status, buttonProps: { ...n4, id: d2, type: "button" }, wrongNetwork: f2, networkId: e2.networkId, labels: I2, descriptions: r3, disabledConnect: s2 }), [l2.status, l2.validating, n4, f2]);
  return jsx(wg$1, { value: l2.status >= h2 && !f2 && !s2, left: T2, children: e2.children });
}, je$3 = (e2) => {
  let { buttonProps: t, labels: n4, descriptions: o2 } = e2, { t: r3 } = ne$6(), { connectWallet: c } = L$3(), { account: g2 } = useAccount(), { isMobile: d2 } = it$6(), m2 = useMediaQuery(MEDIA_TABLET), a2 = () => {
    vo$4.show(m2 ? B$4 : R$1).then((s2) => {
    }, (s2) => {
    });
  }, l2 = async () => {
    let s2 = await c();
    s2 && (s2.wrongNetwork ? f2() : ((s2 == null ? void 0 : s2.status) ?? AccountStatusEnum.NotConnected) < AccountStatusEnum.EnableTrading && a2());
  }, f2 = () => {
    g2.once("validate:end", (s2) => {
      s2 < AccountStatusEnum.EnableTrading ? a2() : toast$2.success(r3("connector.walletConnected"));
    }), vo$4.show(d2 ? A$2 : F$2, { networkId: e2.networkId, bridgeLessOnly: e2.bridgeLessOnly }).then((s2) => {
      s2.wrongNetwork || e2.status >= AccountStatusEnum.Connected && (e2.status < AccountStatusEnum.EnableTrading ? a2() : toast$2.success(r3("connector.walletConnected")));
    }, (s2) => {
    });
  };
  return e2.wrongNetwork && !e2.disabledConnect ? jsx(A$1, { color: "warning", onClick: () => {
    f2();
  }, description: o2 == null ? void 0 : o2.switchChain, ...t, children: n4.switchChain }) : jsx(vg$1, { value: e2.status, case: (s2) => {
    if (s2 <= AccountStatusEnum.NotConnected || e2.disabledConnect) return jsx(A$1, { size: "lg", onClick: () => {
      l2();
    }, variant: e2.disabledConnect ? void 0 : "gradient", angle: 45, description: o2 == null ? void 0 : o2.connectWallet, disabled: e2.disabledConnect, ...t, children: n4.connectWallet });
    if (s2 <= AccountStatusEnum.NotSignedIn) return jsx(A$1, { size: "lg", onClick: () => {
      a2();
    }, angle: 45, description: o2 == null ? void 0 : o2.signin, ...t, children: n4.signin });
  }, default: jsx(A$1, { size: "lg", description: o2 == null ? void 0 : o2.enableTrading, ...t, onClick: () => a2(), children: n4.enableTrading }) });
};
S.displayName = "AuthGuard";
var A$1 = (e2) => {
  let { description: t, ...n4 } = e2;
  return jsxs(z$3, { direction: "column", children: [jsx($e$6, { ...n4 }), !!t && jsx(W$2, { mt: 4, className: "oui-leading-none", style: { lineHeight: 0 }, children: jsx(Q$1, { size: "2xs", intensity: 36, children: t }) })] });
};
var dt$3 = (e2) => {
  var _a3;
  let { status: t, labels: n4, description: o2, dataSource: r3, ...c } = e2, { state: g2 } = useAccount(), { wrongNetwork: d2, disabledConnect: m2 } = L$3(), a2 = useMemo(() => t === void 0 ? g2.status === AccountStatusEnum.EnableTradingWithoutConnected ? AccountStatusEnum.EnableTradingWithoutConnected : AccountStatusEnum.EnableTrading : t, [t, g2.status]), l2 = Tr$2(r3, { accountStatus: a2 }), f2 = d2 || m2 || g2.status < a2 || e2.ignoreLoadingCheck;
  return jsx(L1, { dataSource: l2, ignoreLoadingCheck: f2, emptyView: jsx(ut$2, { status: a2, description: o2, labels: n4, className: (_a3 = e2.classNames) == null ? void 0 : _a3.authGuardDescription, visible: !g2.validating }), manualPagination: true, ...c });
}, ut$2 = (e2) => {
  let { t } = ne$6(), o2 = { ...{ connectWallet: t("connector.trade.connectWallet.tooltip"), switchChain: t("connector.wrongNetwork.tooltip"), enableTrading: t("connector.trade.enableTrading.tooltip"), signin: t("connector.trade.signIn.tooltip") }, ...e2.description };
  return e2.visible ? jsx(z$3, { py: 8, children: jsx(S, { status: e2.status, labels: e2.labels, descriptions: o2, buttonProps: { size: "md" }, children: jsx(bi$2, { position: Yt$1.EmptyDataIdentifier }) }) }) : null;
};
var ce$7 = (e2) => {
  let { t } = ne$6(), { hint: n4 = { connectWallet: t("connector.trade.connectWallet.tooltip"), signIn: t("connector.trade.signIn.tooltip"), enableTrading: t("connector.trade.enableTrading.tooltip"), wrongNetwork: t("connector.wrongNetwork.tooltip") }, status: o2 } = e2;
  return jsx(W$2, { my: 8, children: jsx(S, { status: o2, descriptions: { ...n4, switchChain: n4.wrongNetwork }, children: e2.children || jsx(er$1, {}) }) });
};
ce$7.displayName = "AuthGuardEmpty";
var ge$2 = (e2) => {
  let { t } = ne$6(), { opactiy: n4 = 90, tooltip: o2 = { connectWallet: t("connector.setUp.connectWallet.tooltip"), signIn: t("connector.setUp.signIn.tooltip"), enableTrading: t("connector.setUp.enableTrading.tooltip"), wrongNetwork: t("connector.wrongNetwork.tooltip") } } = e2, [r3, c] = useState(false), { state: g2 } = useAccount(), d2 = true, { wrongNetwork: m2 } = L$3(), a2 = useMemo(() => {
    if (m2) return o2 == null ? void 0 : o2.wrongNetwork;
    switch (g2.status) {
      case AccountStatusEnum.NotConnected:
        return o2 == null ? void 0 : o2.connectWallet;
      case AccountStatusEnum.NotSignedIn:
        return o2 == null ? void 0 : o2.signIn;
      case AccountStatusEnum.DisabledTrading:
        return o2 == null ? void 0 : o2.enableTrading;
      case AccountStatusEnum.EnableTrading:
        return "";
      default:
        return e2.content;
    }
  }, [e2.content, g2, d2, o2]), l2 = useMemo(() => {
    switch (g2.status) {
      case AccountStatusEnum.NotConnected:
      case AccountStatusEnum.NotSignedIn:
        return n4;
      case AccountStatusEnum.EnableTrading:
        return;
      default:
        return;
    }
  }, [e2.opactiy, g2, d2]);
  return jsx(xs, { open: a2 ? r3 : false, onOpenChange: c, content: a2, className: "oui-text-2xs", align: e2.align, alignOffset: e2.alignOffset, side: e2.side, sideOffset: e2.sideOffset, children: jsx("div", { style: { opacity: l2 }, children: e2.children }) });
};
ge$2.displayName = "AuthGuardTooltip";
var Fe$5 = (e2) => {
  let { t } = ne$6(), { accountState: o2, onDisconnect: n4, onOpenExplorer: i } = e2, r3 = o2.validating || e2.disabledConnect;
  if (!r3 && (o2.status === AccountStatusEnum.EnableTrading || o2.status === AccountStatusEnum.EnableTradingWithoutConnected)) return jsx(Un, { address: o2.address, onDisconnect: n4, onOpenExplorer: i });
  if (o2.status <= AccountStatusEnum.NotConnected || r3) return jsx($e$6, { "data-testid": "oui-testid-nav-bar-connectWallet-btn", size: "md", variant: r3 ? void 0 : "gradient", angle: 45, className: "wallet-connect-button", loading: o2.validating, disabled: r3, onClick: () => {
    e2.connect().then((a2) => {
    }).catch((a2) => {
    });
  }, children: t("connector.connectWallet") });
  if (o2.status <= AccountStatusEnum.NotSignedIn) return jsx($e$6, { size: "md", onClick: () => e2.onCrateAccount(), children: t("connector.signIn") });
  if (o2.status <= AccountStatusEnum.DisabledTrading) return jsx($e$6, { size: "md", onClick: () => {
    e2.onCreateOrderlyKey().then((a2) => {
    }).catch((a2) => {
    });
  }, children: t("connector.enableTrading") });
}, Un = (e2) => {
  let { address: t, onDisconnect: o2 } = e2, { t: n4 } = ne$6();
  return jsxs(la$1, { children: [jsx(ua$2, { asChild: true, children: jsx($e$6, { size: "md", variant: "gradient", angle: 45, "data-testid": "oui-testid-nav-bar-address-btn", children: jsx(Q$1.formatted, { rule: "address", className: "oui-text-[rgba(0,0,0,.88)]", children: t }) }) }), jsx(ca$1, { children: jsxs(xr$3, { size: "xl", align: "end", onCloseAutoFocus: (i) => i.preventDefault(), style: { width: "280px" }, className: "oui-py-5 oui-font-semibold", sideOffset: 12, children: [jsx(dg, { children: jsxs(z$3, { px: 4, children: [jsxs(z$3, { gap: 2, className: "oui-flex-1", children: [jsx(Ba, { address: t, size: "md" }), jsx(Q$1.formatted, { rule: "address", size: "base", children: t })] }), jsxs(z$3, { gap: 2, children: [jsx("button", { "data-testid": "oui-testid-nav-bar-dropDownMenuItem-copyAddress", onClick: async () => {
    await navigator.clipboard.writeText(t);
  }, children: jsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: "18", height: "18", viewBox: "0 0 18 18", className: "oui-fill-[rgba(255,255,255,0.36)] hover:oui-fill-primary-darken", children: jsx("path", { d: "M5.249 2.243a3 3 0 0 0-3 3v4.5a3 3 0 0 0 3 3 3 3 0 0 0 3 3h4.5a3 3 0 0 0 3-3v-4.5a3 3 0 0 0-3-3 3 3 0 0 0-3-3zm7.5 4.5a1.5 1.5 0 0 1 1.5 1.5v4.5a1.5 1.5 0 0 1-1.5 1.5h-4.5a1.5 1.5 0 0 1-1.5-1.5h3a3 3 0 0 0 3-3z" }) }) }), jsx("button", { onClick: () => e2.onOpenExplorer(), children: jsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: "18", height: "18", viewBox: "0 0 18 18", className: "oui-fill-[rgba(255,255,255,0.36)] hover:oui-fill-primary-darken", children: jsx("path", { d: "M12.7432 15.7432C14.3999 15.7432 15.7432 14.3999 15.7432 12.7432V5.24316C15.7432 3.58641 14.3999 2.24316 12.7432 2.24316H5.24316C3.58641 2.24316 2.24316 3.58641 2.24316 5.24316V12.7432C2.24316 14.3999 3.58641 15.7432 5.24316 15.7432H12.7432ZM6.74316 11.9932C6.55116 11.9932 6.35092 11.9287 6.20392 11.7824C5.91142 11.4892 5.91142 10.9972 6.20392 10.7039L9.20392 7.70392L7.49316 5.99316H11.9932V10.4932L10.2824 8.78241L7.28241 11.7824C7.13616 11.9287 6.93516 11.9932 6.74316 11.9932Z" }) }) })] })] }) }), jsx(de$5, { className: "oui-mx-4 oui-my-3", intensity: 8 }), jsx(dg, { children: jsx(br$5, { size: "xl", onSelect: (i) => {
    i.preventDefault(), o2();
  }, "data-testid": "oui-testid-nav-bar-dropDownMenuItem-disconnect", children: jsxs(z$3, { gap: 2, className: "oui-text-danger-light", children: [jsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: "18", height: "18", viewBox: "0 0 18 18", fill: "none", children: jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M3.97 14.03a.75.75 0 0 1 0-1.06l.262-.263C2.594 12.354 1.5 11.108 1.5 9.06c0-2.447 1.563-3.75 3.75-3.75H6a.75.75 0 0 1 0 1.5h-.75C3.837 6.81 3 7.508 3 9.06s.837 2.25 2.25 2.25h.38l1.188-1.188a.75.75 0 0 1-.068-.312v-.75c0-1.162.381-2.19 1.172-2.883.645-.565 1.512-.867 2.578-.867h1.13l1.34-1.34a.75.75 0 0 1 1.061 1.06l-9 9a.75.75 0 0 1-1.06 0m6.14-7.2L8.27 8.668c.065-.583.281-1.056.635-1.367.289-.253.684-.419 1.205-.473M7.825 12.8l3.414-3.415c-.126 2.12-1.496 3.297-3.414 3.415m7.705-6.58a.75.75 0 0 0-1.06 1.06c.508.509.53 1.202.53 1.72 0 .739-.014 1.203-.53 1.72-.165.164-.455.307-.825.405a3.8 3.8 0 0 1-.895.125H12a.75.75 0 0 0 0 1.5h.75c.31 0 .787-.045 1.28-.175.48-.127 1.065-.36 1.5-.795.97-.97.97-1.991.97-2.75v-.06c0-.51.002-1.778-.97-2.75", fill: "currentcolor" }) }), jsx("span", { children: n4("connector.disconnect") })] }) }) })] }) })] });
};
var it$5 = () => {
  let { t: e2 } = ne$6(), { disconnect: t, connectedChain: o2 } = useWalletConnector(), { account: n4, state: i } = useAccount(), { connectWallet: r3, disabledConnect: a2 } = L$3(), [s2, { findByChainId: u2 }] = useChains(), d2 = async () => {
    vo$4.show(R$1).then((l2) => {
    }, (l2) => {
    });
  }, p2 = async () => {
    vo$4.show(R$1).then((l2) => {
    }, (l2) => {
    });
  }, m2 = () => {
    n4.once("validate:end", (l2) => {
      l2 < AccountStatusEnum.EnableTrading ? g2({ status: l2 }) : toast$2.success(e2("connector.walletConnected"));
    }), vo$4.show(F$2).then((l2) => {
      l2.wrongNetwork || (i.status < AccountStatusEnum.EnableTrading ? g2(i) : toast$2.success(e2("connector.walletConnected")));
    }, (l2) => {
    });
  }, v3 = async () => {
    let l2 = await r3();
    l2 && (l2.wrongNetwork ? m2() : g2(l2));
  }, g2 = (l2) => {
    l2.validating || l2.status <= AccountStatusEnum.Connected || (l2.status < AccountStatusEnum.SignedIn && d2(), l2.status < AccountStatusEnum.EnableTrading && p2());
  }, b2 = useCallback(() => {
    if (!o2) return;
    let l2 = u2(o2.id, "network_infos");
    if (l2) {
      let { explorer_base_url: f2 } = l2;
      f2 && (f2.endsWith("/") ? window.open(`${f2}address/${n4.address}`) : window.open(`${f2}/address/${n4.address}`));
    }
  }, [i, o2]), x2 = async () => {
    var _a3;
    localStorage.removeItem("orderly_link_device"), await t({ label: (_a3 = i.connectWallet) == null ? void 0 : _a3.name }), await n4.disconnect();
  };
  return { address: i.address, accountState: i, connect: v3, onCrateAccount: d2, onCreateOrderlyKey: p2, onOpenExplorer: b2, onDisconnect: x2, disabledConnect: a2 };
};
Zo({ name: "account-menu", positions: [Yt$1.AccountMenu], builder: it$5, __isInternal: true })((e2) => jsx(Fe$5, { ...e2 }));
var Ve$3 = () => jsx(bi$2, { position: Yt$1.AccountMenu });
var ni$2 = (e2) => {
  let { totalValue: t = 0, visible: o2 = true, onToggleVisibility: n4, visibleAvailable: i = true } = e2, { t: r3 } = ne$6();
  return jsxs(z$3, { direction: "column", gap: 0, className: "oui-text-2xs", itemAlign: "start", children: [jsxs(z$3, { gap: 1, itemAlign: "center", children: [jsx(Q$1, { intensity: 54, className: "oui-whitespace-nowrap", children: r3("common.totalValue") }), i && jsx("button", { onClick: () => n4 == null ? void 0 : n4(), children: o2 ? jsx(Nn$2, { size: 12, className: "oui-text-primary-light", opacity: 1 }) : jsx(zn$1, { size: 12, className: "oui-text-primary-light", opacity: 1 }) }), jsx(Q$1, { intensity: 54, children: "" })] }), jsx(Q$1.numeral, { visible: e2.visible, unit: "USDC", unitClassName: "oui-text-base-contrast-20 oui-ml-1", as: "div", children: t ?? "-" })] });
}, ii$1 = (e2) => {
  let { freeCollateral: t, visible: o2, onToggleVisibility: n4, visibleAvailable: i = true } = e2, { t: r3 } = ne$6();
  return jsxs(z$3, { direction: "column", gap: 0, className: "oui-text-2xs", itemAlign: "start", children: [jsxs(z$3, { gap: 1, itemAlign: "center", children: [jsx(Q$1, { intensity: 54, className: "oui-whitespace-nowrap", children: r3("trading.asset.freeCollateral") }), i && jsx("button", { onClick: () => n4 == null ? void 0 : n4(), children: o2 ? jsx(Nn$2, { size: 12, className: "oui-text-primary-light", opacity: 1 }) : jsx(zn$1, { size: 12, className: "oui-text-primary-light", opacity: 1 }) })] }), jsx(Q$1.numeral, { unit: "USDC", unitClassName: "oui-text-base-contrast-20 oui-ml-1", visible: o2, as: "div", children: t ?? "-" })] });
}, ri$3 = (e2) => {
  let { currentLeverage: t } = e2, { t: o2 } = ne$6();
  return jsxs(z$3, { direction: "column", gap: 0, className: "oui-text-2xs", itemAlign: "start", children: [jsx(W$2, { children: jsx(Q$1, { intensity: 54, className: "oui-whitespace-nowrap", children: o2("leverage.currentLeverage") }) }), jsx(Q$1.numeral, { as: "div", unit: "x", children: t ?? 0 })] });
}, ai = (e2) => {
  let { t } = ne$6();
  return jsxs(z$3, { direction: "column", gap: 0, className: "oui-text-2xs", itemAlign: "start", children: [jsx(W$2, { children: jsx(Q$1, { intensity: 54, className: "oui-whitespace-nowrap", children: t("leverage.maxLeverage") }) }), jsx(Q$1, { color: "primary", as: "div", children: `${e2.maxLeverage ?? "--"}x` })] });
}, si$2 = (e2) => {
  let { visible: t, onToggleVisibility: o2, visibleAvailable: n4 = true } = e2, { t: i } = ne$6();
  return jsxs(z$3, { direction: "column", gap: 0, className: "oui-text-2xs", itemAlign: "start", children: [jsxs(z$3, { gap: 1, itemAlign: "center", children: [jsx(Q$1, { intensity: 54, className: "oui-whitespace-nowrap", children: i("common.unrealizedPnl") }), n4 && jsx("button", { onClick: () => o2 == null ? void 0 : o2(), children: t ? jsx(Nn$2, { size: 12, className: "oui-text-primary-light", opacity: 1 }) : jsx(zn$1, { size: 12, className: "oui-text-primary-light", opacity: 1 }) })] }), jsx(Q$1.numeral, { as: "div", coloring: true, showIdentifier: true, weight: "semibold", visible: t, suffix: jsx(Q$1.numeral, { coloring: true, prefix: "(", suffix: ")", rule: "percentages", children: e2.unrealized_pnl_ROI ?? "-" }), children: e2.unrealPnL ?? "-" })] });
}, li$2 = (e2) => {
  let { totalValue: t, keys: o2, elementKeys: n4 } = e2, { t: i } = ne$6(), r3 = (s2) => (u2) => {
    u2.preventDefault(), u2.stopPropagation(), e2.onKeyToTop(s2);
  }, a2 = n4.map((s2) => {
    switch (s2) {
      case "totalValue":
        return jsxs(ve$3, { onSetTop: r3("totalValue"), children: [jsxs(z$3, { className: "oui-text-base-contrast-54", gapX: 2, children: [jsx(xe$1, { active: o2.includes("totalValue"), onClick: () => e2.onToggleItemByKey("totalValue") }), jsx("span", { children: i("common.totalValue") })] }), jsx(Q$1.numeral, { visible: e2.visible, unit: "USDC", className: "group-hover:-oui-translate-x-5 oui-transition-transform", unitClassName: "oui-text-base-contrast-36 oui-ml-1", children: t ?? "-" })] }, s2);
      case "freeCollateral":
        return jsxs(ve$3, { onSetTop: r3("freeCollateral"), children: [jsxs(z$3, { className: "oui-text-base-contrast-54", gapX: 2, children: [jsx(xe$1, { active: o2.includes("freeCollateral"), onClick: () => e2.onToggleItemByKey("freeCollateral") }), jsx("span", { children: i("trading.asset.freeCollateral") })] }), jsx(Q$1.numeral, { unit: "USDC", visible: e2.visible, className: "group-hover:-oui-translate-x-5 oui-transition-transform", unitClassName: "oui-text-base-contrast-36 oui-ml-1", children: e2.freeCollateral ?? "-" })] }, s2);
      case "unrealPnL":
        return jsxs(ve$3, { onSetTop: r3("unrealPnL"), children: [jsxs(z$3, { className: "oui-text-base-contrast-54", gapX: 2, children: [jsx(xe$1, { active: o2.includes("unrealPnL"), onClick: () => e2.onToggleItemByKey("unrealPnL") }), jsx("span", { children: i("common.unrealizedPnl") })] }), jsx(Q$1.numeral, { coloring: true, showIdentifier: true, visible: e2.visible, className: "group-hover:-oui-translate-x-5 oui-transition-transform", suffix: jsx(Q$1.numeral, { coloring: true, prefix: "(", visible: e2.visible, suffix: ")", rule: "percentages", children: e2.unrealized_pnl_ROI ?? "-" }), children: e2.unrealPnL ?? "-" })] }, s2);
      case "currentLeverage":
        return jsxs(ve$3, { onSetTop: r3("currentLeverage"), children: [jsxs(z$3, { className: "oui-text-base-contrast-54", gapX: 2, children: [jsx(xe$1, { active: o2.includes("currentLeverage"), onClick: () => e2.onToggleItemByKey("currentLeverage") }), jsx("span", { children: i("leverage.currentLeverage") })] }), jsx(Q$1.numeral, { className: "group-hover:-oui-translate-x-5 oui-transition-transform", unit: "x", children: e2.currentLeverage ?? "-" })] }, s2);
      case "maxLeverage":
        return jsxs(ve$3, { onSetTop: r3("maxLeverage"), children: [jsxs(z$3, { className: "oui-text-base-contrast-54", gapX: 2, children: [jsx(xe$1, { active: o2.includes("maxLeverage"), onClick: () => e2.onToggleItemByKey("maxLeverage") }), jsx("span", { children: i("leverage.maxLeverage") })] }), jsx(Q$1, { className: "group-hover:-oui-translate-x-5 oui-transition-transform", color: "primary", children: `${e2.maxLeverage ?? "-"}x` })] }, s2);
      default:
        return null;
    }
  });
  return jsx(z$3, { className: "oui-text-2xs oui-font-semibold", direction: "column", gapY: 1, children: a2 });
}, ve$3 = (e2) => jsxs("div", { className: "oui-w-full oui-relative oui-group hover:oui-bg-base-6 oui-px-[6px] oui-py-1 oui-rounded", children: [jsx(z$3, { justify: "between", width: "100%", children: e2.children }), jsx("button", { className: "oui-absolute oui-right-1 oui-top-1", onClick: e2.onSetTop, children: jsxs("svg", { className: "group-hover:oui-opacity-100 group-hover:oui-translate-x-0 oui-opacity-0 oui-translate-x-3 oui-transition-all oui-cursor-pointer oui-fill-base-contrast-54 hover:oui-fill-base-contrast", width: "16", height: "16", viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsx("rect", { width: "16", height: "16", rx: "2", fill: "rgb(var(--oui-color-primary-darken))" }), jsx("path", { d: "M3.507 3.999a.5.5 0 1 0 0 1h9a.5.5 0 0 0 0-1zm4 8.006a.5.5 0 0 0 1 0V7.724l1.5 1.484.703-.703-2.343-2.36a.515.515 0 0 0-.72 0l-2.343 2.36.703.703 1.5-1.484z" })] }) })] }), xe$1 = (e2) => jsx("button", { onClick: e2.onClick, children: e2.active ? jsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: "12", height: "12", viewBox: "0 0 12 12", fill: "none", children: jsx("path", { d: "M7.506.977a.56.56 0 0 0-.365.16C6.367 1.88 6.13 2.5 6.413 3.348c-.661.506-1.078.63-1.903.63-1.127 0-1.863.137-2.364.637v.016a1.187 1.187 0 0 0 0 1.686l1.4 1.411-2.385 2.385a.513.513 0 0 0-.015.717.514.514 0 0 0 .719 0l2.394-2.395 1.403 1.396a1.19 1.19 0 0 0 1.687 0h.016c.501-.5.64-1.142.64-2.358 0-.773.16-1.319.64-1.893.924.271 1.462.012 2.22-.746a.5.5 0 0 0 .14-.36c0-.175-.044-.445-.156-.78a4 4 0 0 0-.984-1.577 4 4 0 0 0-1.578-.984C7.95 1.02 7.682.977 7.506.977", fill: "currentcolor", className: "oui-text-primary-light" }) }) : jsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: "12", height: "12", viewBox: "0 0 12 12", fill: "none", children: jsx("path", { d: "M7.506.977a.56.56 0 0 0-.365.16C6.367 1.88 6.13 2.5 6.413 3.348c-.661.506-1.078.63-1.903.63-1.127 0-1.863.137-2.364.637v.016a1.187 1.187 0 0 0 0 1.686l1.4 1.411-2.385 2.385a.513.513 0 0 0-.015.717.514.514 0 0 0 .719 0l2.394-2.395 1.403 1.396a1.19 1.19 0 0 0 1.687 0h.016c.501-.5.64-1.142.64-2.358 0-.773.16-1.319.64-1.893.924.271 1.462.012 2.22-.746a.5.5 0 0 0 .14-.36c0-.175-.044-.445-.156-.78a4 4 0 0 0-.984-1.577 4 4 0 0 0-1.578-.984C7.95 1.02 7.682.977 7.506.977m.193 1.027c.531.098 1.066.45 1.447.83.381.382.706.848.84 1.459-.477.458-.77.494-1.247.243a.5.5 0 0 0-.583.087c-.91.91-1.15 1.736-1.15 2.85 0 .97-.057 1.33-.36 1.655-.085.092-.203.078-.281 0L2.849 5.615a.18.18 0 0 1-.012-.255c.178-.217.576-.386 1.669-.386 1.306.001 2-.335 2.859-1.14a.5.5 0 0 0 .094-.578c-.257-.513-.217-.784.24-1.252", fill: "currentcolor" }) }) });
var lt$4 = (e2) => {
  let { keys: t, ...o2 } = e2, n4 = 0, i = ze__default__default.useRef(0);
  useEffect(() => {
    let a2 = new ResizeObserver((s2) => {
      if (Array.isArray(s2) && s2.length > 0) {
        let u2 = s2[0].contentRect.width;
        u2 > 1440 ? i.current = 5 : u2 > 1366 ? i.current = 4 : u2 > 1280 ? i.current = 3 : u2 > 1140 ? i.current = 2 : i.current = 1;
      }
    });
    return a2.observe(document.body), () => {
      a2.disconnect();
    };
  }, []);
  let r3 = t.slice(0, i.current).map((a2, s2) => {
    switch (a2) {
      case "freeCollateral":
        return jsx(ii$1, { freeCollateral: e2.freeCollateral, visible: e2.visible, onToggleVisibility: e2.onToggleVisibility, visibleAvailable: s2 === n4 });
      case "unrealPnL":
        return jsx(si$2, { unrealPnL: e2.unrealPnL, unrealized_pnl_ROI: e2.unrealized_pnl_ROI, visible: e2.visible, onToggleVisibility: e2.onToggleVisibility, visibleAvailable: s2 === n4 });
      case "currentLeverage":
        return n4++, jsx(ri$3, { currentLeverage: e2.currentLeverage });
      case "maxLeverage":
        return n4++, jsx(ai, { maxLeverage: e2.maxLeverage });
      case "totalValue":
      default:
        return jsx(ni$2, { totalValue: e2.totalValue, onToggleVisibility: e2.onToggleVisibility, visible: e2.visible, visibleAvailable: s2 === n4 });
    }
  });
  return jsxs("div", { className: "oui-flex oui-items-center oui-gap-6", children: [jsx(ci$2, { elements: r3 }), jsx(Bo$3, { content: jsx(li$2, { totalValue: o2.totalValue, freeCollateral: e2.freeCollateral, maxLeverage: e2.maxLeverage, currentLeverage: e2.currentLeverage, unrealized_pnl_ROI: e2.unrealized_pnl_ROI, unrealPnL: e2.unrealPnL, keys: t, elementKeys: e2.elementKeys, onToggleItemByKey: e2.onToggleItemByKey, onKeyToTop: e2.onKeyToTop, visible: e2.visible }), contentProps: { onOpenAutoFocus: (a2) => a2.preventDefault(), sideOffset: 12, className: "oui-p-1" }, arrow: true, children: jsx("div", { className: "oui-cursor-pointer oui-group", children: jsx(ui$2, {}) }) })] });
}, ci$2 = (e2) => jsx("div", { className: "oui-flex oui-gap-6", children: e2.elements.map((t, o2) => jsx("div", { children: t }, o2)) }), ui$2 = () => jsx("svg", { width: "20", height: "20", viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg", className: "oui-fill-base-contrast-36 hover:oui-fill-primary-light group-data-[state=open]:oui-fill-primary-light", children: jsx("path", { d: "M10.007 8.335a1.666 1.666 0 1 1 0 3.333 1.666 1.666 0 0 1 0-3.333m-5.84 0a1.666 1.666 0 1 1 0 3.333 1.666 1.666 0 0 1 0-3.333m11.666 0a1.666 1.666 0 1 1 0 3.333 1.666 1.666 0 0 1 0-3.333" }) });
var so$3 = () => {
  let [e2, t] = useLocalStorage("accountSummaryTypes", ["totalValue"]), [o2, n4] = useState(["totalValue", "freeCollateral", "unrealPnL", "currentLeverage", "maxLeverage"]), { freeCollateral: i, totalValue: r3 } = useCollateral({ dp: 2 }), { state: a2 } = useAccount(), [s2, u2] = useLocalStorage("orderly_assets_visible", true), [{ aggregated: d2, totalUnrealizedROI: p2 }] = usePositionStream(), { wrongNetwork: m2, disabledConnect: v3 } = L$3(), { currentLeverage: g2 } = useMarginRatio(), { maxLeverage: b2 } = useLeverage(), x2 = (h2) => {
    e2.includes(h2) ? t(e2.filter((S2) => S2 !== h2)) : t([...e2, h2]);
  }, l2 = (h2) => {
    if (!e2.includes(h2)) {
      t([h2, ...e2]), n4([h2, ...o2.filter((S2) => S2 !== h2)]);
      return;
    }
    t([h2, ...e2.filter((S2) => S2 !== h2)]), n4([h2, ...o2.filter((S2) => S2 !== h2)]);
  }, f2 = m2 || v3 || a2.status < AccountStatusEnum.EnableTrading && a2.status !== AccountStatusEnum.EnableTradingWithoutConnected;
  return { totalValue: f2 ? null : r3, freeCollateral: f2 ? null : i, maxLeverage: f2 ? null : b2, currentLeverage: f2 ? null : g2, unrealPnL: f2 ? null : d2 == null ? void 0 : d2.total_unreal_pnl, unrealized_pnl_ROI: f2 ? null : p2, keys: e2, elementKeys: o2, visible: s2, wrongNetwork: m2, onToggleItemByKey: x2, onKeyToTop: l2, onToggleVisibility: () => u2(!s2) };
};
var Be$5 = () => {
  let e2 = so$3();
  return jsx(lt$4, { ...e2, elementKeys: e2.elementKeys });
};
var co$2 = () => {
  let [e2, t] = useState(false), [o2, n4] = useState(false), { state: i } = useAccount(), { connectedChain: r3 } = useWalletConnector(), { currentChainId: a2, wrongNetwork: s2, disabledConnect: u2, setCurrentChainId: d2 } = L$3(), p2 = useConfig("networkId"), m2 = () => {
    t(false);
  }, v3 = () => {
    n4(true), m2();
  }, g2 = () => {
    n4(false);
  };
  return { isConnected: !!r3, currentChainId: a2, wrongNetwork: s2, disabledConnect: u2, accountStatus: i.status, networkId: p2, open: e2, onOpenChange: t, hide: m2, onChainChangeBefore: v3, onChainChangeAfter: g2, loading: o2, setCurrentChainId: d2 };
};
var He$3 = (e2) => {
  let { t } = ne$6();
  if (e2.wrongNetwork && e2.isConnected && !e2.disabledConnect) return jsx(xs, { open: true, hideWhenDetached: true, content: t("connector.wrongNetwork.tooltip"), className: "oui-bg-base-5", arrow: { className: "oui-fill-base-5" }, children: jsx($e$6, { color: "warning", size: "md", onClick: () => {
    vo$4.show(F$2, { networkId: e2.networkId }).then((i) => {
      !i.wrongNetwork && e2.accountStatus < AccountStatusEnum.EnableTrading && vo$4.show(R$1).then((r3) => {
      }, (r3) => {
      });
    }, (i) => {
    });
  }, children: t("connector.wrongNetwork") }) });
  let o2 = () => {
    if (e2.loading) return jsx(Ie$4, { className: "oui-w-[18px] oui-h-[18px]" });
    if (e2.currentChainId) return jsx(Fr$1, { chainId: e2.currentChainId, size: "xs" });
  }, n4 = jsxs(z$3, { intensity: 500, justify: "center", className: cnBase("oui-relative oui-cursor-pointer", "oui-w-11 oui-h-8", "oui-rounded-t-[6px] oui-rounded-bl-[6px] oui-rounded-br-[3px]"), children: [o2(), jsxs("svg", { width: "10", height: "10", viewBox: "0 0 10 10", xmlns: "http://www.w3.org/2000/svg", className: "oui-absolute oui-right-0 oui-bottom-0", children: [jsx("defs", { children: jsxs("linearGradient", { id: "paint0_linear_490_5080", x1: "10", y1: "5", x2: "-5.79673e-08", y2: "5", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "rgb(var(--oui-gradient-brand-end))" }), jsx("stop", { offset: "1", stopColor: "rgb(var(--oui-gradient-brand-start))" })] }) }), jsx("path", { d: "M10 7V0L0 10H7C8.65685 10 10 8.65685 10 7Z", fill: "url(#paint0_linear_490_5080)" })] })] });
  return jsxs(la$1, { open: e2.open, onOpenChange: e2.onOpenChange, children: [jsx(ua$2, { asChild: true, children: n4 }), jsx(ca$1, { children: jsx(xr$3, { onCloseAutoFocus: (i) => i.preventDefault(), onClick: (i) => i.stopPropagation(), sideOffset: 4, collisionPadding: { right: 16 }, className: cnBase("oui-bg-base-8 oui-w-[456px] oui-p-4 oui-rounded-xl", "oui-border oui-border-line-6", "oui-font-semibold"), children: jsx(I$2, { close: e2.hide, onChainChangeBefore: e2.onChainChangeBefore, onChainChangeAfter: e2.onChainChangeAfter }) }) })] });
};
var po$5 = (e2) => {
  let { t } = ne$6();
  return jsx("button", { onClick: (o2) => {
    vo$4.show(A$2, { bridgeLessOnly: false, isWrongNetwork: e2.wrongNetwork }).then((n4) => {
      (n4 == null ? void 0 : n4.chainId) && e2.setCurrentChainId(n4 == null ? void 0 : n4.chainId), toast$2.success(t("connector.networkSwitched"));
    }, (n4) => {
    });
  }, children: jsxs(W$2, { className: "oui-relative oui-rounded-t-[6px] oui-rounded-bl-[6px] oui-rounded-br-[3px] oui-bg-base-5 oui-px-2 oui-h-8 oui-w-8 oui-flex oui-items-center oui-justify-center", children: [jsx(Fr$1, { chainId: e2.currentChainId, size: "xs", className: "oui-h-[18px] oui-w-[18px]" }), jsx("div", { className: "oui-absolute oui-right-0 oui-bottom-0", children: jsxs("svg", { width: "9", height: "9", viewBox: "0 0 9 9", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsx("path", { d: "M9 6V0L0 9h6a3 3 0 0 0 3-3", fill: "url(#a)" }), jsx("defs", { children: jsxs("linearGradient", { id: "a", x1: "9", y1: "4.5", x2: "0", y2: "4.5", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "rgb(var(--oui-gradient-brand-end))" }), jsx("stop", { offset: "1", stopColor: "rgb(var(--oui-gradient-brand-start))" })] }) })] }) })] }) });
};
var ne$4 = () => {
  let e2 = co$2(), { isMobile: t } = it$6();
  return t ? jsx(po$5, { ...e2 }) : jsx(He$3, { ...e2 });
};
var mt$2 = (e2) => {
  let [t, o$1] = useState(false), [n4, i] = useState(false), [r3, a2] = useState(o.language), { languages: s2, onLanguageBeforeChanged: u2, onLanguageChanged: d2, popup: p2 } = ot$3(), { track: m2, setIdentify: v3 } = useTrack(), { isMobile: g2 } = it$6(), b2 = async (l2, f2) => {
    var _a3;
    i(true), a2(l2), await u2(l2), await o.changeLanguage(l2), await d2(l2), o$1(false), (_a3 = e2 == null ? void 0 : e2.setOpen) == null ? void 0 : _a3.call(e2, false), i(false), m2(TrackerEventName.switchLanguage, { language: f2, language_code: l2 }), v3({ language_code: l2 });
  }, x2 = useMemo(() => {
    var _a3;
    return { ...p2, ...e2 == null ? void 0 : e2.popup, mode: ((_a3 = e2 == null ? void 0 : e2.popup) == null ? void 0 : _a3.mode) || (p2 == null ? void 0 : p2.mode) || (g2 ? "sheet" : "modal") };
  }, [p2, e2 == null ? void 0 : e2.popup, g2]);
  return { open: (e2 == null ? void 0 : e2.open) || t, onOpenChange: (e2 == null ? void 0 : e2.setOpen) || o$1, languages: s2, selectedLang: r3, onLangChange: b2, loading: n4, popup: x2 };
};
var ft$2 = (e2) => {
  let { languages: t, popup: o2 } = e2, { t: n4 } = ne$6(), { isMobile: i } = it$6();
  if (t.length <= 1) return null;
  let r3 = jsx(ar, { className: cnBase("oui-size-6 lg:oui-size-5", "oui-cursor-pointer oui-text-base-contrast-80", i && "oui-h-[18px] oui-w-[18px]"), id: "language-switcher-icon", onClick: () => e2.onOpenChange(true) }), a2 = jsx(Q$1, { weight: "semibold", children: n4("languageSwitcher.language") }), s2 = t.map((p2) => {
    let m2 = e2.selectedLang === p2.localCode;
    return jsx(rr$1, { className: cnBase(["modal", "sheet"].includes(o2.mode ?? "") && "oui-w-[calc((100%_-_4px)/2)] lg:oui-w-[calc((100%_-_8px)/3)]"), selected: m2, item: p2, onClick: () => e2.onLangChange(p2.localCode, p2.displayName), loading: e2.loading }, p2.localCode);
  }), u2 = jsx(z$3, { gap: 1, className: "oui-flex-wrap", children: s2 }), d2 = jsx(W$2, { mt: 4, children: jsx(Q$1, { size: "2xs", intensity: 54, weight: "regular", className: "oui-text-warning-darken", children: n4("languageSwitcher.tips") }) });
  if ((o2 == null ? void 0 : o2.mode) === "sheet" && i) return jsxs(Fragment$1, { children: [r3, jsxs(Jo, { open: e2.open, onOpenChange: e2.onOpenChange, classNames: { content: cnBase("oui-px-5 oui-pb-5", o2 == null ? void 0 : o2.className), body: "oui-pb-[env(safe-area-inset-bottom)]" }, contentProps: { style: o2 == null ? void 0 : o2.style }, title: a2, children: [u2, d2] })] });
  if ((o2 == null ? void 0 : o2.mode) === "dropdown") {
    let p2 = jsx(W$2, { mt: 4, className: cnBase("oui-custom-scrollbar oui-max-h-[348px] oui-overflow-y-auto", "oui-grid oui-gap-1 oui-pr-[6px]"), children: s2 });
    return jsxs(la$1, { open: e2.open, onOpenChange: e2.onOpenChange, children: [jsx(ua$2, { asChild: true, children: r3 }), jsx(ca$1, { children: jsxs(xr$3, { onCloseAutoFocus: (m2) => m2.preventDefault(), onClick: (m2) => m2.stopPropagation(), sideOffset: 10, align: "start", collisionPadding: { right: 16 }, className: cnBase("oui-w-[320px] lg:oui-w-[360px]", "oui-rounded-xl oui-bg-base-8 oui-p-5", "oui-border oui-border-line-6", "oui-font-semibold"), children: [a2, p2, d2] }) })] });
  }
  return jsxs(Fragment$1, { children: [r3, jsxs(Se$5, { title: a2, open: e2.open, onOpenChange: e2.onOpenChange, size: i ? "sm" : "xl", classNames: { content: o2 == null ? void 0 : o2.className }, contentProps: { style: o2 == null ? void 0 : o2.style }, children: [u2, d2] })] });
}, rr$1 = (e2) => {
  let { item: t } = e2, o2 = () => e2.loading && e2.selected ? jsx(Ie$4, { size: "sm" }) : e2.selected ? jsx(W$2, { gradient: "brand", r: "full", width: 4, height: 4 }) : null;
  return jsx("button", { className: cnBase("oui-group oui-rounded-md hover:oui-bg-base-5", e2.selected && "oui-bg-base-5", e2.className), onClick: e2.onClick, children: jsxs(z$3, { justify: "between", className: "oui-h-10", px: 3, children: [jsx(z$3, { itemAlign: "center", width: "100%", className: "oui-gap-x-[6px]", children: jsx(Q$1, { size: "2xs", className: cnBase("oui-text-base-contrast-36 group-hover:oui-text-base-contrast-80", e2.selected && "oui-text-base-contrast-80"), children: t.displayName }) }), o2()] }) });
}, ar = forwardRef((e2, t) => {
  let { size: o2 = 20, ...n4 } = e2;
  return jsx("svg", { width: o2, height: o2, viewBox: "0 0 20 20", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ref: t, ...n4, children: jsx("path", { d: "M10 1.678a8.333 8.333 0 1 0 0 16.667 8.333 8.333 0 1 0 0-16.667m0 1.667c1.1 0 2.308 2.527 2.492 5.831l-4.975.01c.183-3.304 1.382-5.84 2.482-5.84m-2.943.67c-.717 1.393-1.1 3.242-1.193 5.165L3.38 9.174c.248-2.271 1.778-4.176 3.676-5.159m5.889.003c1.898.983 3.388 2.835 3.676 5.168l-2.483-.008c-.078-2-.52-3.758-1.193-5.16m-9.56 6.83 2.483-.02c.092 1.923.478 3.803 1.191 5.182a6.79 6.79 0 0 1-3.674-5.162m4.118.007 4.975-.01c-.184 3.303-1.38 5.833-2.48 5.833s-2.312-2.519-2.495-5.823m6.64-.008 2.471-.008c-.287 2.208-1.68 4.18-3.672 5.162.74-1.53 1.108-3.23 1.2-5.154" }) });
});
var ht$3 = (e2) => {
  let t = mt$2(e2);
  return jsx(ft$2, { ...t });
};
var ze$4 = (e2) => {
  var _a3;
  let { classNames: t, currentPath: o2, item: n4, onClick: i, ...r3 } = e2, a2 = useMemo(() => {
    var _a4;
    return ((_a4 = e2.currentPath) == null ? void 0 : _a4[0]) === e2.item.href;
  }, [o2]), s2 = useCallback(() => {
    var _a4;
    Array.isArray(e2.item.children) || ((_a4 = e2.onClick) == null ? void 0 : _a4.call(e2, [e2.item]));
  }, [e2.item]), u2 = jsxs("button", { id: n4.id, "data-testid": n4.testid, ...r3, disabled: e2.item.disabled, "data-actived": a2, className: cnBase("oui-group oui-relative oui-h-[32px] oui-rounded oui-px-3 oui-py-1 oui-text-sm oui-text-base-contrast-36 hover:oui-bg-base-7", t == null ? void 0 : t.navItem), onClick: s2, children: [jsxs("span", { className: "oui-flex oui-items-center", children: [jsx(wo$3, { isActive: a2, item: e2.item }), jsx(Q$1.gradient, { color: a2 ? "brand" : "inherit", angle: 45, className: "oui-whitespace-nowrap oui-break-normal", children: e2.item.name }), Array.isArray(e2.item.children) && jsx("span", { className: "oui-ml-1 group-data-[open=true]:oui-rotate-180", children: a2 ? jsxs("svg", { width: "12", height: "12", viewBox: "0 0 12 12", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsx("path", { d: "M2.913 4.515a.5.5 0 0 0-.328.202.51.51 0 0 0 .14.701L5.722 7.41a.51.51 0 0 0 .562 0l2.995-1.992a.51.51 0 0 0 .14-.7.51.51 0 0 0-.701-.14L6.002 6.382 3.287 4.577a.5.5 0 0 0-.374-.062", fill: "url(#mainNavDropDownIcon)" }), jsx("defs", { children: jsxs("linearGradient", { id: "mainNavDropDownIcon", x1: "9.502", y1: "5.994", x2: "2.502", y2: "5.994", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "rgb(var(--oui-gradient-brand-end))" }), jsx("stop", { offset: "1", stopColor: "rgb(var(--oui-gradient-brand-start))" })] }) })] }) : jsx(ht$4, { size: 12, color: "white" }) })] }), jsx(W$2, { invisible: !a2, position: "absolute", bottom: 0, left: "50%", height: "3px", r: "full", width: "60%", gradient: "brand", angle: 45, className: "-oui-translate-x-1/2 " })] });
  return Array.isArray(e2.item.children) ? jsx(vr$3, { items: e2.item.children, className: t == null ? void 0 : t.subMenu, current: (_a3 = e2.currentPath) == null ? void 0 : _a3[1], onItemClick: (d2) => {
    var _a4;
    (_a4 = e2.onClick) == null ? void 0 : _a4.call(e2, [e2.item, d2]);
  }, children: u2 }) : u2;
}, vr$3 = (e2) => {
  let [t, o2] = useState(false), n4 = useRef(null), i = useCallback(() => {
    n4.current && (clearTimeout(n4.current), n4.current = null);
  }, []), r3 = e2.children.props.className;
  return jsxs(It$3, { open: t, children: [jsx($r$3, { children: jsx("div", { className: "oui-group", "data-open": t, onMouseEnter: () => {
    o2(true);
  }, onMouseLeave: () => {
    n4.current = setTimeout(() => {
      o2(false);
    }, 150);
  }, children: cloneElement(e2.children, { className: cnBase(r3, t && "oui-bg-base-7") }) }) }), jsx(Vo$3, { align: "start", onMouseEnter: i, onMouseLeave: () => {
    o2(false), n4.current && clearTimeout(n4.current);
  }, className: cnBase("oui-w-[260px] oui-space-y-[2px] oui-border oui-border-line-6 oui-p-1", e2.className), children: e2.items.map((a2, s2) => jsx(xr$2, { item: a2, onClick: e2.onItemClick, active: a2.href === e2.current }, s2)) })] });
}, xr$2 = (e2) => {
  let { item: t } = e2;
  return jsxs(z$3, { px: 2, py: 3, gapX: 2, "data-active": e2.active ?? false, className: cnBase("oui-group oui-w-full oui-cursor-pointer oui-items-start oui-text-base-contrast-80 hover:oui-bg-base-6 data-[active=true]:oui-bg-base-5"), r: "md", onClick: () => {
    e2.onClick(t);
  }, "data-testid": t.testid, children: [!!e2.item.icon && jsx("div", { className: "oui-relative oui-size-6 oui-translate-y-1", children: jsx(wo$3, { isActive: e2.active ?? false, item: e2.item }) }), jsxs("div", { className: "oui-flex-1", children: [jsx(Cr$1, { item: t, isActive: e2.active }), typeof t.description < "u" && jsx(Q$1, { size: "2xs", as: "div", intensity: 36, children: t.description })] })] });
}, Cr$1 = (e2) => {
  let { item: { name: t }, isActive: o2 } = e2;
  return jsxs(z$3, { itemAlign: "center", width: "100%", position: "relative", children: [jsxs("div", { className: "oui-flex oui-flex-1", children: [jsx(Q$1.gradient, { color: o2 ? "brand" : "inherit", size: "xs", as: "div", intensity: 80, weight: "semibold", className: "oui-whitespace-nowrap oui-break-normal", children: t }), typeof e2.item.tag < "u" && jsx(wr, { item: e2.item })] }), e2.item.target === "_blank" && jsx(br$4, {})] });
}, wr = (e2) => jsx("div", { className: "oui-ml-1 oui-inline-flex oui-rounded oui-bg-gradient-to-r oui-from-[rgb(var(--oui-gradient-brand-start)_/_0.12)] oui-to-[rgb(var(--oui-gradient-brand-end)_/_0.12)] oui-px-2 oui-py-1", children: jsx(Q$1.gradient, { color: "brand", size: "3xs", className: "oui-whitespace-nowrap oui-break-normal", children: e2.item.tag }) }), vo$3 = "oui-flex oui-border oui-border-line oui-w-6 oui-h-6 oui-rounded-md oui-justify-center oui-items-center oui-absolute oui-left-0 oui-top-0", wo$3 = (e2) => {
  let { item: t, isActive: o2 } = e2;
  return e2.item.icon ? typeof e2.item.icon == "string" ? jsx("span", { className: "oui-mr-1 oui-size-[20px]", children: jsx("img", { src: o2 && e2.item.activeIcon || e2.item.icon, className: "oui-max-h-full oui-max-w-full" }) }) : jsxs(Fragment$1, { children: [jsx("div", { className: cnBase(vo$3, "group-hover:oui-invisible group-data-[active=true]:oui-invisible"), children: e2.item.icon }), jsx("div", { className: cnBase(vo$3, "oui-invisible group-hover:oui-visible group-data-[active=true]:oui-visible"), children: e2.item.activeIcon || e2.item.icon })] }) : null;
}, br$4 = () => jsxs(Fragment$1, { children: [jsx("svg", { width: "20", height: "20", viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg", className: "oui-absolute oui-right-0 oui-top-0 group-hover:oui-invisible", children: jsx("path", { d: "M14.159 17.492a3.333 3.333 0 0 0 3.333-3.333V5.826a3.333 3.333 0 0 0-3.333-3.334H5.826a3.333 3.333 0 0 0-3.334 3.334v8.333a3.333 3.333 0 0 0 3.334 3.333zm-6.667-4.166a.85.85 0 0 1-.599-.235.86.86 0 0 1 0-1.198l3.333-3.333-1.9-1.901h5v5l-1.901-1.9L8.09 13.09a.84.84 0 0 1-.599.235", fill: "#fff", fillOpacity: ".2" }) }), jsxs("svg", { width: "20", height: "20", viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg", className: "oui-invisible oui-absolute oui-right-0 oui-top-0 group-hover:oui-visible", children: [jsx("path", { d: "M14.159 17.492a3.333 3.333 0 0 0 3.333-3.333V5.826a3.333 3.333 0 0 0-3.333-3.334H5.826a3.333 3.333 0 0 0-3.334 3.334v8.333a3.333 3.333 0 0 0 3.334 3.333zm-6.667-4.166a.85.85 0 0 1-.599-.235.86.86 0 0 1 0-1.198l3.333-3.333-1.9-1.901h5v5l-1.901-1.9L8.09 13.09a.84.84 0 0 1-.599.235", fill: "url(#outlineIcon)" }), jsx("defs", { children: jsxs("linearGradient", { id: "outlineIcon", x1: "17.492", y1: "9.992", x2: "2.492", y2: "9.992", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "rgb(var(--oui-gradient-brand-end))" }), jsx("stop", { offset: "1", stopColor: "rgb(var(--oui-gradient-brand-start))" })] }) })] })] });
var So$3 = (e2) => jsxs(Fragment$1, { children: [jsx(ze$4, { item: e2.item, onClick: e2.onItemClick, classNames: { navItem: cnBase("oui-gradient-primary oui-text-white", e2.className) } }), jsx(de$5, { direction: "vertical", className: "oui-h-8", intensity: 8 })] });
var Ct$3 = 60;
function wt$3() {
  let [e2, t] = useState(false), [o2, n4] = useState(true), [i, r3] = useState(false), [a2, s2] = useState(Ct$3), [u2, d2] = useState(""), [p2, m2] = useState(""), v3 = useEventEmitter(), { track: g2 } = useTrack(), { state: b2, account: x2 } = useAccount(), [l2, { findByChainId: f2 }] = useChains(void 0, { pick: "network_infos", filter: (D2) => {
    var _a3, _b2;
    return ((_a3 = D2.network_infos) == null ? void 0 : _a3.bridge_enable) || ((_b2 = D2.network_infos) == null ? void 0 : _b2.bridgeless);
  } }), h2 = () => {
    var _a3;
    let D2 = f2(x2.chainId);
    return { wallet: (_a3 = b2 == null ? void 0 : b2.connectWallet) == null ? void 0 : _a3.name, network: D2 == null ? void 0 : D2.network_infos.name };
  }, S2 = useCallback(async () => {
    try {
      let D2 = await x2.createApiKey(30);
      d2(D2.secretKey), n4(false), g2(TrackerEventName.signLinkDeviceMessageSuccess, h2());
    } catch (D2) {
      D2 instanceof Error && D2.message.indexOf("Signing off chain messages with Ledger is not yet supported") !== -1 && v3.emit("wallet:sign-message-with-ledger-error", { message: D2.message, userAddress: x2.address }), E3();
    }
  }, [x2]), B2 = useCallback(() => {
    t(true), S2(), g2(TrackerEventName.clickLinkDeviceButton, h2());
  }, [x2]), E3 = useCallback(() => {
    t(false);
  }, []), Dn2 = useCallback(() => {
    r3(true), g2(TrackerEventName.linkDeviceModalClickConfirm, {});
  }, []), Fn2 = useCallback(() => {
    navigator.clipboard.writeText(p2);
  }, [p2]);
  return useEffect(() => {
    e2 || (r3(false), n4(true), s2(Ct$3), d2(""), m2(""));
  }, [e2]), useEffect(() => {
    if (a2 === 0) {
      E3();
      return;
    }
    if (!i) return;
    let D2 = setTimeout(() => {
      s2(a2 - 1);
    }, 1e3);
    return () => clearTimeout(D2);
  }, [a2, i]), useEffect(() => {
    var _a3;
    if (i && u2) {
      let D2 = Math.floor(Date.now() / 1e3) + Ct$3, Vn2 = { k: u2, t: D2, a: x2.address, i: x2.chainId, n: (_a3 = x2.walletAdapter) == null ? void 0 : _a3.chainNamespace }, Bn2 = Lr$2(Vn2);
      m2(Bn2);
    }
  }, [i, u2]), { open: e2, onOpenChange: t, showDialog: B2, hideDialog: E3, loading: o2, seconds: a2, confirm: i, onConfirm: Dn2, url: p2, copyUrl: Fn2 };
}
function Lr$2(e2) {
  let t = JSON.stringify(e2), o2 = window.btoa(t);
  return `${window.location.origin}?link=${o2}`;
}
var We$6 = ze__default__default.forwardRef((e2, t) => {
  let { size: o2 = 20, ...n4 } = e2;
  return jsx("svg", { width: o2, height: o2, viewBox: "0 0 20 20", ref: t, fill: "#fff", fillOpacity: ".54", xmlns: "http://www.w3.org/2000/svg", ...n4, children: jsx("path", { d: "M4.108 9.464S9.645 7.13 11.565 6.31c.736-.328 3.233-1.38 3.233-1.38s1.152-.46 1.056.658c-.032.46-.288 2.069-.544 3.81-.384 2.463-.8 5.157-.8 5.157s-.064.755-.608.887c-.544.13-1.44-.46-1.6-.592-.129-.098-2.401-1.576-3.233-2.299-.224-.197-.48-.591.032-1.051a124 124 0 0 0 3.36-3.285c.384-.394.768-1.313-.832-.197-2.272 1.61-4.513 3.12-4.513 3.12s-.512.33-1.472.034-2.08-.69-2.08-.69-.768-.493.544-1.018" }) });
}), _e$4 = ze__default__default.forwardRef((e2, t) => {
  let { size: o2 = 20, ...n4 } = e2;
  return jsx("svg", { width: o2, height: o2, viewBox: "0 0 20 20", ref: t, fill: "#fff", fillOpacity: ".54", ...n4, xmlns: "http://www.w3.org/2000/svg", children: jsx("path", { d: "M14.956 5.522c1.604 2.374 2.396 5.053 2.1 8.136a.05.05 0 0 1-.02.033 11.7 11.7 0 0 1-3.55 1.805.045.045 0 0 1-.05-.017 9.6 9.6 0 0 1-.725-1.188.046.046 0 0 1 .024-.063 7 7 0 0 0 1.108-.531.046.046 0 0 0 .004-.076 6 6 0 0 1-.22-.174.04.04 0 0 0-.047-.006c-2.296 1.068-4.812 1.068-7.136 0a.04.04 0 0 0-.046.006 6 6 0 0 1-.22.174.046.046 0 0 0 .005.076c.353.204.721.384 1.107.531.025.01.037.039.025.063a8.5 8.5 0 0 1-.725 1.188.05.05 0 0 1-.05.017 11.7 11.7 0 0 1-3.546-1.805.05.05 0 0 1-.018-.033c-.248-2.667.257-5.368 2.097-8.137a.04.04 0 0 1 .02-.016 11.6 11.6 0 0 1 2.89-.903.05.05 0 0 1 .046.022c.125.224.269.51.366.744a10.7 10.7 0 0 1 3.246 0 8 8 0 0 1 .36-.744.044.044 0 0 1 .046-.022 11.7 11.7 0 0 1 2.89.903q.012.005.019.017m-6.018 5.07c.011-.788-.56-1.44-1.276-1.44-.71 0-1.276.647-1.276 1.44 0 .795.576 1.442 1.276 1.442.71 0 1.276-.647 1.276-1.441m4.718 0c.011-.788-.56-1.44-1.276-1.44-.71 0-1.276.647-1.276 1.44 0 .795.577 1.442 1.276 1.442.717 0 1.276-.647 1.276-1.441" }) });
}), Ge$1 = ze__default__default.forwardRef((e2, t) => {
  let { size: o2 = 20, ...n4 } = e2;
  return jsx("svg", { width: o2, height: o2, viewBox: "0 0 20 20", ref: t, fill: "#fff", fillOpacity: ".54", xmlns: "http://www.w3.org/2000/svg", ...n4, children: jsx("path", { d: "m4.42 4.73 4.633 6.194-4.662 5.037H5.44l4.082-4.41 3.298 4.41h3.57l-4.893-6.543 4.34-4.689h-1.05l-3.759 4.062-3.037-4.062zm1.543.772h1.64l7.244 9.686h-1.64z" }) });
});
Ge$1.displayName = "CommuntiyXIcon";
We$6.displayName = "CommuntiyTelegramIcon";
_e$4.displayName = "CommuntiyDiscordIcon";
var yt$4 = ze__default__default.forwardRef((e2, t) => {
  let { opacity: o2 = 1, ...n4 } = e2;
  return jsxs("svg", { ref: t, width: "45", height: "14", viewBox: "0 0 45 14", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...n4, children: [jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M8.352 2.558a.063.063 0 0 1-.04.112H2.419a.063.063 0 0 1-.04-.112A4.73 4.73 0 0 1 5.365 1.5c1.132 0 2.171.396 2.987 1.058M3.518 7.546a.18.18 0 0 0-.148-.08H.886a.085.085 0 0 0-.083.11 4.75 4.75 0 0 0 4.562 3.429 4.75 4.75 0 0 0 4.562-3.43.085.085 0 0 0-.082-.108H7.36a.18.18 0 0 0-.148.079 2.252 2.252 0 0 1-3.694 0m3.518-2.812a.18.18 0 0 0 .134.061h2.598c.06 0 .101-.057.082-.113a4.8 4.8 0 0 0-.801-1.432.17.17 0 0 0-.132-.062H1.814a.17.17 0 0 0-.132.062A4.8 4.8 0 0 0 .88 4.682a.085.085 0 0 0 .081.113h2.6c.05 0 .099-.023.133-.06a2.25 2.25 0 0 1 1.67-.742c.663 0 1.258.286 1.67.741M7.6 6.95a.067.067 0 0 1-.063-.086 2.26 2.26 0 0 0-.079-1.45.067.067 0 0 1 .061-.093h2.45c.03 0 .058.022.063.052a4.8 4.8 0 0 1 .04 1.52.064.064 0 0 1-.065.057zm-4.407-.086a.067.067 0 0 1-.063.086H.723a.064.064 0 0 1-.064-.056 4.8 4.8 0 0 1 .039-1.52.065.065 0 0 1 .063-.053h2.45c.047 0 .079.049.061.093a2.25 2.25 0 0 0-.079 1.45", fill: "#fff", fillOpacity: o2 }), jsx("path", { d: "M11.272 4.438h1.685v1.61l-.275-.312q.237-.511.662-.874.425-.361.949-.487.524-.124 1.073.038v1.585q-.661-.224-1.223-.125-.55.1-.874.475-.312.375-.312.923v3.608h-1.685zm4.148 3.22q0-.923.4-1.697.41-.774 1.123-1.211a2.95 2.95 0 0 1 1.573-.437 2.7 2.7 0 0 1 1.523.437 2.8 2.8 0 0 1 1.01 1.198q.363.762.363 1.71 0 .95-.362 1.71-.35.762-1.011 1.199a2.7 2.7 0 0 1-1.523.437 2.95 2.95 0 0 1-1.573-.437 3.1 3.1 0 0 1-1.124-1.198 3.7 3.7 0 0 1-.4-1.71m1.748 0q0 .5.224.924.225.412.612.65.387.236.861.236.475 0 .862-.237.386-.237.611-.649.225-.424.225-.924 0-.498-.225-.91-.225-.425-.611-.65a1.6 1.6 0 0 0-.862-.237q-.474 0-.861.237a1.6 1.6 0 0 0-.612.65q-.224.412-.224.91m3.395-6.016h1.685v9.237h-1.685zm4.192 5.329h3.97l-.387.537a2 2 0 0 0-.25-.9 1.63 1.63 0 0 0-.612-.623 1.64 1.64 0 0 0-.861-.225q-.487 0-.886.25a1.6 1.6 0 0 0-.625.686 2.1 2.1 0 0 0-.224.961q0 .537.224.974.239.436.662.687.425.25.961.25.525 0 .937-.238.423-.25.661-.674l1.386.624q-.45.787-1.236 1.26-.786.463-1.798.463-.96 0-1.747-.437a3.3 3.3 0 0 1-1.248-1.198 3.34 3.34 0 0 1-.45-1.71q0-.924.437-1.686.45-.775 1.223-1.21.774-.45 1.723-.45 1.061 0 1.885.537.825.536 1.21 1.448.4.898.226 1.96h-5.181zm6.221-2.534h1.685v1.61l-.274-.312q.237-.511.661-.874.425-.361.949-.487.525-.124 1.073.038v1.585q-.661-.224-1.223-.125-.549.1-.874.475-.312.375-.312.923v3.608h-1.685zm4.885-2.796h1.686v9.237H35.86zm4.359 9.324q.224.487.587.737.362.262.836.262.711 0 1.186-.5.487-.486.487-1.26V9.08l.262.35a2.43 2.43 0 0 1-.911 1.011q-.6.362-1.373.362-.8 0-1.386-.337a2.3 2.3 0 0 1-.886-.936q-.312-.6-.312-1.386V4.438h1.685v3.408q0 .436.162.761.162.312.462.5.312.174.761.174.45 0 .8-.175a1.3 1.3 0 0 0 .549-.511q.187-.338.187-.75V4.439H45v5.767q0 .936-.45 1.685a3.07 3.07 0 0 1-1.21 1.186 3.4 3.4 0 0 1-1.698.424q-.973 0-1.735-.474a3.3 3.3 0 0 1-1.186-1.26z", fill: "#fff", fillOpacity: o2 })] });
});
var Ue$4 = ze__default__default.forwardRef((e2, t) => {
  let { size: o2 = 18, ...n4 } = e2;
  return jsx("svg", { width: o2, height: o2, viewBox: "0 0 18 18", ref: t, className: "oui-fill-success-light", xmlns: "http://www.w3.org/2000/svg", ...n4, children: jsx("path", { d: "M9.02092 2.92969C6.18562 2.92969 3.51037 4.13854 1.68502 6.18754C1.40947 6.49676 1.446 6.96671 1.75537 7.24218C2.0646 7.51743 2.53447 7.48143 2.81002 7.17183C4.35112 5.44196 6.6141 4.42969 9.02092 4.42969C11.4205 4.42969 13.6369 5.43123 15.185 7.17183C15.4603 7.48143 15.9301 7.51743 16.2397 7.24218C16.5492 6.96694 16.5853 6.49699 16.31 6.18754C14.4787 4.12856 11.8512 2.92969 9.02092 2.92969ZM9.02092 5.92969C7.04092 5.92969 5.20867 6.78461 3.93502 8.25019C3.6633 8.56294 3.6927 9.03318 4.00537 9.30468C4.31797 9.57618 4.7883 9.54693 5.06002 9.23418C6.05175 8.09343 7.47982 7.42968 9.02092 7.42968C10.5348 7.42968 11.9446 8.08144 12.935 9.18769C13.2113 9.49593 13.681 9.51093 13.9897 9.23418C14.2983 8.95818 14.3364 8.48793 14.06 8.17968C12.7879 6.75896 10.9659 5.92969 9.02092 5.92969ZM9.02092 8.92968C7.91917 8.92968 6.89242 9.40218 6.18502 10.2189C5.91375 10.5317 5.94225 11.0019 6.25537 11.2734C6.56835 11.5449 7.03875 11.5164 7.31002 11.2029C7.73542 10.7124 8.3589 10.4297 9.02092 10.4297C9.6684 10.4297 10.2604 10.7072 10.685 11.1797C10.962 11.4879 11.4552 11.5037 11.7631 11.2262C12.0712 10.9494 12.087 10.4799 11.81 10.1717C11.1037 9.38643 10.0983 8.92968 9.02092 8.92968ZM8.99752 11.9297C8.81609 11.9297 8.64374 12.0047 8.50537 12.1404C8.50537 12.1404 7.3935 13.2362 6.95842 13.6637C6.52342 14.0919 6.7968 14.9319 7.49752 14.9297H9.63037H10.4975C11.1864 14.9319 11.477 14.0739 11.0366 13.6404C10.5961 13.2069 9.51322 12.1404 9.51314 12.1404C9.37469 12.0047 9.17894 11.9297 8.99752 11.9297Z" }) });
});
Ue$4.displayName = "SignalIcon";
var we$4 = (e2) => {
  let { size: t = 20, viewBox: o2, ...n4 } = e2;
  return jsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: `${t}px`, height: `${t}px`, fill: "none", viewBox: "0 0 20 20", ...n4, children: jsx("path", { d: "M10.012 1.66602C5.40954 1.66602 1.67871 5.39685 1.67871 9.99935C1.67871 14.6018 5.40954 18.3327 10.012 18.3327C14.6145 18.3327 18.3454 14.6018 18.3454 9.99935C18.3454 5.39685 14.6145 1.66602 10.012 1.66602ZM10.012 5.83268C10.472 5.83268 10.8454 6.20602 10.8454 6.66602V10.8327C10.8454 11.2927 10.472 11.666 10.012 11.666C9.55204 11.666 9.17871 11.2927 9.17871 10.8327V6.66602C9.17871 6.20602 9.55204 5.83268 10.012 5.83268ZM10.012 12.4993C10.472 12.4993 10.8454 12.8727 10.8454 13.3327C10.8454 13.7927 10.472 14.166 10.012 14.166C9.55204 14.166 9.17871 13.7927 9.17871 13.3327C9.17871 12.8727 9.55204 12.4993 10.012 12.4993Z", fill: "#FF7D00" }) });
};
var se$1 = (e2) => {
  let { size: t = 16, ...o2 } = e2;
  return jsx("svg", { width: `${t}px`, height: `${t}px`, viewBox: "0 0 16 16", xmlns: "http://www.w3.org/2000/svg", ...o2, children: jsx("path", { d: "M3.32972 2.60449C3.15912 2.60449 2.98072 2.66183 2.85052 2.79183C2.59019 3.0525 2.59019 3.48982 2.85052 3.75049L7.03806 7.93782L2.85052 12.1252C2.59019 12.3858 2.59019 12.8232 2.85052 13.0838C3.11092 13.3438 3.54852 13.3438 3.80892 13.0838L7.99639 8.89649L12.1839 13.0838C12.4443 13.3438 12.8819 13.3438 13.1423 13.0838C13.4026 12.8232 13.4026 12.3858 13.1423 12.1252L8.95472 7.93782L13.1423 3.75049C13.4026 3.48982 13.4026 3.0525 13.1423 2.79183C13.0121 2.66183 12.8336 2.60449 12.6631 2.60449C12.4925 2.60449 12.3141 2.66183 12.1839 2.79183L7.99639 6.97916L3.80892 2.79183C3.67872 2.66183 3.50032 2.60449 3.32972 2.60449Z", fill: "currentColor" }) });
};
var St$4 = (e2) => jsxs("svg", { width: "200", height: "24", viewBox: "0 0 200 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...e2, children: [jsx("path", { d: "M22.2637 18.5152H26.1444V13.3629C26.1444 10.2669 27.9664 9.39239 29.6701 9.39239C29.9777 9.39239 30.2617 9.41602 30.6639 9.46329V6.20176C30.2853 6.10722 29.9777 6.08359 29.7174 6.08359C27.8481 6.08359 26.6886 7.3362 26.2153 9.27421H26.1444V6.22539H22.2637V18.5152Z", fill: "white" }), jsx("path", { d: "M37.3191 18.7516C39.1411 18.7516 40.3952 17.7826 40.7265 16.8608V18.5152H44.6072V1.97122H40.7265V7.87979C40.3952 6.95806 39.1411 5.98905 37.3191 5.98905C34.8108 5.98905 31.9713 7.83252 31.9713 12.3703C31.9713 16.9317 34.8108 18.7516 37.3191 18.7516ZM35.6153 12.3703C35.6153 10.196 36.9168 9.20331 38.2892 9.20331C39.638 9.20331 40.8921 10.196 40.8921 12.3703C40.8921 14.5447 39.638 15.5373 38.2892 15.5373C36.9168 15.5373 35.6153 14.5447 35.6153 12.3703Z", fill: "white" }), jsx("path", { d: "M53.418 18.7516C56.4468 18.7516 58.6475 17.1917 59.2154 14.3556H55.8079C55.595 15.1592 55.0744 15.8209 53.489 15.8209C51.9746 15.8209 51.0281 15.1355 50.8151 13.3393H59.31C59.3573 13.0557 59.381 12.8194 59.381 12.3703C59.381 7.57255 56.5888 5.98905 53.418 5.98905C50.1289 5.98905 47.1474 7.73799 47.1474 12.323C47.1474 17.0972 50.3655 18.7516 53.418 18.7516ZM50.8388 11.0941C51.0754 9.676 51.8799 8.9197 53.3234 8.9197C55.0981 8.9197 55.6423 10.0305 55.7133 11.0941H50.8388Z", fill: "white" }), jsx("path", { d: "M61.8978 18.5152H65.7784V13.3629C65.7784 10.2669 67.6005 9.39239 69.3042 9.39239C69.6118 9.39239 69.8957 9.41602 70.298 9.46329V6.20176C69.9194 6.10722 69.6118 6.08359 69.3515 6.08359C67.4821 6.08359 66.3227 7.3362 65.8494 9.27421H65.7784V6.22539H61.8978V18.5152Z", fill: "white" }), jsx("path", { d: "M72.5672 18.5152H76.4479V1.97122H72.5672V18.5152Z", fill: "white" }), jsx("path", { d: "M79.8261 20.0278V23.2893C83.6358 23.6911 85.2212 22.4149 86.8776 18.3734L91.8468 6.22539H87.8714L85.1739 13.5757L82.5473 6.22539H78.5957L83.0679 17.2626C83.3755 17.9953 83.3992 18.3734 83.1389 18.9643C82.9259 19.437 82.3817 20.3587 79.8261 20.0278Z", fill: "white" }), jsx("path", { d: "M100.278 18.5152H104.229V8.63609H104.324L110.287 18.5152H114.546V1.97122H110.571V12.1103H110.476L104.371 1.97122H100.278V18.5152Z", fill: "white" }), jsx("path", { d: "M123.327 18.7516C126.356 18.7516 128.557 17.1917 129.125 14.3556H125.717C125.504 15.1592 124.984 15.8209 123.398 15.8209C121.884 15.8209 120.937 15.1355 120.724 13.3393H129.219C129.267 13.0557 129.29 12.8194 129.29 12.3703C129.29 7.57255 126.498 5.98905 123.327 5.98905C120.038 5.98905 117.057 7.73799 117.057 12.323C117.057 17.0972 120.275 18.7516 123.327 18.7516ZM120.748 11.0941C120.985 9.676 121.789 8.9197 123.233 8.9197C125.007 8.9197 125.552 10.0305 125.623 11.0941H120.748Z", fill: "white" }), jsx("path", { d: "M137.439 18.6807C138.172 18.6807 138.882 18.5861 139.474 18.4207V15.5609C138.93 15.6082 138.717 15.6082 138.456 15.6082C137.202 15.6082 136.966 14.9228 136.966 14.072V9.22695H139.379V6.22539H136.966V3.01113H133.085V6.22539H130.979V9.22695H133.085V14.6156C133.085 17.4753 134.789 18.6807 137.439 18.6807Z", fill: "white" }), jsx("path", { d: "M144.456 18.5152H148.833L150.797 11.3777L152.761 18.5152H157.115L160.333 6.22539H156.666L154.749 14.781H154.654L152.454 6.22539H149.117L146.917 14.781H146.822L144.905 6.22539H141.261L144.456 18.5152Z", fill: "white" }), jsx("path", { d: "M167.796 18.7516C170.896 18.7516 174.043 16.8845 174.043 12.3703C174.043 7.85616 170.896 5.98905 167.796 5.98905C164.673 5.98905 161.549 7.85616 161.549 12.3703C161.549 16.8845 164.673 18.7516 167.796 18.7516ZM165.169 12.3703C165.169 10.196 166.282 9.20331 167.796 9.20331C169.287 9.20331 170.399 10.196 170.399 12.3703C170.399 14.5447 169.287 15.5373 167.796 15.5373C166.282 15.5373 165.169 14.5447 165.169 12.3703Z", fill: "white" }), jsx("path", { d: "M176.554 18.5152H180.434V13.3629C180.434 10.2669 182.256 9.39239 183.96 9.39239C184.268 9.39239 184.552 9.41602 184.954 9.46329V6.20176C184.575 6.10722 184.268 6.08359 184.007 6.08359C182.138 6.08359 180.979 7.3362 180.505 9.27421H180.434V6.22539H176.554V18.5152Z", fill: "white" }), jsx("path", { d: "M187.223 18.5152H191.104V14.9701L192.074 13.9302L195.742 18.5152H200.001L194.44 11.4249L199.362 6.22539H195.126L191.104 10.8104V1.97122H187.223V18.5152Z", fill: "white" }), jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M9.66235 0.640167L9.70838 0.640167C12.1367 0.64581 14.355 1.54403 16.052 3.02375C16.1722 3.1286 16.0961 3.32102 15.9365 3.32102L3.43427 3.32102C3.27465 3.32102 3.1985 3.1286 3.31874 3.02375C5.01571 1.54403 7.23406 0.645809 9.66235 0.640167Z", fill: "white" }), jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M5.9175 12.9472C5.84821 12.8485 5.73663 12.7865 5.61594 12.7865L0.606422 12.7865C0.461299 12.7865 0.355489 12.924 0.39667 13.063C1.58273 17.0661 5.29234 19.9869 9.68495 19.9869C14.0776 19.9869 17.7872 17.0661 18.9732 13.063C19.0144 12.924 18.9086 12.7865 18.7635 12.7865L13.754 12.7865C13.6333 12.7865 13.5218 12.8485 13.4525 12.9472C12.6208 14.1317 11.2434 14.9061 9.68499 14.9061C8.12654 14.9061 6.74917 14.1317 5.9175 12.9472Z", fill: "white" }), jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M13.3322 7.51577C13.4208 7.63078 13.5556 7.7029 13.7009 7.7029L18.7216 7.7029C18.868 7.7029 18.9741 7.56325 18.9304 7.42361C18.551 6.2113 17.9392 5.10154 17.147 4.14637C17.0811 4.06686 16.9826 4.02197 16.8792 4.02197L2.4903 4.02197C2.38694 4.02197 2.28845 4.06686 2.22251 4.14637C1.43037 5.10153 0.818541 6.2113 0.439134 7.42361C0.395431 7.56325 0.501494 7.7029 0.647976 7.7029L5.66868 7.7029C5.81394 7.7029 5.9488 7.63078 6.03735 7.51577C6.87801 6.42387 8.19911 5.72017 9.68478 5.72017C11.1704 5.72017 12.4916 6.42387 13.3322 7.51577Z", fill: "white" }), jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M14.1283 12.0868C14.0334 12.0868 13.969 11.9902 14.0018 11.9013C14.184 11.4069 14.2835 10.8724 14.2835 10.3148C14.2835 9.70687 14.1652 9.12653 13.9505 8.59547C13.9142 8.50592 13.9788 8.40582 14.0755 8.40582L19.0003 8.40582C19.1057 8.40582 19.1968 8.48012 19.2156 8.58377C19.3172 9.14546 19.3702 9.72401 19.3702 10.3149C19.3702 10.8567 19.3256 11.3881 19.2399 11.9057C19.2225 12.0108 19.1307 12.0868 19.0241 12.0868L14.1283 12.0868ZM5.36846 11.9013C5.40122 11.9902 5.33678 12.0868 5.24195 12.0868L0.346163 12.0868C0.239492 12.0868 0.147732 12.0108 0.130321 11.9057C0.0445957 11.3881 0 10.8567 0 10.3149C0 9.72401 0.0530502 9.14546 0.154653 8.58377C0.173403 8.48011 0.264481 8.40582 0.369941 8.40582L5.29476 8.40582C5.39146 8.40582 5.45599 8.50592 5.41977 8.59547C5.20498 9.12653 5.08673 9.70687 5.08673 10.3148C5.08673 10.8724 5.18623 11.4069 5.36846 11.9013Z", fill: "white" })] });
var U$2 = (e2) => {
  let { appIcons: t } = or$3();
  if (e2.src) return jsx(Ds, { src: e2.src, alt: e2.alt });
  let { main: o2 } = t || {};
  return (o2 == null ? void 0 : o2.img) ? jsx("img", { src: o2 == null ? void 0 : o2.img }) : (o2 == null ? void 0 : o2.component) ? o2.component : jsx(St$4, {});
};
var Mt$3 = (e2) => {
  let { t } = ne$6();
  return jsxs(Fragment$1, { children: [jsx(Zr, { className: "oui-text-base-contrast-80 oui-cursor-pointer", onClick: e2.showDialog }), jsx(Se$5, { title: jsx(Q$1, { weight: "semibold", children: t("common.confirm") }), open: e2.open, onOpenChange: e2.onOpenChange, size: "sm", contentProps: { onInteractOutside: (o2) => {
    document.querySelector("#privy-dialog") && o2.preventDefault();
  } }, children: jsx(ko$2, { ...e2 }) })] });
}, ko$2 = (e2) => e2.loading ? jsx(Kr$3, {}) : e2.confirm ? jsx(_r$1, { hideDialog: e2.hideDialog, seconds: e2.seconds, url: e2.url, copyUrl: e2.copyUrl }) : jsx(Ur$1, { hideDialog: e2.hideDialog, onConfirm: e2.onConfirm }), _r$1 = (e2) => {
  let { t } = ne$6(), o2 = { primary: { label: t("common.ok"), onClick: e2.hideDialog, size: "md" } };
  return jsxs(z$3, { direction: "column", gapY: 3, children: [jsx(Q$1, { size: "base", intensity: 98, children: t("linkDevice.scanQRCode") }), jsx(Q$1, { size: "2xs", intensity: 54, weight: "regular", className: "oui-text-center", children: jsx(Trans, { i18nKey: "linkDevice.createQRCode.success.description" }) }), jsxs(Q$1, { size: "sm", intensity: 54, children: [`${t("common.countdown")}: `, jsxs(Q$1.gradient, { color: "brand", className: "oui-tabular-nums", children: [e2.seconds, "s"] })] }), jsx(z$3, { className: cnBase("oui-w-[240px] oui-h-[240px] ", "oui-border oui-border-base-contrast-20 oui-rounded-2xl"), justify: "center", itemAlign: "center", children: jsx(z$3, { className: "oui-w-[220px] oui-h-[220px] oui-rounded-lg oui-bg-white", justify: "center", itemAlign: "center", children: jsx(Gr$3, { width: 196, height: 196, content: e2.url }) }) }), jsxs(z$3, { direction: "row", gap: 1, className: cnBase("oui-cursor-pointer", "oui-group oui-text-base-contrast-54 hover:oui-text-base-contrast"), onClick: e2.copyUrl, children: [jsx(bt$5, { size: 16, opacity: 1, className: "oui-text-base-contrast-54 group-hover:oui-text-base-contrast" }), jsx(Q$1, { size: "2xs", weight: "regular", children: t("linkDevice.createQRCode.success.copyUrl") })] }), jsx(rt$2, { actions: o2, className: "oui-w-full oui-p-0 !oui-pt-8" })] });
}, Gr$3 = (e2) => {
  let t = useRef(null);
  return useEffect(() => {
    if (!t.current || !e2.content) return;
    let o2 = qrcode(e2.content), n4 = e2.width, i = e2.height, r3 = t.current.getContext("2d"), a2 = o2.modules, s2 = n4 / a2.length, u2 = i / a2.length;
    for (let d2 = 0; d2 < a2.length; ++d2) {
      let p2 = a2[d2];
      for (let m2 = 0; m2 < p2.length; ++m2) {
        r3.fillStyle = p2[m2] ? "#000" : "#fff";
        let v3 = Math.ceil((m2 + 1) * s2) - Math.floor(m2 * s2), g2 = Math.ceil((d2 + 1) * u2) - Math.floor(d2 * u2);
        r3.fillRect(Math.round(m2 * s2), Math.round(d2 * u2), v3, g2);
      }
    }
  }, [t, e2.content]), jsx("canvas", { width: e2.width, height: e2.height, ref: t });
}, Ur$1 = (e2) => {
  let { t } = ne$6(), o2 = { secondary: { label: t("common.cancel"), onClick: e2.hideDialog, className: "oui-flex-1", size: "md" }, primary: { label: t("common.confirm"), onClick: e2.onConfirm, className: "oui-flex-1", size: "md" } };
  return jsxs(z$3, { direction: "column", children: [jsx(U$2, {}), jsx(Q$1, { size: "base", intensity: 98, className: "oui-mt-5", children: t("linkDevice.createQRCode.linkMobileDevice") }), jsx(Q$1, { size: "2xs", intensity: 54, weight: "regular", className: "oui-text-center oui-mt-3", children: jsx(Trans, { i18nKey: "linkDevice.createQRCode.linkMobileDevice.description", values: { hostname: window.location.hostname } }) }), jsx(rt$2, { actions: o2, className: "oui-w-full oui-p-0 !oui-pt-8" })] });
}, Kr$3 = () => {
  let { t: e2 } = ne$6();
  return jsxs(z$3, { direction: "column", gap: 5, children: [jsx(Qr$2, {}), jsx(Q$1, { size: "sm", intensity: 98, children: e2("linkDevice.createQRCode.loading.description") })] });
}, Qr$2 = () => jsxs("svg", { width: "80", height: "80", viewBox: "0 0 80 80", fill: "none", xmlns: "http://www.w3.org/2000/svg", className: "oui-animate-spin", children: [jsx("path", { d: "M11.4858 52.1631C10.4698 52.5965 9.28872 52.1259 8.91766 51.0855C7.68926 47.6412 7.04029 44.0121 7.00182 40.3463C6.95634 36.0129 7.76483 31.713 9.38113 27.6921C10.9974 23.6712 13.3899 20.0079 16.4219 16.9116C18.9868 14.2923 21.967 12.122 25.2375 10.4861C26.2253 9.99202 27.4035 10.4698 27.8369 11.4858L28.8571 13.8773C29.2904 14.8933 28.8139 16.0615 27.8336 16.5706C25.3569 17.8567 23.0959 19.5294 21.1375 21.5293C18.7119 24.0064 16.7979 26.9369 15.5049 30.1537C14.2119 33.3704 13.5651 36.8103 13.6015 40.277C13.6308 43.076 14.1051 45.8482 15.0026 48.4906C15.3579 49.5365 14.8933 50.7096 13.8773 51.143L11.4858 52.1631Z", fill: "url(#paint0_linear_177_6754)" }), jsx("path", { d: "M73 40C73 58.2254 58.2254 73 40 73C21.7746 73 7 58.2254 7 40C7 21.7746 21.7746 7 40 7C58.2254 7 73 21.7746 73 40ZM13.6 40C13.6 54.5803 25.4197 66.4 40 66.4C54.5803 66.4 66.4 54.5803 66.4 40C66.4 25.4197 54.5803 13.6 40 13.6C25.4197 13.6 13.6 25.4197 13.6 40Z", fill: "white", fillOpacity: "0.06" }), jsx("defs", { children: jsxs("linearGradient", { id: "paint0_linear_177_6754", x1: "73", y1: "40", x2: "7", y2: "40", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "rgb(var(--oui-gradient-brand-end))" }), jsx("stop", { offset: "1", stopColor: "rgb(var(--oui-gradient-brand-start))" })] }) })] }), Zr = (e2) => {
  let { size: t = 20, viewBox: o2, ...n4 } = e2;
  return jsxs("svg", { width: t, height: t, viewBox: "0 0 20 20", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...n4, children: [jsx("path", { d: "M19.167 7.583a1.74 1.74 0 0 0-1.731-1.75h-4.038a1.74 1.74 0 0 0-1.731 1.75v8.167c0 .967.775 1.75 1.73 1.75h4.039a1.74 1.74 0 0 0 1.73-1.75zm-1.154 0v7.584H12.82V7.583A.58.58 0 0 1 13.398 7h4.038a.58.58 0 0 1 .577.583m-2.02 8.75a.58.58 0 0 1-.576.584.58.58 0 0 1-.577-.584.58.58 0 0 1 .577-.583.58.58 0 0 1 .577.583" }), jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M1.666 5a2.5 2.5 0 0 1 2.5-2.5h10a2.5 2.5 0 0 1 2.5 2.5.08.08 0 0 1-.078.078h-1.51a.08.08 0 0 1-.08-.078.834.834 0 0 0-.833-.833h-10A.834.834 0 0 0 3.333 5v5.633c0 .11.09.2.2.2h7.1c.11 0 .2.09.2.2V12.3a.2.2 0 0 1-.2.2H2.7a.2.2 0 0 0-.2.2v.633c0 .511.308.834.834.834h7.3c.11 0 .2.09.2.2v1.266a.2.2 0 0 1-.2.2h-7.3c-1.465 0-2.5-1.086-2.5-2.5v-1.666c0-.392.27-.72.635-.81.107-.026.198-.113.198-.224z" })] });
};
var Fo$2 = (e2) => {
  let [t, o2] = useState(false), { account: n4 } = useAccount(), { t: i } = ne$6(), r3 = async () => {
    localStorage.removeItem("orderly_link_device"), await n4.disconnect();
  }, a2 = () => {
    o2(true);
  }, s2 = () => {
    o2(false);
  };
  return jsxs(Fragment$1, { children: [jsx(Se$5, { open: t, onOpenChange: o2, title: i("common.tips"), size: "xs", actions: { secondary: { label: i("common.cancel"), onClick: s2, size: "md", fullWidth: true }, primary: { label: i("connector.disconnect"), onClick: async () => {
    await r3(), s2();
  }, size: "md", variant: "outlined", color: "danger" } }, children: jsx(Q$1, { intensity: 54, size: "sm", children: i("linkDevice.scanQRCode.connected.description") }) }), jsxs(z$3, { className: "oui-text-base-contrast oui-px-[6px]", intensity: 500, height: 28, r: "md", onClick: a2, children: [jsx(ea$1, {}), jsx(Ao$4, {}), jsx(oa$1, {}), jsx(Ao$4, {}), jsx(ta$2, {})] })] });
}, Ao$4 = () => jsxs(z$3, { className: "oui-gap-x-[1px] oui-px-[1px]", children: [jsx(It$2, {}), jsx(It$2, {}), jsx(It$2, {})] }), ea$1 = (e2) => jsx("svg", { width: "18", height: "18", viewBox: "0 0 18 18", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...e2, children: jsx("path", { d: "M4.5 2.93a2.25 2.25 0 0 0-2.25 2.25v5.25a.75.75 0 0 0-.75.75v1.5c0 1.272.93 2.25 2.25 2.25h10.5c1.318 0 2.25-.978 2.25-2.25v-1.5a.75.75 0 0 0-.75-.75V5.18a2.25 2.25 0 0 0-2.25-2.25zm0 1.5h9a.75.75 0 0 1 .75.75v5.25H3.75V5.18a.75.75 0 0 1 .75-.75M3 11.93h12v.75c0 .46-.277.75-.75.75H3.75c-.474 0-.75-.29-.75-.75z" }) }), ta$2 = (e2) => jsx("svg", { width: "18", height: "18", viewBox: "0 0 18 18", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...e2, children: jsx("path", { d: "M13.498 3.715a2.25 2.25 0 0 0-2.25-2.25h-4.5a2.25 2.25 0 0 0-2.25 2.25v10.5a2.25 2.25 0 0 0 2.25 2.25h4.5a2.25 2.25 0 0 0 2.25-2.25zm-1.5 0v9.75h-6v-9.75a.75.75 0 0 1 .75-.75h4.5a.75.75 0 0 1 .75.75m-2.25 11.25a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0" }) }), oa$1 = (e2) => jsxs("svg", { width: "12", height: "12", viewBox: "0 0 12 12", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M1.007 6a5 5 0 1 1 10 0 5 5 0 0 1-10 0m7.486-2.344A.6.6 0 0 1 8.91 3.5c.15 0 .305.048.418.156a.55.55 0 0 1 0 .798L5.254 8.337a.62.62 0 0 1-.837 0L2.67 6.673a.55.55 0 0 1 0-.798.62.62 0 0 1 .837 0l1.329 1.266z", fill: "url(#a)" }), jsx("defs", { children: jsxs("linearGradient", { id: "a", x1: "11.007", y1: "5.999", x2: "1.007", y2: "5.999", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "rgb(var(--oui-gradient-brand-end))" }), jsx("stop", { offset: "1", stopColor: "rgb(var(--oui-gradient-brand-start))" })] }) })] }), It$2 = (e2) => jsxs("svg", { width: "2", height: "2", viewBox: "0 0 2 2", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsx("path", { d: "M.667.334a.667.667 0 1 1 0 1.333.667.667 0 0 1 0-1.333", fill: "url(#a)" }), jsx("defs", { children: jsxs("linearGradient", { id: "a", x1: "1.333", y1: "1.001", x2: "0", y2: "1.001", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "rgb(var(--oui-gradient-brand-end))" }), jsx("stop", { offset: "1", stopColor: "rgb(var(--oui-gradient-brand-start))" })] }) })] });
var be$3 = () => {
  let { isMobile: e2 } = it$6(), t = wt$3();
  return e2 ? jsx(Fo$2, { ...t }) : jsx(Mt$3, { ...t });
};
var Eo$3 = (e2) => {
  let { items: t, classNames: o2 } = e2;
  return !Array.isArray(t) || t.length === 0 ? null : jsx(z$3, { className: cnBase("oui-gap-[6px] 2xl:oui-gap-2", o2 == null ? void 0 : o2.root), children: t == null ? void 0 : t.map((n4, i) => jsx(ze$4, { item: n4, currentPath: e2.current, onClick: e2.onItemClick }, i)) });
};
Zo({ name: "default-main-nav-menus", positions: [Yt$1.MainMenus], __isInternal: true })((e2) => jsx(Eo$3, { ...e2 }));
var Oo$2 = (e2) => jsx(bi$2, { position: Yt$1.MainMenus, ...e2 });
var Pt$3 = (e2) => {
  let { maintenanceDialogInfo: t, showAnnouncement: o2, currentTip: n4 } = e2, { t: i } = ne$6(), { isMobile: r3 } = it$6(), a2 = ze__default__default.useMemo(() => n4 ? r3 ? jsx(ba$1, { ...e2 }) : jsx(wa, { ...e2 }) : null, [n4, r3, e2]);
  return t ? jsx(ot$4, { open: true, children: jsxs(xo$3, { closable: false, onOpenAutoFocus: (s2) => s2.preventDefault(), className: "oui-w-[320px] lg:oui-w-auto", children: [jsx(bo$3, { children: jsx(ho$5, { children: i("maintenance.dialog.title") }) }), jsx(de$5, {}), jsx(tt$3, { className: "oui-text-2xs lg:oui-text-xs", children: t })] }) }) : o2 ? jsx(z$3, { style: e2.style, className: cnBase("oui-font-semibold oui-rounded-xl oui-overflow-hidden", e2.className), children: a2 }, n4 == null ? void 0 : n4.announcement_id) : null;
}, wa = (e2) => {
  var _a3;
  let { currentTip: t, currentIndex: o2, tips: n4, prevTips: i, nextTips: r3, closeTips: a2, mutiLine: s2, contentRef: u2, isAnimating: d2 } = e2, p2 = (n4.rows ?? []).length, { i18n: m2 } = ne$6();
  return jsxs(Fragment$1, { children: [jsxs(z$3, { justify: "center", width: "100%", py: 2, pl: 4, gapX: 2, itemAlign: s2 ? "start" : "center", className: cnBase("oui-mr-[125px] oui-relative oui-overflow-hidden", (t == null ? void 0 : t.url) && "oui-cursor-pointer", "oui-transition-transform oui-duration-200 oui-ease-in-out oui-opacity-100", d2 && "oui-translate-y-1/2 oui-opacity-0"), onClick: () => {
    (t == null ? void 0 : t.url) && window.open(t == null ? void 0 : t.url, "_blank");
  }, children: [jsx(Go$1, { type: t == null ? void 0 : t.type }), jsx(Q$1, { size: "xs", intensity: 80, ref: u2, className: "oui-leading-[18px]", children: ((_a3 = t == null ? void 0 : t.i18n) == null ? void 0 : _a3[m2.language]) || (t == null ? void 0 : t.message) })] }), jsxs(z$3, { gapX: 4, justify: "center", className: cnBase("oui-absolute oui-right-4 oui-top-2/4 -oui-translate-y-2/4"), children: [jsx(_o$2, { currentIndex: o2, tipsCount: p2, prevTips: i, nextTips: r3 }), jsx(se$1, { onClick: a2, size: 20, className: "oui-text-base-contrast-80 hover:oui-text-base-contrast" })] })] });
}, ba$1 = (e2) => {
  var _a3;
  let { currentTip: t, currentIndex: o2, tips: n4, prevTips: i, nextTips: r3, closeTips: a2, isAnimating: s2 } = e2, u2 = (n4.rows ?? []).length, { i18n: d2 } = ne$6();
  return jsxs(z$3, { p: 3, gapX: 2, itemAlign: "start", width: "100%", className: "oui-relative oui-overflow-hidden", children: [jsxs(z$3, { gapY: 2, direction: "column", className: cnBase("oui-items-start oui-justify-start oui-w-full"), children: [jsx("div", { className: cnBase("oui-w-full", (t == null ? void 0 : t.url) && "oui-cursor-pointer"), onClick: () => {
    (t == null ? void 0 : t.url) && window.open(t == null ? void 0 : t.url, "_blank");
  }, children: jsx(Q$1, { size: "xs", className: "oui-leading-5", intensity: 80, children: ((_a3 = t == null ? void 0 : t.i18n) == null ? void 0 : _a3[d2.language]) || (t == null ? void 0 : t.message) }) }), jsxs(z$3, { width: "100%", justify: "between", children: [jsx("div", { children: jsx(Go$1, { type: t == null ? void 0 : t.type }) }), jsx(_o$2, { currentIndex: o2, tipsCount: u2, prevTips: i, nextTips: r3 })] })] }), jsx(se$1, { onClick: a2, size: 18, className: "oui-mt-[2px]" })] });
}, _o$2 = (e2) => {
  let { currentIndex: t, tipsCount: o2, prevTips: n4, nextTips: i } = e2;
  return jsxs("div", { className: "oui-flex oui-items-center oui-justify-center oui-gap-1 oui-text-base-contrast-54", children: [jsx(Je$6, { size: 20, opacity: 1, className: " oui-text-base-contrast-54 hover:oui-text-base-contrast-80 oui-flex-shrink-0 oui-w-4 lg:oui-w-5 oui-h-4 lg:oui-h-5 oui-cursor-pointer ", onClick: n4 }), jsxs("div", { className: "oui-text-base-contrast-54 oui-text-sm", children: [t + 1, "/", o2] }), jsx(eo$4, { size: 20, opacity: 1, className: "oui-text-base-contrast-54 hover:oui-text-base-contrast-80 oui-flex-shrink-0 oui-w-4 lg:oui-w-5 oui-h-4 lg:oui-h-5 oui-cursor-pointer ", onClick: i })] });
}, Go$1 = ({ type: e2 }) => {
  let { t } = ne$6(), { label: o2, className: n4 } = useMemo(() => ({ [AnnouncementType.Listing]: { label: t("announcement.type.listing"), className: "oui-bg-primary/15 oui-text-primary" }, [AnnouncementType.Maintenance]: { label: t("announcement.type.maintenance"), className: "oui-bg-[rgba(232,136,0,0.15)] oui-text-warning-darken" }, [AnnouncementType.Delisting]: { label: t("announcement.type.delisting"), className: "oui-bg-[rgba(232,136,0,0.15)] oui-text-warning-darken" } })[e2] || {}, [e2, t]);
  return o2 ? jsx(z$3, { justify: "center", px: 2, r: "base", className: cnBase("oui-text-2xs oui-leading-[18px] oui-font-medium", "oui-break-normal oui-whitespace-nowrap", n4), children: o2 }) : null;
};
var ka = 1e3 * 60 * 60 * 24, Ze$3 = "-1", Yo$3 = "orderly_announcement", Aa$1 = (e2) => produce(e2, (t) => {
  Array.isArray(t.rows) && t.rows.sort((o2, n4) => o2.updated_time && n4.updated_time ? n4.updated_time - o2.updated_time : 0);
}), Rt$2 = (e2) => {
  var _a3;
  let [t, o2] = useState(0), [n4, i] = useState(false), { showAnnouncement: r3, setShowAnnouncement: a2 } = L$3(), { tips: s2, maintenanceDialogInfo: u2 } = Da(), [d2, p2] = useLocalStorage(Yo$3, {}), m2 = () => {
    p2((l2) => ({ ...l2, show: false }));
  }, v3 = useRef(null), g2 = ze__default__default.useCallback(() => {
    if (n4) return;
    let l2 = (s2.rows ?? []).length;
    i(true), o2((f2) => (f2 - 1 + l2) % l2), setTimeout(() => {
      i(false);
    }, 200);
  }, [n4, s2.rows]), b2 = ze__default__default.useCallback(() => {
    if (n4) return;
    let l2 = (s2.rows ?? []).length;
    i(true), o2((f2) => (f2 + 1) % l2), setTimeout(() => {
      i(false);
    }, 200);
  }, [n4, s2.rows]);
  useEffect(() => {
    let l2 = (s2.rows ?? []).length;
    if (!(!r3 || l2 <= 1)) return v3.current = setInterval(b2, 3e3), () => {
      v3.current && clearTimeout(v3.current);
    };
  }, [s2, r3, b2]), useEffect(() => {
    let l2 = (s2.rows ?? []).length;
    a2(!!l2 && d2.show && !(e2 == null ? void 0 : e2.hideTips));
  }, [s2, d2, e2 == null ? void 0 : e2.hideTips, a2]);
  let x2 = Fa();
  return { maintenanceDialogInfo: u2, tips: s2, currentIndex: t, currentTip: (_a3 = s2.rows) == null ? void 0 : _a3[t], closeTips: m2, nextTips: b2, prevTips: g2, showAnnouncement: r3, isAnimating: n4, ...x2 };
};
function Da() {
  let e2 = useWS(), [t, o2] = useLocalStorage(Yo$3, {}), [n4, i] = useState({}), [r3, a2] = useState(), { startTime: s2, endTime: u2, status: d2, brokerName: p2 } = useMaintenanceStatus(), { t: m2 } = ne$6(), { data: v3 } = useQuery("/v2/public/announcement", { revalidateOnFocus: false, refreshInterval: 60 * 60 * 1e3, formatter: (x2) => x2 }), g2 = (x2, l2, f2) => m2("maintenance.tips.description", { brokerName: x2, startDate: l2, endDate: f2 }), b2 = (x2, l2) => m2("maintenance.dialog.description", { brokerName: x2, endDate: l2 });
  return useEffect(() => {
    let x2 = e2.subscribe("announcement", { onMessage(l2) {
      l2 && (i((f2) => produce(f2, (h2) => {
        Array.isArray(h2.rows) || (h2.rows = []);
        let S2 = h2.rows.findIndex((B2) => B2.announcement_id === l2.announcement_id);
        S2 !== -1 && h2.rows.splice(S2, 1), h2.rows.push({ announcement_id: l2.announcement_id, message: l2.message, url: l2.url, i18n: l2.i18n, type: l2.type, updated_time: l2.updated_time });
      })), o2((f2) => ({ ...f2, show: true })));
    }, onError(l2) {
    } });
    return () => {
      x2 == null ? void 0 : x2();
    };
  }, [e2]), useEffect(() => {
    if (!(v3 == null ? void 0 : v3.rows)) return;
    let x2 = v3.last_updated_time ?? 0;
    (t.lastUpdateTime ?? 0) < x2 ? (i((f2) => ({ ...f2, rows: v3 == null ? void 0 : v3.rows })), o2({ show: true, lastUpdateTime: x2 })) : i((f2) => produce(f2, (h2) => {
      var _a3, _b2, _c2, _d3, _e3;
      if ((_a3 = v3 == null ? void 0 : v3.rows) == null ? void 0 : _a3.length) {
        let S2 = new Set((_b2 = f2.rows) == null ? void 0 : _b2.map((E3) => E3.announcement_id)), B2 = (_c2 = f2.rows) == null ? void 0 : _c2.find((E3) => E3.announcement_id === Ze$3);
        h2.rows = [], v3.rows.forEach((E3) => {
          var _a4;
          S2.has(E3.announcement_id) || ((_a4 = h2.rows) == null ? void 0 : _a4.push(E3));
        }), B2 && h2.rows.unshift(B2);
      } else {
        let S2 = (_d3 = h2.rows) == null ? void 0 : _d3.findIndex((B2) => B2.announcement_id === Ze$3);
        S2 !== void 0 && S2 !== -1 && ((_e3 = h2.rows) == null ? void 0 : _e3.splice(S2, 1));
      }
    }));
  }, [v3]), useEffect(() => {
    let x2 = s2 ? qo$4(s2) : "-", l2 = u2 ? qo$4(u2) : "-";
    if (d2 === MaintenanceStatus.Maintenance) {
      a2(b2(p2, l2));
      return;
    }
    a2(void 0), s2 ? s2 < T$1() + ka && i((f2) => produce(f2, (h2) => {
      Array.isArray(h2.rows) || (h2.rows = []), h2.rows = [{ announcement_id: Ze$3, type: AnnouncementType.Maintenance, message: g2(p2, x2, l2) }, ...h2.rows.filter((S2) => S2.type !== AnnouncementType.Maintenance)];
    })) : i((f2) => produce(f2, (h2) => {
      var _a3, _b2;
      let S2 = (_a3 = h2.rows) == null ? void 0 : _a3.findIndex((B2) => B2.announcement_id === Ze$3);
      S2 !== void 0 && S2 !== -1 && ((_b2 = h2.rows) == null ? void 0 : _b2.splice(S2, 1));
    }));
  }, [s2, u2, d2, p2, m2]), { tips: Aa$1(n4), maintenanceDialogInfo: r3 };
}
function Fa() {
  let [e2, t] = useState(false), o2 = useRef(null);
  return zm(o2.current, (n4) => {
    t(n4.contentRect.height > 20);
  }), { mutiLine: e2, contentRef: o2 };
}
function qo$4(e2) {
  let t = format(new UTCDateMini(e2), "MMM dd");
  return `${format(new UTCDateMini(e2), "h:mm aa")} (UTC) on ${t}`;
}
var Me$4 = (e2) => {
  let { hideTips: t, ...o2 } = e2, n4 = Rt$2({ hideTips: t });
  return jsx(Pt$3, { ...n4, ...o2 });
};
var ue$5 = (e2) => {
  let { mainMenus: t, current: o2, onRouteChange: n4 } = e2, i = useMemo(() => t == null ? void 0 : t.every((a2) => a2.href !== o2), [t, o2]), r3 = useMemo(() => t == null ? void 0 : t.map((a2) => {
    let s2 = o2 === a2.href;
    return jsxs(z$3, { direction: "column", itemAlign: "center", justify: "center", className: "oui-flex-1", onClick: () => {
      n4 == null ? void 0 : n4({ href: a2.href, name: a2.name });
    }, children: [jsx(Q$1, { children: s2 ? a2.activeIcon : a2.inactiveIcon }), jsx(Q$1, { children: a2.name })] }, a2.name);
  }), [t, o2, n4]);
  return i || !t ? null : jsx(z$3, { width: "100%", height: 64, px: 3, itemAlign: "center", justify: "between", className: "oui-bg-base-9", children: r3 });
};
function kt$1() {
  let [e2, t] = useState(false), [o2, n4] = useLocalStorage("orderly_qr_code_scan_tooltip_open", true), i = () => {
    t(true);
  }, r3 = () => {
    t(false);
  }, a2 = (s2) => {
    za(s2) && (window.location.href = s2);
  };
  return useEffect(() => {
    o2 && setTimeout(() => {
      n4(false);
    }, 8e3);
  }, [o2]), { open: e2, onOpenChange: t, showDialog: i, hideDialog: r3, onScanSuccess: a2, showScanTooltip: o2 };
}
function za(e2) {
  try {
    let t = new URL(e2);
    return ["http:", "https:"].includes(t.protocol);
  } catch {
    return false;
  }
}
var me$3 = 320, de$3 = 320, qe$5 = 2, nn = (e2) => {
  let t = useRef(null), o2 = useRef(null), n4 = () => {
    var _a3;
    let i = t.current, r3 = o2.current;
    if (!i || !r3) return;
    let a2 = r3.getContext("2d");
    if (i.readyState === i.HAVE_ENOUGH_DATA) {
      let s2 = i.videoWidth, u2 = i.videoHeight, d2 = r3.width / r3.height, p2 = s2 / u2, m2, v3, g2, b2;
      p2 > d2 ? (b2 = u2, g2 = u2 * d2, m2 = (s2 - g2) / 2, v3 = 0) : (g2 = s2, b2 = s2 / d2, m2 = 0, v3 = (u2 - b2) / 2), a2.drawImage(i, m2, v3, g2, b2, 0, 0, r3.width, r3.height);
      let x2 = a2.getImageData(0, 0, r3.width, r3.height), l2 = _a(x2.data, x2.width, x2.height, { inversionAttempts: "dontInvert" });
      (l2 == null ? void 0 : l2.data) && ((_a3 = e2.onSuccess) == null ? void 0 : _a3.call(e2, l2.data));
    }
    requestAnimationFrame(n4);
  };
  return useEffect(() => {
    let i = t.current;
    if (!(!open || !i)) return navigator == null ? void 0 : navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment", width: { ideal: me$3 * qe$5 }, height: { ideal: de$3 * qe$5 } } }).then((r3) => {
      i.srcObject = r3, i.setAttribute("playsinline", "true"), i.play(), i.onloadeddata = () => {
        requestAnimationFrame(n4);
      };
    }).catch((r3) => {
    }), () => {
      let r3 = i.srcObject;
      r3 && r3.getTracks().forEach((s2) => s2.stop()), i.srcObject = null;
    };
  }, [t, o2]), jsxs(Fragment$1, { children: [jsx("video", { ref: t, width: me$3, height: de$3, className: "oui-hidden oui-rounded-2xl oui-bg-base-10" }), jsx("canvas", { ref: o2, width: me$3 * qe$5, height: de$3 * qe$5, style: { width: me$3, height: de$3 }, className: "oui-rounded-2xl oui-bg-base-10" })] });
};
var At$2 = (e2) => {
  let { t } = ne$6();
  return jsxs(Fragment$1, { children: [jsx(xs, { open: e2.showScanTooltip, content: t("linkDevice.scanQRCode.tooltip"), className: "oui-bg-base-6 oui-text-2xs oui-font-semibold oui-text-warning-darken", arrow: { className: "!oui-fill-base-6" }, children: jsx(z$3, { className: "oui-h-8 oui-w-8 oui-cursor-pointer oui-items-center oui-justify-center oui-rounded-md oui-bg-base-5 oui-px-[6px]", onClick: e2.showDialog, children: jsx(Ya, { className: "oui-text-base-contrast-80" }) }) }), jsx(Se$5, { title: jsx(U$2, {}), open: e2.open, onOpenChange: e2.onOpenChange, size: "sm", children: jsx(Xa, { ...e2 }) })] });
}, Xa = (e2) => {
  let { t } = ne$6();
  return jsxs(z$3, { justify: "center", direction: "column", gapY: 5, children: [jsxs(W$2, { width: me$3, height: de$3, className: "oui-relative", children: [jsx(nn, { onSuccess: e2.onScanSuccess }), jsxs(Fragment$1, { children: [jsx(ja, {}), jsx($e$5, { className: "oui-absolute oui-left-[-1.5px] oui-top-[-1.5px]" }), jsx($e$5, { className: "oui-absolute oui-right-[-1.5px] oui-top-[-1.5px] oui-rotate-90" }), jsx($e$5, { className: "oui-absolute oui-bottom-[-1.5px] oui-left-[-1.5px] -oui-rotate-90" }), jsx($e$5, { className: "oui-absolute oui-bottom-[-1.5px] oui-right-[-1.5px] -oui-rotate-180" })] })] }), jsx(Q$1, { size: "sm", intensity: 98, weight: "semibold", children: t("linkDevice.scanQRCode") }), jsx("span", { className: "oui-px-3 oui-text-center", children: jsx(Q$1, { size: "2xs", intensity: 54, weight: "regular", className: "oui-break-words", children: jsx(Trans, { i18nKey: "linkDevice.scanQRCode.description", components: [jsx(Ja, { className: "oui-mx-1 oui-inline-block oui-text-base-contrast-80" }, "0")] }) }) })] });
}, Ya = (e2) => jsx("svg", { width: "18", height: "18", viewBox: "0 0 18 18", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...e2, children: jsx("path", { d: "M5.249 2.243a3 3 0 0 0-3 3v.75a.75.75 0 0 0 1.5 0v-.75a1.5 1.5 0 0 1 1.5-1.5h2.25a.75.75 0 0 0 0-1.5zm5.25 0a.75.75 0 0 0 0 1.5h2.25a1.5 1.5 0 0 1 1.5 1.5v.75a.75.75 0 0 0 1.5 0v-.75a3 3 0 0 0-3-3zm-7.5 9a.75.75 0 0 0-.75.75v.75a3 3 0 0 0 3 3h2.25a.75.75 0 0 0 0-1.5h-2.25a1.5 1.5 0 0 1-1.5-1.5v-.75a.75.75 0 0 0-.75-.75m12 0a.75.75 0 0 0-.75.75v.75a1.5 1.5 0 0 1-1.5 1.5h-2.25a.75.75 0 0 0 0 1.5h2.25a3 3 0 0 0 3-3v-.75a.75.75 0 0 0-.75-.75M5.25 8.999a.75.75 0 0 1 .75-.75h6a.75.75 0 0 1 0 1.5H6a.75.75 0 0 1-.75-.75" }) }), Ja = (e2) => {
  let { size: t = 20, ...o2 } = e2;
  return jsxs("svg", { width: t, height: t, viewBox: "0 0 20 20", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...o2, children: [jsx("path", { d: "M19.167 7.583a1.74 1.74 0 0 0-1.731-1.75h-4.038a1.74 1.74 0 0 0-1.731 1.75v8.167c0 .967.775 1.75 1.73 1.75h4.039a1.74 1.74 0 0 0 1.73-1.75zm-1.154 0v7.584H12.82V7.583A.58.58 0 0 1 13.398 7h4.038a.58.58 0 0 1 .577.583m-2.02 8.75a.58.58 0 0 1-.576.584.58.58 0 0 1-.577-.584.58.58 0 0 1 .577-.583.58.58 0 0 1 .577.583" }), jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M1.666 5a2.5 2.5 0 0 1 2.5-2.5h10a2.5 2.5 0 0 1 2.5 2.5.08.08 0 0 1-.078.078h-1.51a.08.08 0 0 1-.08-.078.834.834 0 0 0-.833-.833h-10A.834.834 0 0 0 3.333 5v5.633c0 .11.09.2.2.2h7.1c.11 0 .2.09.2.2V12.3a.2.2 0 0 1-.2.2H2.7a.2.2 0 0 0-.2.2v.633c0 .511.308.834.834.834h7.3c.11 0 .2.09.2.2v1.266a.2.2 0 0 1-.2.2h-7.3c-1.465 0-2.5-1.086-2.5-2.5v-1.666c0-.392.27-.72.635-.81.107-.026.198-.113.198-.224z" })] });
}, ja = () => jsx("div", { className: cnBase("oui-absolute oui-left-[30px] oui-top-0", "oui-h-[2px] oui-w-[calc(100%-60px)] oui-rounded-full", "oui-bg-[linear-gradient(270deg,rgb(var(--oui-gradient-brand-end))_0%,rgb(var(--oui-gradient-brand-start))_100%)]", "oui-shadow-[0_0_8px_4px_rgba(var(--oui-gradient-brand-start)/0.12)]", "oui-animate-scan-qr-code") }), $e$5 = (e2) => jsxs("svg", { xmlns: "http://www.w3.org/2000/svg", width: "64", height: "64", viewBox: "0 0 64 64", fill: "none", ...e2, children: [jsx("path", { d: "M62 2H18C9.16344 2 2 9.16344 2 18V62", stroke: "url(#paint0_linear_136_6227)", strokeWidth: "3", strokeLinecap: "round" }), jsx("defs", { children: jsxs("linearGradient", { id: "paint0_linear_136_6227", x1: "2", y1: "32", x2: "62", y2: "32", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "rgb(var(--oui-gradient-brand-end))" }), jsx("stop", { offset: "1", stopColor: "rgb(var(--oui-gradient-brand-start))" })] }) })] });
var Dt$6 = () => {
  let e2 = kt$1();
  return jsx(At$2, { ...e2 });
};
var Vt$3 = (e2) => {
  let { wrongNetwork: t, disabledConnect: o2 } = L$3(), { state: n4 } = useAccount(), i = useMemo(() => {
    var _a3;
    return Array.isArray(e2 == null ? void 0 : e2.initialMenu) ? e2 == null ? void 0 : e2.campaigns : (_a3 = e2 == null ? void 0 : e2.mainMenus) == null ? void 0 : _a3.find((m2) => e2.current ? m2.href === e2.current : m2.href === (e2 == null ? void 0 : e2.initialMenu));
  }, [e2 == null ? void 0 : e2.mainMenus, e2 == null ? void 0 : e2.initialMenu]), r3 = useMemo(() => (i == null ? void 0 : i.isHomePageInMobile) ? jsx(U$2, { ...e2 == null ? void 0 : e2.logo }) : jsx(Q$1, { className: "oui-text-base-contrast oui-text-2xl oui-font-bold", children: i == null ? void 0 : i.name }), [i, e2 == null ? void 0 : e2.logo]), a2 = useMemo(() => !!(!i || i.isSubMenuInMobile), [i]), s2 = useMemo(() => {
    var _a3, _b2, _c2;
    return (i == null ? void 0 : i.isSubMenuInMobile) ? i == null ? void 0 : i.name : ((_a3 = e2 == null ? void 0 : e2.subItems) == null ? void 0 : _a3.some((m2) => m2.href === (e2 == null ? void 0 : e2.current))) ? (_c2 = (_b2 = e2 == null ? void 0 : e2.subItems) == null ? void 0 : _b2.find((m2) => m2.href === (e2 == null ? void 0 : e2.current))) == null ? void 0 : _c2.name : null;
  }, [e2 == null ? void 0 : e2.subItems, e2 == null ? void 0 : e2.current, i]), u2 = () => {
    var _a3, _b2;
    let m2 = (_a3 = e2.mainMenus) == null ? void 0 : _a3.find((v3) => v3.href === e2.initialMenu);
    (i == null ? void 0 : i.isSubMenuInMobile) && (m2 = i == null ? void 0 : i.subMenuBackNav), (_b2 = e2 == null ? void 0 : e2.routerAdapter) == null ? void 0 : _b2.onRouteChange(m2);
  }, d2 = () => n4.status === AccountStatusEnum.EnableTradingWithoutConnected ? jsx(be$3, {}) : t ? null : jsx(Fragment$1, { children: jsx(ne$4, {}) }), p2 = useMemo(() => !(n4.status === AccountStatusEnum.EnableTradingWithoutConnected || o2), [n4.status, o2]);
  return a2 ? jsxs(z$3, { width: "100%", height: 44, px: 3, direction: "row", itemAlign: "center", justify: "center", className: "oui-relative", children: [jsx(Je$6, { className: "oui-absolute oui-left-6 oui-text-base-contrast-54", onClick: u2 }), jsx(Q$1, { className: "oui-text-base-contrast oui-text-base oui-font-bold", children: s2 })] }) : jsxs(z$3, { width: "100%", height: 44, px: 3, itemAlign: "center", justify: "between", children: [jsx(z$3, { children: r3 }), jsxs(z$3, { gapX: 2, children: [p2 && jsx(Dt$6, {}), d2(), jsx(Ve$3, {})] })] });
};
var Bt$3 = (e2) => {
  let { brokerName: t } = e2, { ip: o2, content: n4, restrictedOpen: i } = e2.restrictedInfo || {}, { t: r3 } = ne$6();
  if (!i) return;
  let a2 = () => typeof n4 == "function" ? jsx("span", { children: n4({ ip: o2, brokerName: t }) }) : n4 || jsx("span", { children: r3("restrictedInfo.description.default", { brokerName: t, ip: o2 }) });
  return jsx(z$3, { ref: e2.container, justify: "center", className: cnBase("oui-rounded-xl oui-p-[7px]", "oui-text-warning-darken", e2.className), children: jsxs(z$3, { className: cnBase("oui-min-h-[20px] oui-gap-1", "oui-text-2xs md:oui-text-sm oui-leading-4", "oui-items-start lg:oui-justify-center", e2.mutiLine ? "lg:oui-items-start" : "lg:oui-items-center"), children: [jsx(we$4, { size: 20, className: "oui-flex-shrink-0 oui-w-4 oui-h-4 lg:oui-w-5 lg:oui-h-5" }), a2()] }) });
};
var Et$2 = () => {
  let { restrictedInfo: e2 } = L$3(), t = useConfig("brokerName"), o2 = useRef(null), [n4, i] = useState(false);
  return zm(o2.current, (r3) => {
    i(r3.contentRect.height > 28);
  }), { restrictedInfo: e2, brokerName: t, container: o2, mutiLine: n4 };
};
var Te$3 = (e2) => {
  let t = Et$2();
  return jsx(Bt$3, { ...e2, ...t });
};
var Ht$2 = (e2) => {
  var _a3, _b2, _c2, _d3, _e3;
  return jsxs(Fragment$1, { children: [jsx("header", { className: "oui-sticky oui-top-0 oui-z-10 oui-w-full oui-bg-base-10", children: jsx(Vt$3, { ...e2.mainNavProps, routerAdapter: e2.routerAdapter }) }), jsx(Te$3, { className: "oui-mx-1 oui-mb-1 oui-bg-base-6" }), jsx(Me$4, { className: "oui-mx-1 oui-mb-1 oui-bg-base-6", hideTips: (_a3 = e2.restrictedInfo) == null ? void 0 : _a3.restrictedOpen }), e2.children, jsx("footer", { className: "oui-fixed oui-bottom-0 oui-z-10 oui-w-full oui-bg-base-9 oui-pb-[calc(env(safe-area-inset-bottom))]", children: jsx(ue$5, { mainMenus: (_b2 = e2 == null ? void 0 : e2.bottomNavProps) == null ? void 0 : _b2.mainMenus, current: ((_c2 = e2 == null ? void 0 : e2.bottomNavProps) == null ? void 0 : _c2.current) || ((_d3 = e2 == null ? void 0 : e2.mainNavProps) == null ? void 0 : _d3.initialMenu), onRouteChange: (_e3 = e2.routerAdapter) == null ? void 0 : _e3.onRouteChange }) })] });
};
var zt$3 = (e2) => {
  var _a3, _b2;
  let { restrictedInfo: t, showAnnouncement: o2 } = L$3(), [n4, i] = Ot$3(48), [r3, a2] = Ot$3(29), [s2, u2] = Ot$3(0, [o2]), [d2, p2] = useLocalStorage("orderly_scaffold_expanded", true), { isMobile: m2 } = it$6(), v3 = ((_a3 = e2.leftSideProps) == null ? void 0 : _a3.maxWidth) || 185, g2 = ((_b2 = e2.leftSideProps) == null ? void 0 : _b2.minWidth) || 98, b2 = !!e2.leftSidebar;
  return { topNavbarRef: n4, footerRef: r3, topNavbarHeight: i, footerHeight: a2, announcementRef: s2, announcementHeight: u2, restrictedInfo: t, expand: d2, setExpand: p2, isMobile: m2, sideBarExpandWidth: v3, sideBarCollaspedWidth: g2, hasLeftSidebar: b2, footerProps: e2.footerProps, routerAdapter: e2.routerAdapter, mainNavProps: e2.mainNavProps, bottomNavProps: e2.bottomNavProps };
}, Ot$3 = (e2, t = []) => {
  let o2 = useRef(null), [n4, i] = useState(e2);
  return zm(o2.current, (r3) => {
    i(r3.contentRect.height);
  }), useEffect(() => {
    var _a3;
    if (!o2.current) return;
    let r3 = (_a3 = o2.current) == null ? void 0 : _a3.getBoundingClientRect().height;
    i(r3);
  }, [o2, ...t]), [o2, n4];
};
var Is = h$2({ slots: { button: ["oui-min-h-10", "oui-px-3", "oui-py-2", "oui-rounded-md", "oui-w-full", "oui-text-left", "oui-text-base", "oui-text-base-contrast-36", "oui-group", "hover:oui-bg-base-8", "oui-transition-colors", "group-data-[state=closed]/bar:oui-w-[42px]", "oui-overflow-hidden"], icon: [] }, variants: { mode: { "icon-only": { button: "oui-w-10", icon: "w-6 h-6" }, full: { button: "oui-full", icon: "w-6 h-6" } }, active: { true: { button: "oui-bg-base-5 hover:oui-bg-base-5" } }, open: { true: { button: "" } } } }), hn = memo((e2) => {
  let { item: t, mode: o2, open: n4, onClick: i, active: r3, ...a2 } = e2, { button: s2 } = Is({ mode: o2, active: e2.active, open: e2.open }), u2 = jsx("button", { "data-actived": e2.active, disabled: t.disabled, className: s2(), onClick: () => {
    var _a3;
    (_a3 = e2.onClick) == null ? void 0 : _a3.call(e2, t);
  }, children: jsxs(z$3, { itemAlign: "center", gap: 2, as: "span", children: [jsx("div", { children: t.icon }), e2.open && jsx(Q$1.gradient, { color: e2.active ? "brand" : "inherit", angle: 45, size: "base", className: "oui-break-all oui-animate-in oui-fade-in", children: t.name })] }) });
  return e2.open ? jsx("li", { className: "oui-min-w-[120px]", children: u2 }) : jsx("li", { children: jsx(xs, { content: t.name, side: "right", align: "center", sideOffset: 20, children: u2 }) });
});
hn.displayName = "LeftMenuItem";
var Ts = (e2) => {
  var _a3;
  return jsxs(W$2, { py: 6, children: [jsx("svg", { width: "18", height: "18", viewBox: "0 0 18 18", fill: "none", xmlns: "http://www.w3.org/2000/svg", className: "oui-pointer-events-none oui-invisible oui-absolute", children: jsx("defs", { children: jsxs("linearGradient", { id: "side-menu-gradient", x1: "15.7432", y1: "8.94726", x2: "2.24316", y2: "8.94726", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "rgb(var(--oui-gradient-brand-end))" }), jsx("stop", { offset: "1", stopColor: "rgb(var(--oui-gradient-brand-start))" })] }) }) }), jsx("ul", { className: "oui-space-y-4", children: (_a3 = e2.menus) == null ? void 0 : _a3.map((t, o2) => (t == null ? void 0 : t.hide) ? null : jsx(hn, { item: t, open: e2.open, active: t.href === e2.current, onClick: e2.onItemSelect }, o2)) })] });
}, Ps$1 = (e2) => {
  let { title: t } = e2, o2 = typeof t == "string" ? jsx(Q$1, { intensity: 54, size: "xs", children: t }) : t, n4 = { className: "oui-text-base-contrast-36 hover:oui-text-base-contrast-80 oui-cursor-pointer", onClick: e2.onToggle };
  return jsxs(z$3, { justify: e2.open ? "between" : "center", itemAlign: "center", className: "oui-h-6", children: [e2.open ? o2 : null, e2.open ? jsx(Ls$1, { ...n4 }) : jsx(Rs, { ...n4 })] });
}, Re$5 = (e2) => {
  let { open: t = true, items: o2, current: n4, onItemSelect: i } = e2;
  return jsxs(W$2, { "data-state": t ? "opened" : "closed", className: cnBase("oui-group/bar", e2.className), style: e2.style, children: [jsx(Ps$1, { open: t, title: e2.title, onToggle: () => {
    var _a3;
    (_a3 = e2.onOpenChange) == null ? void 0 : _a3.call(e2, !t);
  } }), jsx(Ts, { menus: o2, current: n4, onItemSelect: i, open: t })] });
};
Re$5.displayName = "SideBar";
var Rs = (e2) => jsx("svg", { width: "16", height: "16", viewBox: "0 0 16 16", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...e2, children: jsx("path", { d: "M6.326 8.826a.84.84 0 0 0-.6.234L2.16 12.627v-2.135H.492v4.167c0 .46.373.833.834.833h4.166v-1.667H3.357l3.567-3.567a.857.857 0 0 0 0-1.198.84.84 0 0 0-.598-.234M10.502.492V2.16h2.135L9.07 5.726a.857.857 0 0 0 0 1.199.86.86 0 0 0 1.197 0l3.568-3.568v2.135h1.667V1.326a.834.834 0 0 0-.834-.834z" }) }), Ls$1 = (e2) => jsx("svg", { width: "16", height: "16", viewBox: "0 0 16 16", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...e2, children: jsx("path", { d: "M14.668.492a.85.85 0 0 0-.599.234l-3.567 3.568V2.159H8.835v4.167c0 .46.373.833.833.833h4.167V5.492H11.7l3.569-3.567a.86.86 0 0 0 0-1.199.85.85 0 0 0-.6-.234m-12.5 8.334v1.666h2.135L.736 14.06a.86.86 0 0 0 0 1.198.86.86 0 0 0 1.198 0l3.568-3.567v2.134h1.666V9.66a.834.834 0 0 0-.833-.833z" }) });
var vn = (e2) => {
  var _a3;
  let [t, o2] = useState(((_a3 = e2 == null ? void 0 : e2.items) == null ? void 0 : _a3[0].href) || "/"), { expanded: n4, setExpand: i } = Le$4();
  return { items: [], current: t, open: n4, onOpenChange: (r3) => {
    i == null ? void 0 : i(r3);
  }, onItemSelect: (r3) => {
    r3.href && o2(r3.href);
  }, ...e2 };
};
var Je$5 = (e2) => {
  let t = vn(e2);
  return jsx(Re$5, { ...t });
};
var Gt$4 = (e2) => {
  let { t } = ne$6(), o2 = useMemo(() => {
    switch (e2.wsStatus) {
      case WsNetworkStatus.Connected:
        return "oui-fill-success-light oui-text-success-light";
      case WsNetworkStatus.Disconnected:
        return "oui-fill-danger-light oui-text-danger-light";
      case WsNetworkStatus.Unstable:
        return "oui-fill-warning-light oui-text-warning-light";
    }
  }, [e2.wsStatus]), n4 = (i) => {
    window.open(i, "_blank");
  };
  return jsxs(z$3, { direction: "row", justify: "between", height: 28, px: 3, width: "100%", children: [jsxs(z$3, { children: [jsxs(z$3, { direction: "row", itemAlign: "center", gap: 1, className: o2, children: [jsx(Ue$4, { fillOpacity: 1, fill: "currentColor" }), jsx(Q$1, { size: "2xs", children: t("scaffold.footer.operational") })] }), jsx(de$5, { direction: "vertical", className: "oui-h-[18px] oui-px-1 oui-ml-2 oui-border-line-12" }), jsxs(z$3, { gap: 2, children: [jsx(Q$1, { intensity: 54, size: "2xs", children: t("scaffold.footer.joinCommunity") }), jsxs(z$3, { direction: "row", gap: 1, children: [typeof e2.telegramUrl < "u" && jsx(We$6, { className: "oui-fill-white/[.54] hover:oui-fill-white/[.98] oui-cursor-pointer", fill: "currentColor", fillOpacity: 1, onClick: (i) => n4(e2.telegramUrl) }), typeof e2.discordUrl < "u" && jsx(_e$4, { className: "oui-fill-white/[.54] hover:oui-fill-white/[.98] oui-cursor-pointer", fill: "currentColor", fillOpacity: 1, onClick: (i) => n4(e2.discordUrl) }), typeof e2.twitterUrl < "u" && jsx(Ge$1, { className: "oui-fill-white/[.54] hover:oui-fill-white/[.98] oui-cursor-pointer", fill: "currentColor", fillOpacity: 1, onClick: (i) => n4(e2.twitterUrl) })] }), typeof (e2 == null ? void 0 : e2.trailing) < "u" && jsxs(Fragment$1, { children: [jsx(de$5, { direction: "vertical", className: "oui-h-[18px] oui-border-line-12" }), e2 == null ? void 0 : e2.trailing] })] })] }), jsxs(z$3, { direction: "row", gap: 1, children: [jsx(Q$1, { intensity: 54, size: "2xs", children: t("scaffold.footer.poweredBy") }), jsx(yt$4, {})] })] });
};
var Cn = () => ({ wsStatus: useWsStatus() });
var Ut$2 = (e2) => {
  let t = Cn();
  return jsx(Gt$4, { ...t, ...e2 });
};
var wn$1 = (e2) => {
  var _a3;
  let { classNames: t } = e2;
  return jsxs("div", { style: { height: `calc(100vh - ${e2.footerHeight}px)` }, className: cnBase("oui-scaffold-root oui-font-semibold", "oui-text-base-contrast oui-bg-base-10", "oui-flex oui-flex-col", "oui-overflow-auto oui-custom-scrollbar", t == null ? void 0 : t.root), children: [jsx(W$2, { ref: e2.topNavbarRef, className: cnBase("oui-scaffold-topNavbar oui-bg-base-9", t == null ? void 0 : t.topNavbar), children: e2.topBar ?? jsx(Kt$3, { ...e2.mainNavProps }) }), jsxs("div", { className: cnBase("oui-scaffold-container", "oui-relative oui-h-full", "oui-min-w-[1018px]", t == null ? void 0 : t.container), children: [jsxs(W$2, { px: 3, ref: e2.announcementRef, children: [jsx(Te$3, { className: cnBase("oui-scaffold-restricted-info", "oui-relative oui-z-[1]", "oui-mt-3", "oui-bg-base-9", "oui-min-w-[994px]") }), jsx(Me$4, { className: cnBase("oui-scaffold-maintenance-tips", "oui-mt-3", "oui-relative oui-z-[1]", "oui-bg-base-9", "oui-min-w-[994px]"), hideTips: (_a3 = e2.restrictedInfo) == null ? void 0 : _a3.restrictedOpen })] }), e2.hasLeftSidebar ? jsxs(Sa$1, { className: cnBase("oui-box-content oui-transition-all oui-flex xl:oui-grid", "oui-flex-1 oui-min-h-full", t == null ? void 0 : t.body), style: { gridTemplateColumns: `${e2.expand ? `${e2.sideBarExpandWidth}px` : `${e2.sideBarCollaspedWidth}px`} 1fr` }, children: [jsx("div", { className: cnBase(t == null ? void 0 : t.leftSidebar), children: isValidElement(e2.leftSidebar) ? e2.leftSidebar : jsx(Je$5, { ...e2.leftSideProps }) }), jsx(W$2, { width: "100%", className: cnBase("oui-overflow-hidden", t == null ? void 0 : t.content), children: e2.children })] }) : jsx(W$2, { height: "100%", className: cnBase(t == null ? void 0 : t.content), children: e2.children })] }), jsx(W$2, { ref: e2.footerRef, className: cnBase("oui-scaffold-footer oui-w-full oui-bg-base-10", "oui-fixed oui-bottom-0 oui-z-50", "oui-border-t-[1px] oui-border-line-12", t == null ? void 0 : t.footer), children: e2.footer || jsx(Ut$2, { ...e2.footerProps }) })] });
};
var et$4 = createContext({}), Le$4 = () => useContext(et$4);
function bn$1(e2, t) {
  return typeof e2 == "string" && (e2 = parseInt(e2)), t.some((o2) => o2.network_infos.chain_id === e2);
}
var yn = (e2) => {
  let [t] = useChains(), { networkId: o2 } = useContext(OrderlyContext), n4 = (r3) => bn$1(r3, o2 === "testnet" ? t.testnet : t.mainnet), i = (r3) => {
    e2.setExpand(r3);
  };
  return jsx(et$4.Provider, { value: { routerAdapter: e2.routerAdapter, expanded: e2.expanded, setExpand: i, checkChainSupport: n4, topNavbarHeight: e2.topNavbarHeight, footerHeight: e2.footerHeight, announcementHeight: e2.announcementHeight }, children: e2.children });
};
var Sn$1 = (e2) => {
  let t = zt$3(e2), o2 = () => t.isMobile ? jsx(Ht$2, { ...t, children: e2.children }) : jsx(wn$1, { ...e2, ...t, children: e2.children });
  return jsx(yn, { routerAdapter: e2.routerAdapter, expanded: t.expand, setExpand: t.setExpand, topNavbarHeight: t.topNavbarHeight, footerHeight: t.footerHeight, announcementHeight: t.announcementHeight, children: o2() });
};
var Zt$4 = ((n4) => (n4.menuLeading = "menuLeading", n4.menuTailing = "menuTailing", n4.navTailing = "navTailing", n4))(Zt$4 || {}), Nn$1 = (e2) => {
  var _a3;
  let { onItemClick: t, campaignPosition: o2 = "navTailing" } = e2, { state: n4 } = useAccount(), { routerAdapter: i } = Le$4(), { connectedChain: r3 } = useWalletConnector(), { wrongNetwork: a2, disabledConnect: s2 } = L$3(), [u2, d2] = useState(() => typeof e2.initialMenu > "u" ? [] : Array.isArray(e2.initialMenu) ? e2.initialMenu : [e2.initialMenu]), p2 = (g2) => (b2) => {
    let x2 = b2[b2.length - 1];
    if (!x2) return;
    x2.target !== "_blank" && d2(b2.map((h2) => h2.href));
    let l2 = b2[b2.length - 1], f2 = { href: l2.href, name: l2.name, scope: g2, target: l2.target };
    if (typeof t == "function") {
      t(f2);
      return;
    }
    i == null ? void 0 : i.onRouteChange(f2);
  }, m2 = useMemo(() => {
    let g2 = { leading: null, trailing: null, logo: {}, mainMenus: [], products: [], ...e2, campaignPosition: o2 };
    return e2.leading && (g2.leading = e2.leading), e2.trailing && (g2.trailing = e2.trailing), e2.campaigns && (o2 === "menuTailing" ? g2.mainMenus = [...g2.mainMenus, e2.campaigns] : o2 === "menuLeading" ? g2.mainMenus = [e2.campaigns, ...g2.mainMenus] : g2.campaigns = e2.campaigns), g2;
  }, [e2]), v3 = {};
  return m2.mainMenus && m2.mainMenus.length && (v3.mainMenus = { items: m2.mainMenus, current: u2, onItemClick: p2("mainMenu") }), m2.campaigns && ((_a3 = m2.campaigns.children) == null ? void 0 : _a3.length) && (v3.campaigns = { item: m2.campaigns, current: u2, onItemClick: p2("campaign") }), { ...m2, isConnected: !!r3, wrongNetwork: a2, ...v3, status: n4.status, disabledConnect: s2 };
};
var qt$5 = (e2) => {
  let { className: t, logo: o2, classNames: n4, campaigns: i, campaignPosition: r3 } = e2, a2 = r3 === "navTailing" && i, s2 = !e2.wrongNetwork && !e2.disabledConnect && e2.status >= AccountStatusEnum.SignedIn, u2 = !e2.disabledConnect && e2.wrongNetwork && e2.isConnected, { isDesktop: d2 } = it$6(), p2 = useMemo(() => typeof e2.children > "u" ? null : jsx(z$3, { grow: true, children: e2.children }), [e2.children]);
  return jsxs(z$3, { width: "100%", as: "header", itemAlign: "center", height: "48px", justify: "between", px: 3, gapX: 3, className: cnBase("oui-main-nav oui-font-semibold", t, n4 == null ? void 0 : n4.root), children: [jsxs(z$3, { itemAlign: "center", className: cnBase("oui-gap-3 2xl:oui-gap-4", "oui-overflow-hidden"), children: [jsx(U$2, { ...o2 }), e2.leading, jsx(Oo$2, { ...e2.mainMenus, classNames: n4 == null ? void 0 : n4.mainNav }), e2.trailing] }), p2, jsxs(z$3, { itemAlign: "center", className: "oui-gap-3 2xl:oui-gap-4", children: [!!a2 && jsx(So$3, { ...i, className: n4 == null ? void 0 : n4.campaignButton }), jsx(Be$5, {}), s2 && jsxs(Fragment$1, { children: [jsx(de$5, { direction: "vertical", className: "oui-h-8", intensity: 8 }), jsx(be$3, {})] }), jsx(ht$3, {}), d2 && jsx(ne$4, {}), !u2 && jsx(Ve$3, {})] })] });
};
qt$5.displayName = "MainNav";
var Kt$3 = (e2) => {
  let { children: t, classNames: o2, ...n4 } = e2, i = Nn$1(n4);
  return jsx(qt$5, { classNames: o2, ...i, children: t });
};
var q = [5, 10, 20, 50, 100], C = (e2) => {
  let { Icon: r3, onClick: o2, disabled: n4 } = e2;
  return jsx(r3, { onClick: n4 ? void 0 : o2, className: cnBase("oui-m-2 oui-text-white oui-transition-all", n4 ? "oui-cursor-not-allowed oui-opacity-20" : "oui-cursor-pointer oui-opacity-100") });
}, J$1 = (e2) => {
  let r3 = ze__default__default.useMemo(() => [li$3.numberFormatter, li$3.currencyFormatter, li$3.decimalPointFormatter], []), o2 = useId();
  return jsxs("label", { htmlFor: o2, className: cnBase("oui-w-full", "oui-rounded", "oui-bg-base-6", "oui-flex", "oui-items-center", "oui-justify-between", "oui-outline", "oui-outline-offset-0", "oui-outline-1", "oui-outline-transparent", "focus-within:oui-outline-primary-light", "oui-input-root"), children: [jsx(C, { Icon: cn, onClick: e2.onLeverageReduce, disabled: e2.isReduceDisabled }), jsxs(z$3, { itemAlign: "center", justify: "center", children: [jsx(Fo$3, { value: e2.value, id: o2, autoComplete: "off", classNames: { input: cnBase("oui-text-center"), root: cnBase("oui-text-center", "oui-w-7", "oui-px-0", "oui-outline", "oui-outline-offset-0", "oui-outline-1", "oui-outline-transparent", "focus-within:oui-outline-primary-none") }, formatters: r3, onChange: e2.onInputChange }), jsx("div", { className: "oui-select-none", children: "x" })] }), jsx(C, { Icon: ln$1, onClick: e2.onLeverageIncrease, disabled: e2.isIncreaseDisabled })] });
}, x$1 = (e2) => {
  let { currentLeverage: r3 } = e2, { t: o2 } = ne$6();
  return jsxs(z$3, { itemAlign: "start", direction: "column", mb: 0, children: [jsx(F$1, { currentLeverage: r3 }), jsx(J$1, { ...e2 }), jsx(K$2, { ...e2 }), jsx(w$1, { ...e2 }), jsxs(z$3, { direction: "row", gap: 2, width: "100%", mt: 0, pt: 5, children: [jsx($e$6, { variant: "contained", color: "gray", fullWidth: true, onClick: e2.onCancel, "data-testid": "oui-testid-leverage-cancel-btn", children: o2("common.cancel") }), jsx($e$6, { fullWidth: true, loading: e2.isLoading, onClick: e2.onSave, "data-testid": "oui-testid-leverage-save-btn", children: o2("common.save") })] })] });
}, F$1 = (e2) => {
  let { t: r3 } = ne$6(), { currentLeverage: o2 } = e2;
  return jsx(z$3, { justify: "center", width: "100%", mb: 2, children: jsxs(z$3, { gap: 1, children: [`${r3("common.current")}:`, jsx(Q$1.numeral, { unit: "x", size: "sm", intensity: 80, children: o2 ?? "--" })] }) });
}, K$2 = (e2) => {
  let { value: r3, onLeverageChange: o2 } = e2;
  return jsx(z$3, { itemAlign: "center", justify: "between", width: "100%", mt: 2, children: q.map((n4) => jsx(z$3, { itemAlign: "center", justify: "center", className: cnBase("oui-box-border oui-cursor-pointer oui-rounded-md oui-border oui-border-solid oui-bg-clip-padding oui-px-3 oui-py-2.5 oui-transition-all", r3 === n4 ? "oui-border-primary oui-bg-base-6" : "oui-border-line-12"), onClick: () => o2 == null ? void 0 : o2(n4), children: jsxs(z$3, { itemAlign: "center", justify: "center", className: cnBase("oui-h-3 oui-w-9 oui-select-none"), children: [n4, "x"] }) }, n4)) });
}, w$1 = (e2) => {
  let { leverageLevers: r3, maxLeverage: o2, className: n4, value: g2, showSliderTip: c } = e2;
  return jsxs(W$2, { pt: 4, width: "100%", className: n4, children: [jsx(iu, { max: o2, min: 1, markCount: 5, value: [g2], onValueChange: (a2) => {
    e2.onLeverageChange(a2[0]), e2.setShowSliderTip(true);
  }, color: "primary", onValueCommit: (a2) => {
    var _a3;
    (_a3 = e2.onValueCommit) == null ? void 0 : _a3.call(e2, a2), e2.setShowSliderTip(false);
  }, showTip: c, tipFormatter: (a2) => `${a2}x` }), jsx(z$3, { justify: "between", width: "100%", pt: 3, children: r3 == null ? void 0 : r3.map((a2, m2) => jsx("button", { onClick: () => {
    var _a3;
    e2.onLeverageChange(a2), (_a3 = e2.onValueCommit) == null ? void 0 : _a3.call(e2, [a2]);
  }, className: cnBase("oui-pb-3 oui-text-2xs", m2 === 0 ? "oui-pr-2" : m2 === 5 ? "oui-pl-0" : "oui-ml-2 oui-px-0", e2.value >= a2 && "oui-text-primary-light"), "data-testid": `oui-testid-leverage-${a2}-btn`, children: `${a2}x` }, a2)) })] });
};
var b = (e2) => {
  let [r3, o2] = useState(false), { t: n4 } = ne$6(), { curLeverage: g2, maxLeverage: c, isLoading: a2, leverageLevers: m2, update: P2 } = useLeverage(), S2 = useMemo(() => m2.map((i) => ({ label: `${i}x`, value: i })), [m2]), [v3, d2] = useState(g2 ?? 0), E3 = 100 / (((S2 == null ? void 0 : S2.length) || 0) - 1), T2 = (i) => {
    d2(i);
  }, N2 = () => {
    d2((i) => i + 1);
  }, V2 = () => {
    d2((i) => i - 1);
  }, M2 = useCallback((i) => {
    let h2 = Number.parseInt(i.target.value, 10), W2 = Number.isNaN(h2) ? 0 : h2, A2 = Math.min(Math.max(W2, 1), c);
    d2(A2);
  }, [c]), H2 = async () => {
    try {
      P2({ leverage: v3 }).then(() => {
        var _a3;
        (_a3 = e2 == null ? void 0 : e2.close) == null ? void 0 : _a3.call(e2), toast$2.success(n4("leverage.updated"));
      }, (i) => {
        toast$2.error(i.message);
      });
    } catch {
    }
  };
  return { leverageLevers: m2, currentLeverage: g2, value: v3, marks: S2, onLeverageChange: T2, onLeverageIncrease: N2, onLeverageReduce: V2, onInputChange: M2, isReduceDisabled: v3 <= 1, isIncreaseDisabled: v3 >= c, step: E3, onCancel: e2 == null ? void 0 : e2.close, onSave: H2, isLoading: a2, showSliderTip: r3, setShowSliderTip: o2, maxLeverage: c };
};
var p = (e2) => {
  let r3 = b({ close: e2.close });
  return jsx(x$1, { ...r3 });
};
var re$3 = "LeverageWidgetWithDialog", oe$4 = "LeverageWidgetWithSheet";
Wm(re$3, p, { title: () => o.t("leverage.maxAccountLeverage"), size: "md" });
Um(oe$4, p, { title: () => o.t("leverage.maxAccountLeverage") });
function wt$2(t, o2) {
  let [n4, e2] = useState(""), [r3, a2] = useState(false);
  return useEffect(() => {
    r3 || typeof o2 != "function" || (a2(true), o2(t.address, t.decimals).then((s2) => {
      e2(s2);
    }).catch((s2) => {
    }).finally(() => {
      a2(false);
    }));
  }, [t]), { balance: n4, loading: r3 };
}
var yt$3 = (t) => {
  let { token: o2, isActive: n4, onTokenChange: e2, fetchBalance: r3 } = t, { symbol: a2, precision: s2, decimals: i } = o2, { balance: l2, loading: m2 } = wt$2(o2, r3), c = typeof r3 == "function", p2 = s2 ?? 2, f2 = () => c ? m2 ? jsx(Ie$4, { size: "sm" }) : jsx(Q$1.numeral, { rule: "price", dp: p2, rm: g$6.ROUND_DOWN, className: cnBase("oui-text-base-contrast-80 group-hover:oui-text-base-contrast-54", n4 && "oui-text-base-contrast-54"), children: l2 }) : null;
  return jsxs(z$3, { justify: "between", px: 2, r: "base", className: cnBase("group", "oui-h-[30px] hover:oui-bg-base-5", "oui-text-2xs oui-font-semibold", "oui-cursor-pointer", n4 && "oui-bg-base-5", t.index !== 0 && "oui-mt-[2px]"), onClick: () => {
    e2 == null ? void 0 : e2(o2);
  }, children: [jsxs(z$3, { gapX: 1, children: [jsx(Te$4, { name: a2, className: "oui-w-[16px] oui-h-[16px]" }), jsx(Q$1, { className: cnBase("oui-text-base-contrast-54 group-hover:oui-text-base-contrast-80", n4 && "oui-text-base-contrast-80"), children: a2 })] }), f2()] }, a2);
};
var $$2 = forwardRef((t, o2) => {
  let { token: n4, tokens: e2 = [], classNames: r3, label: a2, status: s2, hintMessage: i, value: l2, onValueChange: m2, onTokenChange: c, fetchBalance: p2, loading: f2, placeholder: b2, ...h2 } = t, { t: d2 } = ne$6(), w4 = useRef(null), [k2, v3] = useState(false), [S2, D2] = useState(0), A2 = useMemo(() => e2.map((g2) => ({ ...g2, name: g2.display_name || g2.symbol })), [e2]);
  useEffect(() => {
    var _a3;
    let g2 = (_a3 = w4 == null ? void 0 : w4.current) == null ? void 0 : _a3.getBoundingClientRect();
    D2((g2 == null ? void 0 : g2.width) || 0);
  }, [w4]);
  let I2 = (g2) => {
    let V2 = e2.find((q2) => q2.symbol === g2);
    V2 && (c == null ? void 0 : c(V2));
  }, F3 = (g2) => {
    let V2 = g2.symbol === (n4 == null ? void 0 : n4.symbol);
    return jsx(yt$3, { token: g2, fetchBalance: p2, onTokenChange: (q2) => {
      c == null ? void 0 : c(q2), v3(false);
    }, isActive: V2 });
  }, W2 = jsxs(W$2, { children: [jsx(W$2, { className: "oui-absolute oui-top-0", children: jsx(Q$1, { size: "2xs", intensity: 36, children: a2 || d2("common.quantity") }) }), f2 && jsx(W$2, { className: "oui-absolute oui-bottom-1", children: jsx(Ie$4, { size: "sm" }) })] }), U2 = e2.length > 1, Q2 = jsx("div", { className: "oui-absolute oui-right-0", children: jsx(Be$6.tokens, { open: U2 ? k2 : false, onOpenChange: v3, disabled: h2.disabled, variant: "text", tokens: A2, value: (n4 == null ? void 0 : n4.display_name) || (n4 == null ? void 0 : n4.symbol), size: h2.size, onValueChange: I2, showIcon: true, optionRenderer: F3, contentProps: { onCloseAutoFocus: (g2) => {
    var _a3;
    g2.preventDefault(), (_a3 = w4.current) == null ? void 0 : _a3.focus();
  }, onClick: (g2) => {
    var _a3;
    g2.preventDefault(), (_a3 = w4.current) == null ? void 0 : _a3.focus();
  }, style: { width: S2 }, align: "end", sideOffset: 5, className: "oui-border oui-border-line-6" } }) }), G2 = jsxs(z$3, { mt: 1, gapX: 1, px: 1, children: [jsx(W$2, { width: 4, height: 4, r: "full", className: cnBase(s2 === "error" && "oui-bg-danger-light", s2 === "warning" && "oui-bg-warning-light") }), jsx(Q$1, { size: "2xs", className: cnBase(s2 === "error" && "oui-text-danger-light", s2 === "warning" && "oui-text-warning-light"), children: i })] }), ne2 = b2 ?? (f2 ? "" : "0");
  return jsxs(Fragment$1, { children: [jsx(Fo$3, { "data-testid": t.testId, ref: w4, autoComplete: "off", placeholder: ne2, prefix: W2, suffix: Q2, value: l2, onValueChange: (g2) => {
    var _a3;
    (_a3 = t.onValueChange) == null ? void 0 : _a3.call(t, g2);
  }, formatters: [li$3.numberFormatter, li$3.dpFormatter((n4 == null ? void 0 : n4.precision) ?? 2), li$3.currencyFormatter], ...h2, classNames: { ...r3, root: cnBase("oui-h-[54px] oui-relative oui-px-3", "oui-border oui-border-line oui-rounded-lg", s2 === "error" && "focus-within:oui-outline-danger-light oui-outline-danger-light", s2 === "warning" && "focus-within:oui-outline-warning-light oui-outline-warning-light", t.readOnly ? "oui-bg-base-6 focus-within:oui-outline-0 oui-border-none" : "oui-bg-base-5", r3 == null ? void 0 : r3.root), input: cnBase("oui-absolute oui-bottom-0", r3 == null ? void 0 : r3.input) } }), i && G2] });
});
var Tt$1 = (t) => jsx("svg", { width: "12", height: "12", viewBox: "0 0 12 12", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...t, children: jsx("path", { d: "M10.997 8.004a.5.5 0 0 0-.14-.36l-1.86-1.843-.703.703.984 1h-7.28a.5.5 0 0 0 0 1h7.28l-.984 1 .703.703 1.86-1.844a.5.5 0 0 0 .14-.36m-.5-4a.5.5 0 0 0-.5-.5H2.716l.984-1-.703-.703-1.859 1.843a.515.515 0 0 0 0 .719l1.86 1.844.702-.703-.984-1h7.281a.5.5 0 0 0 .5-.5" }) }), vt$3 = (t) => jsx("svg", { width: "20", height: "21", viewBox: "0 0 20 21", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...t, children: jsx("path", { d: "M9.994 5.51a.83.83 0 0 0-.832.833v6.295l-2.498-2.471-1.17 1.17 3.902 3.929a.84.84 0 0 0 .599.244.84.84 0 0 0 .597-.244l3.903-3.928-1.171-1.171-2.498 2.471V6.343a.83.83 0 0 0-.832-.833" }) });
var Ft$6 = (t) => jsx("svg", { width: "14", height: "14", viewBox: "0 0 14 14", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...t, children: jsx("path", { d: "M4.078 1.744a2.333 2.333 0 0 0-2.333 2.333v5.834a2.333 2.333 0 0 0 2.333 2.333h5.833a2.333 2.333 0 0 0 2.334-2.333V4.077A2.333 2.333 0 0 0 9.91 1.744zm2.917 2.333c.322 0 .583.262.583.584v2.916h1.75L6.995 9.911 4.66 7.577h1.75V4.661c0-.322.262-.584.584-.584" }) }), St$3 = (t) => jsx("svg", { width: "14", height: "14", viewBox: "0 0 14 14", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...t, children: jsx("path", { d: "M4.078 12.244a2.333 2.333 0 0 1-2.333-2.333V4.077a2.333 2.333 0 0 1 2.333-2.333h5.833a2.333 2.333 0 0 1 2.334 2.333v5.834a2.333 2.333 0 0 1-2.334 2.333zm2.917-2.333a.584.584 0 0 0 .583-.584V6.411h1.75L6.995 4.077 4.66 6.411h1.75v2.916c0 .322.262.584.584.584" }) }), At$1 = (t) => jsx("svg", { width: "12", height: "12", viewBox: "0 0 12 12", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...t, children: jsx("path", { d: "M6.00342 1.49561C4.97642 1.49561 3.99542 1.84011 3.20642 2.46461C2.98992 2.63561 2.95692 2.9511 3.12842 3.1676C3.29992 3.3841 3.61492 3.4171 3.83142 3.2456C4.44492 2.7601 5.20392 2.4956 6.00342 2.4956C7.93642 2.4956 9.50342 4.0626 9.50342 5.9956H8.50342L10.0034 7.9956L11.5034 5.9956H10.5034C10.5034 3.5101 8.48892 1.49561 6.00342 1.49561ZM2.00342 3.9956L0.503418 5.9956H1.50342C1.50342 8.4811 3.51792 10.4956 6.00342 10.4956C7.03092 10.4956 8.01142 10.1516 8.80042 9.52659C9.01692 9.35559 9.04992 9.0401 8.87842 8.8236C8.70692 8.6071 8.39191 8.5741 8.17542 8.7456C7.56142 9.2316 6.80342 9.4956 6.00342 9.4956C4.07042 9.4956 2.50342 7.9286 2.50342 5.9956H3.50342L2.00342 3.9956Z" }) });
var ae$2 = (t) => {
  var _a3, _b2;
  let { chains: o2, value: n4, wrongNetwork: e2, loading: r3 } = t, [a2, s2] = useState(false), { t: i } = ne$6(), l2 = e2 || (o2 == null ? void 0 : o2.length) > 1, m2 = e2 ? jsx(z$3, { width: 18, height: 18, intensity: 100, r: "full", justify: "center", itemAlign: "center", children: jsx(Q$1, { size: "2xs", intensity: 80, children: "U" }) }) : jsx(Fr$1, { className: "oui-w-[18px] oui-h-[18px]", chainId: n4 == null ? void 0 : n4.id }), c = e2 ? "Unknown" : (_b2 = (_a3 = n4 == null ? void 0 : n4.info) == null ? void 0 : _a3.network_infos) == null ? void 0 : _b2.name, p2 = () => {
    if (r3) return jsx(Ie$4, { size: "sm" });
    if (l2) return jsx(Tt$1, { className: "oui-text-base-contrast-54" });
  }, f2 = jsxs(z$3, { intensity: 500, className: cnBase("oui-rounded-t-xl oui-rounded-b-sm oui-border oui-border-line", l2 ? "oui-cursor-pointer" : "oui-cursor-auto"), height: 54, px: 3, justify: "between", itemAlign: "center", children: [jsxs("div", { children: [jsx(z$3, { children: jsx(Q$1, { size: "2xs", intensity: 54, children: i("transfer.network") }) }), jsxs(z$3, { gapX: 1, children: [m2, jsx(Q$1, { size: "sm", intensity: 80, children: c })] })] }), p2()] }), b2 = o2.map((h2, d2) => {
    let w4 = h2.chain_id === (n4 == null ? void 0 : n4.id);
    return jsxs(z$3, { px: 2, r: "base", justify: "between", className: cnBase("oui-deposit-network-select-item", "hover:oui-bg-base-5 oui-h-[30px] oui-cursor-pointer", w4 && "oui-bg-base-5", d2 !== 0 && "oui-mt-[2px]"), onClick: async () => {
      s2(false), await t.onValueChange(h2);
    }, children: [jsxs(z$3, { gapX: 1, itemAlign: "center", children: [jsx(Fr$1, { className: "oui-w-[18px] oui-h-[18px]", chainId: h2.chain_id }), jsx(Q$1, { size: "2xs", intensity: 54, children: h2.name }), h2.bridgeless && jsx(z$3, { className: "oui-bg-success-light/15", height: 18, px: 2, r: "base", justify: "center", itemAlign: "center", children: jsx(Q$1, { size: "2xs", className: "oui-text-success-light", children: i("transfer.lowestFee") }) })] }), w4 && jsx(W$2, { width: 4, height: 4, r: "full", className: "oui-deposit-network-select-active-dot oui-bg-[linear-gradient(270deg,#59B0FE_0%,#26FEFE_100%)]" })] }, h2.chain_id);
  });
  return jsxs(la$1, { open: l2 ? a2 : false, onOpenChange: s2, children: [jsx(ua$2, { asChild: true, children: f2 }), jsx(ca$1, { children: jsx(xr$3, { onCloseAutoFocus: (h2) => h2.preventDefault(), align: "start", sideOffset: 2, className: cnBase("oui-deposit-token-select-dropdown-menu-content", "oui-bg-base-8 oui-p-1", "oui-w-[var(--radix-dropdown-menu-trigger-width)]", "oui-rounded-md oui-select-none"), children: jsx(io$3, { children: jsxs("div", { className: "oui-max-h-[254px]", children: [b2, " "] }) }) }) })] });
};
var le$4 = () => jsxs(z$3, { height: 40, gapX: 3, children: [jsx(z$3, { height: 1, className: "oui-bg-base-contrast-12 oui-flex-1" }), jsx(vt$3, { className: "oui-text-primary-light" }), jsx(z$3, { height: 1, className: "oui-bg-base-contrast-12 oui-flex-1" })] });
function Pt$2(t) {
  return t ? t.replace(/^(.{6})(.*)(.{4})$/, "$1......$3") : "--";
}
var Dt$5 = (t = []) => {
  let o2 = t.reduce((n4, e2) => (n4[e2.symbol] = e2, n4), {});
  return o2.USDC || o2.USDbC || t[0];
}, Wt$1 = (t) => t + 3;
var ue$4 = () => {
  let { t } = ne$6(), { wallet: o2, connectedChain: n4 } = useWalletConnector(), { state: e2, account: r3 } = useAccount(), { walletName: a2, address: s2 } = useMemo(() => {
    var _a3;
    let i = e2.address;
    return (n4 == null ? void 0 : n4.id) && ABSTRACT_CHAIN_ID_MAP.has(parseInt(n4 == null ? void 0 : n4.id)) && (i = (_a3 = r3.getAdditionalInfo()) == null ? void 0 : _a3.AGWAddress), { walletName: o2 == null ? void 0 : o2.label, address: Pt$2(i) };
  }, [o2, e2, r3, n4]);
  return jsxs(z$3, { justify: "between", children: [jsx(Q$1, { size: "sm", intensity: 98, children: t("transfer.web3Wallet") }), jsxs(z$3, { gapX: 1, children: [jsx(cp, { size: "xs", name: a2 ?? "" }), jsx(Q$1, { size: "sm", intensity: 54, children: s2 })] })] });
};
var ce$6 = () => {
  let { t } = ne$6(), { appIcons: o2 } = or$3(), n4 = useConfig("brokerName"), e2 = useMemo(() => {
    let { secondary: r3 } = o2 || {};
    if (!(r3 == null ? void 0 : r3.img) && (r3 == null ? void 0 : r3.component)) return null;
    if (r3 == null ? void 0 : r3.img) return jsx("img", { src: r3 == null ? void 0 : r3.img, className: "oui-w-5 oui-h-5" });
    if (r3 == null ? void 0 : r3.component) return jsx(Fragment$1, { children: r3.component });
  }, [o2]);
  return jsxs(z$3, { justify: "between", children: [jsx(Q$1, { size: "sm", intensity: 98, children: t("transfer.brokerAccount", { brokerName: n4 }) }), e2] });
};
var pe$2 = (t) => {
  let { amount: o2, maxQuantity: n4, token: e2, loading: r3 } = t, { t: a2 } = ne$6(), s2 = (e2 == null ? void 0 : e2.display_name) || (e2 == null ? void 0 : e2.symbol) || "", i = (e2 == null ? void 0 : e2.precision) ?? 2;
  return jsxs(z$3, { justify: "between", px: 2, children: [jsxs(Q$1, { size: "2xs", intensity: 36, children: ["$", jsx(Q$1.numeral, { dp: 2, padding: false, rm: g$6.ROUND_DOWN, children: o2 })] }), jsxs(z$3, { gapX: 2, children: [jsxs(Q$1, { size: "2xs", intensity: 36, children: [`${a2("common.available")}: `, jsx(Q$1.numeral, { rm: g$6.ROUND_DOWN, dp: i, padding: false, "data-testid": "oui-testid-withdraw_deposit-dialog-available-value", children: n4 }), ` ${s2}`] }), r3 && jsx(Ie$4, { size: "sm" }), jsx(Q$1, { size: "2xs", color: "primary", className: "oui-cursor-pointer oui-select-none", onClick: t.onClick, children: a2("common.max") })] })] });
};
var Le$3 = (t) => {
  let { token: o2, dst: n4, price: e2 } = t, r3 = (o2 == null ? void 0 : o2.display_name) || (o2 == null ? void 0 : o2.symbol) || "USDC";
  return jsx(z$3, { children: jsxs(Q$1, { size: "xs", intensity: 36, className: t.className, children: [jsx(Q$1, { size: "xs", intensity: 80, children: "1" }), ` ${r3} = `, e2 ? jsx(Q$1.numeral, { size: "xs", intensity: 80, dp: 3, padding: false, children: e2 }) : "-", ` ${n4 == null ? void 0 : n4.symbol}`] }) });
};
var He$2 = (t) => {
  let { dstGasFee: o2, feeQty: n4, feeAmount: e2, dp: r3, nativeSymbol: a2 } = t, { t: s2 } = ne$6(), i = () => {
    let m2 = jsxs("div", { className: "oui-text-2xs", children: [jsxs(z$3, { gapX: 1, children: [jsx(Q$1, { intensity: 54, children: `${s2("transfer.deposit.destinationGasFee")}: ` }), jsx(Q$1.numeral, { intensity: 80, dp: r3, rm: g$6.ROUND_UP, padding: false, children: n4 }), jsx(Q$1, { intensity: 54, children: a2 })] }), jsx(W$2, { mt: 2, children: jsx(Q$1, { intensity: 36, children: s2("transfer.deposit.destinationGasFee.description") }) })] });
    vo$4.alert({ title: s2("common.fee"), message: m2 });
  }, l2 = !!o2 && o2 !== "0";
  return jsxs(Q$1, { size: "xs", intensity: 36, className: "oui-border-dashed oui-border-b oui-border-line-12 oui-cursor-pointer", onClick: i, children: [`${s2("common.fee")}  `, jsxs(Q$1, { size: "xs", intensity: 80, children: ["$", jsx(Q$1.numeral, { dp: 2, padding: false, rm: g$6.ROUND_UP, children: e2 }), " "] }), l2 && jsxs("span", { children: ["(", jsxs(Q$1, { intensity: 54, children: [jsx(Q$1.numeral, { dp: r3, padding: false, rm: g$6.ROUND_UP, children: n4 }), a2] }), ")"] })] });
};
var Xe$4 = ((e2) => (e2[e2.Deposit = 0] = "Deposit", e2[e2.Approve = 1] = "Approve", e2[e2.Increase = 2] = "Increase", e2))(Xe$4 || {});
var Ye$4 = (t) => {
  let { disabled: o2, loading: n4, actionType: e2, symbol: r3 = "USDC", onDeposit: a2, onApprove: s2, networkId: i } = t, { t: l2 } = ne$6(), m2 = useMemo(() => ({ 1: { children: l2("transfer.deposit.approve.symbol", { symbol: r3 }), onClick: s2, disabled: false, "data-testid": "oui-testid-deposit-dialog-approve-btn" }, 2: { children: l2("transfer.deposit.increase.symbol", { symbol: r3 }), onClick: s2, "data-testid": "oui-testid-deposit-dialog-increase-btn" }, 0: { children: l2("common.deposit"), onClick: a2, "data-testid": "oui-testid-deposit-dialog-deposit-btn" } })[e2], [s2, a2, e2, r3, l2]), c = { initial: "md", lg: "lg" };
  return jsx(W$2, { className: "oui-w-full lg:oui-w-auto lg:oui-min-w-[184px]", children: jsx(S, { status: AccountStatusEnum.EnableTrading, networkId: i, buttonProps: { fullWidth: true, size: c }, children: jsx($e$6, { fullWidth: true, disabled: o2, loading: n4, size: c, ...m2 }) }) });
};
var Ke$6 = (t) => {
  let { token: o2, tokens: n4, onTokenChange: e2, amount: r3, quantity: a2, maxQuantity: s2, onQuantityChange: i, hintMessage: l2, inputStatus: m2, chains: c, currentChain: p2, settingChain: f2, onChainChange: b2, actionType: h2, onDeposit: d2, onApprove: w4, fetchBalance: k2, dst: v3, wrongNetwork: S2, balanceRevalidating: D2, loading: A2, disabled: I2, networkId: F3, fee: W2 } = t;
  return jsxs(W$2, { id: "oui-deposit-form", className: Ra({ weight: "semibold" }), children: [jsxs(W$2, { className: "oui-mb-6 lg:oui-mb-8", children: [jsx(ue$4, {}), jsxs(W$2, { mt: 3, mb: 1, children: [jsx(ae$2, { chains: c, value: p2, onValueChange: b2, wrongNetwork: S2, loading: f2 }), jsx($$2, { classNames: { root: "oui-mt-[2px] oui-rounded-t-sm oui-rounded-b-xl" }, value: a2, onValueChange: i, tokens: n4, token: o2, onTokenChange: e2, status: m2, hintMessage: l2, fetchBalance: k2, "data-testId": "oui-testid-deposit-dialog-quantity-input" })] }), jsx(pe$2, { token: o2, amount: r3, maxQuantity: s2, loading: D2, onClick: () => {
    i(s2);
  } }), jsx(le$4, {}), jsx(ce$6, {}), jsx($$2, { readOnly: true, token: v3, value: a2, classNames: { root: "oui-mt-3 oui-border-transparent focus-within:oui-outline-transparent" } }), jsxs(z$3, { direction: "column", mt: 1, gapY: 1, itemAlign: "start", children: [jsx(Le$3, { token: o2, dst: v3, price: 1 }), jsx(He$2, { ...W2 })] })] }), jsx(z$3, { justify: "center", children: jsx(Ye$4, { actionType: h2, symbol: o2 == null ? void 0 : o2.symbol, disabled: I2, loading: A2, onDeposit: d2, onApprove: w4, networkId: F3 }) })] });
};
function Je$4(t) {
  let { isNativeToken: o2, allowance: n4, quantity: e2, maxQuantity: r3 } = t;
  return useMemo(() => {
    let s2 = o2 ? Number.MAX_VALUE : Number(n4);
    if (s2 <= 0) return 1;
    let i = Number(e2), l2 = Number(r3);
    return s2 < i && i <= l2 ? 2 : 0;
  }, [o2, n4, e2, r3]);
}
function tt$2() {
  let { t } = ne$6(), o2 = useConfig("networkId"), [n4] = useLocalStorage("orderly_link_device", {}), { connectedChain: e2, settingChain: r3, setChain: a2 } = useWalletConnector(), [s2, { findByChainId: i }] = useChains(o2, { pick: "network_infos", filter: (c) => {
    var _a3, _b2;
    return ((_a3 = c.network_infos) == null ? void 0 : _a3.bridge_enable) || ((_b2 = c.network_infos) == null ? void 0 : _b2.bridgeless);
  } }), l2 = useMemo(() => {
    let c = e2 ? N$5(e2.id) : parseInt(n4 == null ? void 0 : n4.chainId);
    if (!c) return null;
    let p2 = i(c);
    return { ...e2, id: c, info: p2 };
  }, [i, e2, n4]), m2 = useCallback(async (c) => {
    var _a3, _b2;
    let p2 = i(c.chain_id);
    if (e2) return !p2 || ((_a3 = p2.network_infos) == null ? void 0 : _a3.chain_id) === (l2 == null ? void 0 : l2.id) ? Promise.resolve() : a2({ chainId: B$7(Number((_b2 = p2.network_infos) == null ? void 0 : _b2.chain_id)) }).then((f2) => {
      f2 ? toast$2.success(t("connector.networkSwitched")) : toast$2.error(t("connector.switchChain.failed"));
    }).catch((f2) => {
      f2 && f2.message && toast$2.error(`${t("connector.switchChain.failed")}: ${f2.message}`);
    });
  }, [l2, a2, i]);
  return { chains: s2, currentChain: l2, settingChain: r3, onChainChange: m2 };
}
function nt$1(t) {
  let { quantity: o2, allowance: n4, approve: e2, deposit: r3, enableCustomDeposit: a2, customDeposit: s2, onSuccess: i } = t, [l2, m2] = useState(false), c = useEventEmitter(), { t: p2 } = ne$6(), f2 = useCallback(async () => {
    if (!l2) return m2(true), e2(o2).then((d2) => {
      toast$2.success(p2("transfer.deposit.approve.success"));
    }).catch((d2) => {
      toast$2.error(d2.message || d2.errorCode || p2("transfer.deposit.approve.failed"));
    }).finally(() => {
      m2(false);
    });
  }, [e2, l2, o2, n4, p2]), b2 = useCallback(async () => r3().then((d2) => {
    toast$2.success(p2("transfer.deposit.requested")), c.emit("deposit:requested"), i == null ? void 0 : i();
  }).catch((d2) => {
    toast$2.error(d2.message || d2.errorCode || p2("transfer.deposit.failed"));
  }), [r3, i, p2]), h2 = useCallback(() => {
    var _a3, _b2;
    let d2 = Number(o2);
    if (isNaN(d2) || d2 <= 0) {
      toast$2.error(p2("transfer.quantity.invalid"));
      return;
    }
    if (l2) return;
    m2(true), (_b2 = (_a3 = a2 ? s2 : b2) == null ? void 0 : _a3()) == null ? void 0 : _b2.finally(() => {
      m2(false);
    });
  }, [o2, l2, b2, a2, s2, p2]);
  return { submitting: l2, onApprove: f2, onDeposit: h2 };
}
function rt$1(t) {
  let { quantity: o2, maxQuantity: n4 } = t, { t: e2 } = ne$6(), [r3, a2] = useState("default"), [s2, i] = useState();
  return useEffect(() => {
    if (!o2) {
      a2("default"), i("");
      return;
    }
    new g$6(o2).gt(n4) ? (a2("error"), i(e2("transfer.insufficientBalance"))) : (a2("default"), i(""));
  }, [o2, n4]), { inputStatus: r3, hintMessage: s2 };
}
function it$4(t) {
  let { currentChain: o2, tokensFilter: n4 } = t, [e2, r3] = useState(), [a2, s2] = useState([]), i = useCallback((l2) => {
    var _a3;
    if (l2 && ((_a3 = l2 == null ? void 0 : l2.token_infos) == null ? void 0 : _a3.length) > 0) {
      let m2 = typeof n4 == "function" ? n4(l2) : l2.token_infos;
      s2(m2);
      let c = Dt$5(m2);
      if (!c) return;
      r3(c);
    }
  }, [n4]);
  return useEffect(() => {
    i(o2 == null ? void 0 : o2.info);
  }, [o2 == null ? void 0 : o2.id, i]), { token: e2, tokens: a2, onTokenChange: r3 };
}
var at$2 = (t) => {
  var _a3;
  let { wrongNetwork: o2 } = L$3(), n4 = useConfig("networkId"), { chains: e2, currentChain: r3, settingChain: a2, onChainChange: s2 } = tt$2(), { token: i, tokens: l2, onTokenChange: m2 } = it$4({ currentChain: r3 }), { dst: c, balance: p2, allowance: f2, depositFeeRevalidating: b2, depositFee: h2, quantity: d2, setQuantity: w4, approve: k2, deposit: v3, isNativeToken: S2, balanceRevalidating: D2, fetchBalance: A2 } = useDeposit({ address: i == null ? void 0 : i.address, decimals: i == null ? void 0 : i.decimals, srcChainId: r3 == null ? void 0 : r3.id, srcToken: i == null ? void 0 : i.symbol }), I2 = useMemo(() => new g$6(p2 || 0).todp((i == null ? void 0 : i.precision) ?? 2, g$6.ROUND_DOWN).toString(), [p2, i]), { inputStatus: F3, hintMessage: W2 } = rt$1({ quantity: d2, maxQuantity: I2 }), U2 = () => {
    w4("");
  }, Q2 = useCallback(() => {
    var _a4;
    U2(), (_a4 = t.onClose) == null ? void 0 : _a4.call(t);
  }, [t.onClose]), { submitting: G2, onApprove: ne2, onDeposit: g2 } = nt$1({ quantity: d2, allowance: f2, approve: k2, deposit: v3, onSuccess: Q2 }), V2 = G2 || b2, q2 = !d2 || Number(d2) === 0 || !i || F3 === "error" || b2, We3 = useMemo(() => new g$6(d2 || 0).mul(1).toNumber(), [d2]), dt2 = Je$4({ isNativeToken: S2, allowance: f2, quantity: d2, maxQuantity: I2 }), B2 = Gn({ nativeToken: (_a3 = r3 == null ? void 0 : r3.info) == null ? void 0 : _a3.nativeToken, depositFee: h2 });
  return useEffect(() => {
    U2();
  }, [i, r3 == null ? void 0 : r3.id]), { token: i, tokens: l2, onTokenChange: m2, amount: We3, quantity: d2, maxQuantity: I2, onQuantityChange: w4, hintMessage: W2, inputStatus: F3, chains: e2, currentChain: r3, settingChain: a2, onChainChange: s2, actionType: dt2, onDeposit: g2, onApprove: ne2, fetchBalance: A2, dst: c, wrongNetwork: o2, balanceRevalidating: D2, loading: V2, disabled: q2, networkId: n4, fee: B2 };
};
function Gn(t) {
  let { nativeToken: o2, depositFee: n4 = 0 } = t, { account: e2 } = useAccount(), r3 = o2 == null ? void 0 : o2.symbol, { data: a2 } = useIndexPrice(`SPOT_${r3}_USDC`);
  return { ...useMemo(() => {
    var _a3;
    let i = new g$6(n4.toString()).div(new g$6(10).pow(((_a3 = e2.walletAdapter) == null ? void 0 : _a3.chainNamespace) === ChainNamespace.solana ? 9 : 18)).toString(), l2 = new g$6(i).mul(a2 || 0).toString();
    return { dstGasFee: i, feeQty: i, feeAmount: l2, dp: Wt$1(4) };
  }, [n4, a2]), nativeSymbol: r3 };
}
var Fe$4 = (t) => {
  let o2 = at$2(t);
  return jsx(Ke$6, { ...o2 });
};
var qt$4 = ({ checkIsBridgeless: t, quantity: o2, chainVaultBalance: n4, currentChain: e2, maxAmount: r3, crossChainTrans: a2 }) => {
  let { t: s2 } = ne$6(), { wrongNetwork: i } = L$3(), { state: l2 } = useAccount(), m2 = useMemo(() => {
    if (e2 && e2.info && e2.info.network_infos) return e2.info.network_infos.name;
  }, [e2]), c = useMemo(() => !n4 || !r3 || !o2 || new g$6(o2).gt(r3) ? false : !!new g$6(o2).gt(n4), [o2, n4]), f2 = (() => {
    if (l2.status !== AccountStatusEnum.NotConnected) {
      if (i || !t) return jsx(W$2, { children: m2 ? s2("transfer.withdraw.unsupported.networkName", { networkName: m2 }) : s2("transfer.withdraw.unsupported.chain") });
      if (a2) return s2("transfer.withdraw.crossChain.process");
      if (c) return s2("transfer.withdraw.crossChain.vaultWarning", { networkName: m2, chainVaultBalance: n4 });
    }
  })();
  return f2 ? jsx(z$3, { className: "oui-text-warning-darken oui-text-xs oui-justify-center oui-text-center", mb: 3, children: f2 }) : null;
};
var Lt$2 = ({ hasPositions: t, unsettledPnl: o2, onSettlle: n4 }) => {
  let { t: e2 } = ne$6();
  if (o2 === 0 && !t) return jsx(Fragment$1, {});
  let r3 = () => {
    vo$4.confirm({ title: e2("settle.settlePnl"), content: jsx(Trans, { i18nKey: "settle.settlePnl.description" }), onOk: () => n4() });
  };
  return jsxs(z$3, { justify: "between", className: "oui-text-2xs oui-text-base-contrast-36 oui-mt-1 oui-mx-2", children: [jsxs(z$3, { itemAlign: "center", justify: "start", gap: 1, children: [jsx(xs, { className: "oui-max-w-[274px]", content: e2("settle.unsettled.tooltip"), children: jsxs(z$3, { itemAlign: "center", justify: "start", gap: 1, children: [jsx(xn, { size: 14, className: "oui-text-warning-darken" }), jsx(Q$1, { className: "oui-border-dashed oui-border-b oui-border-line-12 oui-cursor-pointer", children: `${e2("settle.unsettled")}:` })] }) }), jsx(Q$1.numeral, { showIdentifier: true, coloring: true, weight: "semibold", dp: 6, "data-testid": "oui-testid-withdraw-dialog-unsettledPnl-value", children: o2 }), jsx(Q$1, { children: "USDC" })] }), jsxs(z$3, { itemAlign: "center", gap: 1, className: "oui-cursor-pointer", children: [jsx(At$1, { className: "oui-text-primary" }), jsx(Q$1, { "data-testid": "oui-testid-withdraw-dialog-settle-text", size: "2xs", color: "primary", className: " oui-select-none", onClick: r3, children: e2("common.settle") })] })] });
};
var $t$2 = ({ address: t, amount: o2, currentChain: n4 }) => {
  let { t: e2 } = ne$6(), r3 = useMemo(() => {
    if (n4 && n4.info && n4.info.network_infos) return n4.info.network_infos.name;
  }, [n4]);
  return jsxs(z$3, { direction: "column", itemAlign: "start", justify: "start", className: "oui-gap-1 lg:oui-gap-3", children: [jsxs(z$3, { direction: "column", itemAlign: "start", mb: 5, className: "oui-gap-3 lg:oui-gap-4", children: [jsxs(z$3, { direction: "column", justify: "start", itemAlign: "start", children: [jsx(Q$1, { size: "2xs", intensity: 36, children: e2("transfer.withdraw.crossChain.recipientAddress") }), jsx(Q$1, { size: "sm", intensity: 98, className: "oui-break-all", children: t })] }), jsxs(z$3, { direction: "column", justify: "start", itemAlign: "start", children: [jsx(Q$1, { size: "2xs", intensity: 36, children: e2("transfer.withdraw.crossChain.recipientNetwork") }), jsxs(z$3, { gap: 1, children: [jsx(Fr$1, { className: "oui-h-[18px] oui-w-[18px]", size: "sm", chainId: n4.id }), jsx(Q$1, { size: "sm", intensity: 98, children: r3 })] })] }), jsxs(z$3, { direction: "column", justify: "start", itemAlign: "start", children: [jsx(Q$1, { size: "2xs", intensity: 36, children: `${e2("transfer.withdraw.crossChain.withdrawAmount")} (USDC)` }), jsx(Q$1.numeral, { size: "sm", intensity: 98, dp: 2, children: o2 })] })] }), jsx(z$3, { justify: "center", className: "oui-text-warning-darken oui-text-2xs lg:oui-text-xs oui-text-center", mb: 3, children: e2("transfer.withdraw.crossChain.warning") })] });
};
function lt$3(t) {
  let { t: o2 } = ne$6(), n4 = () => {
    vo$4.show(F$2, { networkId: t.networkId, bridgeLessOnly: true }).then((e2) => {
      toast$2.success(o2("connector.networkSwitched"));
    }, (e2) => {
    });
  };
  return jsx(z$3, { direction: "column", children: jsx($e$6, { color: "warning", size: t.size, fullWidth: true, onClick: () => {
    n4();
  }, children: o2("connector.switchNetwork") }) });
}
var Xt$3 = (t) => {
  let { disabled: o2, loading: n4, onWithdraw: e2, networkId: r3, crossChainWithdraw: a2, address: s2, currentChain: i, quantity: l2, fee: m2, checkIsBridgeless: c } = t, { t: p2 } = ne$6(), f2 = useMemo(() => l2 ? new g$6(l2).minus(m2 ?? 0).toNumber() : 0, [l2, m2]), b2 = () => {
    if (a2) {
      vo$4.confirm({ title: p2("transfer.withdraw.crossChain.confirmWithdraw"), content: jsx($t$2, { address: s2, amount: f2, currentChain: i }), classNames: { content: "oui-font-semibold", body: "!oui-pb-0", footer: "!oui-pt-0" }, onOk: async () => {
        e2();
      } });
      return;
    }
    e2();
  }, h2 = { initial: "md", lg: "lg" };
  return jsx(W$2, { className: "oui-w-full lg:oui-w-auto lg:oui-min-w-[184px]", children: jsx(S, { status: AccountStatusEnum.EnableTrading, networkId: r3, bridgeLessOnly: true, buttonProps: { fullWidth: true, size: h2 }, children: c ? jsx($e$6, { "data-testid": "oui-testid-withdraw-dialog-withdraw-btn", fullWidth: true, disabled: o2, loading: n4, onClick: b2, size: h2, children: p2("common.withdraw") }) : jsx(lt$3, { networkId: r3, size: h2 }) }) });
};
var ct$2 = ({ address: t, loading: o2, disabled: n4, quantity: e2, onQuantityChange: r3, token: a2, inputStatus: s2, hintMessage: i, amount: l2, maxQuantity: m2, balanceRevalidating: c, chains: p2, currentChain: f2, onChainChange: b2, fee: h2, settingChain: d2, wrongNetwork: w4, hasPositions: k2, unsettledPnL: v3, onSettlePnl: S2, onWithdraw: D2, chainVaultBalance: A2, crossChainWithdraw: I2, crossChainTrans: F3, showQty: W2, networkId: U2, checkIsBridgeless: Q2 }) => {
  let { t: G2 } = ne$6();
  return jsxs(W$2, { id: "oui-withdraw-form", className: Ra({ weight: "semibold" }), children: [jsxs(W$2, { className: "oui-mb-6 lg:oui-mb-8", children: [jsx(ce$6, {}), jsx(W$2, { mt: 3, mb: 1, children: jsx($$2, { value: e2, onValueChange: r3, token: a2, onTokenChange: () => {
  }, status: s2, hintMessage: i, testId: "oui-testid-withdraw-dialog-quantity-input" }) }), jsx(pe$2, { token: a2, amount: l2, maxQuantity: m2.toString(), loading: c, onClick: () => {
    r3(m2.toString());
  } }), jsx(Lt$2, { unsettledPnl: v3, hasPositions: k2, onSettlle: S2 }), jsx(le$4, {}), jsx(ue$4, {}), jsxs(W$2, { mt: 3, children: [jsx(ae$2, { chains: p2, value: f2, onValueChange: b2, wrongNetwork: w4, loading: d2 }), jsx($$2, { classNames: { root: "oui-mt-[2px] oui-rounded-t-sm oui-rounded-b-xl" }, token: a2, value: W2, readOnly: true })] }), jsx(z$3, { direction: "column", mt: 1, gapY: 1, itemAlign: "start", children: jsxs(Q$1, { size: "xs", intensity: 36, children: [`${G2("common.fee")}  `, jsx(Q$1, { size: "xs", intensity: 80, children: `${h2} ` }), jsx(Q$1, { children: "USDC" })] }) })] }), jsx(qt$4, { checkIsBridgeless: Q2, chainVaultBalance: A2, currentChain: f2, quantity: e2, maxAmount: m2, crossChainTrans: F3 }), jsx(z$3, { justify: "center", children: jsx(Xt$3, { checkIsBridgeless: Q2, networkId: U2, disabled: n4, loading: o2, onWithdraw: D2, crossChainWithdraw: I2, currentChain: f2, address: t, quantity: e2, fee: h2 }) })] });
};
var Jt$4 = 1, mt$1 = ({ onClose: t }) => {
  let { t: o2 } = ne$6(), [n4] = usePositionStream(), [e2, r3] = useState(false), [a2, s2] = useState(false), { data: i } = usePrivateQuery("/v1/asset/history", { revalidateOnMount: true }), l2 = useConfig("networkId"), m2 = useEventEmitter(), [c, p2] = useState(""), [f2, b2] = useState({ symbol: "USDC", decimals: 6, address: "", display_name: "", precision: 6 }), [h2, d2] = useState("default"), [w4, k2] = useState(), { wrongNetwork: v3 } = L$3(), { account: S2 } = useAccount(), [D2] = useLocalStorage("orderly_link_device", {}), { data: A2 } = useQuery("/v1/public/vault_balance", { revalidateOnMount: true }), { connectedChain: I2, wallet: F3, setChain: W2, settingChain: U2 } = useWalletConnector();
  useConfig();
  let { walletName: G2, address: ne2 } = useMemo(() => {
    var _a3;
    return { walletName: F3 == null ? void 0 : F3.label, address: (_a3 = F3 == null ? void 0 : F3.accounts) == null ? void 0 : _a3[0].address };
  }, [F3]), g2 = (u2) => {
    p2(u2);
  }, V2 = useMemo(() => new g$6(c || 0).mul(Jt$4).toNumber(), [c, Jt$4]), { dst: q2, withdraw: We3, maxAmount: B2, unsettledPnL: ge2 } = useWithdraw(), [so2, L2] = useState(true), [Be2, { findByChainId: we2 }] = useChains(l2, { pick: "network_infos", filter: (u2) => {
    var _a3, _b2;
    return ((_a3 = u2.network_infos) == null ? void 0 : _a3.bridge_enable) || ((_b2 = u2.network_infos) == null ? void 0 : _b2.bridgeless);
  } }), re2 = useMemo(() => l2 === "mainnet" ? Be2.filter((u2) => u2.bridgeless) : Be2, [Be2, l2]), { configStore: ao2 } = useContext(OrderlyContext), lo2 = ao2.get("apiBaseUrl"), { data: ft2 } = useQuery(`${lo2}/v1/public/token?t=withdraw`, { revalidateIfStale: false, revalidateOnFocus: false, revalidateOnReconnect: false, revalidateOnMount: true, dedupingInterval: 36e5, formatter: (u2) => {
    if (u2.rows.length === 1) return u2.rows[0].chain_details;
  } }), C2 = useMemo(() => {
    let u2 = I2 ? N$5(I2.id) : parseInt(D2 == null ? void 0 : D2.chainId);
    if (!u2) return null;
    let T2 = we2(u2);
    return { ...I2, id: u2, info: T2 };
  }, [we2, I2, D2]), uo2 = useMemo(() => v3 || !C2 ? false : l2 === "testnet" ? true : !(!C2.info || !C2.info.network_infos || !C2.info.network_infos.bridgeless), [C2, v3]), co2 = () => {
    p2("");
  }, mo2 = useCallback(async (u2) => {
    var _a3, _b2;
    let T2 = we2(u2.chain_id);
    return !T2 || ((_a3 = T2.network_infos) == null ? void 0 : _a3.chain_id) === (C2 == null ? void 0 : C2.id) ? Promise.resolve() : W2 == null ? void 0 : W2({ chainId: B$7(Number((_b2 = T2.network_infos) == null ? void 0 : _b2.chain_id)) }).then((ie2) => {
      ie2 ? (toast$2.success(o2("connector.networkSwitched")), co2()) : toast$2.error(o2("connector.switchChain.failed"));
    }).catch((ie2) => {
      toast$2.error(`${o2("connector.switchChain.failed")}: ${ie2.message}`);
    });
  }, [C2, W2, we2, o2]), po2 = useMemo(() => {
    var _a3;
    return ((_a3 = n4 == null ? void 0 : n4.rows) == null ? void 0 : _a3.length) > 0;
  }, [n4]), fo2 = async () => S2.settle().catch((u2) => (u2.code == -1104 && toast$2.error(o2("settle.settlement.error")), u2.message.indexOf("Signing off chain messages with Ledger is not yet supported") !== -1 && m2.emit("wallet:sign-message-with-ledger-error", { message: u2.message, userAddress: S2.address }), u2.message.indexOf("user rejected") !== -1 && toast$2.error(o2("transfer.rejectTransaction")), Promise.reject(u2))).then((u2) => (toast$2.success(o2("settle.settlement.requested")), Promise.resolve(u2))), xe2 = useMemo(() => {
    if (!A2 || !C2) return null;
    let u2 = A2.find((T2) => parseInt(T2.chain_id) === (C2 == null ? void 0 : C2.id));
    return u2 ? u2.balance : null;
  }, [re2, C2, A2]), be2 = useMemo(() => {
    if (xe2 !== null) {
      let u2 = parseFloat(c);
      return u2 > xe2 && u2 <= B2;
    }
    return false;
  }, [c, B2, xe2]), ht2 = useMemo(() => re2.minimum_withdraw_amount ?? 1, [re2]), ho2 = async () => {
    if (!a2 && h2 === "default") {
      if (new g$6(c).lt(ht2)) {
        toast$2.error(o2("transfer.withdraw.minAmount.error", { minAmount: ht2 }));
        return;
      }
      return s2(true), We3({ amount: c, token: "USDC", chainId: C2 == null ? void 0 : C2.id, allowCrossChainWithdraw: be2 }).then((u2) => {
        toast$2.success(o2("transfer.withdraw.requested")), m2.emit("withdraw:requested"), t && t(), p2("");
      }).catch((u2) => {
        if (u2.message.indexOf("user rejected") !== -1) {
          toast$2.error(o2("transfer.rejectTransaction"));
          return;
        }
        if (u2.message.indexOf("Signing off chain messages with Ledger is not yet supported") !== -1) {
          m2.emit("wallet:sign-message-with-ledger-error", { message: u2.message, userAddress: S2.address });
          return;
        }
        toast$2.error(u2.message);
      }).finally(() => {
        s2(false);
      });
    }
  }, _e3 = useMemo(() => {
    if (!C2) return 0;
    let u2 = ft2 == null ? void 0 : ft2.find((T2) => parseInt(T2.chain_id) === C2.id);
    return u2 ? be2 ? (u2.withdrawal_fee || 0) + (u2.cross_chain_withdrawal_fee || 0) : u2.withdrawal_fee || 0 : 0;
  }, [C2, ft2, re2, be2]), go2 = useMemo(() => {
    if (!c) return "";
    let u2 = new g$6(c).sub(_e3 ?? 0);
    return u2.isNegative() ? "" : u2.toNumber();
  }, [_e3, c]);
  return useEffect(() => {
    if (e2 && L2(true), !c) {
      d2("default"), k2(""), L2(true);
      return;
    }
    let u2 = new g$6(c ?? 0);
    ge2 < 0 ? u2.gt(B2) ? (d2("error"), k2(o2("transfer.insufficientBalance")), L2(true)) : (d2("default"), k2(""), L2(false)) : u2.gt(B2) ? (d2("error"), k2(o2("transfer.insufficientBalance")), L2(true)) : u2.gt(new g$6(B2).minus(ge2)) && u2.lessThanOrEqualTo(B2) ? (d2("warning"), k2(o2("settle.settlePnl.warning")), L2(true)) : (d2("default"), k2(""), L2(false));
  }, [c, B2, ge2, e2]), useEffect(() => {
    let u2 = i == null ? void 0 : i.find((T2) => T2.trans_status === "pending_rebalance".toUpperCase());
    r3(!!u2);
  }, [i]), useWalletSubscription({ onMessage(u2) {
    if (!e2) return;
    let { trxId: T2, transStatus: ie2 } = u2;
    T2 === e2 && ie2 === "COMPLETED" && r3(false);
  } }), { walletName: G2, address: ne2, quantity: c, onQuantityChange: g2, token: f2, inputStatus: h2, hintMessage: w4, dst: q2, amount: V2, balanceRevalidating: false, maxQuantity: B2, disabled: so2, loading: a2, hasPositions: po2, unsettledPnL: ge2, wrongNetwork: v3, settingChain: U2, chains: re2, currentChain: C2, onChainChange: mo2, onSettlePnl: fo2, onWithdraw: ho2, chainVaultBalance: xe2, fee: _e3, crossChainWithdraw: be2, crossChainTrans: e2, showQty: go2, networkId: l2, checkIsBridgeless: uo2 };
};
var pt$5 = (t) => {
  let o2 = mt$1({ onClose: t.close });
  return jsx(ct$2, { ...o2 });
};
var to$3 = (t) => jsx(bi$2, { position: Yt$1.DepositForm, defaultWidget: Fe$4, ...t });
var Hr$4 = "DepositAndWithdrawWithDialogId", Xr$1 = "DepositAndWithdrawWithSheetId", ro$1 = (t) => {
  let [o2, n4] = useState(t.activeTab || "deposit"), { t: e2 } = ne$6();
  return jsxs(jl, { value: o2, onValueChange: n4, variant: "contained", size: "lg", classNames: { tabsList: "oui-px-0", tabsContent: "oui-pt-5" }, children: [jsx($l, { title: e2("common.deposit"), icon: jsx(Ft$6, {}), value: "deposit", children: jsx(to$3, { onClose: t.close }) }), jsx($l, { title: e2("common.withdraw"), icon: jsx(St$3, {}), value: "withdraw", children: jsx(pt$5, { ...t }) })] });
};
Wm(Hr$4, ro$1, { size: "md", classNames: { content: "oui-border oui-border-line-6" } });
Um(Xr$1, ro$1);
var N$1 = Object.create;
var k$1 = Object.defineProperty;
var I$1 = Object.getOwnPropertyDescriptor;
var K$1 = Object.getOwnPropertyNames;
var $$1 = Object.getPrototypeOf, M$2 = Object.prototype.hasOwnProperty;
var g$2 = (t, e2) => () => (e2 || t((e2 = { exports: {} }).exports, e2), e2.exports);
var X$1 = (t, e2, r3, o2) => {
  if (e2 && typeof e2 == "object" || typeof e2 == "function") for (let i of K$1(e2)) !M$2.call(t, i) && i !== r3 && k$1(t, i, { get: () => e2[i], enumerable: !(o2 = I$1(e2, i)) || o2.enumerable });
  return t;
};
var G$3 = (t, e2, r3) => (r3 = t != null ? N$1($$1(t)) : {}, X$1(!t || !t.__esModule ? k$1(r3, "default", { value: t, enumerable: true }) : r3, t));
var O$1 = g$2((x2) => {
  Object.defineProperty(x2, "__esModule", { value: true });
  Object.defineProperty(x2, "default", { enumerable: true, get: function() {
    return re2;
  } });
  function S2(t, e2) {
    return { handler: t, config: e2 };
  }
  S2.withOptions = function(t, e2 = () => ({})) {
    let r3 = function(o2) {
      return { __options: o2, handler: t(o2), config: e2(o2) };
    };
    return r3.__isOptionsFunction = true, r3.__pluginFunction = t, r3.__configFunction = e2, r3;
  };
  var re2 = S2;
});
var A = g$2((C2) => {
  Object.defineProperty(C2, "__esModule", { value: true });
  Object.defineProperty(C2, "default", { enumerable: true, get: function() {
    return ae2;
  } });
  var oe2 = ie2(O$1());
  function ie2(t) {
    return t && t.__esModule ? t : { default: t };
  }
  var ae2 = oe2.default;
});
var V$2 = g$2((rr2, R2) => {
  var b2 = A();
  R2.exports = (b2.__esModule ? b2 : { default: b2 }).default;
});
var v2 = () => {
  let t = document.documentElement, e2 = getComputedStyle(t);
  return { primary: u(e2.getPropertyValue("--oui-color-primary")), primaryLight: u(e2.getPropertyValue("--oui-color-primary-light")), secondary: u(e2.getPropertyValue("--oui-color-secondary")), success: u(e2.getPropertyValue("--oui-color-success")), warning: u(e2.getPropertyValue("--oui-color-warning")), danger: u(e2.getPropertyValue("--oui-color-danger")), info: u(e2.getPropertyValue("--oui-color-info")), loss: u(e2.getPropertyValue("--oui-color-trading-loss")), profit: u(e2.getPropertyValue("--oui-color-trading-profit")) };
}, u = (t) => `rgb(${t.split(" ").join(",")})`;
var f = (t) => useMemo(() => {
  let r3 = v2();
  return { profit: (t == null ? void 0 : t.profit) || r3.profit, loss: (t == null ? void 0 : t.loss) || r3.loss, primary: r3.primary, primaryLight: r3.primaryLight };
}, [t]);
var d = (t) => {
  let { label: e2, value: r3, prefix: o2, unit: i = "USDC", coloring: a2 = false, dp: n4, rm: c } = t;
  return jsxs(W$2, { intensity: 600, p: 3, r: "md", children: [jsxs(z$3, { direction: "row", className: t.titleClassName, children: [o2, jsx(Q$1.numeral, { unit: i, as: "div", size: "sm", coloring: a2, showIdentifier: a2, unitClassName: "oui-text-base-contrast-54 oui-ml-1", weight: "semibold", rm: c, dp: n4, children: r3 })] }), jsx(Q$1, { size: "2xs", intensity: 54, weight: "semibold", children: e2 })] });
};
var h = (t) => {
  let e2 = Math.abs(t), r3 = e2 === 0 ? 0 : e2 <= 10 ? 2 : e2 <= 100 ? 1 : 0, o2 = C$3(e2, r3);
  return t < 0 ? `-${o2}` : o2;
};
var at$1 = (t) => {
  let { fill: e2, x: r3, y: o2, width: i, height: a2 } = t, n4 = Math.abs(a2);
  return jsx("rect", { rx: 2, x: r3, y: a2 > 0 ? o2 : o2 + a2, width: i, height: n4, stroke: "none", fill: e2 });
}, nt = (t) => {
  let { x: e2, y: r3, stroke: o2, payload: i, index: a2, width: n4, containerWidth: c } = t, { t: z2 } = ne$6(), D2 = a2 === 0 ? 48 : c > 0 ? c - 10 : n4 + i.offset;
  return jsx("g", { transform: `translate(${D2},${r3 - 6})`, children: jsx("text", { x: 0, y: 0, dy: 16, textAnchor: a2 === 0 ? "start" : "end", fontSize: 10, fill: "rgba(255,255,255,0.54)", children: a2 === 0 ? i.value : z2("chart.now") }) });
}, lt$2 = (t) => {
  let { width: e2, height: r3, stroke: o2, fill: i } = t;
  return jsx(Cross, { x: t.x + t.width / 2, top: t.top, height: r3, width: 1, stroke: "rgba(255,255,255,0.16)", strokeDasharray: "3 2", fill: "none" });
}, st = (t) => {
  let { active: e2, payload: r3, label: o2 } = t, i = useRef((/* @__PURE__ */ new Date()).toISOString().split("T")[0]), { t: a2 } = ne$6();
  return e2 && r3 && r3.length ? jsx(d, { label: o2 === i.current ? a2("chart.now") : o2, value: r3[0].value, coloring: true }) : null;
}, ct$1 = (t) => {
  let { invisible: e2 } = t, r3 = f(t.colors), o2 = useRef(0);
  return jsx(ResponsiveContainer, { className: cnBase(e2 && "chart-invisible"), onResize: (i, a2) => {
    o2.current = i;
  }, children: jsxs(BarChart, { data: t.data, margin: { left: -10, top: 10, right: 10, bottom: 30 }, children: [!e2 && jsx(Tooltip, { cursor: jsx(lt$2, {}), content: jsx(st, {}) }), jsx(CartesianGrid, { vertical: false, stroke: "#FFFFFF", strokeOpacity: 0.04 }), jsx(ReferenceLine, { y: 0, stroke: "rgba(0,0,0,0.04)" }), !e2 && jsx(Bar, { dataKey: "pnl", shape: jsx(at$1, {}), children: t.data.map((i, a2) => jsx(Cell, { fill: i.pnl > 0 ? r3.profit : r3.loss }, `cell-${a2}`)) }), jsx(YAxis, { tick: { fontSize: 10, fill: "rgba(255,255,255,0.54)" }, tickFormatter: (i) => h(i), tickLine: false, axisLine: false, dataKey: "pnl" }), jsx(XAxis, { dataKey: "date", tickLine: false, interval: t.data.length - 2, height: 1, tick: jsx(nt, { containerWidth: o2.current }), stroke: "#FFFFFF", strokeOpacity: 0.04 })] }) });
};
var y = (t) => {
  let { x: e2, y: r3, stroke: o2, payload: i, index: a2 } = t, { t: n4 } = ne$6();
  return jsx("g", { transform: `translate(${e2},${r3 - 6})`, children: jsx("text", { x: 0, y: 0, dy: 16, textAnchor: "end", fontSize: 10, fill: "rgba(255,255,255,0.54)", children: a2 === 0 ? i.value : n4("chart.now") }) });
};
var vt$2 = (t) => {
  let { active: e2, payload: r3, label: o2 } = t, i = useRef((/* @__PURE__ */ new Date()).toISOString().split("T")[0]), { t: a2 } = ne$6();
  return e2 && r3 && r3.length ? jsx(d, { label: o2 === i.current ? a2("chart.now") : o2, value: r3[0].value, coloring: true }) : null;
}, Ft$5 = (t) => {
  let e2 = f(t.colors), r3 = (i) => {
    let a2 = [];
    return i == null ? void 0 : i.reduce((n4, c) => (n4 += c.pnl, a2.push({ ...c, pnl: n4, _pnl: c.pnl }), n4), 0), a2;
  }, o2 = useMemo(() => r3(t.data), [t.data]);
  return jsx(ResponsiveContainer, { className: t.invisible ? "chart-invisible" : "", children: jsxs(LineChart, { data: o2, margin: { top: 20, right: 10, left: -10, bottom: 0 }, children: [jsx(CartesianGrid, { vertical: false, stroke: "#FFFFFF", strokeOpacity: 0.04 }), jsx(XAxis, { dataKey: "date", interval: t.data.length - 2, tick: jsx(y, {}), stroke: "#FFFFFF", strokeOpacity: 0.04 }), jsx(YAxis, { dataKey: "pnl", tick: { fontSize: 10, fill: "rgba(255,255,255,0.54)" }, tickLine: false, axisLine: false, tickFormatter: (i) => h(i) }), !t.invisible && jsx(Tooltip, { cursor: { strokeDasharray: "3 2", strokeOpacity: 0.16 }, content: jsx(vt$2, {}) }), !t.invisible && jsx(Line, { type: "natural", dataKey: "pnl", stroke: e2.primary, strokeWidth: 2, dot: false, isAnimationActive: false })] }) });
};
var Bt$2 = (t) => {
  let { active: e2, payload: r3, label: o2 } = t, i = useRef((/* @__PURE__ */ new Date()).toISOString().split("T")[0]), { t: a2 } = ne$6();
  return e2 && r3 && r3.length ? jsx(d, { label: o2 === i.current ? a2("chart.now") : o2, value: r3[0].value }) : null;
}, zt$2 = (t) => {
  let e2 = f(t.colors);
  return jsx(ResponsiveContainer, { className: t.invisible ? "chart-invisible" : "", children: jsxs(LineChart, { width: 530, height: 180, data: t.data, margin: { top: 20, right: 10, left: -20, bottom: -10 }, children: [jsx(CartesianGrid, { vertical: false, stroke: "#FFFFFF", strokeOpacity: 0.04 }), jsx(XAxis, { dataKey: "date", interval: t.data.length - 2, tick: jsx(y, {}), stroke: "#FFFFFF", strokeOpacity: 0.04 }), jsx(YAxis, { dataKey: "account_value", tick: { fontSize: 10, fill: "rgba(255,255,255,0.54)" }, tickLine: false, axisLine: false, tickFormatter: (r3) => h(r3) }), !t.invisible && jsx(Tooltip, { cursor: { strokeDasharray: "3 2", strokeOpacity: 0.16 }, content: jsx(Bt$2, {}) }), !t.invisible && jsx(Line, { type: "natural", dataKey: "account_value", stroke: e2.profit, strokeWidth: 2, dot: false, isAnimationActive: false })] }) });
};
G$3(V$2());
var X = (e2) => {
  let { pnl: t, hide: o2 } = e2, r3 = t == null ? void 0 : t.entity, n4 = useSymbolsInfo(), { getFirstRefCode: i } = useReferralInfo(), s2 = useMemo(() => {
    var _a3;
    let a2 = (_a3 = i()) == null ? void 0 : _a3.code;
    return { code: (t == null ? void 0 : t.refCode) ?? a2, slogan: t == null ? void 0 : t.refSlogan, link: t == null ? void 0 : t.refLink };
  }, [i, t]), c = useMemo(() => {
    if (r3) return n4[r3 == null ? void 0 : r3.symbol]("base_dp");
  }, [r3, n4]), l2 = useMemo(() => {
    if (r3) return n4[r3 == null ? void 0 : r3.symbol]("quote_dp");
  }, [r3, n4]);
  return { entity: r3, leverage: t == null ? void 0 : t.leverage, baseDp: c, quoteDp: l2, referralInfo: s2, shareOptions: t, hide: o2 };
};
function j$1(e2, t, o2, r3, n4, i, s2, c, l2) {
  let { t: a2 } = ne$6(), { symbol: u2, currency: x2 } = Xe$3(e2.symbol), f2 = { symbol: u2, currency: x2, side: e2.side };
  switch (n4) {
    case "pnl": {
      e2.pnl != null && (f2.pnl = new g$6(e2.pnl).toFixed(2, g$6.ROUND_DOWN));
      break;
    }
    case "roi": {
      e2.roi != null && (f2.ROI = new g$6(e2.roi).toFixed(2, g$6.ROUND_DOWN));
      break;
    }
    case "roi_pnl": {
      e2.pnl != null && (f2.pnl = new g$6(e2.pnl).toFixed(2, g$6.ROUND_DOWN)), e2.roi != null && (f2.ROI = new g$6(e2.roi).toFixed(2, g$6.ROUND_DOWN));
      break;
    }
  }
  let y2 = [];
  i.has("leverage") && (f2.leverage = t), ["openPrice", "closePrice", "openTime", "closeTime", "markPrice", "quantity"].forEach((P2) => {
    if (i.has(P2)) switch (P2) {
      case "leverage":
        break;
      case "openPrice": {
        e2.openPrice != null && y2.push({ title: a2("share.pnl.optionalInfo.openPrice"), value: Y$1(e2.openPrice, c || 2) });
        break;
      }
      case "closePrice": {
        e2.closePrice != null && y2.push({ title: a2("share.pnl.optionalInfo.closePrice"), value: Y$1(e2.closePrice, c || 2) });
        break;
      }
      case "openTime": {
        e2.openTime != null && y2.push({ title: a2("share.pnl.optionalInfo.openTime"), value: Pe$1(e2.openTime) });
        break;
      }
      case "closeTime": {
        e2.closeTime != null && y2.push({ title: a2("share.pnl.optionalInfo.closeTime"), value: Pe$1(e2.closeTime) });
        break;
      }
      case "markPrice": {
        e2.markPrice != null && y2.push({ title: a2("common.markPrice"), value: Y$1(e2.markPrice, c || 2) });
        break;
      }
      case "quantity":
        e2.quantity != null && y2.push({ title: a2("common.quantity"), value: Y$1(e2.quantity, s2 || 2) });
    }
  }), f2.informations = y2;
  let w4 = { position: f2, updateTime: Ye$3(/* @__PURE__ */ new Date()), domain: r3 };
  return o2.length > 0 && (w4.message = o2), typeof l2 < "u" && l2.code !== void 0 && (w4.referral = l2), w4;
}
function Xe$3(e2) {
  let t = e2.split("_");
  if (t.length !== 3) return { symbol: e2, currency: "USDC" };
  let [o2, r3, n4] = t;
  return { symbol: `${r3}-${o2}`, currency: n4 || "USDC" };
}
function Ye$3(e2) {
  var _a3, _b2, _c2, _d3, _e3;
  let t = e2 instanceof Date ? e2 : new Date(e2), o2 = { year: "numeric", month: "2-digit", day: "2-digit", hour: "2-digit", minute: "2-digit", hourCycle: "h23" }, n4 = new Intl.DateTimeFormat("en-US", o2).formatToParts(t), i = (_a3 = n4.find((u2) => u2.type === "year" ? u2.value : "")) == null ? void 0 : _a3.value, s2 = (_b2 = n4.find((u2) => u2.type === "month" ? u2.value : "")) == null ? void 0 : _b2.value, c = (_c2 = n4.find((u2) => u2.type === "day" ? u2.value : "")) == null ? void 0 : _c2.value, l2 = (_d3 = n4.find((u2) => u2.type === "hour" ? u2.value : "")) == null ? void 0 : _d3.value, a2 = (_e3 = n4.find((u2) => u2.type === "minute" ? u2.value : "")) == null ? void 0 : _e3.value;
  return `${i}-${s2}-${c} ${l2}:${a2}`;
}
function Pe$1(e2) {
  var _a3, _b2, _c2, _d3;
  let t = e2 instanceof Date ? e2 : new Date(e2), o2 = { year: "numeric", month: "short", day: "2-digit", hour: "2-digit", minute: "2-digit", hourCycle: "h23" }, n4 = new Intl.DateTimeFormat("en-US", o2).formatToParts(t), i = (_a3 = n4.find((a2) => a2.type === "month" ? a2.value : "")) == null ? void 0 : _a3.value, s2 = (_b2 = n4.find((a2) => a2.type === "day" ? a2.value : "")) == null ? void 0 : _b2.value, c = (_c2 = n4.find((a2) => a2.type === "hour" ? a2.value : "")) == null ? void 0 : _c2.value, l2 = (_d3 = n4.find((a2) => a2.type === "minute" ? a2.value : "")) == null ? void 0 : _d3.value;
  return `${i}-${s2} ${c}:${l2}`;
}
function Y$1(e2, t) {
  return new g$6(e2).toFixed(t, g$6.ROUND_DOWN);
}
function ee$1(e2, t, o2, r3) {
  localStorage.setItem("pnl_config_key", JSON.stringify({ bgIndex: o2, pnlFormat: e2, options: Array.from(t), message: r3 }));
}
function te$3() {
  let e2 = localStorage.getItem("pnl_config_key");
  if (e2 && e2.length > 0) try {
    return JSON.parse(e2);
  } catch {
  }
  return { bgIndex: 0, pnlFormat: "roi_pnl", options: ["openPrice", "closePrice", "openTime", "closeTime", "markPrice", "quantity", "leverage"], message: "" };
}
var V$1 = forwardRef((e2, t) => {
  let { width: o2, height: r3, className: n4, data: i, style: s2 } = e2, { ref: c, download: l2, toDataURL: a2, copy: u2, toBlob: x2 } = usePoster(i, { ratio: e2.ratio });
  return useImperativeHandle(t, () => ({ download: l2, toDataURL: a2, toBlob: x2, copy: u2 })), jsx("canvas", { ref: c, width: o2, height: r3, className: n4, style: s2 });
});
var Se$4 = (e2) => {
  let { children: t, ...o2 } = e2;
  return jsx("button", { ...o2, children: jsxs("svg", { width: "20", height: "20", viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsx("rect", { width: "20", height: "20", rx: "10", fill: "#333948" }), jsx("path", { d: "M11.186 5.348a.67.67 0 0 0-.436.27l-2.657 4a.69.69 0 0 0 0 .75l2.657 4a.68.68 0 0 0 .934.188.685.685 0 0 0 .187-.937L9.463 9.993 11.87 6.37a.685.685 0 0 0-.187-.938.65.65 0 0 0-.498-.083", fill: "#fff", fillOpacity: ".54" })] }) });
}, be$2 = (e2) => {
  let { children: t, ...o2 } = e2;
  return jsx("button", { ...o2, children: jsxs("svg", { width: "20", height: "20", viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsx("rect", { width: "20", height: "20", rx: "10", fill: "#333948" }), jsx("path", { d: "M8.777 5.348a.65.65 0 0 0-.498.083.685.685 0 0 0-.187.938L10.5 9.993 8.092 13.62a.685.685 0 0 0 .187.937.68.68 0 0 0 .934-.187l2.657-4a.69.69 0 0 0 0-.75l-2.657-4a.67.67 0 0 0-.436-.271", fill: "#fff", fillOpacity: ".54" })] }) });
};
var ke$3 = (e2) => {
  let { backgroundImages: t, selectedSnap: o2, setSelectedSnap: r3 } = e2, [n4, i] = nt$2({ containScroll: "keepSnaps", dragFree: true }), s2 = useCallback(() => {
    i && ((i == null ? void 0 : i.canScrollPrev()) ? i.scrollPrev() : o2 - 1 >= 0 && r3(o2 - 1));
  }, [i, o2]), c = useCallback(() => {
    i && ((i == null ? void 0 : i.canScrollNext()) ? i.scrollNext() : o2 + 1 < t.length && r3(o2 + 1));
  }, [i, o2]), l2 = useCallback((a2) => {
    r3(a2.selectedScrollSnap());
  }, []);
  return useEffect(() => {
    i && (l2(i), i.on("reInit", l2), i.on("select", l2), i == null ? void 0 : i.scrollTo(o2));
  }, [i, l2]), jsxs(z$3, { mt: 4, px: 2, children: [jsx(Se$4, { onClick: s2 }), jsx("div", { ref: n4, className: "oui-w-full oui-overflow oui-overflow-x-auto oui-scrollbar-hidden oui-hide-scrollbar oui-mx-0", children: jsx(z$3, { children: t.map((a2, u2) => jsx(W$2, { onClick: () => {
    (i == null ? void 0 : i.canScrollPrev()) || (i == null ? void 0 : i.canScrollNext()) ? i == null ? void 0 : i.scrollTo(u2) : r3(u2);
  }, mx: 2, my: 1, mr: 6, r: "base", className: cnBase("oui-shrink-0 oui-w-[162px]", o2 === u2 && "oui-outline oui-outline-1 oui-outline-primary-darken"), children: jsx("img", { src: a2, className: "oui-rounded-sm" }) }, a2)) }) }), jsx(be$2, { onClick: c })] });
};
var Ie$3 = (e2) => {
  let { type: t, curType: o2, setPnlFormat: r3 } = e2, { t: n4 } = ne$6(), i = useMemo(() => {
    switch (t) {
      case "roi_pnl":
        return n4("share.pnl.displayFormat.roi&Pnl");
      case "roi":
        return n4("share.pnl.displayFormat.roi");
      case "pnl":
        return n4("share.pnl.displayFormat.pnl");
    }
  }, [t, n4]), s2 = t === o2, c = "oui-flex oui-items-center oui-gap-1 oui-cursor-pointer";
  return s2 ? c += " oui-text-base-contrast" : c += "", jsxs("div", { className: c, onClick: () => {
    r3(t);
  }, children: [jsx(pt$4, { sel: s2 }), jsx(Q$1, { size: "xs", intensity: 54, className: cnBase("oui-ml-2 "), children: i })] });
}, pt$4 = (e2) => jsx("button", { type: "button", children: e2.sel === true ? jsx(ft$1, {}) : jsx(dt$2, {}) }), ft$1 = () => jsxs("svg", { width: "16", height: "16", viewBox: "0 0 16 16", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", className: "oui-fill-primary-darken", children: [jsx("path", { d: "M8.01 1.333a6.667 6.667 0 1 0 0 13.333 6.667 6.667 0 0 0 0-13.333m0 1.333a5.334 5.334 0 1 1-.001 10.667 5.334 5.334 0 0 1 0-10.667", fill: "#fff", fillOpacity: ".36" }), jsx("circle", { cx: "8", cy: "8", r: "3.333" })] }), dt$2 = () => jsx("svg", { width: "16", height: "16", viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: jsx("path", { d: "M8.01 1.333a6.667 6.667 0 1 0 0 13.333 6.667 6.667 0 0 0 0-13.333m0 1.333a5.334 5.334 0 1 1-.001 10.667 5.334 5.334 0 0 1 0-10.667", fill: "#fff", fillOpacity: ".54" }) });
var oe$3 = (e2) => {
  let { size: t = 16, className: o2 } = e2;
  return jsx("button", { type: "button", onClick: (r3) => {
    e2.onCheckedChange(!e2.checked);
  }, className: o2, children: e2.checked ? jsx("svg", { width: t, height: t, viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M4.66 1.953A2.667 2.667 0 0 0 1.995 4.62v6.667a2.667 2.667 0 0 0 2.667 2.666h6.666a2.667 2.667 0 0 0 2.667-2.666V4.62a2.667 2.667 0 0 0-2.667-2.667zm6.664 2.922a.8.8 0 0 1 .557-.208c.2 0 .406.063.558.208a.734.734 0 0 1 0 1.063l-5.434 5.179a.826.826 0 0 1-1.115 0l-2.33-2.22a.736.736 0 0 1 0-1.063.827.827 0 0 1 1.117 0l1.77 1.687z", fill: "#fff", fillOpacity: ".8" }) }) : jsx("svg", { width: t, height: t, viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: jsx("path", { d: "M4.66 1.953A2.667 2.667 0 0 0 1.995 4.62v6.667a2.667 2.667 0 0 0 2.667 2.666h6.666a2.667 2.667 0 0 0 2.667-2.666V4.62a2.667 2.667 0 0 0-2.667-2.667zm0 1.334h6.667c.737 0 1.334.596 1.334 1.333v6.667c0 .736-.597 1.333-1.334 1.333H4.661a1.333 1.333 0 0 1-1.334-1.333V4.62c0-.737.597-1.333 1.334-1.333", fill: "#fff", fillOpacity: ".8" }) }) });
};
var Oe$1 = (e2) => {
  let { type: t, curType: o2, setShareOption: r3 } = e2, { t: n4 } = ne$6(), i = useMemo(() => {
    switch (t) {
      case "openPrice":
        return n4("share.pnl.optionalInfo.openPrice");
      case "closePrice":
        return n4("share.pnl.optionalInfo.closePrice");
      case "openTime":
        return n4("share.pnl.optionalInfo.openTime");
      case "closeTime":
        return n4("share.pnl.optionalInfo.closeTime");
      case "markPrice":
        return n4("common.markPrice");
      case "quantity":
        return n4("common.quantity");
      case "leverage":
        return n4("common.leverage");
    }
  }, [t, n4]), s2 = o2.has(t);
  return jsxs(z$3, { itemAlign: "center", gap: 1, className: cnBase("hover:oui-cursor-pointer"), onClick: () => {
    r3((c) => {
      let l2 = new Set(c);
      return s2 ? l2.delete(t) : l2.add(t), l2;
    });
  }, children: [jsx(oe$3, { size: 16, checked: s2, className: "oui-pt-[2px]", onCheckedChange: (c) => {
    r3((l2) => {
      let a2 = new Set(l2);
      return s2 ? a2.delete(t) : a2.add(t), a2;
    });
  } }), jsx(Q$1, { size: "xs", intensity: 54, children: i })] });
};
var Fe$3 = (e2) => {
  let { message: t, setMessage: o2, check: r3, setCheck: n4 } = e2, [i, s2] = useState(false), c = useRef(null), { t: l2 } = ne$6();
  return jsxs("div", { className: "oui-mt-3 oui-mb-6 oui-flex oui-items-center", children: [jsx(oe$3, { className: "oui-mt-[2px]", checked: r3, onCheckedChange: (a2) => {
    n4(a2);
  } }), jsx("div", { className: "oui-text-xs oui-text-base-contrast-54 oui-ml-1 hover:oui-cursor-pointer", onClick: () => {
    n4(!e2.check);
  }, children: l2("share.pnl.optionalInfo.message") }), jsx("div", { className: "oui-bg-base-900 oui-mx-2 oui-rounded-sm", children: jsx(Fo$3, { ref: c, placeholder: l2("share.pnl.optionalInfo.message.placeholder"), classNames: { root: "oui-w-[320px]" }, size: "sm", value: t, autoFocus: false, suffix: i && jsx("button", { className: "oui-mr-3 oui-cursor-pointer", onMouseDown: (a2) => {
    o2(""), setTimeout(() => {
      var _a3;
      (_a3 = c.current) == null ? void 0 : _a3.focus();
    }, 50), a2.stopPropagation();
  }, children: jsx(en$2, { size: 18, color: "white" }) }), onFocus: () => s2(true), onBlur: () => s2(false), onChange: (a2) => {
    if (a2.target.value.length > 25) {
      toast$2.error(l2("share.pnl.optionalInfo.message.maxLength"));
      return;
    }
    n4(a2.target.value.length > 0), o2(a2.target.value);
  } }) })] });
};
var Re$4 = (e2) => {
  let { onClickDownload: t, onClickCopy: o2 } = e2, { t: r3 } = ne$6();
  return jsxs(z$3, { px: 8, gap: 3, mt: 3, itemAlign: "center", children: [jsxs($e$6, { color: "secondary", className: "oui-flex-1 oui-flex oui-gap-1", onClick: t, children: [jsx("span", { children: jsx(Ot$2, {}) }), r3("common.download")] }), jsxs($e$6, { className: "oui-flex-1 oui-flex oui-gap-1", onClick: o2, children: [jsx("span", { children: jsx(Ft$4, {}) }), r3("common.copy")] })] });
}, Ot$2 = () => jsx("svg", { width: "16", height: "16", viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: jsx("path", { d: "M4.66 1.994A2.667 2.667 0 0 0 1.995 4.66v6.666a2.667 2.667 0 0 0 2.667 2.667h6.666a2.667 2.667 0 0 0 2.667-2.667V4.661a2.667 2.667 0 0 0-2.667-2.667zM7.995 4.66c.368 0 .667.298.667.666V8.66h2l-2.667 2.666L5.328 8.66h2V5.327c0-.368.299-.667.667-.667", fill: "#fff", fillOpacity: ".98" }) }), Ft$4 = () => jsx("svg", { width: "17", height: "16", viewBox: "0 0 17 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: jsx("path", { d: "M5.166 1.994A2.667 2.667 0 0 0 2.499 4.66v4a2.667 2.667 0 0 0 2.667 2.667 2.667 2.667 0 0 0 2.666 2.667h4a2.667 2.667 0 0 0 2.667-2.667v-4a2.667 2.667 0 0 0-2.667-2.667 2.667 2.667 0 0 0-2.666-2.666zm6.666 4c.737 0 1.334.596 1.334 1.333v4c0 .737-.597 1.334-1.334 1.334h-4A1.333 1.333 0 0 1 6.5 11.327h2.667a2.667 2.667 0 0 0 2.666-2.667z", fill: "#fff", fillOpacity: ".98" }) });
var Ee$1 = (e2) => {
  let { shareOptions: t } = e2, { t: o2 } = ne$6(), r3 = te$3(), i = e2.entity.roi != null && e2.entity.pnl != null ? ["roi_pnl", "roi", "pnl"] : e2.entity.roi != null ? ["roi"] : e2.entity.pnl != null ? ["pnl"] : [], [s2, c] = useState(i.length == 1 ? i[0] : r3.pnlFormat), [l2, a2] = useState(new Set(r3.options)), [u2, x2] = useState(r3.bgIndex), [f2, y2] = useState(r3.message), [M2, w4] = useState(false), { backgroundImages: P2, ...W2 } = t ?? { backgroundImages: [] }, [S2, O2] = useState(""), v3 = useRef(null);
  useEffect(() => {
    let k2 = window.location.hostname;
    O2(k2);
  }, []);
  let $2 = useMemo(() => {
    var _a3;
    return (_a3 = t == null ? void 0 : t.backgroundImages) == null ? void 0 : _a3[u2];
  }, [t == null ? void 0 : t.backgroundImages, u2]), h2 = j$1(e2.entity, e2.leverage, M2 ? f2 : "", S2, s2, l2, e2.baseDp, e2.quoteDp, e2.referral), re2 = () => {
    var _a3;
    (_a3 = v3.current) == null ? void 0 : _a3.copy().then(() => {
      var _a4;
      (_a4 = e2.hide) == null ? void 0 : _a4.call(e2), toast$2.success(o2("share.pnl.image.copied"));
    }).catch((k2) => {
      toast$2.error(() => jsxs("div", { children: [jsx("div", { children: o2("common.copy.failed") }), jsx("div", { className: "oui-text-2xs oui-max-w-[396px] oui-mt-2 oui-text-base-contrast-54", children: o2("share.pnl.copy.failed.description") })] }));
    });
  }, Q2 = () => {
    var _a3, _b2;
    (_a3 = v3.current) == null ? void 0 : _a3.download("Poster.png"), (_b2 = e2.hide) == null ? void 0 : _b2.call(e2);
  }, ae2 = [...e2.entity.openPrice ? ["openPrice"] : [], ...e2.entity.closePrice ? ["closePrice"] : [], ...e2.entity.markPrice ? ["markPrice"] : [], ...e2.entity.openTime ? ["openTime"] : [], ...e2.entity.closeTime ? ["closeTime"] : [], ...e2.leverage ? ["leverage"] : [], ...e2.entity.quantity ? ["quantity"] : []];
  return ee$1(s2, l2, u2, f2), jsxs("div", { className: "oui-h-full oui-flex oui-flex-col oui-relative oui-w-full", children: [jsxs("div", { className: "oui-flex-1 oui-h-full oui-overflow-y-auto", children: [jsxs(W$2, { mt: 9, height: 422, children: [jsx(z$3, { itemAlign: "center", justify: "center", children: jsx(V$1, { width: 552, height: 310, data: { backgroundImg: $2, ...W2, data: h2 }, ratio: 3, ref: v3 }) }), jsx(ke$3, { backgroundImages: (t == null ? void 0 : t.backgroundImages) ?? [], selectedSnap: u2, setSelectedSnap: x2 })] }), jsxs(z$3, { direction: "column", px: 10, mt: 6, justify: "start", itemAlign: "start", width: "100%", children: [jsx(Q$1, { size: "sm", intensity: 80, children: o2("share.pnl.displayFormat") }), jsx(z$3, { pt: 3, gap: 3, itemAlign: "center", children: i.map((k2, E3) => jsx(Ie$3, { setPnlFormat: c, type: k2, curType: s2 }, E3)) }), jsx(de$5, { className: "oui-w-full oui-pt-6 oui-border-white/10" }), jsxs(z$3, { mt: 6, direction: "column", justify: "start", itemAlign: "start", children: [jsx(Q$1, { size: "sm", intensity: 80, children: o2("share.pnl.optionalInfo") }), jsx(z$3, { mt: 3, gap: 4, className: "oui-flex-wrap", children: ae2.map((k2, E3) => jsx(Oe$1, { setShareOption: a2, type: k2, curType: l2 }, E3)) })] }), jsx(Fe$3, { message: f2, setMessage: y2, check: M2, setCheck: w4 })] })] }), jsx(Re$4, { onClickCopy: re2, onClickDownload: Q2 })] });
};
var ze$3 = ze__default__default.createContext(null);
function L() {
  let e2 = ze__default__default.useContext(ze$3);
  if (!e2) throw new Error("useCarousel must be used within a <Carousel />");
  return e2;
}
var ce$5 = ze__default__default.forwardRef(({ orientation: e2 = "horizontal", opts: t, setApi: o2, plugins: r3, className: n4, children: i, ...s2 }, c) => {
  let [l2, a2] = nt$2({ ...t, axis: e2 === "horizontal" ? "x" : "y" }, r3), [u2, x2] = ze__default__default.useState(false), [f2, y2] = ze__default__default.useState(false), [M2, w4] = ze__default__default.useState(s2.initIndex || 0), [P2, W2] = ze__default__default.useState([]), S2 = ze__default__default.useCallback((h2) => {
    h2 && (P2.length === 0 && W2(h2.scrollSnapList()), w4(h2.selectedScrollSnap()), x2(h2.canScrollPrev()), y2(h2.canScrollNext()));
  }, [P2]), O2 = ze__default__default.useCallback(() => {
    a2 == null ? void 0 : a2.scrollPrev();
  }, [a2]), v3 = ze__default__default.useCallback(() => {
    a2 == null ? void 0 : a2.scrollNext();
  }, [a2]), $2 = ze__default__default.useCallback((h2) => {
    h2.key === "ArrowLeft" ? (h2.preventDefault(), O2()) : h2.key === "ArrowRight" && (h2.preventDefault(), v3());
  }, [O2, v3]);
  return ze__default__default.useEffect(() => {
    !a2 || !o2 || o2(a2);
  }, [a2, o2]), ze__default__default.useEffect(() => {
    if (a2) return S2(a2), a2.on("reInit", S2), a2.on("select", S2), s2.initIndex && a2.scrollTo(s2.initIndex), () => {
      a2 == null ? void 0 : a2.off("select", S2);
    };
  }, [a2, S2]), jsx(ze$3.Provider, { value: { carouselRef: l2, api: a2, opts: t, orientation: e2 || ((t == null ? void 0 : t.axis) === "y" ? "vertical" : "horizontal"), scrollPrev: O2, scrollNext: v3, canScrollPrev: u2, canScrollNext: f2, selectedIndex: M2, scrollSnaps: P2 }, children: jsx("div", { ref: c, onKeyDownCapture: $2, className: cnBase("oui-relative", n4), role: "region", "aria-roledescription": "carousel", ...s2, children: i }) });
});
ce$5.displayName = "Carousel";
var Z$4 = ze__default__default.forwardRef(({ className: e2, ...t }, o2) => {
  let { carouselRef: r3, orientation: n4 } = L();
  return jsx("div", { ref: r3, className: "oui-overflow-hidden", children: jsx("div", { ref: o2, className: cnBase("oui-flex", n4 === "horizontal" ? "oui--ml-4" : "oui--mt-4 oui-flex-col", e2), ...t }) });
});
Z$4.displayName = "CarouselContent";
var G$2 = ze__default__default.forwardRef(({ className: e2, ...t }, o2) => {
  let { orientation: r3 } = L();
  return jsx("div", { ref: o2, role: "group", "aria-roledescription": "slide", className: cnBase("oui-min-w-0 oui-shrink-0 oui-grow-0 oui-basis-full", r3 === "horizontal" ? "oui-pl-4" : "oui-pt-4", e2), ...t });
});
G$2.displayName = "CarouselItem";
var ue$3 = ze__default__default.forwardRef(({ className: e2, variant: t = "contained", size: o2 = "icon", ...r3 }, n4) => {
  let { orientation: i, scrollPrev: s2, canScrollPrev: c } = L();
  return jsxs($e$6, { ref: n4, variant: t, className: cnBase("oui-absolute  oui-h-8 oui-w-8 oui-rounded-full", i === "horizontal" ? "oui--left-12 oui-top-1/2 oui--translate-y-1/2" : "oui--top-12 oui-left-1/2 oui--translate-x-1/2 oui-rotate-90", e2), disabled: !c, onClick: s2, ...r3, children: [jsx(ChevronLeft, { size: 20 }), jsx("span", { className: "oui-sr-only", children: "Previous slide" })] });
});
ue$3.displayName = "CarouselPrevious";
var me$2 = ze__default__default.forwardRef(({ className: e2, variant: t = "contained", size: o2 = "icon", ...r3 }, n4) => {
  let { orientation: i, scrollNext: s2, canScrollNext: c } = L();
  return jsxs($e$6, { ref: n4, variant: t, className: cnBase("oui-absolute oui-h-8 oui-w-8 oui-rounded-full", i === "horizontal" ? "oui--right-12 oui-top-1/2 oui--translate-y-1/2" : "oui--bottom-12 oui-left-1/2 oui--translate-x-1/2 oui-rotate-90", e2), disabled: !c, onClick: s2, ...r3, children: [jsx(ChevronRight, { size: 20 }), jsx("span", { className: "oui-sr-only", children: "Next slide" })] });
});
me$2.displayName = "CarouselNext";
var pe$1 = (e2) => {
  let { scrollSnaps: t, selectedIndex: o2 } = L();
  return jsx("div", { className: cnBase("oui-flex oui-gap-1", e2.className), children: t.map((r3, n4) => jsx(fe$1, { index: n4, active: n4 === o2, onClick: e2.onClick, className: e2.dotClassName, activeClassName: e2.dotActiveClassName }, n4)) });
};
pe$1.displayName = "CarouselIdentifier";
var fe$1 = ({ index: e2, active: t, onClick: o2, className: r3, activeClassName: n4 }) => jsx("button", { onClick: () => o2 == null ? void 0 : o2(e2), className: cnBase("oui-w-2 oui-h-2 oui-rounded-full oui-bg-white/30", r3, t && `active ${n4 || "oui-bg-primary-darken"}`) });
var R = ce$5;
R.Content = Z$4;
R.Item = G$2;
R.Next = me$2;
R.Previous = ue$3;
R.indentify = pe$1;
var _e$3 = (e2) => {
  var _a3, _b2;
  let { shareOptions: t } = e2, { t: o2 } = ne$6(), r3 = te$3(), i = e2.entity.roi != null && e2.entity.pnl != null ? ["roi_pnl", "roi", "pnl"] : e2.entity.roi != null ? ["roi"] : e2.entity.pnl != null ? ["pnl"] : [], [s2, c] = useState(i.length == 1 ? i[0] : r3.pnlFormat), [l2, a2] = useState(new Set(r3.options)), [u2, x2] = useState(r3.message), [f2, y2] = useState(r3.bgIndex), { backgroundImages: M2, ...w4 } = t ?? { backgroundImages: [] }, [P2, W2] = useState(""), S2 = (_a3 = t == null ? void 0 : t.backgroundImages) == null ? void 0 : _a3.map(() => useRef(null));
  useEffect(() => {
    let p2 = window.location.hostname;
    W2(p2);
  }, []);
  let O2 = j$1(e2.entity, e2.leverage, u2, P2, s2, l2, e2.baseDp, e2.quoteDp, e2.referral), v3 = useRef(), $2 = 552 / 310, [h2, re2] = useState(1), [Q2, ae2] = useState(0), [k2, E3] = useState(false), xe2 = useRef(null);
  useEffect(() => {
    if (v3.current) {
      let p2 = v3.current.offsetWidth, A2 = p2 / $2;
      ae2(A2), re2(p2 / 552);
    }
  }, [v3, P2]);
  let Ke2 = async (p2) => {
    var _a4, _b3;
    if (!p2.current) return;
    let A2 = (_a4 = p2.current) == null ? void 0 : _a4.toDataURL(), Je2 = Vt$2(A2);
    try {
      navigator.share && await navigator.share({ text: u2, files: [new File([Je2], "image.png", { type: "image/png" })] }), (_b3 = e2.hide) == null ? void 0 : _b3.call(e2);
    } catch {
    }
  };
  return ee$1(s2, l2, f2, u2), jsxs("div", { className: "oui-w-full", children: [jsx("div", { ref: v3, className: "oui-w-full oui-mt-4 oui-overflow-hidden", style: { height: `${Q2 + 20}px` }, children: jsxs(R, { className: "oui-w-full oui-overflow-hidden", opts: { align: "start" }, initIndex: f2, children: [jsx(Z$4, { style: { height: `${Q2}px` }, children: (_b2 = t == null ? void 0 : t.backgroundImages) == null ? void 0 : _b2.map((p2, A2) => jsx(G$2, { children: jsx(V$1, { className: "oui-transform oui-origin-top-left", style: { scale: `${h2}` }, width: 552, height: 310, data: { backgroundImg: p2, ...w4, data: O2 }, ratio: 3, ref: S2 == null ? void 0 : S2[A2] }) }, A2)) }), jsx("div", { className: "oui-mt-2 oui-mb-1 oui-flex oui-justify-center", children: jsx(Kt$2, { dotClassName: "oui-w-[16px] oui-h-[4px] oui-bg-base-300", dotActiveClassName: "!oui-bg-primary-darken oui-w-[20px]", setSelectIndex: y2 }) })] }) }), jsxs(io$3, { className: "oui-max-h-[200px] oui-overflow-y-auto oui-custom-scrollbar", children: [jsxs("div", { className: "oui-mt-4", children: [jsx("div", { className: "oui-text-3xs oui-text-base-contrast-54", children: o2("share.pnl.displayFormat") }), jsx("div", { className: "oui-pt-3 oui-px-1 oui-justify-between oui-gap-3 oui-grid oui-grid-cols-3 oui-row-span-1", children: i.map((p2) => jsx($t$1, { setPnlFormat: c, type: p2, curType: s2 })) })] }), jsxs("div", { className: "oui-mt-3", children: [jsx("div", { className: "oui-text-3xs oui-text-base-contrast-54 oui-h-[18px]", children: o2("share.pnl.optionalInfo") }), jsxs("div", { className: "oui-flex oui-flex-wrap oui-gap-3 oui-mt-3", children: [e2.entity.openPrice && jsx(B$3, { setShareOption: a2, type: "openPrice", curType: l2 }), e2.entity.closePrice && jsx(B$3, { setShareOption: a2, type: "closePrice", curType: l2 }), e2.entity.openTime && jsx(B$3, { setShareOption: a2, type: "openTime", curType: l2 }), e2.entity.closeTime && jsx(B$3, { setShareOption: a2, type: "closeTime", curType: l2 }), e2.leverage && jsx(B$3, { setShareOption: a2, type: "leverage", curType: l2 }), e2.entity.markPrice && jsx(B$3, { setShareOption: a2, type: "markPrice", curType: l2 }), e2.entity.quantity && jsx(B$3, { setShareOption: a2, type: "quantity", curType: l2 })] })] }), jsxs("div", { className: "oui-mt-3 oui-mb-8", children: [jsx("div", { className: "oui-text-3xs oui-text-base-contrast-54 oui-h-[18px]", children: o2("share.pnl.optionalInfo.message") }), jsx("div", { className: "oui-mt-3 oui-h-[48px] oui-bg-base-600 oui-mx-1", children: jsx(Fo$3, { placeholder: o2("share.pnl.optionalInfo.message.placeholder"), containerClassName: "oui-bg-transparent oui-h-[48px]", value: u2, autoFocus: false, onChange: (p2) => {
    if (p2.target.value.length > 25) {
      toast$2.error(o2("share.pnl.optionalInfo.message.maxLength"));
      return;
    }
    x2(p2.target.value);
  }, ref: xe2, onFocus: () => E3(true), onBlur: () => E3(false), suffix: k2 && jsx("button", { className: "oui-mr-3 oui-cursor-pointer", onMouseDown: (p2) => {
    x2(""), setTimeout(() => {
      var _a4;
      (_a4 = xe2.current) == null ? void 0 : _a4.focus();
    }, 50), p2.stopPropagation();
  }, children: jsx(en$2, { size: 18, color: "white" }) }) }) })] })] }), jsx("div", { className: "oui-pt-2", children: jsx($e$6, { fullWidth: true, className: "oui-h-[40px] oui-text-[16px]", onClick: () => {
    let p2 = S2 == null ? void 0 : S2[f2];
    p2 && Ke2(p2);
  }, children: o2("common.share") }) })] });
}, $t$1 = (e2) => {
  let { type: t, curType: o2, setPnlFormat: r3 } = e2, { t: n4 } = ne$6(), i = useMemo(() => {
    switch (t) {
      case "roi_pnl":
        return n4("share.pnl.displayFormat.roi&Pnl");
      case "roi":
        return n4("share.pnl.displayFormat.roi");
      case "pnl":
        return n4("share.pnl.displayFormat.pnl");
    }
  }, [t]);
  return jsx("div", { className: cnBase("oui-shadow-lg oui-rounded-lg oui-h-[46px] oui-flex-1 oui-bg-base-4 hover:oui-cursor-pointer oui-flex oui-items-center oui-px-3 oui-referral-shadow", t === o2 && "oui-bg-primary-darken oui-dot-sel"), onClick: () => {
    r3(t);
  }, children: jsx("div", { className: "oui-text-sm oui-text-base-contrast", children: i }) });
}, B$3 = (e2) => {
  let { type: t, curType: o2, setShareOption: r3 } = e2, { t: n4 } = ne$6(), i = useMemo(() => {
    switch (t) {
      case "openPrice":
        return n4("share.pnl.optionalInfo.openPrice");
      case "closePrice":
        return n4("share.pnl.optionalInfo.closePrice");
      case "openTime":
        return n4("share.pnl.optionalInfo.openTime");
      case "closeTime":
        return n4("share.pnl.optionalInfo.closeTime");
      case "markPrice":
        return n4("common.markPrice");
      case "quantity":
        return n4("common.quantity");
      case "leverage":
        return n4("common.leverage");
    }
  }, [t, n4]), s2 = o2.has(t);
  return jsxs("div", { className: cnBase("oui-shadow-lg oui-rounded-lg oui-h-[46px] oui-mt-0 oui-w-[calc(50%-6px)] oui-bg-base-4 hover:oui-cursor-pointer oui-items-center oui-flex oui-p-3 oui-referral-shadow"), onClick: () => {
    r3((c) => {
      let l2 = new Set(c);
      return s2 ? l2.delete(t) : l2.add(t), l2;
    });
  }, children: [jsx("div", { className: "oui-text-sm oui-flex-1 oui-text-base-contrast", children: i }), s2 && jsx(Jt$3, {})] });
};
function Vt$2(e2) {
  let t = atob(e2.split(",")[1]), o2 = e2.split(",")[0].split(":")[1].split(";")[0], r3 = new ArrayBuffer(t.length), n4 = new Uint8Array(r3);
  for (let i = 0; i < t.length; i++) n4[i] = t.charCodeAt(i);
  return new Blob([r3], { type: o2 });
}
var Kt$2 = (e2) => {
  let { scrollSnaps: t, selectedIndex: o2 } = L();
  return useEffect(() => {
    e2.setSelectIndex(o2);
  }, [o2]), jsx("div", { className: cnBase("oui-flex oui-gap-1"), children: t.map((r3, n4) => jsx(fe$1, { index: n4, active: n4 === o2, onClick: e2.onClick, className: e2.dotClassName, activeClassName: e2.dotActiveClassName }, n4)) });
}, Jt$3 = () => jsx("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M2.01416 11.9989C2.01416 6.47589 6.49136 1.9989 12.0142 1.9989C17.5372 1.9989 22.0142 6.47589 22.0142 11.9989C22.0142 17.5219 17.5372 21.9989 12.0142 21.9989C6.49136 21.9989 2.01416 17.5219 2.01416 11.9989ZM16.9853 7.31211C17.2125 7.09537 17.5236 7 17.8218 7C18.1201 7 18.4312 7.09537 18.6583 7.31211C19.1139 7.74546 19.1139 8.47384 18.6583 8.9072L10.5077 16.675C10.0534 17.1083 9.28909 17.1083 8.83472 16.675L5.34077 13.3459C4.88641 12.9126 4.88641 12.1841 5.34077 11.7508C5.79631 11.3175 6.56057 11.3175 7.01493 11.7508L9.67122 14.2822L16.9853 7.31211Z", fill: "white", fillOpacity: "1" }) });
var Ue$3 = (e2) => {
  let { leverage: t, entity: o2, baseDp: r3, quoteDp: n4, referralInfo: i, shareOptions: s2, hide: c } = e2, [l2, a2] = useState(window.innerHeight < 900 ? 660 : 807);
  return useEffect(() => {
    let u2 = () => {
      a2(window.innerHeight < 900 ? 660 : 807);
    };
    return window.addEventListener("resize", u2), () => {
      window.removeEventListener("resize", u2);
    };
  }, []), s2 == null || o2 == null ? jsx(Fragment$1, {}) : jsx(Ee$1, { entity: o2, leverage: t, hide: c, baseDp: r3, quoteDp: n4, referral: i, shareOptions: s2 });
}, We$5 = (e2) => {
  let { leverage: t, entity: o2, baseDp: r3, quoteDp: n4, referralInfo: i, shareOptions: s2, hide: c } = e2;
  return s2 == null || o2 == null ? jsx(Fragment$1, {}) : jsx(_e$3, { entity: o2, leverage: t, hide: c, baseDp: r3, quoteDp: n4, referral: i, shareOptions: s2 });
};
var ve$2 = (e2) => {
  let t = X({ hide: e2.hide, pnl: e2.pnl });
  return jsx(We$5, { ...t });
}, Ce$2 = (e2) => {
  let t = X({ hide: e2.hide, pnl: e2.pnl });
  return jsx(Ue$3, { ...t });
};
var jt$2 = "sharePnLDialog", eo$3 = "sharePnLBottomSheet";
Wm(jt$2, Ce$2, { classNames: { content: "!oui-max-w-[624px] oui-p-0" } });
Um(eo$3, ve$2, { title: o.t("share.pnl.sharePnl"), classNames: { body: "oui-pb-4 oui-pt-0" } });
var J = (e2) => {
  let { type: t, values: o2 } = e2, [i, a2] = useLocalStorage("TP/SL_Mode", "Offset%"), [l2, p2] = useState(true), { t: g2 } = ne$6(), r3 = useMemo(() => {
    switch (i) {
      case "Offset":
        return `${t.toLowerCase()}_offset`;
      case "Offset%":
        return `${t.toLowerCase()}_offset_percentage`;
      default:
        return `${t.toLowerCase()}_pnl`;
    }
  }, [i]), P2 = useMemo(() => o2[i], [o2, i]), _2 = useMemo(() => [{ label: g2("tpsl.pnl"), value: "PnL", testId: "PnL_menu_item" }, { label: g2("tpsl.offset"), value: "Offset", testId: "Offset_mneu_item" }, { label: `${g2("tpsl.offset")}%`, value: "Offset%", testId: "Offset%_menu_item" }], [g2]), m2 = useRef(""), T2 = (c) => {
    e2.onChange(r3, c);
  }, x2 = (c) => {
    let { dp: u2 = 2 } = c;
    return { onRenderBefore: (s2, L2) => (s2 = `${s2}`, l2 && t === "SL" && i === "PnL" && (s2 = s2.startsWith("-") ? s2 : "-" + s2), s2 === "" || s2 === "-" ? "" : i === "Offset%" ? `${new g$6(s2.replace(new RegExp(m2.current.replace(".", "\\.") + "$"), "")).mul(100).todp(2, 4).toString()}${m2.current}` : (i === "Offset" && (s2 = O$7(s2, u2)), `${s2}`)), onSendBefore: (s2) => {
      if (/^\-?0{2,}$/.test(s2)) return "0";
      if (i === "Offset%") {
        if (s2 !== "") {
          s2 = O$7(s2, 2);
          let L2 = s2.match(/\.0{0,2}$/);
          L2 ? m2.current = L2[0] : m2.current = "", s2 = new g$6(s2).div(100).toString(), s2 = `${s2}${m2.current}`;
        }
      } else i === "PnL" && t === "SL" && l2 ? s2 = s2.startsWith("-") ? s2 : "-" + s2 : s2 = O$7(s2, u2);
      return s2 === "" || s2 === "-" ? "" : s2;
    } };
  };
  return { mode: i, modes: _2, type: e2.type, formatter: x2, onModeChange: (c) => {
    a2(c);
  }, value: P2, pnl: o2.PnL, onValueChange: T2, quote_dp: e2.quote_dp, setFocus: p2 };
};
var te$2 = (e2) => {
  let { mode: t, modes: o2, onModeChange: i, onValueChange: a2, quote: l2, quote_dp: p2, value: g2, pnl: r3 } = e2, { t: P2 } = ne$6(), [_2, m2] = useState(t), [T2, x2] = useState(t === "Offset%" ? "%" : l2), c = useMemo(() => {
    let u2 = Number(r3);
    if (isNaN(u2) || u2 === 0) return "";
    if (u2 > 0) return "oui-text-trade-profit";
    if (u2 < 0) return "oui-text-trade-loss";
  }, [r3]);
  return useEffect(() => {
    var _a3;
    let u2 = (_a3 = o2.find((s2) => s2.value === t)) == null ? void 0 : _a3.label;
    m2(u2), x2(t === "Offset%" ? "%" : l2);
  }, [t, o2]), jsx(Fo$3, { prefix: _2, size: { initial: "lg", lg: "md" }, placeholder: T2, align: "right", value: g2, "data-testid": e2.testId, autoComplete: "off", onValueChange: a2, formatters: [e2.formatter({ dp: p2, mode: t }), li$3.currencyFormatter, li$3.decimalPointFormatter], classNames: { input: c, prefix: "oui-text-base-contrast-54", root: "oui-outline-line-12 focus-within:oui-outline-primary-light" }, onFocus: () => {
    x2(""), e2.setFocus(true);
  }, onBlur: () => {
    x2(t === "Offset%" ? "%" : l2), e2.setFocus(false);
  }, suffix: jsxs(Fragment$1, { children: [t === "Offset%" && !!g2 && jsx(Q$1, { size: "2xs", color: "inherit", className: cnBase("oui-ml-[2px]", c), children: "%" }), jsx(Ae$1, { mode: t, modes: o2, onModeChange: (u2) => i(u2.value) })] }) });
}, Ae$1 = (e2) => jsx(xg, { currentValue: e2.mode, menu: e2.modes, align: "end", size: "xs", className: "oui-min-w-[80px]", onSelect: (t) => e2.onModeChange(t), children: jsx("button", { className: "oui-p-2", children: jsx(oe$7, { size: 12, color: "white" }) }) });
var U$1 = (e2) => {
  let { testId: t, quote: o2, ...i } = e2, a2 = J(i);
  return jsx(te$2, { ...a2, testId: t, quote: o2 });
};
var le$3 = (e2) => {
  let { TPSL_OrderEntity: t, symbolInfo: o2, onCancel: i, onComplete: a2, status: l2, errors: p2, isPosition: g2 } = e2, { t: r3 } = ne$6(), { parseErrorMsg: P2 } = Lr$3(p2);
  return jsxs("div", { id: "orderly-tp_sl-order-edit-content", children: [(!e2.isEditing || e2.isEditing && !e2.isPosition) && jsxs(Fragment$1, { children: [jsx(Ke$5, { maxQty: e2.maxQty, quantity: e2.orderQuantity ?? e2.maxQty, baseTick: o2("base_tick"), dp: o2("base_dp"), onQuantityChange: e2.setQuantity, quote: o2("base"), isEditing: e2.isEditing, isPosition: g2, errorMsg: P2("quantity") }), jsx(de$5, { my: 4, intensity: 8 })] }), jsx(Ye$2, { sl_pnl: t.sl_pnl, tp_pnl: t.tp_pnl, quote: o2("quote"), quote_dp: o2("quote_dp"), onPriceChange: e2.setOrderPrice, onPnLChange: e2.setPnL, errors: p2, tp_values: { PnL: `${t.tp_pnl ?? ""}`, Offset: `${t.tp_offset ?? ""}`, "Offset%": `${t.tp_offset_percentage ?? ""}` }, sl_values: { PnL: `${t.sl_pnl ?? ""}`, Offset: `${t.sl_offset ?? ""}`, "Offset%": `${t.sl_offset_percentage ?? ""}` }, tp_trigger_price: t.tp_trigger_price ?? "", sl_trigger_price: t.sl_trigger_price ?? "" }), jsxs(Sa$1, { cols: 2, gap: 3, mt: 4, children: [jsx($e$6, { size: "md", color: "secondary", "data-testid": "tpsl-cancel", onClick: () => {
    i == null ? void 0 : i();
  }, children: r3("common.cancel") }), jsx(Sr$2, { size: "md", "data-testid": "tpsl-confirm", disabled: !e2.valid || l2.isCreateMutating, loading: l2.isCreateMutating || l2.isUpdateMutating, onClick: () => {
    e2.onSubmit().then(() => {
      a2 == null ? void 0 : a2();
    }, () => {
    });
  }, children: r3("common.confirm") })] })] });
}, Ke$5 = (e2) => {
  let { isPosition: t } = e2, o2 = useRef(null), i = gr$2(e2.quantity, 0, e2.maxQty) / 100, { t: a2 } = ne$6(), l2 = () => {
    var _a3, _b2;
    (_a3 = e2.onQuantityChange) == null ? void 0 : _a3.call(e2, 0), (_b2 = o2.current) == null ? void 0 : _b2.focus(), setTimeout(() => {
      var _a4;
      (_a4 = o2.current) == null ? void 0 : _a4.setSelectionRange(0, 1);
    }, 0);
  }, p2 = (r3) => {
    var _a3;
    if (e2.baseTick > 0) {
      (_a3 = e2.onQuantityChange) == null ? void 0 : _a3.call(e2, utils_exports.formatNumber(r3, e2.baseTick) ?? r3);
    }
  }, g2 = (t ? "" : e2.quantity).toString().length > 0 ? e2.errorMsg : void 0;
  return jsxs(Fragment$1, { children: [jsxs(z$3, { gap: 2, children: [jsx("div", { className: "oui-flex-1", children: jsx(Fo$3.tooltip, { "data-testid": "oui-testid-tpsl-popUp-quantity-input", ref: o2, prefix: a2("common.quantity"), size: { initial: "lg", lg: "md" }, align: "right", value: t ? "" : e2.quantity, autoComplete: "off", classNames: { prefix: "oui-text-base-contrast-54", root: cnBase("oui-bg-base-5 oui-outline-line-12", g2 && "oui-outline-danger") }, tooltipProps: { content: { className: "oui-bg-base-6 oui-text-base-contrast-80" }, arrow: { className: "oui-fill-base-6" } }, tooltip: g2, color: g2 ? "danger" : void 0, formatters: [li$3.dpFormatter(e2.dp), li$3.numberFormatter, li$3.currencyFormatter, li$3.decimalPointFormatter], onValueChange: (r3) => {
    var _a3, _b2, _c2;
    (_a3 = e2.onQuantityChange) == null ? void 0 : _a3.call(e2, r3);
    let P2 = Number(r3);
    if (P2 && P2 > e2.maxQty) {
      let _2 = t ? 0 : e2.maxQty;
      (_b2 = e2.onQuantityChange) == null ? void 0 : _b2.call(e2, _2), (_c2 = o2.current) == null ? void 0 : _c2.blur();
    }
  }, onBlur: (r3) => p2(r3.target.value), suffix: t ? jsx("button", { className: "oui-text-2xs oui-text-base-contrast-54 oui-px-3", onClick: () => {
    l2();
  }, children: a2("tpsl.entirePosition") }) : jsx("span", { className: "oui-text-2xs oui-text-base-contrast-54 oui-px-3", children: e2.quote }) }) }), !e2.isEditing && jsx($e$6, { onClick: () => {
    var _a3;
    let r3 = t ? 0 : e2.maxQty;
    (_a3 = e2.onQuantityChange) == null ? void 0 : _a3.call(e2, r3), r3 === 0 && l2();
  }, variant: "outlined", className: cnBase("oui-text-2xs oui-w-[68px] oui-h-[40px] xl:oui-h-[32px]", t ? "oui-border-primary-light oui-text-primary-light hover:oui-bg-primary-light/20" : "oui-bg-base-6 oui-border-line-12 oui-text-base-contrast-54 hover:oui-bg-base-5"), children: a2("common.position") })] }), jsx(z$3, { mt: 2, itemAlign: "center", height: "15px", children: jsx(iu.single, { markCount: 5, color: "primary", max: e2.maxQty, min: 0, showTip: true, step: e2.baseTick, value: e2.quantity, onValueCommit: (r3) => {
    p2(`${r3}`);
  }, onValueChange: (r3) => {
    var _a3;
    (_a3 = e2.onQuantityChange) == null ? void 0 : _a3.call(e2, r3);
  } }) }), jsxs(z$3, { justify: "between", children: [jsx(Q$1.numeral, { rule: "percentages", color: "primary", size: "2xs", children: i }), jsxs(z$3, { itemAlign: "center", gap: 1, children: [jsx("button", { className: "oui-leading-none", style: { lineHeight: 0 }, onClick: () => {
    var _a3;
    (_a3 = e2.onQuantityChange) == null ? void 0 : _a3.call(e2, e2.maxQty);
  }, children: jsx(Q$1, { color: "primary", size: "2xs", children: a2("common.max") }) }), jsx(Q$1.numeral, { rule: "price", size: "2xs", intensity: 54, tick: e2.baseTick, children: e2.maxQty })] })] })] });
}, Ye$2 = (e2) => {
  var _a3, _b2;
  let { t } = ne$6(), { parseErrorMsg: o2 } = Lr$3(e2.errors), i = (a2, l2) => {
    e2.onPnLChange(a2, l2);
  };
  return jsxs(Fragment$1, { children: [jsxs("div", { children: [jsxs(z$3, { justify: "between", children: [jsxs(z$3, { gap: 1, children: [jsx(Q$1, { size: "2xs", intensity: 80, children: t("tpsl.takeProfit") }), jsx(Q$1, { size: "2xs", intensity: 36, children: `(${(_a3 = t("orderEntry.orderType.marketOrder")) == null ? void 0 : _a3.toLowerCase()})` })] }), jsxs(z$3, { children: [jsx(Q$1, { size: "2xs", intensity: 36, children: `${t("tpsl.estPnl")}:` }), jsx(Q$1.numeral, { size: "2xs", coloring: true, showIdentifier: true, className: "oui-ml-1", children: e2.tp_pnl ?? "-" })] })] }), jsxs(Sa$1, { cols: 2, gap: 2, pt: 2, pb: 4, children: [jsx(re$2, { type: "TP", value: e2.tp_trigger_price, error: o2("tp_trigger_price"), onValueChange: (a2) => {
    e2.onPriceChange("tp_trigger_price", a2);
  }, quote_dp: e2.quote_dp ?? 2 }), jsx(U$1, { type: "TP", onChange: i, quote: e2.quote, quote_dp: e2.quote_dp, values: e2.tp_values })] })] }), jsxs("div", { children: [jsxs(z$3, { justify: "between", children: [jsxs(z$3, { gap: 1, children: [jsx(Q$1, { size: "2xs", intensity: 80, children: t("tpsl.stopLoss") }), jsx(Q$1, { size: "2xs", intensity: 36, children: `(${(_b2 = t("orderEntry.orderType.marketOrder")) == null ? void 0 : _b2.toLowerCase()})` })] }), jsxs(z$3, { children: [jsx(Q$1, { size: "2xs", intensity: 36, children: `${t("tpsl.estPnl")}:` }), jsx(Q$1.numeral, { size: "2xs", coloring: true, showIdentifier: true, className: "oui-ml-1", children: e2.sl_pnl ?? "-" })] })] }), jsxs(Sa$1, { cols: 2, gap: 2, pt: 2, pb: 4, children: [jsx(re$2, { type: "SL", value: e2.sl_trigger_price, error: o2("sl_trigger_price"), onValueChange: (a2) => {
    e2.onPriceChange("sl_trigger_price", a2);
  }, quote_dp: e2.quote_dp ?? 2 }), jsx(U$1, { type: "SL", onChange: i, quote: e2.quote, quote_dp: e2.quote_dp, values: e2.sl_values })] })] })] });
}, re$2 = (e2) => {
  let [t, o2] = useState("USDC"), { t: i } = ne$6();
  return jsx(Fo$3.tooltip, { "data-testid": `oui-testid-tpsl-popUp-${e2.type.toLowerCase()}-input`, prefix: i("common.markPrice"), size: { initial: "lg", lg: "md" }, tooltip: e2.error, placeholder: t, align: "right", autoComplete: "off", value: e2.value, color: e2.error ? "danger" : void 0, classNames: { prefix: "oui-text-base-contrast-54", root: "oui-outline-line-12 focus-within:oui-outline-primary-light" }, onValueChange: e2.onValueChange, onFocus: () => {
    o2("");
  }, onBlur: () => {
    o2("USDC");
  }, formatters: [li$3.numberFormatter, li$3.dpFormatter(e2.quote_dp), li$3.currencyFormatter, li$3.decimalPointFormatter] });
}, B$2 = (e2) => {
  let { symbol: t, tpPrice: o2, slPrice: i, qty: a2, maxQty: l2, side: p2, quoteDP: g2, baseDP: r3, isEditing: P2, isPositionTPSL: _2 } = e2, { t: m2 } = ne$6(), [T2, x2] = useLocalStorage("orderly_order_confirm", true), c = Ra({ size: "xs", intensity: 54 }), u2 = _2 ?? a2 >= l2;
  return jsxs(Fragment$1, { children: [P2 && jsx(Q$1, { as: "div", size: "2xs", intensity: 80, className: "oui-mb-3", children: `You agree to edit your ${G$7(t)} order.` }), jsxs(z$3, { pb: 4, children: [jsx(W$2, { grow: true, children: jsx(Q$1.formatted, { rule: "symbol", formatString: "base-type", size: "base", showIcon: true, as: "div", intensity: 80, children: t }) }), jsxs(z$3, { gap: 1, children: [u2 && jsx(Wd, { size: "xs", color: "primary", children: m2("common.position") }), jsx(Xe$2, { tpPrice: o2, slPrice: i }), p2 === OrderSide.SELL ? jsx(Wd, { size: "xs", color: "success", children: m2("common.buy") }) : jsx(Wd, { size: "xs", color: "danger", children: m2("common.sell") })] })] }), jsx(de$5, {}), jsxs(z$3, { direction: "column", itemAlign: "stretch", gapY: 1, pt: 4, className: cnBase(c, "oui-pb-4 xl:oui-pb-5"), children: [jsxs(z$3, { children: [jsx(W$2, { grow: true, children: m2("common.qty") }), jsx("div", { children: u2 ? jsx("span", { className: "oui-text-base-contrast", children: m2("tpsl.entirePosition") }) : jsx(Q$1.numeral, { intensity: 98, dp: r3, padding: false, children: a2 }) })] }), typeof o2 == "number" && o2 > 0 ? jsxs(z$3, { children: [jsx(W$2, { grow: true, children: m2("tpsl.tpPrice") }), jsx(Q$1.numeral, { as: "div", coloring: true, unit: "USDC", size: "sm", dp: g2, unitClassName: "oui-text-base-contrast-54 oui-ml-1", children: o2 })] }) : null, typeof i == "number" && i > 0 ? jsxs(z$3, { children: [jsx(W$2, { grow: true, children: m2("tpsl.slPrice") }), jsx(Q$1.numeral, { as: "div", coloring: true, unit: "USDC", size: "sm", dp: g2, className: "oui-text-trade-loss", unitClassName: "oui-text-base-contrast-54 oui-ml-1", children: i })] }) : null, jsxs(z$3, { children: [jsx(W$2, { grow: true, children: m2("common.price") }), jsx("div", { className: "oui-text-base-contrast", children: m2("common.marketPrice") })] })] }), jsx(W$2, { pt: 2, children: jsxs(z$3, { gap: 1, children: [jsx(pi$1, { id: "disabledConfirm", color: "white", checked: !T2, onCheckedChange: (s2) => {
    x2(!s2);
  } }), jsx("label", { htmlFor: "disabledConfirm", className: Ra({ size: "xs", intensity: 54, className: "oui-ml-1" }), children: m2("orderEntry.disableOrderConfirm") })] }) })] });
}, Xe$2 = (e2) => {
  let { tpPrice: t, slPrice: o2 } = e2, { t: i } = ne$6();
  return t && o2 ? jsx(Wd, { size: "xs", color: "neutral", children: i("common.tpsl") }) : t ? jsx(Wd, { size: "xs", color: "neutral", children: i("tpsl.tp") }) : o2 ? jsx(Wd, { size: "xs", color: "neutral", children: i("tpsl.sl") }) : null;
};
var ce$4 = (e2) => {
  let { position: t, order: o2, isEditing: i } = e2;
  if (i && !o2) throw new SDKError("order is required when isEditing is true");
  let a2 = i ? o2.symbol : t.symbol, l2 = useSymbolsInfo(), p2 = useRef(AlgoOrderRootType.TP_SL), [g2] = useLocalStorage("orderly_order_confirm", true), [r3, { submit: P2, deleteOrder: _2, setValue: m2, validate: T2, errors: x2, isCreateMutating: c, isUpdateMutating: u2 }] = useTPSLOrder({ symbol: a2, position_qty: t.position_qty, average_open_price: t.average_open_price }, { defaultOrder: o2, isEditing: i }), s2 = (f2) => {
    m2("quantity", f2);
  }, L2 = (f2, h2) => {
    m2(f2, h2);
  }, $2 = (f2, h2) => {
    m2(f2, h2);
  }, C2 = useMemo(() => Math.abs(Number(t.position_qty)), [t.position_qty]), Y2 = useMemo(() => {
    let f2 = (o2 == null ? void 0 : o2.algo_type) === AlgoOrderRootType.POSITIONAL_TP_SL ? C2 : o2 == null ? void 0 : o2.quantity, h2 = 0;
    if ((Number(r3.quantity) !== f2 || !i && r3.quantity) && (h2 = 1), o2 && i) {
      let Te2 = o2.child_orders.find((D2) => D2.algo_type === AlgoOrderType.TAKE_PROFIT), Le2 = o2.child_orders.find((D2) => D2.algo_type === AlgoOrderType.STOP_LOSS);
      (Te2 == null ? void 0 : Te2.trigger_price) !== Number(r3.tp_trigger_price) && typeof typeof r3.tp_trigger_price < "u" && (h2 = 2), (Le2 == null ? void 0 : Le2.trigger_price) !== Number(r3.sl_trigger_price) && typeof r3.sl_trigger_price < "u" && (h2 = 3);
    }
    return h2 === 1 && !r3.tp_trigger_price && !r3.sl_trigger_price && (h2 = -1), h2;
  }, [r3.tp_trigger_price, r3.sl_trigger_price, r3.quantity, o2, i]), _e3 = useMemo(() => (o2 == null ? void 0 : o2.algo_type) === AlgoOrderRootType.POSITIONAL_TP_SL && Number(r3.quantity) < C2 && !r3.tp_trigger_price && !r3.sl_trigger_price ? false : Y2 > 0 && !!r3.quantity && !x2, [r3.quantity, C2, Y2, x2]), V2 = useMemo(() => i ? o2 && o2.algo_type !== AlgoOrderRootType.POSITIONAL_TP_SL ? false : r3.algo_order_id && r3.quantity == 0 ? true : Number(r3.quantity) >= C2 : Number(r3.quantity) >= C2, [r3.quantity, C2, o2 == null ? void 0 : o2.algo_type, i]);
  useEffect(() => {
    if (!i && V2) {
      let f2 = utils_exports.findTPSLFromOrder(o2);
      !r3.tp_trigger_price && f2.tp_trigger_price && L2("tp_trigger_price", f2.tp_trigger_price), !r3.sl_trigger_price && f2.sl_trigger_price && L2("sl_trigger_price", f2.sl_trigger_price);
    }
  }, [i, V2, r3]), useEffect(() => {
    let f2 = Number(r3.quantity) < C2 ? AlgoOrderRootType.TP_SL : AlgoOrderRootType.POSITIONAL_TP_SL;
    typeof e2.onTPSLTypeChange == "function" && p2.current !== f2 && e2.onTPSLTypeChange(f2), p2.current = f2;
  }, [r3.quantity, C2]);
  let be2 = () => (o2 == null ? void 0 : o2.algo_order_id) && (o2 == null ? void 0 : o2.symbol) ? _2(o2 == null ? void 0 : o2.algo_order_id, o2 == null ? void 0 : o2.symbol) : Promise.reject("order id or symbol is invalid"), xe2 = async () => Promise.resolve().then(() => typeof e2.onConfirm != "function" || !g2 ? P2().then(() => true, (f2) => ((f2 == null ? void 0 : f2.message) && toast$2.error(f2.message), Promise.reject(false))) : e2.onConfirm(r3, { position: t, submit: P2, cancel: be2 })).then((f2) => {
  });
  return { isEditing: i, symbolInfo: l2[a2], maxQty: C2, setQuantity: s2, orderQuantity: r3.quantity, isPosition: V2, TPSL_OrderEntity: r3, setOrderValue: m2, setPnL: $2, setOrderPrice: L2, onSubmit: xe2, valid: _e3, errors: x2, status: { isCreateMutating: c, isUpdateMutating: u2 } };
};
var M$1 = (e2) => {
  let { onCancel: t, onComplete: o2, ...i } = e2, a2 = ce$4(i);
  return jsx(le$3, { ...a2, onCancel: t, onComplete: o2 });
};
var pt$3 = (e2) => {
  let { position: t, order: o2, baseDP: i, quoteDP: a2, buttonProps: l2, isEditing: p2 } = e2, [g2, r3] = useState(false), [P2, _2] = useState(true), [m2] = useLocalStorage("orderly_order_confirm", true), { t: T2 } = ne$6(), x2 = p2 ? (o2 == null ? void 0 : o2.algo_type) === AlgoOrderRootType.POSITIONAL_TP_SL : void 0;
  return jsxs(It$3, { onOpenChange: (c) => {
    P2 && r3(c);
  }, open: g2, children: [jsx(as$1, { asChild: true, onClick: () => {
    r3(true);
  }, children: e2.children || jsx($e$6, { variant: "outlined", size: "sm", color: "secondary", ...l2, children: e2.label }) }), jsx(Vo$3, { className: cnBase("oui-w-[360px]", P2 ? "oui-visible" : "oui-invisible"), align: "end", side: "top", children: jsx(M$1, { position: t, order: o2, isEditing: p2, onComplete: () => {
    r3(false);
  }, onCancel: () => {
    r3(false);
  }, onConfirm: (c, u2) => {
    if (!m2) return Promise.resolve(true);
    _2(false);
    let s2 = Math.abs(Number(t.position_qty));
    if (`${c.tp_trigger_price ?? ""}`.length === 0 && `${c.sl_trigger_price ?? ""}`.length === 0) return vo$4.confirm({ title: T2("orders.cancelOrder"), content: T2("tpsl.cancelOrder.description"), onOk: () => u2.cancel() }).then(() => (r3(false), _2(true), true), () => (_2(true), Promise.reject(false)));
    let L2 = p2 || !!c && c.algo_type === AlgoOrderRootType.POSITIONAL_TP_SL && c.quantity === s2;
    return vo$4.confirm({ title: T2(L2 ? "orders.editOrder" : "tpsl.confirmOrder"), onOk: () => u2.submit(), classNames: { body: "!oui-pb-0" }, content: jsx(B$2, { isPositionTPSL: x2, isEditing: L2, symbol: c.symbol, qty: Number(c.quantity), maxQty: s2, tpPrice: Number(c.tp_trigger_price), slPrice: Number(c.sl_trigger_price), side: c.side, quoteDP: a2 ?? 2, baseDP: i ?? 2 }) }).then(() => (r3(false), _2(true), true), () => (_2(true), Promise.reject(false)));
  } }) })] });
};
var Lt$1 = (e2) => {
  let { position: t, order: o2, symbolInfo: i, isEditing: a2 } = e2, { resolve: l2, hide: p2, updateArgs: g2 } = j$3(), [r3] = useLocalStorage("orderly_order_confirm", true), { t: P2 } = ne$6(), _2 = a2 ? (o2 == null ? void 0 : o2.algo_type) === AlgoOrderRootType.POSITIONAL_TP_SL : void 0, m2 = (u2) => {
    a2 || g2({ title: u2 });
  }, T2 = () => {
    l2(), p2();
  }, { quote_dp: x2, base_dp: c } = i;
  return jsxs(Fragment$1, { children: [jsx(St$2, { position: t, symbolInfo: i }), jsx(M$1, { ...e2, onTPSLTypeChange: (u2) => {
    m2(u2 === AlgoOrderRootType.TP_SL ? P2("common.tpsl") : P2("tpsl.positionTpsl"));
  }, onComplete: T2, onConfirm: (u2, s2) => {
    if (!r3) return Promise.resolve(true);
    let L2 = Math.abs(Number(t.position_qty)), $2 = a2 || !!u2 && u2.algo_type === AlgoOrderRootType.POSITIONAL_TP_SL && u2.quantity === L2;
    return vo$4.confirm({ title: P2($2 ? "orders.editOrder" : "tpsl.confirmOrder"), bodyClassName: "oui-pb-0 lg:oui-pb-0", onOk: () => s2.submit(), content: jsx(B$2, { isPositionTPSL: _2, isEditing: a2, symbol: u2.symbol, qty: Number(u2.quantity), maxQty: L2, tpPrice: Number(u2.tp_trigger_price), slPrice: Number(u2.sl_trigger_price), side: u2.side, quoteDP: x2 ?? 2, baseDP: c ?? 2 }) }).then(() => true, (C2) => ((C2 == null ? void 0 : C2.message) && toast$2.error(C2.message), Promise.reject(false)));
  }, onCancel: () => {
    p2();
  } })] });
};
var St$2 = (e2) => {
  var _a3;
  let { position: t, symbolInfo: o2 } = e2, { data: i } = useMarkPrice(t.symbol), a2 = j$3(), { t: l2 } = ne$6(), p2 = useMemo(() => {
    var _a4;
    return ((_a4 = a2.args) == null ? void 0 : _a4.title) === l2("tpsl.positionTpsl");
  }, [(_a3 = a2.args) == null ? void 0 : _a3.title, l2]);
  return jsxs(Fragment$1, { children: [jsxs(z$3, { justify: "between", pb: 3, itemAlign: "center", children: [jsx(Q$1.formatted, { rule: "symbol", className: "oui-text-xs", showIcon: true, children: t.symbol }), jsxs(z$3, { gapX: 1, children: [p2 && jsx(Wd, { size: "xs", color: "primary", children: l2("common.position") }), jsx(Wd, { size: "xs", color: "neutral", children: l2("common.tpsl") }), t.position_qty < 0 ? jsx(Wd, { size: "xs", color: "buy", children: l2("common.buy") }) : jsx(Wd, { size: "xs", color: "sell", children: l2("common.sell") })] })] }), jsx(de$5, { intensity: 8 }), jsxs(W$2, { py: 3, className: "oui-space-y-1", children: [jsxs(z$3, { justify: "between", children: [jsx(Q$1, { size: "sm", intensity: 54, children: l2("common.avgOpen") }), jsx(Q$1.numeral, { className: "oui-text-xs", unit: o2.quote, dp: o2.quote_dp, unitClassName: "oui-ml-1 oui-text-base-contrast-36", children: t.average_open_price })] }), jsxs(z$3, { justify: "between", children: [jsx(Q$1, { size: "sm", intensity: 54, children: l2("common.markPrice") }), jsx(Q$1.numeral, { className: "oui-text-xs", unit: o2.quote, dp: o2.quote_dp, unitClassName: "oui-ml-1 oui-text-base-contrast-36", children: i })] })] })] });
};
var Je$3 = createContext({}), I = () => useContext(Je$3), Pt$1 = (t) => {
  let e2 = useSymbolsInfo()[t.symbol];
  return jsx(Je$3.Provider, { value: { base_dp: e2("base_dp"), quote_dp: e2("quote_dp"), base_tick: e2("base_tick"), quote_tick: e2("quote_tick"), base: e2("base"), quote: e2("quote"), symbol: t.symbol, origin: e2(), quote_max: e2("quote_max"), quote_min: e2("quote_min") }, children: t.children });
};
var eo$2 = createContext({}), O = () => useContext(eo$2), oe$2 = (t) => {
  var _a3;
  let [e2, o2] = useState(Math.abs(t.position.position_qty).toString()), { t: i } = ne$6();
  useEffect(() => {
    o2(Math.abs(t.position.position_qty).toString());
  }, [t.position.position_qty]);
  let [s2, n4] = useState(""), r3 = t.position.position_qty > 0 ? OrderSide.SELL : OrderSide.BUY, [a2, l2] = useState(void 0), [u2, c] = useState(OrderType.MARKET), d2 = useSymbolsInfo(), b2 = t.position.symbol, S2 = d2 == null ? void 0 : d2[b2], m2 = S2("quote_dp"), f2 = S2("base_dp"), P2 = S2("base_tick"), { helper: C2, onSubmit: y2, submitting: v3 } = useOrderEntry((_a3 = t.position) == null ? void 0 : _a3.symbol, r3, true), R2 = (L2, W2) => {
    if (c(L2), L2 === OrderType.LIMIT) {
      if (!W2) throw new Error(i("orderEntry.orderPrice.error.required"));
      n4(W2);
    } else n4("");
  }, H2 = useMemo(() => {
    let { position: L2 } = t;
    if (!L2) return null;
    let W2 = { order_quantity: e2, symbol: t.position.symbol, order_type: u2, side: r3, reduce_only: true };
    return u2 === OrderType.LIMIT && (W2.order_price = s2), W2;
  }, [t.position, s2, u2, e2]), T2 = (L2) => {
    let W2 = C2.calculate({}, "order_quantity", L2);
    o2(W2.order_quantity);
  }, z2 = (L2) => {
    let W2 = C2.calculate({}, "order_price", L2);
    n4(W2.order_price);
  };
  useEffect(() => {
    let L2 = H2;
    C2.validator(L2).then((W2) => {
      l2(W2);
    });
  }, [H2]);
  let kt2 = () => y2(H2).catch((L2) => (typeof L2 == "string" ? toast$2.error(L2) : toast$2.error(L2.message), Promise.resolve()));
  return jsx(eo$2.Provider, { value: { quantity: e2, price: s2, type: u2, side: r3, position: t.position, updatePriceChange: z2, updateQuantity: T2, updateOrderType: R2, tpslOrder: t.position.algo_order, onSubmit: kt2, submitting: v3, closeOrderData: H2, quoteDp: m2, baseDp: f2, baseTick: P2, errors: a2 }, children: t.children });
};
var ao$2 = () => {
  let [t, e2] = useState(false), { onSubmit: o2, price: i, quantity: s2, closeOrderData: n4, type: r3, submitting: a2, quoteDp: l2, errors: u2 } = O(), { base: c, quote: d2 } = I(), [b2] = useLocalStorage("orderly_order_confirm", true), { t: S2 } = ne$6(), { parseErrorMsg: m2 } = Lr$3(u2), f2 = () => o2().then((y2) => {
    e2(false);
  }, (y2) => {
    typeof y2 == "string" ? toast$2.error(y2) : toast$2.error(y2.message);
  }).catch((y2) => {
    typeof y2 == "string" ? toast$2.error(y2) : toast$2.error(y2.message);
  }), P2 = () => {
    e2(false);
  }, C2 = useMemo(() => r3 === OrderType.MARKET ? !s2 : !i || !s2, [i, s2, r3]);
  return jsxs(Fragment$1, { children: [jsx($e$6, { variant: "outlined", size: "sm", color: "secondary", disabled: C2 || a2, loading: a2, onClick: (y2) => {
    y2.stopPropagation();
    let v3 = m2("order_quantity"), R2 = m2("order_price"), H2 = v3 || R2;
    if (H2) {
      toast$2.error(H2);
      return;
    }
    if (!b2) {
      o2();
      return;
    }
    e2(true);
  }, children: S2("positions.column.close") }), jsx(Se$5, { open: t, onOpenChange: e2, size: "sm", children: r3 === OrderType.MARKET ? jsx(qt$3, { base: c, quantity: s2, onClose: P2, onConfirm: f2, submitting: a2, classNames: { root: "oui-items-start" }, hideCloseIcon: true }) : jsx(ne$3, { base: c, quantity: s2, price: i, onClose: P2, onConfirm: f2, submitting: a2, quoteDp: l2, order: n4, hideCloseIcon: true }) })] });
}, lo$2 = (t) => {
  let { hideCloseIcon: e2 = false } = t;
  return jsxs("div", { className: "oui-pb-3 oui-border-b oui-border-line-4 oui-relative oui-w-full", children: [jsx(Q$1, { size: "base", children: t.title }), !e2 && jsx("button", { onClick: t.onClose, className: "oui-absolute oui-right-0 oui-top-0 oui-text-base-contrast-54 hover:oui-text-base-contrast-80 oui-p-2", children: jsx(De$4, { size: 18, color: "white" }) })] });
}, mo$2 = ({ onCancel: t, onConfirm: e2, submitting: o2 }) => {
  let { t: i } = ne$6();
  return jsxs(z$3, { id: "oui-positions-confirm-footer", gap: 2, width: "100%", className: "oui-mt-3 oui-pb-1", children: [jsx($e$6, { id: "oui-positions-confirm-footer-cancel-button", color: "secondary", fullWidth: true, onClick: t, size: "md", children: i("common.cancel") }), jsx(Sr$2, { id: "oui-positions-confirm-footer-confirm-button", onClick: e2, fullWidth: true, loading: o2, size: "md", children: i("common.confirm") })] });
}, Zi$1 = (t) => {
  let { quantity: e2, price: o2, quoteDp: i, side: s2 } = t, { t: n4 } = ne$6(), r3 = useMemo(() => o2 && e2 ? new g$6(o2).mul(e2).toFixed(i, g$6.ROUND_DOWN) : "--", [o2, e2]);
  return jsxs(z$3, { direction: "column", gap: 1, width: "100%", className: "oui-text-sm oui-text-base-contrast-54", py: 5, children: [jsxs(z$3, { justify: "between", width: "100%", gap: 1, children: [jsx(Q$1, { children: n4("common.qty") }), jsx(Q$1, { color: s2 === OrderSide.BUY ? "success" : "danger", children: e2 })] }), jsxs(z$3, { justify: "between", width: "100%", gap: 1, children: [jsx(Q$1, { children: n4("common.price") }), jsx(Q$1.formatted, { intensity: 98, suffix: jsx(Q$1, { intensity: 54, children: "USDC" }), children: o2 })] }), jsxs(z$3, { justify: "between", width: "100%", gap: 1, children: [jsx(Q$1, { children: n4("common.notional") }), jsx(Q$1.formatted, { intensity: 98, suffix: jsx(Q$1, { intensity: 54, children: "USDC" }), children: r3 })] })] });
}, qt$3 = (t) => {
  var _a3;
  let { t: e2 } = ne$6(), o2 = () => {
    var _a4;
    (_a4 = (t == null ? void 0 : t.onClose) ?? t.close) == null ? void 0 : _a4();
  };
  return jsxs(z$3, { direction: "column", className: (_a3 = t.classNames) == null ? void 0 : _a3.root, children: [jsx(lo$2, { onClose: o2, title: e2("positions.marketClose"), hideCloseIcon: t.hideCloseIcon }), jsx(Q$1, { intensity: 54, size: "sm", className: "oui-my-5", children: e2("positions.marketClose.description", { quantity: E$4(t.quantity), base: t.base }) }), jsx(mo$2, { onCancel: o2, onConfirm: async () => {
    var _a4;
    await ((_a4 = t.onConfirm) == null ? void 0 : _a4.call(t)), o2();
  }, submitting: t.submitting })] });
}, ne$3 = (t) => {
  let { order: e2, quoteDp: o2, quantity: i, price: s2, submitting: n4 } = t, { side: r3 } = e2, { t: a2 } = ne$6(), l2 = () => {
    var _a3;
    (_a3 = t.onClose) == null ? void 0 : _a3.call(t);
  };
  return jsxs(Fragment$1, { children: [jsx(lo$2, { onClose: l2, title: a2("positions.limitClose"), hideCloseIcon: t.hideCloseIcon }), jsx(W$2, { mt: 5, children: jsx(Q$1, { intensity: 54, size: "sm", children: a2("positions.limitClose.description", { quantity: d$2(t.quantity), base: t.base }) }) }), jsxs(z$3, { gap: 2, mb: 4, mt: 5, justify: "between", children: [jsx(Q$1.formatted, { rule: "symbol", formatString: "base-type", size: "base", showIcon: true, children: e2.symbol }), jsxs(z$3, { gap: 1, children: [jsx(Wd, { color: "neutral", size: "xs", children: a2("orderEntry.orderType.limit") }), jsx(Wd, { color: r3 === OrderSide.BUY ? "success" : "danger", size: "xs", children: r3 === OrderSide.BUY ? a2("common.buy") : a2("common.sell") })] })] }), jsx(de$5, { className: "oui-w-full" }), jsx(Zi$1, { className: "oui-text-sm", price: s2, quantity: i, side: e2.side, quoteDp: o2 ?? 2 }), jsx(mo$2, { onCancel: l2, onConfirm: t.onConfirm, submitting: t.submitting })] });
};
var po$4 = () => {
  let { type: t, quoteDp: e2, price: o2, updatePriceChange: i, updateOrderType: s2, position: n4 } = O(), [r3, a2] = useState(false), { t: l2 } = ne$6();
  return jsxs(la$1, { children: [jsx(Fo$3, { size: "sm", value: t === OrderType.LIMIT ? o2 : l2("orderEntry.orderType.market"), onValueChange: (u2) => i(u2), formatters: [li$3.numberFormatter, ...e2 ? [li$3.dpFormatter(e2)] : []], onFocus: (u2) => {
    t === OrderType.MARKET && s2(OrderType.LIMIT, `${n4.mark_price}`), a2(true);
  }, onBlur: (u2) => {
    setTimeout(() => {
      a2(false);
    }, 100);
  }, suffix: jsx(ua$2, { asChild: true, children: jsx("button", { className: "oui-px-1 oui-h-full", children: jsx(oe$7, { size: 12, color: "white" }) }) }), classNames: { root: cnBase("oui-outline-line-12 focus-within:oui-outline-primary-light") } }), jsx(xr$3, { align: "end", className: "oui-w-[96px] oui-min-w-[96px]", onCloseAutoFocus: (u2) => u2.preventDefault(), children: jsx(dg, { children: jsx(br$5, { size: "xs", onSelect: (u2) => {
    s2(OrderType.MARKET);
  }, children: jsx("span", { children: l2("common.marketPrice") }) }) }) })] });
};
var xo$2 = (t) => {
  let [e2, o2] = useState(false), [i, s2] = useState(100), { baseDp: n4, quoteDp: r3, updateQuantity: a2, quantity: l2, type: u2, errors: c, baseTick: d2 } = O();
  useEffect(() => {
    let m2 = (f2) => {
      f2.target.closest("[data-popover-root]") || o2(false);
    };
    return document.addEventListener("click", m2), () => {
      document.removeEventListener("click", m2);
    };
  }, []);
  let b2 = (m2) => {
    S2(`${t.value * (m2 / 100)}`);
  }, S2 = (m2) => {
    if (d2 && d2 > 0) {
      let f2 = utils_exports.formatNumber(m2, d2) ?? m2;
      a2(f2);
    }
  };
  return jsxs(It$3, { children: [jsx(as$1, { children: jsx(Fo$3, { size: "sm", onFocus: () => {
    o2(true);
  }, classNames: { root: "oui-outline-line-12 " }, formatters: [li$3.numberFormatter, ...n4 ? [li$3.dpFormatter(n4)] : []], value: l2, onBlur: (m2) => S2(m2.target.value), onValueChange: (m2) => {
    if (a2(m2), m2 == "0" || m2 == "") {
      s2(0);
      return;
    }
    let f2 = new g$6(m2).div(t.value).mul(100).abs().toFixed(0, g$6.ROUND_DOWN);
    s2(Math.min(100, Number(f2)));
  } }) }), jsx(Vo$3, { className: "oui-w-[360px] oui-rounded-xl", align: "start", side: "bottom", onOpenAutoFocus: (m2) => {
    m2.preventDefault();
  }, children: jsxs(z$3, { p: 1, gap: 2, width: "100%", itemAlign: "start", children: [jsx(Q$1, { size: "xs", intensity: 98, className: "oui-min-w-[30px]", children: `${i}%` }), jsxs(z$3, { direction: "column", width: "100%", gap: 2, children: [jsx(iu, { markCount: 4, value: [i], onValueChange: (m2) => {
    let f2 = Array.from(m2.values());
    s2(f2[0]), b2(f2[0]);
  } }), jsx(Sn, { onClick: (m2) => {
    s2(m2 * 100), b2(m2 * 100);
  } })] })] }) })] });
}, Sn = (t) => {
  let { t: e2 } = ne$6(), o2 = [{ label: "0%", value: 0 }, { label: "25%", value: 0.25 }, { label: "50%", value: 0.5 }, { label: "75%", value: 0.75 }, { label: e2("common.max"), value: 1 }];
  return jsx(z$3, { gap: 2, width: "100%", children: o2.map((i, s2) => jsx($e$6, { variant: "outlined", color: "secondary", size: "xs", onClick: (n4) => {
    n4.stopPropagation(), t.onClick(i.value);
  }, className: "oui-w-1/5", children: i.label }, s2)) });
};
var bo$2 = (t, e2) => {
  let o2 = I();
  return jsx(Q$1.numeral, { dp: o2.base_dp, rm: g$6.ROUND_DOWN, padding: false, coloring: true, children: t });
}, Po = (t, e2) => jsx(xo$2, { value: e2.position_qty }), Co$3 = (t) => jsx(po$4, {});
var me$1 = (t) => {
  if (t.sharePnLConfig == null) return jsx(Fragment$1, {});
  let { position: e2 } = t, o2 = () => {
    let i = t.isPositionHistory ? { side: e2.side, pnl: e2.netPnL, openPrice: Math.abs(e2.avg_open_price), closePrice: Math.abs(e2.avg_close_price), openTime: e2.open_timestamp, closeTime: e2.close_timestamp, quantity: e2.closed_position_qty } : { side: e2.position_qty > 0 ? "LONG" : "SHORT", pnl: e2.unrealized_pnl, roi: new g$6(e2.unrealized_pnl_ROI * 100).toFixed(2, g$6.ROUND_DOWN), openPrice: Math.abs(e2.average_open_price), markPrice: e2.mark_price, openTime: e2.timestamp, quantity: e2.position_qty };
    vo$4.show(t.modalId, { pnl: { entity: { symbol: e2.symbol, ...i }, refCode: t.refCode, ...t.sharePnLConfig, leverage: t.isPositionHistory ? void 0 : t.leverage } });
  };
  return jsx("button", { type: "button", onClick: (i) => {
    i.stopPropagation(), o2();
  }, children: jsx(Dn, { color: "white", opacity: 0.54, size: t.iconSize ?? 16 }) });
};
var ho$4 = (t) => {
  let { sharePnLConfig: e2, position: o2, modalId: i, iconSize: s2, isPositionHistory: n4 } = t, { getFirstRefCode: r3 } = useReferralInfo(), a2 = useMemo(() => {
    var _a3;
    return (_a3 = r3()) == null ? void 0 : _a3.code;
  }, [r3]), l2 = useSymbolLeverage(t.position.symbol);
  return { iconSize: s2, position: o2, refCode: a2, leverage: l2, sharePnLConfig: e2, modalId: i, isPositionHistory: n4 };
};
var Z$3 = (t) => {
  let e2 = ho$4(t);
  return jsx(me$1, { ...e2 });
};
var To$2 = () => {
  let { position: t, baseDp: e2, quoteDp: o2, tpslOrder: i } = O(), { t: s2 } = ne$6();
  return jsx(pt$3, { position: t, order: i, label: s2("common.tpsl"), baseDP: e2, quoteDP: o2, isEditing: false });
}, wo$2 = () => {
  let { position: t, baseDp: e2, quoteDp: o2, tpslOrder: i } = O();
  return jsx(pt$3, { position: t, order: i, baseDP: e2, quoteDP: o2, isEditing: true, children: jsx(Rn$1, { opacity: 1, className: "oui-text-base-contrast-54 oui-cursor-pointer", size: 16 }) });
};
var qo$3 = (t) => {
  let { stopLossPrice: e2, takeProfitPrice: o2 } = t, { tpslOrder: i, position: s2 } = O();
  return jsx(An$1, { stopLossPrice: e2, takeProfitPrice: o2, direction: "column", order: i, position: s2, tooltip: true });
}, Do$2 = (t) => {
  let { qty: e2, price: o2, entryPrice: i, orderSide: s2, orderType: n4, symbolInfo: r3 } = t, a2 = utils_exports.priceToPnl({ qty: e2, price: o2, entryPrice: i, orderSide: s2, orderType: n4 }, { symbol: r3 }), l2 = n4 === AlgoOrderType.TAKE_PROFIT ? "TP" : "SL";
  return jsxs(z$3, { children: [jsx(Q$1, { intensity: 54, className: "oui-mr-1", children: `${l2} PnL:` }), jsx(Q$1.formatted, { rule: "price", className: a2 === 0 ? "oui-text-base-contrast-36" : a2 > 0 ? "oui-text-trade-profit oui-gap-0" : "oui-text-trade-loss oui-gap-0", prefix: jsx(Q$1, { children: a2 === 0 ? "" : a2 > 0 ? "+" : "-" }), suffix: jsx(Q$1, { intensity: 36, className: "oui-ml-1", children: "USDC" }), children: `${Math.abs(a2)}` })] });
}, An$1 = (t) => {
  let { direction: e2 = "row", order: o2, position: i } = t, s2 = useSymbolsInfo(), { t: n4 } = ne$6(), r3 = useMemo(() => {
    let c = [];
    if (!t.tooltip || !o2 || !i) return;
    let d2 = o2.quantity;
    return d2 === 0 && o2.child_orders[0].type === "CLOSE_POSITION" && (d2 = i.position_qty), t.takeProfitPrice && c.push(jsx(Do$2, { qty: d2, price: t.takeProfitPrice, entryPrice: i.average_open_price, orderSide: o2.side, orderType: AlgoOrderType.TAKE_PROFIT, symbolInfo: s2[o2.symbol]() }, "tp")), t.stopLossPrice && c.push(jsx(Do$2, { qty: d2, price: t.stopLossPrice, entryPrice: i.average_open_price, orderSide: o2.side, orderType: AlgoOrderType.STOP_LOSS, symbolInfo: s2[o2.symbol]() }, "sl")), jsx("div", { children: c });
  }, [t.takeProfitPrice, t.stopLossPrice, i == null ? void 0 : i.average_open_price, o2 == null ? void 0 : o2.side, o2 == null ? void 0 : o2.quantity, o2 == null ? void 0 : o2.algo_type]), a2 = useMemo(() => {
    let c = [];
    if (!(o2 == null ? void 0 : o2.symbol)) return jsx("span", { children: "-" });
    return t.takeProfitPrice && c.push(jsx(Q$1.formatted, { className: cnBase("oui-text-trade-profit oui-gap-0 oui-decoration-white/20"), rule: "price", dp: s2[o2.symbol]("quote_dp", 2), children: t.takeProfitPrice, prefix: !t.stopLossPrice || e2 === "column" ? jsx(Q$1, { intensity: 54, children: `${n4("tpsl.tp")} - ` }) : "" }, "tp")), t.stopLossPrice && c.push(jsx(Q$1.formatted, { className: cnBase("oui-text-trade-loss oui-gap-0 oui-decoration-white/20 "), rule: "price", dp: s2[o2.symbol]("quote_dp", 2), children: t.stopLossPrice, prefix: !t.takeProfitPrice || e2 === "column" ? jsx(Q$1, { intensity: 54, children: `${n4("tpsl.sl")} - ` }) : "" }, "sl")), c.length === 0 ? jsx(Q$1, { children: "-" }) : (c.length === 2 && e2 === "row" && c.splice(1, 0, jsx(Q$1, { children: "/" }, "split")), c);
  }, [t.takeProfitPrice, t.stopLossPrice, o2 == null ? void 0 : o2.symbol, n4]), l2 = jsx("div", { className: cnBase("oui-inline-flex oui-text-base-contrast-36", t.direction === "column" ? "oui-flex-col" : "oui-flex-row oui-gap-1", t.className), children: a2 }), u2 = Array.isArray(a2) ? !!a2.length : !a2;
  return t.tooltip ? jsxs(z$3, { gapX: 2, children: [jsx(xs, { content: r3, children: l2 }), u2 && jsx(wo$2, {})] }) : l2;
};
var Bo$2 = (t) => {
  let [e2, o2] = useLocalStorage("unPnlPriceBasis", "markPrice"), { t: i } = ne$6();
  return jsxs(z$3, { direction: "column", gap: 3, className: "oui-text-base-contrast-54 oui-items-start", children: [jsx(Q$1, { children: i("positions.column.unrealPnl.tooltip") }), jsx(de$5, { className: "oui-w-full" }), jsx("div", { className: "oui-mb-0", children: i("positions.column.unrealPnl.priceBasis") }), jsx(zn, { value: e2, onValueChange: o2 })] });
}, zn = (t) => {
  let { value: e2, onValueChange: o2 } = t, { t: i } = ne$6();
  return jsxs(z$3, { gap: 2, children: [jsx(vo$2, { sel: e2 === "markPrice", label: i("common.markPrice"), value: "markPrice", onCheckChange: o2 }), jsx(vo$2, { sel: e2 === "lastPrice", label: i("common.lastPrice"), value: "lastPrice", onCheckChange: o2 })] });
}, vo$2 = (t) => {
  let { sel: e2, label: o2, value: i, onCheckChange: s2 } = t;
  return jsxs(z$3, { onClick: (n4) => {
    s2(i), n4.stopPropagation();
  }, gap: 1, className: "oui-cursor-pointer", children: [e2 ? jsx(En$1, {}) : jsx(Wn$3, {}), jsx(Q$1, { size: "xs", intensity: e2 ? 98 : 54, children: o2 })] });
}, En$1 = () => jsxs("svg", { width: "16", height: "16", viewBox: "0 0 16 16", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", className: "oui-fill-white", children: [jsx("path", { d: "M8.01 1.333a6.667 6.667 0 1 0 0 13.333 6.667 6.667 0 0 0 0-13.333m0 1.333a5.334 5.334 0 1 1-.001 10.667 5.334 5.334 0 0 1 0-10.667", fill: "#fff", fillOpacity: ".36" }), jsx("circle", { cx: "8", cy: "8", r: "3.333" })] }), Wn$3 = () => jsx("svg", { width: "16", height: "16", viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: jsx("path", { d: "M8.01 1.333a6.667 6.667 0 1 0 0 13.333 6.667 6.667 0 0 0 0-13.333m0 1.333a5.334 5.334 0 1 1-.001 10.667 5.334 5.334 0 0 1 0-10.667", fill: "#fff", fillOpacity: ".54" }) });
var Et$1 = (t) => {
  let { tick: e2 = "quote_dp", ...o2 } = t, i = I();
  if (!i) throw new Error("NumeralWithCtx must be used inside SymbolProvider");
  return jsx(Q$1.numeral, { as: "span", ...o2, dp: i[e2] });
};
var ko$1 = (t) => {
  let { pnlNotionalDecimalPrecision: e2, sharePnLConfig: o2 } = t, { t: i } = ne$6();
  return useMemo(() => [{ title: i("common.symbol"), dataIndex: "symbol", fixed: "left", width: 140, onSort: (n4, r3) => n4.symbol.localeCompare(r3.symbol), render: (n4, r3) => jsxs(z$3, { gap: 2, children: [jsx(W$2, { width: 4, height: 20, className: cnBase("oui-rounded-[1px]", r3.position_qty > 0 ? "oui-bg-trade-profit" : "oui-bg-trade-loss") }), jsx(Q$1.formatted, { formatString: "base-type", className: "oui-cursor-pointer", onClick: (a2) => {
    var _a3;
    (_a3 = t.onSymbolChange) == null ? void 0 : _a3.call(t, { symbol: n4 }), a2.stopPropagation(), a2.preventDefault();
  }, children: `${n4.split("_")[1]}-PERP` })] }) }, { title: i("common.quantity"), dataIndex: "position_qty", onSort: (n4, r3) => n4.position_qty - r3.position_qty, width: 120, className: "oui-pl-6", render: bo$2 }, { title: i("common.avgOpen"), className: "oui-h-[48px]", width: 120, onSort: true, dataIndex: "average_open_price", render: (n4, r3) => jsx(Et$1, { rm: g$6.ROUND_DOWN, children: n4 }) }, { title: i("common.markPrice"), dataIndex: "mark_price", width: 120, onSort: true, className: "oui-h-[48px]", render: (n4, r3) => jsx(Et$1, { rm: g$6.ROUND_DOWN, children: n4 }) }, { title: jsx(xs, { className: "oui-max-w-[280px] oui-text-2xs oui-text-base-contrast-54 oui-p-3 oui-bg-base-8", content: i("positions.column.liqPrice.tooltip"), children: jsx(Q$1, { children: i("positions.column.liqPrice") }) }), width: 100, onSort: true, dataIndex: "est_liq_price", render: (n4, r3) => Number(n4) === 0 ? "--" : jsx(Et$1, { rm: g$6.ROUND_DOWN, className: Number(n4) > 0 ? "oui-text-warning-light" : "", children: n4 ?? "--" }) }, { title: jsx(L0, { content: jsx(Bo$2, {}), side: "top", align: "center", className: "oui-max-w-[280px] oui-text-2xs", children: jsx(Q$1, { children: i("common.unrealizedPnl") }) }), dataIndex: "unrealized_pnl", width: 180, onSort: true, rule: "price", numeralProps: { coloring: true }, render: (n4, r3) => jsxs(z$3, { gap: 2, children: [jsxs(z$3, { children: [jsx(Q$1.numeral, { dp: t.pnlNotionalDecimalPrecision, rm: g$6.ROUND_DOWN, coloring: true, className: "oui-font-semibold", children: n4 }), jsx(Q$1.numeral, { rule: "percentages", dp: t.pnlNotionalDecimalPrecision, rm: g$6.ROUND_DOWN, coloring: true, className: "oui-font-semibold", prefix: "(", suffix: ")", children: r3.unrealized_pnl_ROI })] }), jsx(Z$3, { position: r3, sharePnLConfig: t.sharePnLConfig, modalId: jt$2 })] }) }, { title: i("common.tpsl"), dataIndex: "__", width: 150, render: (n4, r3) => jsx(qo$3, { stopLossPrice: r3.sl_trigger_price, takeProfitPrice: r3.tp_trigger_price }) }, { title: i("common.notional"), dataIndex: "notional", className: "oui-h-[48px]", width: 100, onSort: true, render: (n4) => jsx(Q$1.numeral, { dp: e2, children: n4 }) }, { title: jsx(xs, { className: "oui-max-w-[280px] oui-text-2xs oui-text-base-contrast-54 oui-p-3 oui-bg-base-8", content: jsxs(z$3, { direction: "column", gap: 3, className: "oui-text-base-contrast-54 oui-bg-base-8 oui-rounded-sm", children: [jsx("span", { children: i("positions.column.margin.tooltip") }), jsx(de$5, { className: "oui-w-full" }), jsx("span", { children: i("positions.column.margin.formula") })] }), children: jsx(Q$1, { children: i("positions.column.margin") }) }), dataIndex: "mm", onSort: true, width: 100, rule: "price", render: (n4) => jsx(Q$1.numeral, { children: n4 }) }, { title: i("common.qty"), dataIndex: "close_qty", width: 100, fixed: "right", render: Po }, { title: i("common.price"), dataIndex: "close_price", width: 100, fixed: "right", render: Co$3 }, { title: "", dataIndex: "close_position", align: "right", width: 160, fixed: "right", render: (n4) => jsxs(z$3, { gapX: 2, justify: "end", children: [jsx(ao$2, {}), jsx(To$2, {})] }) }], [e2, o2, i]);
};
var Ao$3 = (t) => {
  let { item: e2 } = t, o2 = e2.position_qty > 0, { t: i } = ne$6();
  return jsx(Q$1.formatted, { rule: "symbol", formatString: "base-type", size: "2xs", suffix: jsx(Wd, { color: o2 ? "success" : "danger", size: "xs", children: i(o2 ? "common.long" : "common.short") }), showIcon: true, onClick: () => {
    var _a3;
    (_a3 = t.onSymbolChange) == null ? void 0 : _a3.call(t, { symbol: e2.symbol });
  }, children: e2.symbol });
}, Ho$3 = (t) => {
  let { item: e2 } = t, { t: o2 } = ne$6();
  return jsxs(z$3, { gap: 3, children: [jsxs(z$3, { direction: "column", className: "oui-text-2xs", itemAlign: "end", children: [jsxs("div", { children: [jsx(Q$1, { intensity: 36, children: o2("common.unrealizedPnl") }), jsx(Q$1, { intensity: 20, children: "(USDC)" })] }), jsx(Q$1.numeral, { size: "xs", dp: t.pnlNotionalDecimalPrecision, rm: g$6.ROUND_DOWN, coloring: true, className: "orderly-font-semibold", suffix: jsx(Q$1.numeral, { rule: "percentages", dp: t.pnlNotionalDecimalPrecision, rm: g$6.ROUND_DOWN, prefix: "(", suffix: ")", className: cnBase("oui-ml-1", e2.unrealized_pnl_ROI > 0 ? "oui-text-success-darken" : "oui-text-danger-darken"), children: e2.unrealized_pnl_ROI }), children: e2.unrealized_pnl })] }), jsx(Z$3, { position: e2, sharePnLConfig: t.sharePnLConfig, modalId: eo$3, iconSize: 12 })] });
}, Ro$2 = (t) => {
  let { item: e2 } = t, { t: o2 } = ne$6();
  return jsx(za$1, { label: o2("common.qty"), classNames: { root: "oui-text-xs", label: "oui-text-2xs" }, children: jsx(Q$1.numeral, { dp: t.base_dp, padding: false, coloring: true, children: e2.position_qty }) });
}, zo$2 = (t) => {
  let { item: e2 } = t, { t: o2 } = ne$6();
  return jsx(za$1, { label: jsxs("span", { children: [o2("positions.column.margin"), jsx(Q$1, { intensity: 20, children: "(USDC)" })] }), classNames: { root: "oui-text-xs", label: "oui-text-2xs" }, children: jsx(Q$1.numeral, { dp: t.quote_dp, intensity: 80, children: e2.mm }) });
}, Eo$2 = (t) => {
  let { item: e2 } = t, { t: o2 } = ne$6();
  return jsx(za$1, { align: "end", label: jsxs("span", { children: [o2("common.notional"), jsx(Q$1, { intensity: 20, children: "(USDC)" })] }), classNames: { root: "oui-text-xs", label: "oui-text-2xs" }, children: jsx(Q$1.numeral, { dp: t.quote_dp, intensity: 80, children: e2.notional }) });
}, Wo$3 = (t) => {
  let { item: e2 } = t, { t: o2 } = ne$6();
  return jsx(za$1, { label: o2("common.avgOpen"), classNames: { root: "oui-text-xs", label: "oui-text-2xs" }, children: jsx(Q$1.numeral, { dp: t.quote_dp, rm: g$6.ROUND_DOWN, intensity: 80, children: e2.average_open_price }) });
}, Uo = (t) => {
  let { item: e2 } = t, { t: o2 } = ne$6();
  return jsx(za$1, { label: o2("common.markPrice"), classNames: { root: "oui-text-xs", label: "oui-text-2xs" }, children: jsx(Q$1.numeral, { dp: t.quote_dp, rm: g$6.ROUND_DOWN, intensity: 80, children: e2.mark_price }) });
}, Qo$2 = (t) => {
  let { item: e2 } = t, { t: o2 } = ne$6(), i = e2.est_liq_price && e2.est_liq_price > 0 ? e2.est_liq_price : "-";
  return jsx(za$1, { label: o2("positions.column.liqPrice"), align: "end", classNames: { root: "oui-text-xs", label: "oui-text-2xs" }, children: jsx(Q$1.numeral, { dp: t.quote_dp, rm: g$6.ROUND_DOWN, color: "warning", children: i }) });
}, $o = (t) => {
  let { item: e2 } = t, { t: o2 } = ne$6();
  return e2.tp_trigger_price == null && e2.sl_trigger_price == null ? jsx(Fragment$1, {}) : jsxs(z$3, { className: "oui-text-2xs oui-text-base-contrast-36", children: [jsxs(Q$1, { children: [`${o2("common.tpsl")}:`, ""] }), jsxs(z$3, { className: "oui-gap-[2px]", children: [e2.tp_trigger_price && jsx(Q$1.numeral, { color: "buy", children: e2.tp_trigger_price }), e2.sl_trigger_price && "/", e2.sl_trigger_price && jsx(Q$1.numeral, { color: "sell", children: e2.sl_trigger_price })] })] });
};
var ye$2 = (t) => {
  var _a3, _b2;
  let { item: e2, sheetOpen: o2, setSheetOpen: i, dialogOpen: s2, setDialogOpen: n4, updatePriceChange: r3, base: a2, quantity: l2, price: u2, onClose: c, onConfirm: d2, submitting: b2, quote_dp: S2, closeOrderData: m2, onCloseDialog: f2 } = t, P2 = e2.position_qty > 0, { t: C2 } = ne$6(), { parseErrorMsg: y2 } = Lr$3(t.errors), v3 = y2("order_quantity"), R2 = y2("order_price"), H2 = (T2) => {
    if (t.baseTick && t.baseTick > 0) {
      let z2 = utils_exports.formatNumber(T2, t.baseTick) ?? T2;
      t.updateQuantity(z2);
    }
  };
  return jsxs(Fragment$1, { children: [jsx($e$6, { variant: "outlined", color: "secondary", size: "sm", className: "oui-border-base-contrast-36", onClick: () => {
    r3("limit"), i(true);
  }, children: C2("positions.limitClose") }), o2 && jsx(Jo, { title: C2("positions.limitClose"), open: o2, onOpenChange: i, children: jsxs(z$3, { direction: "column", gap: 3, width: "100%", itemAlign: "start", className: "oui-text-sm", children: [jsxs(z$3, { width: "100%", justify: "between", children: [jsx(Q$1.formatted, { rule: "symbol", showIcon: true, children: e2.symbol }), jsxs(z$3, { gap: 1, children: [jsx(Wd, { color: "neutral", size: "xs", children: C2("orderEntry.orderType.limit") }), P2 && jsx(Wd, { color: "success", size: "xs", children: C2("common.buy") }), !P2 && jsx(Wd, { color: "danger", size: "xs", children: C2("common.sell") })] })] }), jsx(de$5, { className: "oui-w-full" }), jsxs(z$3, { width: "100%", justify: "between", children: [jsx(Q$1, { intensity: 54, children: C2("common.lastPrice") }), jsx(Q$1.numeral, { dp: (_b2 = (_a3 = t.item) == null ? void 0 : _a3.symbolInfo) == null ? void 0 : _b2.quote_dp, suffix: jsx(Q$1, { intensity: 36, children: " USDC" }), children: t.curMarkPrice })] }), jsxs(z$3, { width: "100%", direction: "column", gap: 2, children: [jsx(Fo$3.tooltip, { prefix: C2("common.price"), suffix: t.quote, align: "right", fullWidth: true, autoComplete: "off", formatters: [li$3.numberFormatter, li$3.dpFormatter(t.quote_dp)], triggerClassName: "oui-w-full", tooltip: R2, color: R2 ? "danger" : void 0, value: t.price, onValueChange: (T2) => t.updatePriceChange(T2), classNames: { prefix: "oui-text-base-contrast-54", suffix: "oui-text-base-contrast-54", root: cnBase("oui-outline-line-12 oui-w-full", R2 ? "oui-outline-danger" : void 0) } }), jsx(Fo$3, { prefix: C2("common.quantity"), suffix: t.base, align: "right", fullWidth: true, autoComplete: "off", formatters: [li$3.numberFormatter, li$3.dpFormatter(t.base_dp)], value: t.quantity, onBlur: (T2) => H2(T2.target.value), onValueChange: (T2) => {
    t.updateQuantity(T2);
    let z2 = new g$6(T2).div(t.item.position_qty).mul(100).toDecimalPlaces(2, g$6.ROUND_DOWN).toNumber();
    t.setSliderValue(z2);
  }, classNames: { prefix: "oui-text-base-contrast-54", suffix: "oui-text-base-contrast-54", root: cnBase("oui-outline-line-12 oui-w-full") } }), jsx(iu, { markCount: 4, value: [t.sliderValue], color: "primary", onValueChange: (T2) => {
    t.setSliderValue(T2[0]);
    let z2 = new g$6(T2[0]).div(100).mul(t.item.position_qty).toFixed(t.base_dp, g$6.ROUND_DOWN);
    H2(z2);
  } }), jsxs(z$3, { width: "100%", justify: "between", children: [jsx(Q$1, { color: "primary", size: "2xs", children: `${t.sliderValue}%` }), jsxs(z$3, { gap: 1, children: [jsx(Q$1, { size: "2xs", color: "primary", children: C2("common.max") }), jsx(Q$1.numeral, { intensity: 54, size: "2xs", children: Math.abs(t.item.position_qty) })] })] })] }), jsxs(z$3, { width: "100%", gap: 3, mt: 2, children: [jsx($e$6, { fullWidth: true, color: "secondary", onClick: (T2) => {
    c();
  }, children: C2("common.cancel") }), jsx(Sr$2, { fullWidth: true, disabled: b2, loading: b2, onClick: (T2) => {
    T2.stopPropagation(), T2.preventDefault();
    let z2 = v3 || R2;
    if (z2) {
      toast$2.error(z2);
      return;
    }
    if (!t.orderConfirm) {
      d2();
      return;
    }
    n4(true);
  }, children: C2("common.confirm") })] })] }) }), s2 && jsx(Se$5, { open: s2, onOpenChange: n4, size: "xs", children: jsx(ne$3, { base: a2, quantity: l2, price: u2, onClose: f2, onConfirm: d2, submitting: b2, quoteDp: S2, order: m2, hideCloseIcon: true }) })] });
};
var xe = (t) => {
  let { state: e2 } = t, [o2, i] = useState(false), [s2, n4] = useState(false), { onSubmit: r3, price: a2, quantity: l2, closeOrderData: u2, submitting: c, type: d2, updatePriceChange: b2, updateOrderType: S2, updateQuantity: m2, errors: f2, baseTick: P2 } = O(), C2 = useRef(false), [y2, v3] = useState(100), [R2] = useLocalStorage("orderly_order_confirm", true), H2 = () => r3().then((At2) => {
    i(false), n4(false);
  }, (At2) => {
    typeof At2 == "string" ? toast$2.error(At2) : toast$2.error(At2.message);
  }), T2 = () => {
    i(false);
  }, z2 = () => {
    n4(false);
  }, kt2 = useMarkPricesStream(), L2 = useMemo(() => {
    var _a3;
    return ((_a3 = kt2 == null ? void 0 : kt2.data) == null ? void 0 : _a3[e2.item.symbol]) ?? "--";
  }, [kt2]), { quote_dp: W2, base_dp: Li2, base: qi2, quote: Ni2 } = I();
  return useEffect(() => {
    !C2.current && L2 && o2 && (C2.current = true, S2(OrderType.LIMIT, `${L2}`));
  }, [C2, L2, o2]), useEffect(() => {
    o2 || (S2(OrderType.MARKET), C2.current = false);
  }, [o2]), { ...e2, sheetOpen: o2, setSheetOpen: i, curMarkPrice: L2, quote_dp: W2, base_dp: Li2, base: qi2, quote: Ni2, baseTick: P2, orderConfirm: R2, onClose: T2, onConfirm: H2, price: a2, quantity: l2, closeOrderData: u2, submitting: c, updatePriceChange: b2, updateQuantity: m2, errors: f2, sliderValue: y2, setSliderValue: v3, dialogOpen: s2, setDialogOpen: n4, onCloseDialog: z2 };
};
var be$1 = (t) => {
  let e2 = xe(t);
  return jsx(ye$2, { ...e2 });
};
var Ce$1 = (t) => {
  let { t: e2 } = ne$6();
  return jsxs(Fragment$1, { children: [jsx($e$6, { variant: "outlined", color: "secondary", size: "sm", className: "oui-border-base-contrast-36", disabled: t.submitting, loading: t.submitting, onClick: (o2) => {
    if (o2.stopPropagation(), o2.preventDefault(), t.updateOrderType(OrderType.MARKET), !t.orderConfirm) {
      t.onConfirm();
      return;
    }
    t.setDialogOpen(true);
  }, children: e2("positions.marketClose") }), jsx(Se$5, { open: t.dialogOpen, onOpenChange: t.setDialogOpen, size: "xs", children: jsx(qt$3, { base: t.base, quantity: t.quantity, onClose: t.onClose, onConfirm: t.onConfirm, submitting: t.submitting, hideCloseIcon: true }) })] });
};
var Se$3 = (t) => {
  let e2 = I(), [o2, i] = useState(false), { onSubmit: s2, price: n4, quantity: r3, closeOrderData: a2, submitting: l2, type: u2, updatePriceChange: c, updateOrderType: d2, updateQuantity: b2 } = O(), [S2] = useLocalStorage("orderly_order_confirm", true);
  return { ...t, ...e2, dialogOpen: o2, setDialogOpen: i, orderConfirm: S2, onSubmit: s2, quantity: r3, onClose: () => {
    i(false);
  }, onConfirm: () => s2().then((P2) => {
    i(false);
  }, (P2) => {
    typeof P2 == "string" ? toast$2.error(P2) : toast$2.error(P2.message);
  }), submitting: l2, updateOrderType: d2, updateQuantity: b2 };
};
var he$2 = (t) => {
  let e2 = Se$3(t);
  return jsx(Ce$1, { ...e2 });
};
var _e$2 = (t) => {
  let { t: e2 } = ne$6();
  return jsx($e$6, { variant: "outlined", color: "secondary", size: "sm", className: "oui-border-base-contrast-36", onClick: (o2) => {
    o2.stopPropagation(), o2.preventDefault(), t.openTP_SL();
  }, children: e2("common.tpsl") });
};
var Te$2 = (t) => {
  let e2 = useSymbolsInfo()[t.state.item.symbol](), { tpslOrder: o2 } = O(), { t: i } = ne$6();
  return { openTP_SL: () => {
    vo$4.sheet({ title: i("common.tpsl"), content: jsx(Lt$1, { position: t.state.item, symbolInfo: e2, order: o2, isEditing: false }) });
  }, ...t, ...e2 };
};
var we$3 = (t) => {
  let e2 = Te$2(t);
  return jsx(_e$2, { ...e2 });
};
var Fe$2 = (t) => {
  let { className: e2, ...o2 } = t;
  return jsxs(z$3, { direction: "column", width: "100%", gap: 2, p: 2, r: "xl", itemAlign: "start", className: cnBase(e2, "oui-bg-base-9"), children: [jsx(Ar$3, { ...o2 }), jsx(de$5, { intensity: 6, className: "oui-w-full" }), jsx(Hr$3, { ...o2 }), jsx($o, { ...o2 }), jsx(Rr$2, { ...o2 })] });
}, Ar$3 = (t) => jsxs(z$3, { justify: "between", width: "100%", children: [jsx(Ao$3, { ...t }), jsx(Ho$3, { ...t })] }), Hr$3 = (t) => jsxs(Sa$1, { cols: 3, rows: 2, gap: 2, width: "100%", children: [jsx(Ro$2, { ...t }), jsx(zo$2, { ...t }), jsx(Eo$2, { ...t }), jsx(Wo$3, { ...t }), jsx(Uo, { ...t }), jsx(Qo$2, { ...t })] }), Rr$2 = (t) => jsxs(Sa$1, { width: "100%", gap: 2, cols: 3, rows: 1, children: [jsx(we$3, { state: t }), jsx(be$1, { state: t }), jsx(he$2, { state: t })] });
var De$3 = (t) => {
  let e2 = I();
  return { ...t, ...e2 };
};
var Le$2 = (t) => {
  let e2 = De$3(t);
  return jsx(Fe$2, { ...e2, className: t.className });
};
var ei$2 = (t) => {
  let { pnlNotionalDecimalPrecision: e2, sharePnLConfig: o2, pagination: i } = t, s2 = ko$1({ pnlNotionalDecimalPrecision: e2, sharePnLConfig: o2, onSymbolChange: t.onSymbolChange });
  return jsx(dt$3, { loading: t.isLoading, id: "oui-desktop-positions-content", columns: s2, bordered: true, dataSource: t.dataSource, generatedRowKey: (n4) => n4.symbol, renderRowContainer: (n4, r3, a2) => jsx(Pt$1, { symbol: n4.symbol, children: jsx(oe$2, { position: n4, children: a2 }) }), manualPagination: false, pagination: i, testIds: { body: "oui-testid-dataList-position-tab-body" } });
}, oi$2 = (t) => {
  let { pnlNotionalDecimalPrecision: e2, sharePnLConfig: o2 } = t;
  return jsx(og$1, { className: "oui-w-full oui-hide-scrollbar oui-overflow-y-hidden oui-space-y-0", contentClassName: "!oui-space-y-1", dataSource: t.dataSource, renderItem: (i, s2) => jsx(Pt$1, { symbol: i.symbol, children: jsx(oe$2, { position: i, children: jsx(Le$2, { item: i, index: s2, pnlNotionalDecimalPrecision: e2, sharePnLConfig: o2, onSymbolChange: t.onSymbolChange }) }) }) });
};
var qe$4 = (t) => {
  let { symbol: e2, calcMode: o2, includedPendingOrder: i, pnlNotionalDecimalPrecision: s2, sharePnLConfig: n4, onSymbolChange: r3 } = t, { pagination: a2, setPage: l2 } = p0({ pageSize: 50 }), [u2, c, { isLoading: d2 }] = usePositionStream(e2, { calcMode: o2, includedPendingOrder: i });
  return useEffect(() => {
    l2(1);
  }, [e2]), { dataSource: Tr$2(u2 == null ? void 0 : u2.rows, { fallbackData: [] }) ?? void 0, isLoading: d2, pnlNotionalDecimalPrecision: s2, sharePnLConfig: n4, symbol: e2, onSymbolChange: r3, pagination: a2 };
};
var Gr$2 = (t) => {
  let e2 = qe$4(t);
  return jsx(ei$2, { ...e2 });
}, Kr$2 = (t) => {
  let e2 = qe$4(t);
  return jsx(oi$2, { ...e2 });
};
var si$1 = (t) => {
  let { onSymbolChange: e2, pnlNotionalDecimalPrecision: o2 } = t, { t: i } = ne$6();
  return useMemo(() => [{ title: i("common.symbol"), dataIndex: "symbol", fixed: "left", width: 200, onSort: (n4, r3) => n4.symbol.localeCompare(r3.symbol), render: (n4, r3) => jsx(jr$1, { record: r3, onSymbolChange: e2 }) }, { title: i("positions.history.column.closed&maxClosed"), dataIndex: "close_maxClose", width: 200, render: (n4, r3) => jsx(ts, { record: r3 }) }, { title: i("positions.history.column.netPnl"), dataIndex: "netPnL", width: 140, onSort: (n4, r3) => n4.netPnL == null || r3.netPnL == null ? -1 : (n4.netPnL ?? 0) - (r3.netPnL ?? 0), render: (n4, r3) => jsxs(z$3, { gapX: 1, children: [jsx(es, { record: r3, pnlNotionalDecimalPrecision: o2 }), jsx(Z$3, { position: r3, sharePnLConfig: t.sharePnLConfig, modalId: jt$2, isPositionHistory: true })] }) }, { title: i("common.avgPrice"), dataIndex: "avg_open", width: 140, render: (n4, r3) => {
    let a2 = r3.avg_open_price != null ? Math.abs(r3.avg_open_price) : "--", { quote_dp: l2 } = I();
    return jsx(Q$1.numeral, { dp: l2, padding: false, children: a2 });
  } }, { title: i("common.avgClose"), dataIndex: "avg_close", width: 175, render: (n4, r3) => {
    let a2 = r3.avg_close_price != null ? Math.abs(r3.avg_close_price) : "--", { quote_dp: l2 } = I();
    return jsx(Q$1.numeral, { dp: l2, padding: false, children: a2 });
  } }, { title: i("positions.history.column.timeOpened"), dataIndex: "open_timestamp", width: 175, onSort: true, render: (n4, r3) => jsx(Q$1.formatted, { rule: "date", formatString: "yyyy-MM-dd HH:mm:ss", children: r3.open_timestamp }) }, { title: i("positions.history.column.timeClosed"), dataIndex: "close_timestamp", width: 175, onSort: true, render: (n4, r3) => r3.position_status == "closed" && r3.close_timestamp ? jsx(Q$1.formatted, { rule: "date", formatString: "yyyy-MM-dd HH:mm:ss", children: r3.close_timestamp ?? "--" }) : "--" }, { title: i("positions.history.column.updatedTime"), dataIndex: "last_update_time", width: 175, onSort: true, render: (n4, r3) => jsx(Q$1.formatted, { rule: "date", formatString: "yyyy-MM-dd HH:mm:ss", children: r3.last_update_time }) }], [o2, i]);
}, jr$1 = (t) => {
  let { record: e2, onSymbolChange: o2 } = t, { t: i } = ne$6(), s2 = useMemo(() => {
    let n4 = [], r3 = e2.position_status, a2 = () => r3 === "closed" ? i("positions.history.status.closed") : r3 === "partial_closed" ? i("positions.history.status.partialClosed") : yg(r3.replace("_", " "));
    return n4.push(jsx(Wd, { color: r3 !== "closed" ? "primaryLight" : "neutral", size: "xs", className: "oui-break-normal oui-whitespace-nowrap", children: a2() })), e2.type === "adl" ? n4.push(jsx(Wd, { color: "danger", size: "xs", children: i("positions.history.type.adl") })) : e2.type === "liquidated" && n4.push(jsx(xs, { className: "oui-min-w-[204px] oui-bg-base-5", arrow: { className: "oui-fill-base-5" }, content: jsxs(z$3, { direction: "column", itemAlign: "start", className: "oui-text-2xs", children: [e2.liquidation_id != null && jsxs(z$3, { justify: "between", width: "100%", gap: 2, children: [jsx(Q$1, { intensity: 54, children: i("positions.history.liquidated.liquidationId") }), jsx(Q$1, { intensity: 98, children: e2.liquidation_id })] }), jsxs(z$3, { justify: "between", width: "100%", gap: 2, children: [jsx(Q$1, { intensity: 54, children: i("positions.history.liquidated.liquidatorFee") }), jsxs(Q$1, { color: "lose", children: [e2.liquidator_fee > 0 && "-", E$4(e2.liquidator_fee)] })] }), jsxs(z$3, { justify: "between", width: "100%", gap: 2, children: [jsx(Q$1, { intensity: 54, children: i("positions.history.liquidated.insFundFee") }), jsxs(Q$1, { color: "lose", children: [e2.insurance_fund_fee > 0 && "-", E$4(e2.insurance_fund_fee)] })] })] }), children: jsx("div", { children: jsx(Wd, { size: "xs", color: "danger", className: "oui-cursor-pointer", children: jsx("span", { className: "oui-underline oui-decoration-dashed oui-decoration-[1px]", children: i("positions.history.type.liquidated") }) }) }) })), n4;
  }, [e2, i]);
  return jsxs(z$3, { gap: 2, height: 48, children: [jsx(W$2, { width: 4, height: 38, className: cnBase("oui-rounded-[1px] oui-shrink-0", e2.side === "LONG" ? "oui-bg-trade-profit" : "oui-bg-trade-loss") }), jsxs(z$3, { direction: "column", itemAlign: "start", children: [jsx(Q$1.formatted, { formatString: "base-type", className: "oui-cursor-pointer", onClick: (n4) => {
    o2 == null ? void 0 : o2({ symbol: e2.symbol }), n4.stopPropagation(), n4.preventDefault();
  }, children: `${e2.symbol.split("_")[1]}-PERP` }), jsx(z$3, { gap: 1, children: s2 })] })] });
}, ts = (t) => {
  let { record: e2 } = t, { base_dp: o2 } = I();
  return jsxs(z$3, { gap: 1, direction: "column", itemAlign: "start", className: "oui-overflow-hidden oui-whitespace-nowrap oui-text-ellipsis", children: [jsx(Q$1.numeral, { dp: o2, padding: false, children: Math.abs(e2.closed_position_qty) }), jsx(Q$1.numeral, { dp: o2, padding: false, className: "oui-truncate", children: Math.abs(e2.max_position_qty) })] });
}, es = (t) => {
  let { record: e2, pnlNotionalDecimalPrecision: o2 } = t, { t: i } = ne$6(), s2 = e2.netPnL != null ? e2.netPnL : void 0, n4 = () => jsx(Q$1.numeral, { dp: o2, color: e2.netPnL != null ? e2.netPnL > 0 ? "profit" : "lose" : void 0, className: s2 == null ? "" : "oui-cursor-pointer oui-border-b oui-border-dashed oui-border-line-12", children: s2 ?? "--" });
  return e2.netPnL == null ? n4() : jsx(xs, { delayDuration: 200, content: jsxs(z$3, { direction: "column", itemAlign: "start", className: "oui-text-2xs", children: [jsx(Q$1, { intensity: 80, children: i("positions.history.column.netPnl") }), jsxs(z$3, { justify: "between", width: "100%", gap: 2, children: [jsx(Q$1, { intensity: 54, children: i("common.realizedPnl") }), jsx(Q$1, { color: e2.realized_pnl >= 0 ? "profit" : "lose", className: "oui-cursor-pointer", children: E$4(e2.realized_pnl) })] }), jsxs(z$3, { justify: "between", width: "100%", gap: 2, children: [jsx(Q$1, { intensity: 54, children: i("positions.history.netPnl.fundingFee") }), jsx(Q$1, { color: e2.accumulated_funding_fee > 0 ? "lose" : "profit", className: "oui-cursor-pointer", children: E$4(-e2.accumulated_funding_fee) })] }), jsxs(z$3, { justify: "between", width: "100%", gap: 2, children: [jsx(Q$1, { intensity: 54, children: i("positions.history.netPnl.tradingFee") }), jsx(Q$1, { color: e2.trading_fee > 0 ? "lose" : "profit", className: "oui-cursor-pointer", children: E$4(-e2.trading_fee) })] })] }), className: "oui-min-w-[204px] oui-bg-base-5", arrow: { className: "oui-fill-base-5" }, children: jsx("div", { children: n4() }) });
};
function B$1(t) {
  if (t == null) return t;
  let e2 = new Date(t);
  return e2.setHours(0, 0, 0, 0), e2;
}
function M(t) {
  if (t == null) return t;
  let e2 = new Date(t);
  return e2.setHours(23, 59, 59, 999), e2;
}
var St$1 = (t) => ({ from: B$1(t.from), to: M(t.to ?? t.from) }), ht$2 = (t, e2) => t.getTime() === e2.getTime();
var Gt$3 = (t) => {
  let { onSymbolChange: e2, symbol: o2, pnlNotionalDecimalPrecision: i } = t, { state: s2 } = useAccount(), { data: n4, isLoading: r3 } = usePrivateQuery(o2 ? `/v1/position_history?symbol=${o2}&limit=1000` : "/v1/position_history?limit=1000", { formatter(y2) {
    var _a3;
    return (_a3 = y2.rows ?? null) == null ? void 0 : _a3.map((v3) => {
      if (v3.realized_pnl != null && v3.accumulated_funding_fee != null && v3.trading_fee != null) {
        let R2 = v3.realized_pnl - v3.accumulated_funding_fee - v3.trading_fee;
        return { ...v3, netPnL: R2 };
      }
      return v3;
    });
  }, revalidateOnFocus: true }), { pagination: a2, setPage: l2 } = p0({ pageSize: 10 }), { status: u2, side: c, dateRange: d2, filterDays: b2, updateFilterDays: S2, filterItems: m2, onFilter: f2 } = us$1();
  useEffect(() => {
    l2(1);
  }, [u2, c, d2, b2, o2]);
  let P2 = useMemo(() => n4 == null ? n4 : n4.filter((y2) => {
    let v3 = c === "all" ? true : y2.side.toLowerCase() === c.toLowerCase(), R2 = u2 === "all" ? true : y2.position_status.toLowerCase() === u2.toLowerCase(), H2 = (y2 == null ? void 0 : y2.last_update_time) ?? y2.open_timestamp, T2 = d2.from && d2.to ? H2 >= d2.from.getTime() && H2 <= d2.to.getTime() : true, z2 = o2 ? y2.symbol == o2 : true;
    return v3 && R2 && T2 && z2;
  }), [u2, c, d2, n4, o2]);
  return { dataSource: Tr$2(P2, { accountStatus: s2.status === AccountStatusEnum.EnableTradingWithoutConnected ? AccountStatusEnum.EnableTradingWithoutConnected : AccountStatusEnum.EnableTrading, fallbackData: [] }), isLoading: r3, onSymbolChange: e2, pagination: a2, filterItems: m2, onFilter: f2, symbol: o2, filterDays: b2, updateFilterDays: S2, pnlNotionalDecimalPrecision: i };
}, us$1 = () => {
  let { t } = ne$6(), [e2, o2] = useState("all"), [i, s2] = useState("all"), n4 = St$1({ to: M(/* @__PURE__ */ new Date()), from: B$1(subDays(/* @__PURE__ */ new Date(), 89)) }), [r3, a2] = useState(90), [l2, u2] = useState(n4), c = (m2) => {
    a2(m2), u2({ from: B$1(subDays(/* @__PURE__ */ new Date(), m2 - 1)), to: M(/* @__PURE__ */ new Date()) });
  }, d2 = (m2) => {
    if (m2.name === "side" && s2(m2.value), m2.name === "status" && o2(m2.value), m2.name === "dateRange") {
      let f2 = St$1(m2.value);
      if (u2(f2), f2.from && f2.to) {
        let P2 = Math.abs(differenceInDays(f2.from, f2.to)) + 1, y2 = { 1: { from: B$1(/* @__PURE__ */ new Date()), to: M(/* @__PURE__ */ new Date()) }, 7: { from: B$1(subDays(/* @__PURE__ */ new Date(), 6)), to: M(/* @__PURE__ */ new Date()) }, 30: { from: B$1(subDays(/* @__PURE__ */ new Date(), 29)), to: M(/* @__PURE__ */ new Date()) }, 90: { from: B$1(subDays(/* @__PURE__ */ new Date(), 89)), to: M(/* @__PURE__ */ new Date()) } }[P2];
        y2 && ht$2(y2.from, f2.from) && ht$2(y2.to, f2.to) ? a2(P2) : a2(null);
      }
    }
  }, { isMobile: b2 } = it$6();
  return { filterItems: useMemo(() => {
    let m2 = { type: "select", name: "side", options: [{ label: t("common.side.all"), value: "all" }, { label: t("common.buy"), value: "LONG" }, { label: t("common.sell"), value: "SHORT" }], value: i }, f2 = { type: "range", name: "dateRange", value: l2, fromDate: B$1(subDays(/* @__PURE__ */ new Date(), 89)), toDate: M(/* @__PURE__ */ new Date()) }, P2 = { type: "select", name: "status", options: [{ label: t("common.status.all"), value: "all" }, { label: t("positions.history.status.closed"), value: "closed" }, { label: t("positions.history.status.partialClosed"), value: "partial_closed" }], value: e2 };
    return b2 ? [m2, P2] : [m2, P2, f2];
  }, [i, e2, l2]), onFilter: d2, side: i, dateRange: l2, status: e2, filterDays: r3, updateFilterDays: c };
};
var mi$2 = (t) => {
  let { side: e2, symbol: o2 } = t.item, { t: i } = ne$6(), s2 = e2 === "LONG";
  return jsx(Q$1.formatted, { intensity: 80, rule: "symbol", formatString: "base-type", size: "sm", prefix: jsx(Wd, { color: s2 ? "success" : "danger", size: "xs", children: i(s2 ? "common.buy" : "common.sell") }), onClick: () => {
    var _a3;
    (_a3 = t.onSymbolChange) == null ? void 0 : _a3.call(t, { symbol: o2 });
  }, children: o2 });
};
var ui$1 = (t) => {
  let { item: e2 } = t, { t: o2 } = ne$6(), i = () => {
    vo$4.alert({ title: o2("positions.liquidation"), message: jsxs(z$3, { direction: "column", width: "100%", gap: 2, className: "oui-text-2xs oui-text-base-contrast-54", children: [e2.liquidation_id != null && jsxs(z$3, { justify: "between", width: "100%", children: [jsx(Q$1, { children: o2("positions.history.liquidated.liquidationId") }), jsx(Q$1, { intensity: 98, children: e2.liquidation_id })] }), jsxs(z$3, { justify: "between", width: "100%", children: [jsx(Q$1, { children: o2("positions.history.liquidated.liquidatorFee") }), jsxs(Q$1, { color: "lose", children: [e2.liquidator_fee > 0 && "-", E$4(e2.liquidator_fee)] })] }), jsxs(z$3, { justify: "between", width: "100%", children: [jsx(Q$1, { children: o2("positions.history.liquidated.insFundFee") }), jsxs(Q$1, { color: "lose", children: [e2.insurance_fund_fee > 0 && "-", E$4(e2.insurance_fund_fee)] })] })] }) });
  }, s2 = useMemo(() => {
    let n4 = [], r3 = e2.position_status, a2 = () => r3 === "closed" ? o2("positions.history.status.closed") : r3 === "partial_closed" ? o2("positions.history.status.partialClosed") : yg(r3.replace("_", " "));
    return n4.push(jsx(Wd, { color: r3 !== "closed" ? "primaryLight" : "neutral", size: "xs", children: a2() })), e2.type === "adl" ? n4.push(jsx(Wd, { color: "danger", size: "xs", children: o2("positions.history.type.adl") })) : e2.type === "liquidated" && n4.push(jsx(Wd, { size: "xs", color: "danger", className: "oui-cursor-pointer", onClick: i, children: jsx("span", { className: "oui-underline oui-decoration-dashed oui-decoration-[1px]", children: o2("positions.history.type.liquidated") }) })), n4;
  }, [e2]);
  return jsx(z$3, { gap: 1, children: s2 });
}, ci$1 = (t) => {
  let { item: e2 } = t, { t: o2 } = ne$6(), i = e2.closed_position_qty != null ? Math.abs(e2.closed_position_qty) : "--";
  return jsx(za$1, { label: jsx(Q$1, { children: o2("positions.history.column.closed") }), classNames: { root: "oui-text-xs", label: "oui-text-2xs" }, children: jsx(Q$1.numeral, { dp: t.base_dp, padding: false, coloring: true, intensity: 80, children: i }) });
}, di$1 = (t) => {
  let { item: e2 } = t, { t: o2 } = ne$6(), i = e2.max_position_qty != null ? Math.abs(e2.max_position_qty) : "--";
  return jsx(za$1, { label: jsx(Q$1, { children: o2("positions.history.column.maxClosed") }), classNames: { root: "oui-text-xs", label: "oui-text-2xs" }, children: jsx(Q$1.numeral, { dp: t.base_dp, padding: false, coloring: true, intensity: 80, children: i }) });
}, pi = (t) => {
  let { item: e2 } = t, o2 = e2.avg_open_price != null ? Math.abs(e2.avg_open_price) : "--", { t: i } = ne$6();
  return jsx(za$1, { label: jsxs(z$3, { gap: 1, children: [i("common.avgOpen"), jsx(Q$1, { intensity: 20, children: "(USDC)" })] }), classNames: { root: "oui-text-xs", label: "oui-text-2xs" }, children: jsx(Q$1.numeral, { dp: t.quote_dp, padding: false, coloring: true, intensity: 80, children: o2 }) });
}, fi$2 = (t) => {
  let { item: e2 } = t, o2 = e2.avg_close_price != null ? Math.abs(e2.avg_close_price) : "--", { t: i } = ne$6();
  return jsx(za$1, { label: jsxs(z$3, { gap: 1, children: [i("common.avgClose"), jsx(Q$1, { intensity: 20, children: "(USDC)" })] }), classNames: { root: "oui-text-xs", label: "oui-text-2xs" }, children: jsx(Q$1.numeral, { dp: t.quote_dp, padding: false, coloring: true, intensity: 80, children: o2 }) });
}, yi$3 = (t) => {
  let { item: e2 } = t, { t: o2 } = ne$6();
  return jsx(za$1, { label: jsx(Q$1, { children: o2("positions.history.column.timeOpened") }), classNames: { root: "oui-text-xs", label: "oui-text-2xs" }, align: "end", children: jsx(Q$1.formatted, { intensity: 80, formatString: "yyyy-MM-dd HH:mm:ss", rule: "date", children: e2.open_timestamp }) });
}, gi$2 = (t) => {
  let { item: e2 } = t, { t: o2 } = ne$6(), i = e2.position_status == "closed" && e2.close_timestamp ? jsx(Q$1.formatted, { intensity: 80, formatString: "yyyy-MM-dd HH:mm:ss", rule: "date", children: e2.close_timestamp }) : "--";
  return jsx(za$1, { label: jsx(Q$1, { children: o2("positions.history.column.timeClosed") }), classNames: { root: "oui-text-xs", label: "oui-text-2xs" }, align: "end", children: i });
};
var Be$4 = (t) => {
  var _a3;
  return jsxs(z$3, { direction: "column", width: "100%", gap: 2, itemAlign: "start", className: (_a3 = t.classNames) == null ? void 0 : _a3.root, children: [jsx(Ps, { ...t }), jsx(de$5, { intensity: 6, className: "oui-w-full" }), jsx(Cs, { ...t })] });
}, Ps = (t) => {
  let { t: e2 } = ne$6(), o2 = () => {
    let { item: i } = t;
    vo$4.alert({ title: e2("positions.history.column.netPnl"), message: jsxs(z$3, { direction: "column", width: "100%", gap: 2, className: "oui-text-2xs oui-text-base-contrast-54", children: [jsxs(z$3, { justify: "between", width: "100%", gap: 2, children: [jsx(Q$1, { intensity: 54, children: e2("common.realizedPnl") }), jsx(Q$1, { color: i.realized_pnl >= 0 ? "profit" : "lose", children: E$4(i.realized_pnl) })] }), jsxs(z$3, { justify: "between", width: "100%", gap: 2, children: [jsx(Q$1, { intensity: 54, children: e2("positions.history.netPnl.fundingFee") }), jsx(Q$1, { color: i.accumulated_funding_fee > 0 ? "lose" : "profit", children: E$4(-i.accumulated_funding_fee) })] }), jsxs(z$3, { justify: "between", width: "100%", gap: 2, children: [jsx(Q$1, { intensity: 54, children: e2("positions.history.netPnl.tradingFee") }), jsx(Q$1, { color: i.trading_fee > 0 ? "lose" : "profit", children: E$4(-i.trading_fee) })] })] }) });
  };
  return jsxs(z$3, { gap: 1, width: "100%", children: [jsxs(z$3, { direction: "column", itemAlign: "start", className: "oui-flex-1", gap: 1, children: [jsx(mi$2, { ...t }), jsx(ui$1, { ...t })] }), jsxs(z$3, { direction: "column", itemAlign: "end", className: "oui-flex-1", children: [jsx(Q$1, { size: "2xs", intensity: 36, children: e2("positions.history.column.netPnl") }), jsxs(z$3, { gapX: 1, children: [jsx("button", { onClick: o2, children: jsx(Q$1.numeral, { size: "xs", coloring: true, children: t.item.netPnL ?? "--" }) }), jsx(Z$3, { position: t.item, sharePnLConfig: t.sharePnLConfig, modalId: eo$3, iconSize: 12, isPositionHistory: true })] })] })] });
}, Cs = (t) => jsxs(Sa$1, { cols: 3, rows: 2, width: "100%", gap: 0, className: "oui-grid-cols-[1fr,1fr,135px]", children: [jsx(ci$1, { ...t }), jsx(di$1, { ...t }), jsx(yi$3, { ...t }), jsx(pi, { ...t }), jsx(fi$2, { ...t }), jsx(gi$2, { ...t })] });
var Me$3 = (t) => {
  let e2 = I();
  return { ...t, ...e2 };
};
var ke$2 = (t) => {
  let e2 = Me$3(t);
  return jsx(Be$4, { ...e2 });
};
var Re$3 = (t) => {
  let { onSymbolChange: e2, pagination: o2, pnlNotionalDecimalPrecision: i } = t, s2 = si$1({ onSymbolChange: e2, pnlNotionalDecimalPrecision: i, sharePnLConfig: t.sharePnLConfig }), { t: n4 } = ne$6(), r3 = useMemo(() => ({ 1: n4("common.select.1d"), 7: n4("common.select.7d"), 30: n4("common.select.30d"), 90: n4("common.select.90d") }), [n4]);
  return jsxs(z$3, { direction: "column", width: "100%", height: "100%", itemAlign: "start", children: [jsxs(z$3, { gap: 3, children: [t.filterItems.length > 0 && jsx(n0, { items: t.filterItems, onFilter: (a2) => {
    t.onFilter(a2);
  } }), [1, 7, 30, 90].map((a2) => jsxs("button", { className: "oui-relative oui-px-2 oui-py-[2px] oui-text-sm", children: [jsx("div", { className: "oui-z-10", children: jsx(Q$1.gradient, { color: t.filterDays === a2 ? "brand" : void 0, className: cnBase("oui-break-normal oui-whitespace-nowrap", t.filterDays !== a2 ? "oui-text-base-contrast-54" : ""), children: r3[a2] || `${a2}D` }) }), jsx("div", { className: "oui-gradient-primary oui-opacity-[.12] oui-absolute oui-left-0 oui-right-0 oui-top-0 oui-bottom-0 oui-rounded", onClick: () => {
    t.updateFilterDays(a2);
  } })] }))] }), jsx(dt$3, { loading: t.isLoading, id: "oui-desktop-positions-content", columns: s2, bordered: true, dataSource: t.dataSource, generatedRowKey: (a2) => `${a2.symbol}_${a2.position_id}`, renderRowContainer: (a2, l2, u2) => jsx(Pt$1, { symbol: a2.symbol, children: u2 }), manualPagination: false, pagination: o2, testIds: { body: "oui-testid-dataList-positionHistory-tab-body" }, classNames: { root: "!oui-h-[calc(100%_-_49px)]" } })] });
}, ze$2 = (t) => {
  var _a3, _b2;
  return jsxs(Sa$1, { cols: 1, rows: 2, className: "oui-grid-rows-[auto,1fr] oui-w-full", gap: 1, children: [jsx(z$3, { gap: 2, p: 2, className: "oui-bg-base-9 oui-rounded-b-xl", children: jsx(n0, { className: "oui-pt-0 oui-pb-0 oui-border-none", items: t.filterItems, onFilter: (e2) => {
    t.onFilter(e2);
  } }) }), jsx(og$1, { className: cnBase("oui-w-full oui-hide-scrollbar oui-overflow-y-hidden oui-space-y-0", (_a3 = t.classNames) == null ? void 0 : _a3.root), contentClassName: cnBase("!oui-space-y-1", (_b2 = t.classNames) == null ? void 0 : _b2.content), dataSource: t.dataSource, renderItem: (e2, o2) => {
    var _a4;
    return jsx(Pt$1, { symbol: e2.symbol, children: jsx(ke$2, { item: e2, index: o2, onSymbolChange: t.onSymbolChange, classNames: { root: (_a4 = t.classNames) == null ? void 0 : _a4.cell }, sharePnLConfig: t.sharePnLConfig }) });
  } })] });
};
var Ls = (t) => {
  let e2 = Gt$3(t);
  return jsx(Re$3, { ...e2, sharePnLConfig: t.sharePnLConfig });
}, qs$1 = (t) => {
  let { classNames: e2, ...o2 } = t, i = Gt$3(o2);
  return jsx(ze$2, { ...i, classNames: e2, sharePnLConfig: t.sharePnLConfig });
};
var Ci$2 = (t) => {
  let { t: e2 } = ne$6();
  return useMemo(() => [{ title: e2("common.time"), dataIndex: "timestamp", fixed: "left", width: 202, render: (i) => jsx(Q$1.formatted, { rule: "date", formatString: "yyyy-MM-dd HH:mm:ss", children: i }) }, { title: e2("positions.Liquidation.column.liquidationId"), dataIndex: "liquidation_id", width: 202, render: (i) => jsx(Q$1, { children: i }) }, { title: e2("positions.Liquidation.column.insFundTransfer"), dataIndex: "transfer_amount_to_insurance_fund", width: 202, render: (i) => jsx(Q$1, { children: E$4(i) }) }, { title: e2("common.symbol"), dataIndex: "Symbol", width: 202, render: (i, s2) => {
    var _a3;
    return jsx(z$3, { direction: "column", itemAlign: "start", children: (_a3 = s2.positions_by_perp) == null ? void 0 : _a3.map((n4) => jsx(Q$1.formatted, { rule: "symbol", formatString: "base-quote", children: n4.symbol })) });
  } }, { title: `${e2("common.price")} (USDC)`, dataIndex: "Price_(USDC)", width: 202, render: (i, s2) => {
    var _a3;
    return jsx(z$3, { direction: "column", itemAlign: "start", children: (_a3 = s2.positions_by_perp) == null ? void 0 : _a3.map((n4) => jsx(Ee, { value: n4.transfer_price, type: "quote" })) });
  } }, { title: e2("common.quantity"), dataIndex: "Quantity", width: 202, render: (i, s2) => {
    var _a3;
    return jsx(z$3, { direction: "column", itemAlign: "start", children: (_a3 = s2.positions_by_perp) == null ? void 0 : _a3.map((n4) => jsx(Ee, { value: n4.position_qty, type: "base" })) });
  } }, { title: e2("positions.Liquidation.column.liquidationFee"), dataIndex: "abs_liquidation_fee", width: 202, render: (i, s2) => {
    var _a3;
    return jsx(z$3, { direction: "column", itemAlign: "start", children: (_a3 = s2.positions_by_perp) == null ? void 0 : _a3.map((n4) => jsx(Ee, { value: n4.abs_liquidation_fee, type: "quote" })) });
  } }], [e2]);
}, Ee = (t) => jsx(Q$1, { children: E$4(t.value) });
var Si$2 = (t) => {
  let { t: e2 } = ne$6();
  return jsxs(z$3, { width: "100%", justify: "between", children: [jsxs(z$3, { gap: 1, children: [jsx(Q$1, { size: "2xs", intensity: 36, children: e2("common.price") }), jsx(Q$1, { size: "2xs", intensity: 20, children: "(USDC)" })] }), jsx(Q$1, { size: "2xs", intensity: 80, children: E$4(t.transfer_price) })] });
}, hi$1 = (t) => {
  let { t: e2 } = ne$6();
  return jsxs(z$3, { width: "100%", justify: "between", children: [jsx(Q$1, { size: "2xs", intensity: 36, children: e2("common.quantity") }), jsx(Q$1, { size: "2xs", intensity: 80, children: E$4(t.position_qty) })] });
}, _i$2 = (t) => {
  let { t: e2 } = ne$6();
  return jsxs(z$3, { width: "100%", justify: "between", children: [jsx(Q$1, { size: "2xs", intensity: 36, children: e2("positions.Liquidation.column.liquidationFee") }), jsx(Q$1, { size: "2xs", intensity: 80, children: E$4(t.abs_liquidation_fee) })] });
};
var Qe$4 = (t) => {
  var _a3;
  return jsxs(z$3, { direction: "column", width: "100%", gap: 2, itemAlign: "start", className: (_a3 = t.classNames) == null ? void 0 : _a3.root, children: [jsx(ks, { ...t }), jsx(As, { ...t })] }, t.item.timestamp);
}, ks = (t) => {
  let { t: e2 } = ne$6();
  return jsxs(z$3, { gap: 1, width: "100%", children: [jsxs(z$3, { direction: "column", itemAlign: "start", className: "oui-flex-1", gap: 1, children: [jsx(Q$1.formatted, { size: "2xs", intensity: 36, rule: "date", formatString: "yyyy-MM-dd HH:mm:ss", children: t.item.timestamp }), jsxs(z$3, { gap: 1, children: [jsx(Q$1, { size: "2xs", intensity: 36, children: `${e2("positions.Liquidation.column.liquidationId")}:` }), jsx(Q$1, { size: "2xs", intensity: 80, children: ` ${t.item.liquidation_id}` })] })] }), jsxs(z$3, { direction: "column", itemAlign: "end", className: "oui-flex-1", children: [jsx(Q$1, { size: "2xs", intensity: 36, children: `${e2("positions.Liquidation.column.insFundTransfer")}:` }), jsx(Q$1, { intensity: 80, size: "xs", children: E$4(t.item.transfer_amount_to_insurance_fund) })] })] });
}, As = (t) => {
  var _a3;
  return jsx(z$3, { direction: "column", width: "100%", children: (_a3 = t.item.positions_by_perp) == null ? void 0 : _a3.map((e2, o2) => jsx(Hs, { isLast: o2 === t.item.positions_by_perp.length - 1, ...e2 }, `${o2}-${e2.symbol}`)) });
}, Hs = (t) => jsxs(z$3, { width: "100%", itemAlign: "start", className: cnBase("oui-border-t-[1px] oui-border-line-6 oui-pt-2", !t.isLast && "oui-pb-2"), children: [jsx(Q$1.formatted, { rule: "symbol", formatString: "base-quote", size: "xs", intensity: 80, className: "oui-flex-1", children: t.symbol }), jsxs(Sa$1, { cols: 1, rows: 3, width: "100%", gap: 1, className: "oui-flex-1", children: [jsx(Si$2, { ...t }), jsx(hi$1, { ...t }), jsx(_i$2, { ...t })] })] }, t.key);
var $e$4 = (t) => ({ ...t });
var Ve$2 = (t) => {
  let { classNames: e2, ...o2 } = t, i = $e$4(o2);
  return jsx(Qe$4, { classNames: e2, ...i });
};
var Ke$4 = (t) => {
  let e2 = Ci$2();
  return jsxs(z$3, { direction: "column", width: "100%", height: "100%", itemAlign: "start", children: [jsxs(z$3, { gap: 3, children: [t.filterItems.length > 0 && jsx(n0, { items: t.filterItems, onFilter: (o2) => {
    t.onFilter(o2);
  } }), [1, 7, 30, 90].map((o2) => jsxs("button", { className: "oui-relative oui-px-2 oui-py-[2px] oui-text-sm", children: [jsx("div", { className: "oui-z-10", children: jsx(Q$1.gradient, { color: t.filterDays === o2 ? "brand" : void 0, className: t.filterDays !== o2 ? "oui-text-base-contrast-54" : "", children: `${o2}D` }) }), jsx("div", { className: "oui-gradient-primary oui-opacity-[.12] oui-absolute oui-left-0 oui-right-0 oui-top-0 oui-bottom-0 oui-rounded", onClick: () => {
    t.updateFilterDays(o2);
  } })] }))] }), jsx(dt$3, { loading: t.isLoading, id: "oui-desktop-liquidation-content", columns: e2, bordered: true, dataSource: t.dataSource, generatedRowKey: (o2) => `${o2.liquidation_id}`, pagination: t.pagination, testIds: { body: "oui-testid-dataList-liquidation-tab-body" }, classNames: { root: "!oui-h-[calc(100%_-_49px)]" } })] });
}, Xe$1 = (t) => {
  var _a3, _b2;
  return jsxs(Sa$1, { cols: 1, rows: 2, className: "oui-grid-rows-[auto,1fr] oui-w-full", gap: 1, children: [jsx(z$3, { gap: 2, p: 2, className: "oui-bg-base-9 oui-rounded-b-xl", children: jsx(n0, { className: "oui-pt-0 oui-pb-0 oui-border-none", items: t.filterItems, onFilter: (e2) => {
    t.onFilter(e2);
  } }) }), jsx(og$1, { className: cnBase("oui-w-full oui-hide-scrollbar oui-overflow-y-hidden oui-space-y-0", (_a3 = t.classNames) == null ? void 0 : _a3.root), contentClassName: cnBase("!oui-space-y-1", (_b2 = t.classNames) == null ? void 0 : _b2.content), dataSource: t.dataSource, loadMore: t.loadMore, renderItem: (e2, o2) => {
    var _a4;
    return jsx(Ve$2, { item: e2, index: o2, classNames: { root: (_a4 = t.classNames) == null ? void 0 : _a4.cell } });
  } })] });
};
var te$1 = (t) => {
  let { symbol: e2, enableLoadMore: o2 } = t, { page: i, pageSize: s2, setPage: n4, parsePagination: a2 } = p0({ pageSize: 10 }), { dateRange: l2, filterDays: u2, updateFilterDays: c, filterItems: d2, onFilter: b2 } = Js();
  useEffect(() => {
    n4(1);
  }, [e2, l2, u2]);
  let [S2, { meta: m2, isLoading: f2, loadMore: P2 }] = Ys({ page: o2 ? void 0 : i, size: s2, symbol: e2, start_t: l2.from != null ? l2.from.getTime() : void 0, end_t: l2.to != null ? l2.to.getTime() : void 0 });
  return { dataSource: Tr$2(S2, { fallbackData: [] }), isLoading: f2, loadMore: P2, pagination: a2(m2), dateRange: l2, filterDays: u2, updateFilterDays: c, filterItems: d2, onFilter: b2 };
}, Ys = (t) => {
  var _a3;
  let e2 = usePrivateInfiniteQuery(Zs(t), { initialSize: 1, formatter: (r3) => r3, revalidateOnFocus: true }), o2 = useMemo(() => {
    var _a4, _b2;
    return (_b2 = (_a4 = e2.data) == null ? void 0 : _a4[0]) == null ? void 0 : _b2.meta;
  }, [(_a3 = e2.data) == null ? void 0 : _a3[0]]), i = useMemo(() => {
    var _a4, _b2;
    return (_b2 = (_a4 = e2.data) == null ? void 0 : _a4.map((r3) => r3.rows)) == null ? void 0 : _b2.flat();
  }, [e2.data]), s2 = e2.isLoading;
  return [i, { meta: o2, isLoading: s2, loadMore: () => {
    e2.setSize(e2.size + 1);
  } }];
}, Js = () => {
  let t = St$1({ to: M(/* @__PURE__ */ new Date()), from: B$1(subDays(/* @__PURE__ */ new Date(), 89)) }), [e2, o2] = useState(90), [i, s2] = useState(t), n4 = (u2) => {
    o2(u2), s2({ from: B$1(subDays(/* @__PURE__ */ new Date(), u2 - 1)), to: M(/* @__PURE__ */ new Date()) });
  }, r3 = (u2) => {
    if (u2.name === "dateRange") {
      let c = St$1(u2.value);
      if (s2(c), c.from && c.to) {
        let d2 = Math.abs(differenceInDays(c.from, c.to)) + 1, S2 = { 1: { from: B$1(/* @__PURE__ */ new Date()), to: M(/* @__PURE__ */ new Date()) }, 7: { from: B$1(subDays(/* @__PURE__ */ new Date(), 6)), to: M(/* @__PURE__ */ new Date()) }, 30: { from: B$1(subDays(/* @__PURE__ */ new Date(), 29)), to: M(/* @__PURE__ */ new Date()) }, 90: { from: B$1(subDays(/* @__PURE__ */ new Date(), 89)), to: M(/* @__PURE__ */ new Date()) } }[d2];
        S2 && ht$2(S2.from, c.from) && ht$2(S2.to, c.to) ? o2(d2) : o2(null);
      }
    }
  }, { isMobile: a2 } = it$6();
  return { filterItems: useMemo(() => {
    let u2 = { type: "range", name: "dateRange", value: i, fromDate: B$1(subDays(/* @__PURE__ */ new Date(), 89)), toDate: M(/* @__PURE__ */ new Date()) };
    return a2 ? [u2] : [u2];
  }, [i]), onFilter: r3, dateRange: i, filterDays: e2, updateFilterDays: n4 };
}, Zs = (t) => (e2, o2) => {
  var _a3;
  if (o2 && !((_a3 = o2.rows) == null ? void 0 : _a3.length)) return null;
  let { symbol: i, size: s2 = 10, page: n4, end_t: r3, start_t: a2 } = t, l2 = new URLSearchParams([["size", s2.toString()], ["page", `${e2 + 1}`]]);
  return n4 && l2.set("page", `${n4}`), i && l2.set("symbol", i), r3 && l2.set("end_t", `${r3}`), a2 && l2.set("start_t", `${a2}`), `/v1/liquidations?${l2.toString()}`;
};
var js$1 = (t) => {
  let e2 = te$1(t);
  return jsx(Ke$4, { ...e2 });
}, ta$1 = (t) => {
  let { classNames: e2, ...o2 } = t, i = te$1(o2);
  return jsx(Xe$1, { classNames: e2, ...i });
};
var oa = "MarketCloseConfirmID";
Wm(oa, qt$3, { size: "md", closable: false });
var wt$1 = (e2) => {
  let { current: t, pnlNotionalDecimalPrecision: r3, sharePnLConfig: o2 } = e2, n4 = useRef(null);
  return useImperativeHandle(e2.ref, () => ({ download: () => {
    var _a3, _b2;
    (_b2 = (_a3 = n4.current) == null ? void 0 : _a3.download) == null ? void 0 : _b2.call(_a3);
  } })), { current: t, pnlNotionalDecimalPrecision: r3, orderListRef: n4, sharePnLConfig: o2 };
};
var Le$1 = (e2) => e2 === void 0 || e2.length === 0 ? e2 : e2.length === 1 ? e2.charAt(0).toUpperCase() : e2.charAt(0).toUpperCase() + e2.toLowerCase().slice(1);
function ue$2(e2) {
  var _a3, _b2;
  let t = e2.type, r3 = e2.algo_type;
  if (typeof t < "u") {
    let o$1 = [];
    if (e2.parent_algo_type) {
      if (r3 === AlgoOrderType.STOP_LOSS) {
        let i = t === OrderType.CLOSE_POSITION ? [o.t("common.position"), o.t("tpsl.sl")] : [o.t("tpsl.sl")];
        o$1.push(...i);
      }
      if (r3 === AlgoOrderType.TAKE_PROFIT) {
        let i = t === OrderType.CLOSE_POSITION ? [o.t("common.position"), o.t("tpsl.tp")] : [o.t("tpsl.tp")];
        o$1.push(...i);
      }
      return o$1;
    }
    let n4 = typeof t == "string" ? t.replace("_ORDER", "") : "";
    if ([OrderType.ASK, OrderType.BID].includes(t)) return [o.t("orderEntry.orderType.limit")];
    if (e2.algo_order_id === void 0 || e2.algo_order_id && r3 === "BRACKET") return [{ [OrderType.LIMIT]: o.t("orderEntry.orderType.limit"), [OrderType.MARKET]: o.t("orderEntry.orderType.market"), [OrderType.POST_ONLY]: o.t("orderEntry.orderType.postOnly"), [OrderType.IOC]: o.t("orderEntry.orderType.ioc"), [OrderType.FOK]: o.t("orderEntry.orderType.fok") }[n4] || Le$1(n4)];
    if (n4) return [{ [OrderType.LIMIT]: o.t("orderEntry.orderType.stopLimit"), [OrderType.MARKET]: o.t("orderEntry.orderType.stopMarket") }[n4] || n4];
  }
  if (typeof r3 < "u") {
    let o$1 = [];
    r3 === AlgoOrderRootType.POSITIONAL_TP_SL && o$1.push(o.t("common.position"));
    let n4 = (_a3 = e2 == null ? void 0 : e2.child_orders) == null ? void 0 : _a3.find((a2) => a2.algo_type === AlgoOrderType.TAKE_PROFIT && !!a2.trigger_price), i = (_b2 = e2 == null ? void 0 : e2.child_orders) == null ? void 0 : _b2.find((a2) => a2.algo_type === AlgoOrderType.STOP_LOSS && !!a2.trigger_price);
    return (n4 || i) && o$1.push(n4 && i ? o.t("common.tpsl") : n4 ? o.t("tpsl.tp") : o.t("tpsl.sl")), o$1;
  }
}
function ne$2(e2) {
  return e2.status === OrderStatus.CANCELLED || e2.algo_status === OrderStatus.CANCELLED;
}
function pn(e2) {
  var _a3, _b2, _c2;
  if (e2.algo_type !== AlgoOrderRootType.BRACKET) return { tpOrder: void 0, slOrder: void 0 };
  let t = (_a3 = e2.child_orders) == null ? void 0 : _a3[0];
  if (!t) return { tpOrder: void 0, slOrder: void 0 };
  let r3 = (_b2 = t == null ? void 0 : t.child_orders) == null ? void 0 : _b2.find((n4) => n4.algo_type === AlgoOrderType.TAKE_PROFIT), o2 = (_c2 = t == null ? void 0 : t.child_orders) == null ? void 0 : _c2.find((n4) => n4.algo_type === AlgoOrderType.STOP_LOSS);
  return { tpOrder: r3, slOrder: o2 };
}
function ct(e2) {
  let t = { pnl: { tpPnL: void 0, slPnL: void 0 }, roi: { tpRoi: void 0, slRoi: void 0 } }, { tpOrder: r3, slOrder: o2 } = pn(e2);
  if (!r3 && !o2 || typeof e2.price === void 0 || !e2.price) return t;
  let n4 = e2.side === OrderSide.BUY ? e2.quantity : e2.quantity * -1, i = (r3 == null ? void 0 : r3.trigger_price) && utils_exports.priceToPnl({ qty: n4, price: r3 == null ? void 0 : r3.trigger_price, entryPrice: e2.price, orderSide: e2.side, orderType: r3.algo_type }), a2 = (o2 == null ? void 0 : o2.trigger_price) && utils_exports.priceToPnl({ qty: n4, price: o2 == null ? void 0 : o2.trigger_price, entryPrice: e2.price, orderSide: e2.side, orderType: o2.algo_type }), s2 = i ? utils_exports.calcTPSL_ROI({ pnl: i, qty: e2.quantity, price: e2.price }) : void 0, d2 = a2 ? utils_exports.calcTPSL_ROI({ pnl: a2, qty: e2.quantity, price: e2.price }) : void 0;
  return { pnl: { tpPnL: i, slPnL: a2 }, roi: { tpRoi: s2, slRoi: d2 } };
}
function It$1(e2, t) {
  return !e2 || !t ? false : e2.getFullYear() === t.getFullYear() && e2.getMonth() === t.getMonth() && e2.getDate() === t.getDate();
}
var qe$3 = (e2) => {
  let { type: t, base: r3, value: o2, cancelPopover: n4, isSubmitting: i, onConfirm: a2 } = e2, { t: s2 } = ne$6();
  return jsxs("div", { className: "oui-pt-5 oui-relative", children: [jsx("div", { className: "oui-text-base-contrast-54 oui-text-2xs desktop:oui-text-sm", children: (() => {
    let u2 = { values: { base: r3, value: d$2(o2) }, components: [jsx("span", { className: "oui-text-warning-darken" })] };
    switch (t) {
      case 0:
        return jsx(Trans, { i18nKey: "order.edit.confirm.quantity", ...u2 });
      case 1:
        return jsx(Trans, { i18nKey: "order.edit.confirm.price", ...u2 });
      case 2:
        return jsx(Trans, { i18nKey: "order.edit.confirm.triggerPrice", ...u2 });
    }
  })() }), jsxs("div", { className: "oui-grid oui-grid-cols-2 oui-gap-2 oui-mt-5", children: [jsx($e$6, { color: "secondary", size: "md", onClick: n4, disabled: i, children: s2("common.cancel") }), jsx(Sr$2, { size: "md", loading: i, onClick: a2, children: s2("common.confirm") })] }), jsx("button", { className: "oui-absolute oui-right-0 oui-top-0 oui-text-base-contrast-54", onClick: n4, children: jsx(De$4, { size: 16, color: "white", opacity: 1 }) })] });
};
var Re$2 = (e2) => {
  let { inputRef: t, dp: r3, value: o2, setValue: n4, setEditing: i, error: a2, handleKeyDown: s2, onClick: d2, onClose: u2, onFocus: l2, onBlur: f2, hintInfo: x2 } = e2;
  useEffect(() => {
    let h2 = t.current;
    if (h2) {
      let p2 = h2.value.length;
      h2.setSelectionRange(p2, p2);
    }
    i(true);
  }, []);
  let C2 = ((x2 == null ? void 0 : x2.length) || 0) > 0;
  return jsx(xs, { content: x2, open: C2, children: jsx(Fo$3, { ref: t, type: "text", size: "sm", formatters: [li$3.numberFormatter, li$3.dpFormatter(r3), li$3.currencyFormatter], value: o2, onValueChange: (h2) => n4(h2), helpText: a2, onClick: (h2) => {
    h2.stopPropagation(), h2.preventDefault();
  }, autoComplete: "off", onFocus: l2, onBlur: f2, onKeyDown: s2, autoFocus: true, color: C2 ? "danger" : void 0, classNames: { root: "oui-bg-base-700 oui-px-2 oui-py-1 oui-rounded", input: "oui-pr-2" }, suffix: jsx("button", { onClick: d2, children: jsx(Fa$1, { size: 18, color: "white", opacity: 1, className: "oui-cursor-pointer oui-opacity-50 hover:oui-opacity-100" }) }) }) });
};
var vr$2 = createContext({}), Z$2 = () => useContext(vr$2), Dt$4 = (e2) => {
  let { cancelOrder: t, editOrder: r3, cancelAlgoOrder: o2, editAlgoOrder: n4 } = e2, { t: i } = ne$6(), a2 = useSymbolsInfo(), s2 = useCallback(async (l2) => l2.algo_order_id !== void 0 ? "root_algo_order_id" in l2 && l2.root_algo_order_id !== l2.algo_order_id ? o2(l2.root_algo_order_id, l2.symbol) : o2(l2.algo_order_id, l2.symbol).then(() => {
  }) : t(l2.order_id, l2.symbol).then(() => {
  }), []), d2 = useCallback(async (l2, f2) => {
    l2.visible_quantity !== void 0 ? l2.visible_quantity === 0 : l2.visible !== void 0 ? l2.visible === 0 : false;
    await vo$4.sheet({ title: i("orders.editOrder"), classNames: { content: "oui-edit-order-sheet-content" }, content: jsx(Fragment$1, { children: "Content" }) });
  }, [i]), u2 = useCallback((l2, f2, x2) => {
    let { min_notional: C2 } = a2[l2](), h2 = getMinNotional({ price: f2, qty: x2, min_notional: C2 });
    if (h2 !== void 0) return i("orderEntry.total.error.min", { value: h2 });
  }, [a2, i]);
  return jsx(vr$2.Provider, { value: { onCancelOrder: s2, onEditOrder: d2, editOrder: r3, editAlgoOrder: n4, checkMinNotional: u2 }, children: e2.children });
};
var Ar$2 = createContext({}), z$1 = () => useContext(Ar$2), Ft$3 = (e2) => {
  let t = useSymbolsInfo()[e2.symbol];
  return jsx(Ar$2.Provider, { value: { base_dp: t("base_dp"), quote_dp: t("quote_dp"), base_tick: t("base_tick"), quote_tick: t("quote_tick"), base: t("base"), quote: t("quote"), symbol: e2.symbol, origin: t(), quote_max: t("quote_max"), quote_min: t("quote_min") }, children: e2.children });
};
var kr$1 = createContext({}), G$1 = () => useContext(kr$1), qt$2 = (e2) => {
  let { quote_dp: t } = z$1(), [r3, o2] = useState(), [n4] = useMutation("/v1/algo/order", "DELETE"), [i] = useMutation("/v1/algo/order", "PUT"), a2 = useSWRConfig(), { state: s2 } = useAccount(), d2 = useMemo(() => unstable_serialize$1(() => ["/v1/positions", s2.accountId]), [s2.accountId]), u2 = async (P2) => n4(null, { order_id: P2.algo_order_id, symbol: P2.symbol }), l2 = async (P2, N2) => i({ order_id: P2.algo_order_id, child_orders: P2.child_orders.map((T2) => ({ order_id: T2.algo_order_id, quantity: N2.order_quantity })) }), f2 = (P2) => {
    var _a3;
    return (_a3 = a2.cache.get(d2)) == null ? void 0 : _a3.data.rows.find((T2) => T2.symbol === P2);
  }, { sl_trigger_price: x2, tp_trigger_price: C2, tpPnL: h2, slPnL: p2 } = $n({ order: e2.order, position: r3, quote_dp: t });
  return useEffect(() => {
    var _a3;
    if ("algo_type" in e2.order || (((_a3 = e2.order) == null ? void 0 : _a3.reduce_only) ?? false)) {
      let P2 = f2(e2.order.symbol);
      P2 && o2(P2);
    }
  }, [e2.order.symbol]), jsx(kr$1.Provider, { value: { order: e2.order, sl_trigger_price: x2, tp_trigger_price: C2, tpPnL: h2, slPnL: p2, onCancelOrder: u2, onUpdateOrder: l2, getRelatedPosition: f2, position: r3 }, children: e2.children });
};
function $n(e2) {
  var _a3;
  let { order: t, position: r3, quote_dp: o2 } = e2;
  if (!r3) return { sl_trigger_price: void 0, tp_trigger_price: void 0, slPnL: void 0, tpPnL: void 0 };
  let { sl_trigger_price: n4, tp_trigger_price: i } = !("algo_type" in t) || !Array.isArray(t.child_orders) ? {} : utils_exports.findTPSLFromOrder(t), a2 = t.quantity;
  a2 === 0 && ((_a3 = t.child_orders) == null ? void 0 : _a3[0].type) === "CLOSE_POSITION" && (a2 = r3.position_qty);
  let s2 = r3.average_open_price, d2 = typeof a2 == "number" && typeof i == "number" && typeof s2 == "number" ? utils_exports.priceToPnl({ qty: a2, price: i, entryPrice: r3.average_open_price, orderSide: t.side, orderType: AlgoOrderType.TAKE_PROFIT }, { symbol: { quote_dp: o2 } }) : void 0, u2 = typeof a2 == "number" && typeof n4 == "number" && typeof s2 == "number" ? utils_exports.priceToPnl({ qty: a2, price: n4, entryPrice: r3.average_open_price, orderSide: t.side, orderType: AlgoOrderType.STOP_LOSS }, { symbol: { quote_dp: o2 } }) : void 0;
  return { sl_trigger_price: n4, tp_trigger_price: i, slPnL: u2, tpPnL: d2 };
}
var Mt$2 = (e2) => {
  let { order: t, otherOrderQuantity: r3 } = e2, { reduce_only: o2 } = t, [n4, i] = useState(t.quantity.toString()), [a2, s2] = useState(false), { t: d2 } = ne$6();
  useEffect(() => {
    E3(t.quantity.toString());
  }, [e2.order.quantity]);
  let [u2, l2] = useState(false), [f2, x2] = useState(), { editOrder: C2, editAlgoOrder: h2, checkMinNotional: p2 } = Z$2(), { onUpdateOrder: P2, position: N2 } = G$1(), { base_dp: T2, base: q2, base_tick: g2 } = z$1(), E3 = async (y2, b2) => {
    i(y2);
    let B2 = Math.abs((N2 == null ? void 0 : N2.position_qty) || 0);
    if (N2 && o2 && Number(y2) > B2) x2(d2("orders.quantity.lessThanPosition", { quantity: B2 }));
    else {
      let Ce3 = Number(y2);
      b2 && Ce3 > b2 ? x2(d2("orders.quantity.lessThan", { quantity: E$4(b2, { fix: T2 }) })) : x2(void 0);
    }
    return Promise.resolve();
  }, W2 = () => {
    l2(false), s2(false);
  }, R2 = () => {
    l2(false), E3(t.quantity.toString()), s2(false);
  }, [O2, L2] = useState(false), F3 = useRef(null), X2 = () => {
    if (f2) return;
    if (Number(n4) === Number(t.quantity)) {
      s2(false);
      return;
    }
    let y2 = t.algo_order_id !== void 0 ? t.trigger_price : t.price;
    if (y2 !== null && t.reduce_only !== true) {
      let b2 = p2(t.symbol, y2, n4);
      if (b2) {
        toast$2.error(b2), L2(false), R2();
        return;
      }
    }
    l2(true);
  }, v3 = (y2) => {
    y2 == null ? void 0 : y2.stopPropagation(), y2 == null ? void 0 : y2.preventDefault(), X2();
  }, Y2 = (y2) => {
    y2.key === "Enter" && (y2 == null ? void 0 : y2.stopPropagation(), y2 == null ? void 0 : y2.preventDefault(), X2());
  }, A2 = useCallback(() => {
    L2(true);
    let y2 = { symbol: t.symbol, order_type: t.type, side: t.side, order_price: t.price, order_quantity: n4, algo_order_id: t.algo_order_id };
    if (typeof y2.algo_order_id < "u" && y2.order_type === "MARKET") {
      let { order_price: B2, ...Ce3 } = y2;
      y2 = Ce3;
    }
    typeof t.reduce_only < "u" && (y2.reduce_only = t.reduce_only), t.order_tag !== void 0 && (y2 = { ...y2, order_tag: t.order_tag }), (t == null ? void 0 : t.visible_quantity) === 0 && (y2.visible_quantity = 0), (t == null ? void 0 : t.tag) !== void 0 && (y2.order_tag = t.tag);
    let b2;
    "algo_type" in t && t.algo_type === AlgoOrderRootType.TP_SL ? b2 = P2(t, y2) : t.algo_order_id !== void 0 ? b2 = h2(t.algo_order_id.toString(), y2) : b2 = C2(t.order_id.toString(), y2), b2.then((B2) => {
      W2(), E3(n4.toString());
    }, (B2) => {
      toast$2.error(B2.message), E3(t.quantity.toString()), R2();
    }).finally(() => L2(false));
  }, [n4]), D2 = useRef(null), re2 = useRef(null), de2 = (y2) => {
    D2.current && re2.current && !D2.current.contains(y2.target) && !re2.current.contains(y2.target) && !u2 && R2();
  };
  useEffect(() => (document.addEventListener("mousedown", de2), () => {
    document.removeEventListener("mousedown", de2);
  }), [u2, t.quantity]);
  let Ge2 = () => !a2 || e2.disableEdit ? jsx(ei$1, { order: t, quantity: n4, setEditing: s2, disableEdit: e2.disableEdit }) : jsx(ti$1, { inputRef: F3, quantitySliderRef: re2, base_dp: T2, base_tick: g2, quantity: n4, setQuantity: E3, editing: a2, setEditing: s2, handleKeyDown: Y2, onClick: v3, onClose: R2, symbol: t.symbol, reduce_only: o2, positionQty: N2 == null ? void 0 : N2.position_qty, error: f2, confirmOpen: u2, side: t.side, order: t, setError: x2 });
  return jsx(Bo$3, { open: u2, onOpenChange: l2, content: jsx(qe$3, { type: 0, base: q2, value: n4, cancelPopover: R2, isSubmitting: O2, onConfirm: A2 }), contentProps: { onOpenAutoFocus: (y2) => {
  } }, children: jsx("div", { onClick: (y2) => {
    y2.stopPropagation(), y2.preventDefault();
  }, ref: D2, children: Ge2() }) });
}, ei$1 = (e2) => {
  let { order: t, quantity: r3 } = e2, o2 = t.total_executed_quantity;
  return jsxs(z$3, { direction: "row", justify: "start", gap: 1, className: cnBase("oui-max-w-[110px] oui-relative", t.side === OrderSide.BUY && "oui-text-trade-profit", t.side === OrderSide.SELL && "oui-text-trade-loss", ne$2(t) && "oui-text-base-contrast-20"), onClick: (n4) => {
    n4.stopPropagation(), n4.preventDefault(), e2.setEditing(true);
  }, children: ["algo_type" in t && t.algo_type === AlgoOrderRootType.TP_SL ? null : jsxs(Fragment$1, { children: [jsx("span", { children: o2 }), jsx("span", { children: "/" })] }), jsx(z$3, { r: "base", className: cnBase("oui-min-w-[70px] oui-h-[28px]", !e2.disableEdit && "oui-bg-base-7 oui-px-2 oui-border oui-border-line-12"), children: jsx(Q$1, { size: "2xs", children: r3 }) })] });
}, ti$1 = (e2) => {
  let { inputRef: t, quantitySliderRef: r3, base_dp: o2, base_tick: n4, quantity: i, setQuantity: a2, editing: s2, setEditing: d2, handleKeyDown: u2, onClick: l2, onClose: f2, error: x2, symbol: C2, reduce_only: h2, positionQty: p2, confirmOpen: P2, side: N2, order: T2 } = e2, q2 = useMaxQty(C2, T2.side, T2.reduce_only), g2 = useMemo(() => h2 ? Math.abs(p2 ?? 0) : T2.quantity + Math.abs(q2), [T2.quantity, q2, h2, p2]), [E3, W2] = useState(void 0);
  useEffect(() => {
    if (E3 === void 0) {
      let O2 = new g$6(i).div(g2).abs().mul(100).toNumber();
      W2(O2);
    }
  }, [E3, g2, i]);
  let R2 = async (O2) => (n4 > 0 && (O2 = utils_exports.formatNumber(O2, n4) ?? O2), a2(`${O2}`, g2));
  return jsxs(It$3, { open: !P2, children: [jsx(as$1, { children: jsx(Re$2, { inputRef: t, dp: o2, value: i, setValue: (O2) => {
    let L2 = Math.abs(Math.min(Number(O2), g2)).toString();
    if (a2(O2, g2), O2.endsWith(".")) return;
    if (Number(L2) === 0) {
      W2(0);
      return;
    }
    let F3 = new g$6(O2).div(g2).mul(100).toDecimalPlaces(2, g$6.ROUND_DOWN).toNumber();
    W2(Math.min(100, F3));
  }, setEditing: d2, handleKeyDown: u2, onClick: l2, onClose: f2, onBlur: (O2) => {
    R2(O2.target.value);
  }, hintInfo: x2 }) }), jsx(Vo$3, { className: "oui-w-[360px] oui-rounded-xl", align: "start", side: "bottom", onOpenAutoFocus: (O2) => {
    O2.preventDefault();
  }, children: jsxs(z$3, { p: 1, gap: 2, width: "100%", itemAlign: "start", ref: r3, children: [jsx(Q$1.numeral, { size: "xs", intensity: 98, className: "oui-min-w-[30px] ", dp: 2, padding: false, unit: "%", rm: g$6.ROUND_DOWN, children: `${E3}` }), jsxs(z$3, { direction: "column", width: "100%", gap: 2, className: "oui-mt-[6px]", children: [jsx(iu, { markCount: 4, value: [E3 ?? 0], onValueChange: (O2) => {
    let L2 = Array.from(O2.values());
    W2(L2[0]);
    let F3 = new g$6(L2[0]).div(100).mul(g2).abs().toFixed(o2, g$6.ROUND_DOWN);
    a2(F3, g2);
  }, onValueCommit: (O2) => {
    let L2 = new g$6(O2[0]).div(100).mul(g2).abs().toFixed(o2, g$6.ROUND_DOWN);
    R2(L2).finally(() => {
      t.current.focus();
    });
  } }), jsx(ri$2, { onClick: (O2) => {
    W2(O2 * 100);
    let L2 = new g$6(O2).mul(g2).abs().toFixed(o2, g$6.ROUND_DOWN);
    L2 = utils_exports.formatNumber(L2, n4) ?? L2, a2(L2, g2), setTimeout(() => {
      t.current.focus(), t.current.setSelectionRange(L2.length, L2.length);
    }, 100);
  } })] })] }) })] });
}, ri$2 = (e2) => {
  let { t } = ne$6(), r3 = [{ label: "0%", value: 0 }, { label: "25%", value: 0.25 }, { label: "50%", value: 0.5 }, { label: "75%", value: 0.75 }, { label: t("common.max"), value: 1 }];
  return jsx(z$3, { gap: 2, width: "100%", children: r3.map((o2, n4) => jsx($e$6, { variant: "outlined", color: "secondary", size: "xs", onClick: (i) => {
    i.stopPropagation(), i.preventDefault(), e2.onClick(o2.value);
  }, className: "oui-w-1/5", children: o2.label }, n4)) });
};
var Yr$1 = (e2) => {
  let { order: t } = e2, { t: r3 } = ne$6(), [o2, n4] = useState(() => {
    var _a3;
    return t.type === OrderType.MARKET && !t.price ? "Market" : ((_a3 = t.price) == null ? void 0 : _a3.toString()) ?? "Market";
  }), [i, a2] = useState(false), [s2, d2] = useState(false), u2 = (t == null ? void 0 : t.algo_order_id) !== void 0, l2 = (t == null ? void 0 : t.type) === "MARKET" && u2, [f2, x2] = useState(false), { editOrder: C2, editAlgoOrder: h2, checkMinNotional: p2 } = Z$2(), { base: P2, quote_dp: N2 } = z$1(), T2 = useSymbolPriceRange(t.symbol, t.side, u2 ? t.trigger_price : void 0), q2 = () => {
    a2(false), d2(false);
  }, g2 = () => {
    var _a3;
    a2(false), n4(((_a3 = t.price) == null ? void 0 : _a3.toString()) ?? "Market"), d2(false);
  }, E3 = useMemo(() => !T2 || l2 || !s2 ? "" : Number(o2) > T2.max ? r3("orders.price.greaterThan", { max: T2.max }) : Number(o2) < T2.min ? r3("orders.price.lessThan", { min: T2.min }) : "", [l2, s2, T2, o2, r3]), W2 = (A2) => {
    if (A2 == null ? void 0 : A2.stopPropagation(), A2 == null ? void 0 : A2.preventDefault(), !(E3.length > 0)) {
      if (o2 === `${t.price}`) {
        d2(false);
        return;
      }
      if (t.reduce_only !== true) {
        let D2 = p2(t.symbol, o2, t.quantity);
        if (D2) {
          toast$2.error(D2), x2(false), g2();
          return;
        }
      }
      a2(true);
    }
  }, R2 = (A2) => {
    A2.key === "Enter" && W2(A2);
  }, O2 = () => {
    x2(true);
    let A2 = t.order_id, D2 = { order_price: o2, order_quantity: t.quantity, symbol: t.symbol, order_type: t.type, side: t.side };
    typeof t.reduce_only < "u" && (D2.reduce_only = t.reduce_only), t.order_tag !== void 0 && (D2 = { ...D2, order_tag: t.order_tag }), u2 && (A2 = t.algo_order_id, D2 = { ...D2, order_id: A2, price: o2, algo_order_id: A2 }), (t == null ? void 0 : t.visible_quantity) === 0 && (D2.visible_quantity = 0), t.tag !== void 0 && (D2.order_tag = t.tag);
    let re2;
    t.algo_order_id !== void 0 ? re2 = h2(t.algo_order_id.toString(), D2) : re2 = C2(t.order_id.toString(), D2), re2.then((de2) => {
      q2(), n4(o2);
    }, (de2) => {
      toast$2.error(de2.message), g2();
    }).finally(() => x2(false));
  }, L2 = useRef(null);
  useEffect(() => {
    e2.order.price && n4(`${e2.order.price}`);
  }, [e2.order.price]);
  let F3 = useRef(null), X2 = (A2) => {
    F3.current && !F3.current.contains(A2.target) && !i && g2();
  };
  if (useEffect(() => (document.addEventListener("mousedown", X2), () => {
    document.removeEventListener("mousedown", X2);
  }), [i, t.price]), t.algo_order_id && t.type == "MARKET" || o2 === "Market") return jsx("span", { children: r3("common.marketPrice") });
  let Y2 = () => !s2 || e2.disableEdit ? jsx(mi$1, { order: t, price: o2, setEditing: d2, disableEdit: e2.disableEdit }) : jsx(Re$2, { inputRef: L2, dp: N2, value: o2, setValue: n4, setEditing: d2, handleKeyDown: R2, onClick: W2, onClose: g2, hintInfo: E3 });
  return jsx(Bo$3, { open: i, onOpenChange: a2, content: jsx(qe$3, { type: 1, base: P2, value: o2, cancelPopover: g2, isSubmitting: f2, onConfirm: O2 }), children: jsx("div", { onClick: (A2) => {
    A2.stopPropagation(), A2.preventDefault();
  }, ref: F3, children: Y2() }) });
}, mi$1 = (e2) => {
  let { order: t, price: r3 } = e2;
  return jsx("div", { className: cnBase("oui-flex oui-max-w-[110px] oui-justify-start oui-items-center oui-gap-1 oui-relative oui-font-semibold", ne$2(t) && "oui-text-base-contrast-20"), onClick: (o2) => {
    o2.stopPropagation(), o2.preventDefault(), e2.setEditing(true);
  }, children: jsx(z$3, { r: "base", className: cnBase("oui-min-w-[70px] oui-h-[28px]", !e2.disableEdit && "oui-bg-base-7 oui-px-2  oui-border oui-border-line-12"), children: jsx(Q$1, { size: "2xs", children: E$4(r3) }) }) });
};
var eo$1 = (e2) => {
  let { order: t } = e2, [r3, o2] = useState("");
  useEffect(() => {
    var _a3;
    o2(((_a3 = t.trigger_price) == null ? void 0 : _a3.toString()) ?? "0");
  }, [t.trigger_price]);
  let n4 = (t == null ? void 0 : t.algo_order_id) !== void 0, i = (t == null ? void 0 : t.algo_type) === "BRACKET", [a2, s2] = useState(false), [d2, u2] = useState(false), [l2, f2] = useState(false), { editAlgoOrder: x2, checkMinNotional: C2 } = Z$2(), { base: h2, quote_dp: p2, quote_max: P2, quote_min: N2 } = z$1(), T2 = useMemo(() => {
    if (!((!n4 || i) && !d2)) {
      if (Number(r3) > P2) return `Trigger price must be less than ${P2}`;
      if (Number(r3) < N2) return `Trigger price must be greater than ${N2}`;
    }
  }, [d2, r3, n4, i]), q2 = () => {
    s2(false), u2(false);
  }, g2 = () => {
    var _a3;
    o2(((_a3 = t.trigger_price) == null ? void 0 : _a3.toString()) ?? "0"), s2(false), u2(false);
  }, E3 = useRef(null), W2 = (v3) => {
    E3.current && !E3.current.contains(v3.target) && !a2 && g2();
  };
  useEffect(() => (document.addEventListener("mousedown", W2), () => {
    document.removeEventListener("mousedown", W2);
  }), [a2, t.trigger_price]);
  let R2 = (v3) => {
    if (v3 == null ? void 0 : v3.stopPropagation(), v3 == null ? void 0 : v3.preventDefault(), u2(false), Number(r3) !== Number(t.trigger_price)) {
      if (t.price && t.reduce_only !== true) {
        let Y2 = C2(t.symbol, t.price, t.quantity);
        if (Y2) {
          toast$2.error(Y2), f2(false), g2();
          return;
        }
      }
      s2(true);
    }
  }, O2 = (v3) => {
    v3.key === "Enter" && R2(v3);
  }, L2 = () => {
    if ((T2 ?? "").length > 0) return;
    f2(true);
    let v3 = { quantity: t.quantity, trigger_price: r3, symbol: t.symbol, algo_order_id: t.algo_order_id };
    t.order_tag !== void 0 && (v3 = { ...v3, order_tag: t.order_tag }), x2(`${t.algo_order_id}`, v3).then((Y2) => {
      q2(), o2(r3);
    }, (Y2) => {
      var _a3;
      toast$2.error(Y2.message), o2(((_a3 = t.trigger_price) == null ? void 0 : _a3.toString()) ?? "--"), g2();
    }).finally(() => f2(false));
  }, F3 = useRef(null);
  if (!n4 || i) return jsx(Q$1, { children: "--" });
  let X2 = () => !d2 || e2.disableEdit ? jsx(yi$2, { order: t, price: r3, setEditing: u2, disableEdit: e2.disableEdit }) : jsx(Re$2, { inputRef: F3, dp: p2, value: r3, setValue: o2, setEditing: u2, handleKeyDown: O2, onClick: R2, onClose: g2, hintInfo: T2 });
  return jsx(Bo$3, { open: a2, onOpenChange: s2, content: jsx(qe$3, { type: 2, base: h2, value: r3, cancelPopover: g2, isSubmitting: l2, onConfirm: L2 }), children: jsx("div", { onClick: (v3) => {
    v3.stopPropagation(), v3.preventDefault();
  }, ref: E3, children: X2() }) });
}, yi$2 = (e2) => {
  let { order: t, price: r3 } = e2;
  return jsx("div", { className: cnBase("oui-flex oui-max-w-[110px] oui-justify-start oui-items-center oui-gap-1 oui-relative oui-font-semibold", ne$2(t) && "oui-text-base-contrast-20"), onClick: (o2) => {
    o2.stopPropagation(), o2.preventDefault(), e2.setEditing(true);
  }, children: jsx(z$3, { r: "base", className: cnBase("oui-min-w-[70px] oui-h-[28px]", !e2.disableEdit && "oui-bg-base-7 oui-px-2 oui-border oui-border-line-12"), children: jsx(Q$1, { size: "2xs", children: r3 }) }) });
};
var gt$1 = (e2) => {
  let { order: t } = e2, { t: r3 } = ne$6(), { onCancelOrder: o2 } = Z$2(), [n4, i] = useState(false);
  return jsx(Sr$2, { size: "sm", variant: "outlined", color: "secondary", onClick: (a2) => {
    o2 && (a2.preventDefault(), a2.stopPropagation(), i(true), o2(t).then((s2) => s2, (s2) => {
      toast$2.error(s2.message);
    }).finally(() => {
      i(false);
    }));
  }, loading: n4, children: r3("common.cancel") });
};
var to$2 = (e2) => {
  let { record: t } = e2, [r3, o2] = useState(false), [n4, { data: i, error: a2, reset: s2, isMutating: d2 }] = useMutation("/v1/order"), { t: u2 } = ne$6(), l2 = useConfig("brokerId"), f2 = useCallback(() => {
    o2(false);
    let x2 = { symbol: t.symbol, order_type: t.type, order_price: t.price, order_quantity: t.quantity, order_amount: t.amount, side: t.side, broker_id: l2 };
    Number(t.visible_quantity) < Number(t.quantity) && (x2.visible_quantity = 0), typeof t.reduce_only < "u" && (x2.reduce_only = t.reduce_only), n4(x2);
  }, []);
  return jsx($e$6, { size: "sm", variant: "outlined", color: "secondary", loading: d2, disabled: d2, onClick: (x2) => {
    d2 || (x2.preventDefault(), x2.stopPropagation(), f2());
  }, children: u2("orders.history.renew") });
};
var io$2 = () => {
  let { sl_trigger_price: e2, tp_trigger_price: t, order: r3, position: o2 } = G$1();
  return jsx(Ai, { stopLossPrice: e2, takeProfitPrice: t, direction: "column", order: r3, position: o2, tooltip: true });
}, Ai = (e2) => {
  let { direction: t = "row", order: r3, position: o2 } = e2, n4 = useSymbolsInfo(), { t: i } = ne$6(), a2 = useMemo(() => {
    var _a3;
    let u2 = [];
    if (!e2.tooltip || !r3 || !o2) return;
    let l2 = r3.quantity;
    return l2 === 0 && ((_a3 = r3.child_orders) == null ? void 0 : _a3[0].type) === "CLOSE_POSITION" && (l2 = o2.position_qty), e2.takeProfitPrice && u2.push(jsx(oo$1, { qty: l2, price: e2.takeProfitPrice, entryPrice: o2.average_open_price, orderSide: r3.side, orderType: AlgoOrderType.TAKE_PROFIT, symbolInfo: n4[r3.symbol]() }, "tp")), e2.stopLossPrice && u2.push(jsx(oo$1, { qty: l2, price: e2.stopLossPrice, entryPrice: o2.average_open_price, orderSide: r3.side, orderType: AlgoOrderType.STOP_LOSS, symbolInfo: n4[r3.symbol]() }, "sl")), jsx("div", { children: u2 });
  }, [e2.takeProfitPrice, e2.stopLossPrice, o2 == null ? void 0 : o2.average_open_price, r3 == null ? void 0 : r3.side, r3 == null ? void 0 : r3.quantity, r3 == null ? void 0 : r3.algo_type]), s2 = useMemo(() => {
    let u2 = [];
    return (r3 == null ? void 0 : r3.symbol) ? (e2.takeProfitPrice && u2.push(jsx(Q$1.numeral, { className: cnBase("oui-text-trade-profit oui-gap-0  oui-decoration-white/20 oui-border-b oui-border-dashed oui-border-base-contrast-12"), rule: "price", dp: n4[r3.symbol]("quote_dp", 2), children: e2.takeProfitPrice, prefix: !e2.stopLossPrice || t === "column" ? jsxs("span", { className: "oui-text-base-contrast-54", children: [`${i("tpsl.tp")} -`, ""] }) : "" }, "tp")), e2.stopLossPrice && u2.push(jsx(Q$1.numeral, { className: cnBase("oui-text-trade-loss oui-gap-0 oui-decoration-white/20 oui-border-b oui-border-dashed oui-border-base-contrast-12"), rule: "price", dp: n4[r3.symbol]("quote_dp", 2), children: e2.stopLossPrice, prefix: !e2.takeProfitPrice || t === "column" ? jsxs("span", { className: "oui-text-base-contrast-54", children: [`${i("tpsl.sl")} -`, ""] }) : "" }, "sl")), u2.length === 0 ? jsx("span", { children: "-" }) : (u2.length === 2 && t === "row" && u2.splice(1, 0, jsx("span", { children: "/" }, "split")), u2)) : jsx("span", { children: "-" });
  }, [e2.takeProfitPrice, e2.stopLossPrice, r3 == null ? void 0 : r3.symbol, i]), d2 = jsx("div", { className: cnBase("oui-inline-flex oui-text-base-contrast-36", e2.direction === "column" ? "oui-flex-col" : "oui-flex-row oui-gap-1", e2.className), children: s2 });
  return e2.tooltip ? jsx(xs, { content: a2, className: "oui-bg-base-5", arrow: { className: "oui-fill-base-5" }, children: d2 }) : d2;
}, oo$1 = (e2) => {
  let { qty: t, price: r3, entryPrice: o2, orderSide: n4, orderType: i, symbolInfo: a2 } = e2, { t: s2 } = ne$6(), d2 = utils_exports.priceToPnl({ qty: t, price: r3, entryPrice: o2, orderSide: n4, orderType: i }, { symbol: a2 }), l2 = (i === AlgoOrderType.TAKE_PROFIT ? "TP" : "SL") === "TP" ? `${s2("tpsl.tpPnl")}:` : `${s2("tpsl.slPnl")}:`;
  return jsxs("div", { className: "oui-flex oui-items-center", children: [jsx("span", { className: "oui-text-base-contrast-54 oui-mr-1", children: l2 }), jsx(Q$1.numeral, { rule: "price", dp: a2.quote_dp, padding: false, className: d2 === 0 ? "oui-text-base-contrast-36" : d2 > 0 ? "oui-text-trade-profit oui-gap-0" : "oui-text-trade-loss oui-gap-0", prefix: jsx("span", { children: d2 === 0 ? "" : d2 > 0 ? "+" : "-" }), suffix: jsx("span", { className: "oui-text-base-contrast-36 oui-ml-1", children: "USDC" }), children: `${Math.abs(d2)}` })] });
};
var uo$1 = (e2) => {
  let { order: t } = e2, { quote_dp: r3, base_dp: o2 } = z$1(), { t: n4 } = ne$6(), { sl_trigger_price: i, tp_trigger_price: a2 } = useMemo(() => !("algo_type" in t) || !Array.isArray(t.child_orders) ? {} : utils_exports.findTPSLFromOrder(e2.order.child_orders[0]), [e2.order]), { pnl: s2, roi: d2 } = ct(t);
  return !a2 && !i ? "--" : jsx(xs, { content: jsxs(z$3, { direction: "column", itemAlign: "start", gap: 1, children: [typeof s2.tpPnL < "u" && jsx(Q$1.numeral, { prefix: jsxs(Q$1, { intensity: 80, children: [`${n4("tpsl.tpPnl")}:`, " "] }), suffix: jsx(Q$1, { intensity: 20, children: " USDC" }), dp: r3, color: "buy", showIdentifier: true, children: s2.tpPnL }), typeof s2.slPnL < "u" && jsx(Q$1.numeral, { prefix: jsxs(Q$1, { intensity: 80, children: [`${n4("tpsl.slPnl")}:`, " "] }), suffix: jsx(Q$1, { intensity: 20, children: " USDC" }), dp: r3, color: "sell", children: s2.slPnL })] }), className: "oui-bg-base-6", children: jsxs(z$3, { direction: "column", width: "100%", justify: "start", itemAlign: "start", children: [jsx(so$2, { type: "TP", value: a2, quote_dp: r3 }), jsx(so$2, { type: "SL", value: i, quote_dp: r3 })] }) });
}, so$2 = (e2) => {
  let { type: t, value: r3, quote_dp: o2 } = e2, { t: n4 } = ne$6();
  return r3 ? jsx(Q$1.numeral, { className: cnBase("oui-gap-0 oui-decoration-white/20 oui-border-b oui-border-dashed oui-border-base-contrast-12", t === "TP" ? "oui-text-trade-profit" : "oui-text-trade-loss"), rule: "price", dp: o2, prefix: jsxs("span", { className: "oui-text-base-contrast-54", children: [t === "TP" ? `${n4("tpsl.tp")} -` : `${n4("tpsl.sl")} -`, ""] }), children: r3 }, "tp") : jsx(Fragment$1, {});
};
var co$1 = (e2) => {
  let { position: t, order: r3 } = G$1(), { quote_dp: o2, base_dp: n4 } = z$1(), { t: i } = ne$6();
  return jsx(pt$3, { quoteDP: o2, baseDP: n4, position: t, order: r3, label: i("common.edit"), isEditing: true });
};
var po$3 = () => {
  let { sl_trigger_price: e2, tp_trigger_price: t } = G$1(), { t: r3 } = ne$6();
  return jsxs("div", { children: [t ? jsxs("div", { className: "oui-text-base-contrast-80 oui-td-bg-transparent", children: [jsxs(Q$1, { intensity: 54, children: [`${r3("tpsl.tp")} -`, ""] }), jsx("span", { children: r3("common.marketPrice") })] }) : null, e2 ? jsxs("div", { className: "oui-text-base-contrast-80 oui-td-bg-transparent", children: [jsxs("span", { className: "oui-text-base-contrast-54", children: [`${r3("tpsl.sl")} -`, ""] }), jsx("span", { children: r3("common.marketPrice") })] }) : null] });
};
function fo$2(e2) {
  let { sl_trigger_price: t, tp_trigger_price: r3 } = !("algo_type" in e2) || !Array.isArray(e2.child_orders) ? {} : utils_exports.findTPSLFromOrder(e2), o$1 = r3 ? `${o.t("tpsl.tp")} - ${o.t("common.marketPrice")}` : void 0, n4 = t ? `${o.t("tpsl.sl")} - ${o.t("common.marketPrice")}` : void 0;
  return { tpTriggerPrice: o$1, slTriggerPrice: n4 };
}
var Qt$4 = (e2) => {
  let { t } = ne$6();
  return e2.sharePnLConfig == null ? jsx(Fragment$1, {}) : jsx("button", { type: "button", onClick: (r3) => {
    r3.stopPropagation(), vo$4.show(e2.modalId, { pnl: { entity: { symbol: e2.order.symbol, pnl: e2.order.realized_pnl, side: e2.order.side == "BUY" ? t("share.pnl.share.long") : t("share.pnl.share.short"), openPrice: e2.order.average_executed_price, openTime: e2.order.updated_time, quantity: e2.order.quantity }, refCode: e2.refCode, leverage: e2.leverage, ...e2.sharePnLConfig } });
  }, children: jsx(Dn, { color: "white", opacity: 0.54, size: e2.iconSize ?? 16 }) });
};
var go$3 = (e2) => {
  let { sharePnLConfig: t, order: r3, modalId: o2, iconSize: n4 } = e2, { getFirstRefCode: i } = useReferralInfo(), a2 = useMemo(() => {
    var _a3;
    return (_a3 = i()) == null ? void 0 : _a3.code;
  }, [i]), s2 = useSymbolLeverage(e2.order.symbol);
  return { iconSize: n4, order: r3, refCode: a2, leverage: s2, sharePnLConfig: t, modalId: o2 };
};
var et$3 = (e2) => {
  let t = go$3(e2);
  return jsx(Qt$4, { ...t });
};
var xo$1 = (e2) => {
  let { _type: t, onSymbolChange: r3, pnlNotionalDecimalPrecision: o2, sharePnLConfig: n4 } = e2, { t: i } = ne$6();
  return useMemo(() => {
    switch (t) {
      case "all":
        return [we$2({ width: 130, showType: true, onSymbolChange: r3, enableSort: false }), Me$2({ width: 130, disableEdit: true, className: "oui-pl-0 oui-pr-0", enableSort: false }), We$4({ width: 130, title: i("orders.column.orderPrice"), disableEdit: true, enableSort: false }), bt$4({ width: 130, enableSort: false }), yo$3({ width: 130, symbolsInfo: e2.symbolsInfo }), Ht$1({ width: 124, pnlNotionalDecimalPrecision: o2, sharePnLConfig: n4, symbolsInfo: e2.symbolsInfo }), ze$1({ width: 130, enableSort: false }), rt({ width: 130 }), ot$2({ width: 130 }), Ie$2({ width: 130 }), $e$3({ width: 130 }), bo$1({ width: 130 }), Ue$2({ width: 160, enableSort: false })];
      case "pending":
        return [we$2({ width: 172, showType: true, onSymbolChange: r3, enableSort: false }), Me$2({ width: 162, className: "oui-pr-0", enableSort: false }), We$4({ width: 162, className: "oui-pr-0", enableSort: false }), tt$1({ width: 162, className: "oui-pr-0" }), la({ width: 130 }), ze$1({ width: 162, isPending: true }), Ie$2({ width: 162 }), $e$3({ width: 162 }), Ue$2({ width: 162, enableSort: false }), ua$1({ width: 162 })];
      case "tp_sl":
        return [we$2({ width: 176, showType: true, onSymbolChange: r3, enableSort: false }), ia({ width: 176 }), yo$3({ width: 176, symbolsInfo: e2.symbolsInfo }), aa({ width: 176 }), da({ width: 176 }), Ie$2({ width: 176 }), Ue$2({ width: 176, enableSort: false }), ca({ width: 176 })];
      case "filled":
        return [we$2({ showType: true, width: 154, onSymbolChange: r3 }), Me$2({ width: 124, disableEdit: true, className: "oui-pl-0 oui-pr-0" }), We$4({ width: 124, title: i("orders.column.orderPrice"), disableEdit: true }), sa$1({ width: 124 }), tt$1({ width: 124, disableEdit: true }), Ht$1({ width: 124, pnlNotionalDecimalPrecision: o2, sharePnLConfig: n4, symbolsInfo: e2.symbolsInfo, hideShare: true }), ze$1({ width: 124 }), rt({ width: 124 }), ot$2({ width: 124 }), Ie$2({ width: 124 }), $e$3({ width: 124 }), Ue$2({ width: 176 })];
      case "cancelled":
        return [we$2({ showType: true, width: 154, onSymbolChange: r3, enableSort: false }), Me$2({ width: 124, disableEdit: true, className: "oui-pl-0 oui-pr-0", enableSort: false }), We$4({ width: 124, disableEdit: true, enableSort: false }), bt$4({ width: 124, enableSort: false }), tt$1({ width: 124, disableEdit: true }), ze$1({ width: 124 }), rt({ width: 124 }), ot$2({ width: 124 }), Ie$2({ width: 124 }), $e$3({ width: 124 })];
      case "rejected":
        return [we$2({ showType: true, width: 154, onSymbolChange: r3 }), Me$2({ width: 124, disableEdit: true, className: "oui-pl-0 oui-pr-0" }), We$4({ width: 124, disableEdit: true }), bt$4({ width: 124 }), tt$1({ width: 124, disableEdit: true }), ze$1({ width: 124 }), rt({ width: 124 }), ot$2({ width: 124 }), Ie$2({ width: 124 }), $e$3({ width: 124 }), Ue$2({ width: 176 })];
      case "orderHistory":
        return [we$2({ showType: true, width: 154, onSymbolChange: r3 }), Me$2({ width: 150, disableEdit: true, className: "oui-pl-6 oui-pr-0" }), We$4({ width: 124, disableEdit: true }), bt$4({ width: 124 }), tt$1({ width: 124, disableEdit: true }), Ht$1({ width: 124, pnlNotionalDecimalPrecision: o2, sharePnLConfig: n4, symbolsInfo: e2.symbolsInfo }), ze$1({ width: 124 }), rt({ width: 124 }), ot$2({ width: 124 }), Ie$2({ width: 124 }), $e$3({ width: 124 }), Ue$2({ width: 150 }), bo$1({ width: 80 })];
    }
  }, [t, o2, n4, i]);
};
function we$2(e2) {
  return { title: o.t("common.symbol"), dataIndex: "symbol", fixed: "left", width: e2 == null ? void 0 : e2.width, onSort: (e2 == null ? void 0 : e2.enableSort) ? (t, r3) => t.symbol.localeCompare(r3.symbol) : void 0, renderPlantText: (t, r3) => {
    var _a3;
    let o2 = (_a3 = ue$2(r3)) == null ? void 0 : _a3.join(","), n4 = (o2 == null ? void 0 : o2.length) ? ` (${o2})` : "";
    return `${t.split("_")[1]}-PERP${n4}`;
  }, render: (t, r3) => {
    var _a3;
    let o2 = ne$2(r3);
    return jsxs(z$3, { gap: 2, children: [jsx("div", { className: cnBase("oui-rounded-[1px] oui-w-1 oui-h-7 oui-shrink-0", r3.side === OrderSide.BUY ? "oui-bg-trade-profit" : "oui-bg-trade-loss") }), jsxs(z$3, { direction: "column", itemAlign: "start", children: [jsx(Q$1.formatted, { size: "xs", className: "oui-cursor-pointer oui-text-xs", onClick: (n4) => {
      var _a4;
      (_a4 = e2 == null ? void 0 : e2.onSymbolChange) == null ? void 0 : _a4.call(e2, { symbol: t }), n4.stopPropagation(), n4.preventDefault();
    }, children: `${t.split("_")[1]}-PERP` }), (e2 == null ? void 0 : e2.showType) && jsx(z$3, { direction: "row", gap: 1, children: (_a3 = ue$2(r3)) == null ? void 0 : _a3.map((n4, i) => jsx(Wd, { color: n4.toLocaleLowerCase() === "position" ? o2 ? "neutral" : "primary" : "neutral", size: "xs", className: "oui-break-normal oui-whitespace-nowrap", children: n4 }, i)) })] })] });
  } };
}
function Me$2(e2) {
  return { title: o.t("orders.column.fill&Quantity"), dataIndex: "fill_quantity", className: e2 == null ? void 0 : e2.className, width: e2 == null ? void 0 : e2.width, onSort: (e2 == null ? void 0 : e2.enableSort) ?? false ? (t, r3) => {
    let o2 = (t.algo_type === AlgoOrderRootType.POSITIONAL_TP_SL ? 0 : t.quantity) ?? 0, n4 = (r3.algo_type === AlgoOrderRootType.POSITIONAL_TP_SL ? 0 : r3.quantity) ?? 0;
    return it$3(o2, n4);
  } : void 0, renderPlantText: (t, r3) => {
    if (r3.type === OrderType.CLOSE_POSITION && r3.status !== OrderStatus.FILLED) return o.t("tpsl.entirePosition");
    let o$1 = r3.total_executed_quantity;
    return ("algo_type" in r3 && r3.algo_type === AlgoOrderRootType.TP_SL ? "" : `${o$1} / `) + `${r3.quantity}`;
  }, render: (t, r3) => r3.type === OrderType.CLOSE_POSITION && r3.status !== OrderStatus.FILLED ? o.t("tpsl.entirePosition") : jsx(Mt$2, { order: r3, disableEdit: e2 == null ? void 0 : e2.disableEdit }) };
}
function ia(e2) {
  return { title: o.t("common.quantity"), className: e2 == null ? void 0 : e2.className, dataIndex: "quantity", width: e2 == null ? void 0 : e2.width, onSort: (e2 == null ? void 0 : e2.enableSort) ?? false ? (t, r3) => {
    let o2 = (t.algo_type === AlgoOrderRootType.POSITIONAL_TP_SL ? 0 : t.quantity) ?? 0, n4 = (r3.algo_type === AlgoOrderRootType.POSITIONAL_TP_SL ? 0 : r3.quantity) ?? 0;
    return it$3(o2, n4);
  } : void 0, renderPlantText: (t, r3) => {
    if (r3.algo_type === AlgoOrderRootType.POSITIONAL_TP_SL) return o.t("tpsl.entirePosition");
    let o$1 = r3.total_executed_quantity;
    return ("algo_type" in r3 && r3.algo_type === AlgoOrderRootType.TP_SL ? "" : `${o$1}/`) + `${r3.quantity}`;
  }, render: (t, r3) => r3.algo_type === AlgoOrderRootType.POSITIONAL_TP_SL ? o.t("tpsl.entirePosition") : jsx(Mt$2, { order: r3 }) };
}
function We$4(e2) {
  return { title: (e2 == null ? void 0 : e2.title) ?? o.t("common.price"), dataIndex: "price", className: e2 == null ? void 0 : e2.className, width: e2 == null ? void 0 : e2.width, onSort: (e2 == null ? void 0 : e2.enableSort) ?? false ? (t, r3, o2) => it$3(t.price ?? 0, r3.price ?? 0) : void 0, renderPlantText: (t, r3) => {
    var _a3;
    return E$4((_a3 = r3.price) == null ? void 0 : _a3.toString(), { fallback: o.t("common.marketPrice") });
  }, render: (t, r3) => jsx(Yr$1, { order: r3, disableEdit: e2 == null ? void 0 : e2.disableEdit }) };
}
function aa(e2) {
  return { title: (e2 == null ? void 0 : e2.title) ?? o.t("common.price"), dataIndex: "price", className: e2 == null ? void 0 : e2.className, width: e2 == null ? void 0 : e2.width, onSort: e2 == null ? void 0 : e2.enableSort, renderPlantText: (t, r3) => {
    let { tpTriggerPrice: o2, slTriggerPrice: n4 } = fo$2(r3), i = `${o2 || ""}${n4 ? `${o2 ? `
` : ""}${n4}` : ""}`;
    return i.length > 0 ? i : "--";
  }, render: (t, r3) => jsx(po$3, {}) };
}
function sa$1(e2) {
  return { title: o.t("common.avgPrice"), dataIndex: "average_executed_price", className: e2 == null ? void 0 : e2.className, width: e2 == null ? void 0 : e2.width, onSort: e2 == null ? void 0 : e2.enableSort, render: (t, r3) => E$4(t) };
}
function tt$1(e2) {
  return { title: o.t("common.trigger"), className: e2 == null ? void 0 : e2.className, dataIndex: "trigger_price", width: e2 == null ? void 0 : e2.width, onSort: e2 == null ? void 0 : e2.enableSort, renderPlantText: (t, r3) => {
    let o2 = (r3 == null ? void 0 : r3.algo_order_id) !== void 0, n4 = (r3 == null ? void 0 : r3.algo_type) === "BRACKET";
    return !o2 || n4 ? "--" : E$4(t);
  }, render: (t, r3) => jsx(eo$1, { order: r3, disableEdit: e2 == null ? void 0 : e2.disableEdit }) };
}
function yo$3(e2) {
  return { title: (e2 == null ? void 0 : e2.title) ?? o.t("common.trigger"), className: e2 == null ? void 0 : e2.className, dataIndex: "tpsl_trigger_price", width: e2 == null ? void 0 : e2.width, onSort: e2 == null ? void 0 : e2.enableSort, renderPlantText: (t, r3) => {
    var _a3;
    let o$1 = (_a3 = e2 == null ? void 0 : e2.symbolsInfo) == null ? void 0 : _a3[r3.symbol], n4 = o$1 == null ? void 0 : o$1("quote_dp"), { sl_trigger_price: i, tp_trigger_price: a2 } = !("algo_type" in r3) || !Array.isArray(r3.child_orders) ? {} : utils_exports.findTPSLFromOrder(r3), s2 = (a2 != null ? `${o.t("tpsl.tp")}: ${E$4(a2, { fix: n4, padEnd: true })}` : "") + (i != null ? `${a2 ? `
` : ""}${o.t("tpsl.sl")}: ${E$4(i, { fix: n4, padEnd: true })}` : "");
    return s2.length > 0 ? s2 : "--";
  }, render: (t, r3) => jsx(io$2, {}) };
}
function la(e2) {
  return { title: o.t("common.tpsl"), className: e2 == null ? void 0 : e2.className, dataIndex: "bracketOrderPrice", width: e2 == null ? void 0 : e2.width, onSort: e2 == null ? void 0 : e2.enableSort, renderPlantText: (t, r3) => {
    let o$1 = () => !("algo_type" in r3) || !Array.isArray(r3.child_orders) ? {} : utils_exports.findTPSLFromOrder(r3.child_orders[0]), { sl_trigger_price: n4, tp_trigger_price: i } = o$1(), a2 = (i != null ? `${o.t("tpsl.tp")}: ${i}` : "") + (n4 != null ? `${i ? `
` : ""}${o.t("tpsl.sl")}: ${n4}` : "");
    return a2.length > 0 ? a2 : "--";
  }, render: (t, r3) => jsx(uo$1, { order: r3 }) };
}
function ze$1(e2) {
  return { title: o.t("common.notional"), dataIndex: "executed", width: e2 == null ? void 0 : e2.width, className: e2 == null ? void 0 : e2.className, onSort: (e2 == null ? void 0 : e2.enableSort) ?? false ? (t, r3, o2) => {
    let n4 = t.type === OrderType.CLOSE_POSITION && t.status !== OrderStatus.FILLED || t.total_executed_quantity === 0 || Number.isNaN(t.average_executed_price) || t.average_executed_price === null ? 0 : t.total_executed_quantity * t.average_executed_price, i = r3.type === OrderType.CLOSE_POSITION && r3.status !== OrderStatus.FILLED || r3.total_executed_quantity === 0 || Number.isNaN(r3.average_executed_price) || r3.average_executed_price === null ? 0 : r3.total_executed_quantity * r3.average_executed_price;
    return it$3(n4, i);
  } : void 0, renderPlantText: (t, r3) => Vt$1(r3, (e2 == null ? void 0 : e2.isPending) ?? false) === "Entire position" ? o.t("tpsl.entirePosition") : E$4(Vt$1(r3, (e2 == null ? void 0 : e2.isPending) ?? false), { fix: 2 }), render: (t, r3) => {
    let o$1 = Vt$1(r3, (e2 == null ? void 0 : e2.isPending) ?? false);
    return o$1 === "Entire position" ? o.t("tpsl.entirePosition") : jsx(Q$1.numeral, { rm: g$6.ROUND_DOWN, dp: 2, children: o$1 });
  } };
}
function Ht$1(e2) {
  return { title: o.t("common.realizedPnl"), dataIndex: "realized_pnl", width: e2 == null ? void 0 : e2.width, className: e2 == null ? void 0 : e2.className, renderPlantText: (t, r3) => {
    var _a3;
    let o2 = (_a3 = e2 == null ? void 0 : e2.symbolsInfo) == null ? void 0 : _a3[r3.symbol], n4 = o2 == null ? void 0 : o2("quote_dp"), i = (e2 == null ? void 0 : e2.pnlNotionalDecimalPrecision) ?? n4, a2 = new g$6(t ?? 0).toDecimalPlaces(i, g$6.ROUND_DOWN).toNumber(), s2 = E$4(a2);
    return a2 > 0 ? `+${s2}` : s2;
  }, render: (t, r3) => {
    let { quote_dp: o2 } = z$1(), n4 = (e2 == null ? void 0 : e2.pnlNotionalDecimalPrecision) ?? o2, i = new g$6(t ?? 0).toDecimalPlaces(n4, g$6.ROUND_DOWN).toNumber();
    return jsxs(z$3, { gap: 1, children: [jsx(Q$1.numeral, { dp: n4, rm: g$6.ROUND_DOWN, padding: false, intensity: (i ?? 0) == 0 ? 80 : void 0, showIdentifier: (i ?? 0) > 0, coloring: (i ?? 0) != 0, children: i ?? "--" }), !(e2 == null ? void 0 : e2.hideShare) && jsx(et$3, { order: r3, sharePnLConfig: e2 == null ? void 0 : e2.sharePnLConfig, modalId: jt$2 })] });
  } };
}
function Ie$2(e2) {
  return { title: o.t("orderEntry.reduceOnly"), dataIndex: "reduce_only", width: e2 == null ? void 0 : e2.width, className: e2 == null ? void 0 : e2.className, renderPlantText: (t, r3) => t ? o.t("common.yes") : o.t("common.no"), render: (t) => jsx(Q$1, { children: t ? o.t("common.yes") : o.t("common.no") }) };
}
function $e$3(e2) {
  return { title: o.t("orders.column.hidden"), dataIndex: "visible", width: e2 == null ? void 0 : e2.width, className: e2 == null ? void 0 : e2.className, renderPlantText: (t, r3) => t !== 0 ? o.t("common.no") : o.t("common.yes"), render: (t, r3) => jsx(Q$1, { children: r3.visible_quantity !== 0 ? o.t("common.no") : o.t("common.yes") }) };
}
function Ue$2(e2) {
  return { title: o.t("orders.column.orderTime"), dataIndex: "created_time", width: e2 == null ? void 0 : e2.width, onSort: e2 == null ? void 0 : e2.enableSort, className: e2 == null ? void 0 : e2.className, renderPlantText: (t, r3) => {
    let o2 = new Date(t);
    return format(o2, "yyyy-MM-dd HH:mm:ss");
  }, render: (t) => jsx(Q$1.formatted, { rule: "date", formatString: (e2 == null ? void 0 : e2.formatString) || "yyyy-MM-dd HH:mm:ss", className: "oui-break-normal oui-whitespace-nowrap oui-font-semibold", children: t }) };
}
function rt(e2) {
  return { title: o.t("common.fee"), dataIndex: "total_fee", width: e2 == null ? void 0 : e2.width, onSort: e2 == null ? void 0 : e2.enableSort, className: e2 == null ? void 0 : e2.className };
}
function da(e2) {
  return { title: o.t("common.notional"), dataIndex: "executed", width: e2 == null ? void 0 : e2.width, onSort: e2 == null ? void 0 : e2.enableSort, className: e2 == null ? void 0 : e2.className, renderPlantText: (t, r3) => r3.algo_type === AlgoOrderRootType.POSITIONAL_TP_SL ? o.t("tpsl.entirePosition") : E$4(r3.quantity === 0 ? "--" : `${new g$6(r3.mark_price).mul(r3.quantity).todp(2).toNumber()}`), render: (t, r3) => r3.algo_type === AlgoOrderRootType.POSITIONAL_TP_SL ? o.t("tpsl.entirePosition") : jsx(Q$1.numeral, { className: "oui-break-normal oui-whitespace-nowrap oui-font-semibold", children: r3.quantity === 0 ? "--" : `${new g$6(r3.mark_price).mul(r3.quantity).todp(2).toNumber()}` }) };
}
function ot$2(e2) {
  let t = { [OrderStatus.NEW]: o.t("orders.status.pending"), [OrderStatus.FILLED]: o.t("orders.status.filled"), [OrderStatus.PARTIAL_FILLED]: o.t("orders.status.partialFilled"), [OrderStatus.CANCELLED]: o.t("orders.status.canceled"), [OrderStatus.REJECTED]: o.t("orders.status.rejected"), [OrderStatus.INCOMPLETE]: o.t("orders.status.incomplete"), [OrderStatus.COMPLETED]: o.t("orders.status.completed") };
  return { title: o.t("common.status"), dataIndex: "status", width: e2 == null ? void 0 : e2.width, onSort: e2 == null ? void 0 : e2.enableSort, className: e2 == null ? void 0 : e2.className, renderPlantText: (r3, o2) => {
    let n4 = r3 || o2.algo_status;
    return t[n4] || Le$1(n4);
  }, render: (r3, o2) => {
    let n4 = r3 || o2.algo_status;
    return t[n4] || Le$1(n4);
  } };
}
function bt$4(e2) {
  return { title: o.t("common.avgPrice"), dataIndex: "average_executed_price", width: e2 == null ? void 0 : e2.width, onSort: (e2 == null ? void 0 : e2.enableSort) ?? false ? (t, r3) => it$3(t.average_executed_price ?? 0, r3.average_executed_price ?? 0) : void 0, className: e2 == null ? void 0 : e2.className, render: (t, r3) => r3.type === OrderType.MARKET && !t ? "--" : jsx(Q$1, { className: "oui-break-normal oui-whitespace-nowrap oui-font-semibold", children: t }), renderPlantText: (t, r3) => E$4(t, { fix: 2 }) };
}
function bo$1(e2) {
  return { title: "", type: "action", dataIndex: "action", width: e2 == null ? void 0 : e2.width, className: e2 == null ? void 0 : e2.className, align: "right", fixed: "right", render: (t, r3) => r3.status === OrderStatus.CANCELLED ? jsx(to$2, { record: r3 }) : r3.status === OrderStatus.NEW || r3.algo_status === OrderStatus.NEW ? jsx(gt$1, { order: r3 }) : null };
}
function ua$1(e2) {
  return { title: "", type: "action", dataIndex: "action", width: e2 == null ? void 0 : e2.width, className: e2 == null ? void 0 : e2.className, align: "right", fixed: "right", render: (t, r3) => jsx(gt$1, { order: r3 }) };
}
function ca(e2) {
  return { title: "", type: "action", dataIndex: "action", width: e2 == null ? void 0 : e2.width, className: e2 == null ? void 0 : e2.className, align: "right", fixed: "right", render: (t, r3) => jsxs(z$3, { gap: 3, children: [jsx(co$1, { order: r3 }), jsx(gt$1, { order: r3 })] }) };
}
function it$3(e2, t) {
  return e2 > t ? 1 : e2 < t ? -1 : 0;
}
function Vt$1(e2, t) {
  return t ? e2.price && e2.quantity ? new g$6(e2.price).mul(e2.quantity).toFixed(2, g$6.ROUND_DOWN) : "--" : e2.type === OrderType.CLOSE_POSITION && e2.status !== OrderStatus.FILLED ? o.t("tpsl.entirePosition") : e2.total_executed_quantity === 0 || Number.isNaN(e2.average_executed_price) || e2.average_executed_price === null ? "--" : `${e2.total_executed_quantity * e2.average_executed_price}`;
}
var ho$3 = (e2) => {
  let { item: t } = e2, r3 = t.side === OrderSide.BUY, { t: o2 } = ne$6();
  return jsx(Q$1.formatted, { intensity: 80, rule: "symbol", formatString: "base-type", size: "sm", prefix: jsx(Wd, { color: r3 ? "success" : "danger", size: "xs", children: o2(r3 ? "common.buy" : "common.sell") }), onClick: () => {
    var _a3;
    (_a3 = e2.onSymbolChange) == null ? void 0 : _a3.call(e2, { symbol: t.symbol });
  }, children: t.symbol });
}, Co$2 = (e2) => {
  var _a3;
  let { item: t } = e2;
  useCallback(() => {
    let o2 = typeof t.type == "string" ? t.type.replace("_ORDER", "").toLowerCase() : t.type;
    return t.algo_order_id && t.algo_type !== AlgoOrderRootType.BRACKET ? `Stop ${o2}` : Le$1(t.type);
  }, [t]);
  return jsx(z$3, { direction: "row", gap: 1, children: (_a3 = ue$2(e2.item)) == null ? void 0 : _a3.map((o2, n4) => jsx(Wd, { color: o2.toLocaleLowerCase() === "position" ? "primary" : "neutral", size: "xs", children: o2 }, n4)) });
}, To$1 = (e2) => {
  let { item: t } = e2;
  return jsx(Q$1.formatted, { rule: "date", formatString: "yyyy-MM-dd hh:mm:ss", intensity: 36, size: "2xs", children: t.updated_time });
}, Lo$1 = (e2) => {
  let { item: t } = e2, { t: r3 } = ne$6(), o2 = t.status || t.algo_status, n4 = useMemo(() => ({ [OrderStatus.NEW]: r3("orders.status.pending"), [OrderStatus.FILLED]: r3("orders.status.filled"), [OrderStatus.PARTIAL_FILLED]: r3("orders.status.partialFilled"), [OrderStatus.CANCELLED]: r3("orders.status.canceled"), [OrderStatus.REJECTED]: r3("orders.status.rejected"), [OrderStatus.INCOMPLETE]: r3("orders.status.incomplete"), [OrderStatus.COMPLETED]: r3("orders.status.completed") }), [r3]);
  return jsx(Q$1.formatted, { intensity: 80, size: "2xs", children: n4[o2] || Le$1(o2) });
}, Gt$2 = (e2) => {
  let { item: t } = e2, { t: r3 } = ne$6(), o2 = t.type === OrderType.CLOSE_POSITION && (t == null ? void 0 : t.status) !== OrderStatus.FILLED;
  return jsx(za$1, { label: r3("common.qty"), classNames: { root: "oui-text-xs", label: "oui-text-2xs" }, children: jsx(Q$1.numeral, { dp: e2.base_dp, padding: false, coloring: true, placeholder: r3("tpsl.entirePosition"), intensity: 80, children: o2 ? r3("tpsl.entirePosition") : t.quantity }) });
}, Jt$2 = (e2) => {
  let { item: t } = e2, { t: r3 } = ne$6();
  return jsx(za$1, { label: jsx(Q$1, { children: r3("orders.status.filled") }), classNames: { root: "oui-text-xs", label: "oui-text-2xs" }, children: jsx(Q$1.numeral, { dp: e2.base_dp, intensity: 80, padding: false, rm: g$6.ROUND_DOWN, children: t.total_executed_quantity }) });
};
var No$1 = (e2) => {
  let { item: t } = e2, { t: r3 } = ne$6(), o2 = useMemo(() => t.price && t.quantity ? new g$6(t.price).mul(t.quantity).toFixed(e2.quote_dp, g$6.ROUND_DOWN) : "--", [t.price, t.quantity]);
  return jsx(za$1, { align: "end", label: jsxs(Q$1, { children: [r3("common.notional"), jsx(Q$1, { intensity: 20, children: "(USDC)" })] }), classNames: { root: "oui-text-xs", label: "oui-text-2xs" }, children: jsx(Q$1.numeral, { dp: e2.quote_dp, coloring: true, intensity: 80, padding: false, rm: g$6.ROUND_DOWN, children: o2 }) });
}, Xt$2 = (e2) => {
  let { item: t } = e2, { t: r3 } = ne$6();
  return jsx(za$1, { label: r3("orders.column.triggerPrice"), classNames: { root: "oui-text-xs", label: "oui-text-2xs" }, align: e2.align, children: jsx(Q$1.numeral, { dp: e2.quote_dp, intensity: 80, padding: false, rm: g$6.ROUND_DOWN, children: t.trigger_price ?? "--" }) });
}, wo$1 = (e2) => {
  let { item: t } = e2, { t: r3 } = ne$6();
  return jsx(za$1, { label: r3("common.markPrice"), align: "end", classNames: { root: "oui-text-xs", label: "oui-text-2xs" }, children: jsx(Q$1.numeral, { dp: e2.quote_dp, rm: g$6.ROUND_DOWN, intensity: 80, padding: false, children: t.mark_price }) });
}, Io$3 = (e2) => {
  let { item: t } = e2, { t: r3 } = ne$6(), o2 = (t == null ? void 0 : t.algo_order_id) !== void 0, n4 = (t == null ? void 0 : t.type) === "MARKET" && o2;
  return jsx(za$1, { label: r3("common.limitPrice"), classNames: { root: "oui-text-xs", label: "oui-text-2xs" }, children: n4 ? jsx(Q$1, { children: r3("common.marketPrice") }) : jsx(Q$1.numeral, { dp: e2.quote_dp, rm: g$6.ROUND_DOWN, intensity: 80, padding: false, children: t.price ?? "--" }) });
}, Eo$1 = (e2) => {
  let { tp_trigger_price: t, tpPnL: r3 } = G$1(), { t: o2 } = ne$6();
  return jsx(za$1, { label: o2("tpsl.tpTrigger"), classNames: { root: "oui-text-xs", label: "oui-text-2xs" }, children: jsx(xt$2, { content: r3 && jsx(Q$1.numeral, { size: "2xs", showIdentifier: true, prefix: jsxs(Q$1, { intensity: 54, children: [`${o2("tpsl.tpPnl")}:`, ""] }), suffix: jsx(Q$1, { intensity: 20, children: "USDC" }), coloring: true, children: r3 }), classNames: { content: "oui-bg-base-6 oui-ml-2", arrow: "oui-fill-base-6" }, children: jsx(Q$1.numeral, { dp: e2.quote_dp, rm: g$6.ROUND_DOWN, color: "buy", padding: false, className: t ? "oui-border-b oui-border-dashed oui-border-base-contrast-12" : void 0, children: t ?? "--" }) }) });
}, vo$1 = (e2) => {
  let { sl_trigger_price: t, slPnL: r3 } = G$1(), { t: o2 } = ne$6();
  return jsx(za$1, { label: o2("tpsl.slTrigger"), classNames: { root: "oui-text-xs", label: "oui-text-2xs" }, children: jsx(xt$2, { content: r3 && jsx(Q$1.numeral, { size: "2xs", prefix: jsxs(Q$1, { intensity: 54, children: [`${o2("tpsl.slPnl")}:`, ""] }), suffix: jsx(Q$1, { intensity: 20, children: "USDC" }), coloring: true, children: r3 }), classNames: { content: "oui-bg-base-6 oui-ml-2", arrow: "oui-fill-base-6" }, children: jsx(Q$1.numeral, { dp: e2.quote_dp, rm: g$6.ROUND_DOWN, color: "sell", padding: false, className: t ? "oui-border-b oui-border-dashed oui-border-base-contrast-12" : void 0, children: t ?? "--" }) }) });
}, Ao$2 = (e2) => {
  let { t } = ne$6();
  return jsx(za$1, { label: t("tpsl.tpPrice"), classNames: { root: "oui-text-xs", label: "oui-text-2xs" }, children: jsx(Q$1, { intensity: 80, children: t("common.marketPrice") }) });
}, Do$1 = (e2) => {
  let { t } = ne$6();
  return jsx(za$1, { label: t("tpsl.slPrice"), classNames: { root: "oui-text-xs", label: "oui-text-2xs" }, children: jsx(Q$1, { intensity: 80, children: t("common.marketPrice") }) });
}, Fo$1 = (e2) => {
  let { item: t } = e2, { t: r3 } = ne$6(), o2 = useMemo(() => t.algo_type === AlgoOrderRootType.POSITIONAL_TP_SL ? jsx("span", { className: "oui-text-base-contrast-80", children: r3("tpsl.entirePosition") }) : jsx(Q$1.numeral, { dp: e2.quote_dp, rm: g$6.ROUND_DOWN, intensity: 80, padding: false, children: t.quantity }), [t, r3]);
  return jsx(za$1, { label: r3("common.quantity"), classNames: { root: "oui-text-xs", label: "oui-text-2xs" }, align: "end", children: o2 });
}, ko = (e2) => {
  var _a3;
  let { t } = ne$6();
  return jsx(za$1, { label: jsxs(Q$1, { children: [t("common.avgPrice"), jsx(Q$1, { intensity: 20, children: "(USDC)" })] }), classNames: { root: "oui-text-xs", label: "oui-text-2xs" }, children: jsx(Q$1.numeral, { dp: e2.quote_dp, rm: g$6.ROUND_DOWN, intensity: 80, padding: false, children: ((_a3 = e2.item) == null ? void 0 : _a3.average_executed_price) ?? "--" }) });
}, qo$2 = (e2) => {
  var _a3;
  let { t } = ne$6();
  return jsx(za$1, { label: jsxs(Q$1, { children: [t("orders.column.orderPrice"), jsx(Q$1, { intensity: 20, children: "(USDC)" })] }), classNames: { root: "oui-text-xs", label: "oui-text-2xs" }, children: jsx(Q$1.numeral, { dp: e2.quote_dp, rm: g$6.ROUND_DOWN, intensity: 80, padding: false, placeholder: t("common.marketPrice"), children: ((_a3 = e2.item) == null ? void 0 : _a3.price) ?? "--" }) });
}, Ro$1 = (e2) => {
  var _a3;
  let t = (_a3 = e2 == null ? void 0 : e2.item) == null ? void 0 : _a3.realized_pnl, { t: r3 } = ne$6();
  return jsx(za$1, { label: jsxs(Q$1, { children: [r3("common.realizedPnl"), jsx(Q$1, { intensity: 20, children: "(USDC)" })] }), classNames: { root: "oui-text-xs", label: "oui-text-2xs" }, align: "end", children: jsxs(z$3, { gap: 1, children: [jsx(Q$1.numeral, { dp: e2.quote_dp, rm: g$6.ROUND_DOWN, padding: false, intensity: (t ?? 0) == 0 ? 80 : void 0, showIdentifier: (t ?? 0) > 0, coloring: (t ?? 0) != 0, children: t ?? "--" }), jsx(et$3, { order: e2.item, sharePnLConfig: e2.sharePnLConfig, modalId: eo$3, iconSize: 12 })] }) });
}, xt$2 = (e2) => {
  let { classNames: t, content: r3 } = e2, [o2, n4] = useState(false);
  return typeof r3 > "u" ? e2.children : jsx(xs, { content: r3, className: t == null ? void 0 : t.content, open: o2, onOpenChange: n4, arrow: { className: t == null ? void 0 : t.arrow }, children: jsx("div", { onClick: () => n4((i) => !i), children: e2.children }) });
};
var Zt$3 = (e2) => {
  let { t } = ne$6(), { item: r3 } = e2;
  r3.quantity > 0;
  return jsx(Fragment$1, { children: jsx($e$6, { variant: "outlined", fullWidth: true, color: "secondary", size: "sm", className: "oui-border-base-contrast-36", onClick: () => {
    e2.onShowEditSheet();
  }, children: t("common.edit") }) });
};
var Wo$2 = (e2) => {
  var _a3;
  let { side: t } = e2.item, { price: r3, quantity: o2, triggerPrice: n4, isAlgoOrder: i } = e2, a2 = t === OrderSide.BUY, { t: s2 } = ne$6();
  return jsxs("div", { className: "oui-pt-2", children: [jsx(Q$1, { intensity: 80, children: `You agree to edit your ${e2.base}-PERP order.` }), jsxs(z$3, { gap: 2, mb: 3, mt: 2, justify: "between", children: [jsx(Q$1.formatted, { rule: "symbol", formatString: "base-type", size: "base", showIcon: true, children: e2.item.symbol }), jsxs(z$3, { direction: "row", gap: 1, children: [(_a3 = ue$2(e2.item)) == null ? void 0 : _a3.map((d2, u2) => jsx(Wd, { color: d2.toLocaleLowerCase() === "position" ? "primary" : "neutral", size: "xs", children: d2 }, u2)), a2 && jsx(Wd, { color: "success", size: "xs", children: s2("common.buy") }), !a2 && jsx(Wd, { color: "danger", size: "xs", children: s2("common.sell") })] })] }), jsx(de$5, {}), jsxs(z$3, { direction: "column", gap: 1, width: "100%", className: "oui-text-sm oui-text-base-contrast-54", py: 3, children: [i && jsxs(z$3, { justify: "between", width: "100%", gap: 1, children: [jsx(Q$1, { children: s2("orders.column.triggerPrice") }), jsx(Q$1.numeral, { intensity: 80, dp: e2.quote_dp, padding: false, rm: g$6.ROUND_DOWN, suffix: jsx(Q$1, { intensity: 54, children: " USDC" }), children: n4 ?? "--" })] }), jsxs(z$3, { justify: "between", width: "100%", gap: 1, children: [jsx(Q$1, { children: s2("common.price") }), jsx(Q$1.numeral, { intensity: 80, dp: e2.quote_dp, padding: false, rm: g$6.ROUND_DOWN, suffix: jsx(Q$1, { intensity: 54, children: " USDC" }), placeholder: e2.isStopMarket ? s2("common.marketPrice") : "--", children: e2.isStopMarket ? s2("common.marketPrice") : r3 ?? "--" })] }), jsxs(z$3, { justify: "between", width: "100%", gap: 1, children: [jsx(Q$1, { children: s2("common.qty") }), jsx(Q$1.numeral, { color: t === OrderSide.BUY ? "buy" : "sell", dp: e2.base_dp, padding: false, rm: g$6.ROUND_DOWN, children: o2 ?? "--" })] })] }), jsxs(z$3, { className: "oui-gap-[2px]", children: [jsx(pi$1, { color: "white", id: "oui-checkbox-disableOrderConfirmation", checked: !e2.orderConfirm, onCheckedChange: (d2) => {
    e2.setOrderConfirm(!d2);
  } }), jsx("label", { className: "oui-text-2xs oui-text-base-contrast-54", htmlFor: "oui-checkbox-disableOrderConfirmation", children: s2("orderEntry.disableOrderConfirm") })] })] });
};
var nr$1 = (e2) => {
  var _a3, _b2, _c2;
  let { item: t } = e2, r3 = t.side === OrderSide.BUY, { t: o2 } = ne$6(), { parseErrorMsg: n4 } = Lr$3(e2.errors), i = n4("order_quantity"), a2 = n4("order_price"), s2 = n4("trigger_price"), d2 = e2.quantity && e2.maxQty ? Math.min(Number(e2.quantity) / e2.maxQty, 1) : void 0, u2 = (l2) => {
    let f2 = e2.baseTick;
    if (f2 && f2 > 0) {
      let x2 = utils_exports.formatNumber(l2, f2) ?? l2;
      e2.setQuantity(x2);
    }
  };
  return jsxs(Fragment$1, { children: [jsxs(z$3, { direction: "column", gap: 3, width: "100%", itemAlign: "start", className: "oui-text-sm", children: [jsxs(z$3, { width: "100%", justify: "between", children: [jsx(Q$1.formatted, { rule: "symbol", showIcon: true, intensity: 80, children: t.symbol }), jsxs(z$3, { direction: "row", gap: 1, children: [(_a3 = ue$2(e2.item)) == null ? void 0 : _a3.map((l2, f2) => jsx(Wd, { color: l2.toLocaleLowerCase() === "position" ? "primary" : "neutral", size: "xs", children: l2 }, f2)), r3 && jsx(Wd, { color: "success", size: "xs", children: o2("common.buy") }), !r3 && jsx(Wd, { color: "danger", size: "xs", children: o2("common.sell") })] })] }), jsx(de$5, { intensity: 8, className: "oui-w-full" }), jsxs(z$3, { width: "100%", justify: "between", children: [jsx(Q$1, { children: o2("common.lastPrice") }), jsx(Q$1.numeral, { dp: (_c2 = (_b2 = e2.item) == null ? void 0 : _b2.symbolInfo) == null ? void 0 : _c2.duote_dp, children: e2.curMarkPrice ?? "--" })] }), jsxs(z$3, { width: "100%", direction: "column", itemAlign: "stretch", gap: 2, children: [e2.isAlgoOrder && jsx(Fo$3.tooltip, { prefix: jsx(Q$1, { intensity: 54, className: "oui-px-3", children: o2("orders.column.triggerPrice") }), suffix: jsx(Q$1, { intensity: 54, className: "oui-px-3", children: e2.quote }), color: s2 ? "danger" : void 0, align: "right", fullWidth: true, autoComplete: "off", formatters: [li$3.numberFormatter, li$3.dpFormatter(e2.quote_dp)], value: e2.triggerPrice, onValueChange: (l2) => e2.setTriggerPrice(l2), tooltip: s2, tooltipProps: { content: { className: "oui-bg-base-6 oui-text-base-contrast-80" }, arrow: { className: "oui-fill-base-6" } }, classNames: { input: "oui-text-base-contrast oui-w-full", root: cnBase("oui-outline-line-12", s2 && "oui-outline-danger") } }), jsx(Fo$3.tooltip, { prefix: jsx(Q$1, { intensity: 54, className: "oui-px-3", children: o2("common.price") }), suffix: jsx(Q$1, { intensity: 54, className: "oui-px-3", children: e2.quote }), color: a2 ? "danger" : void 0, align: "right", fullWidth: true, autoComplete: "off", formatters: [li$3.numberFormatter, li$3.dpFormatter(e2.quote_dp)], disabled: !e2.priceEdit, value: e2.isStopMarket ? o2("orderEntry.orderType.market") : e2.price, onValueChange: (l2) => e2.setPrice(l2), tooltip: a2, tooltipProps: { content: { className: "oui-bg-base-5" }, arrow: { className: "oui-fill-base-5" } }, classNames: { input: "oui-text-base-contrast", root: cnBase("oui-outline-line-12", a2 && "oui-outline-danger") } }), jsx(Fo$3.tooltip, { prefix: jsx(Q$1, { intensity: 54, className: "oui-px-3", children: o2("common.quantity") }), suffix: jsx(Q$1, { intensity: 54, className: "oui-px-3", children: e2.base }), color: i ? "danger" : void 0, align: "right", fullWidth: true, autoComplete: "off", formatters: [li$3.numberFormatter, li$3.dpFormatter(e2.base_dp)], value: e2.quantity, onValueChange: (l2) => {
    e2.setQuantity(l2);
  }, onBlur: (l2) => u2(l2.target.value), tooltip: i, tooltipProps: { content: { className: "oui-bg-base-6" }, arrow: { className: "oui-fill-base-6" } }, classNames: { input: "oui-text-base-contrast", root: cnBase("oui-outline-line-12", i && "oui-outline-danger") } }), jsx(iu, { markCount: 4, value: [e2.sliderValue ?? 0], onValueChange: (l2) => {
    e2.setSliderValue(l2[0]);
  }, color: "primary" }), jsxs(z$3, { width: "100%", justify: "between", children: [jsx(Q$1.numeral, { color: "primary", size: "2xs", dp: 2, padding: false, rule: "percentages", children: `${d2 ?? 0}` }), jsxs(z$3, { gap: 1, children: [jsx(Q$1, { size: "2xs", color: "primary", children: o2("common.max") }), jsx(Q$1.numeral, { intensity: 54, size: "2xs", dp: e2.base_dp, children: e2.maxQty })] })] })] }), jsxs(z$3, { width: "100%", gap: 3, mt: 2, children: [jsx($e$6, { fullWidth: true, color: "secondary", onClick: (l2) => {
    e2.onClose();
  }, children: o2("common.cancel") }), jsx(Sr$2, { fullWidth: true, onClick: (l2) => {
    l2.stopPropagation(), l2.preventDefault(), e2.onSheetConfirm();
  }, loading: e2.submitting, disabled: !e2.isChanged, children: o2("common.confirm") })] })] }), jsx(Se$5, { open: e2.dialogOpen, onOpenChange: e2.setDialogOpen, title: o2("orders.editOrder"), size: "xs", actions: { primary: { label: o2("common.confirm"), onClick: e2.onDialogConfirm, loading: e2.submitting, fullWidth: true }, secondary: { label: o2("common.cancel"), onClick: e2.onCloseDialog, fullWidth: true } }, classNames: { content: "oui-pb-4", body: "oui-p-0", footer: "oui-pt-3 oui-pb-0" }, children: jsx(Wo$2, { ...e2 }) })] });
};
var lr$1 = (e2) => {
  let { state: t, editAlgoOrder: r3, editOrder: o2, autoCheckInput: n4 = true, position: i } = e2, { item: a2 } = t, { hide: s2 } = j$3(), [d2, u2] = useState(false), l2 = (a2 == null ? void 0 : a2.algo_order_id) !== void 0 && a2.algo_type !== AlgoOrderRootType.BRACKET, f2 = (a2 == null ? void 0 : a2.type) === "MARKET" && l2;
  f2 || (a2 == null ? void 0 : a2.type) === "MARKET";
  let [C2, h2] = useState(false), p2 = useMemo(() => l2 && a2.algo_type !== AlgoOrderRootType.BRACKET ? `STOP_${a2.type}` : a2.type, [a2, l2]), [P2, N2] = useLocalStorage("orderly_order_confirm", true), { base_dp: T2, base_tick: q2 } = e2.state, { formattedOrder: g2, setValue: E3, markPrice: R2, errors: O2, validate: L2, maxQty: F3 } = Wa({ order: a2, orderType: p2, position: i }), X2 = () => {
    L2().then((b2) => {
      P2 ? u2(true) : D2(g2);
    }, (b2) => {
      var _a3;
      ((_a3 = b2 == null ? void 0 : b2.total) == null ? void 0 : _a3.message) && toast$2.error(b2 == null ? void 0 : b2.total.message);
    }).catch((b2) => {
    });
  }, v3 = useCallback(() => {
    u2(false);
  }, []), Y2 = () => g2 ? D2(g2) : Promise.reject(), A2 = useCallback(() => {
    s2();
  }, []), D2 = useCallback(async (b2) => {
    let B2, Ce3 = a2.visible_quantity !== void 0 ? a2.visible_quantity === 0 : a2.visible !== void 0 ? a2.visible === 0 : false;
    if (a2.algo_order_id !== void 0) {
      if (f2 && "order_price" in b2) {
        let { order_price: Te2, ...Lt2 } = b2;
        b2 = Lt2;
      }
      B2 = r3(a2.algo_order_id.toString(), { ...b2 });
    } else B2 = o2(a2.order_id.toString(), { ...b2, ...Ce3 ? { visible_quantity: 0 } : {} });
    try {
      h2(true);
      let Te2 = await B2;
      A2();
    } catch (Te2) {
      toast$2.error((Te2 == null ? void 0 : Te2.message) ?? `${Te2}`);
    } finally {
      h2(false);
    }
  }, [r3, o2]), re2 = useMemo(() => {
    let b2 = g2.order_quantity;
    return b2 && Number(b2) !== 0 && F3 !== 0 ? new g$6(b2).div(F3).mul(100).toDecimalPlaces(2, g$6.ROUND_DOWN).toNumber() : 0;
  }, [g2.order_quantity, F3]), de2 = a2.price != g2.order_price || a2.quantity != g2.order_quantity || a2.trigger_price != g2.trigger_price, Ge2 = useThrottledCallback((b2) => {
    let B2 = new g$6(b2).div(100).mul(F3).toDecimalPlaces(T2, g$6.ROUND_DOWN).toNumber();
    E3("order_quantity", utils_exports.formatNumber(B2, q2));
  }, 50, {}), y2 = (b2, B2) => {
    E3(b2, B2);
  };
  return { ...t, curMarkPrice: R2, isAlgoOrder: l2, isStopMarket: f2, price: g2.order_price, setPrice: (b2) => y2("order_price", b2), priceEdit: !f2, triggerPrice: g2.trigger_price, setTriggerPrice: (b2) => y2("trigger_price", b2), quantity: g2.order_quantity, setQuantity: (b2) => {
    y2("order_quantity", b2);
  }, maxQty: F3, sliderValue: re2, setSliderValue: Ge2, onClose: A2, onSheetConfirm: X2, errors: O2, orderType: p2, isChanged: de2, baseTick: q2, dialogOpen: d2, setDialogOpen: u2, onDialogConfirm: Y2, onCloseDialog: v3, submitting: C2, orderConfirm: P2, setOrderConfirm: N2 };
}, Wa = (e2) => {
  let { order: t, orderType: r3, position: o2 } = e2, [n4, i] = useState({ side: t.side, order_type: r3, order_price: t.price, order_quantity: t.quantity, trigger_price: t.trigger_price, reduce_only: t.reduce_only, symbol: t.symbol }), { reduce_only: a2 } = t, s2 = o2 == null ? void 0 : o2.position_qty, d2 = useMaxQty(t.symbol, t.side, t.reduce_only), u2 = useMemo(() => a2 ? Math.abs(s2 ?? 0) : t.quantity + Math.abs(d2), [t.quantity, d2, a2, s2]), { symbolInfo: l2, markPrice: f2, errors: x2, validate: C2 } = useOrderEntity({ ...n4, symbol: t.symbol }, { maxQty: u2 });
  return { symbolInfo: l2, markPrice: f2, errors: x2, validate: C2, setValue: (p2, P2) => {
    i((N2) => ({ ...N2, [p2]: P2 }));
  }, formattedOrder: n4, maxQty: u2 };
};
var dr$2 = (e2) => {
  let t = lr$1(e2);
  return jsx(nr$1, { ...t });
};
var ur$3 = (e2) => {
  let { state: t } = e2, { t: r3 } = ne$6(), { editAlgoOrder: o2, editOrder: n4 } = Z$2(), { order: i, position: a2 } = G$1(), s2 = useCallback(() => {
    e2.state.type === "tp_sl" ? vo$4.sheet({ title: r3("common.tpsl"), content: jsx(Lt$1, { isEditing: true, order: e2.state.item, position: a2, symbolInfo: e2.state.origin }) }).catch((d2) => {
    }) : vo$4.sheet({ title: r3("orders.editOrder"), classNames: { content: "oui-bg-base-8" }, content: jsx(dr$2, { position: a2, state: t, editAlgoOrder: o2, editOrder: n4 }) }).catch((d2) => {
    });
  }, [t]);
  return { ...t, onShowEditSheet: s2 };
};
var cr$1 = (e2) => {
  let t = ur$3(e2);
  return jsx(Zt$3, { ...t });
};
var pr$1 = (e2) => {
  let { t } = ne$6();
  return jsxs(Fragment$1, { children: [jsx($e$6, { variant: "outlined", fullWidth: true, color: "secondary", size: "sm", className: "oui-border-base-contrast-36", onClick: (r3) => e2.setOpen(true), children: t("common.cancel") }), e2.open && jsx(Se$5, { size: "xs", open: e2.open, onOpenChange: e2.setOpen, title: t("orders.cancelOrder"), actions: { primary: { label: t("common.confirm"), loading: e2.isLoading, fullWidth: true, size: "md", onClick: (r3) => {
    e2.onCancel(r3);
  } }, secondary: { label: t("common.cancel"), fullWidth: true, size: "md", onClick: () => {
    e2.onClose();
  } } }, children: jsx(Q$1, { size: "2xs", intensity: 54, children: t("orders.cancelOrder.description") }) })] });
};
var fr$3 = (e2) => {
  let { state: t } = e2, [r3, o2] = useState(false), { onCancelOrder: n4 } = Z$2(), [i, a2] = useState(false);
  return { ...t, open: r3, setOpen: o2, onCancel: (u2) => n4 ? (u2 == null ? void 0 : u2.preventDefault(), u2 == null ? void 0 : u2.stopPropagation(), a2(true), n4(t.item).then((l2) => {
    o2(false);
  }, (l2) => {
    toast$2.error(l2.message);
  }).finally(() => {
    a2(false);
  })) : Promise.resolve(), onClose: () => {
    o2(false);
  }, isLoading: i };
};
var gr$1 = (e2) => {
  let t = fr$3(e2);
  return jsx(pr$1, { ...t });
};
var br$3 = (e2) => {
  var _a3, _b2, _c2, _d3;
  let { t } = ne$6();
  return !e2.sl_trigger_price && !e2.tp_trigger_price ? jsx(Fragment$1, {}) : jsx(Fragment$1, { children: jsx(xt$2, { classNames: { content: "oui-bg-base-6 oui-ml-2", arrow: "oui-fill-base-6" }, content: jsxs(z$3, { direction: "column", itemAlign: "start", gap: 1, children: [typeof ((_a3 = e2.pnl) == null ? void 0 : _a3.tpPnL) < "u" && jsx(Q$1.numeral, { prefix: jsxs(Q$1, { intensity: 80, children: [`${t("tpsl.tpPnl")}:`, " "] }), suffix: jsx(Q$1, { intensity: 20, children: " USDC" }), dp: e2.quote_dp, color: "buy", showIdentifier: true, children: (_b2 = e2.pnl) == null ? void 0 : _b2.tpPnL }), typeof ((_c2 = e2.pnl) == null ? void 0 : _c2.slPnL) < "u" && jsx(Q$1.numeral, { prefix: jsxs(Q$1, { intensity: 80, children: [`${t("tpsl.slPnl")}:`, " "] }), suffix: jsx(Q$1, { intensity: 20, children: " USDC" }), dp: e2.quote_dp, color: "sell", children: (_d3 = e2.pnl) == null ? void 0 : _d3.slPnL })] }), children: jsx("button", { onClick: () => {
    e2.setOpen(!e2.open);
  }, children: jsxs(z$3, { gap: 1, width: "1", children: [e2.tp_trigger_price && jsx(Vo$2, { type: "TP", value: e2.tp_trigger_price, quote_dp: e2.quote_dp }), e2.sl_trigger_price && jsx(Vo$2, { type: "SL", value: e2.sl_trigger_price, quote_dp: e2.quote_dp })] }) }) }) });
}, Vo$2 = (e2) => {
  let { type: t, value: r3, quote_dp: o2 } = e2;
  return r3 ? jsx(Q$1.numeral, { size: "2xs", className: cnBase("oui-border-b oui-border-dashed oui-border-base-contrast-12", t === "TP" ? "oui-text-trade-profit" : "oui-text-trade-loss"), rule: "price", dp: o2, padding: false, rm: g$6.ROUND_DOWN, prefix: jsxs("span", { className: "oui-text-base-contrast-36", children: [`${t} `, ":"] }), children: r3 }, "tp") : jsx(Fragment$1, {});
};
var Pr$1 = (e2) => {
  let { item: t, quote_dp: r3, base_dp: o2 } = e2, [n4, i] = useState(false), { sl_trigger_price: a2, tp_trigger_price: s2 } = useMemo(() => !("algo_type" in t) || !Array.isArray(t.child_orders) ? {} : utils_exports.findTPSLFromOrder(t.child_orders[0]), [t]), { pnl: d2, roi: u2 } = ct(t);
  return { sl_trigger_price: a2, tp_trigger_price: s2, pnl: d2, roi: u2, quote_dp: r3, open: n4, setOpen: i };
};
var xr$1 = (e2) => {
  let t = Pr$1(e2);
  return jsx(br$3, { ...t });
};
var Sr$1 = (e2) => jsxs(z$3, { direction: "column", width: "100%", gap: 2, itemAlign: "start", className: e2.className, children: [jsx(ls, { ...e2 }), jsx(de$5, { intensity: 6, className: "oui-w-full" }), jsx(ds, { ...e2 }), e2.type === "pending" && jsx(xr$1, { ...e2 }), e2.type !== "orderHistory" && jsx(us, { ...e2 })] }), ls = (e2) => jsxs(z$3, { direction: "column", gap: 1, width: "100%", children: [jsxs(z$3, { justify: "between", width: "100%", children: [jsx(ho$3, { ...e2 }), jsx(To$1, { ...e2 })] }), jsxs(z$3, { width: "100%", justify: "between", children: [jsx(Co$2, { ...e2 }), e2.type === "orderHistory" && jsx(Lo$1, { ...e2 })] })] }), ds = (e2) => jsx(Sa$1, { cols: 3, rows: 2, width: "100%", gap: 1, children: cs(e2) }), us = (e2) => jsxs(Sa$1, { cols: 3, rows: 1, width: "100%", gap: 2, children: [jsx("div", {}), jsx(cr$1, { state: e2 }), jsx(gr$1, { state: e2 })] });
function cs(e2) {
  switch (e2.type) {
    case "all":
      return jsx(Fragment$1, {});
    case "pending":
      return jsxs(Fragment$1, { children: [jsx(Gt$2, { ...e2 }), jsx(Jt$2, { ...e2 }), jsx(No$1, { ...e2 }), jsx(Xt$2, { ...e2 }), jsx(Io$3, { ...e2 }), jsx(wo$1, { ...e2 })] });
    case "tp_sl":
      return jsxs(Fragment$1, { children: [jsx(Eo$1, { ...e2 }), jsx(Ao$2, { ...e2 }), jsx(Fo$1, { ...e2 }), jsx(vo$1, { ...e2 }), jsx(Do$1, { ...e2 })] });
    case "filled":
      return jsx(Fragment$1, {});
    case "cancelled":
      return jsx(Fragment$1, {});
    case "rejected":
      return jsx(Fragment$1, {});
    case "orderHistory":
      return jsxs(Fragment$1, { children: [jsx(Gt$2, { ...e2 }), jsx(Jt$2, { ...e2 }), jsx(Xt$2, { ...e2, align: "end" }), jsx(ko, { ...e2 }), jsx(qo$2, { ...e2 }), jsx(Ro$1, { ...e2 })] });
  }
}
var _r = (e2) => {
  let t = z$1();
  return { ...e2, ...t };
};
var Or$1 = (e2) => {
  let { className: t, ...r3 } = e2, o2 = _r(r3);
  return jsx(Sr$1, { ...o2, className: t });
};
var hr$1 = (e2) => {
  var _a3;
  let { sharePnLConfig: t, ...r3 } = e2, o2 = xo$1({ _type: e2.type, onSymbolChange: e2.onSymbolChange, pnlNotionalDecimalPrecision: e2.pnlNotionalDecimalPrecision, sharePnLConfig: t, symbolsInfo: e2.symbolsInfo });
  return jsx(Dt$4, { cancelOrder: e2.cancelOrder, editOrder: e2.updateOrder, cancelAlgoOrder: e2.cancelAlgoOrder, editAlgoOrder: e2.updateAlgoOrder, children: jsxs(z$3, { direction: "column", width: "100%", height: "100%", itemAlign: "start", children: [e2.filterItems.length > 0 && jsx(n0, { items: e2.filterItems, onFilter: (n4) => {
    e2.onFilter(n4);
  }, trailing: ["pending", "tp_sl"].includes(e2.type) && jsx(_s, { ...e2 }) }), jsx(dt$3, { columns: o2, loading: e2.isLoading, dataSource: e2.dataSource, bordered: true, ignoreLoadingCheck: true, testIds: { body: (_a3 = e2.testIds) == null ? void 0 : _a3.tableBody }, classNames: { header: "oui-h-[38px]", root: "oui-items-start !oui-h-[calc(100%_-_49px)]" }, onRow: (n4, i) => ({ className: cnBase("oui-h-[48px]", ne$2(n4) ? "oui-text-base-contrast-20" : "oui-text-base-contrast-80") }), generatedRowKey: (n4, i) => `${e2.type}${i}${n4.order_id || n4.algo_order_id}_index${i}`, renderRowContainer: (n4, i, a2) => ((e2.type === "tp_sl" || e2.type === "pending") && (a2 = jsx(qt$2, { order: n4, children: a2 })), jsx(Ft$3, { symbol: n4.symbol, children: a2 })), pagination: e2.pagination, manualPagination: e2.manualPagination, features: [Fl.DownloadFeature], getTableInstance: (n4) => {
    e2.tableInstance.current = n4;
  } })] }) });
}, Cr = (e2) => {
  var _a3, _b2;
  let { t } = ne$6();
  return jsx(Dt$4, { cancelOrder: e2.cancelOrder, editOrder: e2.updateOrder, cancelAlgoOrder: e2.cancelAlgoOrder, editAlgoOrder: e2.updateAlgoOrder, children: jsxs(Sa$1, { cols: 1, rows: 2, className: "oui-w-full oui-grid-rows-[auto,1fr]", gap: 2, children: [e2.showFilter ? jsx(z$3, { gap: 2, p: 2, className: "oui-rounded-b-xl oui-bg-base-9", children: e2.filterItems.map((r3) => r3.type !== "select" ? jsx(Fragment$1, {}) : jsx(Oi$2, { options: r3.options, size: "sm", value: r3.value, className: "oui-text-2xs oui-text-base-contrast-54 ", placeholder: r3.name === "side" ? t("common.side.all") : r3.name === "status" ? t("common.status.all") : "", onValueChange: (o2) => {
    var _a4;
    (_a4 = e2.onFilter) == null ? void 0 : _a4.call(e2, { name: r3.name, value: o2 });
  } }, r3.name)) }) : jsx("div", {}), jsx(og$1, { className: (_a3 = e2.classNames) == null ? void 0 : _a3.root, contentClassName: (_b2 = e2.classNames) == null ? void 0 : _b2.content, dataSource: e2.dataSource, loadMore: e2.loadMore, isLoading: e2.isLoading, renderItem: (r3, o2) => {
    var _a4;
    let n4 = jsx(Or$1, { item: r3, index: o2, className: (_a4 = e2.classNames) == null ? void 0 : _a4.cell, type: e2.type, onSymbolChange: e2.onSymbolChange, sharePnLConfig: e2.sharePnLConfig });
    return ["tp_sl", "pending"].includes(e2.type) && (n4 = jsx(qt$2, { order: r3, children: n4 })), jsx(Ft$3, { symbol: r3.symbol, children: n4 });
  } })] }) });
}, _s = (e2) => {
  var _a3;
  let { t } = ne$6();
  return jsx($e$6, { variant: "outlined", color: "secondary", size: "xs", disabled: (((_a3 = e2.dataSource) == null ? void 0 : _a3.length) ?? 0) == 0, className: "disabled:oui-bg-transport", onClick: (r3) => e2.onCancelAll(), "data-testid": `oui-testid-dataList-${e2.type.toLowerCase()}-cancelAll-button`, children: t("orders.cancelAll") });
};
var jo = (e2) => useMemo(() => {
  let r3 = [];
  for (let o2 = 0; o2 < e2.length; o2++) {
    let n4 = e2[o2];
    if (n4.algo_type === AlgoOrderRootType.POSITIONAL_TP_SL || n4.algo_type === AlgoOrderRootType.TP_SL) if (n4.algo_status !== OrderStatus.FILLED && n4.algo_status !== OrderStatus.PARTIAL_FILLED) for (let i = 0; i < n4.child_orders.length; i++) {
      let a2 = n4.child_orders[i];
      !a2.is_activated || !a2.trigger_price || (a2.parent_algo_type = n4.algo_type, r3.push(a2));
    }
    else for (let i = 0; i < n4.child_orders.length; i++) {
      let a2 = n4.child_orders[i];
      a2 && (a2.algo_status === OrderStatus.FILLED || a2.algo_status === OrderStatus.PARTIAL_FILLED) && (a2.parent_algo_type = n4.algo_type, r3.push(a2));
    }
    else r3.push(n4);
  }
  return r3;
}, [e2]);
var Tt = (e2) => {
  let { ordersStatus: t, type: r3, enableLoadMore: o2 = false, onSymbolChange: n4, filterConfig: i, pnlNotionalDecimalPrecision: a2, sharePnLConfig: s2 } = e2, { t: d2 } = ne$6(), u2 = useSymbolsInfo(), l2 = useMemo(() => t !== OrderStatus.INCOMPLETE, [t]), f2 = 50, { page: x2, pageSize: C2, setPage: h2, pagination: p2, parsePagination: P2 } = p0({ pageSize: f2 });
  useEffect(() => {
    h2(1);
  }, [e2.symbol]);
  let { orderStatus: N2, ordersSide: T2, dateRange: q2, filterItems: g2, onFilter: E3, filterDays: W2, updateFilterDays: R2 } = qs(r3, { ordersStatus: t, setPage: h2, filterConfig: i }), O2 = useMemo(() => {
    if (r3 === "tp_sl") return [AlgoOrderRootType.POSITIONAL_TP_SL, AlgoOrderRootType.TP_SL];
  }, [r3]), L2 = useMemo(() => {
    if (r3 === "pending") return [AlgoOrderRootType.POSITIONAL_TP_SL, AlgoOrderRootType.TP_SL];
  }, [r3]), F3 = useRef();
  useImperativeHandle(e2.ref, () => ({ download: () => {
    var _a3;
    let Nt2 = `orders_${format(/* @__PURE__ */ new Date(), "yyyyMMdd_HHmmss")}`;
    (_a3 = F3.current) == null ? void 0 : _a3.download(Nt2);
  } }));
  let [X2, { isLoading: v3, loadMore: Y2, cancelOrder: A2, updateOrder: D2, cancelAlgoOrder: re2, updateAlgoOrder: de2, cancelAllOrders: Ge2, cancelAllTPSLOrders: y2, meta: b2, refresh: B2 }] = useOrderStream({ symbol: e2.symbol, status: N2, side: T2, page: o2 || !l2 ? void 0 : x2, size: l2 ? C2 : 500, dateRange: q2, includes: O2, excludes: L2 }), Ce3 = `orderly_${r3}_pageSize`, [Te2, Lt2] = useLocalStorage(Ce3, f2);
  useEffect(() => {
    Te2 !== C2 && Lt2(C2);
  }, [C2, Te2]);
  let nn2 = useCallback(() => {
    let Nt2 = e2.type === "pending" ? d2("orders.pending.cancelAll") : e2.type === "tp_sl" ? d2("orders.tpsl.cancelAll") : "", dn2 = d2("orders.pending.cancelAll.description");
    vo$4.confirm({ title: Nt2, content: jsx(Q$1, { size: "sm", children: dn2 }), onCancel: async () => {
    }, onOk: async () => {
      try {
        return r3 === "tp_sl" ? await y2() : await Ge2(), B2(), Promise.resolve(true);
      } catch (Lr2) {
        return (Lr2 == null ? void 0 : Lr2.message) !== void 0 && toast.error(Lr2.message), Promise.resolve(false);
      } finally {
        Promise.resolve();
      }
    } });
  }, [r3, d2]), an2 = jo(X2 ?? []), sn2 = Tr$2(r3 !== "tp_sl" ? an2 : X2, { fallbackData: [] }) ?? void 0, ln2 = useMemo(() => l2 ? P2(b2) : p2, [b2, l2, P2, p2]);
  return { type: r3, dataSource: sn2, isLoading: v3, loadMore: Y2, cancelOrder: A2, updateOrder: D2, cancelAlgoOrder: re2, updateAlgoOrder: de2, pagination: ln2, manualPagination: l2, pnlNotionalDecimalPrecision: a2, onFilter: E3, filterItems: g2, onCancelAll: nn2, onSymbolChange: n4, sharePnLConfig: s2, tableInstance: F3, symbolsInfo: u2, filterDays: W2, updateFilterDays: R2 };
}, qs = (e2, t) => {
  var _a3, _b2;
  let { t: r3 } = ne$6(), [o2, n4] = useState(t.ordersStatus ?? "all"), [i, a2] = useState(((_a3 = t.filterConfig) == null ? void 0 : _a3.side) ?? "all"), [s2, d2] = useState(90), u2 = ((_b2 = t.filterConfig) == null ? void 0 : _b2.range) ?? (e2 === "all" || e2 === "orderHistory" ? Tr$1({ to: /* @__PURE__ */ new Date(), from: Fe$1(subDays(/* @__PURE__ */ new Date(), 89)) }) : {}), [l2, f2] = useState(u2), x2 = (p2) => {
    d2(p2), f2({ from: Ve$1(subDays(/* @__PURE__ */ new Date(), p2 - 1)), to: Fe$1(/* @__PURE__ */ new Date()) }), t.setPage(1);
  }, C2 = (p2) => {
    if (p2.name === "side" && (a2(p2.value), t.setPage(1)), p2.name === "status" && (n4(p2.value), t.setPage(1)), p2.name === "dateRange") {
      f2(Tr$1(p2.value)), t.setPage(1);
      let P2 = Tr$1(p2.value);
      if (P2.from && P2.to) {
        let N2 = Math.abs(differenceInDays(P2.from, P2.to)) + 1, q2 = { 1: { from: Ve$1(/* @__PURE__ */ new Date()), to: Fe$1(/* @__PURE__ */ new Date()) }, 7: { from: Ve$1(subDays(/* @__PURE__ */ new Date(), 6)), to: Fe$1(/* @__PURE__ */ new Date()) }, 30: { from: Ve$1(subDays(/* @__PURE__ */ new Date(), 29)), to: Fe$1(/* @__PURE__ */ new Date()) }, 90: { from: Ve$1(subDays(/* @__PURE__ */ new Date(), 89)), to: Fe$1(/* @__PURE__ */ new Date()) } }[N2];
        q2 && It$1(q2.from, P2.from) && It$1(q2.to, P2.to) ? d2(N2) : d2(null);
      }
    }
  };
  return { filterItems: useMemo(() => {
    let p2 = { type: "select", name: "side", options: [{ label: r3("common.side.all"), value: "all" }, { label: r3("common.buy"), value: "BUY" }, { label: r3("common.sell"), value: "SELL" }], value: i }, P2 = { type: "range", name: "dateRange", value: l2 }, N2 = { type: "select", name: "status", options: [{ label: r3("common.status.all"), value: "all" }, { label: r3("orders.status.pending"), value: OrderStatus.INCOMPLETE }, { label: r3("orders.status.filled"), value: OrderStatus.FILLED }, { label: r3("orders.status.partialFilled"), value: OrderStatus.PARTIAL_FILLED }, { label: r3("orders.status.canceled"), value: OrderStatus.CANCELLED }, { label: r3("orders.status.rejected"), value: OrderStatus.REJECTED }], value: o2 };
    switch (e2) {
      case "all":
        return [p2, N2, P2];
      case "pending":
        return [p2];
      case "tp_sl":
        return [p2];
      case "filled":
        return [p2];
      case "cancelled":
        return [p2];
      case "rejected":
        return [p2];
      case "orderHistory":
        return [p2, N2, P2];
    }
  }, [e2, i, o2, l2, r3]), onFilter: C2, ordersSide: i === "all" ? void 0 : i, dateRange: l2, orderStatus: o2 === "all" ? void 0 : o2, filterDays: s2, updateFilterDays: x2 };
};
function Ve$1(e2) {
  if (e2 == null) return e2;
  let t = new Date(e2);
  return t.setHours(0, 0, 0, 0), t;
}
function Fe$1(e2) {
  if (e2 == null) return e2;
  let t = new Date(e2);
  return t.setHours(23, 59, 59, 999), t;
}
var Tr$1 = (e2) => ({ from: Ve$1(e2.from), to: Fe$1(e2.to ?? e2.from) });
var he$1 = forwardRef((e2, t) => {
  let { testIds: r3, ...o2 } = e2, n4 = Tt({ ...o2, ref: t });
  return jsx(hr$1, { ...n4, testIds: r3 });
}), Ms = (e2) => {
  let t = Tt({ ...e2, enableLoadMore: true });
  return jsx(Cr, { ...t, classNames: e2.classNames, showFilter: e2.showFilter });
};
var on = (e2) => {
  let { t } = ne$6(), r3 = { pnlNotionalDecimalPrecision: e2.pnlNotionalDecimalPrecision };
  return jsxs(jl, { defaultValue: e2.current || "all", variant: "contained", className: "oui-h-full", classNames: { tabsContent: "oui-h-[calc(100%_-_28px)]" }, children: [jsx($l, { value: "all", title: t("common.all"), children: jsx(he$1, { ref: e2.orderListRef, type: "all", pnlNotionalDecimalPrecision: e2.pnlNotionalDecimalPrecision, sharePnLConfig: e2.sharePnLConfig, ...r3 }) }), jsx($l, { value: "pending", title: t("orders.status.pending"), children: jsx(he$1, { ref: e2.orderListRef, type: "pending", ordersStatus: OrderStatus.INCOMPLETE, ...r3 }) }), jsx($l, { value: "tp_sl", title: t("common.tpsl"), children: jsx(he$1, { ref: e2.orderListRef, type: "tp_sl", ordersStatus: OrderStatus.INCOMPLETE, ...r3 }) }), jsx($l, { value: "filled", title: t("orders.status.filled"), children: jsx(he$1, { ref: e2.orderListRef, type: "filled", ordersStatus: OrderStatus.FILLED, pnlNotionalDecimalPrecision: e2.pnlNotionalDecimalPrecision, sharePnLConfig: e2.sharePnLConfig, ...r3 }) }), jsx($l, { value: "cancelled", title: t("orders.status.canceled"), children: jsx(he$1, { ref: e2.orderListRef, type: "cancelled", ordersStatus: OrderStatus.CANCELLED, ...r3 }) }), jsx($l, { value: "rejected", title: t("orders.status.rejected"), children: jsx(he$1, { ref: e2.orderListRef, type: "rejected", ordersStatus: OrderStatus.REJECTED, ...r3 }) })] });
};
var Pe = ((s2) => (s2.all = "all", s2.pending = "pending", s2.tp_sl = "tp_sl", s2.filled = "filled", s2.cancelled = "cancelled", s2.rejected = "rejected", s2.orderHistory = "orderHistory", s2))(Pe || {}), Ks = forwardRef((e2, t) => {
  let r3 = wt$1({ ...e2, ref: t });
  return jsx(on, { ...r3 });
});
const { isNumber } = ((_o2 = (_n2 = __cjsInterop1__$2) == null ? void 0 : _n2.default) == null ? void 0 : _o2.__esModule) ? __cjsInterop1__$2.default : __cjsInterop1__$2;
var ra = Object.defineProperty;
var le$2 = (e2, t) => {
  for (var o2 in t) ra(e2, o2, { get: t[o2], enumerable: true });
};
var ut$1 = ((n4) => (n4.Overview = "/portfolio", n4.Positions = "/portfolio/positions", n4.Orders = "/portfolio/orders", n4.FeeTier = "/portfolio/feeTier", n4.ApiKey = "/portfolio/apiKey", n4.Setting = "/portfolio/setting", n4.History = "/portfolio/history", n4))(ut$1 || {}), Qt$3 = (e2) => {
  let { routerAdapter: t } = Le$4(), [o2, i] = useState(e2.current ?? (t == null ? void 0 : t.currentPath) ?? "/portfolio"), { t: r3 } = ne$6();
  useEffect(() => {
    (o2 || (t == null ? void 0 : t.currentPath)) && i(o2 || (t == null ? void 0 : t.currentPath) || "/portfolio");
  }, [o2, t == null ? void 0 : t.currentPath]);
  let a2 = useMemo(() => [{ name: r3("common.overview"), href: "/portfolio", icon: jsx("svg", { width: "18", height: "18", viewBox: "0 0 18 18", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: jsx("path", { d: "M5.24316 2.19727C3.58641 2.19727 2.24316 3.54044 2.24316 5.19727V12.6973C2.24316 14.3541 3.58641 15.6973 5.24316 15.6973H12.7432C14.3999 15.6973 15.7432 14.3541 15.7432 12.6973V5.19727C15.7432 3.54044 14.3999 2.19727 12.7432 2.19727H5.24316ZM5.24316 3.69727H12.7432C13.5719 3.69727 14.2432 4.36882 14.2432 5.19727V12.6973C14.2432 13.2484 13.9319 13.734 13.4894 13.9947C13.3454 12.2235 11.4427 11.1973 8.99316 11.1973C6.54366 11.1973 4.60341 12.251 4.48566 13.9997C4.04241 13.739 3.74316 13.2484 3.74316 12.6973V5.19727C3.74316 4.36882 4.41441 3.69727 5.24316 3.69727ZM8.99316 5.19727C7.54341 5.19727 6.36816 6.37252 6.36816 7.82227C6.36816 9.27202 7.54341 10.4473 8.99316 10.4473C10.4429 10.4473 11.6182 9.27202 11.6182 7.82227C11.6182 6.37252 10.4429 5.19727 8.99316 5.19727Z", className: "oui-fill-current group-data-[actived=true]:oui-fill-[url(#side-menu-gradient)]" }) }) }, { name: r3("common.positions"), href: "/portfolio/positions", icon: jsx("svg", { width: "18", height: "18", viewBox: "0 0 18 18", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: jsx("path", { d: "M4.51 3.021a3 3 0 0 0-3 3v6a3 3 0 0 0 3 3h9a3 3 0 0 0 3-3v-6a3 3 0 0 0-3-3zm2.25 3a.76.76 0 0 1 .54.211.77.77 0 0 1 0 1.078l-.75.75a.77.77 0 0 1-.54.211h-.75a.75.75 0 0 1 0-1.5h.422l.54-.539a.76.76 0 0 1 .539-.21m3 .75h3a.75.75 0 0 1 0 1.5h-3a.75.75 0 0 1 0-1.5m-3 2.25a.76.76 0 0 1 .54.211.77.77 0 0 1 0 1.079l-.75.75a.77.77 0 0 1-.54.21h-.75a.75.75 0 0 1 0-1.5h.422l.54-.539a.76.76 0 0 1 .539-.21m3 .75h3a.75.75 0 0 1 0 1.5h-3a.75.75 0 0 1 0-1.5", className: "oui-fill-current group-data-[actived=true]:oui-fill-[url(#side-menu-gradient)]" }) }) }, { name: r3("common.orders"), href: "/portfolio/orders", icon: jsx("svg", { width: "18", height: "18", viewBox: "0 0 18 18", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: jsx("path", { d: "M5.693 1.5C4.229 1.5 3.02 2.61 3.02 4.006v9.984c0 1.398 1.208 2.508 2.672 2.508h6.657c1.463 0 2.671-1.11 2.671-2.508V6.726c0-2.672-2.579-5.227-5.25-5.227zm4.828 1.593c1.33.352 2.562 1.58 2.906 2.906h-1.734c-.667 0-1.172-.472-1.172-1.008zm-3.75 2.906h.75a.75.75 0 0 1 0 1.5h-.75a.75.75 0 0 1 0-1.5m0 3h4.5a.75.75 0 0 1 0 1.5h-4.5a.75.75 0 0 1 0-1.5m0 3h4.5a.75.75 0 0 1 0 1.5h-4.5a.75.75 0 0 1 0-1.5", className: "oui-fill-current group-data-[actived=true]:oui-fill-[url(#side-menu-gradient)]" }) }) }, { name: r3("portfolio.feeTier"), href: "/portfolio/feeTier", icon: jsx("svg", { width: "18", height: "18", viewBox: "0 0 18 18", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: jsx("path", { d: "M5.99829 1.51062C4.34154 1.51062 2.99829 2.85387 2.99829 4.51062V13.5106C2.99829 15.1674 4.34154 16.5106 5.99829 16.5106H11.9983C13.655 16.5106 14.9983 15.1674 14.9983 13.5106V4.51062C14.9983 2.85387 13.655 1.51062 11.9983 1.51062H5.99829ZM5.99829 3.76062H11.9983C12.4123 3.76062 12.7483 4.09662 12.7483 4.51062V6.01062C12.7483 6.42462 12.4123 6.76062 11.9983 6.76062H5.99829C5.58429 6.76062 5.24829 6.42462 5.24829 6.01062V4.51062C5.24829 4.09662 5.58429 3.76062 5.99829 3.76062ZM5.99829 8.26062C6.41229 8.26062 6.74829 8.59662 6.74829 9.01062C6.74829 9.42462 6.41229 9.76062 5.99829 9.76062C5.58429 9.76062 5.24829 9.42462 5.24829 9.01062C5.24829 8.59662 5.58429 8.26062 5.99829 8.26062ZM8.99829 8.26062C9.41229 8.26062 9.74829 8.59662 9.74829 9.01062C9.74829 9.42462 9.41229 9.76062 8.99829 9.76062C8.58429 9.76062 8.24829 9.42462 8.24829 9.01062C8.24829 8.59662 8.58429 8.26062 8.99829 8.26062ZM11.9983 8.26062C12.4123 8.26062 12.7483 8.59662 12.7483 9.01062C12.7483 9.42462 12.4123 9.76062 11.9983 9.76062C11.5843 9.76062 11.2483 9.42462 11.2483 9.01062C11.2483 8.59662 11.5843 8.26062 11.9983 8.26062ZM5.99829 10.5106C6.41229 10.5106 6.74829 10.8466 6.74829 11.2606C6.74829 11.6746 6.41229 12.0106 5.99829 12.0106C5.58429 12.0106 5.24829 11.6746 5.24829 11.2606C5.24829 10.8466 5.58429 10.5106 5.99829 10.5106ZM8.99829 10.5106C9.41229 10.5106 9.74829 10.8466 9.74829 11.2606C9.74829 11.6746 9.41229 12.0106 8.99829 12.0106C8.58429 12.0106 8.24829 11.6746 8.24829 11.2606C8.24829 10.8466 8.58429 10.5106 8.99829 10.5106ZM11.9983 10.5106C12.4123 10.5106 12.7483 10.8466 12.7483 11.2606V13.5106C12.7483 13.9246 12.4123 14.2606 11.9983 14.2606C11.5843 14.2606 11.2483 13.9246 11.2483 13.5106V11.2606C11.2483 10.8466 11.5843 10.5106 11.9983 10.5106ZM5.99829 12.7606C6.41229 12.7606 6.74829 13.0966 6.74829 13.5106C6.74829 13.9246 6.41229 14.2606 5.99829 14.2606C5.58429 14.2606 5.24829 13.9246 5.24829 13.5106C5.24829 13.0966 5.58429 12.7606 5.99829 12.7606ZM8.99829 12.7606C9.41229 12.7606 9.74829 13.0966 9.74829 13.5106C9.74829 13.9246 9.41229 14.2606 8.99829 14.2606C8.58429 14.2606 8.24829 13.9246 8.24829 13.5106C8.24829 13.0966 8.58429 12.7606 8.99829 12.7606Z", className: "oui-fill-current group-data-[actived=true]:oui-fill-[url(#side-menu-gradient)]" }) }) }, { name: r3("portfolio.apiKeys"), href: "/portfolio/apiKey", icon: jsx("svg", { width: "18", height: "18", viewBox: "0 0 18 18", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: jsx("path", { d: "M9.02124 1.49915C7.77849 1.49915 6.77124 2.5064 6.77124 3.74915C6.77124 4.70015 7.40049 5.55517 8.26974 5.86942L8.27124 8.24915H5.27124C4.85724 8.24915 4.52124 8.58515 4.52124 8.99915L4.52048 12.1304C3.65723 12.4274 3.02124 13.2981 3.02124 14.2491C3.02124 15.4919 4.02849 16.4991 5.27124 16.4991C6.51399 16.4991 7.52124 15.4919 7.52124 14.2491C7.52124 13.2981 6.92499 12.4596 6.02949 12.1206L6.02124 9.74915H9.02124H12.0212L12.0265 12.1319C11.1257 12.4446 10.5212 13.2981 10.5212 14.2491C10.5212 15.4919 11.5285 16.4991 12.7712 16.4991C14.014 16.4991 15.0212 15.4919 15.0212 14.2491C15.0212 13.2981 14.407 12.4611 13.5272 12.1281L13.5212 8.99915C13.5212 8.58515 13.1852 8.24915 12.7712 8.24915H9.77124L9.76899 5.86639C10.642 5.55814 11.2712 4.70015 11.2712 3.74915C11.2712 2.5064 10.264 1.49915 9.02124 1.49915Z", className: "oui-fill-current group-data-[actived=true]:oui-fill-[url(#side-menu-gradient)]" }) }) }, { name: r3("portfolio.setting"), href: "/portfolio/setting", icon: jsx("svg", { width: "18", height: "18", viewBox: "0 0 18 18", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: jsx("path", { d: "M6.72601 1.84159C5.66251 2.17834 4.74527 2.7296 3.93677 3.48185C3.68702 3.7151 3.61052 4.09534 3.77252 4.39609C4.37327 5.50684 3.74476 6.69484 2.39026 6.76309C2.05801 6.78034 1.76477 7.02559 1.68677 7.34884C1.55252 7.90759 1.49927 8.37559 1.49927 8.98984C1.49927 9.50509 1.55476 10.0878 1.66351 10.6068C1.73101 10.9308 2.01302 11.1641 2.34302 11.1933C3.70652 11.3111 4.38152 12.3506 3.77252 13.6773C3.63752 13.9721 3.69902 14.3246 3.93677 14.5443C4.73327 15.2816 5.64826 15.8006 6.72601 16.1381C7.03351 16.2348 7.38076 16.1186 7.56976 15.8568C8.40376 14.7033 9.61352 14.6988 10.4055 15.8568C10.5923 16.1298 10.9343 16.2611 11.2493 16.1613C12.2895 15.8343 13.2585 15.2771 14.0618 14.5443C14.3093 14.3193 14.3745 13.9541 14.226 13.6541C13.602 12.3948 14.3198 11.2383 15.6083 11.2166C15.9503 11.2106 16.2548 10.9856 16.335 10.6541C16.4648 10.1163 16.4993 9.64759 16.4993 8.98984C16.4993 8.42434 16.4325 7.86709 16.3118 7.32559C16.2353 6.98359 15.936 6.74059 15.585 6.73984C14.3168 6.73759 13.6058 5.49109 14.226 4.39609C14.3985 4.09084 14.3445 3.71735 14.085 3.48185C13.2675 2.73935 12.2708 2.15959 11.226 1.84159C10.905 1.74409 10.5638 1.86409 10.3823 2.14609C9.65776 3.27109 8.30477 3.29135 7.59302 2.16935C7.41077 1.8821 7.05001 1.73809 6.72601 1.84159ZM8.99927 5.98984C10.656 5.98984 11.9993 7.33309 11.9993 8.98984C11.9993 10.6466 10.656 11.9898 8.99927 11.9898C7.34252 11.9898 5.99927 10.6466 5.99927 8.98984C5.99927 7.33309 7.34252 5.98984 8.99927 5.98984Z", className: "oui-fill-current group-data-[actived=true]:oui-fill-[url(#side-menu-gradient)]" }) }) }, { name: r3("trading.history"), href: "/portfolio/history", hide: true }], [r3]), s2 = useMediaQuery("(max-width: 768px)");
  return { items: a2, current: o2, hideSideBar: s2, onItemSelect: (n4) => {
    typeof n4.href > "u" || (i(n4.href), t == null ? void 0 : t.onRouteChange({ href: n4.href, name: n4.name }));
  } };
};
var jt$1 = (e2) => {
  var _a3;
  let { children: t, leftSideProps: o2, classNames: i, ...r3 } = e2;
  return jsx(Sn$1, { leftSidebar: e2.hideSideBar ? null : jsx(ga$1, { current: (_a3 = e2.routerAdapter) == null ? void 0 : _a3.currentPath, routerAdapter: e2.routerAdapter, items: e2.items, ...o2 }), routerAdapter: e2.routerAdapter, classNames: { ...i, content: cnBase("oui-my-6 oui-px-3", i == null ? void 0 : i.content), topNavbar: cnBase("oui-bg-base-9", i == null ? void 0 : i.topNavbar), leftSidebar: cnBase("oui-rounded-xl oui-bg-base-9", "oui-m-3 oui-p-4", "oui-border oui-border-line", i == null ? void 0 : i.leftSidebar) }, ...r3, children: t });
}, ga$1 = (e2) => {
  let { expanded: t, setExpand: o2 } = Le$4(), { t: i } = ne$6();
  return jsx(Re$5, { title: i("common.portfolio"), ...e2, open: t, onOpenChange: (r3) => o2(r3), onItemSelect: (r3) => {
    var _a3, _b2, _c2;
    (_a3 = e2.onItemSelect) == null ? void 0 : _a3.call(e2, r3), (_c2 = (_b2 = e2.routerAdapter) == null ? void 0 : _b2.onRouteChange) == null ? void 0 : _c2.call(_b2, { href: r3.href || "", name: r3.name });
  } });
};
var qo$1 = createContext({ sideOpen: true }), Yo$2 = () => useContext(qo$1), Qo$1 = (e2) => {
  let [t, o2] = useState(true);
  return jsx(qo$1.Provider, { value: { sideOpen: t, onSideOpenChange: o2, routerAdapter: e2.routerAdapter }, children: e2.children });
};
var Xo$1 = (e2) => {
  var _a3, _b2;
  return jsx(Qo$1, { ...e2, children: jsxs(z$3, { direction: "column", width: "100%", height: "100%", className: "oui-h-full-screen oui-bg-base-10", children: [jsx("header", { className: "oui-sticky oui-top-0 oui-z-10 oui-w-full oui-bg-base-10", children: jsx(Vt$3, { ...e2.mainNavProps, current: e2 == null ? void 0 : e2.current, subItems: e2 == null ? void 0 : e2.items, routerAdapter: e2.routerAdapter }) }), jsx(W$2, { className: "oui-min-h-[calc(100vh-44px-64px-env(safe-area-inset-bottom))] oui-w-full", children: e2.children }), jsx("footer", { className: "oui-sticky oui-bottom-0 oui-z-10 oui-w-full oui-bg-base-9 oui-pb-[calc(env(safe-area-inset-bottom))]", children: jsx(ue$5, { mainMenus: (_a3 = e2.bottomNavProps) == null ? void 0 : _a3.mainMenus, current: e2 == null ? void 0 : e2.current, onRouteChange: (_b2 = e2.routerAdapter) == null ? void 0 : _b2.onRouteChange }) })] }) });
};
var Aa = (e2) => {
  var _a3;
  let t = Qt$3({ current: (_a3 = e2.leftSideProps) == null ? void 0 : _a3.current }), { isMobile: o2 } = it$6();
  return jsx(Fragment$1, { children: o2 ? jsx(Xo$1, { ...t, ...e2 }) : jsx(jt$1, { ...t, ...e2 }) });
};
var Qi = {};
le$2(Qi, { AssetHistory: () => Ue$1, AssetHistoryWidget: () => ue$1, AssetWidget: () => We$3, AssetsChartWidget: () => wt, AssetsUI: () => Ke$3, DistributionHistoryDesktop: () => Ye$1, DistributionHistoryMobile: () => qe$2, DistributionHistoryWidget: () => pe, FundingHistoryWidget: () => ce$3, HistoryDataGroupWidget: () => oe$1, OverviewContextProvider: () => ht$1, OverviewPage: () => Yi, PerformanceUI: () => Qe$3, PerformanceWidget: () => je$2, useAssetHistoryColumns: () => Oe, useAssetHistoryHook: () => Be$3, useAssetsLineChartScript: () => Ct$2, useFundingHistoryColumns: () => $e$2, useFundingHistoryHook: () => Ze$2, usePerformanceScript: () => Je$2 });
var Me$1 = () => {
  let { connect: e2, namespace: t } = useWalletConnector(), { state: o2 } = useAccount(), { totalValue: i, freeCollateral: r3 } = useCollateral(), { wrongNetwork: a2, disabledConnect: s2 } = L$3(), [n4] = usePositionStream(), { curLeverage: u2 } = useLeverage(), [l2, c] = useLocalStorage("orderly_assets_visible", true), { isMobile: g2 } = it$6(), y2 = g2 ? Xr$1 : Hr$4, m2 = useMemo(() => !a2 && !s2 && (o2.status === AccountStatusEnum.EnableTrading || o2.status === AccountStatusEnum.EnableTradingWithoutConnected), [o2.status, a2, s2]), d2 = () => {
    vo$4.show(re$3);
  }, p2 = useCallback(() => {
    vo$4.show(y2, { activeTab: "deposit" });
  }, [y2]), D2 = () => {
    vo$4.show(y2, { activeTab: "withdraw" });
  };
  return { canTrade: m2, connect: e2, portfolioValue: i, freeCollateral: r3, unrealPnL: n4.aggregated.total_unreal_pnl, unrealROI: n4.totalUnrealizedROI, currentLeverage: u2, onLeverageEdit: d2, visible: l2, wrongNetwork: a2, toggleVisible: () => c(!l2), onDeposit: p2, onWithdraw: D2, namespace: t };
};
var oi$1 = (e2) => {
  let { t } = ne$6();
  return jsxs(z$3, { justify: "between", children: [jsx(ur$4, { children: t("common.overview") }), jsxs(z$3, { gap: 3, children: [jsx($e$6, { disabled: e2.disabled, size: "md", color: "secondary", onClick: () => {
    var _a3;
    return (_a3 = e2.onWithdraw) == null ? void 0 : _a3.call(e2);
  }, icon: jsx(yn$1, {}), "data-testid": "oui-testid-portfolio-assets-withdraw-btn", children: t("common.withdraw") }), jsx($e$6, { disabled: e2.disabled, size: "md", onClick: () => {
    var _a3;
    return (_a3 = e2.onDeposit) == null ? void 0 : _a3.call(e2);
  }, icon: jsx(Pn$1, {}), "data-testid": "oui-testid-portfolio-assets-deposit-btn", children: t("common.deposit") })] })] });
};
var Ke$3 = (e2) => {
  let { t } = ne$6();
  return jsx(Kl, { classNames: { footer: "oui-h-[48px]", root: "oui-h-[240px]" }, title: jsx(oi$1, { disabled: !e2.canTrade, onDeposit: e2.onDeposit, onWithdraw: e2.onWithdraw }), children: jsxs(Fragment$1, { children: [jsx(za$1, { label: jsxs(z$3, { gap: 1, children: [jsx(Q$1, { intensity: 54, children: t("common.totalValue") }), jsx("button", { onClick: () => {
    e2.toggleVisible();
  }, "data-testid": "oui-testid-portfolio-assets-eye-btn", children: e2.visible ? jsx(Nn$2, { size: 16, color: "white" }) : jsx(zn$1, { size: 16, color: "white" }) })] }), children: jsx(wg$1, { value: e2.canTrade, left: jsx(en$1, {}), children: jsx(Q$1.numeral, { visible: e2.visible, unit: "USDC", style: { "--oui-gradient-angle": "45deg" }, unitClassName: "oui-text-base oui-text-base-contrast-80 oui-h-9 oui-ml-1", className: jn$2({ className: "oui-font-bold oui-text-3xl", color: "brand" }), children: e2.portfolioValue ?? "--" }) }) }), jsx(de$5, { className: "oui-my-4", intensity: 8 }), jsx(S, { buttonProps: { size: "lg", fullWidth: true }, children: jsx(tn$1, { unrealROI: e2.unrealROI, unrealPnL: e2.unrealPnL, freeCollateral: e2.freeCollateral, currentLeverage: e2.currentLeverage, onLeverageEdit: e2.onLeverageEdit, visible: e2.visible }) })] }) });
}, en$1 = () => jsxs(z$3, { gap: 1, className: "oui-h-9", children: [jsx(Q$1.gradient, { color: "brand", weight: "bold", children: "--" }), jsx(Q$1, { children: "USDC" })] }), tn$1 = (e2) => {
  let { t } = ne$6();
  return jsxs(Sa$1, { cols: 3, className: "oui-h-12", children: [jsx(za$1, { label: t("common.unrealizedPnl"), children: jsxs(z$3, { children: [jsx(Q$1.numeral, { coloring: true, size: "lg", weight: "semibold", visible: e2.visible, children: e2.unrealPnL }), jsx(Q$1.numeral, { coloring: true, rule: "percentages", size: "sm", weight: "semibold", prefix: "(", suffix: ")", visible: e2.visible, children: e2.unrealROI })] }) }), jsx(za$1, { label: t("leverage.maxAccountLeverage"), children: jsxs(z$3, { itemAlign: "center", children: [jsx("span", { "data-testid": "oui-testid-portfolio-assets-maxAccountLeverage-value", className: "oui-text-lg", children: e2.currentLeverage }), jsx("span", { children: "x" }), jsx("button", { className: "oui-ml-1", onClick: () => {
    var _a3;
    return (_a3 = e2.onLeverageEdit) == null ? void 0 : _a3.call(e2);
  }, "data-testid": "oui-testid-portfolio-assets-maxAccountLeverage-edit-btn", children: jsx(Rn$1, { color: "white", size: 18 }) })] }) }), jsx(za$1, { label: t("portfolio.overview.availableWithdraw"), align: "right", valueProps: { size: "lg", visible: e2.visible }, children: e2.freeCollateral })] });
};
var We$3 = () => {
  let { canTrade: e2, connect: t, portfolioValue: o2, onLeverageEdit: i, ...r3 } = Me$1();
  return jsx(Ke$3, { onConnectWallet: t, canTrade: e2, portfolioValue: o2, onLeverageEdit: i, ...r3 });
};
function ri$1() {
  let t = new URL(window.location.href).searchParams.get("link");
  if (!t) return;
  let { a: o2, k: i, i: r3, n: a2 } = an$1(t) || {};
  if (o2 && i && r3 && a2) return { address: o2, secretKey: i, chainId: r3, chainNamespace: a2 };
}
function an$1(e2) {
  try {
    let t = JSON.parse(window.atob(e2)), o2 = Math.floor(Date.now() / 1e3), i = t.t;
    return !i || o2 > i ? void 0 : t;
  } catch {
  }
}
var ui = "orderly:wallet-info";
var ci = (e2) => {
  let { wallet: t, connect: o2, connectedChain: i, disconnect: r3, namespace: a2 } = useWalletConnector();
  if (typeof o2 != "function") throw new SDKError("Please provide a wallet connector provider");
  useEventEmitter();
  let n4 = useRef(false);
  useConfig("brokerId");
  let { account: l2, state: c } = useAccount(), g2 = useKeyStore(), y2 = useConfig("networkId"), [m2, { checkChainSupport: d2 }] = useChains(), [p2, D2] = useState(false), { track: z2, setTrackUserId: O2 } = useTrack(), k2 = useMemo(() => {
    var _a3, _b2;
    return (_b2 = (_a3 = t == null ? void 0 : t.accounts) == null ? void 0 : _a3[0]) == null ? void 0 : _b2.address;
  }, [t]), C2 = useMemo(() => {
    var _a3, _b2, _c2, _d3;
    let T2 = (_b2 = (_a3 = t == null ? void 0 : t.chains) == null ? void 0 : _a3[0]) == null ? void 0 : _b2.id, f2 = (_d3 = (_c2 = t == null ? void 0 : t.chains) == null ? void 0 : _c2[0]) == null ? void 0 : _d3.namespace;
    if (!(typeof T2 > "u")) return { id: z$4(T2), namespace: f2 };
  }, [t]);
  return useEffect(() => {
    c.status >= AccountStatusEnum.EnableTrading && l2.accountId && O2(l2.accountId);
  }, [l2, c]), useEffect(() => {
    if (!i) {
      D2(false);
      return;
    }
    let T2 = d2(i.id, y2);
    ABSTRACT_CHAIN_ID_MAP.has(parseInt(i.id)) && (t == null ? void 0 : t.label) !== "AGW" && (T2 = false), D2(!T2);
  }, [i, m2, d2, y2, t]), useEffect(() => {
    w$4(() => {
      let T2 = g2.getAddress(), f2 = JSON.parse(localStorage.getItem(ui) ?? "{}");
      (i == null ? void 0 : i.namespace) !== ChainNamespace.solana && T2 && l2.address !== T2 && f2.label && o2({ autoSelect: { label: f2.label, disableModals: true } }).then((b2) => {
      }, (b2) => {
      });
    });
  }, [t, l2.address]), useEffect(() => {
    if (t === null && c.status > AccountStatusEnum.NotConnected && !c.validating) {
      l2.disconnect();
      return;
    }
    if (p2 || !i || n4.current) return;
    let T2 = ri$1();
    k2 && k2 !== l2.address && !T2 && (l2.setAddress(k2, { provider: t == null ? void 0 : t.provider, chain: { id: N$5(C2.id), namespace: C2.namespace.toUpperCase() }, wallet: { name: (t == null ? void 0 : t.label) ?? "" }, additionalInfo: (t == null ? void 0 : t.additionalInfo) ?? {} }), z2(TrackerEventName.walletConnect, { wallet: (t == null ? void 0 : t.label) ?? "", network: C2.namespace.toUpperCase() }), w$4(() => {
      localStorage.setItem(ui, JSON.stringify({ label: (t == null ? void 0 : t.label) ?? "" }));
    })), (C2 == null ? void 0 : C2.id) !== l2.chainId && l2.switchChainId(C2 == null ? void 0 : C2.id);
  }, [t, i, k2, C2, l2.address, c, l2.chainId, p2]), { connectWallet: async () => (n4.current = true, o2({ chainId: e2.currentChainId }).then(async (T2) => {
    if (Array.isArray(T2) && T2.length > 0 && T2[0] && T2[0].accounts.length > 0) {
      let f2 = T2[0], b2 = N$5(f2.chains[0].id);
      if (!d2(b2, y2)) return { wrongNetwork: true };
      if (!l2) throw new Error("account is not initialized");
      c.status === AccountStatusEnum.EnableTradingWithoutConnected && (localStorage.removeItem("orderly_link_device"), await l2.disconnect());
      let S2 = await l2.setAddress(f2.accounts[0].address, { provider: f2.provider, chain: { id: N$5(f2.chains[0].id), namespace: f2.chains[0].namespace.toUpperCase() }, wallet: { name: f2.label } });
      return z2(TrackerEventName.walletConnect, { wallet: f2.label, network: f2.chains[0].namespace.toUpperCase() }), { wallet: f2, status: S2, wrongNetwork: false };
    }
    return null;
  }).finally(() => {
    n4.current = false;
  })), wrongNetwork: p2 };
};
var fi$1 = ({ type: e2 = TWType.normal }) => {
  let t = useGetClaimed(e2 === TWType.mm ? DistributionId.mmOrder : DistributionId.order), [o2] = useCurEpochEstimate(e2), [i] = useAllBrokers(), { state: r3 } = useAccount(), { data: a2, mutate: s2 } = usePrivateQuery("/v1/referral/info", { revalidateOnFocus: true }), n4 = useEpochInfo(e2), u2 = useConfig("brokerId"), l2 = useMemo(() => i == null ? void 0 : i[u2], [u2, i]), c = useRef(AccountStatusEnum.NotConnected);
  return useEffect(() => {
    let g2;
    return c.current !== r3.status && (c.current = r3.status, g2 = setTimeout(() => {
      s2();
    }, 1e3)), () => {
      g2 && clearTimeout(g2);
    };
  }, [r3.status]), { totalOrderClaimedReward: t, curEpochEstimate: o2, epochList: n4, brokerName: l2, referralInfo: a2 };
}, gi$1 = () => {
  let { totalOrderClaimedReward: e2, curEpochEstimate: t, epochList: o2, brokerName: i, referralInfo: r3 } = useContext(pt$2), { state: a2 } = useAccount(), { wrongNetwork: s2 } = ci({}), n4 = a2.status === AccountStatusEnum.EnableTrading || a2.status === AccountStatusEnum.EnableTradingWithoutConnected;
  return { totalOrderClaimedReward: e2, curEpochEstimate: t, epochList: o2, brokerName: i, isSignIn: n4, referralInfo: r3, wrongNetwork: s2 };
};
var xt$1 = ((i) => (i.WEEK = "7D", i.MONTH = "30D", i.QUARTER = "90D", i))(xt$1 || {}), xi$1 = (e2, t) => {
  var _a3;
  let [o2] = useState(() => {
    let f2 = /* @__PURE__ */ new Date();
    return new Date(getYear(f2), getMonth(f2), getDate(f2), 0, 0, 0);
  }), { isRealtime: i = false } = t || {}, r3 = Object.values(xt$1), [a2, s2] = useLocalStorage(e2, "7D"), { totalValue: n4 } = useCollateral(), u2 = (f2) => {
    switch (f2) {
      case "30D":
        return subDays(o2, 35);
      case "90D":
        return subDays(o2, 95);
      default:
        return subDays(o2, 10);
    }
  }, l2 = useMemo(() => {
    switch (a2) {
      case "7D":
        return 7;
      case "30D":
        return 30;
      case "90D":
        return 90;
      default:
        return 7;
    }
  }, [a2]), [c, g2] = useState(u2(a2)), y2 = useMemo(() => addDays(o2, 1), [o2]), [m2] = useStatisticsDaily({ startDate: c.toISOString().split("T")[0], endDate: y2.toISOString().split("T")[0] }, { ignoreAggregation: true }), [d2] = useAssetsHistory({ startTime: subDays(o2, 2).getTime().toString(), endTime: y2.getTime().toString(), pageSize: 50 }), p2 = (f2) => {
    g2(u2(f2)), s2(f2);
  }, D2 = (f2) => {
    if (n4 == null) return null;
    let b2 = new g$6(n4).sub(f2.lastItem.account_value);
    if (Array.isArray(f2.assetHistory) && f2.assetHistory.length > 0 && typeof f2.lastItem.snapshot_time < "u") {
      let S2 = [];
      for (let v3 = 0; v3 < f2.assetHistory.length; v3++) {
        let I2 = f2.assetHistory[v3];
        I2.created_time > f2.lastItem.snapshot_time && S2.push(I2);
      }
      for (let v3 = 0; v3 < S2.length; v3++) {
        let I2 = S2[v3];
        I2.side === "DEPOSIT" ? I2.trans_status === "COMPLETED" && (b2 = b2.sub(I2.amount)) : I2.side === "WITHDRAW" && I2.trans_status !== "FAILED" && (b2 = b2.add(I2.amount));
      }
    }
    return b2.toNumber();
  }, z2 = (f2, b2) => {
    let S2 = f2[f2.length - 1], v3 = format(o2, "yyyy-MM-dd");
    return { ...S2, date: v3, perp_volume: 0, account_value: b2 !== null ? b2 : (S2 == null ? void 0 : S2.account_value) ?? 0, pnl: D2({ lastItem: S2, assetHistory: d2 }) ?? 0 };
  }, O2 = (f2, b2) => !Array.isArray(f2) || f2.length === 0 ? f2 : (f2[f2.length - 1].date, format(o2, "yyyy-MM-dd"), f2.concat([z2(f2, b2)])), k2 = (f2, b2) => {
    let S2 = b2 ? O2(f2, n4) : f2;
    return S2.slice(Math.max(0, S2.length - l2));
  }, C2 = useMemo(() => n4 == null ? [] : k2(m2, i), [m2, n4, d2, i]), st2 = useMemo(() => {
    var _a4;
    let f2 = $$4, b2 = $$4, S2 = $$4;
    if (Array.isArray(C2) && C2.length) {
      C2.forEach((He2) => {
        b2 = b2.add(He2.pnl);
      });
      let v3 = C2[0], I2 = m2.findIndex((He2) => He2.date === v3.date), Ee2 = (_a4 = m2[I2 - 1]) == null ? void 0 : _a4.account_value;
      typeof Ee2 > "u" || Ee2 === 0 ? S2 = $$4 : S2 = b2.div(Ee2);
    }
    if (m2.length > 0) for (let v3 = 0; v3 < l2; v3++) {
      let I2 = m2[m2.length - 1 - v3];
      I2 && (f2 = f2.add(I2.perp_volume ?? 0));
    }
    return { vol: f2.toNumber(), pnl: b2.toNumber(), roi: S2.toNumber() };
  }, [C2, m2, l2]);
  return { periodTypes: r3, period: a2, onPeriodChange: p2, data: C2, aggregateValue: st2, createFakeData: (f2, b2) => Array.from({ length: 2 }, (S2, v3) => ({ date: format(v3 === 0 ? c : /* @__PURE__ */ new Date(), "yyyy-MM-dd"), ...v3 === 0 ? f2 : b2 })), volumeUpdateDate: ((_a3 = m2 == null ? void 0 : m2[m2.length - 1]) == null ? void 0 : _a3.date) ?? "" };
};
var pt$2 = createContext({}), Wn$2 = "portfolio_performance_period", bt$3 = () => useContext(pt$2), ht$1 = (e2) => {
  let t = xi$1(Wn$2, { isRealtime: true }), o2 = fi$1({ type: e2.type });
  return jsx(pt$2.Provider, { value: { ...t, type: e2.type, ...o2 }, children: e2.children });
};
var Ct$2 = () => {
  let e2 = bt$3(), { wrongNetwork: t, disabledConnect: o2 } = L$3(), { state: i } = useAccount(), r3 = Tr$2(e2.data, { accountStatus: i.status === AccountStatusEnum.EnableTradingWithoutConnected ? AccountStatusEnum.EnableTradingWithoutConnected : AccountStatusEnum.EnableTrading, fallbackData: e2.createFakeData({ account_value: 0 }, { account_value: 500 }) }), a2 = useMemo(() => (r3 == null ? void 0 : r3.length) ?? 0 > 0 ? r3 : e2.createFakeData({ account_value: 0 }, { account_value: 500 }), [r3]), s2 = t || o2 || !e2.data.length;
  return { ...e2, data: a2, invisible: s2 };
};
var vt$1 = (e2) => {
  let { t } = ne$6(), o2 = useMemo(() => ({ "7D": t("common.select.7d"), "30D": t("common.select.30d"), "90D": t("common.select.90d") }), [t]);
  return jsxs(z$3, { justify: "between", children: [jsx(ur$4, { children: e2.title }), jsx("div", { className: "oui-min-w-14", children: jsx(Be$6.options, { size: "xs", value: e2.period, onValueChange: e2.onPeriodChange, options: e2.periodTypes.map((i) => ({ value: i, label: o2[i] })) }) })] });
};
var bi$1 = (e2) => {
  let { onPeriodChange: t, periodTypes: o2, period: i, data: r3 } = e2, { t: a2 } = ne$6();
  return jsx(Kl, { title: jsx(vt$1, { onPeriodChange: t, periodTypes: o2, period: i, title: a2("common.assets") }), id: "portfolio-overview-assets-chart", classNames: { content: "oui-h-[168px] oui-pb-0" }, children: jsx(zt$2, { data: e2.data, invisible: e2.invisible }) });
};
var wt = () => {
  let e2 = Ct$2();
  return jsx(bi$1, { ...e2 });
};
var Oe = () => {
  let { data: e2 } = useQuery("/v1/public/chain_info"), { t } = ne$6();
  return useMemo(() => [{ title: t("common.token"), dataIndex: "token", width: 80, render: (i) => jsxs(z$3, { gapX: 1, children: [jsx(Te$4, { name: i, size: "xs" }), jsx("span", { children: i })] }) }, { title: t("common.time"), dataIndex: "created_time", width: 80, rule: "date" }, { title: t("portfolio.overview.column.txId"), dataIndex: "tx_id", width: 120, render: (i, r3) => {
    var _a3;
    if (!i) return jsx("div", { className: "oui-text-base-contrast-54", children: "-" });
    let n4 = `${(_a3 = e2 == null ? void 0 : e2.find((u2) => parseInt(r3.chain_id) === parseInt(u2.chain_id))) == null ? void 0 : _a3.explorer_base_url}/tx/${i}`;
    return jsx("a", { href: n4, target: "_blank", children: jsx(Q$1.formatted, { copyable: !!i, rule: "txId", className: "oui-underline-offset-4 oui-underline oui-decoration-dashed oui-decoration-line-16", onCopy: (u2) => {
      u2.preventDefault(), u2.stopPropagation(), toast$2.success(t("common.copy.copied"));
    }, children: i }) });
  } }, { title: t("common.status"), dataIndex: "trans_status", width: 100, render: (i) => ({ [AssetHistoryStatusEnum.NEW]: t("assetHistory.status.pending"), [AssetHistoryStatusEnum.CONFIRM]: t("assetHistory.status.confirm"), [AssetHistoryStatusEnum.PROCESSING]: t("assetHistory.status.processing"), [AssetHistoryStatusEnum.COMPLETED]: t("assetHistory.status.completed"), [AssetHistoryStatusEnum.FAILED]: t("assetHistory.status.failed") })[i] || yg(i.toLowerCase()) }, { title: t("common.type"), dataIndex: "side", width: 80, render: (i) => jsx(Q$1, { color: i === "DEPOSIT" ? "deposit" : "withdraw", children: t(i === "DEPOSIT" ? "common.deposit" : "common.withdraw") }) }, { title: t("common.amount"), dataIndex: "amount", width: 100, rule: "price", formatter: (i, r3) => r3.side === "WITHDRAW" ? -(i - (r3.fee ?? 0)) : i - (r3.fee ?? 0), numeralProps: { coloring: true, showIdentifier: true } }], [e2, t]);
};
var Te$1 = (e2) => {
  let { from: t, to: o2 } = e2;
  return typeof o2 > "u" && (o2 = /* @__PURE__ */ new Date()), differenceInDays(t, o2) === 0 ? [t, setHours(o2, 23)] : [t, o2];
};
var Be$3 = () => {
  let [e2] = useState(() => {
    let d2 = /* @__PURE__ */ new Date();
    return new Date(getYear(d2), getMonth(d2), getDate(d2), 0, 0, 0);
  }), [t, o2] = useState([R$3(90, e2), e2]), [i, r3] = useState("All"), { page: a2, pageSize: s2, setPage: n4, parsePagination: u2 } = p0(), [l2, { meta: c, isLoading: g2 }] = useAssetsHistory({ startTime: t[0].getTime().toString(), endTime: set(t[1], { hours: 23, minutes: 59, seconds: 59, milliseconds: 0 }).getTime().toString(), page: a2, pageSize: s2, side: i }), y2 = (d2) => {
    d2.name === "side" && (r3(d2.value), n4(1)), d2.name === "dateRange" && (o2(Te$1(d2.value)), n4(1));
  }, m2 = useMemo(() => u2(c), [u2, c]);
  return { dataSource: l2, total: c == null ? void 0 : c.total, isLoading: g2, queryParameter: { side: i, dateRange: t }, onFilter: y2, pagination: m2 };
};
var Ue$1 = (e2) => {
  let { dataSource: t, queryParameter: o2, onFilter: i, isLoading: r3 } = e2, { side: a2, dateRange: s2 } = o2, n4 = Oe(), { t: u2 } = ne$6(), l2 = useMemo(() => [{ label: u2("common.all"), value: "All" }, { label: u2("common.deposit"), value: "DEPOSIT" }, { label: u2("common.withdraw"), value: "WITHDRAW" }], [u2]);
  return jsxs(Fragment$1, { children: [jsx(n0, { items: [{ type: "select", name: "side", options: l2, value: a2 }, { type: "range", name: "dateRange", value: { from: s2[0], to: s2[1] } }], onFilter: (c) => {
    i(c);
  } }), jsx(dt$3, { bordered: true, loading: r3, classNames: { root: "oui-h-[calc(100%_-_49px)]" }, columns: n4, dataSource: t, pagination: e2.pagination })] });
};
var vi$1 = (e2) => {
  let { dataSource: t, queryParameter: o2, onFilter: i, isLoading: r3, pagination: a2, onDeposit: s2, chains: n4 } = e2, { side: u2, dateRange: l2 } = o2, { t: c } = ne$6(), g2 = useMemo(() => [{ label: c("common.all"), value: "All" }, { label: c("common.deposit"), value: "DEPOSIT" }, { label: c("common.withdraw"), value: "WITHDRAW" }], [c]), y2 = () => {
    t.length < ((a2 == null ? void 0 : a2.count) || 0) && (a2 == null ? void 0 : a2.onPageSizeChange) && a2.onPageSizeChange((a2 == null ? void 0 : a2.pageSize) + 50);
  }, m2 = (p2) => ({ [AssetHistoryStatusEnum.NEW]: c("assetHistory.status.pending"), [AssetHistoryStatusEnum.CONFIRM]: c("assetHistory.status.confirm"), [AssetHistoryStatusEnum.PROCESSING]: c("assetHistory.status.processing"), [AssetHistoryStatusEnum.COMPLETED]: c("assetHistory.status.completed"), [AssetHistoryStatusEnum.FAILED]: c("assetHistory.status.failed") })[p2] || yg(p2.toLowerCase()), d2 = (p2) => {
    let D2 = p2.side === "WITHDRAW" ? -(p2.amount - (p2.fee ?? 0)) : `+${p2.amount - (p2.fee ?? 0)}`, z2 = () => {
      if (!p2.tx_id) return;
      let k2 = n4 && Array.isArray(n4) ? n4.find((C2) => parseInt(p2.chain_id) === parseInt(C2.chain_id)) : void 0;
      if (k2 == null ? void 0 : k2.explorer_base_url) return `${k2.explorer_base_url}/tx/${p2.tx_id}`;
    }, O2 = p2.side === "DEPOSIT" ? "buy" : "sell";
    return jsxs(z$3, { p: 2, direction: "column", gapY: 1, className: "oui-rounded-xl oui-bg-base-9 oui-font-semibold", children: [jsxs(z$3, { direction: "row", justify: "start", width: "100%", className: "oui-text-xs", height: "18px", children: [jsx(Q$1, { color: O2, children: D2 }), jsx(Q$1, { className: "oui-ml-1 oui-text-base-contrast-80", children: p2.token }), jsx(Wd, { color: O2, className: "oui-ml-2", size: "xs", children: p2.side === "DEPOSIT" ? c("common.deposit") : c("common.withdraw") }), jsx(Q$1, { className: "oui-text-base-contrast-80 oui-ml-auto", children: m2(p2.trans_status) })] }), jsxs(z$3, { direction: "row", justify: "between", width: "100%", height: "18px", children: [jsx(Q$1.formatted, { rule: "date", className: "oui-text-base-contrast-36 oui-text-2xs", children: p2.created_time }), p2.tx_id ? jsx("a", { href: z2(), target: "_blank", className: "oui-text-base-contrast-36 oui-text-xs", rel: "noreferrer", children: jsx(Q$1.formatted, { copyable: !!p2.tx_id, className: "oui-underline-offset-4 oui-underline oui-decoration-dashed oui-decoration-line-16", rule: "txId", onCopy: (k2) => {
      k2.preventDefault(), k2.stopPropagation(), toast$2.success(c("common.copy.copied"));
    }, children: p2.tx_id }) }) : jsx("div", { className: "oui-text-base-contrast-54", children: "-" })] })] });
  };
  return jsxs(Fragment$1, { children: [jsx(n0, { items: [{ type: "picker", name: "side", options: g2, value: u2, size: "md" }, { type: "range", name: "dateRange", value: { from: l2[0], to: l2[1] } }], onFilter: (p2) => {
    i(p2);
  }, className: "oui-border-none oui-px-3 oui-py-2 oui-sticky oui-top-[44px] oui-z-10 oui-bg-base-10" }), jsx(og$1, { dataSource: t, renderItem: d2, contentClassName: "!oui-space-y-1", loadMore: y2, isLoading: r3, className: "oui-px-1", emptyView: jsxs(z$3, { direction: "column", height: "100%", itemAlign: "center", justify: "center", mt: 3, children: [jsx(er$1, {}), (t == null ? void 0 : t.length) == 0 && jsxs(z$3, { direction: "row", itemAlign: "center", justify: "center", onClick: s2, className: "oui-w-full oui-text-secondary oui-mt-2 oui-h-4", children: [jsx(Q$1, { color: "primary", size: "2xs", children: c("common.deposit") }), jsx(Wn$4, { className: "oui-ml-0.5 oui-opacity-100 oui-w-4 oui-h-4 oui-text-primary", color: "primary", size: 16, opacity: 100 })] })] }) })] });
};
var ue$1 = () => {
  let e2 = Be$3(), { data: t } = useQuery("/v1/public/chain_info"), o2 = useCallback(() => {
    vo$4.show(Xr$1, { activeTab: "deposit" });
  }, []), { isMobile: i } = it$6();
  return i ? jsx(vi$1, { ...e2, onDeposit: o2, chains: t }) : jsx(Ue$1, { ...e2 });
};
var $e$2 = () => {
  let { t: e2 } = ne$6();
  return useMemo(() => [{ title: e2("common.symbol"), dataIndex: "symbol", width: 80, rule: "symbol", textProps: { showIcon: true } }, { title: e2("common.time"), dataIndex: "created_time", width: 120, rule: "date" }, { title: e2("portfolio.overview.column.funding&AnnualRate"), dataIndex: "funding_rate", width: 80, render: (o2, i) => jsxs(z$3, { gap: 1, children: [jsx(Q$1.numeral, { rule: "percentages", dp: 6, children: i.funding_rate }), jsx("span", { children: "/" }), jsx(Q$1.numeral, { rule: "percentages", dp: 6, children: i.annual_rate })] }) }, { title: e2("portfolio.overview.column.paymentType"), dataIndex: "payment_type", width: 80, render: (o2) => {
    switch (o2) {
      case "Pay":
      case "Paid":
        return e2("portfolio.overview.column.paymentType.paid");
      case "Receive":
      case "Received":
        return e2("portfolio.overview.column.paymentType.received");
      default:
        return o2;
    }
  } }, { title: `${e2("portfolio.overview.column.fundingFee")} (USDC)`, dataIndex: "funding_fee", width: 80, rule: "price", formatter(o2, i, r3) {
    return Number(o2) * -1;
  }, numeralProps: { coloring: true, showIdentifier: true, ignoreDP: true } }], [e2]);
};
var mo$1 = (e2) => {
  let { dataSource: t, queryParameter: o2, onFilter: i, isLoading: r3 } = e2, a2 = $e$2(), s2 = useSymbolsInfo(), { symbol: n4, dateRange: u2 } = o2, { t: l2 } = ne$6(), c = useMemo(() => [{ label: l2("common.all"), value: "All" }, ...Object.keys(s2).map((g2) => ({ label: g2.split("_")[1], value: g2 }))], [l2, s2]);
  return jsxs(Fragment$1, { children: [jsx(n0, { items: [{ type: "select", name: "symbol", isCombine: true, options: c, value: n4, valueFormatter: (g2) => {
    var _a3;
    return ((_a3 = c.find((m2) => m2.value === g2)) == null ? void 0 : _a3.label) || g2;
  } }, { type: "range", name: "dateRange", value: { from: u2[0], to: u2[1] } }], onFilter: (g2) => {
    i(g2);
  } }), jsx(dt$3, { bordered: true, columns: a2, dataSource: t, loading: r3, generatedRowKey: (g2) => `${g2.updated_time}`, classNames: { root: "oui-h-[calc(100%_-_49px)]" }, pagination: e2.pagination })] });
};
var po$2 = (e2) => {
  let { dataSource: t, queryParameter: o2, onFilter: i, isLoading: r3, pagination: a2 } = e2, s2 = useSymbolsInfo(), { symbol: n4, dateRange: u2 } = o2, { t: l2 } = ne$6(), c = (m2) => {
    switch (m2) {
      case "Pay":
      case "Paid":
        return l2("portfolio.overview.column.paymentType.paid");
      case "Receive":
      case "Received":
        return l2("portfolio.overview.column.paymentType.received");
      default:
        return m2;
    }
  }, g2 = () => {
    t && t.length < ((a2 == null ? void 0 : a2.count) || 0) && (a2 == null ? void 0 : a2.onPageSizeChange) && a2.onPageSizeChange((a2 == null ? void 0 : a2.pageSize) + 50);
  }, y2 = (m2) => {
    let d2 = l2("portfolio.overview.column.funding&AnnualRate") || "", [p2, D2] = d2.split("/");
    return jsxs(z$3, { p: 2, direction: "column", gapY: 2, className: "oui-rounded-xl oui-bg-base-9 oui-font-semibold", children: [jsxs(z$3, { direction: "row", justify: "between", width: "100%", height: "20px", children: [jsx(Q$1.formatted, { rule: "symbol", className: "oui-text-base-contrast oui-mr-1 oui-text-sm", children: m2.symbol }), jsx(Wd, { color: "neutral", size: "xs", children: c(m2.payment_type) }), jsx(Q$1.formatted, { rule: "date", className: "oui-text-base-contrast-36 oui-text-2xs oui-ml-auto", children: m2.created_time })] }), jsx("div", { className: "oui-w-full oui-h-[1px] oui-bg-base-6" }), jsxs(z$3, { direction: "row", justify: "between", width: "100%", children: [jsxs(z$3, { direction: "column", children: [jsx(Q$1, { className: "oui-text-base-contrast-36 oui-text-2xs", children: p2 }), jsx(Q$1.numeral, { rule: "percentages", dp: 6, className: "oui-text-base-contrast-80 oui-text-xs", children: m2.funding_rate })] }), jsxs(z$3, { direction: "column", children: [jsx(Q$1, { className: "oui-text-base-contrast-36 oui-text-2xs", children: D2 }), jsx(Q$1.numeral, { rule: "percentages", dp: 6, className: "oui-text-base-contrast-80 oui-text-xs", children: m2.annual_rate })] }), jsxs(z$3, { direction: "column", children: [jsxs(Q$1, { className: "oui-text-base-contrast-36 oui-text-2xs", children: [l2("portfolio.overview.column.fundingFee"), " ", jsx(Q$1, { className: "oui-text-base-contrast-20", children: "(USDC)" })] }), jsx(Q$1.numeral, { dp: 6, ignoreDP: true, coloring: true, showIdentifier: true, className: "oui-text-xs oui-self-end", children: Number(m2.funding_fee) * -1 })] })] })] });
  };
  return jsxs(Fragment$1, { children: [jsx(n0, { items: [{ type: "select", name: "symbol", isCombine: true, options: [{ label: "All", value: "All" }, ...Object.keys(s2).map((m2) => ({ label: m2.split("_")[1], value: m2 }))], value: n4, valueFormatter: (m2) => m2 === "All" ? "All" : m2.split("_")[1] }, { type: "range", name: "dateRange", value: { from: u2[0], to: u2[1] } }], onFilter: (m2) => {
    i(m2);
  }, className: "oui-px-3 oui-py-2 oui-sticky oui-top-[44px] oui-z-10 oui-bg-base-10" }), jsx(og$1, { dataSource: t, renderItem: y2, contentClassName: "!oui-space-y-1", loadMore: g2, isLoading: r3, className: "oui-px-1" })] });
};
var Ze$2 = () => {
  let [e2] = useState(() => {
    let p2 = /* @__PURE__ */ new Date();
    return new Date(getYear(p2), getMonth(p2), getDate(p2), 0, 0, 0);
  }), [t, o2] = useState([R$3(90, e2), e2]), [i, r3] = useState("All"), { page: a2, pageSize: s2, setPage: n4, parsePagination: u2 } = p0(), [l2, { isLoading: c, meta: g2, isValidating: y2 }] = useFundingFeeHistory({ dataRange: [t[0].getTime(), set(t[1], { hours: 23, minutes: 59, seconds: 59, milliseconds: 0 }).getTime()], symbol: i, page: a2, pageSize: s2 }, { keepPreviousData: true }), m2 = (p2) => {
    p2.name === "symbol" && (r3(p2.value), n4(1)), p2.name === "dateRange" && (o2(Te$1(p2.value)), n4(1));
  }, d2 = useMemo(() => u2(g2), [u2, g2]);
  return { dataSource: l2, isLoading: c, isValidating: y2, queryParameter: { symbol: i, dateRange: t }, onFilter: m2, pagination: d2 };
};
var ce$3 = () => {
  let e2 = Ze$2(), { isMobile: t } = it$6();
  return t ? jsx(po$2, { ...e2 }) : jsx(mo$1, { ...e2 });
};
var qe$2 = (e2) => {
  let { dataSource: t, queryParameter: o2, onFilter: i, isLoading: r3, pagination: a2 } = e2, { type: s2, dateRange: n4 } = o2, { t: u2 } = ne$6(), l2 = useMemo(() => [{ label: u2("common.all"), value: "All" }, { label: u2("portfolio.overview.distribution.type.referralCommission"), value: "REFERRER_REBATE" }, { label: u2("portfolio.overview.distribution.type.refereeRebate"), value: "REFEREE_REBATE" }, { label: u2("portfolio.overview.distribution.type.brokerFee"), value: "BROKER_FEE" }], [u2]), c = (d2) => {
    switch (d2) {
      case "CREATED":
      case "SPLIT":
        return u2("assetHistory.status.processing");
      case "COMPLETED":
      default:
        return u2("assetHistory.status.completed");
    }
  }, g2 = (d2) => {
    switch (d2) {
      case "REFERRER_REBATE":
        return u2("portfolio.overview.distribution.type.referralCommission");
      case "REFEREE_REBATE":
        return u2("portfolio.overview.distribution.type.refereeRebate");
      case "BROKER_FEE":
        return u2("portfolio.overview.distribution.type.brokerFee");
      default:
        return "-";
    }
  }, y2 = (d2) => jsxs(z$3, { p: 2, direction: "column", gapY: 2, className: "oui-rounded-xl oui-bg-base-9 oui-font-semibold", children: [jsxs(z$3, { direction: "row", justify: "between", width: "100%", height: "20px", children: [jsx(Q$1.formatted, { rule: "date", className: "oui-text-2xs oui-text-base-contrast-36", children: d2.created_time }), jsx(Q$1, { className: "oui-text-sm oui-text-base-contrast-80", children: c(d2.status) })] }), jsx("div", { className: "oui-h-px oui-w-full oui-bg-base-6" }), jsxs(z$3, { direction: "row", justify: "between", width: "100%", children: [jsxs(z$3, { direction: "column", children: [jsx(Q$1, { className: "oui-text-2xs oui-text-base-contrast-36", children: u2("common.token") }), jsxs(z$3, { gapX: 2, children: [jsx(Te$4, { name: d2.token, size: "xs" }), jsx("span", { className: "oui-text-xs oui-text-base-contrast-80", children: d2.token })] })] }), jsxs(z$3, { direction: "column", children: [jsx(Q$1, { className: "oui-text-2xs oui-text-base-contrast-36", children: u2("common.type") }), jsx(Q$1, { className: "oui-text-xs oui-text-base-contrast-80", children: g2(d2.type) })] }), jsxs(z$3, { direction: "column", children: [jsx(Q$1, { className: "oui-text-2xs oui-text-base-contrast-36", children: u2("common.amount") }), jsx(Q$1, { className: "oui-text-xs oui-text-base-contrast-80", children: d2.amount })] })] })] }), m2 = () => {
    t.length < ((a2 == null ? void 0 : a2.count) || 0) && (a2 == null ? void 0 : a2.onPageSizeChange) && a2.onPageSizeChange((a2 == null ? void 0 : a2.pageSize) + 50);
  };
  return jsxs(Fragment$1, { children: [jsx(n0, { items: [{ type: "picker", name: "type", options: l2, value: s2, size: "md" }, { type: "range", name: "dateRange", value: { from: n4[0], to: n4[1] } }], onFilter: (d2) => {
    i(d2);
  }, className: "oui-px-3 oui-py-2 oui-sticky oui-top-[44px] oui-z-10 oui-bg-base-10" }), jsx(og$1, { dataSource: t, renderItem: y2, contentClassName: "oui-space-y-1", loadMore: m2, isLoading: r3, className: "oui-px-1" })] });
};
var Fi = () => {
  let { t: e2 } = ne$6();
  return useMemo(() => [{ title: e2("common.token"), dataIndex: "token", width: 80, render: (o2, i) => jsxs(z$3, { gapX: 2, children: [jsx(Te$4, { name: o2, size: "xs" }), jsx("span", { children: o2 })] }) }, { title: e2("common.time"), dataIndex: "updated_time", width: 120, rule: "date" }, { title: e2("common.status"), dataIndex: "status", width: 120, formatter(o2, i, r3) {
    switch (o2) {
      case "CREATED":
      case "SPLIT":
        return e2("assetHistory.status.processing");
      case "COMPLETED":
      default:
        return e2("assetHistory.status.completed");
    }
  } }, { title: e2("common.type"), dataIndex: "type", width: 80, formatter: (o2) => {
    switch (o2) {
      case "REFERRER_REBATE":
        return e2("portfolio.overview.distribution.type.referralCommission");
      case "REFEREE_REBATE":
        return e2("portfolio.overview.distribution.type.refereeRebate");
      case "BROKER_FEE":
        return e2("portfolio.overview.distribution.type.brokerFee");
      default:
        return "-";
    }
  } }, { title: e2("common.amount"), dataIndex: "amount", width: 80 }], [e2]);
};
var Ye$1 = (e2) => {
  let { dataSource: t, queryParameter: o2, onFilter: i, isLoading: r3, isValidating: a2 } = e2, s2 = Fi(), { type: n4, dateRange: u2 } = o2, { t: l2 } = ne$6(), c = useMemo(() => [{ label: l2("common.all"), value: "All" }, { label: l2("portfolio.overview.distribution.type.referralCommission"), value: "REFERRER_REBATE" }, { label: l2("portfolio.overview.distribution.type.refereeRebate"), value: "REFEREE_REBATE" }, { label: l2("portfolio.overview.distribution.type.brokerFee"), value: "BROKER_FEE" }], [l2]);
  return jsxs(Fragment$1, { children: [jsx(n0, { items: [{ type: "select", name: "type", options: c, value: n4 }, { type: "range", name: "dateRange", value: { from: u2[0], to: u2[1] } }], onFilter: (g2) => {
    i(g2);
  } }), jsx(dt$3, { bordered: true, columns: s2, dataSource: t, loading: r3, className: "oui-font-semibold", classNames: { root: "oui-h-[calc(100%_-_49px)]" }, pagination: e2.pagination })] });
};
var Ni$1 = () => {
  let [e2] = useState(() => {
    let p2 = /* @__PURE__ */ new Date();
    return new Date(getYear(p2), getMonth(p2), getDate(p2), 0, 0, 0);
  }), [t, o2] = useState([R$3(90, e2), e2]), [i, r3] = useState("All"), { page: a2, pageSize: s2, setPage: n4, parsePagination: u2 } = p0(), [l2, { isLoading: c, meta: g2, isValidating: y2 }] = useDistributionHistory({ dataRange: [t[0].getTime(), set(t[1], { hours: 23, minutes: 59, seconds: 59, milliseconds: 0 }).getTime()], type: i, pageSize: s2, page: a2 }), m2 = (p2) => {
    p2.name === "type" && (r3(p2.value), n4(1)), p2.name === "dateRange" && (o2(Te$1(p2.value)), n4(1));
  }, d2 = useMemo(() => u2(g2), [u2, g2]);
  return { dataSource: l2, isLoading: c, isValidating: y2, queryParameter: { type: i, dateRange: t }, onFilter: m2, pagination: d2 };
};
var pe = () => {
  let e2 = Ni$1(), { isMobile: t } = it$6();
  return t ? jsx(qe$2, { ...e2 }) : jsx(Ye$1, { ...e2 });
};
var Di = (e2) => {
  let { active: t = "deposit", onTabChange: o2 } = e2, { t: i } = ne$6();
  return jsx(Kl, { children: jsxs(jl, { value: t, onValueChange: o2, variant: "contained", size: "xl", children: [jsx($l, { title: i("portfolio.overview.deposits&Withdrawals"), icon: jsx(wn$2, {}), value: "deposit", children: jsx(ue$1, {}) }), jsx($l, { title: i("common.funding"), icon: jsx(Sn$2, {}), value: "funding", children: jsx(ce$3, {}) }), jsx($l, { title: i("portfolio.overview.distribution"), icon: jsx(Ln, {}), value: "distribution", children: jsx(pe, {}) })] }) });
};
var Ri$1 = (e2) => {
  let { active: t = "deposit", onTabChange: o2 } = e2, { t: i } = ne$6();
  return jsxs(jl, { value: t, onValueChange: o2, variant: "contained", size: "lg", classNames: { tabsList: "oui-px-3 oui-py-2" }, children: [jsx($l, { title: i("portfolio.overview.deposits&Withdrawals"), value: "deposit", children: jsx(ue$1, {}) }), jsx($l, { title: i("common.funding"), value: "funding", children: jsx(ce$3, {}) }), jsx($l, { title: i("portfolio.overview.distribution"), value: "distribution", children: jsx(pe, {}) })] });
};
var _i$1 = () => {
  let [e2, t] = useState("deposit");
  return { active: e2, onTabChange: (o2) => t(o2) };
};
var oe$1 = () => {
  let e2 = _i$1(), { isMobile: t } = it$6();
  return t ? jsx(Ri$1, { ...e2 }) : jsx(Di, { ...e2 });
};
var Qe$3 = (e2) => {
  var _a3;
  let { periodTypes: t, period: o2, onPeriodChange: i, aggregateValue: r3, invisible: a2, visible: s2, volumeUpdateDate: n4 } = e2, { t: u2 } = ne$6(), l2 = useMemo(() => ({ "7D": u2("common.select.7d"), "30D": u2("common.select.30d"), "90D": u2("common.select.90d") }), [u2]);
  return jsxs(Kl, { title: jsx(vt$1, { onPeriodChange: i, periodTypes: t, period: o2, title: u2("portfolio.overview.performance") }), id: "portfolio-overview-performance", children: [jsxs(Sa$1, { cols: 3, gap: 4, children: [jsx(W$2, { gradient: "neutral", r: "md", px: 4, py: 2, angle: 184, border: true, borderColor: 6, children: jsx(za$1, { label: u2("portfolio.overview.performance.roi", { period: l2[o2] }), valueProps: { rule: "percentages", coloring: true, visible: s2 }, children: a2 ? "--" : r3.roi }) }), jsx(W$2, { gradient: "neutral", r: "md", px: 4, py: 2, angle: 184, border: true, borderColor: 6, children: jsx(za$1, { label: u2("portfolio.overview.performance.pnl", { period: l2[o2] }), valueProps: { coloring: true, showIdentifier: true, visible: s2 }, children: a2 ? "--" : r3.pnl }) }), jsx(W$2, { gradient: "neutral", r: "md", px: 4, py: 2, angle: 184, border: true, borderColor: 6, children: jsx(za$1, { classNames: { label: "oui-w-full" }, label: jsxs(z$3, { justify: "between", children: [jsx("span", { children: u2("portfolio.overview.performance.volume", { period: l2[o2] }) }), jsx("span", { children: n4 })] }), children: a2 ? "--" : r3.vol }) })] }), jsxs(Sa$1, { cols: 2, gap: 4, children: [jsx(tu, { data: e2.data ?? [], invisible: e2.invisible }), jsx(ou, { data: e2.data ?? [], invisible: e2.invisible || (((_a3 = e2.data) == null ? void 0 : _a3.length) ?? 0) <= 2 })] })] });
}, tu = (e2) => {
  var _a3;
  let { t } = ne$6();
  return jsxs(W$2, { mt: 4, height: "188px", children: [jsx(Q$1, { as: "div", size: "sm", className: "oui-mb-3", children: t("portfolio.overview.performance.dailyPnl") }), jsx(W$2, { r: "md", className: "oui-border oui-border-line-4 oui-h-[188px]", children: jsx(ct$1, { data: e2.data, invisible: e2.invisible || (((_a3 = e2.data) == null ? void 0 : _a3.length) ?? 0) <= 2 }) })] });
}, ou = (e2) => {
  var _a3;
  let { t } = ne$6();
  return jsxs(W$2, { mt: 4, children: [jsx(Q$1, { as: "div", size: "sm", className: "oui-mb-3", children: t("portfolio.overview.performance.cumulativePnl") }), jsx(W$2, { r: "md", className: "oui-border oui-border-line-4 oui-h-[188px]", children: jsx(Ft$5, { data: e2.data, invisible: e2.invisible || (((_a3 = e2.data) == null ? void 0 : _a3.length) ?? 0) <= 2 }) })] });
};
var Je$2 = () => {
  let e2 = bt$3(), [t] = useLocalStorage("orderly_assets_visible", true), { wrongNetwork: o2, disabledConnect: i } = L$3(), { state: r3 } = useAccount(), a2 = Tr$2(e2.data, { accountStatus: r3.status === AccountStatusEnum.EnableTradingWithoutConnected ? AccountStatusEnum.EnableTradingWithoutConnected : AccountStatusEnum.EnableTrading, fallbackData: e2.createFakeData({ account_value: 0, pnl: 0 }, { account_value: 500, pnl: 500 }) }), s2 = useMemo(() => (a2 == null ? void 0 : a2.length) ?? 0 > 0 ? a2 : e2.createFakeData({ account_value: 0, pnl: 0 }, { account_value: 500, pnl: 500 }), [a2]), n4 = o2 || i || r3.status < AccountStatusEnum.EnableTrading && r3.status !== AccountStatusEnum.EnableTradingWithoutConnected;
  return { ...e2, data: s2, invisible: n4, visible: t };
};
var je$2 = () => {
  let e2 = Je$2();
  return jsx(Qe$3, { ...e2 });
};
var xu = () => {
  let { state: e2 } = useAccount(), { wrongNetwork: o2, disabledConnect: i, connectWallet: r3 } = L$3(), { t: a2 } = ne$6(), s2 = { wrongNetwork: { description: a2("connector.wrongNetwork.tooltip"), rootClass: "oui-bg-[linear-gradient(15deg,#D25F00_0%,transparent_30%)]" }, connectWallet: { description: a2("connector.trade.connectWallet.tooltip"), rootClass: "oui-bg-[linear-gradient(15deg,#27FDFE_0%,transparent_30%)]" }, notSignedIn: { description: a2("connector.trade.signIn.tooltip"), rootClass: "oui-bg-[linear-gradient(15deg,#335FFC_0%,transparent_30%)]" }, disabledTrading: { description: a2("connector.trade.enableTrading.tooltip"), rootClass: "oui-bg-[linear-gradient(15deg,#335FFC_0%,transparent_30%)]" }, default: { description: "", rootClass: "", arrowIconClass: "", textClass: "" } };
  return useMemo(() => {
    if (i) return s2.connectWallet;
    if (o2) return s2.wrongNetwork;
    switch (e2.status) {
      case AccountStatusEnum.NotConnected:
        return s2.connectWallet;
      case AccountStatusEnum.NotSignedIn:
        return s2.notSignedIn;
      case AccountStatusEnum.DisabledTrading:
        return s2.disabledTrading;
      default:
        return s2.default;
    }
  }, [e2.status, o2]);
};
function bu({ children: e2 }) {
  let [t] = useChains("mainnet", { pick: "network_infos" }), { t: o2 } = ne$6();
  return jsx("button", { onClick: () => {
    vo$4.dialog({ title: o2("connector.privy.supportedEvmChain"), size: "xs", content: jsx("div", { children: jsx("div", { className: "oui-p-1 oui-grid oui-grid-cols-2 oui-gap-x-2 oui-gap-y-3 oui-text-2xs oui-text-base-contrast-54", children: t.map((r3, a2) => jsxs("div", { className: "oui-flex oui-items-center oui-justify-start oui-gap-1", children: [jsx(Fr$1, { chainId: r3.chain_id, size: "2xs" }), jsx("div", { children: r3.name })] }, a2)) }) }) });
  }, children: e2 });
}
var hu$1 = (e2) => jsxs("svg", { xmlns: "http://www.w3.org/2000/svg", width: "16", height: "16", viewBox: "0 0 16 16", fill: "currentColor", ...e2, children: [jsx("path", { d: "M8.00521 6.66797C8.74161 6.66797 9.33854 7.26464 9.33854 8.0013C9.33854 8.73797 8.74161 9.33464 8.00521 9.33464C7.26881 9.33464 6.67188 8.73797 6.67188 8.0013C6.67188 7.26464 7.26881 6.66797 8.00521 6.66797Z" }), jsx("path", { d: "M3.33333 6.66797C4.06973 6.66797 4.66667 7.26464 4.66667 8.0013C4.66667 8.73797 4.06973 9.33464 3.33333 9.33464C2.59693 9.33464 2 8.73797 2 8.0013C2 7.26464 2.59693 6.66797 3.33333 6.66797Z" }), jsx("path", { d: "M12.6666 6.66797C13.403 6.66797 14 7.26464 14 8.0013C14 8.73797 13.403 9.33464 12.6666 9.33464C11.9302 9.33464 11.3333 8.73797 11.3333 8.0013C11.3333 7.26464 11.9302 6.66797 12.6666 6.66797Z" })] }), Cu = () => jsxs("div", { className: "oui-relative oui-flex oui-items-center oui-justify-center", children: [jsx("div", { className: "oui-flex oui-h-[18px] oui-items-center oui-justify-center ", children: jsx("img", { src: "https://oss.orderly.network/static/sdk/portfolio/chains.png", className: "oui-relative oui-z-0 oui-h-[18px] oui-w-[49px]" }) }), jsxs("div", { className: "oui-relative oui-left-[-9px] oui-flex oui-items-center oui-justify-center oui-gap-1", children: [jsx("div", { className: "oui-flex oui-size-[18px] oui-items-center oui-justify-center oui-rounded-full oui-bg-[#282e3a]", children: jsx(bu, { children: jsx(hu$1, { className: "oui-relative oui-z-10 oui-size-3 oui-text-base-contrast-54 hover:oui-text-base-contrast", style: { zIndex: 1 } }) }) }), jsx("div", { className: "oui-text-2xs oui-font-semibold oui-text-base-contrast", children: "Evm" })] })] }), vu = () => {
  let { state: e2 } = useAccount(), { namespace: o2 } = useWalletConnector(), { t: i } = ne$6(), r3 = () => {
    navigator.clipboard.writeText(e2.address ?? ""), toast$2.success(i("common.copy.copied"));
  }, a2 = useMemo(() => {
    var _a3;
    return o2 || (e2.status === AccountStatusEnum.EnableTradingWithoutConnected ? (_a3 = wu()) == null ? void 0 : _a3.chainNamespace : null);
  }, [o2, e2.status]), s2 = useMemo(() => {
    if (e2.address) return jsxs(z$3, { className: "oui-text-base oui-text-base-contrast", gapX: 2, children: [Ju(e2.address ?? ""), jsx("button", { className: "oui-cursor-pointer", onClick: () => {
      r3();
    }, children: jsx(bt$5, { size: 18, className: "oui-text-base-contrast-80", opacity: 1 }) })] });
  }, [e2.address]), n4 = useMemo(() => a2 === ChainNamespace.evm ? jsx(Cu, {}) : jsxs(z$3, { gapX: 1, itemAlign: "center", className: "oui-text-2xs", children: [jsx("img", { src: "https://oss.orderly.network/static/sdk/solana-logo.png", className: "oui-w-[15px]" }), "Solana"] }), [a2]), u2 = useMemo(() => {
    let l2 = "";
    return a2 == ChainNamespace.evm ? l2 = "oui-bg-[linear-gradient(15deg,#283BEE_-11%,transparent_30%,transparent_77%,#A53411_100%)]" : a2 == ChainNamespace.solana && (l2 = "oui-bg-[linear-gradient(15deg,#7400D0_-11%,transparent_30%,transparent_77%,#009A7E_100%)]"), l2;
  }, [a2]);
  return jsxs("div", { className: cnBase(["oui-flex oui-h-[44px] oui-w-full oui-items-center oui-justify-between oui-rounded-[10px] oui-px-3 oui-py-[10px]", u2]), children: [s2, n4] });
}, Wi$1 = () => {
  let { state: e2 } = useAccount(), { wrongNetwork: t } = L$3(), { description: o2, rootClass: i } = xu();
  return useMemo(() => e2.status === AccountStatusEnum.EnableTradingWithoutConnected ? true : t ? false : e2.status >= AccountStatusEnum.EnableTrading, [e2.status, t]) ? jsx(vu, {}) : jsx("div", { className: cnBase(["oui-flex oui-h-[44px] oui-w-full oui-items-center oui-justify-center oui-rounded-[10px] oui-px-3 oui-py-[10px]", i]), children: jsx("div", { className: cnBase("oui-flex oui-items-center oui-justify-end oui-rounded-[10px] oui-text-xs oui-font-semibold", "oui-text-base-contrast-54"), children: o2 }) });
};
function wu() {
  try {
    let e2 = localStorage.getItem("orderly_link_device");
    return e2 ? parseJSON(e2) : null;
  } catch {
  }
}
var zi$1 = (e2) => {
  var _a3, _b2, _c2;
  let { t } = ne$6();
  return jsxs(z$3, { className: `
        oui-via-21.6% 
        oui-via-83.23% 
        oui-relative 
        oui-h-[112px] 
        oui-w-full 
        oui-flex-col 
        oui-items-start 
        oui-rounded-xl 
        oui-border 
        oui-border-solid 
        oui-border-[rgba(var(--oui-gradient-primary-start)/0.36)] 
        oui-bg-gradient-to-r
        oui-from-[rgba(var(--oui-gradient-primary-end)/0.12)]
        oui-to-[rgba(var(--oui-gradient-primary-start)/0.12)]
        oui-p-3
      `, children: [jsxs(z$3, { className: "oui-w-full oui-flex-row oui-justify-between oui-items-center", children: [jsxs(z$3, { className: "oui-flex-col oui-items-start", children: [jsx(Q$1, { className: "oui-text-base-contrast oui-text-base oui-font-semibold", children: t("affiliate.asAffiliate.affilates") }), jsx(Q$1, { className: "oui-text-2xs oui-font-normal oui-text-base-contrast-54", children: t("affiliate.commission") })] }), jsx(Cp, {})] }), jsxs(z$3, { className: "oui-mt-auto oui-w-full oui-flex-row oui-items-center oui-gap-1", children: [jsx("img", { src: "https://oss.orderly.network/static/symbol_logo/USDC.png", alt: "USDC", className: "oui-size-5" }), jsx(Q$1, { className: cnBase("oui-text-xs oui-font-semibold", isNumber((_a3 = e2 == null ? void 0 : e2.referralInfo) == null ? void 0 : _a3.referrer_info["30d_referrer_rebate"]) && ((_b2 = e2 == null ? void 0 : e2.referralInfo) == null ? void 0 : _b2.referrer_info["30d_referrer_rebate"]) != 0 ? "oui-text-base-contrast" : "oui-text-base-contrast-36"), children: E$4((_c2 = e2 == null ? void 0 : e2.referralInfo) == null ? void 0 : _c2.referrer_info["30d_referrer_rebate"], { fix: 2, fallback: "--" }) }), jsx(Q$1, { className: "oui-text-xs oui-font-semibold oui-text-base-contrast-36", children: "(30D)" }), jsx(eo$4, { size: 18, color: "white", className: "oui-ml-auto", onClick: () => {
    var _a4;
    return (_a4 = e2 == null ? void 0 : e2.routerAdapter) == null ? void 0 : _a4.onRouteChange({ href: "/rewards/affiliate?tab=affiliate", name: t("tradingRewards.rewards") });
  } })] })] });
};
var Oi$1 = (e2) => {
  let { t } = ne$6(), o2 = () => {
    var _a3;
    (_a3 = e2.routerAdapter) == null ? void 0 : _a3.onRouteChange({ href: "/portfolio/history", name: t("trading.history") });
  };
  return jsxs(z$3, { direction: "row", width: "100%", height: "71px", className: "oui-gap-3 oui-bg-transparent", children: [jsxs(z$3, { direction: "column", gapY: 2, itemAlign: "center", className: "oui-flex-1 oui-cursor-pointer", onClick: e2 == null ? void 0 : e2.onWithdraw, children: [jsx("div", { className: "oui-flex oui-size-[48px] oui-items-center oui-justify-center oui-rounded-xl oui-bg-base-9", children: jsx(yn$1, { size: 28, color: "white", opacity: 1 }) }), jsx(Q$1, { className: "oui-text-base-80 oui-text-2xs", children: t("common.withdraw") })] }), jsxs(z$3, { direction: "column", gapY: 2, itemAlign: "center", className: "oui-flex-1 oui-cursor-pointer", onClick: e2 == null ? void 0 : e2.onDeposit, children: [jsx("div", { className: "oui-flex oui-size-[48px] oui-items-center oui-justify-center oui-rounded-xl oui-bg-base-9", children: jsx(Pn$1, { size: 28, color: "white", opacity: 1 }) }), jsx(Q$1, { className: "oui-text-base-80 oui-text-2xs", children: t("common.deposit") })] }), jsxs(z$3, { direction: "column", gapY: 2, itemAlign: "center", className: "oui-flex-1 oui-cursor-pointer", children: [jsx("div", { className: "oui-flex oui-size-[48px] oui-items-center oui-justify-center oui-rounded-xl oui-bg-base-9", onClick: o2, children: jsx(Ya$1, { size: 28, color: "white", opacity: 1, viewBox: "0 0 28 28", className: "oui-w-[28px] oui-h-[28px]" }) }), jsx(Q$1, { className: "oui-text-base-80 oui-text-2xs", children: t("trading.history") })] })] });
};
var Vi$1 = (e2) => {
  let { t } = ne$6(), { state: o2 } = useAccount(), i = useMemo(() => {
    var _a3;
    return e2.namespace ? e2.namespace : o2.status === AccountStatusEnum.EnableTradingWithoutConnected ? (_a3 = Wu()) == null ? void 0 : _a3.chainNamespace : null;
  }, [e2.namespace, o2.status]);
  return jsxs(z$3, { direction: "column", width: "100%", height: "100%", className: cnBase(["oui-relative oui-items-start oui-overflow-hidden oui-rounded-2xl oui-bg-base-9", i === ChainNamespace.evm && "oui-bg-[#283BEE]", i === ChainNamespace.solana && "oui-bg-[#630EAD]"]), p: 4, children: [jsxs(z$3, { direction: "row", gapX: 1, itemAlign: "center", children: [jsx(Q$1, { className: "oui-text-sm oui-text-base-contrast-54", children: "Portfolio value" }), jsx(Nn$2, { size: 16, className: cnBase(e2.canTrade ? "oui-text-base-contrast-54" : "oui-hidden"), onClick: e2.toggleVisible })] }), jsxs(z$3, { direction: "row", gapX: 1, itemAlign: "baseline", className: "oui-mt-1", children: [jsx(Q$1.numeral, { visible: e2.visible, className: "oui-text-base-contrast oui-text-3xl oui-font-bold", children: e2.portfolioValue ?? "--" }), jsx(Q$1, { className: "oui-text-base oui-font-bold oui-text-base-contrast-80", children: "USDC" })] }), jsxs(z$3, { direction: "row", gapX: 1, itemAlign: "center", className: "oui-text-base-contrast oui-text-sm", children: [jsx(Q$1.numeral, { visible: e2.visible, children: e2.unrealPnL ?? "--" }), jsx(Q$1.numeral, { visible: e2.visible, rule: "percentages", prefix: "(", suffix: ")", children: e2.unrealROI ?? "--" })] })] });
};
function Wu() {
  try {
    let e2 = localStorage.getItem("orderly_link_device");
    return e2 ? parseJSON(e2) : null;
  } catch {
  }
}
var Gi$1 = (e2) => {
  let { t } = ne$6();
  return jsxs(z$3, { direction: "row", width: "100%", className: "oui-cursor-pointer oui-items-center oui-gap-2 oui-rounded-xl oui-bg-base-9 oui-p-4 oui-mb-3", onClick: () => {
    var _a3;
    return (_a3 = e2 == null ? void 0 : e2.routerAdapter) == null ? void 0 : _a3.onRouteChange({ href: "/portfolio/setting", name: t("portfolio.setting") });
  }, children: [jsx(qa, { size: 18, opacity: 0.98, color: "white" }), jsx(Q$1, { className: "oui-text-base oui-font-semibold oui-text-base-contrast-80", children: t("portfolio.setting") }), jsx(eo$4, { className: "oui-ml-auto", size: 18, opacity: 0.36, color: "white" })] });
};
var Zi = (e2) => {
  var _a3, _b2, _c2, _d3, _e3, _f2;
  let { t } = ne$6();
  return jsxs(z$3, { className: `
        oui-via-21.6% 
        oui-via-83.23% 
        oui-relative 
        oui-h-[112px] 
        oui-w-full 
        oui-flex-col 
        oui-items-start 
        oui-rounded-xl 
        oui-border
        oui-border-solid 
        oui-border-[rgba(var(--oui-gradient-success-start)/0.36)]
        oui-bg-gradient-to-r
        oui-from-[rgba(var(--oui-gradient-success-end)/0.12)]
        oui-to-[rgba(var(--oui-gradient-success-start)/0.12)]
        oui-p-3
      `, children: [jsxs(z$3, { className: "oui-w-full oui-flex-row oui-justify-between oui-items-center", children: [jsxs(z$3, { className: "oui-flex-col oui-items-start", children: [jsx(Q$1, { className: "oui-text-base-contrast oui-text-base oui-font-semibold", children: t("affiliate.trader.rebates") }), jsx(Q$1, { className: "oui-text-2xs oui-font-normal oui-text-base-contrast-54", children: t("affiliate.trader.tradingRebates") })] }), jsx(yp, {})] }), jsxs(z$3, { className: cnBase("oui-mt-auto oui-w-full oui-flex-row oui-items-center oui-gap-1"), children: [jsx("img", { src: "https://oss.orderly.network/static/symbol_logo/USDC.png", alt: "USDC", className: "oui-size-5" }), jsx(Q$1, { className: cnBase("oui-text-xs oui-font-semibold", isNumber((_b2 = (_a3 = e2 == null ? void 0 : e2.referralInfo) == null ? void 0 : _a3.referee_info) == null ? void 0 : _b2["30d_referee_rebate"]) && ((_d3 = (_c2 = e2 == null ? void 0 : e2.referralInfo) == null ? void 0 : _c2.referee_info) == null ? void 0 : _d3["30d_referee_rebate"]) != 0 ? "oui-text-base-contrast" : "oui-text-base-contrast-36"), children: E$4((_f2 = (_e3 = e2 == null ? void 0 : e2.referralInfo) == null ? void 0 : _e3.referee_info) == null ? void 0 : _f2["30d_referee_rebate"], { fix: 2, fallback: "--" }) }), jsx(Q$1, { className: "oui-text-xs oui-font-semibold oui-text-base-contrast-36", children: "(30D)" }), jsx(eo$4, { size: 18, color: "white", className: "oui-ml-auto", onClick: () => {
    var _a4;
    return (_a4 = e2 == null ? void 0 : e2.routerAdapter) == null ? void 0 : _a4.onRouteChange({ href: "/rewards/affiliate?tab=trader", name: t("tradingRewards.rewards") });
  } })] })] });
};
var qi$1 = (e2) => {
  var _a3, _b2, _c2;
  let { t } = ne$6(), o2 = (_a3 = e2.epochList) == null ? void 0 : _a3[1].curEpochInfo, i = o2 == null ? void 0 : o2.end_time, r3 = o2 == null ? void 0 : o2.epoch_id, a2 = o2 ? `${o2 == null ? void 0 : o2.epoch_token}`.toLowerCase() === "order" : void 0, s2 = (n4) => {
    !e2.isSignIn || e2.wrongNetwork ? (n4.stopPropagation(), n4.preventDefault(), vo$4.alert({ title: t("common.tips"), message: jsx(Q$1, { intensity: 54, children: e2.wrongNetwork ? t("connector.wrongNetwork.tooltip") : t("affiliate.connectWallet.tooltip") }) })) : e2.goToClaim();
  };
  return jsxs(z$3, { className: `
        oui-via-21.6% 
        oui-via-83.23% 
        oui-relative 
        oui-h-[236px] 
        oui-w-full 
        oui-flex-col 
        oui-items-start
        oui-rounded-xl 
        oui-border 
        oui-border-solid 
        oui-border-[rgba(var(--oui-gradient-secondary-start)/0.36)] 
        oui-bg-gradient-to-r
        oui-from-[rgba(var(--oui-gradient-secondary-end)/0.12)]
        oui-to-[rgba(var(--oui-gradient-secondary-start)/0.12)]
        oui-p-3
      `, children: [jsxs(z$3, { className: "oui-w-full oui-flex-row oui-justify-between oui-items-center", children: [jsxs(z$3, { className: "oui-flex-col oui-items-start", children: [jsx(Q$1, { className: "oui-text-base-contrast oui-text-base oui-font-semibold oui-whitespace-pre max-[400px]:oui-text-[15px]", children: t("common.tradingRewards") }), jsx(Q$1, { className: "oui-text-2xs oui-font-normal oui-whitespace-pre oui-text-base-contrast-54", children: t("tradingRewards.subtitle.mm") })] }), jsx(Pp, {})] }), jsxs(z$3, { direction: "row", itemAlign: "center", className: "oui-mb-3 oui-mt-[35px] oui-w-full oui-justify-center oui-gap-1.5", children: [jsx(Q$1, { className: "oui-text-sm oui-font-normal oui-text-base-contrast-80", children: t("tradingRewards.epoch") }), jsx(Q$1, { className: "oui-text-base-contrast oui-text-sm oui-font-bold", children: r3 })] }), jsx(sc, { targetTimestamp: i }), jsxs(z$3, { className: "oui-mt-auto oui-w-full oui-flex-row oui-items-center oui-gap-1", children: [a2 ? jsx(sp, { className: "oui-size-5" }) : jsx(lp, { className: "oui-size-5" }), jsx(Q$1, { className: cnBase("oui-text-xs oui-font-semibold", isNumber((_b2 = e2 == null ? void 0 : e2.curEpochEstimate) == null ? void 0 : _b2.est_r_wallet) ? "oui-text-base-contrast" : "oui-text-base-contrast-36"), children: ((_c2 = e2 == null ? void 0 : e2.curEpochEstimate) == null ? void 0 : _c2.est_r_wallet) ?? "--" }), jsx(z$3, { className: "oui-ml-auto", children: jsx(eo$4, { size: 18, color: "white", className: "oui-ml-auto", onClick: s2 }) })] })] });
}, sc = ({ targetTimestamp: e2 }) => {
  let [t, o2] = useState({ days: 0, hours: 0, minutes: 0, seconds: 0 });
  return useEffect(() => {
    let i = setInterval(() => {
      if (typeof e2 > "u") return;
      let r3 = (/* @__PURE__ */ new Date()).getTime(), a2 = e2 - r3;
      if (a2 < 0) clearInterval(i), o2({ days: 0, hours: 0, minutes: 0, seconds: 0 });
      else {
        let s2 = Math.floor(a2 / 864e5), n4 = Math.floor(a2 % (1e3 * 60 * 60 * 24) / (1e3 * 60 * 60)), u2 = Math.floor(a2 % (1e3 * 60 * 60) / (1e3 * 60)), l2 = Math.floor(a2 % (1e3 * 60) / 1e3);
        o2({ days: s2, hours: n4, minutes: u2, seconds: l2 });
      }
    }, 1e3);
    return () => clearInterval(i);
  }, [e2]), jsxs(z$3, { direction: "row", itemAlign: "center", className: "oui-w-full oui-justify-around", children: [jsx(_t$1, { type: "D", value: t.days }), jsx(_t$1, { type: "H", value: t.hours }), jsx(_t$1, { type: "M", value: t.minutes }), jsx(_t$1, { type: "S", value: t.seconds })] });
}, _t$1 = ({ type: e2, value: t }) => jsxs(z$3, { direction: "column", itemAlign: "center", className: "oui-h-11 oui-w-8 oui-rounded-[6px] oui-bg-white/[0.08]", children: [jsx(Q$1, { className: "oui-text-base-contrast oui-text-base oui-font-bold", children: t }), jsx(Q$1, { className: "oui-text-2xs oui-font-normal oui-text-base-contrast-36", children: e2 })] });
var Ao$1 = (e2) => {
  let { canTrade: t, onWithdraw: o2, onDeposit: i, portfolioValue: r3, unrealPnL: a2, unrealROI: s2, visible: n4, namespace: u2, toggleVisible: l2 } = Me$1(), c = gi$1(), g2 = Yo$2(), y2 = useGetEnv(), m2 = () => {
    let d2 = `https://${y2 !== ENVType2.prod ? `${y2}-` : ""}app.orderly.network/tradingRewards`;
    window.open(d2, "_blank");
  };
  return jsxs(Fragment$1, { children: [jsx("div", { className: "oui-my-1 oui-px-3", children: jsx(Wi$1, {}) }), jsxs(z$3, { direction: "column", width: "100%", height: "100%", className: "oui-gap-5 oui-px-3", children: [jsx(Vi$1, { toggleVisible: l2, portfolioValue: r3, unrealPnL: a2, unrealROI: s2, visible: n4, canTrade: t, namespace: u2 }), jsx(Oi$1, { disabled: !t, onWithdraw: o2, onDeposit: i, routerAdapter: g2 == null ? void 0 : g2.routerAdapter }), jsxs(z$3, { direction: "row", width: "100%", height: "100%", className: "oui-gap-3", children: [jsxs(z$3, { direction: "column", className: "oui-flex-1 oui-gap-3", children: [jsx(zi$1, { referralInfo: c.referralInfo, routerAdapter: g2 == null ? void 0 : g2.routerAdapter }), jsx(Zi, { referralInfo: c.referralInfo, routerAdapter: g2 == null ? void 0 : g2.routerAdapter })] }), jsx(z$3, { direction: "column", className: "oui-flex-1", children: jsx(qi$1, { ...c, goToClaim: m2 }) })] }), jsx(Gi$1, { routerAdapter: g2 == null ? void 0 : g2.routerAdapter })] })] });
};
var Yi = () => {
  let { isMobile: e2 } = it$6();
  return jsx(ht$1, { children: e2 ? jsx(Ao$1, {}) : jsxs(Sa$1, { cols: 2, gap: 4, children: [jsx(We$3, {}), jsx(wt, {}), jsx(Sa$1.span, { colSpan: 2, children: jsx(je$2, {}) }), jsx(Sa$1.span, { colSpan: 2, children: jsx(oe$1, {}) })] }) });
};
var rr = {};
le$2(rr, { FeeTierPage: () => ir$1 });
var Io$2 = [{ tier: 1, maker_fee: "0.03%", taker_fee: "0.06%", volume_min: 0, volume_max: 5e5 }, { tier: 2, maker_fee: "0.02%", taker_fee: "0.05%", volume_min: 5e5, volume_max: 25e5 }, { tier: 3, maker_fee: "0.015%", taker_fee: "0.045%", volume_min: 25e5, volume_max: 1e7 }, { tier: 4, maker_fee: "0.01%", taker_fee: "0.04%", volume_min: 1e7, volume_max: 5e7 }, { tier: 5, maker_fee: "0.005%", taker_fee: "0.035%", volume_min: 5e7, volume_max: 125e6, or: "/", staking_min: 3e5, staking_max: null }, { tier: 6, maker_fee: "0%", taker_fee: "0.03%", volume_min: 125e6, volume_max: null, or: "/", staking: null, staking_min: null, staking_max: null }];
var Ji = () => {
  let { t: e2 } = ne$6();
  return useMemo(() => [{ title: e2("portfolio.feeTier.column.tier"), dataIndex: "tier", align: "left", width: 100 }, { title: `${e2("portfolio.feeTier.column.30dVolume")} (USDC)`, dataIndex: "volume", align: "center", width: 170, render: (o2, i) => {
    let { volume_min: r3, volume_max: a2, volume_node: s2 } = i;
    return s2 || (!r3 && !a2 ? jsx("div", { style: { fontVariantLigatures: "none" }, children: "--" }) : r3 && !a2 ? jsx("div", { children: e2("portfolio.feeTier.column.30dVolume.above", { volume: C$3(r3, r3 === 25e5 ? 1 : 0) }) }) : jsxs("div", { children: [r3 && C$3(r3, r3 === 25e5 ? 1 : 0), " - ", a2 && C$3(a2, a2 === 25e5 ? 1 : 0)] }));
  } }, { title: e2("portfolio.feeTier.column.maker"), dataIndex: "maker_fee", align: "right", width: 100, render: (o2) => jsx(Q$1, { children: o2 }) }, { title: e2("portfolio.feeTier.column.taker"), dataIndex: "taker_fee", align: "right", width: 100, render: (o2) => jsx(Q$1, { children: o2 }) }], [e2]);
};
function ji(e2) {
  let { dataAdapter: t } = e2 || {}, [o2, i] = useState(), { data: r3 } = useAccountInfo2(), { state: a2 } = useAccount(), s2 = Ji(), { data: n4 } = usePrivateQuery("/v1/volume/user/stats"), { columns: u2, dataSource: l2 } = useMemo(() => typeof t == "function" ? t(s2, Io$2) : { columns: s2, dataSource: Io$2 }, [t, s2]), c = (d2, p2) => {
    let { futures_taker_fee_rate: D2 = 0, futures_maker_fee_rate: z2 = 0 } = p2, O2 = `${new g$6(D2).mul(0.01).toString()}%`, k2 = `${new g$6(z2).mul(0.01).toString()}%`;
    for (let C2 of d2) if (O2 === C2.taker_fee && k2 === C2.maker_fee) return C2.tier;
  };
  useEffect(() => {
    if (!r3) return;
    let d2 = c(l2, r3);
    i(d2);
  }, [r3, l2]);
  let g2 = useMemo(() => {
    let d2 = r3 == null ? void 0 : r3.futures_taker_fee_rate;
    if (!(typeof d2 > "u")) return `${new g$6(d2).mul(0.01).toString()}%`;
  }, [r3]), y2 = useMemo(() => {
    let d2 = r3 == null ? void 0 : r3.futures_maker_fee_rate;
    if (!(typeof d2 > "u")) return `${new g$6(d2).mul(0.01).toString()}%`;
  }, [r3]);
  return { ...Tr$2({ tier: o2, vol: n4 == null ? void 0 : n4.perp_volume_last_30_days, takerFeeRate: g2, makerFeeRate: y2 }, { accountStatus: a2.status === AccountStatusEnum.EnableTradingWithoutConnected ? AccountStatusEnum.EnableTradingWithoutConnected : AccountStatusEnum.EnableTrading }), columns: u2, dataSource: l2, onRow: e2 == null ? void 0 : e2.onRow };
}
var tr$1 = (e2) => {
  let { columns: t, dataSource: o2, tier: i, vol: r3, takerFeeRate: a2, makerFeeRate: s2 } = e2, { t: n4 } = ne$6();
  return jsxs(Kl, { title: jsxs(z$3, { justify: "between", children: [jsx(Q$1, { size: "lg", children: n4("portfolio.feeTier") }), jsxs(z$3, { gap: 1, children: [jsx(Q$1, { size: "xs", intensity: 54, children: n4("portfolio.feeTier.updatedDailyBy") }), jsx(Q$1, { size: "xs", intensity: 80, children: "2:00 UTC" })] })] }), className: "w-full", id: "oui-portfolio-fee-tier", children: [jsx(de$5, {}), jsx(Nc, { tier: i, vol: r3, takerFeeRate: a2, makerFeeRate: s2 }), jsx(kc, { dataSource: o2, columns: t, tier: i, onRow: e2.onRow })] });
}, Nc = (e2) => {
  let { t } = ne$6();
  return jsxs(z$3, { direction: "row", gapX: 4, my: 4, itemAlign: "stretch", children: [jsx(Kt$1, { label: t("portfolio.feeTier.header.yourTier"), value: jsx(Q$1.gradient, { color: "brand", angle: 270, size: "base", children: e2.tier || "--" }) }), jsx(Kt$1, { label: `${t("portfolio.feeTier.header.30dVolume")} (USDC)`, value: jsx(Q$1.numeral, { rule: "price", dp: 2, rm: g$6.ROUND_DOWN, children: typeof e2.vol !== void 0 ? `${e2.vol}` : "-" }) }), jsx(Kt$1, { label: t("portfolio.feeTier.header.takerFeeRate"), value: jsx(Q$1.gradient, { color: "brand", angle: 270, size: "base", children: e2.takerFeeRate || "--" }) }), jsx(Kt$1, { label: t("portfolio.feeTier.header.makerFeeRate"), value: jsx(Q$1.gradient, { color: "brand", angle: 270, size: "base", children: e2.makerFeeRate || "--" }) })] });
}, Kt$1 = (e2) => jsxs(W$2, { gradient: "neutral", r: "lg", px: 4, py: 2, angle: 184, width: "100%", border: true, borderColor: 6, children: [jsx(Q$1, { as: "div", intensity: 36, size: "2xs", weight: "semibold", className: "oui-leading-[18px]", children: e2.label }), jsx(Q$1, { size: "base", intensity: 80, className: "oui-leading-[24px] oui-mt-[2px]", children: e2.value })] }), kc = (e2) => {
  let [t, o2] = useState(void 0);
  useEffect(() => {
    var _a3, _b2;
    let r3 = (_a3 = document.getElementById("oui-fee-tier-content")) == null ? void 0 : _a3.getBoundingClientRect(), a2 = (_b2 = document.getElementById("oui-fee-tier-current")) == null ? void 0 : _b2.getBoundingClientRect();
    if (a2 && r3 && e2.tier) {
      let s2 = a2.top - r3.top;
      o2(s2);
    } else o2(void 0);
  }, [e2.tier]);
  let i = useCallback((r3, a2) => {
    var _a3;
    let s2 = ((_a3 = e2 == null ? void 0 : e2.onRow) == null ? void 0 : _a3.call(e2, r3, a2)) ?? { normal: void 0, active: void 0 };
    return a2 + 1 == e2.tier ? { ...{ id: "oui-fee-tier-current", "data-state": "active", className: "group oui-h-12 oui-text-[rgba(0,0,0,0.88)] oui-pointer-events-none" }, ...s2.active } : { "data-state": "none", className: "oui-h-12", ...s2.normal };
  }, [e2.tier, e2.onRow]);
  return jsxs(W$2, { id: "oui-fee-tier-content", className: "oui-border-b oui-border-line-4 oui-relative", children: [t && jsx(W$2, { angle: 90, gradient: "brand", className: "oui-rounded-md oui-absolute oui-w-full", style: { top: `${t}px`, height: "48px" } }), jsx(L1, { bordered: true, className: "oui-font-semibold", classNames: { root: "oui-bg-transparent" }, onRow: i, columns: e2.columns, dataSource: e2.dataSource })] });
};
var or$2 = (e2) => {
  let t = ji(e2);
  return jsx(tr$1, { ...t });
};
var ir$1 = (e2) => jsx(or$2, { ...e2 });
var sr$2 = {};
le$2(sr$2, { PositionsPage: () => Bc });
var Bc = (e2) => {
  let [t, o2] = useState("Positions"), { t: i } = ne$6();
  return jsxs(z$3, { direction: "column", itemAlign: "start", gap: 4, width: "100%", height: "100%", children: [jsx(z$3, { children: jsx(Q$1, { size: "lg", children: i("common.positions") }) }), jsx(de$5, { className: "oui-w-full" }), jsx(W$2, { width: "100%", className: "oui-h-[calc(100%_-_59px)]", children: jsxs(jl, { value: t, onValueChange: (r3) => o2(r3), classNames: { tabsList: "!oui-border-none oui-pb-1", tabsContent: "oui-h-[calc(100%_-_28px)]" }, className: "oui-h-full", children: [jsx($l, { value: "Positions", title: i("common.positions"), children: jsx(Gr$2, { ...e2 }) }), jsx($l, { value: "Position history", title: i("positions.positionHistory"), children: jsx(Ls, { ...e2 }) }), jsx($l, { value: "Liquidation", title: i("positions.liquidation"), children: jsx(js$1, {}) })] }) })] });
};
var ur$2 = {};
le$2(ur$2, { OrdersPage: () => Xc });
var Xc = (e2) => {
  let { sharePnLConfig: t } = e2, { t: o2 } = ne$6(), i = useRef(null), r3 = () => {
    var _a3, _b2;
    (_b2 = (_a3 = i.current) == null ? void 0 : _a3.download) == null ? void 0 : _b2.call(_a3);
  };
  return jsxs(z$3, { direction: "column", itemAlign: "start", gap: 4, width: "100%", height: "100%", children: [jsxs(z$3, { width: "100%", justify: "between", children: [jsx(Q$1, { size: "lg", children: o2("common.orders") }), jsx(xs, { content: o2("orders.download.tooltip"), children: jsxs($e$6, { color: "gray", size: "sm", className: "oui-bg-base-4", onClick: r3, children: [o2("common.download"), jsx(Jc, { className: "oui-text-base-contrast-36 oui-ml-[5px]" })] }) })] }), jsx(de$5, { className: "oui-w-full" }), jsx(W$2, { width: "100%", className: "oui-h-[calc(100%_-_59px)]", children: jsx(Ks, { ref: i, sharePnLConfig: t }) })] });
}, Jc = (e2) => jsx("svg", { width: "12", height: "12", viewBox: "0 0 12 12", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...e2, children: jsx("path", { d: "M5.999 1.007a5 5 0 1 0 0 10 5 5 0 0 0 0-10m0 2.5a.5.5 0 1 1 0 1 .5.5 0 0 1 0-1m0 1.5a.5.5 0 0 1 .5.5v2.5a.5.5 0 0 1-1 0v-2.5a.5.5 0 0 1 .5-.5" }) });
var Ar$1 = {};
le$2(Ar$1, { APIManagerPage: () => Pr, APIManagerWidget: () => Zt$2 });
var dr$1 = (e2) => {
  var _a3;
  let { filterTags: t, keyStatus: o2 } = e2 ?? {}, [i, r3] = useState(false), [a2, s2] = useState(false), [n4, u2] = useState(), { configStore: l2 } = useContext(OrderlyContext), c = l2.get("brokerId"), { wrongNetwork: g2, disabledConnect: y2 } = L$3(), { state: m2, account: d2 } = useAccount(), { t: p2 } = ne$6(), D2 = !g2 && !y2 && (m2.status === AccountStatusEnum.EnableTrading || m2.status === AccountStatusEnum.EnableTradingWithoutConnected), { data: z2 } = useQuery(`/v1/get_account?address=${d2.address}&broker_id=${c}&chain_type=${(_a3 = d2.walletAdapter) == null ? void 0 : _a3.chainNamespace}`), [O2, { generateOrderlyKey: k2, setIPRestriction: C2, removeOrderlyKey: st2, resetOrderlyKeyIPRestriction: T2, refresh: f2, isLoading: b2, error: S2 }] = useApiKeyManager({ keyInfo: { key_status: o2 } }), [v3, I2] = useState(void 0);
  useEffect(() => {
    var _a4;
    (_a4 = d2.keyStore.getOrderlyKey()) == null ? void 0 : _a4.getPublicKey().then((P2) => {
      I2(P2);
    });
  }, [d2, m2]);
  let Ee2 = () => {
    r3(true);
  }, He2 = () => {
    window.open("https://orderly.network/docs/build-on-evm/evm-api/api-authentication", "_blank");
  }, Go2 = () => {
    r3(false);
  }, Or2 = async (P2, B2) => {
    var _a4;
    try {
      let R2 = (Yt2, lt2) => {
        var _a5;
        let { key: ta2, secretKey: oa2 } = Yt2;
        Go2(), u2({ key: ta2, screctKey: oa2, ip: lt2, permissions: (_a5 = B2 == null ? void 0 : B2.split(",")) == null ? void 0 : _a5.map((ia2) => Mo$1(ia2)).join(", ") }), s2(true);
      }, U2 = await k2(B2);
      if (toast$2.success(p2("portfolio.apiKey.created")), ((P2 == null ? void 0 : P2.length) || 0) > 0) {
        let Yt2 = U2.key.startsWith("ed25519:") ? U2.key : `ed25519:${U2.key}`, lt2 = await C2(Yt2, P2);
        lt2.success && R2(U2, (_a4 = lt2.data.ip_restriction_list) == null ? void 0 : _a4.join(","));
      } else R2(U2, void 0);
    } catch (R2) {
      (R2 == null ? void 0 : R2.message) && toast$2.error(R2 == null ? void 0 : R2.message);
    }
    return Promise.resolve(0);
  }, $o2 = () => {
    s2(false), f2();
  }, Br2 = () => {
    navigator.clipboard.writeText(JSON.stringify(n4)), toast$2.success(p2("portfolio.apiKey.apiInfo.copied"));
  }, Ur2 = () => {
    $o2();
  }, Vr2 = (P2) => new Promise(async (B2) => {
    await st2(P2.orderly_key).then(async (R2) => {
      var _a4;
      if (R2 == null ? void 0 : R2.success) {
        toast$2.success(p2("portfolio.apiKey.deleted")), f2();
        let U2 = await ((_a4 = d2.keyStore.getOrderlyKey()) == null ? void 0 : _a4.getPublicKey());
        P2.orderly_key === U2 && d2.destroyOrderlyKey();
      }
      B2(1);
    }, (R2) => {
    }).catch((R2) => {
    });
  }), Gr2 = async (P2, B2) => {
    let R2;
    ((B2 == null ? void 0 : B2.length) || 0) === 0 ? R2 = T2(P2.orderly_key, "ALLOW_ALL_IPS") : R2 = C2(P2.orderly_key, B2);
    let U2 = await R2;
    return U2.success ? (toast$2.success(p2("portfolio.apiKey.updated")), f2(), Promise.resolve()) : (toast$2.error(U2.message), Promise.reject());
  }, $r2 = () => toast$2.success(p2("portfolio.apiKey.accountId.copied")), Zr2 = (P2) => {
    typeof P2 < "u" && navigator.clipboard.writeText(P2.replace("ed25519:", "")), toast$2.success(p2("portfolio.apiKey.column.apiKey.copy"));
  }, qr2 = () => toast$2.success(p2("portfolio.apiKey.secretKey.copied")), Yr2 = () => toast$2.success(p2("portfolio.apiKey.column.restrictedIP.copy")), Qr2 = useMemo(() => O2 == null ? void 0 : O2.filter((P2) => {
    let B2 = t ? t == null ? void 0 : t.includes(P2.tag) : true, R2 = v3 ? !P2.orderly_key.includes(v3) : true;
    return B2 && R2;
  }), [O2, t, v3]), Xr2 = (P2) => /^((25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])(,((25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9]))*$/.test(P2) ? "" : "The IP restriction format is incorrect. Please use the correct format: [xx.xx.xxx.x],[xx.xxx.xxx.xxx]", Zo2 = m2.status === AccountStatusEnum.EnableTradingWithoutConnected ? AccountStatusEnum.EnableTradingWithoutConnected : AccountStatusEnum.EnableTrading, Jr2 = Tr$2(z2 == null ? void 0 : z2.account_id, { accountStatus: Zo2 }), jr2 = Tr$2(z2 == null ? void 0 : z2.user_id, { accountStatus: Zo2 }), { pagination: ea2 } = p0();
  return { address: Jr2 ?? "--", uid: `${jr2 ?? "--"}`, onCreateApiKey: Ee2, onReadApiGuide: He2, showCreateDialog: i, hideCreateDialog: Go2, doCreate: Or2, showCreatedDialog: a2, hideCreatedDialog: $o2, onCopyApiKeyInfo: Br2, doConfirm: Ur2, doDelete: Vr2, doEdit: Gr2, canCreateApiKey: D2, status: m2.status, keys: Qr2, generateKey: n4, onCopyAccountId: $r2, wrongNetwork: g2, onCopyApiKey: Zr2, onCopyApiSecretKey: qr2, onCopyIP: Yr2, verifyIP: Xr2, isLoading: b2, pagination: ea2 };
};
function Mo$1(e2) {
  return e2.charAt(0).toUpperCase() + e2.slice(1);
}
var fr$2 = (e2) => {
  let [t, o2] = useState(""), [i, r3] = useState(true), [a2, s2] = useState(true), [n4, u2] = useState(""), { t: l2 } = ne$6();
  return useEffect(() => {
    e2.showCreateDialog || (o2(""), r3(true), s2(true), u2(""));
  }, [e2.showCreateDialog]), useEffect(() => {
    t.length === 0 && u2("");
  }, [t]), jsx(Se$5, { size: "sm", open: e2.showCreateDialog, onOpenChange: (c) => {
    var _a3;
    (_a3 = e2.hideCreateDialog) == null ? void 0 : _a3.call(e2);
  }, title: l2("portfolio.apiKey.create.dialog.title"), actions: { primary: { label: l2("common.confirm"), className: "oui-w-[120px] lg:oui-w-[154px]", "data-testid": "oui-testid-apiKey-createApiKey-dialog-comfirm-btn", onClick: async () => {
    if (t.length > 0) {
      let g2 = e2.verifyIP(t);
      if (u2(g2), g2.length > 0) return;
    }
    let c = [];
    i && c.push("read"), a2 && c.push("trading"), await e2.doCreate(t, c.join(","));
  }, disabled: !a2 && !i, size: "md" } }, classNames: { footer: "oui-justify-center", content: "oui-bg-base-8 oui-w-[300px] lg:oui-w-[360px] oui-font-semibold" }, children: jsxs(z$3, { direction: "column", gap: 6, children: [jsxs(z$3, { direction: "column", gap: 1, width: "100%", itemAlign: "start", children: [jsx(Q$1, { intensity: 54, size: "2xs", children: l2("portfolio.apiKey.create.ipRestriction") }), jsx("textarea", { "data-testid": "oui-testid-apiKey-createApiKey-dialog-textarea", placeholder: l2("portfolio.apiKey.create.ipRestriction.placeholder"), className: cnBase("oui-text-sm oui-text-base-contrast-80 oui-p-3 oui-h-[100px] oui-rounded-xl oui-bg-base-6 oui-w-full", "oui-border-0 focus:oui-border-2 focus:oui-border-primary-darken oui-outline-none", "oui-placeholder-base-contrast-20", n4.length > 0 && "oui-outline-1 oui-outline-danger focus:oui-outline-none"), value: t, onChange: (c) => {
    o2(c.target.value);
  }, style: { resize: "none" } }), n4.length > 0 && jsxs(z$3, { gap: 1, className: "oui-relative", children: [jsx("div", { className: cnBase("oui-absolute oui-top-[10px]", "oui-h-1 oui-w-1 oui-rounded-full oui-bg-danger") }), jsx(Q$1, { color: "danger", size: "xs", className: "oui-ml-2", children: n4 })] })] }), jsx(za$1, { label: jsx(Q$1, { size: "xs", intensity: 54, children: l2("portfolio.apiKey.permissions") }), className: "oui-w-full", children: jsxs(z$3, { direction: "row", gap: 6, itemAlign: "start", className: "oui-mt-2", children: [jsx(it$2, { size: 18, checked: i, onCheckedChange: (c) => r3(c), label: l2("portfolio.apiKey.permissions.read"), testid: "oui-testid-apiKey-createApiKey-dialog-read-checkbox" }), jsx(it$2, { size: 18, checked: a2, onCheckedChange: (c) => s2(c), label: l2("portfolio.apiKey.permissions.trading"), testid: "oui-testid-apiKey-createApiKey-dialog-trading-checkbox" })] }) })] }) });
}, it$2 = (e2) => jsxs("button", { disabled: e2.disabled, onClick: (t) => {
  e2.onCheckedChange(!e2.checked);
}, className: "disabled:oui-cursor-not-allowed disabled:oui-opacity-50 oui-flex oui-items-center oui-gap-2", "data-testid": e2.testid, children: [e2.checked ? jsx("svg", { width: "props.size", height: e2.size, viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M6.99072 2.92981C4.78172 2.92981 2.99072 4.72071 2.99072 6.92981V16.9298C2.99072 19.1389 4.78172 20.9298 6.99072 20.9298H16.9907C19.1997 20.9298 20.9907 19.1389 20.9907 16.9298V6.92981C20.9907 4.72071 19.1997 2.92981 16.9907 2.92981H6.99072ZM16.9853 7.31211C17.2125 7.09537 17.5236 7 17.8218 7C18.1201 7 18.4312 7.09537 18.6584 7.31211C19.1139 7.74546 19.1139 8.47384 18.6584 8.9072L10.5077 16.675C10.0534 17.1083 9.28909 17.1083 8.83472 16.675L5.34077 13.3459C4.88641 12.9126 4.88641 12.1841 5.34077 11.7508C5.79631 11.3175 6.56057 11.3175 7.01493 11.7508L9.67122 14.2822L16.9853 7.31211Z", fill: "white", fillOpacity: "0.54" }) }) : jsx("svg", { width: e2.size, height: e2.size, viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: jsx("path", { d: "M6.99072 2.92981C4.78172 2.92981 2.99072 4.72071 2.99072 6.92981V16.9298C2.99072 19.1389 4.78172 20.9298 6.99072 20.9298H16.9907C19.1997 20.9298 20.9907 19.1389 20.9907 16.9298V6.92981C20.9907 4.72071 19.1997 2.92981 16.9907 2.92981H6.99072ZM6.99072 4.92981H16.9907C18.0957 4.92981 18.9907 5.82521 18.9907 6.92981V16.9298C18.9907 18.0344 18.0957 18.9298 16.9907 18.9298H6.99072C5.88572 18.9298 4.99072 18.0344 4.99072 16.9298V6.92981C4.99072 5.82521 5.88572 4.92981 6.99072 4.92981Z", fill: "white", fillOpacity: "0.54" }) }), jsx(Q$1, { intensity: 54, size: "sm", className: "oui-break-normal oui-whitespace-nowrap", children: e2.label })] });
var xr = (e2) => {
  var _a3, _b2, _c2, _d3;
  let t = ((_a3 = e2.generateKey) == null ? void 0 : _a3.ip) ?? "--", { t: o2 } = ne$6();
  return jsx(Se$5, { size: "sm", open: e2.showCreatedDialog, onOpenChange: (i) => {
    var _a4;
    (_a4 = e2.hideCreatedDialog) == null ? void 0 : _a4.call(e2);
  }, title: o2("portfolio.apiKey.created"), actions: { primary: { label: o2("common.ok"), "data-testid": "oui-testid-apiKey-createdApiKey-dialog-ok-btn", className: "oui-w-[120px] lg:oui-w-[154px] oui-bg-base-2 hover:oui-bg-base-3", size: "md", onClick: async () => e2.doConfirm() }, secondary: { label: o2("portfolio.apiKey.created.button.copyApiInfo"), "data-testid": "oui-testid-apiKey-createdApiKey-dialog-copy-btn", className: "oui-w-[120px] lg:oui-w-[154px] oui-bg-primary-darken hover:oui-opacity-80", size: "md", onClick: async () => e2.onCopyApiKeyInfo() } }, classNames: { footer: "oui-justify-center", content: "oui-bg-base-8 oui-w-[300px] lg:oui-w-[360px] oui-font-semibold", body: "oui-py-0 oui-pt-5" }, children: jsxs(z$3, { direction: "column", gap: 4, itemAlign: "start", children: [jsx(za$1, { label: o2("portfolio.apiKey.accountId"), children: jsx(Q$1.formatted, { size: "sm", intensity: 80, copyable: true, copyIconSize: 16, className: "oui-break-all", onCopy: e2.onCopyAccountId, "data-testid": "oui-testid-apiKey-createdApiKey-dialog-key-span", children: e2.address }) }), jsx(za$1, { label: o2("portfolio.apiKey.column.apiKey"), children: jsx(Q$1.formatted, { size: "sm", intensity: 80, copyable: true, copyIconSize: 16, className: "oui-break-all", onCopy: () => {
    var _a4;
    return e2.onCopyApiKey((_a4 = e2.generateKey) == null ? void 0 : _a4.key);
  }, "data-testid": "oui-testid-apiKey-createdApiKey-dialog-key-span", children: (_b2 = e2.generateKey) == null ? void 0 : _b2.key }) }), jsxs(za$1, { label: o2("portfolio.apiKey.secretKey"), children: [jsx(Q$1.formatted, { size: "sm", intensity: 80, copyable: true, copyIconSize: 16, className: "oui-break-all", onCopy: e2.onCopyApiSecretKey, children: (_c2 = e2.generateKey) == null ? void 0 : _c2.screctKey }), " "] }), jsx(za$1, { label: o2("portfolio.apiKey.ip"), children: jsxs(z$3, { width: 320, gap: 1, itemAlign: "center", className: "oui-text-base-contrast-80 oui-text-sm", children: [jsx(W$2, { className: "oui-max-h-[100px] oui-flex-1 oui-overflow-hidden oui-text-ellipsis oui-line-clamp-5 oui-break-all", children: t }), t !== "--" && jsx(W$2, { width: 16, height: 16, className: "oui-cursor-pointer oui-flex-shrink-0", children: jsx(bt$5, { color: "white", opacity: 0.54, size: 16, onClick: (i) => {
    var _a4, _b3;
    ((_a4 = e2.generateKey) == null ? void 0 : _a4.ip) && navigator.clipboard.writeText((_b3 = e2.generateKey) == null ? void 0 : _b3.ip), e2 == null ? void 0 : e2.onCopyIP();
  } }) })] }) }), jsx(za$1, { label: o2("portfolio.apiKey.permissions"), children: jsx(Q$1, { size: "sm", intensity: 80, "data-testid": "oui-testid-apiKey-createdApiKey-dialog-permissions-span", children: (_d3 = e2.generateKey) == null ? void 0 : _d3.permissions }) }), jsx("div", {}), jsx(Q$1, { color: "warning", size: "xs", className: "oui-text-center", children: o2("portfolio.apiKey.created.warning") })] }) });
};
var br$2 = (e2) => {
  let { item: t, open: o2, setOpen: i, onDelete: r3 } = e2, { t: a2 } = ne$6();
  return jsx(Se$5, { size: "sm", open: o2, onOpenChange: i, title: a2("portfolio.apiKey.delete.dialog.title"), actions: { primary: { label: a2("common.confirm"), "data-testid": "oui-testid-apiKey-deleteApiKey-dialog-confirm-btn", className: "oui-w-[120px] lg:oui-w-[154px]", size: "md", onClick: async () => {
    var _a3;
    await ((_a3 = e2.onDelete) == null ? void 0 : _a3.call(e2, t)), i(false);
  } }, secondary: { label: a2("common.cancel"), className: "oui-w-[120px] lg:oui-w-[154px]", size: "md", onClick: async () => {
    i(false);
  } } }, classNames: { footer: "oui-justify-center", content: "oui-bg-base-8 oui-w-[300px] lg:oui-w-[360px] oui-font-semibold" }, children: jsx(z$3, { className: "oui-text-xs", children: jsx(Trans, { i18nKey: "portfolio.apiKey.delete.dialog.description", values: { apiKey: Ko(t == null ? void 0 : t.orderly_key) }, components: [jsx(Q$1, { color: "primary", className: "oui-px-1" })] }) }) });
};
var vr$1 = (e2) => {
  var _a3;
  let { item: t, open: o2, setOpen: i, onUpdate: r3 } = e2, [a2, s2] = useState((_a3 = t.ip_restriction_list) == null ? void 0 : _a3.join(",")), [n4, u2] = useState(true), [l2, c] = useState(true), [g2, y2] = useState(""), { t: m2 } = ne$6();
  return useEffect(() => {
    var _a4, _b2;
    s2(t.ip_restriction_list.join(",")), u2(((_a4 = t.scope) == null ? void 0 : _a4.toLocaleLowerCase().includes("read")) || false), c(((_b2 = t.scope) == null ? void 0 : _b2.toLocaleLowerCase().includes("trading")) || false);
  }, [t]), useEffect(() => {
    a2.length === 0 && y2("");
  }, [a2]), jsx(Se$5, { size: "sm", open: o2, onOpenChange: i, title: m2("portfolio.apiKey.edit.dialog.title"), actions: { primary: { label: m2("common.confirm"), "data-testid": "oui-testid-apiKey-editApiKey-dialog-confirm-btn", className: "oui-w-[120px] lg:oui-w-[154px]", onClick: async () => {
    var _a4;
    if (a2.length > 0) {
      let d2 = e2.verifyIP(a2);
      if (y2(d2), d2.length > 0) return;
    }
    await ((_a4 = e2.onUpdate) == null ? void 0 : _a4.call(e2, t, a2)), i(false);
  }, disabled: t.ip_restriction_list.join(",") === a2, size: "md", fullWidth: true } }, classNames: { footer: "oui-justify-center", content: "oui-bg-base-8 oui-w-[300px] lg:oui-w-[360px] oui-font-semibold" }, children: jsxs(z$3, { direction: "column", gap: 6, children: [jsxs(z$3, { direction: "column", gap: 1, width: "100%", itemAlign: "start", children: [jsx(Q$1, { intensity: 54, size: "2xs", children: m2("portfolio.apiKey.create.ipRestriction") }), jsx("textarea", { "data-testid": "oui-testid-apiKey-editApiKey-dialog-textarea", placeholder: m2("portfolio.apiKey.create.ipRestriction.placeholder"), className: cnBase("oui-text-sm oui-text-base-contrast-80 oui-p-3 oui-h-[100px] oui-rounded-xl oui-bg-base-6 oui-w-full", "oui-border-0 focus:oui-border-2 focus:oui-border-primary-darken oui-outline-none", "oui-placeholder-base-contrast-20", g2.length > 0 && "oui-outline-1 oui-outline-danger focus:oui-outline-none"), value: a2, onChange: (d2) => {
    s2(d2.target.value);
  }, style: { resize: "none" } }), g2.length > 0 && jsxs(z$3, { gap: 1, className: "oui-relative", children: [jsx("div", { className: cnBase("oui-absolute oui-top-[10px]", "oui-h-1 oui-w-1 oui-rounded-full oui-bg-danger") }), jsx(Q$1, { color: "danger", size: "xs", className: "oui-ml-2", children: g2 })] })] }), jsx(za$1, { label: jsx(Q$1, { size: "xs", intensity: 54, children: m2("portfolio.apiKey.permissions") }), className: "oui-w-full", children: jsxs(z$3, { direction: "row", gap: 6, itemAlign: "start", className: "oui-mt-2", children: [jsx(it$2, { disabled: true, size: 18, checked: n4, onCheckedChange: (d2) => u2(d2), label: m2("portfolio.apiKey.permissions.read") }), jsx(it$2, { disabled: true, size: 18, checked: l2, onCheckedChange: (d2) => c(d2), label: m2("portfolio.apiKey.permissions.trading") })] }) })] }) });
};
var Tr = (e2) => {
  let { t } = ne$6();
  return jsxs(Kl, { title: t("portfolio.apiKeys"), id: "portfolio-apikey-manager", className: "oui-bg-base-9 oui-font-semibold", children: [jsxs(z$3, { direction: "column", gap: 4, width: "100%", className: "oui-font-semibold", children: [jsx(Dd, { ...e2 }), jsx(Rd, { ...e2 })] }), jsxs("div", { children: [jsx(_d, { ...e2 }), jsx(fr$2, { ...e2 }), jsx(xr, { ...e2 })] })] });
}, Dd = (e2) => {
  let { t } = ne$6();
  return jsxs(z$3, { width: "100%", gap: 4, className: "oui-border-t-2 oui-border-line-6 oui-pt-4", children: [jsxs(z$3, { py: 2, px: 4, direction: "column", itemAlign: "start", r: "xl", gradient: "neutral", angle: 27, border: true, className: "oui-w-1/2", children: [jsx(Q$1, { size: "xs", intensity: 36, children: t("portfolio.apiKey.accountId") }), jsx(Q$1.formatted, { size: "base", inlist: 80, rule: "address", copyable: e2.address !== "--", copyIconSize: 16, onCopy: e2.onCopyAccountId, copyIconTestid: "oui-testid-apiKey-accountInfo-accountId-copy-btn", children: e2.address })] }), jsxs(z$3, { py: 2, px: 4, direction: "column", itemAlign: "start", r: "xl", gradient: "neutral", angle: 27, border: true, className: "oui-w-1/2", children: [jsx(Q$1, { size: "xs", intensity: 36, children: t("portfolio.apiKey.uid") }), jsx(Q$1, { size: "base", inlist: 80, children: e2.uid })] })] });
}, Rd = (e2) => {
  let { t } = ne$6();
  return jsxs(z$3, { width: "100%", direction: "row", className: "oui-text-sm oui-border-b-2 oui-border-line-6 oui-pb-4", children: [jsxs(z$3, { direction: "column", itemAlign: "start", width: "100%", gap: 1, children: [jsx(Q$1, { intensity: 54, children: t("portfolio.apiKey.description") }), jsxs(z$3, { itemAlign: "center", className: "oui-text-primary-light oui-fill-primary-light hover:oui-text-primary-darken oui-cursor-pointer oui-text-2xs md:oui-text-xs xl:oui-text-sm", onClick: e2.onReadApiGuide, children: [jsx(Q$1, { children: t("portfolio.apiKey.readApiGuide") }), jsx("svg", { width: "16", height: "16", viewBox: "0 0 16 16", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", children: jsx("path", { d: "M4.008 7.995c0-.368.298-.666.666-.666H9.71L7.733 5.331l.937-.936 3.143 3.122c.13.13.195.304.195.479a.67.67 0 0 1-.195.478L8.67 11.596l-.937-.937 1.978-1.998H4.674a.666.666 0 0 1-.666-.666" }) })] })] }), jsx(ge$2, { side: "top", tooltip: { connectWallet: t("portfolio.apiKey.create.connectWallet.tooltip"), signIn: t("portfolio.apiKey.create.signIn.tooltip"), enableTrading: t("portfolio.apiKey.create.enableTrading.tooltip"), wrongNetwork: t("portfolio.apiKey.create.wrongNetwork.tooltip") }, children: jsx($e$6, { size: "md", icon: jsx(ln$1, {}), variant: "contained", color: "primary", onClick: e2.onCreateApiKey, disabled: !e2.canCreateApiKey, "data-testid": "oui-testid-apiKey-createApiKey-btn", children: t("portfolio.apiKey.create.dialog.title") }) })] });
}, _d = (e2) => {
  let { t } = ne$6(), o2 = [{ title: t("portfolio.apiKey.column.apiKey"), dataIndex: "orderly_key", render: (i) => jsx(Q$1.formatted, { rule: "", copyable: true, copyIconSize: 16, onCopy: () => {
    var _a3;
    (_a3 = e2.onCopyApiKey) == null ? void 0 : _a3.call(e2, i);
  }, children: Ko(i) }) }, { title: t("portfolio.apiKey.column.permissionType"), dataIndex: "scope", render: (i) => i == null ? void 0 : i.split(",").map((r3) => Mo$1(`${r3}`)).join(", ") }, { title: t("portfolio.apiKey.column.restrictedIP"), dataIndex: "ip_restriction_list", render: (i) => {
    let r3 = i.join(",");
    return r3.length === 0 && (r3 = "--"), jsx(xs, { content: r3, className: "oui-max-w-[200px] oui-break-all", children: jsxs(z$3, { gap: 1, children: [jsx("div", { className: " oui-overflow-ellipsis oui-overflow-hidden", children: r3 }), r3 !== "--" && jsx(W$2, { width: 16, height: 16, className: "oui-cursor-pointer", children: jsx(bt$5, { color: "white", opacity: 0.54, size: 16, onClick: (a2) => {
      navigator.clipboard.writeText(r3), e2 == null ? void 0 : e2.onCopyIP();
    } }) })] }) });
  } }, { title: t("portfolio.apiKey.column.expirationDate"), dataIndex: "expiration", render: (i) => jsx(Q$1.formatted, { rule: "date", formatString: "yyyy-MM-dd", children: i }) }, { title: "", type: "action", dataIndex: "action", width: 120, render: (i, r3) => jsxs(z$3, { direction: "row", gap: 2, children: [jsx(Ed, { item: r3, onUpdate: e2.doEdit, verifyIP: e2.verifyIP }), jsx(Hd, { item: r3, onDelete: e2.doDelete })] }) }];
  return jsx(dt$3, { bordered: true, columns: o2, loading: e2.isLoading, dataSource: e2.keys, emptyView: jsx(ce$7, {}), classNames: {}, pagination: e2.pagination, manualPagination: false });
}, Ed = (e2) => {
  let { item: t, onUpdate: o2, verifyIP: i } = e2, [r3, a2] = useState(false), { t: s2 } = ne$6();
  return jsxs(Fragment$1, { children: [jsx($e$6, { size: "xs", color: "primary", variant: "contained", onClick: (n4) => {
    n4.stopPropagation(), a2(true);
  }, "data-testid": "oui-testid-apiKey-keyList-edit-btn", children: s2("common.edit") }), r3 && jsx(vr$1, { item: t, open: r3, setOpen: a2, onUpdate: o2, verifyIP: i })] });
}, Hd = (e2) => {
  let { item: t, onDelete: o2 } = e2, [i, r3] = useState(false), { t: a2 } = ne$6();
  return jsxs(Fragment$1, { children: [jsx($e$6, { size: "xs", color: "gray", variant: "contained", onClick: (s2) => {
    s2.stopPropagation(), r3(true);
  }, "data-testid": "oui-testid-apiKey-keyList-delete-btn", children: a2("common.delete") }), i && jsx(br$2, { item: t, open: i, setOpen: r3, onDelete: o2 })] });
};
function Ko(e2) {
  return typeof e2 > "u" ? "-" : `${`${e2}`.replace("ed25519:", "").slice(0, 6)}*****`;
}
var Zt$2 = (e2) => {
  let t = dr$1(e2);
  return jsx(Tr, { ...t });
};
var Pr = (e2) => {
  let { filterTags: t, keyStatus: o2 = "ACTIVE" } = e2;
  return jsx(Zt$2, { filterTags: t, keyStatus: o2 });
};
var Mr$1 = {};
le$2(Mr$1, { SettingPage: () => Hr$2, SettingWidget: () => qt$1 });
var kr = (e2) => {
  let { t } = ne$6();
  return jsx(Kl, { title: t("portfolio.setting.systemUpgrade"), id: "portfolio-apikey-manager", className: "oui-bg-base-9 oui-font-semibold", children: jsxs(z$3, { direction: "row", gap: 4, width: "100%", itemAlign: "center", pt: 4, className: "oui-font-semibold oui-border-t-2 oui-border-line-6", children: [jsxs(z$3, { direction: "column", itemAlign: "start", className: "oui-flex-1", children: [jsx(Q$1, { intensity: 80, size: "base", children: t("portfolio.setting.cancelOpenOrders") }), jsx(Q$1, { intensity: 54, size: "sm", children: t("portfolio.setting.cancelOpenOrders.description") })] }), jsx(ge$2, { align: "end", children: jsx(di$2, { checked: e2.maintenance_cancel_orders, onCheckedChange: (o2) => {
    e2.setMaintainConfig(o2);
  }, disabled: e2.isSetting || !e2.canTouch, "data-testid": "oui-testid-setting-switch-btn" }) })] }) });
};
var Dr = (e2) => {
  let { t } = ne$6(), [o2, i] = useState(false);
  return jsxs(Fragment$1, { children: [jsxs(z$3, { className: "oui-flex-row oui-items-center oui-mt-1 oui-mb-2 oui-p-4 oui-bg-base-9 oui-rounded-xl", onClick: () => {
    i(true);
  }, children: [jsx(ht$3, { open: o2, setOpen: i }), jsx(Q$1, { className: "oui-text-base oui-font-semibold oui-text-base-contrast-80 oui-ml-2", children: t("languageSwitcher.language") }), jsx(eo$4, { size: 18, className: "oui-ml-auto oui-text-base-contrast-36" })] }), jsx(Kl, { title: jsx("div", { className: "oui-text-sm", children: t("portfolio.setting.systemUpgrade") }), id: "portfolio-apikey-manager", className: "oui-bg-base-9 oui-font-semibold", classNames: { root: "oui-p-4", content: "!oui-pt-3" }, children: jsx(z$3, { direction: "row", gap: 4, width: "100%", itemAlign: "center", pt: 3, className: "oui-font-semibold oui-border-t-2 oui-border-line-6", children: jsxs(z$3, { direction: "column", itemAlign: "start", className: "oui-flex-1 oui-gap-2", children: [jsx(Q$1, { intensity: 80, size: "xs", children: t("portfolio.setting.cancelOpenOrders") }), jsx(Q$1, { intensity: 36, size: "2xs", className: "oui-font-normal", children: t("portfolio.setting.cancelOpenOrders.description") }), jsx(ge$2, { children: jsx(di$2, { className: "oui-mt-1", checked: e2.maintenance_cancel_orders, onCheckedChange: (a2) => {
    e2.setMaintainConfig(a2);
  }, disabled: e2.isSetting || !e2.canTouch, "data-testid": "oui-testid-setting-switch-btn" }) })] }) }) })] });
};
var Rr$1 = (e2) => {
  let { isMobile: t } = it$6();
  return t ? jsx("div", { className: "oui-px-3", children: jsx(Dr, { ...e2 }) }) : jsx(kr, { ...e2 });
};
var Er$1 = () => {
  let { data: e2, mutate: t } = useAccountInfo2(), { wrongNetwork: o2, disabledConnect: i } = L$3(), [r3, { isMutating: a2 }] = useMutation("/v1/client/maintenance_config"), [s2, n4] = useState(false);
  useEffect(() => {
    n4((e2 == null ? void 0 : e2.maintenance_cancel_orders) || false);
  }, [e2]);
  let u2 = useDebouncedCallback((y2) => {
    r3({ maintenance_cancel_order_flag: y2 }).then((m2) => {
      m2.success ? toast$2.success(y2 ? "Opened" : "Closed") : n4(!y2);
    });
  }, 300), l2 = (y2) => {
    n4(y2), u2(y2);
  }, { state: c } = useAccount(), g2 = !o2 && !i && (c.status === AccountStatusEnum.EnableTrading || c.status === AccountStatusEnum.EnableTradingWithoutConnected);
  return { maintenance_cancel_orders: s2, setMaintainConfig: l2, isSetting: false, canTouch: g2 };
};
var qt$1 = () => {
  let e2 = Er$1();
  return jsx(Rr$1, { ...e2 });
};
var Hr$2 = () => jsx(qt$1, {});
var zr$2 = {};
le$2(zr$2, { HistoryPage: () => Kr$1, HistoryWidget: () => Lr$1 });
var Lr$1 = () => jsx(oe$1, {}), Kr$1 = () => jsx(oe$1, {});
var _excluded = ["prefixCls", "className", "children", "mode", "visiable", "visible", "renderBar", "lineBar", "disable", "onDragEnd", "onDragging"];
class Split extends ze__default__default.Component {
  constructor(props) {
    super(props);
    this.state = {
      dragging: false
    };
    this.warpper = void 0;
    this.paneNumber = void 0;
    this.startX = void 0;
    this.startY = void 0;
    this.move = void 0;
    this.target = void 0;
    this.boxWidth = void 0;
    this.boxHeight = void 0;
    this.preWidth = void 0;
    this.nextWidth = void 0;
    this.preHeight = void 0;
    this.nextHeight = void 0;
    this.preSize = void 0;
    this.nextSize = void 0;
    this.onDragEnd = this.onDragEnd.bind(this);
    this.onDragging = this.onDragging.bind(this);
  }
  componentWillUnmount() {
    this.removeEvent();
  }
  removeEvent() {
    window.removeEventListener("mousemove", this.onDragging, false);
    window.removeEventListener("mouseup", this.onDragEnd, false);
  }
  onMouseDown(paneNumber, env) {
    if (!env.target || !this.warpper) {
      return;
    }
    this.paneNumber = paneNumber;
    this.startX = env.clientX;
    this.startY = env.clientY;
    this.move = true;
    this.target = env.target.parentNode;
    var prevTarget = this.target.previousElementSibling;
    var nextTarget = this.target.nextElementSibling;
    this.boxWidth = this.warpper.clientWidth;
    this.boxHeight = this.warpper.clientHeight;
    if (prevTarget) {
      this.preWidth = prevTarget.clientWidth;
      this.preHeight = prevTarget.clientHeight;
    }
    if (nextTarget) {
      this.nextWidth = nextTarget.clientWidth;
      this.nextHeight = nextTarget.clientHeight;
    }
    window.addEventListener("mousemove", this.onDragging);
    window.addEventListener("mouseup", this.onDragEnd, false);
    this.setState({
      dragging: true
    });
  }
  onDragging(env) {
    if (!this.move) {
      return;
    }
    if (!this.state.dragging) {
      this.setState({
        dragging: true
      });
    }
    var {
      mode: mode2,
      onDragging
    } = this.props;
    var nextTarget = this.target.nextElementSibling;
    var prevTarget = this.target.previousElementSibling;
    var x2 = env.clientX - this.startX;
    var y2 = env.clientY - this.startY;
    this.preSize = 0;
    this.nextSize = 0;
    if (mode2 === "horizontal") {
      this.preSize = this.preWidth + x2 > -1 ? this.preWidth + x2 : 0;
      this.nextSize = this.nextWidth - x2 > -1 ? this.nextWidth - x2 : 0;
      if (this.preSize === 0 || this.nextSize === 0) {
        return;
      }
      this.preSize = (this.preSize / this.boxWidth >= 1 ? 1 : this.preSize / this.boxWidth) * 100;
      this.nextSize = (this.nextSize / this.boxWidth >= 1 ? 1 : this.nextSize / this.boxWidth) * 100;
      if (prevTarget && nextTarget) {
        prevTarget.style.width = this.preSize + "%";
        nextTarget.style.width = this.nextSize + "%";
      }
    }
    if (mode2 === "vertical" && this.preHeight + y2 > -1 && this.nextHeight - y2 > -1) {
      this.preSize = this.preHeight + y2 > -1 ? this.preHeight + y2 : 0;
      this.nextSize = this.nextHeight - y2 > -1 ? this.nextHeight - y2 : 0;
      this.preSize = (this.preSize / this.boxHeight >= 1 ? 1 : this.preSize / this.boxHeight) * 100;
      this.nextSize = (this.nextSize / this.boxHeight >= 1 ? 1 : this.nextSize / this.boxHeight) * 100;
      if (this.preSize === 0 || this.nextSize === 0) {
        return;
      }
      if (prevTarget && nextTarget) {
        prevTarget.style.height = this.preSize + "%";
        nextTarget.style.height = this.nextSize + "%";
      }
    }
    onDragging && onDragging(this.preSize, this.nextSize, this.paneNumber);
  }
  onDragEnd() {
    var {
      onDragEnd
    } = this.props;
    this.move = false;
    onDragEnd && onDragEnd(this.preSize, this.nextSize, this.paneNumber);
    this.removeEvent();
    this.setState({
      dragging: false
    });
  }
  render() {
    var _this$props$visible;
    var _this$props = this.props, {
      prefixCls,
      className,
      children,
      mode: mode2,
      visible = (_this$props$visible = this.props.visible) != null ? _this$props$visible : this.props.visiable,
      renderBar,
      lineBar,
      disable
    } = _this$props, other = _objectWithoutPropertiesLoose(_this$props, _excluded);
    var {
      dragging
    } = this.state;
    var cls = [prefixCls, className, prefixCls + "-" + mode2, dragging ? "dragging" : null].filter(Boolean).join(" ").trim();
    var child = ze__default__default.Children.toArray(children);
    return /* @__PURE__ */ jsx("div", _extends({
      className: cls
    }, other, {
      ref: (node) => this.warpper = node,
      children: ze__default__default.Children.map(child, (element, idx) => {
        var props = Object.assign({}, element.props, {
          className: [prefixCls + "-pane", element.props.className].filter(Boolean).join(" ").trim(),
          style: _extends({}, element.props.style)
        });
        var visibleBar = visible === true || visible && visible.includes(idx + 1) || false;
        var barProps = {
          className: [prefixCls + "-bar", lineBar ? prefixCls + "-line-bar" : null, !lineBar ? prefixCls + "-large-bar" : null].filter(Boolean).join(" ").trim()
        };
        if (disable === true || disable && disable.includes(idx + 1)) {
          barProps.className = [barProps.className, disable ? "disable" : null].filter(Boolean).join(" ").trim();
        }
        var BarCom = null;
        if (idx !== 0 && visibleBar && renderBar) {
          BarCom = renderBar(_extends({}, barProps, {
            onMouseDown: this.onMouseDown.bind(this, idx + 1)
          }));
        } else if (idx !== 0 && visibleBar) {
          BarCom = /* @__PURE__ */ ze__default__default.createElement("div", _extends({}, barProps), /* @__PURE__ */ jsx("div", {
            onMouseDown: this.onMouseDown.bind(this, idx + 1)
          }));
        }
        return /* @__PURE__ */ jsxs(ze__default__default.Fragment, {
          children: [BarCom, /* @__PURE__ */ ze__default__default.cloneElement(element, _extends({}, props))]
        }, idx);
      })
    }));
  }
}
Split.defaultProps = {
  prefixCls: "w-split",
  visiable: true,
  mode: "horizontal"
};
var Lo = createContext({}), E$1 = (e2) => {
  let [t, o2] = useState(""), a2 = useCallback(() => {
    o2("");
  }, []);
  return jsx(Lo.Provider, { value: { searchValue: t, onSearchValueChange: o2, clearSearchValue: a2, symbol: e2.symbol, onSymbolChange: e2.onSymbolChange }, children: e2.children });
};
function g$1() {
  return useContext(Lo);
}
var Do = (e2) => jsxs("svg", { width: "16", height: "16", viewBox: "0 0 16 16", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...e2, children: [jsx("mask", { id: "a", style: { maskType: "alpha" }, maskUnits: "userSpaceOnUse", x: "0", y: "0", width: "16", height: "16", children: jsx("path", { fill: "#D9D9D9", d: "M0 0h16v16H0z" }) }), jsx("g", { mask: "url(#a)", children: jsx("path", { d: "M3.333 12.667h.95L10.8 6.15l-.95-.95-6.517 6.517zM2.667 14a.65.65 0 0 1-.475-.192.65.65 0 0 1-.192-.475v-1.616a1.32 1.32 0 0 1 .383-.934l8.417-8.4q.2-.183.442-.283.24-.1.508-.1.267 0 .517.1.249.1.433.3l.917.933q.2.184.291.434a1.44 1.44 0 0 1 0 1.008 1.25 1.25 0 0 1-.291.442l-8.4 8.4a1.32 1.32 0 0 1-.933.383zm7.65-8.317L9.85 5.2l.95.95z" }) })] }), Ro = (e2) => jsx("svg", { width: "16", height: "16", viewBox: "0 0 16 16", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...e2, children: jsx("path", { d: "M7.205 1.334c-.345 0-.674.136-.918.38L6.001 2H2.667a.667.667 0 1 0 0 1.334h10.667a.667.667 0 1 0 0-1.334h-3.333l-.287-.286a1.3 1.3 0 0 0-.918-.38zM2.911 4.667l1.018 8.842c.088.66.656 1.158 1.322 1.158h5.498c.666 0 1.235-.497 1.323-1.163l1.019-8.837z" }) }), Bo$1 = (e2) => jsxs("svg", { width: "12", height: "12", viewBox: "0 0 12 12", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...e2, children: [jsx("mask", { id: "a", style: { maskType: "alpha" }, maskUnits: "userSpaceOnUse", x: "0", y: "0", width: "12", height: "12", children: jsx("path", { fill: "#D9D9D9", d: "M0 0h12v12H0z" }) }), jsx("g", { mask: "url(#a)", children: jsx("path", { d: "M8.5 10a.48.48 0 0 1-.356-.144A.48.48 0 0 1 8 9.5V7q0-.213.144-.356A.48.48 0 0 1 8.5 6.5h1q.212 0 .356.144A.48.48 0 0 1 10 7v2.5q0 .212-.144.356A.48.48 0 0 1 9.5 10zm-3 0a.48.48 0 0 1-.356-.144A.48.48 0 0 1 5 9.5v-7q0-.212.144-.356A.48.48 0 0 1 5.5 2h1q.213 0 .356.144A.48.48 0 0 1 7 2.5v7q0 .212-.144.356A.48.48 0 0 1 6.5 10zm-3 0a.48.48 0 0 1-.356-.144A.48.48 0 0 1 2 9.5V5q0-.213.144-.356A.48.48 0 0 1 2.5 4.5h1q.212 0 .356.144A.48.48 0 0 1 4 5v4.5q0 .212-.144.356A.48.48 0 0 1 3.5 10z" }) })] }), Oo$1 = (e2) => jsx("svg", { width: "12", height: "12", viewBox: "0 0 12 12", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...e2, children: jsx("path", { d: "M5.993.958a.416.416 0 0 0-.41.422v.416a.416.416 0 1 0 .832 0V1.38a.416.416 0 0 0-.422-.422M2.749 2.29a.416.416 0 0 0-.29.714l.291.292a.416.416 0 1 0 .589-.588l-.292-.292a.42.42 0 0 0-.298-.126m6.489 0a.42.42 0 0 0-.286.126l-.292.292a.416.416 0 1 0 .588.588l.292-.292a.416.416 0 0 0-.302-.714m-3.239.753a2.895 2.895 0 0 0-2.913 2.914A2.86 2.86 0 0 0 4.751 8.58v1.123c0 .458.374.833.832.833h.832a.835.835 0 0 0 .833-.833V8.58a2.86 2.86 0 0 0 1.665-2.622 2.895 2.895 0 0 0-2.914-2.914M1.421 5.541a.416.416 0 1 0 0 .833h.417a.416.416 0 1 0 0-.833zm8.74 0a.416.416 0 1 0 0 .833h.416a.417.417 0 1 0 0-.833zM3.037 8.492a.42.42 0 0 0-.287.126l-.291.292a.416.416 0 1 0 .588.588l.292-.292a.416.416 0 0 0-.302-.714m5.913 0a.416.416 0 0 0-.29.714l.292.292a.416.416 0 1 0 .588-.588l-.292-.292a.42.42 0 0 0-.298-.126" }) }), te2 = (e2) => jsxs("svg", { width: "20", height: "21", viewBox: "0 0 20 21", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...e2, children: [jsx("mask", { id: "a", style: { maskType: "alpha" }, maskUnits: "userSpaceOnUse", x: "0", y: "0", width: "20", height: "21", children: jsx("path", { fill: "#D9D9D9", d: "M0 .5h20v20H0z" }) }), jsx("g", { mask: "url(#a)", children: jsx("path", { d: "m10 14.074-3.2 1.913a.6.6 0 0 1-.332.068.6.6 0 0 1-.277-.101.5.5 0 0 1-.186-.256.5.5 0 0 1-.005-.336l.84-3.556-2.82-2.394a.5.5 0 0 1-.174-.281.6.6 0 0 1 .013-.315.5.5 0 0 1 .173-.252.55.55 0 0 1 .305-.112l3.693-.33 1.467-3.393a.57.57 0 0 1 .211-.255A.54.54 0 0 1 10 4.39q.16 0 .292.083.131.082.211.255l1.467 3.414 3.693.309q.178.014.305.123.126.11.173.262t.002.304a.56.56 0 0 1-.183.27l-2.8 2.395.84 3.556a.5.5 0 0 1-.005.336.5.5 0 0 1-.186.256.6.6 0 0 1-.277.101.6.6 0 0 1-.332-.068z" }) })] }), Ve2 = (e2) => jsxs("svg", { width: "20", height: "21", viewBox: "0 0 20 21", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...e2, children: [jsx("mask", { id: "a", style: { maskType: "alpha" }, maskUnits: "userSpaceOnUse", x: "0", y: "0", width: "20", height: "21", children: jsx("path", { fill: "#D9D9D9", d: "M0 .5h20v20H0z" }) }), jsx("g", { mask: "url(#a)", children: jsx("path", { d: "M7.333 14.396 10 12.813l2.688 1.583-.709-3 2.313-1.98-3.063-.27L10 6.292 8.77 9.146l-3.062.27 2.334 1.98zM10 14.074l-3.2 1.913a.6.6 0 0 1-.332.068.6.6 0 0 1-.277-.101.5.5 0 0 1-.186-.256.5.5 0 0 1-.005-.336l.84-3.556-2.82-2.394a.5.5 0 0 1-.174-.281.6.6 0 0 1 .013-.315.5.5 0 0 1 .173-.252.55.55 0 0 1 .305-.112l3.693-.33 1.467-3.393a.57.57 0 0 1 .211-.255A.54.54 0 0 1 10 4.39q.16 0 .292.083.131.082.211.255l1.467 3.414 3.693.309q.178.014.305.123.126.11.173.262t.002.304a.56.56 0 0 1-.183.27l-2.8 2.395.84 3.556a.5.5 0 0 1-.005.336.5.5 0 0 1-.186.256.6.6 0 0 1-.277.101.6.6 0 0 1-.332-.068z" }) })] });
var K = (e2) => jsx("svg", { width: "14", height: "14", viewBox: "0 0 14 14", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...e2, children: jsx("path", { d: "M5.841 1.14a4.667 4.667 0 0 0 0 9.333 4.74 4.74 0 0 0 2.875-.975l2.54 2.56a.6.6 0 0 0 .838 0 .6.6 0 0 0 0-.838L9.537 8.677a4.72 4.72 0 0 0 .971-2.871 4.667 4.667 0 0 0-4.667-4.667m0 1.166a3.5 3.5 0 1 1 0 7 3.5 3.5 0 0 1 0-7" }) }), Vo$1 = (e2) => jsx("svg", { width: "20", height: "21", viewBox: "0 0 20 21", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...e2, children: jsx("path", { d: "M10 5.5a.76.76 0 0 0-.583.25l-4.334 4c0 .083-.083.25-.083.333 0 .25.167.417.417.417h2.916v6.667c0 .416.334.833.834.833h1.666c.5 0 .834-.417.834-.833V10.5h2.916c.25 0 .417-.167.417-.417 0-.083-.083-.25-.083-.333l-4.25-4.084c-.25-.083-.417-.166-.667-.166M2.177 3.06A.8.8 0 0 1 2.5 3h15a.834.834 0 1 1 0 1.667h-15a.833.833 0 0 1-.323-1.607" }) }), ce$2 = (e2) => jsx("svg", { width: "12", height: "13", viewBox: "0 0 12 13", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...e2, children: jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M6.015.34h-.029a5.98 5.98 0 0 0-3.93 1.477c-.074.065-.027.184.072.184h7.745c.099 0 .146-.119.072-.184A5.98 5.98 0 0 0 6.015.341M3.48 7.866a.23.23 0 0 1 .187.1A2.85 2.85 0 0 0 6 9.178a2.85 2.85 0 0 0 2.334-1.213.23.23 0 0 1 .186-.1h3.104c.09 0 .155.086.13.172A6 6 0 0 1 6 12.327a6 6 0 0 1-5.755-4.29.134.134 0 0 1 .13-.172zM8.26 4.6a.29.29 0 0 0 .229.116h3.11c.09 0 .156-.086.13-.173a6 6 0 0 0-1.106-2.03.22.22 0 0 0-.165-.077H1.543a.22.22 0 0 0-.165.077 6 6 0 0 0-1.105 2.03.134.134 0 0 0 .13.173h3.11A.29.29 0 0 0 3.74 4.6 2.85 2.85 0 0 1 6 3.488c.92 0 1.738.436 2.26 1.112m.414 2.717c-.02.055.02.115.079.115h3.033a.135.135 0 0 0 .133-.112 6 6 0 0 0-.015-2.058.135.135 0 0 0-.133-.11H8.72c-.06 0-.1.061-.078.117a2.83 2.83 0 0 1 .032 2.048m-5.427.115c.06 0 .1-.06.079-.115a2.84 2.84 0 0 1 .032-2.048.085.085 0 0 0-.078-.118H.23a.135.135 0 0 0-.134.11A6 6 0 0 0 .08 7.32c.01.065.067.112.133.112z" }) }), ve$1 = (e2) => jsx("svg", { width: "12", height: "13", viewBox: "0 0 12 13", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...e2, children: jsx("path", { d: "M6.012 1.72c-.286 0-.577.178-.75.532L4.2 4.438l-2.42.344c-.78.108-1.03.872-.47 1.42l1.75 1.703-.407 2.39c-.133.773.508 1.24 1.203.874.268-.142 1.648-.857 2.155-1.124l2.155 1.124c.695.367 1.339-.1 1.202-.874l-.421-2.39 1.749-1.702c.565-.547.326-1.31-.453-1.421l-2.436-.344L6.76 2.252c-.172-.354-.464-.531-.75-.531" }) }), Se$2 = (e2) => jsx("svg", { width: "12", height: "13", viewBox: "0 0 12 13", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...e2, children: jsx("path", { d: "M6.012 1.72c-.286 0-.577.178-.75.532L4.2 4.438l-2.42.344c-.78.108-1.03.872-.47 1.42l1.75 1.703-.407 2.39c-.133.773.508 1.24 1.203.874.268-.142 1.648-.857 2.155-1.124l2.155 1.124c.695.367 1.339-.1 1.202-.874l-.421-2.39 1.749-1.702c.565-.547.326-1.31-.453-1.421l-2.436-.344L6.76 2.252c-.172-.354-.464-.531-.75-.531m0 1.297 1.03 2.108c.073.15.211.242.375.266l2.343.343-1.702 1.64a.48.48 0 0 0-.14.437l.405 2.312L6.246 9.03a.5.5 0 0 0-.468 0L3.7 10.123l.39-2.296a.52.52 0 0 0-.14-.453l-1.687-1.64 2.327-.328a.52.52 0 0 0 .39-.28z" }) }), ye$1 = (e2) => jsx("svg", { width: "16", height: "17", viewBox: "0 0 16 17", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...e2, children: jsx("path", { d: "M2.01 2.915a.667.667 0 1 0 0 1.334h12a.667.667 0 0 0 0-1.334zM7.343 13.59a.667.667 0 0 0 1.333 0V7.88l2 1.98.937-.938L8.49 5.777a.686.686 0 0 0-.959 0L4.405 8.923l.938.937 2-1.979z" }) }), ke$1 = (e2) => jsx("svg", { width: "16", height: "17", viewBox: "0 0 16 17", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...e2, children: jsx("path", { d: "M4.67 2.203A2.667 2.667 0 0 0 2.005 4.87v6.667a2.667 2.667 0 0 0 2.667 2.666h6.666a2.667 2.667 0 0 0 2.667-2.666V4.87a2.667 2.667 0 0 0-2.667-2.667zm1.334 3.334c.17 0 .349.057.48.187l1.52 1.52 1.52-1.52a.68.68 0 0 1 .48-.187c.17 0 .349.057.48.187.26.26.26.698 0 .959l-1.521 1.52 1.52 1.52c.26.262.26.699 0 .96a.687.687 0 0 1-.958 0L8.004 9.162l-1.52 1.52a.687.687 0 0 1-.96 0 .687.687 0 0 1 0-.958l1.521-1.52-1.52-1.521a.687.687 0 0 1 0-.96.68.68 0 0 1 .479-.186" }) }), Wo$1 = (e2) => jsxs("svg", { width: "16", height: "16", viewBox: "0 0 16 16", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...e2, children: [jsx("mask", { id: "a", style: { maskType: "alpha" }, maskUnits: "userSpaceOnUse", x: "0", y: "0", width: "16", height: "16", children: jsx("path", { d: "M0 0h16v16H0z" }) }), jsx("g", { mask: "url(#a)", children: jsx("path", { d: "M7.333 8.667h-4V7.333h4v-4h1.333v4h4v1.334h-4v4H7.333z" }) })] }), _o$1 = (e2) => jsxs("svg", { xmlns: "http://www.w3.org/2000/svg", width: "12", height: "12", viewBox: "0 0 12 12", fill: "none", children: [jsx("path", { d: "M5.99536 1.46487C5.71936 1.46487 5.49536 1.68887 5.49536 1.96487V5.46487H1.99536C1.71936 5.46487 1.49536 5.68887 1.49536 5.96487C1.49536 6.24087 1.71936 6.46487 1.99536 6.46487H5.49536V9.96487C5.49536 10.2409 5.71936 10.4649 5.99536 10.4649C6.27136 10.4649 6.49536 10.2409 6.49536 9.96487V6.46487H9.99536C10.2714 6.46487 10.4954 6.24087 10.4954 5.96487C10.4954 5.68887 10.2714 5.46487 9.99536 5.46487H6.49536V1.96487C6.49536 1.68887 6.27136 1.46487 5.99536 1.46487Z", fill: "url(#paint0_linear_1951_55156)" }), jsx("defs", { children: jsxs("linearGradient", { id: "paint0_linear_1951_55156", x1: "10.4954", y1: "5.96487", x2: "1.49536", y2: "5.96487", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "rgb(var(--oui-gradient-brand-end))" }), jsx("stop", { offset: "1", stopColor: "rgb(var(--oui-gradient-brand-start))" })] }) })] }), Ao = (e2) => jsx("svg", { width: "16", height: "16", viewBox: "0 0 16 16", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...e2, children: jsx("path", { d: "M6.326 8.826a.84.84 0 0 0-.6.234L2.16 12.627v-2.135H.492v4.167c0 .46.373.833.834.833h4.166v-1.667H3.357l3.567-3.567a.857.857 0 0 0 0-1.198.84.84 0 0 0-.598-.234M10.502.492V2.16h2.135L9.07 5.726a.857.857 0 0 0 0 1.199.86.86 0 0 0 1.197 0l3.568-3.568v2.135h1.667V1.326a.834.834 0 0 0-.834-.834z" }) }), zo$1 = (e2) => jsx("svg", { width: "16", height: "16", viewBox: "0 0 16 16", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...e2, children: jsx("path", { d: "M14.668.492a.85.85 0 0 0-.599.234l-3.567 3.568V2.159H8.835v4.167c0 .46.373.833.833.833h4.167V5.492H11.7l3.569-3.567a.86.86 0 0 0 0-1.199.85.85 0 0 0-.6-.234m-12.5 8.334v1.666h2.135L.736 14.06a.86.86 0 0 0 0 1.198.86.86 0 0 0 1.198 0l3.568-3.567v2.134h1.666V9.66a.834.834 0 0 0-.833-.833z" }) }), Ke$2 = (e2) => jsx("svg", { width: "12", height: "12", viewBox: "0 0 12 12", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...e2, children: jsx("path", { d: "M3.003 3.998a.494.494 0 0 0-.39.797l3 4c.2.266.597.266.797 0l3-4a.5.5 0 0 0-.407-.797z" }) }), Eo = (e2) => jsx("svg", { width: "16", height: "16", viewBox: "0 0 16 16", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...e2, children: jsx("path", { d: "M9.186 3.348a.67.67 0 0 0-.436.27l-2.657 4a.69.69 0 0 0 0 .75l2.657 4a.68.68 0 0 0 .934.188.685.685 0 0 0 .187-.937L7.463 7.993 9.87 4.37a.685.685 0 0 0-.187-.938.65.65 0 0 0-.498-.083" }) });
var yt$2 = (e2) => {
  let { emblaRef: t, emblaApi: o2, scrollIndex: a2, enableScroll: r3, news: s2, gainers: n4, losers: i, total24Amount: l2, totalOpenInterest: u2, tvl: c, favorite: m2 } = e2, { onSymbolChange: f2 } = g$1(), { t: p2 } = ne$6(), d2 = cnBase("oui-flex-[0_0_calc((100%_-_32px)_/_3)] 3xl:oui-flex-[0_0_calc((100%_-_48px)_/_4)] oui-min-w-0", r3 && "oui-select-none oui-cursor-pointer"), x2 = (v3) => {
    f2 == null ? void 0 : f2(v3), m2.addToHistory(v3);
  };
  return jsxs("div", { id: "oui-markets-header", className: "oui-overflow-hidden", ref: r3 ? t : void 0, children: [jsxs(z$3, { width: "100%", gapX: 4, mt: 4, children: [jsx(Jr$1, { total24Amount: l2, totalOpenInterest: u2, tvl: c, className: d2 }), jsx(vt, { data: s2, title: jsx(Q$1.gradient, { color: "brand", children: p2("markets.newListings") }), className: d2, onSymbol: x2 }), jsx(vt, { data: n4, title: jsx(Q$1, { className: "oui-text-success-light", children: p2("markets.topGainers") }), className: d2, onSymbol: x2 }), jsx(vt, { data: i, title: jsx(Q$1, { className: "oui-text-danger-light", children: p2("markets.topLosers") }), className: d2, onSymbol: x2 })] }), jsx("div", { className: "oui-mt-1 oui-mb-3  3xl:oui-mt-4 3xl:oui-mb-0", children: jsx(ta, { scrollIndex: a2, scrollPrev: o2 == null ? void 0 : o2.scrollPrev, scrollNext: o2 == null ? void 0 : o2.scrollNext }) })] });
}, Jr$1 = (e2) => {
  let { total24Amount: t, totalOpenInterest: o2, tvl: a2 } = e2, { t: r3 } = ne$6(), s2 = useMemo(() => [{ label: jsxs(z$3, { gapX: 1, children: [jsx(ce$2, {}), " ", r3("markets.column.24hVolume")] }), value: t }, { label: jsxs(z$3, { gapX: 1, children: [jsx(ce$2, {}), " ", r3("markets.openInterest")] }), value: o2 }, { label: jsxs(z$3, { gapX: 1, children: [jsx(ce$2, {}), " ", `${r3("common.assets")} (TVL)`] }), value: a2 }], [t, o2, a2]);
  return jsx(z$3, { direction: "column", justify: "between", width: "100%", height: 236, className: e2.className, children: s2 == null ? void 0 : s2.map((n4, i) => jsx(jr, { ...n4 }, i)) });
}, jr = (e2) => jsxs(W$2, { intensity: 900, r: "lg", px: 4, py: 3, width: "100%", children: [jsx(Q$1, { as: "div", intensity: 36, size: "xs", weight: "semibold", children: e2.label }), jsx(Q$1.numeral, { size: "base", currency: "$", dp: e2.dp || 0, rm: g$6.ROUND_DOWN, rule: e2.rule, children: e2.value })] }), vt = (e2) => {
  var _a3;
  return jsxs(W$2, { intensity: 900, r: "lg", py: 4, pb: 2, height: 236, className: e2.className, children: [jsx(W$2, { px: 4, children: jsx(Q$1.gradient, { color: "brand", size: "sm", weight: "semibold", children: e2.title }) }), jsx(z$3, { direction: "column", itemAlign: "start", mt: 2, children: (_a3 = e2.data) == null ? void 0 : _a3.map((t, o2) => jsx(ea, { item: t, onSymbol: e2.onSymbol }, t.symbol)) })] });
}, ea = (e2) => {
  let { item: t } = e2;
  return jsxs(z$3, { width: "100%", gapX: 3, py: 2, px: 4, className: cnBase("hover:oui-bg-base-8 oui-cursor-pointer", e2.className), onClick: () => {
    e2.onSymbol(t);
  }, children: [jsx(z$3, { width: "100%", gapX: 1, children: jsx(Q$1.formatted, { rule: "symbol", formatString: "base", size: "xs", weight: "semibold", showIcon: true, children: t.symbol }) }), jsx(z$3, { width: "100%", justify: "end", children: jsx(Q$1.numeral, { currency: "$", size: "xs", weight: "semibold", dp: t.quote_dp, children: t["24h_close"] }) }), jsx(z$3, { width: "100%", justify: "end", children: jsx(Q$1.numeral, { rule: "percentages", coloring: true, size: "xs", weight: "semibold", showIdentifier: true, children: t.change }) })] });
}, ta = (e2) => {
  let { scrollIndex: t, scrollPrev: o2, scrollNext: a2 } = e2;
  return jsx(z$3, { gapX: 1, justify: "center", className: "3xl:oui-hidden", children: [0, 1].map((r3) => jsx(W$2, { py: 1, pl: r3 === 0 ? 1 : 0, pr: r3 === 1 ? 1 : 0, onClick: () => {
    t === 0 && r3 === 1 ? a2 == null ? void 0 : a2() : t === 1 && r3 === 0 && (o2 == null ? void 0 : o2());
  }, className: "oui-cursor-pointer", children: jsx(W$2, { width: 8, height: 4, r: "full", className: cnBase("oui-transition-all oui-duration-300", t === r3 ? "oui-bg-base-contrast-36 oui-w-4" : "oui-bg-base-contrast-20") }, r3) }, r3)) });
};
function _e$1(e2, t) {
  let { sortKey: o2, sortOrder: a2 } = t || {}, r3 = [...e2 || []], s2 = (n4) => n4 == null;
  return o2 && a2 && r3.sort((n4, i) => {
    let l2 = n4[o2], u2 = i[o2];
    return s2(l2) ? 1 : s2(u2) ? -1 : a2 === "desc" ? u2 - l2 : l2 - u2;
  }), r3;
}
function N(e2, t) {
  let [o2, a2] = useState(e2), r3 = useCallback((n4) => {
    let i = n4 ? { sortKey: n4.sortKey, sortOrder: n4.sort } : void 0;
    a2(i), t == null ? void 0 : t(i);
  }, []), s2 = useCallback((n4) => _e$1(n4, o2), [o2]);
  return { sort: o2, onSort: r3, getSortedList: s2 };
}
function P(e2, t = "", o2) {
  if (!t) return e2;
  let a2 = new RegExp(t, "i"), r3 = t.toLowerCase(), s2 = [], n4 = [], i = [];
  e2 == null ? void 0 : e2.forEach((u2) => {
    let c = kt(u2.symbol, o2), m2 = c.toLowerCase();
    a2.test(c) && (m2 === r3 ? s2.push(u2) : m2.startsWith(r3) ? n4.push(u2) : i.push(u2));
  });
  let l2 = (u2, c) => {
    let m2 = kt(u2.symbol, o2), f2 = kt(c.symbol, o2);
    return m2 < f2 ? -1 : m2 > f2 ? 1 : 0;
  };
  return n4.sort(l2), i.sort(l2), [...s2, ...n4, ...i];
}
function kt(e2, t = "base") {
  let o2 = e2.split("_"), a2 = o2[0], r3 = o2[1], s2 = o2[2];
  return t.replace("type", a2).replace("base", r3).replace("quote", s2);
}
function Ho$2() {
  let [e2, t] = useState(0), [o2, a2] = useState(0);
  return useEffect(() => {
    t(window.innerWidth), a2(window.innerHeight);
    let r3 = () => {
      a2(window.innerHeight), t(window.innerWidth);
    };
    return window == null ? void 0 : window.addEventListener("resize", r3), () => {
      window == null ? void 0 : window.removeEventListener("resize", r3);
    };
  }, []), { width: e2, height: o2 };
}
var Ct$1 = () => {
  let [e2, t] = useState(0), o2 = ma$1(), { width: a2 } = Ho$2(), [r3, s2] = nt$2({ loop: true, slidesToScroll: "auto" });
  return useEffect(() => {
    s2 == null ? void 0 : s2.on("select", () => {
      t(s2 == null ? void 0 : s2.selectedScrollSnap());
    });
  }, [s2]), { scrollIndex: e2, setScrollIndex: t, emblaRef: r3, emblaApi: s2, enableScroll: a2 < 1440, ...o2 };
};
function ma$1() {
  let [e2, t] = useMarkets(MarketsType.ALL), { data: o2 } = useQuery("/v1/public/balance/stats"), a2 = useMemo(() => _e$1(e2, { sortKey: "created_time", sortOrder: "desc" }).slice(0, 5), [e2]), r3 = useMemo(() => _e$1(e2, { sortKey: "change", sortOrder: "desc" }).slice(0, 5), [e2]), s2 = useMemo(() => _e$1(e2, { sortKey: "change", sortOrder: "asc" }).slice(0, 5), [e2]), n4 = useMemo(() => (e2 == null ? void 0 : e2.reduce((u2, c) => u2.add(c["24h_amount"] || 0), new g$6(0))) || new g$6(0), [e2]), i = useMemo(() => (e2 == null ? void 0 : e2.reduce((u2, c) => u2.add(c.openInterest || 0), new g$6(0))) || new g$6(0), [e2]), l2 = useMemo(() => {
    if (!o2) return 0;
    let { total_holding: u2 = 0 } = o2;
    return new g$6(u2).toNumber();
  }, [o2]);
  return { markets: e2, news: a2, gainers: r3, losers: s2, total24Amount: n4.toNumber(), totalOpenInterest: i.toNumber(), tvl: l2, favorite: t };
}
var Ft$2 = () => {
  let e2 = Ct$1();
  return jsx(yt$2, { ...e2 });
};
var Nt = (e2) => {
  var _a3;
  let { open: t, setOpen: o2, container: a2, inputRef: r3, inputWidth: s2, spanRef: n4, editing: i, value: l2, onValueChange: u2, updateCurTab: c, onEdit: m2, addTab: f2, delTab: p2, size: d2 = "default", scrollable: x2 } = e2, { t: v3 } = ne$6(), { selectedFavoriteTab: S2, favoriteTabs: F3, updateSelectedFavoriteTab: O2 } = e2.favorite, W2 = d2 === "sm" ? 28 : 36, w4 = d2 === "sm" ? 18 : 24, T2 = (l2 == null ? void 0 : l2.length) > 15, $2 = "oui-bg-gradient-to-r oui-from-[rgb(var(--oui-gradient-brand-start)_/_0.12)] oui-to-[rgb(var(--oui-gradient-brand-end)_/_0.12)]", gt2 = (y2) => {
    vo$4.confirm({ title: v3("markets.favorites.tabs.delete.dialog.title"), content: jsx(Q$1, { size: "sm", children: v3("markets.favorites.tabs.delete.dialog.description", { name: y2.name }) }), onOk() {
      return p2(y2), Promise.resolve();
    } });
  }, bt2 = (y2) => {
    y2.key === "Enter" && c(T2);
  }, xt2 = (y2) => jsxs(z$3, { gapX: 2, itemAlign: "center", px: 2, py: 1, children: [jsx(Do, { className: "oui-cursor-pointer oui-text-base-contrast-36 hover:oui-text-base-contrast", onClick: () => {
    m2(y2);
  } }), jsx(Ro, { className: "oui-cursor-pointer oui-text-base-contrast-36 hover:oui-text-base-contrast", onClick: () => {
    gt2(y2);
  } })] }), He2 = () => {
    let y2 = F3.length >= 10, D2 = jsx(z$3, { className: cnBase("oui-inline-flex", y2 ? "oui-cursor-not-allowed" : "oui-cursor-pointer", y2 ? "oui-bg-base-3" : $2), width: W2, height: w4, r: "base", justify: "center", itemAlign: "center", onClick: y2 ? void 0 : f2, children: y2 ? jsx(Wo$1, { className: "oui-z-[1] oui-size-3 oui-text-base-contrast-54" }) : jsx(_o$1, { className: "oui-size-3" }) });
    return y2 ? jsx(xs, { content: jsx(Q$1, { size: "2xs", intensity: 80, children: "Maximum 10 groups in the favorite list" }), className: "oui-bg-base-6", delayDuration: 0, arrow: { className: "oui-fill-base-6" }, children: D2 }) : D2;
  }, L2 = (y2) => jsx(xs, { open: T2, content: jsx(Q$1, { size: "2xs", intensity: 80, children: "List name cannot exceed 15 characters" }), className: "oui-bg-base-6", delayDuration: 0, sideOffset: 0, children: jsx(Fo$3, { ref: r3, style: T2 ? { width: s2 } : { "--oui-gradient-angle": "270deg", backgroundClip: "text", WebkitTextFillColor: "transparent", WebkitBackgroundClip: "text", width: s2 }, classNames: { root: cnBase("oui-my-px oui-rounded oui-p-0 oui-px-2", "focus-within:oui-outline-transparent focus-visible:oui-outline-none", d2 === "sm" ? "oui-h-[18px]" : "oui-h-[24px]", y2 && cnBase(T2 ? "oui-bg-danger/15" : $2)), input: cnBase("oui-font-semibold oui-caret-[rgba(217,217,217,1)]", T2 ? "oui-text-danger" : "oui-text-transparent oui-gradient-brand ", d2 === "sm" ? "oui-text-2xs" : "oui-text-sm") }, value: l2, onValueChange: u2, onBlur: () => {
    c(T2);
  }, onKeyUp: bt2, autoComplete: "off" }) }), me2 = (y2, D2) => {
    if (i && D2) return L2(D2);
    let Y2 = { weight: "semibold", size: d2 === "sm" ? "2xs" : "sm", className: d2 === "sm" ? "oui-leading-[18px]" : "oui-leading-[24px]", as: "div" }, ht2 = D2 ? jsx(Q$1.gradient, { color: "brand", angle: 270, ...Y2, children: y2.name }) : jsx(Q$1, { ...Y2, children: y2.name });
    return jsx(W$2, { r: "base", px: 2, height: w4, className: cnBase("oui-cursor-pointer oui-select-none", D2 ? "oui-markets-favorites-active-tab-item" : "oui-markets-favorites-tab-item", D2 ? $2 : "oui-bg-line-6 oui-text-base-contrast-36 hover:oui-text-base-contrast"), onClick: () => {
      O2(y2), D2 && o2(true);
    }, children: ht2 });
  };
  return jsxs(z$3, { width: "100%", gapX: 3, className: e2.className, children: [jsxs(z$3, { ref: a2, id: "oui-markets-favorites-tabs-container", className: cnBase("oui-hide-scrollbar oui-relative oui-cursor-pointer", "oui-overflow-hidden oui-overflow-x-auto"), gapX: d2 === "sm" ? 2 : 3, width: "100%", children: [(_a3 = F3 == null ? void 0 : F3.slice(0, 10)) == null ? void 0 : _a3.map((y2) => {
    let D2 = S2.id === y2.id;
    return jsx(xs, { open: D2 && !i ? t : false, onOpenChange: (Y2) => {
      D2 && o2(Y2);
    }, content: xt2(y2), delayDuration: 0, className: cnBase("oui-bg-base-5"), arrow: { className: "oui-fill-base-5" }, children: me2(y2, D2) }, y2.id);
  }), !x2 && He2(), jsx(Q$1, { size: "xs", ref: n4, className: "oui-invisible", children: l2 })] }), x2 && He2()] });
};
function It2(e2) {
  let { favorite: t, size: o2 = "default" } = e2, { favorites: a2, favoriteTabs: r3, selectedFavoriteTab: s2, updateFavoriteTabs: n4, updateSelectedFavoriteTab: i, updateFavorites: l2 } = t, [u2, c] = useState(false), [m2, f2] = useState(false), [p2, d2] = useState(""), [x2, v3] = useState(false), S2 = useRef(null), F3 = useRef(null), O2 = useRef(null), [W2, w4] = useState(50), T2 = () => {
    setTimeout(() => {
      let { scrollWidth: me2, clientWidth: y2 } = S2.current || {};
      me2 > y2 && v3(true);
    }, 0);
  }, $2 = () => {
    setTimeout(() => {
      S2.current && (S2.current.scrollLeft = S2.current.scrollWidth - S2.current.clientWidth);
    }, 0);
  }, gt2 = (L2) => {
    f2(true), d2(L2.name), setTimeout(() => {
      var _a3, _b2;
      (_a3 = F3.current) == null ? void 0 : _a3.focus(), (_b2 = F3.current) == null ? void 0 : _b2.setSelectionRange(-1, -1);
    }, 0);
  }, bt2 = (L2) => {
    n4({ ...s2, name: L2 ? s2.name : p2 }, { update: true }), f2(false), c(false), T2();
  }, xt2 = () => {
    let L2 = { name: `WatchList_${r3.length}`, id: Date.now() };
    n4(L2, { add: true }), i(L2), T2(), $2();
  }, He2 = (L2) => {
    n4(L2, { delete: true }), setTimeout(() => {
      let me2 = a2.map((Y2) => {
        var _a3;
        return { ...Y2, tabs: (_a3 = Y2.tabs) == null ? void 0 : _a3.filter((ht2) => ht2.id !== L2.id) };
      });
      l2(me2);
      let y2 = r3.filter((Y2) => Y2.id !== L2.id), D2 = (y2 == null ? void 0 : y2[(y2 == null ? void 0 : y2.length) - 1]) || (y2 == null ? void 0 : y2[0]);
      i(D2);
    }, 0);
  };
  return useEffect(() => {
    var _a3;
    if (p2) {
      let L2 = (_a3 = O2.current) == null ? void 0 : _a3.getBoundingClientRect(), me2 = o2 === "sm" ? 0 : 14;
      w4(Math.max(((L2 == null ? void 0 : L2.width) || 0) + me2, 50));
    }
  }, [p2]), useEffect(() => {
    T2();
  }, []), { favorite: t, open: u2, setOpen: c, container: S2, inputRef: F3, inputWidth: W2, spanRef: O2, editing: m2, value: p2, onValueChange: d2, onEdit: gt2, updateCurTab: bt2, addTab: xt2, delTab: He2, scrollable: x2 };
}
var de$2 = (e2) => {
  let { className: t, ...o2 } = e2, a2 = It2(o2);
  return jsx(Nt, { ...a2, size: e2.size, className: t });
};
var Dt$3 = (e2) => {
  var _a3;
  let { symbol: t, favoriteTabs: o2, open: a2, onOpenChange: r3, inputVisible: s2, selectedTabs: n4, value: i, onValueChange: l2, hide: u2, hideInput: c, showInput: m2, onCheck: f2, addTab: p2, confirm: d2 } = e2, { t: x2 } = ne$6(), v3 = (i == null ? void 0 : i.length) > 15, S2 = () => {
    if (s2) return jsxs(W$2, { children: [jsxs(z$3, { gapX: 2, children: [jsx(Fo$3, { autoFocus: true, value: i, onValueChange: l2, classNames: { root: cnBase("oui-ml-px oui-h-7 oui-w-full oui-rounded-sm oui-bg-base-6", v3 && "focus-within:oui-outline-danger focus-visible:oui-outline-danger") }, autoComplete: "off", suffix: i && jsx(W$2, { mr: 2, children: jsx(en$2, { opacity: 1, size: 14, className: "oui-cursor-pointer oui-text-base-contrast-20", onClick: () => {
      l2("");
    } }) }) }), jsx($e$6, { className: "oui-rounded-sm", size: "sm", onClick: p2, disabled: !i || v3, children: x2("common.add") })] }), v3 && jsxs(z$3, { itemAlign: "center", gapX: 1, mt: 1, children: [jsx("div", { className: "oui-size-1 oui-rounded-full oui-bg-danger" }), jsx(Q$1, { color: "danger", children: x2("markets.favorites.tabs.maxName") })] })] });
    let w4 = o2.length >= 10;
    return jsx(xs, { open: w4 ? void 0 : false, content: jsx(Q$1, { size: "2xs", intensity: 80, children: x2("markets.favorites.tabs.maxList") }), className: "oui-bg-base-6", delayDuration: 0, arrow: { className: "oui-fill-base-6" }, children: jsx("div", { children: jsxs(z$3, { className: cnBase(w4 ? "oui-cursor-not-allowed" : "oui-cursor-pointer"), itemAlign: "center", gapX: 2, p: 2, intensity: w4 ? 500 : 600, onClick: w4 ? void 0 : m2, height: 28, r: "base", children: [jsx(ln$1, { size: 14, className: "oui-text-base-contrast-36", opacity: 1 }), jsx(Q$1, { className: "", intensity: 20, children: x2("markets.favorites.dropdown.addPlaceholder") })] }) }) });
  }, F3 = jsxs(z$3, { justify: "between", className: "oui-mb-[10px] oui-mt-3", children: [jsxs(z$3, { gapX: 1, children: [x2("markets.favorites.dropdown.title"), jsx(Q$1.formatted, { rule: "symbol", formatString: "base-type", size: "base", showIcon: true, children: t })] }), jsx(De$4, { size: 16, className: "oui-cursor-pointer oui-text-base-contrast", onClick: u2 })] }), O2 = jsxs(W$2, { children: [jsx(W$2, { my: 2, className: "oui-custom-scrollbar oui-max-h-[288px] oui-overflow-y-auto", children: (_a3 = o2 == null ? void 0 : o2.slice(0, 10)) == null ? void 0 : _a3.map((w4) => {
    let T2 = !!n4.find(($2) => $2.id === w4.id);
    return jsx(W$2, { className: "oui-cursor-pointer", children: jsxs(z$3, { className: "oui-gap-x-[6px] hover:oui-bg-base-6", p: 2, r: "md", onClick: () => {
      f2(w4, T2);
    }, children: [T2 ? jsx(rn$1, { size: 18, className: "oui-text-base-contrast-80" }) : jsx(nn$1, { size: 18, className: "oui-text-base-contrast-80" }), jsx(Q$1, { intensity: 54, children: w4.name })] }) }, w4.id);
  }) }), jsx(W$2, { mt: 3, pb: 5, children: S2() })] }), W2 = jsxs(z$3, { gapX: 3, mt: 3, children: [jsx($e$6, { color: "gray", onClick: u2, fullWidth: true, className: "oui-text-sm", size: "md", children: x2("common.cancel") }, "secondary"), jsx($e$6, { onClick: d2, fullWidth: true, className: "oui-text-sm", size: "md", children: x2("common.confirm") }, "primary")] });
  return jsxs(la$1, { open: a2, onOpenChange: r3, children: [jsx(ua$2, { asChild: true, children: e2.children }), jsx(ca$1, { children: jsx(xr$3, { onCloseAutoFocus: (w4) => w4.preventDefault(), onClick: (w4) => w4.stopPropagation(), align: "start", alignOffset: -12, sideOffset: 24, className: "oui-markets-favorite-dropdown-menu-content oui-bg-base-8", children: jsx(W$2, { px: 5, pb: 5, width: 360, children: jsxs(Q$1, { as: "div", size: "sm", weight: "semibold", children: [F3, jsx(de$5, {}), O2, W2] }) }) }) })] });
};
function Rt$1(e2) {
  let { symbol: t } = e2.row || {}, { favorites: o2, favoriteTabs: a2, updateFavoriteTabs: r3, updateSymbolFavoriteState: s2 } = e2.favorite, [n4, i] = useState(false), [l2, u2] = useState(false), [c, m2] = useState(""), [f2, p2] = useState([]), d2 = () => {
    i(false);
  }, x2 = () => {
    u2(true);
  }, v3 = () => {
    u2(false);
  }, S2 = () => {
    m2(""), v3(), p2([]);
  }, F3 = () => {
    let w4 = { name: c || `WatchList_${a2.length}`, id: Date.now() };
    r3(w4, { add: true }), S2();
  }, O2 = (w4, T2) => {
    p2(T2 ? f2 == null ? void 0 : f2.filter(($2) => $2.id !== w4.id) : [...f2, w4]), v3();
  }, W2 = () => {
    s2(e2.row, f2, false), i(false);
  };
  return useEffect(() => {
    var _a3;
    if (!n4) return;
    let w4 = o2 == null ? void 0 : o2.find((T2) => T2.name === t);
    ((_a3 = w4 == null ? void 0 : w4.tabs) == null ? void 0 : _a3.length) && p2(w4 == null ? void 0 : w4.tabs);
  }, [n4, o2, a2, t]), useEffect(() => {
    n4 || S2();
  }, [n4]), { symbol: t, favoriteTabs: a2, open: n4, onOpenChange: i, inputVisible: l2, selectedTabs: f2, value: c, onValueChange: m2, hide: d2, hideInput: v3, showInput: x2, onCheck: O2, addTab: F3, confirm: W2 };
}
var Z$1 = (e2) => {
  let t = Rt$1(e2);
  return jsx(Dt$3, { ...t, children: e2.children });
};
var Qe$2 = (e2, t = false) => {
  let { t: o2 } = ne$6();
  return useMemo(() => [{ title: jsx(Ve2, { className: "oui-mt-1" }), dataIndex: "isFavorite", align: "center", width: 30, render: (r3, s2) => {
    let i = jsx(z$3, { width: "100%", height: "100%", mr: 3, justify: "center", itemAlign: "center", onClick: t ? (l2) => {
      e2.updateSymbolFavoriteState(s2, e2.selectedFavoriteTab, true), l2.stopPropagation();
    } : void 0, "data-testid": "oui-testid-markets-table-row-favorite-icon", children: r3 ? jsx(te2, { className: "oui-text-[rgba(255,154,46,1)]" }) : jsx(Ve2, { className: "oui-text-base-contrast-36 hover:oui-text-[rgba(255,154,46,1)]" }) });
    return t ? i : jsx(Z$1, { row: s2, favorite: e2, children: i });
  } }, { title: o2("markets.column.market"), dataIndex: "symbol", width: 90, render: (r3) => jsx(Q$1.formatted, { rule: "symbol", formatString: "base-type", size: "xs", weight: "semibold", showIcon: true, children: r3 }) }, { title: o2("common.price"), dataIndex: "24h_close", width: 100, align: "right", onSort: true, render: (r3, s2) => jsx(Q$1.numeral, { dp: s2.quote_dp || 2, currency: "$", children: r3 }) }, { title: o2("markets.column.24hChange"), dataIndex: "change", width: 100, align: "right", onSort: true, render: (r3) => jsx(Q$1.numeral, { rule: "percentages", coloring: true, rm: g$6.ROUND_DOWN, showIdentifier: true, children: r3 }) }, { title: jsxs(z$3, { gapX: 1, children: [jsx(ce$2, {}), " ", o2("markets.column.24hVolume")] }), dataIndex: "24h_amount", width: 100, align: "right", onSort: true, render: (r3) => jsx(Q$1.numeral, { currency: "$", dp: 0, rm: g$6.ROUND_DOWN, children: r3 }) }, { title: jsxs(z$3, { gapX: 1, children: [jsx(ce$2, {}), " ", o2("markets.openInterest")] }), dataIndex: "openInterest", width: 100, align: "right", onSort: true, render: (r3) => jsx(Q$1.numeral, { currency: "$", dp: 0, rm: g$6.ROUND_DOWN, children: r3 }) }, { title: o2("markets.dataList.column.8hFunding"), dataIndex: "8h_funding", width: 100, align: "right", onSort: true, render: (r3) => r3 === null ? "--" : jsx(Q$1.numeral, { rule: "percentages", coloring: true, dp: 4, rm: g$6.ROUND_DOWN, showIdentifier: true, children: r3 }) }, { dataIndex: "action", type: "action", width: 40, render: (r3, s2) => t ? jsx(z$3, { justify: "end", mr: 4, children: jsx(xs, { content: o2("markets.dataList.column.moveTop"), align: "center", delayDuration: 0, children: jsx(W$2, { className: "oui-hidden oui-cursor-pointer group-hover:oui-block", onClick: (n4) => {
    n4.stopPropagation(), e2.pinToTop(s2);
  }, "data-testid": "oui-markets-favorites-pinned-icon", children: jsx(Vo$1, { className: "oui-text-base-contrast-20 hover:oui-text-base-contrast" }) }) }) }) : null }], [e2, t, o2]);
};
var Yo$1 = Qe$2;
var Bt$1 = (e2) => {
  let { dataSource: t, favorite: o2, onSort: a2, loading: r3, pagination: s2 } = e2, { symbol: n4, onSymbolChange: i } = g$1(), l2 = Yo$1(o2, true);
  return jsxs("div", { children: [jsx(de$2, { favorite: o2, className: "oui-my-3" }), jsx(L1, { bordered: true, columns: l2, dataSource: t, emptyView: jsx(z$3, { className: "oui-text-xs oui-text-base-contrast-36", children: jsx(Trans, { i18nKey: "markets.dataList.favorites.empty", components: [jsx(Ve2, { className: "oui-text-base-contrast-36" }, "0")] }) }), loading: r3, onRow: (c, m2) => ({ className: cnBase("oui-h-[55px] oui-cursor-pointer"), onClick: () => {
    i == null ? void 0 : i(c), o2.addToHistory(c);
  } }), generatedRowKey: (c) => c.symbol, rowSelection: { [n4]: true }, onSort: a2, pagination: s2, manualSorting: true })] });
};
var Ot$1 = () => {
  let { setPage: t, pagination: o2 } = p0({ pageSize: 10 }), [a2, r3] = useMarkets(MarketsType.FAVORITES), [s2, n4] = useState(true), { favorites: i, selectedFavoriteTab: l2 } = r3, { searchValue: u2 } = g$1(), { onSort: c, getSortedList: m2 } = N(), f2 = useMemo(() => {
    var _a3, _b2;
    let d2 = (_b2 = (_a3 = i == null ? void 0 : i.filter((x2) => {
      var _a4;
      return ((_a4 = x2.tabs) == null ? void 0 : _a4.findIndex((v3) => v3.id === l2.id)) !== -1;
    })) == null ? void 0 : _a3.map((x2) => {
      let v3 = a2 == null ? void 0 : a2.findIndex((S2) => S2.symbol === x2.name);
      return v3 !== -1 ? a2[v3] : null;
    })) == null ? void 0 : _b2.filter((x2) => !!x2);
    return P(d2, u2, "base-type");
  }, [a2, l2, i, u2]), p2 = useMemo(() => m2(f2), [f2, m2]);
  return useEffect(() => {
    n4(false);
  }, [i]), useEffect(() => {
    t(1);
  }, [u2]), { loading: s2, dataSource: p2, favorite: r3, onSort: c, pagination: o2 };
};
var Vt = () => {
  let e2 = Ot$1();
  return jsx(Bt$1, { ...e2 });
};
var Wt = (e2) => {
  let { loading: t, dataSource: o2, favorite: a2, onSort: r3, initialSort: s2, type: n4, pagination: i } = e2, { symbol: l2, onSymbolChange: u2 } = g$1(), c = Qe$2(a2, false);
  return jsx(L1, { bordered: true, columns: c, loading: t, dataSource: o2, onRow: (m2, f2) => ({ className: cnBase("oui-h-[55px] oui-cursor-pointer"), onClick: () => {
    u2 == null ? void 0 : u2(m2), a2.addToHistory(m2);
  }, "data-testid": `oui-testid-markets-${n4 === "new" ? "newListing" : "all"}-tr-${m2.symbol}` }), generatedRowKey: (m2) => m2.symbol, rowSelection: { [l2]: true }, onSort: r3, initialSort: s2, pagination: i, classNames: { header: "oui-h-12" }, manualSorting: true });
};
var At = (e2) => {
  let [t, o2] = useState(true), { setPage: a2, pagination: r3 } = p0({ pageSize: 10 }), [s2, n4] = useMarkets(MarketsType.ALL), { searchValue: i } = g$1(), { onSort: l2, getSortedList: u2, sort: c } = N(e2.initialSort), m2 = useMemo(() => {
    let p2 = P(s2, i, "base-type");
    return u2(p2);
  }, [s2, u2, i]);
  useEffect(() => {
    o2(false);
  }, [s2]), useEffect(() => {
    a2(1);
  }, [i]), useEffect(() => {
    e2.type === "all" && n4.updateTabsSortState("all", c == null ? void 0 : c.sortKey, c == null ? void 0 : c.sortOrder);
  }, [c, e2.type]);
  let f2 = useMemo(() => {
    var _a3, _b2, _c2;
    let p2 = e2.type === "all" ? (_a3 = n4.tabSort) == null ? void 0 : _a3.all : void 0;
    return { sortKey: (p2 == null ? void 0 : p2.sortKey) || ((_b2 = e2 == null ? void 0 : e2.initialSort) == null ? void 0 : _b2.sortKey), sort: (p2 == null ? void 0 : p2.sortOrder) || ((_c2 = e2 == null ? void 0 : e2.initialSort) == null ? void 0 : _c2.sortOrder) };
  }, [n4.tabSort, e2.initialSort, e2.type]);
  return { loading: t, dataSource: m2, favorite: n4, onSort: l2, pagination: r3, initialSort: f2 };
};
var Ze$1 = (e2) => {
  let t = At(e2);
  return jsx(Wt, { ...t, type: e2.type });
};
var Ut$1 = (e2) => {
  let { activeTab: t, onTabChange: o2 } = e2, { t: a2 } = ne$6(), { searchValue: r3, onSearchValueChange: s2, clearSearchValue: n4 } = g$1(), i = jsx(Fo$3, { value: r3, onValueChange: s2, placeholder: a2("markets.search.placeholder"), className: "oui-my-1 oui-w-[240px]", size: "sm", "data-testid": "oui-testid-markets-searchMarket-input", prefix: jsx(W$2, { pl: 3, pr: 1, children: jsx(K, { className: "oui-text-base-contrast-36" }) }), suffix: r3 && jsx(W$2, { mr: 2, children: jsx(en$2, { size: 14, className: "oui-cursor-pointer oui-text-base-contrast-36", onClick: n4 }) }), autoComplete: "off" });
  return jsx(W$2, { id: "oui-markets-list", intensity: 900, p: 6, r: "2xl", children: jsxs(jl, { variant: "contained", size: "xl", value: t, onValueChange: o2, trailing: i, children: [jsx($l, { title: a2("markets.favorites"), icon: jsx(te2, {}), value: "favorites", testid: "oui-testid-markets-favorites-tab", children: jsx(Vt, {}) }), jsx($l, { title: a2("markets.allMarkets"), icon: jsx(Bo$1, {}), value: "all", testid: "oui-testid-markets-all-tab", children: jsx(Ze$1, { type: "all", initialSort: { sortKey: "24h_amount", sortOrder: "desc" } }) }), jsx($l, { title: a2("markets.newListings"), icon: jsx(Oo$1, {}), value: "new", testid: "oui-testid-markets-newListings-tab", children: jsx(Ze$1, { type: "new", initialSort: { sortKey: "created_time", sortOrder: "desc" } }) })] }) });
};
function Gt$1() {
  let [e2, t] = useState("all"), { clearSearchValue: o2 } = g$1();
  return useEffect(() => {
    o2 == null ? void 0 : o2();
  }, [e2]), { activeTab: e2, onTabChange: (a2) => t(a2) };
}
var Ht = () => {
  let e2 = Gt$1();
  return jsx(Ut$1, { ...e2 });
};
var re$1 = (e2) => {
  var _a3;
  let { symbol: t, onSymbolChange: o2 } = g$1(), { t: a2 } = ne$6();
  return jsx("div", { className: "oui-custom-scrollbar oui-h-full oui-overflow-y-auto", children: jsx(z$3, { direction: "column", px: 2, gapY: 1, children: (_a3 = e2.dataSource) == null ? void 0 : _a3.map((r3) => {
    let s2 = jsxs(z$3, { intensity: 800, p: 2, className: "oui-gap-x-7", r: "base", children: [jsxs(z$3, { direction: "column", itemAlign: "start", gapY: 1, children: [jsxs(z$3, { gapX: 1, children: [jsx(Te$4, { symbol: r3.symbol, className: "oui-size-[18px]" }), jsx(Q$1.formatted, { rule: "symbol", formatString: "base", size: "2xs", weight: "semibold", children: r3.symbol })] }), jsx(Q$1, { size: "2xs", intensity: 36, children: a2("markets.column.last") }), jsx(Q$1, { size: "2xs", intensity: 36, children: a2("markets.column.24hPercentage") })] }), jsxs(z$3, { direction: "column", itemAlign: "end", gapY: 1, children: [jsxs(Wd, { size: "xs", color: "primary", children: [r3.leverage, "x"] }), jsx(Q$1.numeral, { dp: r3.quote_dp || 2, currency: "$", size: "2xs", intensity: 80, children: r3["24h_close"] }), jsx(Q$1.numeral, { rule: "percentages", coloring: true, rm: g$6.ROUND_DOWN, showIdentifier: true, size: "2xs", children: r3.change })] })] });
    return jsx(xs, { side: "right", sideOffset: 6, content: s2, delayDuration: 0, children: jsxs(z$3, { direction: "column", justify: "center", itemAlign: "center", gapY: 1, width: 54, height: 54, r: "lg", className: cnBase("oui-cursor-pointer", "hover:oui-bg-base-7", t === r3.symbol && "oui-bg-base-6 hover:oui-bg-base-6"), onClick: () => {
      o2 == null ? void 0 : o2(r3);
    }, children: [jsx(Te$4, { symbol: r3.symbol, className: "oui-size-[18px]" }), jsx(Q$1.numeral, { rule: "percentages", coloring: true, rm: g$6.ROUND_DOWN, showIdentifier: true, size: "2xs", children: r3.change })] }) }, r3.symbol);
  }) }) });
};
var ae$1 = (e2, t = false) => {
  let { t: o2 } = ne$6();
  return [{ title: o2("markets.column.market&Volume"), dataIndex: "24h_amount", onSort: true, className: "oui-h-[36px]", render: (a2, r3) => {
    let s2;
    return t || (s2 = jsx(Z$1, { row: r3, favorite: e2, children: jsx(z$3, { width: 12, height: 12, justify: "center", itemAlign: "center", className: "oui-mr-1 oui-cursor-pointer", children: r3.isFavorite ? jsx(ve$1, { className: "oui-size-3 oui-text-[rgba(255,154,46,1)]" }) : jsx(Se$2, { className: "oui-size-3 oui-text-base-contrast-36 hover:oui-text-[rgba(255,154,46,1)]" }) }) })), jsxs(z$3, { children: [s2, jsxs(z$3, { direction: "column", itemAlign: "start", gapY: 1, children: [jsxs(z$3, { gapX: 1, children: [jsx(Te$4, { symbol: r3.symbol, className: "oui-size-[18px]" }), jsx(Q$1.formatted, { rule: "symbol", formatString: "base", size: "2xs", weight: "semibold", children: r3.symbol }), jsxs(Wd, { size: "xs", color: "primary", children: [r3.leverage, "x"] })] }), jsx(Q$1.numeral, { intensity: 54, size: "2xs", rule: "human", dp: 2, rm: g$6.ROUND_DOWN, children: a2 })] })] });
  } }, { title: o2("markets.column.price&Change"), dataIndex: "change", align: "right", onSort: true, className: "oui-h-[36px]", render: (a2, r3) => {
    let s2 = (l2) => {
      e2.updateSymbolFavoriteState(r3, e2.selectedFavoriteTab, true), l2.stopPropagation();
    }, n4 = "oui-w-4 oui-h-4 oui-text-base-contrast-54 hover:oui-text-base-contrast", i = jsx("div", { className: cnBase("oui-absolute oui-right-0 oui-top-[6.5px]", "oui-hidden group-hover:oui-block"), children: jsxs(z$3, { className: cnBase("oui-inline-flex", "oui-bg-primary-darken oui-py-[6px]"), r: "base", width: 52, justify: "center", itemAlign: "end", gapX: 2, children: [jsx(ye$1, { className: n4, onClick: (l2) => {
      l2.stopPropagation(), e2.pinToTop(r3);
    } }), jsx(ke$1, { className: n4, onClick: s2 })] }) });
    return jsxs("div", { className: "oui-relative", children: [t && i, jsxs(z$3, { direction: "column", justify: "end", itemAlign: "end", gapY: 1, className: cnBase(t && "group-hover:oui-invisible"), children: [jsx(Q$1.numeral, { dp: r3.quote_dp || 2, size: "2xs", children: r3["24h_close"] }), jsx(Q$1.numeral, { rule: "percentages", coloring: true, rm: g$6.ROUND_DOWN, showIdentifier: true, size: "2xs", children: a2 })] })] });
  } }];
};
var Xt$1 = (e2) => {
  var _a3, _b2, _c2, _d3;
  let { loading: t, dataSource: o2, favorite: a2, onSort: r3, initialSort: s2, getColumns: n4, collapsed: i, isFavoritesList: l2, renderHeader: u2 } = e2, { symbol: c, onSymbolChange: m2 } = g$1(), f2 = ae$1(a2, l2), p2 = typeof n4 == "function" ? n4(a2, l2) : f2;
  return i ? jsx(re$1, { dataSource: o2 }) : jsxs(Fragment$1, { children: [u2 == null ? void 0 : u2(a2), jsx(L1, { classNames: { root: (_a3 = e2.tableClassNames) == null ? void 0 : _a3.root, body: (_b2 = e2.tableClassNames) == null ? void 0 : _b2.body, header: cnBase("oui-h-9", (_c2 = e2.tableClassNames) == null ? void 0 : _c2.header), scroll: (_d3 = e2.tableClassNames) == null ? void 0 : _d3.scroll }, columns: p2, loading: t, dataSource: o2, onRow: (d2, x2) => ({ className: cnBase("oui-h-[53px]", e2.rowClassName), onClick: () => {
    m2 == null ? void 0 : m2(d2), a2.addToHistory(d2);
  } }), generatedRowKey: (d2) => d2.symbol, rowSelection: { [c]: true }, onSort: r3, initialSort: s2 ? { sortKey: s2.sortKey, sort: s2.sortOrder } : void 0, manualSorting: true })] });
};
var Ss = { all: MarketsType.ALL, favorites: MarketsType.FAVORITES, recent: MarketsType.RECENT, newListing: MarketsType.NEW_LISTING }, qt = (e2) => {
  let [t, o2] = useState(true), [a2, r3] = useMarkets(Ss[e2.type] || MarketsType.ALL), { favorites: s2, selectedFavoriteTab: n4 } = r3, { searchValue: i } = g$1(), { onSort: l2, getSortedList: u2 } = N(e2.initialSort, e2.onSort), c = useMemo(() => {
    let f2 = typeof e2.dataFilter == "function" ? e2.dataFilter(a2, { favorites: s2, selectedFavoriteTab: n4 }) : a2, p2 = P(f2, i, "base");
    return u2(p2);
  }, [a2, u2, i, e2.dataFilter, s2, n4]);
  useEffect(() => {
    o2(false);
  }, [a2]);
  let m2 = e2.type === "favorites";
  return { loading: t, dataSource: c, favorite: r3, onSort: l2, isFavoritesList: m2 };
};
var j = (e2) => {
  let t = qt(e2);
  return jsx(Xt$1, { ...t, initialSort: e2.initialSort, getColumns: e2.getColumns, collapsed: e2.collapsed, tableClassNames: e2.tableClassNames, rowClassName: e2.rowClassName, renderHeader: e2.renderHeader });
};
function Le() {
  let e2 = useCallback((o2) => jsx(W$2, { px: 3, className: "oui-my-[6px]", children: jsx(de$2, { favorite: o2, size: "sm" }) }), []), t = useCallback((o2, a2) => {
    var _a3, _b2;
    let { favorites: r3, selectedFavoriteTab: s2 } = a2;
    return (_b2 = (_a3 = r3 == null ? void 0 : r3.filter((n4) => {
      var _a4;
      return ((_a4 = n4.tabs) == null ? void 0 : _a4.findIndex((i) => i.id === s2.id)) !== -1;
    })) == null ? void 0 : _a3.map((n4) => {
      let i = o2 == null ? void 0 : o2.findIndex((l2) => l2.symbol === n4.name);
      return i !== -1 ? o2[i] : null;
    })) == null ? void 0 : _b2.filter((n4) => n4);
  }, []);
  return { renderHeader: e2, dataFilter: t };
}
var Yt = (e2) => {
  let { activeTab: t, onTabChange: o2, tabSort: a2, onTabSort: r3 } = e2, { searchValue: s2, onSearchValueChange: n4, clearSearchValue: i } = g$1(), { t: l2 } = ne$6(), u2 = jsx(Fo$3, { value: s2, onValueChange: n4, placeholder: l2("markets.search.placeholder"), classNames: { root: "oui-border oui-mt-[1px] oui-border-line" }, size: "sm", prefix: jsx(W$2, { pl: 3, pr: 1, children: jsx(K, { className: "oui-text-base-contrast-36" }) }), suffix: s2 && jsx(W$2, { mr: 2, children: jsx(en$2, { size: 14, className: "oui-cursor-pointer oui-text-base-contrast-36", onClick: i }) }), autoComplete: "off" }), c = "oui-h-[calc(100%_-_36px)]", { renderHeader: m2, dataFilter: f2 } = Le(), p2 = (d2) => {
    let x2 = d2 === "favorites" ? { renderHeader: m2, dataFilter: f2 } : {};
    return jsx("div", { className: c, children: jsx(j, { type: d2, initialSort: a2[d2], onSort: r3(d2), tableClassNames: { scroll: cnBase("oui-px-1", d2 === "favorites" ? "oui-pb-9" : "oui-pb-2") }, ...x2 }) });
  };
  return jsxs(W$2, { className: cnBase("oui-overflow-hidden oui-font-semibold"), height: "100%", children: [jsx(W$2, { px: 3, pb: 2, children: u2 }), jsxs(jl, { variant: "contained", size: "md", value: t, onValueChange: o2, classNames: { tabsList: cnBase("oui-my-[6px]"), tabsContent: "oui-h-full", scrollIndicator: "oui-mx-3" }, className: c, showScrollIndicator: true, children: [jsx($l, { title: l2("markets.favorites"), icon: jsx(te2, {}), value: "favorites", children: p2("favorites") }), jsx($l, { title: l2("markets.recent"), value: "recent", children: p2("recent") }), jsx($l, { title: l2("common.all"), value: "all", children: p2("all") }), jsx($l, { title: l2("markets.newListings"), value: "newListing", children: p2("newListing") })] })] });
};
var De$2 = "orderly_side_markets_tab_sort";
function se(e2) {
  let [t, o2] = useSessionStorage(e2.storageKey, { all: { sortKey: "24h_amount", sortOrder: "desc" } }), a2 = useCallback((r3) => (s2) => {
    o2({ ...t, [r3]: s2 });
  }, [t]);
  return { tabSort: t, onTabSort: a2 };
}
function Qt$2(e2) {
  let [t, o2] = useState(e2.activeTab), { tabSort: a2, onTabSort: r3 } = se({ storageKey: De$2 }), { clearSearchValue: s2 } = g$1(), n4 = useCallback((i) => {
    typeof (e2 == null ? void 0 : e2.onTabChange) == "function" ? e2.onTabChange(i) : o2(i);
  }, [e2 == null ? void 0 : e2.onTabChange]);
  return useEffect(() => {
    o2((e2 == null ? void 0 : e2.activeTab) || "favorites");
  }, [e2 == null ? void 0 : e2.activeTab]), useEffect(() => {
    s2 == null ? void 0 : s2();
  }, [t]), { activeTab: t, onTabChange: n4, tabSort: a2, onTabSort: r3 };
}
var Zt$1 = (e2) => {
  let t = Qt$2({ activeTab: e2.activeTab, onTabChange: e2.onTabChange });
  return jsx(E$1, { symbol: e2.symbol, onSymbolChange: e2.onSymbolChange, children: jsx(Yt, { ...t }) });
};
var ne$1 = (e2 = 5) => (t) => t === 0 ? jsx(Q$1, { children: " - " }) : jsx(Q$1.numeral, { rule: "percentages", dp: e2, coloring: true, rm: g$6.ROUND_DOWN, showIdentifier: true, children: t }), cr = (e2, t) => {
  let { t: o2 } = ne$6();
  return [{ title: o2("markets.column.market"), dataIndex: "symbol", width: 120, render: (a2) => jsx(Q$1.formatted, { rule: "symbol", formatString: "base-type", size: "xs", weight: "semibold", showIcon: true, children: a2 }) }, { title: o2("markets.funding.column.estFunding"), dataIndex: "estFunding", width: 120, onSort: true, render: (a2, r3) => jsxs("div", { children: [jsx(Q$1.numeral, { rule: "percentages", dp: 5, coloring: true, rm: g$6.ROUND_DOWN, showIdentifier: true, children: a2 }), jsx("span", { className: "oui-text-base-contrast-54", children: `/ ${r3.fundingInterval}h` })] }) }, { title: o2("markets.funding.column.lastFunding"), dataIndex: "lastFunding", width: 90, onSort: true, render: ne$1() }, { title: o2("markets.funding.column.1dAvg"), dataIndex: "funding1d", width: 90, onSort: true, render: ne$1() }, { title: o2("markets.funding.column.3dAvg"), dataIndex: "funding3d", width: 90, onSort: true, render: ne$1() }, { title: o2("markets.funding.column.7dAvg"), dataIndex: "funding7d", width: 90, onSort: true, render: ne$1() }, { title: o2("markets.funding.column.14dAvg"), dataIndex: "funding14d", width: 90, onSort: true, render: ne$1() }, { title: o2("markets.funding.column.30dAvg"), dataIndex: "funding30d", width: 90, onSort: true, render: ne$1() }, { title: o2("markets.funding.column.90dAvg"), dataIndex: "funding90d", width: 90, onSort: true, render: ne$1() }, { title: jsxs("div", { className: "oui-flex oui-gap-1", children: [jsx("select", { value: e2, onChange: (a2) => t(a2.target.value), onClick: (a2) => a2.stopPropagation(), className: "oui-w-12 oui-rounded-md oui-border oui-border-line oui-bg-[var(--oui-table-background-color)]", children: [{ label: o2("common.select.1d"), value: "1dPositive" }, { label: o2("common.select.3d"), value: "3dPositive" }, { label: o2("common.select.7d"), value: "7dPositive" }, { label: o2("common.select.14d"), value: "14dPositive" }, { label: o2("common.select.30d"), value: "30dPositive" }, { label: o2("common.select.90d"), value: "90dPositive" }].map((a2) => jsx("option", { value: a2.value, children: a2.label }, a2.value)) }), jsx("span", { children: o2("markets.funding.column.positiveRate") })] }), dataIndex: e2, width: 130, align: "right", onSort: true, render: ne$1(2) }];
};
var Jt$1 = (e2) => {
  let { dataSource: t, isLoading: o2, pagination: a2, onSort: r3 } = e2, [s2, n4] = useState("1dPositive"), i = cr(s2, n4);
  return jsx("div", { className: "w-full", children: jsx(L1, { columns: i, dataSource: t, loading: o2, bordered: true, onRow: () => ({ className: cnBase("oui-h-[48px] oui-cursor-pointer") }), classNames: { header: "oui-h-12" }, pagination: a2, onSort: r3, manualSorting: true, generatedRowKey: (l2) => l2.symbol }) });
};
var eo = () => {
  let { pagination: e2 } = p0({ pageSize: 10 }), [t] = useMarkets(MarketsType.ALL), { data: o2, isLoading: a2, getPositiveRates: r3 } = useFundingRateHistory(), s2 = useFundingRates(), { onSort: n4, getSortedList: i } = N(), { searchValue: l2 } = g$1(), u2 = useMemo(() => {
    if (!(t == null ? void 0 : t.length)) return [];
    let p2 = ["1d", "3d", "7d", "14d", "30d", "90d"].reduce((d2, x2) => (d2[x2] = r3(o2, x2), d2), {});
    return t.map((d2) => {
      var _a3, _b2, _c2, _d3, _e3, _f2, _g2, _h2, _i3, _j2, _k2, _l3;
      let x2 = d2.symbol, v3 = o2 == null ? void 0 : o2.find((O2) => O2.symbol === x2), S2 = s2[x2], F3 = zs(S2("next_funding_time"), S2("last_funding_rate_timestamp"));
      return { symbol: x2, estFunding: S2("est_funding_rate"), lastFunding: S2("last_funding_rate"), fundingInterval: F3, funding1d: ((_b2 = (_a3 = v3 == null ? void 0 : v3.funding) == null ? void 0 : _a3["1d"]) == null ? void 0 : _b2.rate) ?? 0, funding3d: ((_d3 = (_c2 = v3 == null ? void 0 : v3.funding) == null ? void 0 : _c2["3d"]) == null ? void 0 : _d3.rate) ?? 0, funding7d: ((_f2 = (_e3 = v3 == null ? void 0 : v3.funding) == null ? void 0 : _e3["7d"]) == null ? void 0 : _f2.rate) ?? 0, funding14d: ((_h2 = (_g2 = v3 == null ? void 0 : v3.funding) == null ? void 0 : _g2["14d"]) == null ? void 0 : _h2.rate) ?? 0, funding30d: ((_j2 = (_i3 = v3 == null ? void 0 : v3.funding) == null ? void 0 : _i3["30d"]) == null ? void 0 : _j2.rate) ?? 0, funding90d: ((_l3 = (_k2 = v3 == null ? void 0 : v3.funding) == null ? void 0 : _k2["90d"]) == null ? void 0 : _l3.rate) ?? 0, "1dPositive": p2["1d"][x2] ?? "-", "3dPositive": p2["3d"][x2] ?? "-", "7dPositive": p2["7d"][x2] ?? "-", "14dPositive": p2["14d"][x2] ?? "-", "30dPositive": p2["30d"][x2] ?? "-", "90dPositive": p2["90d"][x2] ?? "-" };
    });
  }, [t, o2, s2, r3]), c = useMemo(() => P(u2, l2, "base-type"), [u2, l2, e2]);
  return { dataSource: useMemo(() => i(c), [c, i]), isLoading: a2, pagination: e2, onSort: n4 };
};
function zs(e2, t) {
  if (!e2 || !t) return 8;
  let o2 = e2 - t;
  return Math.round(o2 / 36e5);
}
var to$1 = () => {
  let e2 = eo();
  return jsx(Jt$1, { ...e2 });
};
var ot$1 = ["WOOFi Pro", "Binance", "OKX", "Bybit", "dYdX", "Bitget", "Kucoin"], ro = () => {
  let { pagination: e2 } = p0({ pageSize: 10 }), { onSort: t, getSortedList: o2 } = N(), { searchValue: a2 } = g$1(), r3 = useFundingRates(), { data: s2, isLoading: n4 } = useQuery("/v1/public/market_info/funding_comparison"), i = useMemo(() => (s2 == null ? void 0 : s2.length) ? s2.map((c) => {
    let m2 = { symbol: c.symbol };
    return ot$1.forEach((f2, p2) => {
      let d2 = f2.toLowerCase();
      if (d2 === "woofi pro") {
        let v3 = r3[c.symbol];
        m2[`exchange_${p2}`] = v3("last_funding_rate") ?? null;
        return;
      }
      let x2 = c.exchanges.find((v3) => v3.name.toLowerCase() === d2);
      m2[`exchange_${p2}`] = (x2 == null ? void 0 : x2.last) ?? null;
    }), m2;
  }) : [], [s2, ot$1, r3]), l2 = useMemo(() => P(i, a2, "base-type"), [i, a2, e2]);
  return { data: useMemo(() => o2(l2), [l2, o2]), isLoading: n4, pagination: e2, onSort: t };
};
var fr$1 = () => {
  let { t: e2 } = ne$6();
  return [{ title: e2("markets.column.market"), dataIndex: "symbol", width: 150, onSort: true, render: (t) => jsx(Q$1.formatted, { rule: "symbol", formatString: "base-type", size: "xs", weight: "semibold", showIcon: true, children: t }) }, ...ot$1.map((t, o2) => ({ title: jsxs("div", { style: { display: "flex", alignItems: "center", gap: "4px" }, children: [jsx("img", { src: `https://oss.orderly.network/static/exchange_logo/${t.toLowerCase().replace(" ", "_")}.png`, style: { width: "24px", height: "24px", objectFit: "cover", borderRadius: "50%" } }), jsx("span", { children: t })] }), dataIndex: `exchange_${o2}`, onSort: true, width: 100, render: (a2) => a2 === null ? "-" : jsx(Q$1.numeral, { rule: "percentages", dp: 5, coloring: true, rm: g$6.ROUND_DOWN, showIdentifier: true, children: a2 }) }))];
};
var ao$1 = ({ data: e2, isLoading: t, pagination: o2 }) => {
  let a2 = fr$1();
  return jsx(L1, { columns: a2, dataSource: e2, loading: t, onRow: () => ({ className: cnBase("oui-h-[48px] oui-cursor-pointer") }), classNames: { header: "oui-h-12" }, bordered: true, pagination: o2 });
};
var so$1 = () => {
  let e2 = ro();
  return jsx(ao$1, { ...e2 });
};
var io$1 = (e2) => {
  let { collapsable: t, collapsed: o2, onCollapse: a2, activeTab: r3, onTabChange: s2, className: n4, tabSort: i } = e2, { symbol: l2, onSymbolChange: u2 } = g$1(), { renderHeader: c, dataFilter: m2 } = Le(), f2 = () => {
    if (!o2) return jsx(Zt$1, { activeTab: r3, onTabChange: s2, symbol: l2, onSymbolChange: u2 });
    let p2 = r3 === "favorites" ? { renderHeader: c, dataFilter: m2 } : {};
    return jsx(j, { type: r3, initialSort: i[r3], collapsed: o2, ...p2 });
  };
  return jsxs(z$3, { id: "oui-side-markets", className: cnBase("oui-font-semibold", n4), direction: "column", gapY: 5, height: "100%", width: "100%", children: [jsx(tn, { collapsable: t, collapsed: o2, onCollapse: a2 }), jsx(W$2, { width: "100%", className: cnBase(o2 ? "oui-h-[calc(100%_-_52px)]" : "oui-h-[calc(100%_-_56px)]"), children: f2() })] });
}, tn = (e2) => {
  let { collapsable: t, collapsed: o2, onCollapse: a2 } = e2, { t: r3 } = ne$6(), s2 = cnBase("oui-text-base-contrast-36", t ? "oui-cursor-pointer hover:oui-text-base-contrast-80" : "oui-cursor-not-allowed");
  return o2 ? jsx(Ao, { className: s2, onClick: () => {
    a2 == null ? void 0 : a2(false);
  } }) : jsxs(z$3, { justify: "between", px: 3, width: "100%", children: [jsx(Q$1, { size: "base", intensity: 80, children: r3("common.markets") }), jsx(zo$1, { className: s2, onClick: () => {
    a2 == null ? void 0 : a2(true);
  } })] });
};
var ln = "orderly_side_markets_sel_tab_key";
function lo$1(e2) {
  let [t, o2] = useState(e2 == null ? void 0 : e2.collapsed), [a2, r3] = useLocalStorage(ln, "all"), { tabSort: s2 } = se({ storageKey: De$2 }), n4 = useMemo(() => (e2 == null ? void 0 : e2.collapsable) ?? true, [e2 == null ? void 0 : e2.collapsable]), i = useCallback((l2) => {
    typeof (e2 == null ? void 0 : e2.onCollapse) == "function" ? e2.onCollapse(l2) : o2(l2);
  }, [e2 == null ? void 0 : e2.onCollapse]);
  return useEffect(() => {
    o2(e2 == null ? void 0 : e2.collapsed);
  }, [e2 == null ? void 0 : e2.collapsed]), { collapsable: n4, collapsed: t, onCollapse: i, activeTab: a2, onTabChange: r3, tabSort: s2 };
}
var mn = (e2) => {
  let t = lo$1({ collapsable: e2.collapsable, collapsed: e2.collapsed, onCollapse: e2.onCollapse });
  return jsx(E$1, { symbol: e2.symbol, onSymbolChange: e2.onSymbolChange, children: jsx(io$1, { ...t, className: e2.className }) });
};
var co = () => {
  let { t: e2 } = ne$6();
  return useCallback((t, o2 = false) => [{ title: e2("common.symbol"), dataIndex: "symbol", width: 150, render: (a2, r3) => {
    let s2;
    return o2 || (s2 = jsx(Z$1, { row: r3, favorite: t, children: jsx(z$3, { width: 12, height: 12, justify: "center", itemAlign: "center", className: "oui-mr-1 oui-cursor-pointer", children: r3.isFavorite ? jsx(ve$1, { className: "oui-size-3 oui-text-[rgba(255,154,46,1)]" }) : jsx(Se$2, { className: "oui-size-3 oui-text-base-contrast-36 hover:oui-text-[rgba(255,154,46,1)]" }) }) })), jsxs(z$3, { gapX: 1, children: [s2, jsx(Te$4, { symbol: a2, className: "oui-size-[18px]" }), jsx(Q$1.formatted, { rule: "symbol", formatString: "base", size: "2xs", weight: "semibold", children: a2 }), jsxs(Wd, { size: "xs", color: "primary", children: [r3.leverage, "x"] })] });
  } }, { title: e2("markets.column.last"), dataIndex: "24h_close", align: "right", onSort: true, width: 100, render: (a2, r3) => jsx(Q$1.numeral, { dp: r3.quote_dp || 2, size: "2xs", children: a2 }) }, { title: e2("markets.column.24hPercentage"), dataIndex: "change", align: "right", onSort: true, width: 80, render: (a2) => jsx(Q$1.numeral, { rule: "percentages", coloring: true, rm: g$6.ROUND_DOWN, showIdentifier: true, size: "2xs", children: a2 }) }, { title: e2("common.volume"), dataIndex: "24h_amount", align: "right", onSort: true, className: "oui-relative", width: 80, render: (a2, r3) => {
    let s2 = (l2) => {
      t.updateSymbolFavoriteState(r3, t.selectedFavoriteTab, true), l2.stopPropagation();
    }, n4 = "oui-w-4 oui-h-4 oui-text-base-contrast-54 hover:oui-text-base-contrast", i = jsx("div", { className: cnBase("oui-absolute oui-right-1 oui-top-[3px]"), children: jsxs(z$3, { className: cnBase("oui-bg-primary-darken oui-py-[6px]", "oui-hidden group-hover:oui-inline-flex"), r: "base", width: 52, justify: "center", itemAlign: "end", gapX: 2, children: [jsx(ye$1, { className: n4, onClick: (l2) => {
      l2.stopPropagation(), t.pinToTop(r3);
    } }), jsx(ke$1, { className: n4, onClick: s2 })] }) });
    return jsxs(Fragment$1, { children: [o2 && i, jsx(Q$1.numeral, { rule: "human", dp: 2, rm: g$6.ROUND_DOWN, className: cnBase(o2 && "group-hover:oui-invisible"), children: a2 })] });
  } }], [e2]);
};
var po$1 = (e2) => jsxs(la$1, { open: e2.open, onOpenChange: e2.onOpenChange, children: [jsx(ua$2, { asChild: true, children: e2.children }), jsx(ca$1, { children: jsx(xr$3, { onCloseAutoFocus: (t) => t.preventDefault(), onClick: (t) => t.stopPropagation(), align: "start", alignOffset: -32, sideOffset: 20, className: cnBase("oui-markets-dropdown-menu-content oui-bg-base-8 oui-p-0", e2.contentClassName), children: jsx(yr$1, { ...e2, hide: e2.hide }) }) })] }), yr$1 = (e2) => {
  let { activeTab: t, onTabChange: o2, tabSort: a2, onTabSort: r3 } = e2, { searchValue: s2, onSearchValueChange: n4 } = g$1(), { t: i } = ne$6(), l2 = co(), u2 = jsxs(z$3, { mx: 3, gapX: 3, pt: 3, pb: 2, children: [jsx(Fo$3, { value: s2, onValueChange: n4, placeholder: i("markets.search.placeholder"), classNames: { root: "oui-border oui-mt-[1px] oui-border-line oui-flex-1" }, size: "sm", prefix: jsx(W$2, { pl: 3, pr: 1, children: jsx(K, { className: "oui-text-base-contrast-36" }) }), autoComplete: "off" }), jsx(De$4, { size: 12, className: "oui-cursor-pointer oui-text-base-contrast-80", onClick: e2.hide, opacity: 1 })] }), c = "oui-h-[calc(100%_-_36px)]", { renderHeader: m2, dataFilter: f2 } = Le(), p2 = (d2) => {
    let x2 = d2 === "favorites" ? { renderHeader: m2, dataFilter: f2 } : {};
    return jsx("div", { className: c, children: jsx(j, { type: d2, initialSort: a2[d2], onSort: r3(d2), getColumns: l2, tableClassNames: { root: "!oui-bg-base-8", scroll: "oui-pb-5 oui-px-1" }, rowClassName: "!oui-h-[34px]", ...x2 }) });
  };
  return jsxs(W$2, { className: cnBase("oui-overflow-hidden oui-font-semibold"), height: "100%", intensity: 800, children: [u2, jsxs(jl, { variant: "contained", size: "md", value: t, onValueChange: o2, classNames: { tabsList: "oui-my-[6px] oui-px-3", tabsContent: "oui-h-full" }, className: c, children: [jsx($l, { title: i("markets.favorites"), icon: jsx(te2, {}), value: "favorites", children: p2("favorites") }), jsx($l, { title: i("markets.recent"), value: "recent", children: p2("recent") }), jsx($l, { title: i("common.all"), value: "all", children: p2("all") }), jsx($l, { title: i("markets.newListings"), value: "newListing", children: p2("newListing") })] })] });
};
var Mn = "orderly_dropdown_markets_sel_tab_key", Nn = "orderly_dropdown_markets_tab_sort";
function fo$1() {
  let [e2, t] = useState(false), [o2, a2] = useLocalStorage(Mn, "all"), { tabSort: r3, onTabSort: s2 } = se({ storageKey: Nn }), { clearSearchValue: n4 } = g$1(), i = () => {
    t(false);
  };
  return useEffect(() => {
    n4 == null ? void 0 : n4();
  }, [o2]), { activeTab: o2, onTabChange: (l2) => a2(l2), open: e2, onOpenChange: t, hide: i, tabSort: r3, onTabSort: s2 };
}
var go$2 = (e2) => {
  let t = fo$1();
  return jsx(E$1, { symbol: e2.symbol, onSymbolChange: e2.onSymbolChange, children: jsx(po$1, { ...t, contentClassName: e2.contentClassName, children: e2.children }) });
};
var Fr = (e2, t = false) => [{ title: o.t("markets.column.market&Volume"), dataIndex: "24h_amount", onSort: true, className: "oui-h-[36px]", render: (o2, a2) => jsxs(z$3, { direction: "column", itemAlign: "start", gapY: 1, children: [jsxs(z$3, { gapX: 1, children: [jsx(Te$4, { symbol: a2.symbol, className: "oui-size-[18px]" }), jsx(Q$1.formatted, { rule: "symbol", formatString: "base", size: "2xs", weight: "semibold", children: a2.symbol }), jsxs(Wd, { size: "xs", color: "primary", children: [a2.leverage, "x"] })] }), jsx(Q$1.numeral, { intensity: 54, rule: "human", dp: 2, rm: g$6.ROUND_DOWN, children: o2 })] }) }, { title: o.t("markets.column.price&Change"), dataIndex: "change", align: "right", onSort: true, className: "oui-h-[36px]", render: (o2, a2) => {
  let r3 = (i) => {
    e2.updateSymbolFavoriteState(a2, e2.selectedFavoriteTab, true), i.stopPropagation();
  }, s2 = "oui-w-4 oui-h-4 oui-text-base-contrast-54 hover:oui-text-base-contrast", n4 = jsx("div", { className: cnBase("oui-absolute oui-right-0 oui-top-[6.5px]", "oui-hidden group-hover:oui-block"), children: jsxs(z$3, { className: cnBase("oui-inline-flex", "oui-bg-primary-darken oui-py-[6px]"), r: "base", width: 52, justify: "center", itemAlign: "end", gapX: 2, children: [jsx(ye$1, { className: s2, onClick: (i) => {
    i.stopPropagation(), e2.pinToTop(a2);
  } }), jsx(ke$1, { className: s2, onClick: r3 })] }) });
  return jsxs("div", { className: "oui-relative", children: [t && n4, jsxs(z$3, { direction: "column", justify: "end", itemAlign: "end", gapY: 1, className: cnBase(t && "group-hover:oui-invisible"), children: [jsx(Q$1.numeral, { dp: a2.quote_dp || 2, size: "2xs", children: a2["24h_close"] }), jsx(Q$1.numeral, { rule: "percentages", coloring: true, rm: g$6.ROUND_DOWN, showIdentifier: true, size: "2xs", children: o2 })] })] });
} }];
var xo = (e2) => {
  let { className: t, tabSort: o2, onTabSort: a2 } = e2, { searchValue: r3, onSearchValueChange: s2, clearSearchValue: n4 } = g$1(), { t: i } = ne$6(), l2 = jsx(Fo$3, { value: r3, onValueChange: s2, placeholder: i("markets.search.placeholder"), classNames: { root: "oui-border oui-border-line oui-mt-4" }, size: "sm", prefix: jsx(W$2, { pl: 3, pr: 1, children: jsx(K, { className: "oui-text-base-contrast-36" }) }), suffix: r3 && jsx(W$2, { mr: 2, children: jsx(en$2, { size: 14, className: "oui-cursor-pointer oui-text-base-contrast-36", onClick: n4 }) }), autoComplete: "off" });
  return jsxs(Sa$1, { cols: 1, className: cnBase("oui-grid-rows-[auto,1fr] oui-font-semibold", t), height: "100%", width: "100%", children: [jsxs(W$2, { px: 3, mt: 3, children: [jsx(Q$1, { size: "base", intensity: 80, children: i("common.markets") }), l2] }), jsx("div", { className: "oui-relative", children: jsx(W$2, { width: "100%", mt: 2, className: "oui-absolute oui-inset-y-0 oui-left-0 oui-right-9", children: jsx(j, { type: "all", initialSort: o2.all, onSort: a2("all"), getColumns: Fr, tableClassNames: { root: "!oui-bg-base-8", scroll: "oui-pb-[calc(env(safe-area-inset-bottom))]" } }) }) })] });
};
function ho$2() {
  let { tabSort: e2, onTabSort: t } = se({ storageKey: De$2 });
  return { tabSort: e2, onTabSort: t };
}
var Wn$1 = (e2) => {
  let t = ho$2();
  return jsx(E$1, { symbol: e2.symbol, onSymbolChange: e2.onSymbolChange, children: jsx(xo, { ...t, className: e2.className }) });
};
var vo = (e2) => {
  let { symbol: t, data: o2, leverage: a2, onSymbol: r3 } = e2, s2 = jsxs(z$3, { className: "oui-cursor-pointer oui-gap-x-[6px]", onClick: r3, children: [jsx(Q$1.formatted, { className: "oui-break-normal oui-whitespace-nowrap", rule: "symbol", formatString: "base-type", size: "sm", weight: "semibold", showIcon: true, children: t }), jsx(Ke$2, { className: "oui-text-base-contrast-54 oui-w-[14px] oui-h-[14px]" })] });
  return jsxs(z$3, { className: cnBase("oui-symbol-info-bar-mobile", "oui-font-semibold oui-h-full", e2.className), children: [jsxs(z$3, { gapX: 3, className: "oui-flex-1 oui-overflow-hidden oui-h-full", children: [jsxs(z$3, { gapX: 3, children: [s2, jsxs(Wd, { size: "xs", color: "primary", children: [a2, "x"] })] }), jsx(de$5, { className: "oui-h-6", direction: "vertical", intensity: 8 }), jsx(Q$1.numeral, { size: "2xs", rule: "percentages", coloring: true, rm: g$6.ROUND_DOWN, showIdentifier: true, children: o2 == null ? void 0 : o2.change })] }), e2.trailing] });
};
function So$2(e2) {
  let { symbol: t } = e2, o2 = useTickerStream(t), a2 = useSymbolsInfo(), r3 = useMemo(() => {
    let s2 = a2[t], n4 = s2("base_imr");
    return Kn(n4);
  }, [t, a2]);
  return { symbol: t, data: o2, leverage: r3 };
}
function Kn(e2) {
  return e2 ? 1 / e2 : void 0;
}
var Xn = (e2) => {
  let { symbol: t, ...o2 } = e2, a2 = So$2({ symbol: t });
  return jsx(vo, { ...a2, ...o2 });
};
var yo$2 = (e2) => {
  let { symbol: t, isFavorite: o2, favorite: a2, data: r3, quotoDp: s2, openInterest: n4, fundingRate: i, containerRef: l2, leadingElementRef: u2, tailingElementRef: c, leadingVisible: m2, tailingVisible: f2, onScoll: p2 } = e2, { t: d2 } = ne$6(), x2 = jsx(Z$1, { row: { symbol: t }, favorite: a2, children: jsx(z$3, { width: 12, height: 12, justify: "center", itemAlign: "center", className: "oui-cursor-pointer oui-mr-1", children: o2 ? jsx(ve$1, { className: "oui-w-3 oui-h-3 oui-text-[rgba(255,154,46,1)]" }) : jsx(Se$2, { className: "oui-w-3 oui-h-3 oui-text-base-contrast-36 hover:oui-text-[rgba(255,154,46,1)]" }) }) }), v3 = jsx(go$2, { contentClassName: "oui-w-[429px] oui-h-[496px]", symbol: e2.symbol, onSymbolChange: e2.onSymbolChange, children: jsxs(z$3, { gapX: 1, className: "oui-cursor-pointer", children: [jsx(Te$4, { symbol: t, className: "oui-w-4 oui-h-4" }), jsx(Q$1.formatted, { className: "oui-break-normal oui-whitespace-nowrap", rule: "symbol", formatString: "base-type", size: "xs", weight: "semibold", intensity: 98, children: t }), jsx(Ke$2, { className: "oui-text-base-contrast-54" })] }) }), S2 = jsx(Q$1.numeral, { dp: s2 || 2, currency: "$", size: "sm", intensity: 98, className: "oui-data-value", children: r3 == null ? void 0 : r3["24h_close"] }), F3 = jsxs(Fragment$1, { children: [jsx(Q$1.numeral, { coloring: true, rm: g$6.ROUND_DOWN, showIdentifier: true, children: r3 == null ? void 0 : r3["24h_change"] }), jsx(Q$1, { intensity: 36, children: "/" }), jsx(Q$1.numeral, { rule: "percentages", coloring: true, rm: g$6.ROUND_DOWN, showIdentifier: true, children: r3 == null ? void 0 : r3.change })] });
  return jsxs(z$3, { className: cnBase("oui-symbol-info-bar-desktop", "oui-font-semibold oui-h-[54px]", e2.className), style: { transform: "translateZ(0)", willChange: "transform" }, children: [jsxs(z$3, { gapX: 6, className: "oui-flex-1 oui-overflow-hidden oui-h-full", children: [jsxs(z$3, { gapX: 1, children: [x2, v3] }), jsx(de$5, { className: "oui-h-[26px]", direction: "vertical", intensity: 8 }), S2, jsxs("div", { className: "oui-relative oui-overflow-hidden oui-h-full", children: [jsx("div", { ref: l2, className: "oui-overflow-x-auto oui-hide-scrollbar oui-h-full", children: jsxs(z$3, { gapX: 8, height: "100%", children: [jsx("div", { ref: u2, children: jsx(Be$2, { label: d2("markets.column.24hChange"), value: F3 }) }), jsx(Be$2, { label: d2("markets.symbolInfoBar.Mark"), value: jsx(Q$1.numeral, { dp: s2, "data-testid": "oui-testid-tokenInfo-markPrice-value", children: r3 == null ? void 0 : r3.mark_price }), hint: d2("markets.symbolInfoBar.Mark.tooltip") }), jsx(Be$2, { label: d2("markets.symbolInfoBar.Index"), value: jsx(Q$1.numeral, { dp: s2, children: r3 == null ? void 0 : r3.index_price }), hint: d2("markets.symbolInfoBar.Index.tooltip") }), jsx(Be$2, { label: d2("markets.symbolInfoBar.24hVolume"), value: jsx(Q$1.numeral, { rule: "human", dp: 2, children: r3 == null ? void 0 : r3["24h_amount"] }), hint: d2("markets.symbolInfoBar.24hVolume.tooltip") }), jsx(Be$2, { label: d2("markets.symbolInfoBar.predFundingRate"), value: jsx(jn$1, { symbol: t }), hint: d2("markets.symbolInfoBar.predFundingRate.tooltip") }), jsx("div", { ref: c, children: jsx(Be$2, { label: d2("markets.openInterest"), value: jsxs(Fragment$1, { children: [jsx(Q$1.numeral, { rule: "human", dp: 2, children: n4 }), jsx(Q$1, { intensity: 36, children: " USDC" })] }), hint: d2("markets.openInterest.tooltip") }) })] }) }), jsx(Ir, { leading: true, onClick: p2, visible: m2 }), jsx(Ir, { tailing: true, onClick: p2, visible: f2 })] })] }), e2.trailing] });
}, Be$2 = (e2) => jsxs(z$3, { direction: "column", itemAlign: "start", children: [jsx(xs, { open: e2.hint ? void 0 : false, content: e2.hint, className: "oui-max-w-[240px] oui-bg-base-6 ", arrow: { className: "oui-fill-base-6" }, delayDuration: 300, children: jsx(Q$1, { size: "2xs", intensity: 36, className: cnBase("oui-data-label", "oui-break-normal oui-whitespace-nowrap", e2.hint && "oui-cursor-pointer oui-border-b oui-border-dashed oui-border-line-12"), children: e2.label }) }), jsx(Q$1, { size: "2xs", intensity: 98, className: cnBase("oui-data-value", "oui-leading-[20px] oui-break-normal oui-whitespace-nowrap"), children: e2.value })] }), Ir = (e2) => {
  let { visible: t, leading: o2, tailing: a2, onClick: r3 } = e2;
  return t ? jsx("button", { onClick: () => {
    r3 == null ? void 0 : r3(o2 ? "left" : "right");
  }, style: { background: "linear-gradient(90deg, #07080A 0%, rgba(7, 8, 10, 0.60) 65%, rgba(7, 8, 10, 0.00) 100%)" }, className: cnBase("oui-flex oui-items-center oui-w-[80px]", "oui-absolute oui-top-0 oui-bottom-0 oui-rounded-l", o2 && "oui-left-0 oui-pl-1", a2 && "oui-right-0 oui-pr-1 oui-rotate-180"), children: jsx(Eo, { className: "oui-text-base-contrast-54 hover:oui-text-base-contrast-80" }) }) : null;
}, jn$1 = ({ symbol: e2 }) => {
  let t = useFundingRate(e2);
  return (t == null ? void 0 : t.est_funding_rate) === null ? "--" : jsxs("div", { children: [jsx(Q$1.numeral, { unit: "%", dp: 4, className: "oui-text-[#FF9A2E]", children: t.est_funding_rate }), jsx(Q$1, { intensity: 36, className: "oui-tabular-nums", children: ` in ${t.countDown}` })] });
};
function wo(e2) {
  let { symbol: t } = e2, o2 = useTickerStream(t), a2 = useFundingRate(t), r3 = useMarketsStore(), n4 = useSymbolsInfo()[t]("quote_dp"), [i, l2] = useState(false), [u2, c] = useState(false), m2 = useRef(null), f2 = useRef(null), p2 = useRef(null), d2 = useMemo(() => !!r3.favorites.find((S2) => S2.name === t), [r3.favorites, t]), x2 = useMemo(() => new g$6((o2 == null ? void 0 : o2.open_interest) ?? 0).mul((o2 == null ? void 0 : o2.index_price) ?? 0).toDecimalPlaces(2).valueOf(), [o2]);
  return useEffect(() => {
    let S2 = new IntersectionObserver((F3) => {
      for (let O2 = 0; O2 < F3.length; O2++) {
        let W2 = F3[O2];
        W2 && (W2.target === f2.current && l2(!W2.isIntersecting), W2.target === p2.current && c(!W2.isIntersecting));
      }
    });
    return f2.current && S2.observe(f2.current), p2.current && S2.observe(p2.current), () => {
      S2.disconnect();
    };
  }, []), { symbol: t, isFavorite: d2, favorite: r3, data: o2, quotoDp: n4, openInterest: x2, fundingRate: a2, containerRef: m2, leadingElementRef: f2, tailingElementRef: p2, leadingVisible: i, tailingVisible: u2, onScoll: (S2) => {
    var _a3, _b2;
    S2 === "left" ? (_a3 = m2.current) == null ? void 0 : _a3.scrollBy({ left: -100, behavior: "smooth" }) : (_b2 = m2.current) == null ? void 0 : _b2.scrollBy({ left: 100, behavior: "smooth" });
  } };
}
var ni$1 = (e2) => {
  let { symbol: t, ...o2 } = e2, a2 = wo({ symbol: t });
  return jsx(yo$2, { ...a2, ...o2 });
};
var zr$1 = ({ activeFundingTab: e2, onFundingTabChange: t }) => {
  let { searchValue: o2, onSearchValueChange: a2, clearSearchValue: r3 } = g$1(), { t: s2 } = ne$6(), n4 = jsx(Fo$3, { value: o2, onValueChange: a2, placeholder: s2("markets.search.placeholder"), className: "oui-w-[240px] oui-my-1", size: "sm", "data-testid": "oui-testid-markets-searchMarket-input", prefix: jsx(W$2, { pl: 3, pr: 1, children: jsx(K, { className: "oui-text-base-contrast-36" }) }), suffix: o2 && jsx(W$2, { mr: 2, children: jsx(en$2, { size: 14, className: "oui-text-base-contrast-36 oui-cursor-pointer", onClick: r3 }) }), autoComplete: "off" });
  return jsx(W$2, { id: "oui-funding-list", intensity: 900, p: 6, mt: 4, r: "2xl", children: jsxs(jl, { variant: "contained", size: "lg", value: e2, onValueChange: t, trailing: n4, children: [jsx($l, { title: s2("common.overview"), value: "overview", testid: "oui-testid-funding-overview-tab", children: jsx(to$1, {}) }), jsx($l, { title: s2("markets.funding.comparison"), value: "comparison", testid: "oui-testid-funding-comparison-tab", children: jsx(so$1, {}) })] }) });
};
function Er() {
  let [e2, t] = useState("overview");
  return { activeFundingTab: e2, onFundingTabChange: (o2) => t(o2) };
}
var Ur = () => {
  let e2 = Er();
  return jsx(zr$1, { ...e2 });
};
var qi = (e2) => {
  let [t, o2] = useState("markets"), { t: a2 } = ne$6();
  return jsx(E$1, { onSymbolChange: e2.onSymbolChange, children: jsx(W$2, { id: "oui-markets-home-page", className: cnBase("oui-font-semibold", e2.className), p: 6, children: jsxs(jl, { variant: "text", size: "xl", value: t, onValueChange: o2, children: [jsxs($l, { title: a2("common.markets"), value: "markets", testid: "oui-testid-markets-tab", children: [jsx(Ft$2, {}), jsx(Ht, {})] }), jsx($l, { title: a2("common.funding"), value: "funding", testid: "oui-testid-funding-tab", children: jsx(Ur, {}) })] }) }) });
};
var Ke$1 = (e2) => {
  let { pinned: t, orderTypeExtra: r3 } = e2, { t: o2 } = ne$6(), a2 = (i) => (c) => {
    e2.onValueChange && e2.onValueChange("order_type_ext", c ? i : "");
  };
  return useEffect(() => {
    var _a3;
    (_a3 = e2.onValueChange) == null ? void 0 : _a3.call(e2, "visible_quantity", e2.hidden ? 0 : 1);
  }, [e2.hidden]), jsxs("div", { className: "oui-text-base-contrast-54", children: [jsxs(z$3, { justify: t ? "start" : "between", mb: 3, width: t ? "unset" : "100%", className: "oui-gap-x-2 md:oui-gap-x-3", wrap: "wrap", gapY: 1, children: [jsxs(z$3, { itemAlign: "center", children: [jsx(pi$1, { "data-testid": "oui-testid-orderEntry-postOnly-checkBox", id: "toggle_order_post_only", className: "oui-peer", color: "white", variant: "radio", disabled: !e2.showExtra, checked: r3 === OrderType.POST_ONLY, onCheckedChange: a2(OrderType.POST_ONLY) }), jsx("label", { htmlFor: "toggle_order_post_only", className: cnBase("oui-text-2xs oui-ml-1 peer-data-[disabled]:oui-text-base-contrast-20", "oui-break-normal oui-whitespace-nowrap"), children: o2("orderEntry.orderType.postOnly") })] }), jsxs(z$3, { itemAlign: "center", children: [jsx(pi$1, { "data-testid": "oui-testid-orderEntry-ioc-checkBox", id: "toggle_order_iov", color: "white", className: "oui-peer", variant: "radio", checked: r3 === OrderType.IOC, onCheckedChange: a2(OrderType.IOC), disabled: !e2.showExtra }), jsx("label", { htmlFor: "toggle_order_iov", className: cnBase("oui-text-2xs oui-ml-1 peer-data-[disabled]:oui-text-base-contrast-20", "oui-break-normal oui-whitespace-nowrap"), children: o2("orderEntry.orderType.ioc") })] }), jsxs(z$3, { itemAlign: "center", children: [jsx(pi$1, { "data-testid": "oui-testid-orderEntry-fox-checkBox", id: "toggle_order_fok", color: "white", variant: "radio", className: "oui-peer", checked: r3 === OrderType.FOK, onCheckedChange: a2(OrderType.FOK), disabled: !e2.showExtra }), jsx("label", { htmlFor: "toggle_order_fok", className: cnBase("oui-text-2xs oui-ml-1 peer-data-[disabled]:oui-text-base-contrast-20", "oui-break-normal oui-whitespace-nowrap"), children: o2("orderEntry.orderType.fok") })] })] }), jsxs(z$3, { gapX: 6, children: [jsxs(z$3, { children: [jsx(pi$1, { "data-testid": "oui-testid-orderEntry-orderConfirm-checkBox", id: "toggle_order_confirm", color: "white", checked: e2.needConfirm, onCheckedChange: (i) => {
    e2.setNeedConfirm(!!i);
  } }), jsx("label", { htmlFor: "toggle_order_confirm", className: "oui-text-2xs oui-ml-1", children: o2("orderEntry.orderConfirm") })] }), jsxs(z$3, { children: [jsx(pi$1, { "data-testid": "oui-testid-orderEntry-hidden-checkBox", id: "toggle_order_hidden", color: "white", checked: e2.hidden, onCheckedChange: (i) => {
    e2.setHidden(i);
  } }), jsx("label", { htmlFor: "toggle_order_hidden", className: "oui-text-2xs oui-ml-1", children: o2("orderEntry.hidden") })] })] }), !t && jsxs(Fragment$1, { children: [jsx(de$5, { className: "oui-my-3" }), jsxs(z$3, { children: [jsx(di$2, { "data-testid": "oui-testid-orderEntry-additional-keepVisible-switch", id: "toggle_order_keep_visible", onCheckedChange: (i) => {
    e2.setPinned(i);
  } }), jsx("label", { htmlFor: "toggle_order_keep_visible", className: "oui-text-2xs oui-ml-1", children: o2("orderEntry.keepVisible") })] })] })] });
};
var Ge = () => ({});
var ge$1 = (e2) => {
  let t = Ge();
  return jsx(Ke$1, { ...t, ...e2 });
};
function de$1(e2) {
  let { order_type: t, order_type_ext: r3 } = e2, o2 = [OrderType.ASK, OrderType.BID].includes(r3);
  return t ? t === OrderType.LIMIT && o2 : o2;
}
function He$1(e2, t) {
  if ([BBOOrderType.COUNTERPARTY1, BBOOrderType.COUNTERPARTY5].includes(e2)) return t === OrderSide.BUY ? OrderType.ASK : OrderType.BID;
  if ([BBOOrderType.QUEUE1, BBOOrderType.QUEUE5].includes(e2)) return t === OrderSide.BUY ? OrderType.BID : OrderType.ASK;
}
function We$2(e2) {
  if ([BBOOrderType.COUNTERPARTY1, BBOOrderType.QUEUE1].includes(e2)) return OrderLevel.ONE;
  if ([BBOOrderType.COUNTERPARTY5, BBOOrderType.QUEUE5].includes(e2)) return OrderLevel.FIVE;
}
function $e$1(e2) {
  let { type: t, side: r3, level: o2 } = e2;
  if (t === OrderType.ASK) {
    if (o2 === OrderLevel.ONE) return r3 === OrderSide.BUY ? BBOOrderType.COUNTERPARTY1 : BBOOrderType.QUEUE1;
    if (o2 === OrderLevel.FIVE) return r3 === OrderSide.BUY ? BBOOrderType.COUNTERPARTY5 : BBOOrderType.QUEUE5;
  }
  if (t === OrderType.BID) {
    if (o2 === OrderLevel.ONE) return r3 === OrderSide.BUY ? BBOOrderType.QUEUE1 : BBOOrderType.COUNTERPARTY1;
    if (o2 === OrderLevel.FIVE) return r3 === OrderSide.BUY ? BBOOrderType.QUEUE5 : BBOOrderType.COUNTERPARTY5;
  }
}
var Ne$2 = (e2) => {
  let { baseDP: t, quoteDP: r3, order: o2, onConfirm: a2, onCancel: i } = e2, { side: c, order_type: m2, order_type_ext: s2, level: f2 } = o2, { t: d2 } = ne$6(), [h2, g2] = useLocalStorage("orderly_order_confirm", true), O2 = () => {
    if (m2 === OrderType.MARKET || m2 === OrderType.STOP_MARKET) return jsx(Q$1, { intensity: 80, children: d2("common.marketPrice") });
    if (de$1({ order_type: m2, order_type_ext: s2 })) {
      let _2 = $e$1({ type: s2, side: c, level: f2 }), x2 = { [BBOOrderType.COUNTERPARTY1]: d2("orderEntry.bbo.counterparty1"), [BBOOrderType.COUNTERPARTY5]: d2("orderEntry.bbo.counterparty5"), [BBOOrderType.QUEUE1]: d2("orderEntry.bbo.queue1"), [BBOOrderType.QUEUE5]: d2("orderEntry.bbo.queue5") }[_2];
      return jsx(Q$1, { intensity: 80, children: x2 });
    }
    return jsx(Q$1.numeral, { unit: "USDC", rule: "price", className: "oui-text-base-contrast", unitClassName: "oui-text-base-contrast-36 oui-ml-1", dp: r3, padding: false, children: o2.order_price });
  };
  return jsxs(Fragment$1, { children: [jsxs(z$3, { justify: "between", children: [jsx(Q$1.formatted, { rule: "symbol", showIcon: true, children: o2.symbol }), jsxs(z$3, { justify: "end", gapX: 1, children: [jsx(Dt$2, { type: m2 }), c === OrderSide.BUY ? jsx(Wd, { color: "buy", size: "sm", children: d2("common.buy") }) : jsx(Wd, { color: "sell", size: "sm", children: d2("common.sell") })] })] }), jsx(de$5, { className: "oui-my-4" }), jsxs("div", { className: Ra({ size: "sm", intensity: 54, className: "oui-space-y-1" }), children: [jsxs(z$3, { justify: "between", children: [jsx(Q$1, { children: d2("common.qty") }), jsx(Q$1.numeral, { rule: "price", dp: t, padding: false, className: "oui-text-base-contrast", children: o2.order_quantity })] }), o2.trigger_price ? jsxs(z$3, { justify: "between", children: [jsx(Q$1, { children: d2("common.trigger") }), jsx(Q$1.numeral, { unit: "USDC", rule: "price", className: "oui-text-base-contrast", unitClassName: "oui-text-base-contrast-36 oui-ml-1", dp: r3, padding: false, children: o2.trigger_price })] }) : null, jsxs(z$3, { justify: "between", children: [jsx(Q$1, { children: d2("common.price") }), O2()] }), jsxs(z$3, { justify: "between", children: [jsx(Q$1, { children: d2("common.notional") }), jsx(Q$1.numeral, { unit: "USDC", rule: "price", dp: r3, padding: false, className: "oui-text-base-contrast", unitClassName: "oui-text-base-contrast-36 oui-ml-1", children: o2.total })] })] }), o2.tp_trigger_price || o2.sl_trigger_price ? jsxs(Fragment$1, { children: [jsx(de$5, { className: "oui-my-4" }), jsxs("div", { className: Ra({ size: "sm", intensity: 54, className: "oui-space-y-1" }), children: [o2.tp_trigger_price && jsxs(z$3, { justify: "between", children: [jsx(Q$1, { children: d2("orderEntry.tpMarkPrice") }), jsx(Q$1.numeral, { unit: "USDC", rule: "price", coloring: true, dp: r3, padding: false, unitClassName: "oui-text-base-contrast-36 oui-ml-1", children: o2.tp_trigger_price })] }), o2.sl_trigger_price && jsxs(z$3, { justify: "between", children: [jsx(Q$1, { children: d2("orderEntry.slMarkPrice") }), jsx(Q$1.numeral, { unit: "USDC", rule: "price", coloring: true, className: "oui-text-trade-loss", unitClassName: "oui-text-base-contrast-36 oui-ml-1", dp: r3, padding: false, children: o2.sl_trigger_price })] })] })] }) : null, jsxs(z$3, { gapX: 1, pt: 4, pb: 5, children: [jsx(pi$1, { id: "orderConfirm", color: "white", onCheckedChange: (_2) => {
    g2(!_2);
  } }), jsx("label", { htmlFor: "orderConfirm", className: Ra({ size: "xs", intensity: 54 }), children: d2("orderEntry.disableOrderConfirm") })] }), o2.tp_trigger_price || o2.sl_trigger_price ? jsx(W$2, { py: 3, px: 3, className: "oui-text-center", children: jsx(Q$1, { color: "warning", size: "xs", children: d2("orderEntry.tpsl.trigger.description") }) }) : null, jsxs(Sa$1, { cols: 2, gapX: 3, children: [jsx($e$6, { color: "secondary", size: "md", onClick: () => i(), children: d2("common.cancel") }), jsx($e$6, { size: "md", onClick: () => a2(), children: d2("common.confirm") })] })] });
};
Ne$2.displayName = "OrderConfirmDialog";
var Dt$2 = (e2) => {
  let { t } = ne$6(), r3 = useMemo(() => {
    switch (e2.type) {
      case OrderType.LIMIT:
        return t("orderEntry.orderType.limit");
      case OrderType.MARKET:
        return t("common.marketPrice");
      case OrderType.STOP_LIMIT:
        return t("orderEntry.orderType.stopLimit");
      case OrderType.STOP_MARKET:
        return t("orderEntry.orderType.stopMarket");
      default:
        return "";
    }
  }, [e2.type]);
  return jsx(Wd, { color: "neutral", size: "sm", children: r3 });
}, zt$1 = (e2) => {
  let { close: t, resolve: r3, reject: o2, ...a2 } = e2;
  return jsx(Ne$2, { ...a2, onCancel: t, onConfirm: () => {
    r3(), t();
  } });
}, Se$1 = "orderConfirm";
Wm(Se$1, zt$1, { size: "sm", title: () => o.t("orderEntry.orderConfirm") });
var le$1 = createContext({}), et$2 = le$1.Provider;
var ot = createContext({}), Te = () => useContext(ot), Be$1 = (e2) => {
  let { type: t, values: r3 } = e2, [o2, a2] = useLocalStorage("TP/SL_Mode", "Offset%"), { t: i } = ne$6(), c = useMemo(() => !r3.PnL || !e2.values.trigger_price ? null : jsxs(z$3, { children: [jsx("span", { className: "oui-text-xs oui-text-base-contrast-54", children: o2 === "PnL" ? i("orderEntry.estRoi") : i("orderEntry.estPnL") }), o2 === "PnL" ? jsx(Q$1.numeral, { rule: "percentages", className: cnBase("oui-text-xs oui-ml-1", t === "TP" ? "oui-text-trade-profit" : "oui-text-trade-loss"), children: r3.ROI }) : jsx(Q$1.numeral, { rule: "price", className: cnBase("oui-text-xs oui-ml-1", t === "TP" ? "oui-text-trade-profit" : "oui-text-trade-loss"), children: r3.PnL })] }), [o2, e2.values.PnL, e2.values.trigger_price]);
  return jsx(ot.Provider, { value: { mode: o2, setMode: a2, tipsEle: c }, children: e2.children });
};
var it$1 = (e2) => {
  let { type: t, values: r3, quote_dp: o2 } = e2, { t: a2 } = ne$6(), { mode: i, setMode: c, tipsEle: m2 } = Te(), [s2, f2] = useState(false), [d2, h2] = useState(false), g2 = useMemo(() => {
    switch (i) {
      case "Offset":
        return `${t.toLowerCase()}_offset`;
      case "Offset%":
        return `${t.toLowerCase()}_offset_percentage`;
      default:
        return `${t.toLowerCase()}_pnl`;
    }
  }, [i]), [O2, _2] = useState(r3[i]);
  useEffect(() => {
    d2 || _2(r3[i]);
  }, [r3, i, d2]);
  let x2 = useMemo(() => [{ label: a2("tpsl.pnl"), value: "PnL", testId: "PnL_menu_item" }, { label: a2("tpsl.offset"), value: "Offset", testId: "Offset_mneu_item" }, { label: `${a2("tpsl.offset")}%`, value: "Offset%", testId: "Offset%_menu_item" }], [a2]), A2 = useMemo(() => ({ PnL: a2("tpsl.pnl"), Offset: a2("tpsl.offset"), "Offset%": `${a2("tpsl.offset")}%` }), [a2]), v3 = useRef("");
  return { mode: i, modes: x2, modeLabelMap: A2, formatter: (B2) => {
    let { dp: w4 = 2 } = B2;
    return { onRenderBefore: (u2, H2) => (u2 = `${u2}`, t === "SL" && i === "PnL" && (u2 = u2.startsWith("-") ? u2 : "-" + u2), u2 === "" || u2 === "-" ? "" : i === "Offset%" ? `${new g$6(u2.replace(new RegExp(v3.current.replace(".", "\\.") + "$"), "")).mul(100).todp(2, 4).toString()}${v3.current}` : (i === "Offset" && (u2 = O$7(u2, w4)), `${u2}`)), onSendBefore: (u2) => {
      if (/^\-?0{2,}$/.test(u2)) return "0";
      if (i === "Offset%") {
        if (u2 !== "") {
          u2 = O$7(u2, 2);
          let H2 = u2.match(/\.0{0,2}$/);
          H2 ? v3.current = H2[0] : v3.current = "", u2 = new g$6(u2).div(100).toString(), u2 = `${u2}${v3.current}`;
        }
      } else u2 = O$7(u2, w4);
      return u2 === "" || u2 === "-" ? "" : u2;
    } };
  }, onModeChange: (B2) => {
    c(B2);
  }, onFocus: () => {
    f2(true), h2(true);
  }, onBlur: () => {
    f2(false), h2(false), e2.onChange(g2, O2);
  }, value: O2, onValueChange: (B2) => {
    _2(B2), e2.onChange(g2, B2);
  }, quote_dp: o2, tips: s2 ? m2 : void 0 };
};
var dt$1 = (e2) => {
  var _a3, _b2;
  let { mode: t, modes: r3, modeLabelMap: o2, onModeChange: a2, onValueChange: i, quote: c, quote_dp: m2, value: s2, type: f2, tips: d2, onFocus: h2, onBlur: g2 } = e2, [O2, _2] = useState(t), [x2, A2] = useState(t === "Offset%" ? "%" : c);
  useEffect(() => {
    _2(t), A2(t === "Offset%" ? "%" : c);
  }, [t]), useEffect(() => {
    _2(s2 ? "" : t);
  }, [s2]);
  let v3 = useMemo(() => `${f2.toLowerCase()}_${t.toLowerCase()}`, []);
  return jsx(Fo$3.tooltip, { prefix: o2[O2] || O2, size: "md", placeholder: x2, id: v3, align: "right", value: s2, tooltip: d2, tooltipProps: { content: { side: e2.type === "TP" ? "top" : "bottom" } }, "data-testid": (_a3 = e2.testIds) == null ? void 0 : _a3.input, autoComplete: "off", onValueChange: i, formatters: [e2.formatter({ dp: m2, mode: t, type: f2 }), li$3.currencyFormatter], classNames: { root: f2 === "TP" ? "oui-text-trade-profit" : "oui-text-trade-loss", additional: "oui-text-base-contrast-54", input: "oui-text-inherit" }, onFocus: () => {
    _2(""), A2(""), h2();
  }, onBlur: () => {
    _2(s2 ? "" : t), A2(t === "Offset%" ? "%" : c), g2();
  }, suffix: jsxs(Fragment$1, { children: [t === "Offset%" && !!s2 && jsx(Q$1, { size: "2xs", color: "inherit", className: "oui-ml-[2px]", children: "%" }), jsx(sr$1, { mode: t, modes: r3, onModeChange: (q2) => a2(q2.value), testId: (_b2 = e2.testIds) == null ? void 0 : _b2.dropDown })] }) });
}, sr$1 = (e2) => jsx(xg, { currentValue: e2.mode, menu: e2.modes, align: "end", size: "xs", className: "oui-min-w-[80px]", onCloseAutoFocus: (t) => t.preventDefault(), onSelect: (t) => e2.onModeChange(t), children: jsx("button", { className: "oui-p-2", "data-testid": e2.testId, children: jsx(oe$7, { size: 12, color: "white" }) }) });
var lt$1 = (e2) => {
  let { testIds: t, quote: r3, ...o2 } = e2, a2 = it$1(o2);
  return jsx(dt$1, { ...a2, testIds: t, quote: r3, type: e2.type });
};
var pt$1 = (e2) => {
  let t = ze__default__default.useRef(null), { t: r3 } = ne$6();
  return useEffect(() => {
    e2.orderType !== OrderType.LIMIT && e2.orderType !== OrderType.MARKET && e2.onSwitchChanged(false);
  }, [e2.orderType]), e2.orderType !== OrderType.LIMIT && e2.orderType !== OrderType.MARKET || e2.isReduceOnly ? null : jsxs("div", { children: [jsxs(z$3, { itemAlign: "center", gapX: 1, children: [jsx(di$2, { id: "order_entry_tpsl", className: "oui-h-[14px]", checked: e2.switchState, disabled: e2.orderType !== OrderType.LIMIT && e2.orderType !== OrderType.MARKET || e2.isReduceOnly, onCheckedChange: (o2) => {
    e2.onSwitchChanged(o2);
  } }), jsx("label", { htmlFor: "order_entry_tpsl", className: "oui-text-xs", children: r3("common.tpsl") }), jsx(xn, { color: "white", size: 14, opacity: 1, className: "oui-cursor-pointer oui-text-white/[.36] hover:oui-text-white/80", onClick: () => {
    vo$4.dialog({ title: r3("common.tips"), size: "xs", content: jsx(Q$1, { intensity: 54, children: r3("orderEntry.tpsl.tips") }) });
  } })] }), jsx("div", { className: cnBase("oui-max-h-0 oui-overflow-hidden oui-transition-all", e2.switchState && "oui-max-h-[100px]"), onTransitionEnd: () => {
    var _a3;
    (_a3 = t.current) == null ? void 0 : _a3.style.setProperty("opacity", e2.switchState ? "1" : "0");
  }, children: jsx(yt$1, { ref: t, onChange: e2.onChange, values: e2.values, errors: e2.errors, quote_dp: e2.quote_dp }) })] });
}, yt$1 = ze__default__default.forwardRef((e2, t) => {
  let { parseErrorMsg: r3 } = Lr$3(e2.errors);
  return jsxs("div", { ref: t, className: "oui-space-y-1 oui-px-px oui-py-2 oui-transition-all", children: [jsx(Be$1, { values: e2.values.tp, type: "TP", children: jsx(ut, { type: "TP", error: r3("tp_trigger_price"), onChange: e2.onChange, values: e2.values.tp, quote_dp: e2.quote_dp, testIds: { first: "oui-testid-orderEntry-tpsl-tpPrice-input", second: "oui-testid-orderEntry-tpsl-tpPnl-input", dropDown: "oui-testid-orderEntry-tpsl-tp-dropDown-trigger-button" } }) }), jsx(Be$1, { values: e2.values.sl, type: "SL", children: jsx(ut, { type: "SL", error: r3("sl_trigger_price"), onChange: e2.onChange, values: e2.values.sl, quote_dp: e2.quote_dp, testIds: { first: "oui-testid-orderEntry-tpsl-slPrice-input", second: "oui-testid-orderEntry-tpsl-slPnl-input", dropDown: "oui-testid-orderEntry-tpsl-sl-dropDown-trigger-button" } }) })] });
});
yt$1.displayName = "TPSLInputForm";
var Or = (e2) => {
  let { t } = ne$6(), { errorMsgVisible: r3 } = useContext(le$1), { tipsEle: o2 } = Te(), [a2, i] = useState(`${e2.type} Price`), [c, m2] = useState("USDC"), [s2, f2] = useState(false), [d2, h2] = useState(false), [g2, O2] = useState(e2.values.trigger_price ?? "");
  useEffect(() => {
    d2 || O2(e2.values.trigger_price ?? "");
  }, [e2.values.trigger_price, d2]);
  let _2 = useMemo(() => e2.error && r3 ? e2.error : s2 ? o2 : null, [e2.error, r3, s2, o2]), x2 = (U2) => {
    let S2 = e2.type === "TP" ? t("tpsl.tpPrice") : t("tpsl.slPrice");
    return U2 && (S2 = e2.type === "TP" ? t("tpsl.tp") : t("tpsl.sl")), S2;
  }, A2 = (U2) => {
    O2(U2), e2.onChange(U2);
  };
  useEffect(() => {
    i(x2(e2.values.trigger_price)), d2 || O2(e2.values.trigger_price ?? "");
  }, [e2.type, e2.values.trigger_price]);
  let v3 = () => {
    i(e2.type === "TP" ? t("tpsl.tp") : t("tpsl.sl")), m2(""), f2(true), h2(true);
  }, q2 = () => {
    i(x2(e2.values.trigger_price)), m2("USDC"), f2(false), h2(false), e2.onChange(g2);
  };
  return jsx(Fo$3.tooltip, { "data-testid": e2.testId, prefix: a2, size: "md", placeholder: c, align: "right", onFocus: v3, onBlur: q2, tooltip: _2, tooltipProps: { content: { side: e2.type === "TP" ? "top" : "bottom" } }, color: e2.error ? "danger" : void 0, autoComplete: "off", value: g2, classNames: { additional: "oui-text-base-contrast-54", root: "oui-pr-2 md:oui-pr-3", prefix: "oui-pr-1 md:oui-pr-2" }, onValueChange: A2, formatters: [li$3.numberFormatter, li$3.dpFormatter(e2.quote_dp ?? 2), li$3.currencyFormatter] });
}, ut = (e2) => {
  var _a3, _b2, _c2;
  let t = e2.type === "SL" ? "sl_trigger_price" : "tp_trigger_price";
  return jsxs(Sa$1, { cols: 2, gapX: 1, children: [jsx(Or, { testId: (_a3 = e2.testIds) == null ? void 0 : _a3.first, type: e2.type, error: e2.error, values: e2.values ?? "", onChange: (r3) => {
    e2.onChange(t, r3);
  }, quote_dp: e2.quote_dp }), jsx(lt$1, { testIds: { input: (_b2 = e2.testIds) == null ? void 0 : _b2.second, dropDown: (_c2 = e2.testIds) == null ? void 0 : _c2.dropDown }, onChange: e2.onChange, quote: "USDC", quote_dp: e2.quote_dp, type: e2.type, values: { PnL: e2.values.PnL, Offset: e2.values.Offset, "Offset%": e2.values["Offset%"], ROI: e2.values.ROI } })] });
};
var De$1 = (e2) => {
  let { side: t, formattedOrder: r3, setOrderValue: o2, symbolInfo: a2, maxQty: i, freeCollateral: c, helper: m2, submit: s2, metaState: f2, bboStatus: d2, bboType: h2, onBBOChange: g2, toggleBBO: O2 } = e2, { curLeverage: _2 } = useLeverage(), { t: x2 } = ne$6(), { isMobile: A2 } = it$6(), { errors: v3, validated: q2 } = f2, [U2, S2] = useState(false), [Y2, B2] = useLocalStorage("orderly_order_confirm", true), [w4, u2] = useLocalStorage("orderly-order-additional-pinned", true), [H2, pe2] = useLocalStorage("orderly-order-hidden", false), Pe2 = useMemo(() => t === OrderSide.BUY ? x2("orderEntry.buyLong") : x2("orderEntry.sellShort"), [t, x2]);
  useEffect(() => {
    q2 && S2(true);
  }, [q2]), useEffect(() => {
    let p2 = ($2) => {
      $2.target.closest("#order-entry-submit-button") || S2((fe2) => fe2 && false);
    };
    return U2 ? document.addEventListener("click", p2) : document.removeEventListener("click", p2), () => {
      document.removeEventListener("click", p2);
    };
  }, [U2]);
  let ve3 = () => {
    m2.validate().then(() => Y2 ? vo$4.show(Se$1, { order: r3, quote: a2.quote, base: a2.base, quoteDP: a2.quote_dp, baseDP: a2.base_dp }) : true, (p2) => {
      if (S2(true), typeof p2 == "object" && (p2.total != null || p2.order_quantity != null || p2.order_price != null || p2.trigger_price != null)) return Promise.reject();
    }).then(() => s2({ resetOnSuccess: false }).then((p2) => {
      p2.success || toast$2.error(p2.message);
    })).catch((p2) => {
      p2 !== "cancel" && typeof p2 == "object" && p2.message && toast$2.error(p2.message);
    });
  }, ye2 = A2 && e2.canTrade;
  return jsx(et$2, { value: { errorMsgVisible: U2 }, children: jsxs("div", { className: "oui-space-y-2 oui-text-base-contrast-54 xl:oui-space-y-3", ref: e2.containerRef, children: [jsxs(z$3, { gapX: 2, className: "oui-flex-col oui-gap-y-3 lg:oui-flex-row", children: [jsxs("div", { className: cnBase("oui-grid oui-w-full oui-flex-1 oui-gap-x-2 lg:oui-flex lg:oui-gap-x-[6px]", ye2 ? "oui-grid-cols-3" : "oui-grid-cols-2"), children: [jsx($e$6, { onClick: () => {
    e2.setOrderValue("side", OrderSide.BUY);
  }, size: "md", fullWidth: true, "data-type": OrderSide.BUY, className: cnBase(t === OrderSide.BUY && e2.canTrade ? "oui-bg-success-darken hover:oui-bg-success-darken/80 active:oui-bg-success-darken/80" : "oui-bg-base-7 oui-text-base-contrast-36 hover:oui-bg-base-6 active:oui-bg-base-6"), "data-testid": "oui-testid-orderEntry-side-buy-button", children: x2("common.buy") }), jsx($e$6, { onClick: () => {
    e2.setOrderValue("side", OrderSide.SELL);
  }, "data-type": OrderSide.SELL, fullWidth: true, size: "md", className: cnBase(t === OrderSide.SELL && e2.canTrade ? "oui-bg-danger-darken hover:oui-bg-danger-darken/80 active:oui-bg-danger-darken/80" : "oui-bg-base-7 oui-text-base-contrast-36 hover:oui-bg-base-6 active:oui-bg-base-6"), "data-testid": "oui-testid-orderEntry-side-sell-button", children: x2("common.sell") }), ye2 && jsx($e$6, { size: "md", fullWidth: true, trailing: jsx(Za, { size: 12, className: "oui-text-base-contrast-36" }), onClick: () => {
    vo$4.show(oe$4, { currentLeverage: _2 });
  }, className: cnBase("oui-bg-base-7 oui-text-primary-light hover:oui-bg-base-6 active:oui-bg-base-6"), children: E$4(_2, { fix: 2 }) + "x" })] }), jsx("div", { className: "oui-w-full lg:oui-flex-1", children: jsx(Gr$1, { type: r3.order_type, side: t, canTrade: e2.canTrade, onChange: (p2) => {
    o2("order_type", p2);
  } }) })] }), jsxs(z$3, { justify: "between", children: [jsx(Q$1, { size: "2xs", children: x2("common.available") }), jsx(Q$1.numeral, { unit: a2.quote, size: "2xs", className: "oui-text-base-contrast-80", unitClassName: "oui-ml-1 oui-text-base-contrast-54", dp: 2, padding: false, children: e2.canTrade ? c : 0 })] }), jsx(Qr$1, { type: e2.type, symbolInfo: a2, values: { quantity: r3.order_quantity, price: r3.order_price, trigger_price: r3.trigger_price, total: r3.total, level: r3.level, side: r3.side, order_type_ext: r3.order_type_ext }, errors: q2 ? v3 : null, onChange: (p2, $2) => {
    e2.setOrderValue(p2, $2);
  }, onValuesChange: e2.setOrderValues, refs: e2.refs, onBlur: e2.onBlur, onFocus: e2.onFocus, bbo: { bboStatus: d2, bboType: h2, onBBOChange: g2, toggleBBO: O2 }, priceInputContainerWidth: e2.priceInputContainerWidth }), jsx(Kr, { canTrade: e2.canTrade, maxQty: i, currentQtyPercentage: e2.currentQtyPercentage, value: r3.order_quantity ? Number(r3.order_quantity) : 0, tick: a2.base_tick, dp: a2.base_dp, setMaxQty: e2.setMaxQty, onValueChange: (p2) => {
    o2("order_quantity", p2);
  }, side: e2.side }), jsx(Sr$2, { fullWidth: true, id: "order-entry-submit-button", "data-type": OrderSide.BUY, className: cnBase(t === OrderSide.BUY ? "orderly-order-entry-submit-button-buy oui-bg-success-darken hover:oui-bg-success-darken/80 active:oui-bg-success-darken/80" : "orderly-order-entry-submit-button-sell oui-bg-danger-darken hover:oui-bg-danger-darken/80 active:oui-bg-danger-darken/80"), onClick: () => {
    ve3();
  }, loading: e2.isMutating, disabled: !e2.canTrade, children: Pe2 }), jsx(Hr$1, { canTrade: e2.canTrade, quote: a2.quote, estLiqPrice: e2.estLiqPrice, estLeverage: e2.estLeverage, currentLeverage: e2.currentLeverage }), jsx(de$5, { className: "oui-w-full" }), jsx(pt$1, { quote_dp: e2.symbolInfo.quote_dp, switchState: e2.tpslSwitch, onSwitchChanged: e2.setTpslSwitch, orderType: r3.order_type, errors: q2 ? v3 : null, isReduceOnly: r3.reduce_only, values: { tp: { trigger_price: r3.tp_trigger_price ?? "", PnL: r3.tp_pnl ?? "", Offset: r3.tp_offset ?? "", "Offset%": r3.tp_offset_percentage ?? "", ROI: r3.tp_ROI ?? "" }, sl: { trigger_price: r3.sl_trigger_price ?? "", PnL: r3.sl_pnl ?? "", Offset: r3.sl_offset ?? "", "Offset%": r3.sl_offset_percentage ?? "", ROI: r3.sl_ROI ?? "" } }, onChange: (p2, $2) => {
    e2.setOrderValue(p2, $2);
  } }), jsxs(z$3, { justify: "between", itemAlign: "center", className: "!oui-mt-0 xl:!oui-mt-3", children: [jsxs(z$3, { itemAlign: "center", gapX: 1, children: [jsx(di$2, { "data-testid": "oui-testid-orderEntry-reduceOnly-switch", className: "oui-h-[14px]", id: "reduceOnly", checked: e2.formattedOrder.reduce_only, onCheckedChange: (p2) => {
    e2.setOrderValue("reduce_only", p2);
  } }), jsx("label", { htmlFor: "reduceOnly", className: "oui-text-xs", children: x2("orderEntry.reduceOnly") })] }), !w4 && jsx(Wr$1, { pinned: w4, setPinned: u2, needConfirm: Y2, setNeedConfirm: B2, onValueChange: o2, orderTypeExtra: r3.order_type_ext, showExtra: r3.order_type === OrderType.LIMIT && !e2.tpslSwitch, hidden: H2, setHidden: pe2 })] }), w4 && jsxs(W$2, { p: 2, r: "md", intensity: 700, position: "relative", children: [jsx(ge$1, { pinned: w4, setPinned: u2, needConfirm: Y2, setNeedConfirm: B2, onValueChange: o2, orderTypeExtra: r3.order_type_ext, showExtra: r3.order_type === OrderType.LIMIT && !e2.tpslSwitch, hidden: H2, setHidden: pe2 }), jsx(zr, { onClick: () => {
    u2(false);
  }, className: "oui-group oui-absolute oui-right-2 oui-top-2", "data-testid": "oui-testid-orderEntry-pinned-button" })] })] }) });
}, bt$2 = "M10.007 1.302a.74.74 0 0 0-.486.214c-1.033.989-1.349 1.815-.972 2.948-.88.675-1.437.84-2.536.84-1.503 0-2.484.182-3.152.85v.02a1.583 1.583 0 0 0 0 2.248l1.867 1.882-3.181 3.18c-.26.26-.28.696-.02.956.261.26.699.26.959 0l3.193-3.194 1.87 1.861a1.585 1.585 0 0 0 2.25 0h.02c.668-.667.854-1.523.854-3.144 0-1.03.212-1.758.852-2.523 1.233.361 1.95.015 2.961-.995a.68.68 0 0 0 .188-.48c0-.234-.06-.593-.209-1.04a5.34 5.34 0 0 0-1.312-2.103 5.35 5.35 0 0 0-2.104-1.312c-.448-.15-.808-.208-1.042-.208", zr = (e2) => {
  let [t, r3] = useState(bt$2);
  return jsx("button", { ...e2, children: jsx("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", onMouseEnter: () => {
    r3('M10.008 1.302a.74.74 0 0 0-.486.214c-1.033.989-1.349 1.815-.972 2.948-.88.675-1.437.84-2.536.84-1.503 0-2.484.182-3.152.85v.02a1.583 1.583 0 0 0 0 2.248l1.867 1.882-3.181 3.18c-.26.26-.28.696-.02.956.261.26.699.26.959 0l3.193-3.194 1.87 1.861a1.585 1.585 0 0 0 2.25 0h.02c.668-.667.854-1.523.854-3.144 0-1.03.212-1.758.853-2.523 1.232.361 1.95.015 2.96-.995a.68.68 0 0 0 .188-.48c0-.234-.06-.593-.209-1.04a5.34 5.34 0 0 0-1.312-2.103A5.35 5.35 0 0 0 11.05 1.51c-.448-.15-.808-.208-1.042-.208m.258 1.37c.708.131 1.421.6 1.93 1.107.507.508.94 1.13 1.119 1.945-.636.61-1.026.658-1.662.323a.67.67 0 0 0-.779.117c-1.214 1.213-1.533 2.314-1.533 3.8 0 1.292-.076 1.773-.48 2.206-.113.123-.27.104-.374 0L3.799 7.486a.24.24 0 0 1-.017-.34c.239-.29.769-.515 2.226-.514 1.742.001 2.668-.448 3.812-1.52a.67.67 0 0 0 .125-.77c-.343-.686-.29-1.047.321-1.67"');
  }, onMouseLeave: () => {
    r3(bt$2);
  }, className: "oui-text-primary-darken ", children: jsx("path", { d: t }) }) });
}, Qr$1 = (e2) => {
  let { type: t, symbolInfo: r3, errors: o2, values: a2, onFocus: i, onBlur: c, bbo: m2 } = e2, { t: s2 } = ne$6(), { parseErrorMsg: f2 } = Lr$3(o2), d2 = m2.bboStatus === "on", h2 = t === OrderType.LIMIT ? jsxs(z$3, { direction: "column", itemAlign: "end", className: "oui-text-2xs", children: [r3.quote, jsx(z$3, { height: 20, px: 3, justify: "center", itemAlign: "center", r: "base", className: cnBase("oui-mt-[2px] oui-cursor-pointer oui-select-none oui-border", m2.bboStatus === "on" ? "oui-border-primary" : "oui-border-line-12", m2.bboStatus === "disabled" && "oui-cursor-not-allowed"), onClick: () => {
    m2.bboStatus === "disabled" ? vo$4.dialog({ title: s2("common.tips"), size: "xs", content: jsx(Q$1, { intensity: 54, children: s2("orderEntry.bbo.disabled.tips") }) }) : m2.toggleBBO();
  }, children: jsx(Q$1, { className: cnBase(m2.bboStatus === "on" && "oui-text-primary", m2.bboStatus === "off" && "oui-text-base-contrast-54", m2.bboStatus === "disabled" && "oui-text-base-contrast-20"), children: s2("orderEntry.bbo") }) })] }) : r3.quote;
  return jsxs("div", { className: "oui-space-y-1", children: [t === OrderType.STOP_LIMIT || t === OrderType.STOP_MARKET ? jsx("div", { className: "oui-group", children: jsx(ce$1, { label: s2("common.trigger"), suffix: r3.quote, error: f2("trigger_price"), id: "trigger", ref: e2.refs.triggerPriceInputRef, value: a2.trigger_price, onChange: (g2) => {
    e2.onChange("trigger_price", g2);
  }, formatters: [li$3.dpFormatter(r3.quote_dp)], onFocus: i(1), onBlur: c(1) }) }) : null, t === OrderType.LIMIT || t === OrderType.STOP_LIMIT ? jsxs("div", { ref: e2.refs.priceInputContainerRef, className: "oui-group oui-relative oui-w-full", children: [jsx(ce$1, { label: s2("common.price"), suffix: h2, id: "price", value: a2.price, error: f2("order_price"), ref: e2.refs.priceInputRef, onChange: (g2) => {
    e2.onChange("order_price", g2);
  }, formatters: [li$3.dpFormatter(r3.quote_dp)], onFocus: i(0), onBlur: c(0), readonly: d2, classNames: { root: cnBase(d2 && "focus-within:oui-outline-transparent "), input: cnBase(d2 && "oui-cursor-auto") } }), m2.bboStatus === "on" && jsx("div", { className: cnBase("oui-absolute oui-bottom-1 oui-left-0"), children: jsx($r$2, { value: m2.bboType, onChange: m2.onBBOChange, contentStyle: { width: e2.priceInputContainerWidth } }) })] }) : null, jsxs(Sa$1, { cols: 2, className: "oui-group oui-space-x-1", children: [jsx(ce$1, { label: s2("common.qty"), suffix: r3.base, id: "order_quantity_input", name: "order_quantity_input", className: "!oui-rounded-r", value: a2.quantity, error: f2("order_quantity"), onChange: (g2) => {
    e2.onChange("order_quantity", g2);
  }, formatters: [li$3.dpFormatter(r3.base_dp)], onFocus: i(2), onBlur: c(2) }), jsx(ce$1, { label: `${s2("common.total")}`, suffix: r3.quote, id: "total", className: "!oui-rounded-l", value: a2.total, error: f2("total"), onChange: (g2) => {
    e2.onChange("total", g2);
  }, onFocus: i(3), onBlur: c(3), formatters: [li$3.dpFormatter(r3.quote_dp)] })] })] });
}, ce$1 = forwardRef((e2, t) => {
  var _a3, _b2, _c2, _d3;
  let { errorMsgVisible: r3 } = useContext(le$1), [o2, a2] = useState("0");
  return jsx(Fo$3.tooltip, { ref: t, tooltip: r3 ? e2.error : void 0, autoComplete: "off", autoFocus: e2.autoFocus, size: "lg", placeholder: e2.readonly ? "" : o2, id: e2.id, name: e2.name, color: e2.error ? "danger" : void 0, prefix: jsx(Yr, { id: e2.id, children: e2.label }), suffix: e2.suffix, value: e2.readonly ? "" : e2.value || "", onValueChange: e2.onChange, onFocus: (i) => {
    var _a4;
    a2(""), (_a4 = e2.onFocus) == null ? void 0 : _a4.call(e2, i);
  }, onBlur: (i) => {
    var _a4;
    a2("0"), (_a4 = e2.onBlur) == null ? void 0 : _a4.call(e2, i);
  }, formatters: [...e2.formatters ?? [], li$3.numberFormatter, li$3.currencyFormatter, li$3.decimalPointFormatter], classNames: { root: cnBase("orderly-order-entry oui-relative oui-h-[54px] oui-rounded oui-border oui-border-solid oui-border-line oui-px-2 oui-py-1 group-first:oui-rounded-t-xl group-last:oui-rounded-b-xl", e2.className, (_a3 = e2.classNames) == null ? void 0 : _a3.root), input: cnBase("oui-mb-1 oui-mt-5 oui-h-5", (_b2 = e2 == null ? void 0 : e2.classNames) == null ? void 0 : _b2.input), prefix: cnBase("oui-absolute oui-left-2 oui-top-[7px] oui-text-base-contrast-36", (_c2 = e2.classNames) == null ? void 0 : _c2.prefix), suffix: cnBase("oui-absolute oui-right-0 oui-top-0 oui-justify-start oui-py-2 oui-text-2xs oui-text-base-contrast-36", (_d3 = e2.classNames) == null ? void 0 : _d3.suffix) }, readOnly: e2.readonly });
});
ce$1.displayName = "CustomInput";
var Yr = (e2) => jsx("label", { htmlFor: e2.id, className: "oui-absolute oui-left-2 oui-top-[7px] oui-text-2xs oui-text-base-contrast-36", children: e2.children }), Kr = (e2) => {
  let { canTrade: t } = e2, { t: r3 } = ne$6(), o2 = useMemo(() => t ? e2.side === OrderSide.BUY ? "buy" : "sell" : void 0, [e2.side, t]), a2 = useMemo(() => e2.side === OrderSide.BUY ? r3("orderEntry.maxBuy") : r3("orderEntry.maxSell"), [e2.side, r3]);
  return jsxs("div", { children: [jsx(iu.single, { disabled: e2.maxQty === 0 || !t, value: e2.value, color: o2, markCount: 4, showTip: true, max: e2.maxQty, step: e2.tick, onValueChange: e2.onValueChange }), jsxs(z$3, { justify: "between", className: "oui-pt-1 xl:oui-pt-2", children: [jsx(Q$1.numeral, { rule: "percentages", size: "2xs", color: o2, dp: 2, padding: false, children: t ? e2.currentQtyPercentage : 0 }), jsxs(z$3, { children: [jsx("button", { className: Ra({ size: "2xs", className: "oui-mr-1" }), onClick: () => e2.setMaxQty(), "data-testid": "oui-testid-orderEntry-maxQty-value-button", children: a2 }), jsx(Q$1.numeral, { size: "2xs", color: o2, dp: e2.dp, padding: false, "data-testid": "oui-testid-orderEntry-maxQty-value", children: t ? e2.maxQty : 0 })] })] })] });
}, Gr$1 = (e2) => {
  let { t } = ne$6(), r3 = [{ label: t("orderEntry.orderType.limitOrder"), value: OrderType.LIMIT }, { label: t("orderEntry.orderType.marketOrder"), value: OrderType.MARKET }, { label: t("orderEntry.orderType.stopLimit"), value: OrderType.STOP_LIMIT }, { label: t("orderEntry.orderType.stopMarket"), value: OrderType.STOP_MARKET }];
  return jsx(Be$6.options, { testid: "oui-testid-orderEntry-orderType-button", currentValue: e2.type, value: e2.type, options: r3, onValueChange: e2.onChange, contentProps: { className: "oui-bg-base-8 oui-w-full" }, valueFormatter: (o2, a2) => {
    if (!r3.find((m2) => m2.value === o2)) return jsx(Q$1, { size: "xs", children: a2.placeholder });
    let c = { [OrderType.LIMIT]: t("orderEntry.orderType.limit"), [OrderType.MARKET]: t("common.marketPrice"), [OrderType.STOP_LIMIT]: t("orderEntry.orderType.stopLimit"), [OrderType.STOP_MARKET]: t("orderEntry.orderType.stopMarket") }[o2];
    return jsx(Q$1, { size: "xs", color: e2.canTrade ? e2.side === OrderSide.BUY ? "buy" : "sell" : void 0, children: c });
  }, size: "md" });
};
function Hr$1(e2) {
  let { canTrade: t } = e2, { t: r3 } = ne$6();
  return jsxs("div", { className: "oui-space-y-[2px] xl:oui-space-y-1", children: [jsxs(z$3, { justify: "between", children: [jsx(Q$1, { size: "2xs", children: r3("orderEntry.estLiqPrice") }), jsx(Q$1.numeral, { unit: e2.quote, size: "2xs", className: "oui-text-base-contrast-80", unitClassName: "oui-ml-1 oui-text-base-contrast-36", children: t ? e2.estLiqPrice ?? "--" : "--" })] }), jsxs(z$3, { justify: "between", children: [jsx(Q$1, { size: "2xs", children: r3("leverage.accountLeverage") }), jsxs(z$3, { gapX: 1, className: Ra({ size: "2xs", intensity: 80 }), children: [jsx(Q$1.numeral, { unit: t ? "x" : void 0, children: t ? e2.currentLeverage ?? "--" : "--" }), e2.estLeverage && jsxs(Fragment$1, { children: [jsx("svg", { width: "10", height: "10", viewBox: "0 0 10 10", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: jsx("path", { d: "M2.505 4.997c0-.23.186-.416.416-.416H6.07L4.833 3.332l.586-.585 1.964 1.95a.42.42 0 0 1 .122.3.42.42 0 0 1-.122.3l-1.964 1.95-.586-.585L6.07 5.413H2.921a.416.416 0 0 1-.416-.416", fill: "#fff", fillOpacity: ".54" }) }), jsx("span", { children: `${e2.estLeverage}x` })] })] })] })] });
}
function Wr$1(e2) {
  let [t, r3] = useState(false);
  return jsxs(It$3, { open: t, onOpenChange: r3, children: [jsx(as$1, { asChild: true, children: jsx("button", { "data-testid": "oui-testid-orderEntry-additional-button", onClick: () => {
    r3(true);
  }, children: jsx("svg", { width: "16", height: "16", viewBox: "0 0 16 16", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", className: "oui-fill-white/[.36] hover:oui-fill-white/80", children: jsx("path", { d: "M3.332 2.665a.667.667 0 0 0-.667.667v1.333c0 .368.299.667.667.667h1.333a.667.667 0 0 0 .667-.667V3.332a.667.667 0 0 0-.667-.667zm4 0a.667.667 0 0 0-.667.667v1.333c0 .368.299.667.667.667h1.333a.667.667 0 0 0 .667-.667V3.332a.667.667 0 0 0-.667-.667zm4 0a.667.667 0 0 0-.667.667v1.333c0 .368.299.667.667.667h1.333a.667.667 0 0 0 .667-.667V3.332a.667.667 0 0 0-.667-.667zm-8 4a.667.667 0 0 0-.667.667v1.333c0 .368.299.667.667.667h1.333a.667.667 0 0 0 .667-.667V7.332a.667.667 0 0 0-.667-.667zm4 0a.667.667 0 0 0-.667.667v1.333c0 .368.299.667.667.667h1.333a.667.667 0 0 0 .667-.667V7.332a.667.667 0 0 0-.667-.667zm4 0a.667.667 0 0 0-.667.667v1.333c0 .368.299.667.667.667h1.333a.667.667 0 0 0 .667-.667V7.332a.667.667 0 0 0-.667-.667zm-8 4a.667.667 0 0 0-.667.667v1.333c0 .368.299.667.667.667h1.333a.667.667 0 0 0 .667-.667v-1.333a.667.667 0 0 0-.667-.667zm4 0a.667.667 0 0 0-.667.667v1.333c0 .368.299.667.667.667h1.333a.667.667 0 0 0 .667-.667v-1.333a.667.667 0 0 0-.667-.667zm4 0a.667.667 0 0 0-.667.667v1.333c0 .368.299.667.667.667h1.333a.667.667 0 0 0 .667-.667v-1.333a.667.667 0 0 0-.667-.667z" }) }) }) }), jsx(Vo$3, { side: "top", align: "end", className: "oui-w-[230px]", children: jsx(ge$1, { ...e2 }) })] });
}
var $r$2 = (e2) => {
  let { t } = ne$6(), r3 = [{ label: t("orderEntry.bbo.counterparty1"), value: BBOOrderType.COUNTERPARTY1 }, { label: t("orderEntry.bbo.counterparty5"), value: BBOOrderType.COUNTERPARTY5 }, { label: t("orderEntry.bbo.queue1"), value: BBOOrderType.QUEUE1 }, { label: t("orderEntry.bbo.queue5"), value: BBOOrderType.QUEUE5 }];
  return jsx(Be$6.options, { testid: "oui-testid-orderEntry-bbo-orderType-button", currentValue: e2.value, value: e2.value, options: r3, onValueChange: e2.onChange, contentProps: { className: "oui-bg-base-8 oui-w-full", style: e2.contentStyle }, size: "sm", classNames: { trigger: "oui-border-none oui-bg-transparent" }, valueFormatter: (o2, a2) => {
    let i = r3.find((c) => c.value === o2);
    return jsx(W$2, { children: jsx(Q$1, { size: "sm", children: i == null ? void 0 : i.label }) });
  } });
};
var Qe$1 = (e2) => {
  let [t, r3] = useLocalStorage("orderly-order-entry-order-type", OrderType.LIMIT), [o2, a2] = useLocalStorage("orderly-order-entry-order-side", OrderSide.BUY), [i, c] = useLocalStorage("orderly_order_bbo_type", void 0), m2 = useRef(i), { formattedOrder: s2, setValue: f2, setValues: d2, symbolInfo: h2, ...g2 } = useOrderEntry2(e2.symbol, { initialOrder: { symbol: e2.symbol, order_type: t, side: o2 } }), [O2, _2] = useLocalStorage("orderly-order-entry-tp_sl-switch", false), { state: x2 } = useAccount(), { wrongNetwork: A2, disabledConnect: v3 } = L$3(), q2 = useMemo(() => !A2 && !v3 && (x2.status === AccountStatusEnum.EnableTrading || x2.status === AccountStatusEnum.EnableTradingWithoutConnected), [x2.status, A2, v3]), { currentLeverage: U2 } = useMarginRatio(), S2 = useEventEmitter(), Y2 = useRef(4), B2 = useRef(null), w4 = useRef(null), u2 = useRef(null), [H2, pe2] = useState(0), Pe2 = useMemo(() => Number(s2.order_quantity) >= Number(g2.maxQty) ? 1 : gr$2(Number(s2.order_quantity ?? 0), 0, g2.maxQty) / 100, [s2.order_quantity, g2.maxQty]), ve3 = () => {
    if (h2.base_tick < 1) return;
    let l2 = utils_exports.formatNumber(s2 == null ? void 0 : s2.order_quantity, new g$6((h2 == null ? void 0 : h2.base_tick) || "0").toNumber());
    f2("order_quantity", l2, { shouldUpdateLastChangedField: false });
  }, ye2 = (l2) => (b2) => {
    Y2.current = l2;
  }, p2 = (l2) => (b2) => {
    setTimeout(() => {
      Y2.current === l2 && (Y2.current = 4);
    }, 300), l2 === 2 && ve3();
  }, $2 = () => {
    d2({ tp_trigger_price: "", sl_trigger_price: "" });
  }, Ye2 = () => {
    d2({ order_type_ext: void 0 });
  }, fe2 = () => {
    f2("order_quantity", g2.maxQty);
  }, Ot2 = (l2, b2, j2) => {
    if (l2 === "order_type" && r3(b2), l2 === "side" && a2(b2), l2 === "reduce_only" && b2 || l2 === "order_type" && (b2 === OrderType.STOP_LIMIT || b2 === OrderType.STOP_MARKET)) {
      let F3 = { tp_trigger_price: "", sl_trigger_price: "", [l2]: b2 };
      l2 === "order_type" && (F3.order_type_ext = ""), d2(F3);
      return;
    }
    if (l2 === "order_type" && b2 !== OrderType.LIMIT) {
      let F3 = { level: void 0, order_type_ext: void 0, [l2]: b2 };
      d2(F3);
      return;
    }
    f2(l2, b2, j2);
  }, Et2 = (l2) => {
    _2(l2), l2 ? Ye2() : $2();
  }, ae2 = useMemo(() => O2 || [OrderType.POST_ONLY, OrderType.IOC, OrderType.FOK].includes(s2.order_type_ext) ? "disabled" : i && s2.order_type === OrderType.LIMIT ? "on" : "off", [i, O2, s2.order_type, s2.order_type_ext]), Pt2 = () => {
    i ? (c(void 0), d2({ order_type_ext: void 0, level: void 0 })) : c(m2.current || BBOOrderType.COUNTERPARTY1);
  }, vt2 = (l2) => {
    c(l2), m2.current = l2;
  };
  return useEffect(() => {
    if (ae2 === "disabled") {
      let { order_type_ext: l2 } = s2;
      d2({ order_type_ext: de$1({ order_type_ext: l2 }) ? void 0 : l2, level: void 0 });
    }
  }, [ae2, s2.order_type_ext]), useEffect(() => {
    if (ae2 === "on") {
      let l2 = He$1(i, s2.side), b2 = We$2(i);
      d2({ order_type_ext: l2, level: b2 });
    }
  }, [i, ae2, s2.side]), useEffect(() => {
    let l2 = (b2) => {
      f2("order_price", b2);
    };
    return S2.on("update:orderPrice", l2), () => {
      S2.off("update:orderPrice", l2);
    };
  }, []), useEffect(() => {
    let l2 = (j2) => {
      setTimeout(() => {
        j2 == null ? void 0 : j2.focus();
      }, 0);
    }, b2 = (j2) => {
      let F3 = I$6(j2[0]), { order_type: z2, order_type_ext: Ct2 } = s2;
      if (Y2.current === 1 && (z2 === OrderType.STOP_LIMIT || z2 === OrderType.STOP_MARKET)) {
        f2("trigger_price", F3), l2(B2.current);
        return;
      }
      if (de$1({ order_type: z2, order_type_ext: Ct2 })) {
        c(void 0), d2({ order_type_ext: void 0, level: void 0 }), setTimeout(() => {
          S2.emit("update:orderPrice", F3);
        }, 0), l2(w4.current);
        return;
      }
      if (z2 === OrderType.STOP_LIMIT || z2 === OrderType.LIMIT) {
        f2("order_price", F3), l2(w4.current);
        return;
      }
      if (z2 === OrderType.STOP_MARKET) {
        f2("trigger_price", F3), l2(B2.current);
        return;
      }
      if (z2 === OrderType.MARKET) {
        c(void 0), d2({ order_type: OrderType.LIMIT, order_price: F3 }), l2(w4.current);
        return;
      }
      f2("order_price", F3), l2(w4.current);
    };
    return S2.on("orderbook:item:click", b2), () => {
      S2.off("orderbook:item:click", b2);
    };
  }, [s2, h2]), useEffect(() => {
    let l2 = u2.current;
    if (!l2) return;
    let b2 = new ResizeObserver((j2) => {
      for (let F3 of j2) {
        let z2 = F3.contentRect.width;
        z2 && pe2(z2);
      }
    });
    return b2.observe(l2), () => {
      b2.unobserve(l2);
    };
  }, [u2, s2.order_type_ext]), useEffect(() => {
    g2.reset(), g2.resetMetaState();
  }, [e2.symbol]), { ...g2, currentQtyPercentage: Pe2, side: s2.side, type: s2.order_type, level: s2.level, setOrderValue: Ot2, setOrderValues: d2, currentLeverage: U2, formattedOrder: s2, tpslSwitch: O2, setTpslSwitch: Et2, setMaxQty: fe2, symbolInfo: h2, onFocus: ye2, onBlur: p2, refs: { triggerPriceInputRef: B2, priceInputRef: w4, priceInputContainerRef: u2 }, canTrade: q2, bboStatus: ae2, bboType: i, onBBOChange: vt2, toggleBBO: Pt2, priceInputContainerWidth: H2 };
};
var uo = (e2) => {
  let t = Qe$1(e2);
  return jsx(De$1, { ...t, containerRef: e2.containerRef });
};
function we$1(r3) {
  return jsx("div", { className: "top-toolbar oui-flex oui-h-[44px] oui-justify-between md:oui-justify-start oui-items-center oui-p-2 md:oui-px-3 md:oui-pt-3 md:oui-pb-[14px]", children: r3.children });
}
var $ = (r3) => jsx("svg", { viewBox: "0 0 12 12", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...r3, children: jsx("g", { id: "Caret-down", children: jsx("path", { id: "Vector", d: "M3.00349 3.9978C2.59149 3.9978 2.36564 4.4653 2.61289 4.7948C2.98789 5.2948 5.23784 8.29479 5.61289 8.79479C5.81289 9.06128 6.20974 9.06128 6.40974 8.79479L9.40974 4.7948C9.65694 4.4653 9.41554 3.9978 9.00349 3.9978H3.00349Z" }) }) }), Re$1 = (r3) => jsx("svg", { viewBox: "0 0 18 18", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...r3, children: jsx("g", { id: "Display settings", children: jsx("path", { id: "Union", fillRule: "evenodd", clipRule: "evenodd", d: "M15.0571 10.9856L11.6295 5.06523L8.71377 10.8968C8.38933 11.5456 7.54464 11.7223 6.98733 11.2579L5.75311 10.2294L2.83709 14.7654L1.57532 13.9543L4.49134 9.41824C4.97892 8.65978 6.0207 8.49981 6.71338 9.07705L7.58387 9.80246L10.5991 3.77192C10.9997 2.97082 12.1302 2.93624 12.579 3.71137L14.6517 7.29147C14.7714 7.03643 15.0305 6.85983 15.3309 6.85983C15.7451 6.85983 16.0809 7.19562 16.0809 7.60983C16.0809 8.02405 15.7451 8.35983 15.3309 8.35983C15.31 8.35983 15.2892 8.35897 15.2687 8.35729L16.3553 10.2341L15.0571 10.9856ZM2.58093 6.85983C2.16672 6.85983 1.83093 7.19562 1.83093 7.60983C1.83093 8.02405 2.16672 8.35983 2.58093 8.35983C2.99515 8.35983 3.33093 8.02405 3.33093 7.60983C3.33093 7.19562 2.99515 6.85983 2.58093 6.85983ZM4.83093 6.85983C4.41672 6.85983 4.08093 7.19562 4.08093 7.60983C4.08093 8.02405 4.41672 8.35983 4.83093 8.35983C5.24515 8.35983 5.58093 8.02405 5.58093 7.60983C5.58093 7.19562 5.24515 6.85983 4.83093 6.85983ZM6.33093 7.60983C6.33093 7.19562 6.66672 6.85983 7.08093 6.85983C7.49515 6.85983 7.83093 7.19562 7.83093 7.60983C7.83093 8.02405 7.49515 8.35983 7.08093 8.35983C6.66672 8.35983 6.33093 8.02405 6.33093 7.60983ZM11.5809 6.85983C11.1667 6.85983 10.8309 7.19562 10.8309 7.60983C10.8309 8.02405 11.1667 8.35983 11.5809 8.35983C11.9951 8.35983 12.3309 8.02405 12.3309 7.60983C12.3309 7.19562 11.9951 6.85983 11.5809 6.85983Z" }) }) });
var dt = (r3) => jsx("svg", { viewBox: "0 0 18 18", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...r3, children: jsx("g", { id: "Indicators", children: jsx("path", { id: "Union", fillRule: "evenodd", clipRule: "evenodd", d: "M9.74483 2.25C8.96145 2.25 8.26885 2.76459 8.04549 3.51818L7.46202 5.48254H5.06262V7.08339H6.98652L5.00539 13.7532L4.31554 13.1112L3.22498 14.2831L4.4777 15.4489C5.08739 16.015 6.08317 15.7469 6.32134 14.945L8.65649 7.08339H11.6032V5.48254H9.13198L9.58033 3.97311C9.60167 3.90112 9.66833 3.85084 9.74483 3.85084H11.69V2.25H9.74483ZM10.6234 11.2354L10.2638 11.5172C10.0153 11.712 9.65591 11.6684 9.46115 11.4199C9.26639 11.1713 9.30998 10.812 9.55852 10.6172L10.1451 10.1575C10.5693 9.82514 11.1868 9.94011 11.4642 10.4005L11.4682 10.407L12.1304 11.5752L13.4594 10.3111C13.6882 10.0935 14.05 10.1025 14.2677 10.3313C14.4853 10.5601 14.4763 10.922 14.2475 11.1396L12.7116 12.6006L13.3897 13.797L13.6482 13.4503C13.8369 13.1972 14.1951 13.145 14.4483 13.3337C14.7014 13.5225 14.7536 13.8807 14.5649 14.1338L13.9917 14.9025L13.94 14.9457C13.5178 15.2981 12.8837 15.1886 12.6003 14.7226L12.5958 14.7151L11.8576 13.4129L10.3563 14.841C10.1275 15.0586 9.76561 15.0495 9.54798 14.8208C9.33036 14.592 9.3394 14.2301 9.56819 14.0125L11.2764 12.3875L10.6234 11.2354Z" }) }) }), pt = (r3) => jsx("svg", { viewBox: "0 0 18 18", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...r3, children: jsx("g", { id: "Setting", children: jsx("path", { id: "Vector", d: "M6.72589 1.84154C5.66239 2.17904 4.74515 2.72954 3.93665 3.48254C3.6869 3.71504 3.6104 4.09604 3.7724 4.39604C4.37315 5.50679 3.74464 6.69554 2.38939 6.76379C2.05789 6.78029 1.76465 7.0263 1.68665 7.34955C1.5524 7.9083 1.49915 8.37629 1.49915 8.98979C1.49915 9.50504 1.55464 10.0885 1.66339 10.6075C1.73089 10.9315 2.0129 11.1648 2.3429 11.1933C3.7064 11.311 4.3814 12.3513 3.7724 13.6773C3.6374 13.972 3.6989 14.3245 3.93665 14.545C4.73315 15.2815 5.64814 15.8013 6.72589 16.1388C7.03339 16.2348 7.38064 16.1185 7.56964 15.8575C8.40364 14.7033 9.6134 14.6995 10.4054 15.8575C10.5921 16.1298 10.9341 16.261 11.2491 16.162C12.2894 15.8343 13.2584 15.277 14.0616 14.545C14.3091 14.3193 14.3744 13.954 14.2259 13.654C13.6019 12.3948 14.3197 11.239 15.6082 11.2165C15.9502 11.2105 16.2547 10.9863 16.3349 10.654C16.4647 10.1163 16.4991 9.64829 16.4991 8.98979C16.4991 8.42429 16.4324 7.86704 16.3116 7.32629C16.2351 6.98354 15.9359 6.74054 15.5849 6.73979C14.3167 6.73754 13.6056 5.49104 14.2259 4.39604C14.3984 4.09154 14.3444 3.71804 14.0849 3.48254C13.2674 2.74004 12.2706 2.15954 11.2259 1.84154C10.9049 1.74404 10.5636 1.86404 10.3821 2.14604C9.65764 3.27179 8.30465 3.29129 7.5929 2.17004C7.41065 1.88204 7.04989 1.73879 6.72589 1.84154ZM11.2844 3.43455C11.7966 3.64905 12.2009 3.8733 12.6651 4.22505C12.1206 5.9478 13.0439 7.73729 14.9564 8.17304C15.0036 8.48279 14.9991 8.67029 14.9991 8.98979C14.9991 9.37154 15.0044 9.50579 14.9609 9.78179C13.0566 10.1763 12.1146 11.9155 12.6449 13.7538C12.1889 14.0845 11.8626 14.314 11.2904 14.5353C9.94639 13.1673 8.0804 13.1073 6.7079 14.5443C6.1724 14.3088 5.76066 14.0995 5.34441 13.7478C5.86041 11.881 4.98815 10.2693 3.05165 9.7803C2.9654 9.4383 2.9999 8.4723 3.0494 8.17905C5.0519 7.69905 5.8409 5.92679 5.34365 4.21979C5.78315 3.88904 6.1784 3.6483 6.69215 3.4398C7.9859 4.75605 9.92839 4.8873 11.2844 3.43455ZM8.99915 5.98979C7.3424 5.98979 5.99915 7.33304 5.99915 8.98979C5.99915 10.6473 7.3424 11.9898 8.99915 11.9898C10.6559 11.9898 11.9991 10.6473 11.9991 8.98979C11.9991 7.33304 10.6559 5.98979 8.99915 5.98979ZM8.99915 7.48979C9.8279 7.48979 10.4991 8.16179 10.4991 8.98979C10.4991 9.81855 9.8279 10.4898 8.99915 10.4898C8.1704 10.4898 7.49915 9.81855 7.49915 8.98979C7.49915 8.16179 8.1704 7.48979 8.99915 7.48979Z" }) }) }), mt = (r3) => jsx("svg", { viewBox: "0 0 20 20", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...r3, children: jsx("g", { id: "Bars", children: jsx("path", { id: "Union", fillRule: "evenodd", clipRule: "evenodd", d: "M12.5 15.5C12.5 15.7761 12.7239 16 13 16H14C14.2761 16 14.5 15.7761 14.5 15.5V14H16C16.2761 14 16.5 13.7761 16.5 13.5V12.5C16.5 12.2239 16.2761 12 16 12H14.5V2.5C14.5 2.22386 14.2761 2 14 2H13C12.7239 2 12.5 2.22386 12.5 2.5V4H11C10.7239 4 10.5 4.22386 10.5 4.5V5.5C10.5 5.77614 10.7239 6 11 6H12.5V15.5ZM5.5 17.5C5.5 17.7761 5.72386 18 6 18H7C7.27614 18 7.5 17.7761 7.5 17.5V10H9C9.27614 10 9.5 9.77614 9.5 9.5V8.5C9.5 8.22386 9.27614 8 9 8H7.5V4.5C7.5 4.22386 7.27614 4 7 4H6C5.72386 4 5.5 4.22386 5.5 4.5V14H4C3.72386 14 3.5 14.2239 3.5 14.5V15.5C3.5 15.7761 3.72386 16 4 16H5.5V17.5Z" }) }) }), gt = (r3) => jsx("svg", { viewBox: "0 0 20 20", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...r3, children: jsx("g", { id: "Candles", children: jsx("path", { id: "Union", fillRule: "evenodd", clipRule: "evenodd", d: "M7.25 2.5V4H8.5C8.77614 4 9 4.22386 9 4.5V15.5C9 15.7761 8.77614 16 8.5 16H7.25V17.5C7.25 17.7761 7.02614 18 6.75 18H6.25C5.97386 18 5.75 17.7761 5.75 17.5V16H4.5C4.22386 16 4 15.7761 4 15.5V4.5C4 4.22386 4.22386 4 4.5 4H5.75V2.5C5.75 2.22386 5.97386 2 6.25 2H6.75C7.02614 2 7.25 2.22386 7.25 2.5ZM5.5 5.5V14.5H7.5V5.5H5.5ZM14.25 4.5V7H15.5C15.7761 7 16 7.22386 16 7.5V15.5C16 15.7761 15.7761 16 15.5 16H14.25V17.5C14.25 17.7761 14.0261 18 13.75 18H13.25C12.9739 18 12.75 17.7761 12.75 17.5V16H11.5C11.2239 16 11 15.7761 11 15.5V7.5C11 7.22386 11.2239 7 11.5 7H12.75V4.5C12.75 4.22386 12.9739 4 13.25 4H13.75C14.0261 4 14.25 4.22386 14.25 4.5ZM12.5 8.5V14.5H14.5V8.5H12.5Z" }) }) }), ft = (r3) => jsx("svg", { viewBox: "0 0 20 20", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...r3, children: jsxs("g", { id: "Hollow Candles", children: [jsx("path", { id: "Subtract", fillRule: "evenodd", clipRule: "evenodd", d: "M5.5 14.5V5.5H7.5V14.5H5.5Z", fill: "white", fillOpacity: "0.12" }), jsx("path", { id: "Union", fillRule: "evenodd", clipRule: "evenodd", d: "M7.25 2.5V4H8.5C8.77614 4 9 4.22386 9 4.5V15.5C9 15.7761 8.77614 16 8.5 16H7.25V17.5C7.25 17.7761 7.02614 18 6.75 18H6.25C5.97386 18 5.75 17.7761 5.75 17.5V16H4.5C4.22386 16 4 15.7761 4 15.5V4.5C4 4.22386 4.22386 4 4.5 4H5.75V2.5C5.75 2.22386 5.97386 2 6.25 2H6.75C7.02614 2 7.25 2.22386 7.25 2.5ZM5.5 5.5V14.5H7.5V5.5H5.5ZM14.25 4.5V7H15.5C15.7761 7 16 7.22386 16 7.5V15.5C16 15.7761 15.7761 16 15.5 16H14.25V17.5C14.25 17.7761 14.0261 18 13.75 18H13.25C12.9739 18 12.75 17.7761 12.75 17.5V16H11.5C11.2239 16 11 15.7761 11 15.5V7.5C11 7.22386 11.2239 7 11.5 7H12.75V4.5C12.75 4.22386 12.9739 4 13.25 4H13.75C14.0261 4 14.25 4.22386 14.25 4.5ZM12.5 8.5V14.5H14.5V8.5H12.5Z" })] }) }), ht = (r3) => jsx("svg", { viewBox: "0 0 20 20", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...r3, children: jsx("g", { id: "Line", children: jsx("path", { id: "Vector 16 (Stroke)", fillRule: "evenodd", clipRule: "evenodd", d: "M18.3 2.72288C18.542 2.85596 18.6303 3.15999 18.4972 3.40195L13.495 12.4968C13.0776 13.2557 12.1061 13.5044 11.3754 13.0394L7.19878 10.3816L2.97738 17.558C2.83737 17.796 2.53092 17.8754 2.2929 17.7354L1.43097 17.2284C1.19295 17.0884 1.1135 16.7819 1.25351 16.5439L5.73746 8.92122C6.16792 8.18943 7.1194 7.96045 7.83567 8.41626L11.9995 11.0659L16.7448 2.43811C16.8778 2.19615 17.1819 2.10788 17.4238 2.24096L18.3 2.72288Z" }) }) }), bt$1 = (r3) => jsx("svg", { viewBox: "0 0 20 20", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...r3, children: jsxs("g", { id: "Area", children: [jsx("path", { id: "Vector 16 (Stroke)", fillRule: "evenodd", clipRule: "evenodd", d: "M18.3 2.72288C18.542 2.85596 18.6303 3.15999 18.4972 3.40195L13.495 12.4968C13.0776 13.2557 12.1061 13.5044 11.3754 13.0394L7.19878 10.3816L2.97738 17.558C2.83737 17.796 2.53092 17.8754 2.2929 17.7354L1.43097 17.2284C1.19295 17.0884 1.1135 16.7819 1.25351 16.5439L5.73746 8.92122C6.16792 8.18943 7.1194 7.96045 7.83567 8.41626L11.9995 11.0659L16.7448 2.43811C16.8778 2.19615 17.1819 2.10788 17.4238 2.24096L18.3 2.72288Z" }), jsx("path", { id: "Subtract", fillRule: "evenodd", clipRule: "evenodd", d: "M2.7608 17.7562C2.84602 17.899 3.00106 18 3.19016 18H16.362C17.4665 18 18.362 17.1046 18.362 16V3.94663C18.362 3.86618 18.3453 3.79397 18.3162 3.73108L13.495 12.4968C13.0776 13.2557 12.1061 13.5044 11.3754 13.0394L7.19881 10.3816L2.9774 17.558C2.92465 17.6477 2.84826 17.7148 2.7608 17.7562Z", fill: "white", fillOpacity: "0.12" })] }) }), yt = (r3) => jsx("svg", { viewBox: "0 0 20 20", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...r3, children: jsx("g", { id: "Baseline", children: jsx("path", { id: "Union", fillRule: "evenodd", clipRule: "evenodd", d: "M6.05938 2.93544C6.55642 1.71198 8.27766 1.68139 8.81785 2.88642L11.4361 8.72723H9.24438L7.4717 4.77279L5.86521 8.72723H3.70647L6.05938 2.93544ZM13.9282 14.2865L13.0051 12.2272H10.8133L12.5586 16.1204C13.088 17.3014 14.7641 17.3026 15.2952 16.1224L17.048 12.2272H14.8549L13.9282 14.2865ZM2.28459 12.2272H4.44333L1.85293 18.6036L0 17.8509L2.28459 12.2272ZM16.4299 8.72723H18.623L19.3384 7.13759L17.5145 6.31686L16.4299 8.72723ZM1.42645 10.2272C1.42645 9.95109 1.65031 9.72723 1.92645 9.72723H2.92645C3.20259 9.72723 3.42645 9.95109 3.42645 10.2272V10.7272C3.42645 11.0034 3.20259 11.2272 2.92645 11.2272H1.92645C1.65031 11.2272 1.42645 11.0034 1.42645 10.7272V10.2272ZM4.42645 10.2272C4.42645 9.95109 4.65031 9.72723 4.92645 9.72723H5.92645C6.20259 9.72723 6.42645 9.95109 6.42645 10.2272V10.7272C6.42645 11.0034 6.20259 11.2272 5.92645 11.2272H4.92645C4.65031 11.2272 4.42645 11.0034 4.42645 10.7272V10.2272ZM7.92645 9.72723C7.65031 9.72723 7.42645 9.95109 7.42645 10.2272V10.7272C7.42645 11.0034 7.65031 11.2272 7.92645 11.2272H8.92645C9.20259 11.2272 9.42645 11.0034 9.42645 10.7272V10.2272C9.42645 9.95109 9.20259 9.72723 8.92645 9.72723H7.92645ZM10.4265 10.2272C10.4265 9.95109 10.6503 9.72723 10.9265 9.72723H11.9265C12.2026 9.72723 12.4265 9.95109 12.4265 10.2272V10.7272C12.4265 11.0034 12.2026 11.2272 11.9265 11.2272H10.9265C10.6503 11.2272 10.4265 11.0034 10.4265 10.7272V10.2272ZM13.9265 9.72723C13.6503 9.72723 13.4265 9.95109 13.4265 10.2272V10.7272C13.4265 11.0034 13.6503 11.2272 13.9265 11.2272H14.9265C15.2026 11.2272 15.4265 11.0034 15.4265 10.7272V10.2272C15.4265 9.95109 15.2026 9.72723 14.9265 9.72723H13.9265ZM16.4265 10.2272C16.4265 9.95109 16.6503 9.72723 16.9265 9.72723H17.9265C18.2026 9.72723 18.4265 9.95109 18.4265 10.2272V10.7272C18.4265 11.0034 18.2026 11.2272 17.9265 11.2272H16.9265C16.6503 11.2272 16.4265 11.0034 16.4265 10.7272V10.2272Z" }) }) }), Ct = (r3) => jsx("svg", { viewBox: "0 0 12 12", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...r3, children: jsx("g", { id: "Unselected", children: jsx("path", { id: "Vector", d: "M6.00684 0.999023C3.24544 0.999023 1.00684 3.23752 1.00684 5.99902C1.00684 8.76051 3.24544 10.999 6.00684 10.999C8.76834 10.999 11.0068 8.76051 11.0068 5.99902C11.0068 3.23752 8.76834 0.999023 6.00684 0.999023ZM6.00684 1.99902C8.21584 1.99902 10.0068 3.79002 10.0068 5.99902C10.0068 8.20801 8.21584 9.99901 6.00684 9.99901C3.79769 9.99901 2.00684 8.20801 2.00684 5.99902C2.00684 3.79002 3.79769 1.99902 6.00684 1.99902Z", fill: "white", fillOpacity: "0.2" }) }) }), _t = (r3) => jsx("svg", { viewBox: "0 0 12 12", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...r3, children: jsx("g", { id: "Selected-Multiple Choices-fill", children: jsx("path", { id: "Subtract", fillRule: "evenodd", clipRule: "evenodd", d: "M1.00684 5.99902C1.00684 3.23752 3.24544 0.999023 6.00684 0.999023C8.76834 0.999023 11.0068 3.23752 11.0068 5.99902C11.0068 8.76051 8.76834 10.999 6.00684 10.999C3.24544 10.999 1.00684 8.76051 1.00684 5.99902ZM8.49243 3.65563C8.60602 3.54726 8.76156 3.49957 8.91068 3.49957C9.05981 3.49957 9.21534 3.54726 9.32893 3.65563C9.5567 3.87231 9.5567 4.23649 9.32893 4.45317L5.25362 8.33706C5.02644 8.55374 4.6443 8.55374 4.41712 8.33706L2.67014 6.67253C2.44296 6.45585 2.44296 6.09161 2.67014 5.87499C2.89791 5.65831 3.28004 5.65831 3.50722 5.87499L4.83537 7.1407L8.49243 3.65563Z", fill: "#608CFF" }) }) });
var St2 = () => {
  let { t: r3 } = ne$6();
  return { mobileTimeIntervalMoreMap: useMemo(() => [[{ value: "3", label: r3("tradingView.timeInterval.3m") }, { value: "5", label: r3("tradingView.timeInterval.5m") }, { value: "30", label: r3("tradingView.timeInterval.30m") }, { value: "120", label: r3("tradingView.timeInterval.2h") }], [{ value: "360", label: r3("tradingView.timeInterval.6h") }, { value: "720", label: r3("tradingView.timeInterval.12h") }, { value: "3d", label: r3("tradingView.timeInterval.3d") }, { value: "1M", label: r3("tradingView.timeInterval.1M") }]], [r3]) };
};
function ke(r3) {
  return useMediaQuery(MEDIA_TABLET) ? jsx(Qr, { ...r3 }) : jsx(Gr, { ...r3 });
}
function Gr(r3) {
  let { t: e2 } = ne$6(), t = useMemo(() => [{ value: "1", label: e2("tradingView.timeInterval.1m") }, { value: "3", label: e2("tradingView.timeInterval.3m") }, { value: "5", label: e2("tradingView.timeInterval.5m") }, { value: "15", label: e2("tradingView.timeInterval.15m") }, { value: "30", label: e2("tradingView.timeInterval.30m") }, { value: "60", label: e2("tradingView.timeInterval.1h") }, { value: "240", label: e2("tradingView.timeInterval.4h") }, { value: "720", label: e2("tradingView.timeInterval.12h") }, { value: "1D", label: e2("tradingView.timeInterval.1d") }, { value: "1W", label: e2("tradingView.timeInterval.1w") }, { value: "1M", label: e2("tradingView.timeInterval.1M") }], [e2]);
  return jsx("div", { className: cnBase("oui-text-2xs oui-text-base-contrast-36 oui-flex oui-gap-[2px] oui-items-center oui-mr-3 oui-font-semibold", "oui-overflow-hidden"), children: t.map((o2) => jsx("div", { className: cnBase("oui-cursor-pointer oui-px-2", "hover:oui-text-base-contrast-80", "oui-break-normal oui-whitespace-nowrap", r3.interval === o2.value && "oui-text-base-contrast-80 oui-bg-white/[.06] oui-rounded"), id: o2.value, onClick: () => r3.changeInterval(o2.value), children: o2.label }, o2.value)) });
}
function Qr(r3) {
  let { t: e2 } = ne$6(), t = useMemo(() => [{ value: "1", label: e2("tradingView.timeInterval.1m") }, { value: "15", label: e2("tradingView.timeInterval.15m") }, { value: "60", label: e2("tradingView.timeInterval.1h") }, { value: "240", label: e2("tradingView.timeInterval.4h") }, { value: "1D", label: e2("tradingView.timeInterval.1d") }, { value: "1W", label: e2("tradingView.timeInterval.1w") }], [e2]), { mobileTimeIntervalMoreMap: o2 } = St2(), i = useMemo(() => {
    for (let s2 of o2) for (let n4 of s2) if (n4.value === r3.interval) return n4.label;
    return null;
  }, [r3.interval, o2]);
  return jsxs(z$3, { justify: "start", itemAlign: "center", gap: 3, className: cnBase("oui-text-2xs oui-text-base-contrast-36", "oui-overflow-hidden"), children: [jsx("div", { className: " oui-flex oui-gap-1 oui-items-center oui-mr-3 oui-font-semibold", children: t.map((s2) => jsx("div", { className: cnBase("oui-px-2", "oui-break-normal oui-whitespace-nowrap", r3.interval === s2.value && "oui-text-base-contrast-80 oui-bg-white/[.06] oui-rounded"), onClick: () => r3.changeInterval(s2.value), children: s2.label }, s2.value)) }), jsx($r$1, { ...r3, children: i ? jsx("div", { className: "oui-text-base-contrast-80", children: i }) : jsx(Q$1, { className: "oui-break-normal oui-whitespace-nowrap", children: e2("tradingView.timeInterval.more") }) })] });
}
function $r$1(r3) {
  let [e2, t] = ze__default__default.useState(false), { mobileTimeIntervalMoreMap: o2 } = St2();
  return jsxs(la$1, { open: e2, onOpenChange: t, children: [jsx(ua$2, { asChild: true, children: jsxs("div", { className: "oui-flex oui-justify-start oui-items-center oui-gap-0.5", children: [r3.children, jsx($, { className: cnBase("oui-w-3 oui-h-3", e2 && "oui-text-base-contrast-80 oui-rotate-180") })] }) }), jsx(ca$1, { children: jsx(xr$3, { onCloseAutoFocus: (i) => i.preventDefault(), onClick: (i) => i.stopPropagation(), align: "start", alignOffset: 0, sideOffset: 0, className: cnBase("oui-markets-dropdown-menu-content oui-bg-base-9 oui-w-screen oui-flex oui-flex-col oui-gap-2 oui-p-3"), children: o2.map((i, s2) => jsx("div", { className: "oui-flex oui-gap-2", children: i.map((n4) => jsx("div", { className: cnBase("oui-w-full  oui-text-2xs oui-flex oui-items-center oui-justify-center oui-h-6  oui-rounded", n4.value === r3.interval ? "oui-text-base-contrast oui-bg-primary-darken" : "oui-text-base-contrast-36 oui-bg-base-5"), onClick: () => {
    r3.changeInterval(n4.value);
  }, children: jsx("div", { children: n4.label }) }, n4.value)) }, s2)) }) })] });
}
function Pt({ displayControlState: r3, changeDisplayControlState: e2 }) {
  let [t, o2] = useState(false), { t: i } = ne$6(), s2 = useMemo(() => [{ label: i("common.position"), id: "position" }, { label: i("tradingView.displayControl.buySell"), id: "buySell" }, { label: i("tradingView.displayControl.limitOrders"), id: "limitOrders" }, { label: i("tradingView.displayControl.stopOrders"), id: "stopOrders" }, { label: i("common.tpsl"), id: "tpsl" }, { label: i("tpsl.positionTpsl"), id: "positionTpsl" }], [i]);
  return jsx(Fragment$1, { children: jsxs(la$1, { open: t, onOpenChange: o2, children: [jsx(ua$2, { asChild: true, children: jsxs(z$3, { justify: "start", itemAlign: "center", className: "oui-gap-[2px] oui-cursor-pointer oui-text-base-contrast-36  hover:oui-text-base-contrast-80", children: [jsx(Re$1, { className: cnBase("oui-w-[18px] oui-h-[18px] ", t && "oui-text-base-contrast-80") }), jsx($, { className: cnBase("oui-w-3 oui-h-3", t && "oui-text-base-contrast-80 oui-rotate-180") })] }) }), jsx(ca$1, { children: jsx(xr$3, { onCloseAutoFocus: (n4) => n4.preventDefault(), onClick: (n4) => n4.stopPropagation(), align: "start", className: "oui-bg-base-8", children: jsx(z$3, { direction: "column", gap: 4, px: 5, py: 5, width: 240, justify: "start", itemAlign: "start", children: s2.map((n4) => jsxs(z$3, { justify: "between", itemAlign: "center", className: "oui-w-full", children: [jsx(Q$1, { className: cnBase("oui-text-sm oui-text-base-contrast-80", !r3[n4.id] && "oui-text-base-contrast-36"), children: n4.label }), jsx(di$2, { className: "oui-h-4 oui-w-8", checked: r3[n4.id], onCheckedChange: (a2) => {
    e2({ ...r3, [n4.id]: a2 });
  } })] }, n4.id)) }) }) })] }) });
}
function Et(r3) {
  let [e2, t] = useState(false), { t: o2 } = ne$6(), i = useMemo(() => [[{ label: o2("common.position"), id: "position" }, { label: o2("tradingView.displayControl.limitOrders"), id: "limitOrders" }], [{ label: o2("tradingView.displayControl.stopOrders"), id: "stopOrders" }, { label: o2("common.tpsl"), id: "tpsl" }], [{ label: o2("tpsl.positionTpsl"), id: "positionTpsl" }, { label: o2("tradingView.displayControl.buySell"), id: "buySell" }]], [o2]);
  return jsxs(la$1, { open: e2, onOpenChange: t, children: [jsx(ua$2, { asChild: true, children: jsxs("div", { className: cnBase("oui-flex oui-gap-0.5 oui-justify-center oui-text-base-contrast-36 oui-items-center", e2 && "oui-text-base-contrast-8"), children: [jsx(Re$1, { className: cnBase("oui-w-[18px] oui-h-[18px] ", e2 && "oui-text-base-contrast-80") }), jsx($, { className: cnBase("oui-w-3 oui-h-3", e2 && "oui-text-base-contrast-80 oui-rotate-180") })] }) }), jsx(ca$1, { children: jsx(xr$3, { onCloseAutoFocus: (s2) => s2.preventDefault(), onClick: (s2) => s2.stopPropagation(), align: "start", alignOffset: 0, sideOffset: 0, className: cnBase("oui-tradingview-display-control-dropdown-menu-content oui-bg-base-9 oui-w-screen oui-flex oui-flex-col oui-gap-2 oui-p-3"), children: i.map((s2, n4) => jsx("div", { className: "oui-flex oui-gap-2", children: s2.map((a2) => jsxs("div", { className: cnBase("oui-w-full oui-bg-base-5  oui-text-2xs oui-flex oui-items-center oui-justify-between oui-h-6  oui-rounded oui-px-2", r3.displayControlState[a2.id] ? "oui-text-base-contrast" : "oui-text-base-contrast-36 "), onClick: () => {
    r3.changeDisplayControlState({ ...r3.displayControlState, [a2.id]: !r3.displayControlState[a2.id] });
  }, children: [jsx("div", { children: a2.label }), r3.displayControlState[a2.id] ? jsx(_t, { className: "oui-h-3 oui-w-3" }) : jsx(Ct, { className: "oui-h-3 oui-w-3" })] }, a2.id)) }, n4)) }) })] });
}
var Mt$1 = ({ url: r3, children: e2 }) => jsx("span", { onClick: () => {
  window.open(r3);
}, className: "oui-text-primary-light oui-underline oui-cursor-pointer", children: e2 });
function Dt$1() {
  let { t: r3 } = ne$6();
  return jsx("div", { className: "oui-z-0 oui-text-base-contrast-80 oui-absolute oui-top-0 oui-left-0 oui-right-0 oui-bottom-0 oui-flex oui-flex-col oui-justify-start md:oui-justify-center oui-items-center oui-p-2 md:oui-p-10", children: jsxs("div", { children: [jsx("p", { className: "oui-mb-6 oui-text-xs", children: r3("tradingView.noScriptSrc") }), jsx("p", { className: "oui-mb-3 oui-text-2xs md:oui-text-xs oui-text-base-contrast-54 md:oui-text-base-contrast-80 md:oui-text-base oui-pl-0 md:oui-pl-2", children: jsx(Trans, { i18nKey: "tradingView.noScriptSrc.1", components: [jsx(Mt$1, { url: "https://www.tradingview.com/advanced-charts" })] }) }), jsx("p", { className: "oui-text-2xs md:oui-text-xs oui-text-base-contrast-54 md:oui-text-base-contrast-80 md:oui-text-base oui-pl-0 md:oui-pl-2", children: jsx(Trans, { i18nKey: "tradingView.noScriptSrc.2", components: [jsx(Mt$1, { url: "https://orderly.network/docs/sdks/react/components/trading#tradingviewconfig" })] }) })] }) });
}
function De(r3) {
  let [e2, t] = useState(false), { t: o2 } = ne$6(), i = useMemo(() => [{ icon: jsx(mt, { fill: "currentColor", className: "oui-w-5 oui-h-5" }), label: o2("tradingView.lineType.bars"), value: "0" }, { icon: jsx(gt, { fill: "currentColor", className: "oui-w-5 oui-h-5" }), label: o2("tradingView.lineType.candles"), value: "1" }, { icon: jsx(ft, { fill: "currentColor", className: "oui-w-5 oui-h-5" }), label: o2("tradingView.lineType.hollowCandles"), value: "9" }, { icon: jsx(ht, { fill: "currentColor", className: "oui-w-5 oui-h-5" }), label: o2("tradingView.lineType.line"), value: "2" }, { icon: jsx(bt$1, { fill: "currentColor", className: "oui-w-5 oui-h-5" }), label: o2("tradingView.lineType.area"), value: "3" }, { icon: jsx(yt, { fill: "currentColor", className: "oui-w-5 oui-h-5" }), label: o2("tradingView.lineType.baseline"), value: "10" }], [o2]), s2 = useMemo(() => {
    let n4 = i.find((a2) => a2.value === r3.lineType);
    return n4 ? n4.icon : i[1].icon;
  }, [r3.lineType]);
  return jsxs(la$1, { open: e2, onOpenChange: t, children: [jsx(ua$2, { asChild: true, children: jsx(W$2, { className: cnBase("oui-w-[18px] oui-h-[18px] oui-cursor-pointer oui-text-base-contrast-36 hover:oui-text-base-contrast-80", e2 && "oui-text-base-contrast-80"), children: s2 }) }), jsx(ca$1, { children: jsx(xr$3, { onCloseAutoFocus: (n4) => n4.preventDefault(), onClick: (n4) => n4.stopPropagation(), align: "start", sideOffset: 20, className: "oui-bg-base-8", children: jsx(z$3, { direction: "column", gap: 4, px: 5, py: 5, width: 240, justify: "start", itemAlign: "start", children: i.map((n4) => jsxs(z$3, { justify: "start", itemAlign: "center", gap: 2, className: cnBase("oui-text-base-contrast-36 oui-cursor-pointer oui-w-full hover:oui-text-base-contrast", r3.lineType === n4.value && "oui-text-base-contrast"), onClick: () => r3.changeLineType(n4.value), children: [n4.icon, jsx(Q$1, { className: "oui-text-sm", children: n4.label })] }, n4.value)) }) }) })] });
}
var Ut = ({ children: r3, onClick: e2 }) => jsx(W$2, { onClick: e2, className: "oui-cursor-pointer oui-w-[18px] oui-h-[18px] oui-text-base-contrast-36  hover:oui-text-base-contrast-80", children: r3 });
function Ae(r3) {
  let { chartRef: e2, interval: t, changeDisplaySetting: o2, displayControlState: i, tradingViewScriptSrc: s2, changeInterval: n4, lineType: a2, changeLineType: c, openChartSetting: l2, openChartIndicators: u2 } = r3, m2 = useMediaQuery(MEDIA_TABLET);
  return jsx("div", { className: "oui-h-full oui-w-full  oui-relative", children: s2 ? jsxs("div", { className: "oui-z-[1] oui-absolute oui-top-0 oui-bottom-0 oui-right-0 oui-left-0 oui-h-full oui-w-full oui-flex oui-flex-col", children: [jsx(we$1, { children: m2 ? jsxs(z$3, { gapX: 2, width: "100%", justify: "between", className: "oui-overflow-x-scroll oui-hide-scrollbar", children: [jsx(ke, { interval: t ?? "1", changeInterval: n4 }), jsx(Et, { displayControlState: i, changeDisplayControlState: o2 })] }) : jsxs(Fragment$1, { children: [jsx(ke, { interval: t ?? "1", changeInterval: n4 }), jsx(de$5, { direction: "vertical", className: "oui-h-4", mx: 2, intensity: 8 }), jsxs(z$3, { justify: "start", itemAlign: "center", gap: 2, children: [jsx(Pt, { displayControlState: i, changeDisplayControlState: o2 }), jsx(Ut, { onClick: u2, children: jsx(dt, {}) }), jsx(De, { lineType: a2, changeLineType: c }), jsx(Ut, { onClick: l2, children: jsx(pt, {}) })] })] }) }), jsx("div", { className: "oui-h-full oui-w-full", ref: e2 })] }) : jsx(Dt$1, {}) });
}
var mo = "#008676", go$1 = "#D92D6B", Be = "#131519", fo = "#00B49E", ho$1 = "#FF447C", bo = "#333948", yo$1 = "#FFFFFF", Co$1 = "#F4F7F9", _o = "regular 11px Manrope", Ft$1 = { upColor: mo, downColor: go$1, chartBG: Be, pnlUpColor: fo, pnlDownColor: ho$1, pnlZoreColor: bo, textColor: yo$1, qtyTextColor: Co$1, font: _o, volumeUpColor: "#0C3E3A", volumeDownColor: "#5A1E36", closeIcon: "rgba(255, 255, 255, 0.8)" }, Kt = (r3, e2) => {
  let t = { "paneProperties.background": r3.chartBG, "paneProperties.backgroundType": "solid", "mainSeriesProperties.candleStyle.upColor": r3.upColor, "mainSeriesProperties.candleStyle.downColor": r3.downColor, "mainSeriesProperties.candleStyle.borderColor": r3.upColor, "mainSeriesProperties.candleStyle.borderUpColor": r3.upColor, "mainSeriesProperties.candleStyle.borderDownColor": r3.downColor, "mainSeriesProperties.candleStyle.wickUpColor": r3.upColor, "mainSeriesProperties.candleStyle.wickDownColor": r3.downColor, "paneProperties.separatorColor": "#2B2833", "paneProperties.vertGridProperties.color": "#26232F", "paneProperties.horzGridProperties.color": "#26232F", "scalesProperties.fontSize": e2 ? 8 : 12, "scalesProperties.textColor": "#97969B", "paneProperties.legendProperties.showSeriesTitle": false }, o2 = { "volume.volume.color.0": r3.volumeDownColor, "volume.volume.color.1": r3.volumeUpColor };
  return { overrides: t, studiesOverrides: o2 };
}, re = "Orderly", x = (r3) => r3.includes(":") ? r3.split(":")[1] : r3, oe = (r3) => r3.startsWith(`${re}:`) ? r3 : `${re}:${r3}`;
var So$1 = 2, Io$1 = "--", Ne$1 = ["BRACKET", "STOP_BRACKET"], ne = ["POSITIONAL_TP_SL", "TP_SL"];
var He = (r3) => r3.root_algo_order_id !== r3.algo_order_id && (r3.algo_type === "TAKE_PROFIT" || r3.algo_type === "STOP_LOSS"), To = (r3) => !!r3 && Ne$1.includes(r3);
var Ue = (r3) => r3.type === "CLOSE_POSITION", Gt = (r3) => Ue(r3) && r3.is_activated, Qt$1 = (r3) => He(r3) && r3.is_activated, Fe = (r3) => r3.root_algo_order_algo_type === "TP_SL" || To(r3.root_algo_order_algo_type) && r3.is_activated, $t = (r3, e2) => {
  let t = r3.algo_type, o$1 = { TAKE_PROFIT: o.t("tpsl.takeProfit"), STOP_LOSS: o.t("tpsl.stopLoss") }[t];
  return o$1 || null;
}, Zt = (r3) => {
  let e2 = /* @__PURE__ */ new Map(), t = 1;
  return [...r3].reverse().filter(Fe).forEach((o2) => {
    o2.root_algo_order_id && !e2.has(o2.root_algo_order_id) && e2.set(o2.root_algo_order_id, t++);
  }), e2;
}, zt = (r3, e2) => {
  let t = Math.abs(r3.type === "CLOSE_POSITION" ? e2.balance : r3.quantity), o2 = r3.side === "SELL" ? 1 : -1, i = e2.open.toString();
  return { estPnl: new g$6(r3.trigger_price).minus(i ?? 0).times(t).times(o2).toString(), quantity: t, openPrice: i };
}, jt = (r3) => r3 !== void 0 && r3 !== "" ? new g$6(r3).todp(So$1, g$6.ROUND_FLOOR) : Io$1;
function Ke() {
  let [r3, { cancelOrder: e2, cancelAlgoOrder: t, cancelTPSLChildOrder: o2 }] = useOrderStream({ status: OrderStatus.INCOMPLETE });
  return useCallback((i) => {
    if (i.algo_order_id) {
      if (ne.includes(i.root_algo_order_algo_type)) {
        let s2 = r3 == null ? void 0 : r3.find((a2) => a2.algo_order_id === i.root_algo_order_id);
        return s2.child_orders.every((a2) => !!a2.trigger_price) ? o2(i.algo_order_id, i.root_algo_order_id) : t(s2.algo_order_id, i.symbol).then();
      }
      return t(i.algo_order_id, i.symbol).then();
    }
    return e2(i.order_id, i.symbol).then();
  }, [e2, r3]);
}
function qe$1(r3) {
  useEventEmitter();
  let [, { updateOrder: t, cancelAlgoOrder: o2, updateAlgoOrder: i, updateTPSLOrder: s2 }] = useOrderStream({ status: OrderStatus.INCOMPLETE });
  return useCallback((n4, a2) => {
    var _a3;
    if (n4.algo_order_id) if (ne.includes(n4.root_algo_order_algo_type)) {
      let l2 = [{ order_id: n4.algo_order_id, trigger_price: new g$6(a2.value).toString() }];
      return s2(n4.root_algo_order_id, l2).then((u2) => {
      }).catch((u2) => {
        r3 && r3.error(u2.message);
      });
    } else {
      if (Ne$1.includes(n4.algo_type)) return i(n4.algo_order_id, { order_price: new g$6(a2.value).toString() }).then((l2) => {
      }).catch((l2) => {
        r3 && r3.error(l2.message);
      });
      {
        let l2 = { quantity: n4.quantity, trigger_price: n4.trigger_price, symbol: n4.symbol, price: n4.price, algo_order_id: n4.algo_order_id };
        return n4.order_tag && (l2.order_tag = n4.order_tag), a2.type === "price" && (l2.price = new g$6(a2.value).toString()), a2.type === "trigger_price" && (l2.trigger_price = new g$6(a2.value).toString()), i(n4.algo_order_id, l2).then((u2) => {
        }).catch((u2) => {
          r3 && r3.error(u2.message);
        });
      }
    }
    let c = { order_price: (_a3 = n4.price) == null ? void 0 : _a3.toString(), order_quantity: n4.quantity.toString(), symbol: n4.symbol, order_type: n4.type, side: n4.side, visible_quantity: 0, reduce_only: n4.reduce_only };
    return new g$6(n4.visible_quantity ?? n4.visible ?? 0).eq(n4.quantity) && delete c.visible_quantity, Object.keys(n4).includes("reduce_only") || delete c.reduce_only, n4.order_tag && (c.order_tag = n4.order_tag), a2.type === "price" && (c.order_price = new g$6(a2.value).toString()), t(n4.order_id, c).then((l2) => {
    }).catch((l2) => {
      r3.error(l2.message);
    });
  }, [t]);
}
function We$1(r3) {
  let { onSubmit: e2 } = useOrderEntry({ symbol: r3, side: OrderSide.BUY, order_type: OrderType.MARKET }, { watchOrderbook: true });
  return { sendLimitOrder: () => {
  }, sendMarketOrder: (s2) => (s2.reduce_only = false, e2(s2).catch((n4) => {
    toast$2.error(n4);
  })) };
}
var No = (r3) => (e2) => r3(e2), Ho$1 = ({ closeConfirm: r3, colorConfig: e2, onToast: t, mode: o2, symbol: i }) => {
  let s2 = Ke(), n4 = qe$1(t), a2 = useSymbolsInfo(), c = useCallback((f2) => r3 && r3(f2), [r3]), { sendMarketOrder: l2, sendLimitOrder: u2 } = We$1(i), m2 = useCallback((f2) => {
    if (a2) return { baseMin: a2[f2]("base_min"), baseMax: a2[f2]("base_max"), baseTick: a2[f2]("base_tick"), quoteTick: a2[f2]("quote_tick") };
  }, [a2]), h2 = useRef({ cancelOrder: s2, closePosition: c, editOrder: n4, colorConfig: e2, sendLimitOrder: u2, getSymbolInfo: m2, sendMarketOrder: No(l2), mode: o2 });
  return useEffect(() => {
    h2.current.getSymbolInfo = m2;
  }, [a2]), useEffect(() => {
    h2.current.sendLimitOrder = u2, h2.current.sendMarketOrder = l2;
  }, [u2, l2]), useEffect(() => {
    h2.current.closePosition = c;
  }, [r3]), useEffect(() => {
    h2.current.cancelOrder = s2;
  }, [s2]), h2.current;
}, Jt = Ho$1;
var ae = class r {
  constructor(e2, t) {
    this.instance = e2, this.currentSymbol = "", this.broker = t, this.positionLines = {}, this.lastPositions = null;
  }
  renderPositions(e2) {
    var _a3;
    if (e2 === null || e2.length === 0) {
      this.removePositions();
      return;
    }
    ((_a3 = this.lastPositions) == null ? void 0 : _a3.length) !== e2.length && this.removePositions(), e2[0].symbol !== this.currentSymbol && (this.removePositions(), this.currentSymbol = e2[0].symbol), e2.forEach((t, o2) => this.drawPositionLine(t, o2)), this.lastPositions = e2;
  }
  getBasePositionLine() {
    return this.instance.activeChart().createPositionLine().setTooltip(o.t("positions.closePosition")).setQuantityBackgroundColor(this.broker.colorConfig.chartBG).setCloseButtonBackgroundColor(this.broker.colorConfig.chartBG).setBodyTextColor(this.broker.colorConfig.textColor).setQuantityTextColor(this.broker.colorConfig.qtyTextColor).setBodyFont(this.broker.colorConfig.font).setQuantityFont(this.broker.colorConfig.font).setLineLength(100).setLineStyle(1);
  }
  static getPositionQuantity(e2) {
    return d$2(new g$6(e2).todp(4, g$6.ROUND_DOWN).toString());
  }
  static getPositionPnL(e2, t) {
    let o$1 = o.t("tpsl.pnl"), i = new g$6(e2).toFixed(t, g$6.ROUND_DOWN);
    return new g$6(e2).eq(0) ? `${o$1} 0` : new g$6(e2).greaterThan(0) ? `${o$1} +${d$2(i)}` : `${o$1} ${d$2(i)}`;
  }
  removePositions() {
    Object.keys(this.positionLines).forEach((e2) => {
      this.positionLines[Number(e2)].remove(), delete this.positionLines[Number(e2)];
    });
  }
  drawPositionLine(e2, t) {
    let o2 = this.broker.colorConfig, i = e2.unrealPnl >= 0, s2 = e2.balance >= 0, n4 = o2.pnlZoreColor, a2 = new g$6(e2.unrealPnl);
    a2.greaterThan(0) ? n4 = o2.upColor : a2.lessThan(0) && (n4 = o2.downColor);
    i ? o2.pnlUpColor : o2.pnlDownColor;
    let l2 = s2 ? o2.upColor : o2.downColor, u2 = new g$6(e2.open).toNumber();
    this.positionLines[t] = this.positionLines[t] ?? this.getBasePositionLine(), this.positionLines[t].setQuantity(r.getPositionQuantity(e2.balance)).setPrice(u2).setCloseButtonIconColor(o2.closeIcon).setCloseButtonBorderColor(l2).setBodyBackgroundColor(n4).setQuantityTextColor(l2).setBodyBorderColor(n4).setLineColor(l2).setQuantityBorderColor(l2).setText(r.getPositionPnL(e2.unrealPnl, e2.unrealPnlDecimal)), this.broker.mode !== 3 && this.positionLines[t].onClose(null, () => {
      this.broker.closePosition(e2);
    });
  }
};
var Z = (r3) => {
  if (r3 != null) return r3.algo_order_id || r3.order_id;
};
var le = class {
  constructor() {
    this.quantityTpslNoMap = /* @__PURE__ */ new Map(), this.tpslPnlMap = /* @__PURE__ */ new Map(), this.positions = null;
  }
  getQuantityTpslNoMap() {
    return this.quantityTpslNoMap;
  }
  getTpslPnlMap() {
    return this.tpslPnlMap;
  }
  getFormattedEstPnl(e2) {
    if (this.positions === null) return "";
    let t = this.positions[0];
    if (!t) return "";
    let { estPnl: o2 } = zt(e2, t);
    return jt(o2);
  }
  prepareTpslPnlMap(e2) {
    let t = [];
    return e2.forEach((o2) => {
      let i = Z(o2);
      if (i && Qt$1(o2)) {
        let s2 = this.tpslPnlMap.get(i), n4 = this.getFormattedEstPnl(o2);
        s2 !== n4 && (t.push(i), this.tpslPnlMap.set(i, n4));
      }
    }), t;
  }
  prepareQuantityTpslNoMap(e2) {
    this.quantityTpslNoMap = Zt(e2);
  }
  recalculatePnl(e2, t) {
    return this.positions = e2, this.prepareTpslPnlMap(t);
  }
  clear() {
    this.positions = null, this.quantityTpslNoMap.clear(), this.tpslPnlMap.clear();
  }
};
var w2 = class w3 {
  constructor(e2, t) {
    this.instance = e2, this.pendingOrderLineMap = /* @__PURE__ */ new Map(), this.pendingOrders = [], this.broker = t, this.tpslCalService = new le();
  }
  renderPendingOrders(e2) {
    e2 && (this.pendingOrders = e2), this.cleanOldPendingOrders(this.pendingOrders), this.tpslCalService.prepareTpslPnlMap(this.pendingOrders), this.tpslCalService.prepareQuantityTpslNoMap(this.pendingOrders), this.pendingOrders.forEach((t) => this.renderPendingOrder(t));
  }
  updatePositions(e2) {
    let t = this.tpslCalService.recalculatePnl(e2, this.pendingOrders);
    this.pendingOrders.filter((o2) => t.includes(Z(o2))).forEach((o2) => this.renderPendingOrder(o2));
  }
  renderPendingOrder(e2) {
    let t = w3.getOrderId(e2);
    if (!t) return;
    let o2 = this.drawOrderLine(t, e2);
    o2 && this.pendingOrderLineMap.set(t, o2);
  }
  cleanOldPendingOrders(e2) {
    let t = new Set(e2.map((o2) => w3.getOrderId(o2)));
    this.pendingOrderLineMap.forEach((o2, i) => !t.has(i) && this.removePendingOrder(i));
  }
  removePendingOrder(e2) {
    if (e2 === void 0) return;
    let t = this.pendingOrderLineMap.get(e2);
    t && (this.pendingOrderLineMap.delete(e2), t.remove());
  }
  getBaseOrderLine() {
    let e2 = this.broker.colorConfig;
    return this.instance.activeChart().createOrderLine().setCancelTooltip(o.t("orders.cancelOrder")).setQuantityTextColor(e2.qtyTextColor).setQuantityBackgroundColor(e2.chartBG).setBodyBackgroundColor(e2.chartBG).setCancelButtonBackgroundColor(e2.chartBG).setLineStyle(1).setBodyFont(e2.font).setQuantityFont(e2.font);
  }
  static getCombinationType(e2) {
    let { algo_type: t, type: o2 } = e2;
    if ((t === "STOP_LOSS" || t === "TAKE_PROFIT" || t === "STOP") && o2 === "LIMIT") return "STOP_LIMIT";
    if ((t === "STOP_LOSS" || t === "TAKE_PROFIT" || t === "STOP") && o2 === "MARKET") return "STOP_MARKET";
    if (t === "BRACKET") {
      if (o2 === "LIMIT") return "BRACKET_LIMIT";
      if (o2 === "MARKET") return "BRACKET_MARKET";
    }
    return "LIMIT";
  }
  static getText(e2) {
    let t = w3.getCombinationType(e2);
    return t === "STOP_LIMIT" || t === "STOP_MARKET" || t === "STOP_BRACKET_LIMIT" || t === "STOP_BRACKET_MARKET" ? e2.type === "LIMIT" ? `${o.t("orderEntry.orderType.stopLimit")} ${d$2(e2.price)}` : o.t("orderEntry.orderType.stopMarket") : o.t("orderEntry.orderType.limit");
  }
  static getOrderPrice(e2) {
    return e2.trigger_price || e2.price;
  }
  getTPSLTextWithTpsl(e2, t) {
    return Z(t), e2;
  }
  getTPSLText(e2) {
    let t = $t(e2, this.tpslCalService.getQuantityTpslNoMap());
    return t ? this.getTPSLTextWithTpsl(t, e2) : null;
  }
  getOrderQuantity(e2) {
    if (e2.algo_order_id) {
      if (Gt(e2) || Ue(e2)) return "100%";
      if (Fe(e2)) {
        let o2 = new g$6(e2.quantity).minus(e2.executed ?? 0).div(new g$6(e2.position_qty)).mul(100).todp(2).toNumber();
        return `${Math.min(Math.abs(o2), 100).toString()}%`;
      }
    }
    return d$2(new g$6(e2.quantity).toString());
  }
  drawOrderLine(e2, t) {
    let o2 = He(t) ? this.getTPSLText(t) : w3.getText(t);
    if (o2 === null) return null;
    let i = this.broker.colorConfig, s2 = this.pendingOrderLineMap.get(e2) ?? this.getBaseOrderLine(), n4 = t.side === "BUY" ? i.upColor : i.downColor;
    t.side === "BUY" ? i.pnlUpColor : i.pnlDownColor;
    let c = w3.getOrderPrice(t), l2 = 100, u2 = this.getOrderQuantity(t), m2 = i.textColor;
    return s2.setText(o2).setCancelButtonIconColor(i.closeIcon).setCancelButtonBorderColor(n4).setBodyTextColor(m2).setBodyBorderColor(n4).setQuantityBorderColor(n4).setQuantityTextColor(n4).setLineColor(n4).setLineLength(l2).setQuantity(u2 ?? "").setPrice(c), this.broker.mode !== 3 ? (s2.onCancel(null, () => this.broker.cancelOrder(t)), this.applyEditOnMove(s2, t)) : s2.setEditable(false).setCancellable(false), s2;
  }
  static getOrderEditKey(e2) {
    let t = this.getCombinationType(e2);
    if (["LIMIT", "BRACKET_LIMIT"].includes(t)) return "price";
    if (t === "STOP_LIMIT" || t === "STOP_MARKET" || e2.rootAlgoOrderAlgoType === "POSITIONAL_TP_SL" || e2.rootAlgoOrderAlgoType === "TP_SL" || e2.rootAlgoOrderAlgoType === "BRACKET" || e2.rootAlgoOrderAlgoType === "STOP_BRACKET") return "trigger_price";
  }
  applyEditOnMove(e2, t) {
    let o2 = w3.getOrderEditKey(t);
    e2.onMove(() => {
      this.broker.editOrder(t, { type: o2, value: `${e2.getPrice()}` }).then((i) => {
        i.success || this.renderPendingOrder(t);
      }).catch(() => this.renderPendingOrder(t));
    });
  }
  removeAll() {
    this.pendingOrderLineMap.forEach((e2) => e2.remove()), this.pendingOrderLineMap.clear(), this.pendingOrders = [], this.tpslCalService.clear();
  }
};
w2.getOrderId = (e2) => {
  if (e2 != null) return e2.algo_order_id || e2.order_id;
};
var ce = w2;
var ir = { 1: { startOf: "minute", period: 0 }, 3: { startOf: "hour", period: 3 * 60 * 1e3 }, 5: { startOf: "hour", period: 5 * 60 * 1e3 }, 15: { startOf: "hour", period: 15 * 60 * 1e3 }, 30: { startOf: "hour", period: 30 * 60 * 1e3 }, 60: { startOf: "hour", period: 0 }, 120: { startOf: "day", period: 2 * 60 * 60 * 1e3 }, 240: { startOf: "day", period: 4 * 60 * 60 * 1e3 }, 480: { startOf: "day", period: 8 * 60 * 60 * 1e3 }, 720: { startOf: "day", period: 12 * 60 * 60 * 1e3 }, D: { startOf: "day", period: 0 }, "1D": { startOf: "day", period: 0 }, "3D": { startOf: "year", period: 3 * 24 * 60 * 60 * 1e3 }, "5D": { startOf: "year", period: 5 * 24 * 60 * 60 * 1e3 }, "1W": { startOf: "week", period: 0 }, "1M": { startOf: "month", period: 0 } };
function or$1(r3, e2, t, o2) {
  let { startOf: i, period: s2 } = ir[t], n4 = new Date(r3.updated_time).getTime(), a2 = startOfSecond(n4).getTime();
  i === "minute" ? a2 = startOfMinute(n4).getTime() : i === "hour" ? a2 = startOfHour(n4).getTime() : i === "day" ? a2 = startOfDay(n4).getTime() : i === "month" ? a2 = startOfMonth(n4).getTime() : i === "year" ? a2 = startOfYear(n4).getTime() : i === "week" ? a2 = startOfWeek(n4).getTime() : i === "month" && (a2 = startOfMonth(n4).getTime());
  let c = s2 === 0 ? a2 : Math.floor((n4 - a2) / s2) * s2 + a2;
  e2[c] || (e2[c] = { BUY: [], SELL: [] }), e2[c][r3.side].length < 5 && (e2[c][r3.side].push(r3), o2.push(r3));
}
var nr = (r3, e2) => {
  let t = [], o2 = {};
  return ir[e2] ? (r3.forEach((i) => {
    if (i.child_orders) for (let s2 of i.child_orders) s2.is_activated && s2.algo_status === OrderStatus.FILLED && or$1(s2, o2, e2, t);
    else or$1(i, o2, e2, t);
  }), t) : [];
};
var ue = class r2 {
  constructor(e2, t) {
    this.interval = "1D";
    this.changeInterval = (e3) => {
      let t2 = () => {
        this.renderExecutions(this.filledOrders, this.basePriceDecimal), this.instance.activeChart().onDataLoaded().unsubscribe(null, t2);
      };
      this.interval = e3, this.instance.activeChart().onDataLoaded().subscribe(null, t2);
    };
    this.instance = e2, this.executions = [], this.filledOrders = [], this.basePriceDecimal = 0, this.broker = t, this.subscribeIntervalChange();
  }
  async subscribeIntervalChange() {
    this.interval = this.instance.symbolInterval().interval;
    let e2 = this.changeInterval;
    this.instance.activeChart().onIntervalChanged().subscribe(null, e2);
  }
  renderExecutions(e2, t) {
    this.filledOrders = e2, this.basePriceDecimal = t, this.interval && (this.removeAll(), nr(e2, this.interval).forEach((o2) => {
      this.executions.push(this.drawExecution(o2, t));
    }));
  }
  removeAll() {
    this.executions.forEach((e2) => e2.remove()), this.executions = [];
  }
  static getExecutionInfo(e2, t) {
    var _a3, _b2;
    let o$1 = e2.side, i = e2.average_executed_price || ((_b2 = (_a3 = e2.child_orders) == null ? void 0 : _a3.find((n4) => !!n4.average_executed_price)) == null ? void 0 : _b2.average_executed_price) || 0, s2 = new g$6(i).todp(t, g$6.ROUND_FLOOR).toString();
    return `${o$1 === "BUY" ? o.t("common.buy") : o.t("common.sell")} ${e2.total_executed_quantity} @${d$2(s2)}`;
  }
  drawExecution(e2, t) {
    var _a3, _b2;
    let o2 = e2.side, i = e2.average_executed_price || ((_b2 = (_a3 = e2.child_orders) == null ? void 0 : _a3.find((a2) => !!a2.average_executed_price)) == null ? void 0 : _b2.average_executed_price) || 0, s2 = new Date(e2.updated_time).getTime() / 1e3, n4 = this.broker.colorConfig;
    return this.instance.activeChart().createExecutionShape().setArrowHeight(9).setTooltip(r2.getExecutionInfo(e2, t)).setTime(s2).setPrice(i).setArrowColor(o2 === "BUY" ? n4.upColor : n4.downColor).setDirection(o2 === "BUY" ? "buy" : "sell");
  }
  unsubscribeIntervalChange() {
    let e2 = this.changeInterval;
    try {
      this.instance.activeChart().onIntervalChanged().unsubscribe(null, e2);
    } catch (t) {
      t instanceof Error && t.message;
    }
  }
  destroy() {
    this.removeAll(), this.unsubscribeIntervalChange();
  }
};
var de = class {
  constructor(e2, t, o2) {
    this.instance = e2, this.positionLineService = new ae(e2, o2), this.orderLineService = new ce(e2, o2), this.executionService = new ue(e2, o2);
  }
  async renderPositions(e2) {
    await this.chartReady(), await this.onDataLoaded(), this.positionLineService.renderPositions(e2), this.orderLineService.updatePositions(e2);
  }
  async renderPendingOrders(e2) {
    await this.chartReady(), this.orderLineService.renderPendingOrders(e2);
  }
  async renderFilledOrders(e2, t) {
    await this.chartReady(), await this.onDataLoaded(), this.executionService.renderExecutions(e2, t);
  }
  remove() {
    this.orderLineService.removeAll(), this.positionLineService.removePositions(), this.executionService.destroy();
  }
  onDataLoaded() {
    return this.instance.activeChart().symbolExt() ? Promise.resolve() : new Promise((e2) => this.instance.activeChart().onDataLoaded().subscribe(null, () => {
      e2();
    }, true));
  }
  chartReady() {
    return new Promise((e2) => this.instance.onChartReady(() => {
      try {
        this.instance.activeChart().dataReady(() => e2());
      } catch (t) {
        t.toString().includes("tradingViewApi");
      }
    }));
  }
};
function ze(r3, e2) {
  var _a3;
  let [t, o2] = useState(), i = useRef(), { state: s2 } = useAccount(), [n4] = useLocalStorage("unPnlPriceBasis", "markPrice"), [{ rows: a2 }, c] = usePositionStream(r3, { calcMode: n4 }), [l2] = useOrderStream({ status: OrderStatus.INCOMPLETE, symbol: r3 }), m2 = (_a3 = useSymbolsInfo()) == null ? void 0 : _a3[r3], h2 = m2("quote_dp"), [f2] = useOrderStream({ symbol: r3, status: OrderStatus.FILLED, size: 500 }), b2 = useRef((I2, _2, M2) => {
    i.current && i.current.remove(), i.current = new de(I2, _2, M2), o2(i.current);
  }), K2 = useRef(() => {
    var _a4;
    (_a4 = i.current) == null ? void 0 : _a4.remove(), i.current = void 0;
  });
  return useEffect(() => {
    if (s2.status < AccountStatusEnum.EnableTrading && s2.status !== AccountStatusEnum.EnableTradingWithoutConnected) {
      t == null ? void 0 : t.renderPositions([]);
      return;
    }
    if (!e2 || !e2.position) {
      t == null ? void 0 : t.renderPositions([]);
      return;
    }
    let I2 = (a2 ?? []).filter((_2) => _2.symbol === r3).map((_2) => ({ symbol: _2.symbol, open: _2.average_open_price, balance: _2.position_qty, closablePosition: 9999, unrealPnl: _2.unrealized_pnl ?? 0, interest: 0, unrealPnlDecimal: 2, basePriceDecimal: 4 }));
    t == null ? void 0 : t.renderPositions(I2);
  }, [t, a2, r3, e2, s2]), useEffect(() => {
    if (!e2 || !e2.buySell) {
      t == null ? void 0 : t.renderFilledOrders([], 6);
      return;
    }
    let I2 = f2 == null ? void 0 : f2.filter((_2) => _2.symbol === r3);
    t == null ? void 0 : t.renderFilledOrders(I2 ?? [], h2 ?? 6);
  }, [t, f2, r3, h2, e2]), useEffect(() => {
    let I2 = [], _2 = [], M2 = [], q2 = [], W2 = [];
    if (s2.status < AccountStatusEnum.EnableTrading && s2.status !== AccountStatusEnum.EnableTradingWithoutConnected) {
      t == null ? void 0 : t.renderPendingOrders([]);
      return;
    }
    let Y2 = (a2 ?? []).find((y2) => y2.symbol === r3);
    l2 == null ? void 0 : l2.forEach((y2) => {
      if (r3 === y2.symbol) {
        if (!y2.algo_order_id) M2.push(y2);
        else if (y2.algo_order_id) if (y2.algo_type === "POSITIONAL_TP_SL") for (let T2 of y2.child_orders) T2.root_algo_order_algo_type = y2.algo_type, T2.trigger_price && T2.status !== OrderStatus.FILLED && _2.push(T2);
        else if (y2.algo_type === "TP_SL") {
          if (Y2) for (let T2 of y2.child_orders) T2.root_algo_order_algo_type = y2.algo_type, T2.position_qty = Y2.position_qty, T2.trigger_price && T2.status !== OrderStatus.FILLED && I2.push(T2);
        } else y2.algo_type === "STOP_LOSS" || y2.algo_type === "TAKE_PROFIT" ? q2.push(y2) : y2.algo_type === "BRACKET" && W2.push(y2);
      }
    }), e2 && (e2.positionTpsl || (_2 = []), e2.tpsl || (I2 = []), e2.limitOrders || (M2 = [], W2 = []), e2.stopOrders || (q2 = [])), t == null ? void 0 : t.renderPendingOrders(I2.concat(_2).concat(M2).concat(q2).concat(W2));
  }, [t, l2, r3, e2, a2, s2.status]), [b2.current, K2.current];
}
function B(r3) {
  return r3 === void 0 ? "" : typeof r3 == "string" ? r3 : r3.message;
}
var ge = class {
  constructor(e2, t, o2) {
    this._datafeedUrl = e2, this._requester = t, this._limitedServerResponse = o2;
  }
  getBars(e2, t, o2) {
    let i = { symbol: e2.ticker || "", resolution: t, from: o2.from, to: o2.to };
    return o2.countBack !== void 0 && (i.countback = o2.countBack), e2.currency_code !== void 0 && (i.currencyCode = e2.currency_code), e2.unit_id !== void 0 && (i.unitId = e2.unit_id), new Promise(async (s2, n4) => {
      try {
        let a2 = await this._requester.sendRequest(this._datafeedUrl, "history", i), c = this._processHistoryResponse(a2);
        this._limitedServerResponse && await this._processTruncatedResponse(c, i), s2(c);
      } catch (a2) {
        if (a2 instanceof Error || typeof a2 == "string") {
          let c = B(a2);
          n4(c);
        }
      }
    });
  }
  async _processTruncatedResponse(e2, t) {
    let o2 = e2.bars.length;
    try {
      for (; this._limitedServerResponse && this._limitedServerResponse.maxResponseLength > 0 && this._limitedServerResponse.maxResponseLength === o2 && t.from < t.to; ) {
        t.countback && (t.countback = t.countback - o2), this._limitedServerResponse.expectedOrder === "earliestFirst" ? t.from = Math.round(e2.bars[e2.bars.length - 1].time / 1e3) : t.to = Math.round(e2.bars[0].time / 1e3);
        let i = await this._requester.sendRequest(this._datafeedUrl, "history", t), s2 = this._processHistoryResponse(i);
        o2 = s2.bars.length, this._limitedServerResponse.expectedOrder === "earliestFirst" ? (s2.bars[0].time === e2.bars[e2.bars.length - 1].time && s2.bars.shift(), e2.bars.push(...s2.bars)) : (s2.bars[s2.bars.length - 1].time === e2.bars[0].time && s2.bars.pop(), e2.bars.unshift(...s2.bars));
      }
    } catch (i) {
      if (i instanceof Error || typeof i == "string") {
        B(i);
      }
    }
  }
  _processHistoryResponse(e2) {
    if (e2.s !== "ok" && e2.s !== "no_data") throw new Error(e2.errmsg);
    let t = [], o2 = { noData: false };
    if (e2.s === "no_data") o2.noData = true, o2.nextTime = e2.nextTime;
    else {
      let i = e2.v !== void 0, s2 = e2.o !== void 0;
      for (let n4 = 0; n4 < e2.t.length; ++n4) {
        let a2 = { time: e2.t[n4] * 1e3, close: parseFloat(e2.c[n4]), open: parseFloat(e2.c[n4]), high: parseFloat(e2.c[n4]), low: parseFloat(e2.c[n4]) };
        s2 && (a2.open = parseFloat(e2.o[n4]), a2.high = parseFloat(e2.h[n4]), a2.low = parseFloat(e2.l[n4])), i && (a2.volume = parseFloat(e2.v[n4])), t.push(a2);
      }
    }
    return { bars: t, meta: o2 };
  }
};
var fe = class {
  constructor(e2) {
    e2 && (this._headers = e2);
  }
  sendRequest(e2, t, o2) {
    if (o2 !== void 0) {
      let s2 = Object.keys(o2);
      s2.length !== 0 && (t += "?"), t += s2.map((n4) => `${encodeURIComponent(n4)}=${encodeURIComponent(o2[n4].toString())}`).join("&");
    }
    "" + t;
    let i = { credentials: "same-origin" };
    return this._headers !== void 0 && (i.headers = this._headers), fetch(`${e2}/${t}`, i).then((s2) => s2.text()).then((s2) => JSON.parse(s2));
  }
};
function g(r3, e2, t, o2) {
  let i = r3[e2];
  return Array.isArray(i) && (!o2 || Array.isArray(i[0])) ? i[t] : i;
}
function he(r3, e2, t) {
  return r3 + (e2 !== void 0 ? "_%|#|%_" + e2 : "") + (t !== void 0 ? "_%|#|%_" + t : "");
}
var be = class {
  constructor(e2, t, o2) {
    this._exchangesList = ["Orderly"];
    this._symbolsInfo = {};
    this._symbolsList = [];
    this._datafeedUrl = e2, this._datafeedSupportedResolutions = t, this._requester = o2, this._readyPromise = this._init(), this._readyPromise.catch((i) => {
    });
  }
  resolveSymbol(e2, t, o2) {
    return this._readyPromise.then(() => {
      let i = this._symbolsInfo[he(e2, t, o2)];
      return i === void 0 ? Promise.reject("invalid symbol") : Promise.resolve(i);
    });
  }
  searchSymbols(e2, t, o2, i) {
    return this._readyPromise.then(() => {
      let s2 = [], n4 = e2.length === 0;
      e2 = e2.toUpperCase();
      for (let c of this._symbolsList) {
        let l2 = this._symbolsInfo[c];
        if (l2 === void 0 || o2.length > 0 && l2.type !== o2 || t && t.length > 0 && l2.exchange !== t) continue;
        let u2 = l2.name.toUpperCase().indexOf(e2), m2 = l2.description.toUpperCase().indexOf(e2);
        if ((n4 || u2 >= 0 || m2 >= 0) && !s2.some((f2) => f2.symbolInfo === l2)) {
          let f2 = u2 >= 0 ? u2 : 8e3 + m2;
          s2.push({ symbolInfo: l2, weight: f2 });
        }
      }
      let a2 = s2.sort((c, l2) => c.weight - l2.weight).slice(0, i).map((c) => {
        let l2 = c.symbolInfo;
        return { symbol: l2.name, full_name: `${l2.exchange}:${l2.name}`, description: l2.description, exchange: l2.exchange, params: [], type: l2.type, ticker: l2.name };
      });
      return Promise.resolve(a2);
    });
  }
  _init() {
    let e2 = [], t = {};
    for (let o2 of this._exchangesList) t[o2] || (t[o2] = true, e2.push(this._requestExchangeData(o2)));
    return Promise.all(e2).then(() => {
      this._symbolsList.sort();
    });
  }
  _requestExchangeData(e2) {
    return new Promise((t, o2) => {
      this._requester.sendRequest(this._datafeedUrl, "symbol_info", { group: e2 }).then((i) => {
        try {
          this._onExchangeDataReceived(e2, i);
        } catch (s2) {
          o2(s2 instanceof Error ? s2 : new Error(`SymbolsStorage: Unexpected exception ${s2}`));
          return;
        }
        t();
      }).catch((i) => {
        `${e2}${B(i)}`, t();
      });
    });
  }
  _onExchangeDataReceived(e2, t) {
    let o2 = 0;
    try {
      let i = t.symbol.length, s2 = t.ticker !== void 0;
      for (; o2 < i; ++o2) {
        let n4 = t.symbol[o2], a2 = g(t, "exchange-listed", o2), c = g(t, "exchange-traded", o2), l2 = c + ":" + n4, u2 = g(t, "currency-code", o2), m2 = g(t, "unit-id", o2), h2 = s2 ? g(t, "ticker", o2) : n4, f2 = { ticker: h2, name: n4, base_name: [a2 + ":" + n4], listed_exchange: a2, exchange: c, currency_code: u2, original_currency_code: g(t, "original-currency-code", o2), unit_id: m2, original_unit_id: g(t, "original-unit-id", o2), unit_conversion_types: g(t, "unit-conversion-types", o2, true), description: g(t, "description", o2), has_intraday: U(g(t, "has-intraday", o2), false), visible_plots_set: U(g(t, "visible-plots-set", o2), "ohlcv"), minmov: g(t, "minmovement", o2) || g(t, "minmov", o2) || 0, minmove2: g(t, "minmove2", o2) || g(t, "minmov2", o2), fractional: g(t, "fractional", o2), pricescale: g(t, "pricescale", o2), type: g(t, "type", o2), session: g(t, "session-regular", o2), session_holidays: g(t, "session-holidays", o2), corrections: g(t, "corrections", o2), timezone: g(t, "timezone", o2), supported_resolutions: U(g(t, "supported-resolutions", o2, true), this._datafeedSupportedResolutions), has_daily: U(g(t, "has-daily", o2), true), intraday_multipliers: U(g(t, "intraday-multipliers", o2, true), ["1", "5", "15", "30", "60"]), has_weekly_and_monthly: g(t, "has-weekly-and-monthly", o2), has_empty_bars: g(t, "has-empty-bars", o2), volume_precision: U(g(t, "volume-precision", o2), 0), format: "price" };
        this._symbolsInfo[h2] = f2, this._symbolsInfo[n4] = f2, this._symbolsInfo[l2] = f2, (u2 !== void 0 || m2 !== void 0) && (this._symbolsInfo[he(h2, u2, m2)] = f2, this._symbolsInfo[he(n4, u2, m2)] = f2, this._symbolsInfo[he(l2, u2, m2)] = f2), this._symbolsList.push(n4);
      }
    } catch (i) {
      throw new Error(`SymbolsStorage: API error when processing exchange ${e2} symbol #${o2} (${t.symbol[o2]}): ${Object(i).message}`);
    }
  }
};
function U(r3, e2) {
  return r3 !== void 0 ? r3 : e2;
}
var ye = class {
  constructor(e2) {
    this._configuration = ur$1();
    this._symbolsStorage = null;
    this._datafeedURL = e2, this._requester = new fe(), this._historyProvider = new ge(e2, this._requester), this._configurationReadyPromise = this._requestConfiguration().then((t) => {
      t === null && (t = ur$1()), this._setupWithConfiguration(t);
    });
  }
  getBars(e2, t, o2, i, s2) {
    this._historyProvider.getBars(e2, t, o2).then((n4) => {
      i(n4.bars, n4.meta);
    }).catch(s2);
  }
  onReady(e2) {
    this._configurationReadyPromise.then(() => {
      e2(this._configuration);
    });
  }
  searchSymbols(e2, t, o2, i) {
    if (this._symbolsStorage === null) throw new Error("Datafeed: inconsistent configuration (symbols storage)");
    this._symbolsStorage.searchSymbols(e2, t, o2, 30).then(i).catch(i.bind(null, []));
  }
  resolveSymbol(e2, t, o2, i) {
    let s2 = i && i.currencyCode, n4 = i && i.unitId;
    function c(l2) {
      t(l2);
    }
    if (this._symbolsStorage === null) throw new Error("Datafeed: inconsistent configuration (symbols storage)");
    this._symbolsStorage.resolveSymbol(e2, s2, n4).then(c).catch(o2);
  }
  getMarks() {
  }
  getTimescaleMarks() {
  }
  getServerTime() {
  }
  _requestConfiguration() {
    return this._send("config").catch((e2) => (`${B(e2)}`, null));
  }
  _send(e2, t) {
    return this._requester.sendRequest(this._datafeedURL, e2, t);
  }
  _setupWithConfiguration(e2) {
    if (this._configuration = e2, e2.exchanges === void 0 && (e2.exchanges = []), !e2.supports_search && !e2.supports_group_request) throw new Error("Unsupported datafeed configuration. Must either support search, or support group request");
    (e2.supports_group_request || !e2.supports_search) && (this._symbolsStorage = new be(this._datafeedURL, e2.supported_resolutions || [], this._requester)), `${JSON.stringify(e2)}`;
  }
};
function ur$1() {
  return { supports_search: false, supports_group_request: true, supported_resolutions: ["1", "3", "5", "15", "30", "60", "120", "240", "480", "720", "1D", "3D", "1W", "1M"], supports_marks: false, supports_timescale_marks: false };
}
var Ce2 = class {
  constructor() {
    this.subscribers = /* @__PURE__ */ new Map();
  }
  subscribe(e2, t) {
    return this.subscribers.has(e2) || this.subscribers.set(e2, []), this.subscribers.get(e2).push(t), () => {
      this.unsubscribe(e2, t);
    };
  }
  unsubscribe(e2, t) {
    if (this.subscribers.has(e2)) {
      let o2 = this.subscribers.get(e2);
      this.subscribers.set(e2, o2.filter((i) => i !== t)), this.subscribers.get(e2).length === 0 && this.subscribers.delete(e2);
    }
  }
  publish(e2, t) {
    this.subscribers.has(e2) && this.subscribers.get(e2).forEach((i) => {
      i(t);
    });
  }
};
var je$1 = (r3) => {
  let e2 = "1d";
  switch (r3) {
    case "1":
      e2 = "1m";
      break;
    case "3":
      e2 = "3m";
      break;
    case "5":
      e2 = "5m";
      break;
    case "15":
      e2 = "15m";
      break;
    case "30":
      e2 = "30m";
      break;
    case "60":
      e2 = "1h";
      break;
    case "120":
      e2 = "2h";
      break;
    case "240":
      e2 = "4h";
      break;
    case "480":
      e2 = "8h";
      break;
    case "720":
      e2 = "12h";
      break;
    case "D":
    case "1D":
      e2 = "1d";
      break;
    case "3D":
      e2 = "3d";
      break;
    case "1W":
      e2 = "1w";
      break;
    case "1M":
      e2 = "1M ";
      break;
  }
  return e2;
}, V = { interval: "TradingviewSDK.lastUsedTimeBasedResolution", lineType: "TradingviewSDK.lastUsedStyle", displayControlSetting: "TradingviewSDK.displaySetting" };
var Ye = (r3, e2) => `${r3}kline_${e2}`, ei = (r3) => ["trade"].map((t) => `${r3}@${t}`), E = class E2 {
  constructor(e2) {
    this.klineSubscribeIdMap = /* @__PURE__ */ new Map();
    this.klineOnTickCallback = /* @__PURE__ */ new Map();
    this.subscribeCachedTopics = /* @__PURE__ */ new Map();
    this.wsInstance = null;
    this.klineData = /* @__PURE__ */ new Map();
    return E2._created || (this.wsInstance = e2, E2._instance = this, E2._created = true), E2._instance;
  }
  subscribeKline(e2, t, o2, i) {
    var _a3;
    let s2 = je$1(o2);
    this.klineSubscribeIdMap.set(e2, { symbol: t, resolution: o2 });
    let n4 = Ye(t, s2);
    if (this.klineOnTickCallback.has(n4)) {
      let a2 = this.klineOnTickCallback.get(n4);
      a2[e2] = i;
    } else {
      this.klineOnTickCallback.set(n4, { [e2]: i });
      let a2 = (_a3 = this.wsInstance) == null ? void 0 : _a3.subscribe({ event: "subscribe", topic: `${t}@kline_${s2}`, id: `${t}@kline_${s2}`, ts: (/* @__PURE__ */ new Date()).getTime() }, { onMessage: (c) => {
        let { open: l2, close: u2, high: m2, low: h2, volume: f2, startTime: b2 } = c, K2 = Ye(c.symbol, c.type);
        this.updateKline(K2, { time: b2, close: u2, open: l2, high: m2, low: h2, volume: f2 });
      } });
      this.subscribeCachedTopics.set(`${t}@kline_${s2}`, a2);
    }
  }
  unsubscribeKline(e2) {
    if (!this.klineSubscribeIdMap.has(e2)) return;
    let { symbol: t, resolution: o2 } = this.klineSubscribeIdMap.get(e2), i = je$1(o2), s2 = Ye(t, i);
    if (this.klineOnTickCallback.has(s2)) {
      let n4 = this.klineOnTickCallback.get(s2);
      delete n4[e2], Object.keys(n4).length === 0 && (this.klineOnTickCallback.delete(s2), this.subscribeCachedTopics.get(`${t}@kline_${i}`)());
    }
    delete this.klineSubscribeIdMap[e2];
  }
  subscribeSymbol(e2) {
    ei(e2).forEach((o2) => {
      var _a3;
      if (!this.subscribeCachedTopics.has(o2)) {
        let i = (_a3 = this.wsInstance) == null ? void 0 : _a3.subscribe({ event: "subscribe", topic: o2, id: o2, ts: (/* @__PURE__ */ new Date()).getTime() }, { onMessage: (s2) => {
          this.updateKlineByLastPrice(s2.symbol, s2.price);
        } });
        this.subscribeCachedTopics.set(o2, i);
      }
    });
  }
  updateKlineByLastPrice(e2, t) {
    this.klineOnTickCallback.forEach((o2, i) => {
      if (i.startsWith(e2)) {
        let s2 = this.klineData.get(i);
        s2 && this.updateKline(i, { ...s2, close: t });
      }
    });
  }
  updateKline(e2, t) {
    let o2 = this.klineOnTickCallback.get(e2);
    o2 && t && (this.klineData.set(e2, t), Object.keys(o2).forEach((i) => {
      let s2 = o2[i];
      s2 && typeof s2 == "function" && s2(t);
    }));
  }
};
E._created = false, E._instance = null;
var F2 = E;
var ti = /* @__PURE__ */ (() => {
  let r3 = 0;
  return () => r3++;
})(), _e = class extends ye {
  constructor(t, o2) {
    let i = `${t}/tv`;
    super(i);
    this.bbosMap = /* @__PURE__ */ new Map();
    this.tickersMap = /* @__PURE__ */ new Map();
    this.eventBus = new Ce2();
    this._subscribeQuoteMap = /* @__PURE__ */ new Map(), this._prefixId = ti(), this._publicWs = new F2(o2), this.bbosMap = /* @__PURE__ */ new Map(), o2.on("tickers", (s2) => {
      for (let n4 of s2.data) n4.change = n4.close - n4.open, n4.perChange = n4.open ? +(100 * n4.change / n4.open).toFixed(2) : 0, this.tickersMap.set(n4.symbol, n4);
      this.eventBus.publish("tickerUpdate", { message: "ticker" });
    }), o2.subscribe({ event: "subscribe", topic: "bbos" }, { formatter: (s2) => s2, onMessage: (s2) => {
      for (let n4 of s2.data) this.bbosMap.set(n4.symbol, { ask: n4.ask, bid: n4.bid, askSize: n4.askSize, bidSize: n4.bidSize });
      this.eventBus.publish("tickerUpdate", { message: "bbos" });
    } });
  }
  remove() {
    Array.from(this._subscribeQuoteMap.values()).forEach((t) => t == null ? void 0 : t());
  }
  getSubscriptionId(t) {
    return `${this._prefixId}${t}`;
  }
  subscribeBars(t, o2, i, s2) {
    this._publicWs.subscribeKline(`${this._prefixId}${s2}`, t.ticker, o2, i);
  }
  unsubscribeBars(t) {
    this._publicWs.unsubscribeKline(`${this._prefixId}${t}`);
  }
  getQuotes(t, o2) {
    let i = this.getSubscriptionId("getQuotes");
    this.unsubscribeQuotes("getQuotes");
    let s2 = this.eventBus.subscribe("tickerUpdate", (n4) => {
      let a2 = /* @__PURE__ */ new Map();
      t.forEach((c) => {
        let l2 = this.bbosMap.get(x(c)), u2 = this.tickersMap.get(x(c));
        if (!l2 || !u2) return;
        let m2 = { ...u2, ask: l2.ask, bid: l2.bid };
        a2.set(x(c), m2);
      }), a2.size && o2(Array.from(a2.values()).map((c) => this._toUDFTicker(c)));
    });
    this._subscribeQuoteMap.set(i, s2);
  }
  subscribeQuotes(t, o2, i, s2) {
    let n4 = `${this._prefixId}${s2}`;
    if (t.length > 0) {
      this.unsubscribeQuotes(n4);
      let a2 = this.eventBus.subscribe("tickerUpdate", (c) => {
        let l2 = /* @__PURE__ */ new Map();
        t.forEach((u2) => {
          let m2 = this.bbosMap.get(x(u2)), h2 = this.tickersMap.get(x(u2));
          if (!m2 || !h2) return;
          let f2 = { ...h2, ask: m2.ask, bid: m2.bid };
          l2.set(x(u2), f2);
        }), l2.size && i(Array.from(l2.values()).map((u2) => this._toUDFTicker(u2)));
      });
      this._subscribeQuoteMap.set(n4, a2);
    }
  }
  unsubscribeQuotes(t) {
    let o2 = this.getSubscriptionId(t), i = this._subscribeQuoteMap.get(o2);
    i && (i(), this._subscribeQuoteMap.delete(o2));
  }
  _toUDFTicker(t) {
    return { n: oe(t.symbol), s: "ok", v: { ask: t.ask, bid: t.bid, ch: t.change, chp: t.perChange / 100, description: "", exchange: re, hight_price: t.high, low_price: t.low, lp: t.close, open_price: t.open, prev_close_price: 0, volume: t.volume } };
  }
};
var dr = (r3, e2) => new Promise((t) => {
  let o2 = r3.querySelector(e2);
  o2 && t(o2);
  let i = new MutationObserver(() => {
    let s2 = r3.querySelector(e2);
    s2 && (t(s2), i.disconnect());
  });
  i.observe(r3, { childList: true, subtree: true });
});
var ve2 = class {
  constructor({ iframeDocument: e2 }) {
    this.iframeDocument = e2;
  }
  defaultHack() {
    this.showFavoriteStarByDefault();
  }
  showFavoriteStarByDefault() {
    dr(this.iframeDocument, ".dropdown-2R6OKuTS").then(() => {
      this.iframeDocument.querySelectorAll(".toolbox-2IihgTnv.showOnHover-2IihgTnv").forEach((t) => {
        t.style.opacity = "1";
      });
    });
  }
};
var ri = (r3) => {
  let e2 = ["header_symbol_search", "volume_force_overlay", "trading_account_manager", "drawing_templates", "open_account_manager", "right_toolbar", "support_multicharts", "header_layouttoggle", "order_panel", "order_info", "trading_notifications", "display_market_status", "broker_button", "add_to_watchlist", "chart_crosshair_menu", "header_fullscreen_button", "header_widget"];
  return r3 === 3 && (e2 = [...e2, "left_toolbar", "timeframes_toolbar", "go_to_date", "timezone_menu", "create_volume_indicator_by_default", "buy_sell_buttons"]), r3 === 0 ? e2 = [...e2, "header_widget", "left_toolbar", "timeframes_toolbar", "buy_sell_buttons"] : r3 === 1 && (e2 = [...e2, "left_toolbar", "timeframes_toolbar", "buy_sell_buttons"]), e2;
};
function Je$1(r3, e2) {
  return { ...r3, disabled_features: ri(e2), enabled_features: ["hide_left_toolbar_by_default", "order_panel_close_button", "iframe_loading_compatibility_mode"], auto_save_delay: 0.1, broker_config: { configFlags: { supportStopLimitOrders: true, supportReversePosition: false } } };
}
var Xe2 = (r3) => `${r3}_adapter`, Se = { "trading.chart.proterty": JSON.stringify({ showSellBuyButtons: 0, noConfirmEnabled: 1, qweqrq: 0, showPricesWithZeroVolume: 1, showSpread: 1, orderExecutedSoundParams: '{"enabled":0,"name":"alert/alarm_clock"}' }), "hint.startFocusedZoom": "true" }, k = /* @__PURE__ */ new Map();
var oi = (r3, e2, t) => {
  let o2 = Xe2(r3);
  try {
    let i = e2, s2 = i ? JSON.parse(i) : void 0, n4 = t ? JSON.parse(t) : Se;
    return i && k.set(r3, i), t && k.set(o2, t), { savedData: s2, adapterSetting: n4 };
  } catch {
  }
  return { savedData: void 0, adapterSetting: Se };
}, pr = async (r3, e2) => {
  let t = Xe2(r3), o2 = localStorage.getItem(r3) || "", i = localStorage.getItem(t) || "";
  try {
    if (k.has(r3) && k.has(t)) return { savedData: JSON.parse(k.get(r3)), adapterSetting: JSON.parse(k.get(t)) };
  } catch {
  }
  return oi(r3, o2, i);
}, mr$1 = async (r3, e2, t) => {
  e2 && (localStorage.setItem(r3, e2), k.set(r3, e2));
}, gr = async (r3, e2, t) => {
  let o2 = Xe2(r3);
  e2 && (localStorage.setItem(o2, e2), k.set(o2, e2));
};
var fr = (r3, e2) => {
  let t = null, o2 = (...i) => {
    t && window.clearTimeout(t), t = setTimeout(() => {
      r3(...i);
    }, e2);
  };
  return o2.cancel = () => {
    t && window.clearTimeout(t), t = null;
  }, o2;
}, ii = "chartProp_default", hr = 300, Ie$1 = class Ie {
  constructor(e2) {
    this._instance = null;
    this._onClick = null;
    this._datafeed = null;
    this._chartKey = ii;
    this._adapterSetting = Se;
    this._savedData = null;
    this._isLoggedIn = false;
    this.debounceSaveChart = fr(() => {
      var _a3;
      try {
        (_a3 = this._instance) == null ? void 0 : _a3.save((e3) => {
          Object.is(this._savedData, e3) || (this._savedData = e3, mr$1(this._chartKey, JSON.stringify(e3), this._isLoggedIn));
        });
      } catch {
      }
    }, hr * 2);
    this.debounceSaveChartAdapterSetting = fr(() => {
      gr(this._chartKey, JSON.stringify(this._adapterSetting), this._isLoggedIn);
    }, hr);
    this._create(e2);
  }
  remove() {
    var _a3, _b2, _c2;
    this.unsubscribeClick(), (_a3 = this._datafeed) == null ? void 0 : _a3.remove(), (_b2 = this._broker) == null ? void 0 : _b2.remove(), (_c2 = this._instance) == null ? void 0 : _c2.remove(), this.debounceSaveChart.cancel(), this.debounceSaveChartAdapterSetting.cancel();
  }
  updateOverrides(e2) {
    this.instance && this.instance.applyOverrides(e2);
  }
  setSymbol(e2, t, o2) {
    var _a3;
    try {
      (_a3 = this._instance) == null ? void 0 : _a3.onChartReady(() => {
        var _a4, _b2, _c2;
        let i = t ?? ((_b2 = (_a4 = this._instance) == null ? void 0 : _a4.symbolInterval()) == null ? void 0 : _b2.interval);
        i || (i = 1), (_c2 = this._instance) == null ? void 0 : _c2.setSymbol(e2, i, o2);
      });
    } catch {
    }
  }
  executeActionById(e2) {
    var _a3;
    try {
      (_a3 = this._instance) == null ? void 0 : _a3.onChartReady(() => {
        var _a4;
        (_a4 = this._instance) == null ? void 0 : _a4.activeChart().executeActionById(e2);
      });
    } catch {
    }
  }
  changeLineType(e2) {
    var _a3;
    try {
      (_a3 = this._instance) == null ? void 0 : _a3.onChartReady(() => {
        var _a4;
        (_a4 = this._instance) == null ? void 0 : _a4.activeChart().setChartType(e2);
      });
    } catch {
    }
  }
  subscribeClick(e2) {
    var _a3;
    this._onClick = e2, (_a3 = this._instance) == null ? void 0 : _a3.onChartReady(() => {
      var _a4, _b2;
      (_b2 = (_a4 = this._instance) == null ? void 0 : _a4._iFrame.contentDocument) == null ? void 0 : _b2.addEventListener("click", this._onClick);
    });
  }
  unsubscribeClick() {
    var _a3, _b2;
    (_b2 = (_a3 = this._instance) == null ? void 0 : _a3._iFrame.contentDocument) == null ? void 0 : _b2.removeEventListener("click", this._onClick);
  }
  get instance() {
    return this._instance;
  }
  chartHack() {
    var _a3;
    (_a3 = this._instance) == null ? void 0 : _a3.onChartReady(() => {
      let e2 = this._instance._iFrame.contentWindow.document;
      new ve2({ iframeDocument: e2 }).defaultHack();
    });
  }
  subscribeAutoSave() {
    var _a3;
    (_a3 = this._instance) == null ? void 0 : _a3.onChartReady(() => {
      var _a4, _b2;
      (_a4 = this._instance) == null ? void 0 : _a4.subscribe("onAutoSaveNeeded", () => {
        this.debounceSaveChart();
      }), (_b2 = this._instance) == null ? void 0 : _b2.activeChart().onVisibleRangeChanged().subscribe(null, () => {
        this.debounceSaveChart();
      });
    });
  }
  async _create({ options: e2, chartKey: t, mode: o2, onClick: i }) {
    let s2 = e2.getBroker, n4 = { fullscreen: e2.fullscreen ?? true, autosize: e2.autosize ?? false, timezone: e2.timezone, symbol: e2.symbol, library_path: e2.libraryPath, interval: e2.interval ?? "1", custom_css_url: e2.customCssUrl, custom_font_family: e2.customFontFamily, datafeed: e2.datafeed, studies_overrides: e2.studiesOverrides, locale: e2.locale, theme: e2.theme, loading_screen: e2.loadingScreen, overrides: e2.overrides, container: e2.container, favorites: { intervals: ["1", "3", "5", "15", "30", "60", "240", "1D", "1W", "1M"], chartTypes: ["Area", "Line"] }, broker_factory: s2 ? (l2) => (this._broker && this._broker.remove(), this._broker = s2(this._instance, l2), this._broker) : void 0 };
    this._datafeed = e2.datafeed, t && (this._chartKey = t);
    let { savedData: a2, adapterSetting: c } = await pr(this._chartKey, this._isLoggedIn);
    this._adapterSetting = c, this._savedData = a2, this._instance = new TradingView.widget({ ...Je$1(n4, o2), interval: c["chart.lastUsedTimeBasedResolution"] ?? n4.interval, saved_data: a2, settings_adapter: { initialSettings: c, setValue: (l2, u2) => {
      this._adapterSetting = { ...this._adapterSetting, [l2]: u2 }, this.debounceSaveChartAdapterSetting();
    }, removeValue: () => {
    } } }), this._instance.onChartReady(() => {
      var _a3;
      e2.symbol && ((_a3 = this._instance) == null ? void 0 : _a3.activeChart().symbol()) !== x(e2.symbol) && this.setSymbol(e2.symbol);
    }), this.subscribeAutoSave(), this.subscribeClick(i), this.chartHack();
  }
};
function ni(r3) {
  r3.setBrokerConnectionAdapter = function(e2) {
    let t = { subscribe: () => {
    }, unsubscribe: () => {
    }, unsubscribeAll: () => {
    } };
    Object.defineProperty(e2, "_ordersCache", { get: function() {
      return { start: () => {
      }, stop: () => {
      }, update: () => {
      }, partialUpdate: () => {
      }, fullUpdate: () => {
      }, getObjects: async () => [], updateDelegate: t, partialUpdateDelegate: t };
    }, set: () => {
    } }), e2._waitForOrderModification = async () => true, this._adapter = e2;
  };
}
function si(r3, e2) {
  r3.onChartReady(() => {
    e2.silentOrdersPlacement().subscribe((t) => {
      var _a3;
      t || (e2.silentOrdersPlacement().setValue(true), r3 && (r3._iFrame.contentDocument.querySelector(".wrapper-3X2QgaDd").className = "wrapper-3X2QgaDd highButtons-3X2QgaDd"), (_a3 = e2.sellBuyButtonsVisibility()) == null ? void 0 : _a3.setValue(false));
    });
  });
}
function et$1(r3, e2) {
  ni(e2), si(r3, e2);
}
var li$1 = (r3, e2) => {
  let o2, i = (s2) => [null, "limit", "MARKET", "STOP_MARKET", "STOP_LIMIT"][s2];
  return { symbolInfo: async (s2) => (o2 = e2.getSymbolInfo(x(s2)), { qty: { min: (o2 == null ? void 0 : o2.baseMin) ?? 0, max: (o2 == null ? void 0 : o2.baseMax) ?? 0, step: (o2 == null ? void 0 : o2.baseTick) ?? 0 }, pipValue: 0, pipSize: (o2 == null ? void 0 : o2.quoteTick) ?? 0, minTick: (o2 == null ? void 0 : o2.quoteTick) ?? 0, description: "" }), placeOrder: async (s2) => {
    let n4 = ["SELL", "BUY"][+(s2.side > 0)], a2 = s2.qty.toString();
    (s2.limitPrice ?? 0).toString();
    (s2.stopPrice ?? 0).toString();
    let u2 = x(s2.symbol), m2 = i(s2.type);
    m2 === "MARKET" ? e2.sendMarketOrder({ side: n4, order_quantity: a2, symbol: u2, order_type: OrderType.MARKET }) : "LIMIT";
  }, orders: () => [], positions: () => [], executions: () => [], connectionStatus: () => 1, chartContextMenuActions: (s2) => r3.defaultContextMenuActions(s2), isTradable: async () => true, accountManagerInfo: () => ({}), currentAccount: () => "1", accountsMetainfo: async () => [{ id: "1" }], remove: () => r3 == null ? void 0 : r3.silentOrdersPlacement().unsubscribe() };
}, br$1 = li$1;
var yi$1 = "SDK_Tradingview", Ci$1 = "SDK_Moblie_Tradingview", _i = (r3) => r3 ? Ci$1 : yi$1, vi = (r3) => r3 === "id" ? "id_ID" : r3;
function it(r3) {
  let { scriptSRC: e2, libraryPath: t, customCssUrl: o2, overrides: i, studiesOverrides: s2, fullscreen: n4, symbol: a2, theme: c, loadingScreen: l2, mode: u2, colorConfig: m2, locale: h2 = vi } = r3, f2 = de$4(), b2 = useRef(), K2 = useConfig("apiBaseUrl"), { state: I2 } = useAccount(), [_2, M2] = useState(OrderSide.SELL), q2 = useSymbolsInfo(), { onSubmit: W2, submitting: Y2 } = useOrderEntry({ symbol: a2 ?? "", side: _2, order_type: OrderType.MARKET }, { watchOrderbook: true }), [y2, T2] = useState(() => {
    let d2 = localStorage.getItem(V.displayControlSetting);
    return d2 ? JSON.parse(d2) : { position: true, buySell: true, limitOrders: true, stopOrders: true, tpsl: true, positionTpsl: true };
  }), [nt2, Sr2] = useState(() => {
    let d2 = localStorage.getItem(V.interval);
    return d2 || "1";
  }), [Ir2, Tr2] = useState(() => {
    let d2 = localStorage.getItem(V.lineType);
    return d2 || "1";
  }), Oe2 = useMediaQuery(MEDIA_TABLET), xe2 = useMemo(() => Object.assign({}, Ft$1, m2 ?? {}), [m2]), Or2 = useMemo(() => typeof l2 == "object" ? l2 : { backgroundColor: Be }, [l2]), st2 = useWS(), [G2, xr2] = useState(false), Lr2 = (d2) => {
    let J2 = q2[a2];
    if (!J2) return;
    let X2 = new g$6(d2.balance).greaterThan(0) ? OrderSide.SELL : OrderSide.BUY, ct2 = { order_quantity: new g$6(d2.balance).abs().toNumber(), symbol: a2, order_type: OrderType.MARKET, side: X2, reduce_only: true };
    M2(X2), vo$4.show("MarketCloseConfirmID", { base: J2("base"), quantity: d2.balance, onConfirm: async () => W2(ct2).catch((Q2) => {
      typeof Q2 == "string" ? toast$2.error(Q2) : toast$2.error(Q2.message);
    }), submitting: Y2 });
  }, D2 = useRef(null), at2 = useMemo(() => !(I2.status < AccountStatusEnum.EnableTrading && I2.status !== AccountStatusEnum.EnableTradingWithoutConnected), [I2]), lt2 = Jt({ closeConfirm: Lr2, colorConfig: xe2, onToast: toast$2, symbol: a2 ?? "", mode: u2 }), [wr2, Rr2] = ze(a2, y2), Pr2 = (d2) => {
    b2.current && (localStorage.setItem(V.interval, d2), Sr2(d2), b2.current.setSymbol(a2, d2));
  }, Er2 = (d2) => {
    b2.current && (localStorage.setItem(V.lineType, d2), Tr2(d2), b2.current.changeLineType(Number(d2)));
  }, kr2 = (d2) => {
    localStorage.setItem(V.displayControlSetting, JSON.stringify(d2)), T2(d2);
  }, Mr2 = () => {
    b2.current && b2.current.executeActionById("chartProperties");
  }, Dr2 = () => {
    b2.current && b2.current.executeActionById("insertIndicator");
  };
  return useEffect(() => {
    if (e2 && D2.current && !G2) {
      let d2 = document.createElement("script");
      d2.setAttribute("data-nscript", "afterInteractive"), d2.src = e2, d2.async = true, d2.type = "text/javascript", d2.onload = () => {
        xr2(true);
      }, d2.onerror = () => {
      }, D2.current.appendChild(d2);
    }
  }, [D2, G2, e2]), useEffect(() => {
    if (!a2 || !G2 || !e2) return;
    let d2 = Kt(xe2, Oe2), J2 = i ? Object.assign({}, d2.overrides, i) : d2.overrides, X2 = s2 ? Object.assign({}, d2.studiesOverrides, s2) : d2.studiesOverrides;
    if (D2.current) {
      let Q2 = { options: { fullscreen: n4 ?? false, autosize: true, symbol: oe(a2), locale: typeof h2 == "function" ? h2(f2) : h2, timezone: Intl.DateTimeFormat().resolvedOptions().timeZone, container: D2.current, libraryPath: t, customCssUrl: o2, interval: nt2 ?? "1", theme: c ?? "dark", loadingScreen: Or2 ?? {}, overrides: J2, studiesOverrides: X2, datafeed: new _e(K2, st2), contextMenu: { items_processor: async (Le2) => Le2 }, getBroker: (Le2, ut2) => (et$1(Le2, ut2), br$1(ut2, lt2)) }, chartKey: _i(Oe2), mode: u2, onClick: () => {
      } };
      b2.current = new Ie$1(Q2);
    }
    return () => {
      var _a3;
      (_a3 = b2.current) == null ? void 0 : _a3.remove();
    };
  }, [G2, Oe2, u2, b2, D2, G2, e2, xe2, h2, f2]), useEffect(() => (b2.current && b2.current.instance && b2.current.instance.onChartReady(() => {
    at2 && b2.current.instance && wr2(b2.current.instance, void 0, lt2);
  }), () => {
    Rr2();
  }), [b2.current, at2]), useEffect(() => {
    var _a3;
    if (!a2 || !b2.current) return;
    (_a3 = b2.current) == null ? void 0 : _a3.setSymbol(a2);
    let d2 = new F2(st2);
    return d2.subscribeSymbol(a2), () => {
      d2.unsubscribeKline(a2);
    };
  }, [a2]), { tradingViewScriptSrc: e2, chartRef: D2, changeDisplaySetting: kr2, displayControlState: y2, interval: nt2, changeInterval: Pr2, lineType: Ir2, changeLineType: Er2, openChartSetting: Mr2, openChartIndicators: Dr2, symbol: a2 };
}
function Si$1(r3) {
  let e2 = it(r3);
  return jsx(Ae, { ...e2 });
}
var to = (e2) => {
  let { isMobile: t } = it$6();
  return t ? jsx(Ha, { ...e2 }) : jsx(Ea, { ...e2 });
}, Ha = (e2) => {
  let { t } = ne$6();
  return jsxs(z$3, { direction: "column", gap: 2, width: "100%", itemAlign: "start", p: 2, className: "oui-bg-base-9 oui-rounded-b-xl", children: [jsxs(z$3, { width: "100%", justify: "between", children: [jsx(er, { classNames: { label: "oui-text-2xs oui-text-base-contrast-54", root: "oui-text-sm" }, ...e2 }), jsx(tr, { classNames: { label: "oui-text-2xs oui-text-base-contrast-54", root: "oui-text-sm" }, ...e2 })] }), jsx(de$5, { className: "oui-w-full" }), jsxs(z$3, { className: "oui-gap-[2px] oui-cursor-pointer", children: [jsx(pi$1, { id: "oui-checkbox-hideOtherSymbols", color: "white", checked: !e2.showAllSymbol, onCheckedChange: (o2) => {
    e2.setShowAllSymbol(!o2);
  } }), jsx("label", { className: "oui-text-2xs oui-text-base-contrast-54 oui-cursor-pointer", htmlFor: "oui-checkbox-hideOtherSymbols", children: t("trading.hideOtherSymbols") })] })] });
}, Ea = (e2) => jsxs(z$3, { py: 2, px: 3, gap: 6, width: "100%", justify: "start", children: [jsx(er, { ...e2, classNames: { label: "oui-text-base-contrast-54" } }), jsx(tr, { ...e2, classNames: { label: "oui-text-base-contrast-54" } })] }), er = (e2) => {
  let { t } = ne$6(), o2 = typeof e2.unrealPnL == "number" ? e2.unrealPnL >= 0 ? "oui-text-trade-profit" : "oui-text-trade-loss" : "oui-text-base-contrast-80", i = typeof e2.unrealPnL == "number" && e2.unrealPnlROI ? e2.unrealPnlROI >= 0 ? "oui-text-success-darken" : "oui-text-danger-darken" : "oui-text-base-contrast-80";
  return jsx(za$1, { label: t("common.unrealizedPnl"), classNames: e2.classNames, children: jsxs(z$3, { gap: 1, children: [jsx(Q$1.numeral, { dp: e2.pnlNotionalDecimalPrecision, rm: g$6.ROUND_DOWN, intensity: 80, className: o2, children: e2.unrealPnL ?? "--" }), typeof e2.unrealPnlROI < "u" && jsx(Q$1.numeral, { prefix: "(", suffix: ")", rule: "percentages", size: "2xs", dp: e2.pnlNotionalDecimalPrecision, rm: g$6.ROUND_DOWN, className: i, children: e2.unrealPnlROI })] }) });
}, tr = (e2) => {
  let { t } = ne$6();
  return jsx(za$1, { label: t("common.notional"), classNames: e2.classNames, children: jsx(Q$1.numeral, { dp: e2.pnlNotionalDecimalPrecision, rm: g$6.ROUND_DOWN, intensity: 80, children: e2.notional ?? "--" }) });
};
var G = (e2) => {
  let [t, o2] = useLocalStorage("unPnlPriceBasis", "markPrice"), [i, r3] = useLocalStorage("pnlNotionalDecimalPrecision", (e2 == null ? void 0 : e2.pnlNotionalDecimalPrecision) ?? 2), [n4, a2] = useLocalStorage("showAllSymbol", true), [s2, c] = useLocalStorage("hideAssets", false);
  return { unPnlPriceBasis: t, setUnPnlPriceBasic: o2, pnlNotionalDecimalPrecision: i, setPnlNotionalDecimalPrecision: r3, showAllSymbol: n4, setShowAllSymbol: a2, hideAssets: s2, setHideAssets: c };
};
var or = (e2) => {
  let { pnlNotionalDecimalPrecision: t, unPnlPriceBasis: o2, symbol: i } = e2, r3 = o2, [n4] = usePositionStream(i, { calcMode: r3 }), a2 = Tr$2(n4.aggregated), s2 = a2 == null ? void 0 : a2.total_unreal_pnl, c = a2 == null ? void 0 : a2.unrealPnlROI, l2 = a2 == null ? void 0 : a2.notional, { showAllSymbol: d2, setShowAllSymbol: u2 } = G();
  return { pnlNotionalDecimalPrecision: t, unrealPnL: s2, unrealPnlROI: c, notional: l2, showAllSymbol: d2, setShowAllSymbol: u2 };
};
var Ze = (e2) => {
  let t = or(e2);
  return jsx(to, { ...t });
};
var Je = (e2) => {
  var _a3;
  let { showAllSymbol: t } = G(), [o2] = usePositionStream(t ? void 0 : e2), i = useMemo(() => {
    var _a4;
    return (_a4 = o2.rows) == null ? void 0 : _a4.length;
  }, [(_a3 = o2.rows) == null ? void 0 : _a3.length]);
  return { positionCount: Tr$2(i) ?? 0 };
};
var je2 = (e2) => {
  let { showAllSymbol: t } = G();
  `orderly_${Pe.pending}_pageSize`;
  `orderly_${Pe.tp_sl}_pageSize`;
  let [r3, { total: n4 }] = useOrderStream({ symbol: t ? void 0 : e2, status: OrderStatus.INCOMPLETE, excludes: [AlgoOrderRootType.POSITIONAL_TP_SL, AlgoOrderRootType.TP_SL], size: 500 }, { keeplive: true }), [a2, { total: s2 }] = useOrderStream({ symbol: t ? void 0 : e2, status: OrderStatus.INCOMPLETE, includes: [AlgoOrderRootType.POSITIONAL_TP_SL, AlgoOrderRootType.TP_SL], size: 500 }, { keeplive: true }), c = Tr$2(n4) ?? 0, l2 = Tr$2(s2) ?? 0;
  return { pendingOrderCount: c, tpSlOrderCount: l2 };
};
var et = (e2) => ({ base_dp: e2("base_dp"), quote_dp: e2("quote_dp"), base_tick: e2("base_tick"), base: e2("base"), quote: e2("quote") });
var sr = createContext({}), z = () => useContext(sr), lr = (e2) => {
  let t = useSymbolsInfo()[e2.symbol];
  return jsx(sr.Provider, { value: { ...e2, symbolInfo: { ...et(t), symbol: e2.symbol } }, children: e2.children });
};
var ur = (e2) => {
  let { current: t, pnlNotionalDecimalPrecision: o2, sharePnLConfig: i, symbol: r3, includedPendingOrder: n4 } = e2, a2 = G({ pnlNotionalDecimalPrecision: o2 }), { onSymbolChange: s2 } = z(), { positionCount: c } = Je(e2.symbol), { pendingOrderCount: l2, tpSlOrderCount: d2 } = je2(e2.symbol);
  return { current: t, sharePnLConfig: i, symbol: r3, calcMode: a2.unPnlPriceBasis, includedPendingOrder: n4, ...a2, positionCount: c, pendingOrderCount: l2, tpSlOrderCount: d2, onSymbolChange: s2 };
};
var oo = (e2) => {
  let [t, o2] = useState(false), { t: i } = ne$6();
  return jsxs(z$3, { gap: 0, children: [jsxs(z$3, { gap: 1, children: [jsx(pi$1, { id: "oui-checkbox-hideOtherSymbols", color: "white", checked: e2.hideOtherSymbols, onCheckedChange: (r3) => {
    e2.setHideOtherSymbols(r3);
  } }), jsx("label", { className: "oui-text-xs oui-text-base-contrast-54 oui-cursor-pointer", htmlFor: "oui-checkbox-hideOtherSymbols", children: i("trading.hideOtherSymbols") })] }), jsxs(la$1, { open: t, onOpenChange: o2, children: [jsx(ua$2, { asChild: true, children: jsx($e$6, { size: "xs", type: "button", variant: "contained", className: "oui-bg-transparent hover:oui-bg-transparent", children: jsx(qa, { size: 16, color: "white", opacity: 1, className: "oui-text-white/[.36] hover:oui-text-white/80" }) }) }), jsx(xr$3, { className: "oui-px-5 oui-py-3 oui-w-[360px]", alignOffset: 2, align: "end", children: jsxs("div", { className: "oui-flex oui-flex-col oui-text-sm", children: [jsx(Q$1, { className: "oui-text-base oui-pb-3", children: i("trading.portfolioSettings") }), jsx(de$5, {}), jsx(Q$1, { className: "oui-pb-3 oui-text-base-contrast-54 oui-mt-2", children: i("trading.portfolioSettings.decimalPrecision") }), jsx(rs, { value: e2.pnlNotionalDecimalPrecision, onValueChange: (r3) => {
    e2.setPnlNotionalDecimalPrecision(r3), o2(false);
  } }), jsx(de$5, { className: "oui-my-3" }), jsx(Q$1, { className: "oui-pb-3 oui-text-base-contrast-54 oui-mt-2", children: i("trading.portfolioSettings.unrealPnlPriceBasis") }), jsx(is, { value: e2.unPnlPriceBasis, onValueChange: (r3) => {
    e2.setUnPnlPriceBasic(r3), o2(false);
  } })] }) })] })] });
}, is = (e2) => {
  let { value: t, onValueChange: o2 } = e2, { t: i } = ne$6();
  return jsxs(z$3, { gap: 2, children: [jsx(tt, { sel: t === "markPrice", label: i("common.markPrice"), value: "markPrice", onCheckChange: o2 }), jsx(tt, { sel: t === "lastPrice", label: i("common.lastPrice"), value: "lastPrice", onCheckChange: o2 })] });
}, rs = (e2) => {
  let { value: t, onValueChange: o2 } = e2;
  return jsxs(z$3, { gap: 2, children: [jsx(tt, { sel: t === 0, label: 1, value: 0, onCheckChange: o2 }), jsx(tt, { sel: t === 1, label: 0.1, value: 1, onCheckChange: o2 }), jsx(tt, { sel: t === 2, label: 0.01, value: 2, onCheckChange: o2 })] });
}, tt = (e2) => {
  let { sel: t, label: o2, value: i, onCheckChange: r3 } = e2;
  return jsxs(z$3, { onClick: (n4) => {
    r3(i), n4.stopPropagation();
  }, gap: 1, className: "oui-cursor-pointer", children: [t ? jsx(ns, {}) : jsx(as, {}), jsx(Q$1, { size: "2xs", intensity: t ? 98 : 54, children: o2 })] });
}, ns = () => jsxs("svg", { width: "16", height: "16", viewBox: "0 0 16 16", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", className: "oui-fill-white", children: [jsx("path", { d: "M8.01 1.333a6.667 6.667 0 1 0 0 13.333 6.667 6.667 0 0 0 0-13.333m0 1.333a5.334 5.334 0 1 1-.001 10.667 5.334 5.334 0 0 1 0-10.667", fill: "#fff", fillOpacity: ".36" }), jsx("circle", { cx: "8", cy: "8", r: "3.333" })] }), as = () => jsx("svg", { width: "16", height: "16", viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: jsx("path", { d: "M8.01 1.333a6.667 6.667 0 1 0 0 13.333 6.667 6.667 0 0 0 0-13.333m0 1.333a5.334 5.334 0 1 1-.001 10.667 5.334 5.334 0 0 1 0-10.667", fill: "#fff", fillOpacity: ".54" }) });
var mr = (e2) => ({ ...e2 });
var io = (e2) => {
  let t = mr(e2);
  return jsx(oo, { ...t });
};
var no = (e2) => {
  let { t } = ne$6();
  return jsxs(jl, { defaultValue: e2.current || "Positions", variant: "contained", trailing: jsx(io, { pnlNotionalDecimalPrecision: e2.pnlNotionalDecimalPrecision, setPnlNotionalDecimalPrecision: e2.setPnlNotionalDecimalPrecision, unPnlPriceBasis: e2.unPnlPriceBasis, setUnPnlPriceBasic: e2.setUnPnlPriceBasic, hideOtherSymbols: !e2.showAllSymbol, setHideOtherSymbols: (o2) => e2.setShowAllSymbol(!o2) }), size: "lg", className: "oui-h-full", classNames: { tabsContent: "oui-h-[calc(100%_-_32px)]" }, children: [jsx($l, { testid: "oui-testid-dataList-position-tab", value: "Positions", title: `${t("common.positions")} ${(e2.positionCount ?? 0) > 0 ? `(${e2.positionCount})` : ""}`, children: jsx(hs, { ...e2 }) }), jsx($l, { testid: "oui-testid-dataList-pending-tab", value: "Pending", title: `${t("orders.status.pending")} ${(e2.pendingOrderCount ?? 0) > 0 ? `(${e2.pendingOrderCount})` : ""}`, children: jsx(he$1, { type: Pe.pending, ordersStatus: OrderStatus.INCOMPLETE, symbol: e2.showAllSymbol ? void 0 : e2.symbol, onSymbolChange: e2.onSymbolChange, testIds: { tableBody: "oui-testid-dataList-pending-table-body" } }) }), jsx($l, { testid: "oui-testid-dataList-tpsl-tab", value: "TP/SL", title: `${t("common.tpsl")} ${(e2.tpSlOrderCount ?? 0) > 0 ? `(${e2.tpSlOrderCount})` : ""}`, children: jsx(he$1, { type: Pe.tp_sl, ordersStatus: OrderStatus.INCOMPLETE, symbol: e2.showAllSymbol ? void 0 : e2.symbol, onSymbolChange: e2.onSymbolChange, testIds: { tableBody: "oui-testid-dataList-tpsl-table-body" } }) }), jsx($l, { testid: "oui-testid-dataList-filled-tab", value: "Filled", title: t("orders.status.filled"), children: jsx(he$1, { type: Pe.filled, symbol: e2.showAllSymbol ? void 0 : e2.symbol, pnlNotionalDecimalPrecision: e2.pnlNotionalDecimalPrecision, ordersStatus: OrderStatus.FILLED, onSymbolChange: e2.onSymbolChange, testIds: { tableBody: "oui-testid-dataList-filled-table-body" }, sharePnLConfig: e2.sharePnLConfig }) }), jsx($l, { testid: "oui-testid-dataList-positionHistory-tab", value: "Position history", title: t("positions.positionHistory"), children: jsx(Ls, { pnlNotionalDecimalPrecision: e2.pnlNotionalDecimalPrecision, symbol: e2.showAllSymbol ? void 0 : e2.symbol, onSymbolChange: e2.onSymbolChange, sharePnLConfig: e2.sharePnLConfig }) }), jsx($l, { testid: "oui-testid-dataList-orderHistory-tab", value: "Order history", title: t("orders.orderHistory"), children: jsx(he$1, { type: Pe.orderHistory, pnlNotionalDecimalPrecision: e2.pnlNotionalDecimalPrecision, symbol: e2.showAllSymbol ? void 0 : e2.symbol, onSymbolChange: e2.onSymbolChange, testIds: { tableBody: "oui-testid-dataList-orderHistory-table-body" }, sharePnLConfig: e2.sharePnLConfig }) }), jsx($l, { testid: "oui-testid-dataList-liquidation-tab", value: "Liquidation", title: t("positions.liquidation"), children: jsx(js$1, { symbol: e2.showAllSymbol ? void 0 : e2.symbol }) })] });
}, hs = (e2) => jsxs(z$3, { direction: "column", width: "100%", height: "100%", children: [jsx(Ze, { pnlNotionalDecimalPrecision: e2.pnlNotionalDecimalPrecision, symbol: e2.showAllSymbol ? void 0 : e2.symbol, unPnlPriceBasis: e2.unPnlPriceBasis }), jsx(de$5, { className: "oui-w-full" }), jsx(W$2, { className: "oui-h-[calc(100%_-_60px)]", width: "100%", children: jsx(Gr$2, { symbol: e2.showAllSymbol ? void 0 : e2.symbol, pnlNotionalDecimalPrecision: e2.pnlNotionalDecimalPrecision, sharePnLConfig: e2.sharePnLConfig, calcMode: e2.calcMode, includedPendingOrder: e2.includedPendingOrder, onSymbolChange: e2.onSymbolChange }) })] });
var ao = (e2) => {
  let t = ur({ ...e2 });
  return jsx(no, { ...t });
};
var so = (e2) => {
  var _a3, _b2, _c2, _d3;
  return jsxs(W$2, { className: cnBase("oui-grid oui-grid-rows=[auto,1fr] oui-h-full oui-w-full", (_a3 = e2.classNames) == null ? void 0 : _a3.root), style: e2.style, children: [jsx(W$2, { className: "oui-pr-1", children: jsx(ws, { base: e2.base, quote: e2.quote, className: (_b2 = e2.classNames) == null ? void 0 : _b2.listHeader }) }), jsx(vs, { data: e2.data, isLoading: e2.isLoading, baseDp: e2.baseDp, quoteDp: e2.quoteDp, classNames: (_c2 = e2.classNames) == null ? void 0 : _c2.listItem, className: (_d3 = e2.classNames) == null ? void 0 : _d3.list })] });
}, br = (e2) => {
  let { left: t, mid: o2, right: i, classNames: r3 } = e2;
  return jsxs(Sa$1, { cols: 3, gapX: 2, width: "100%", className: cnBase("oui-text-xs oui-tabular-nums", r3 == null ? void 0 : r3.root), children: [jsx("div", { className: cnBase("oui-flex-1", r3 == null ? void 0 : r3.left), children: t }), jsx("div", { className: cnBase("oui-flex-1", r3 == null ? void 0 : r3.mid), children: o2 }), jsx("div", { className: cnBase("oui-flex-1 oui-text-right", r3 == null ? void 0 : r3.right), children: i })] });
}, ws = (e2) => {
  let { t } = ne$6();
  return jsx(br, { left: t("common.time"), mid: `${t("common.price")}(${e2.quote})`, right: `${t("common.qty")}(${e2.base})`, classNames: { root: cnBase("oui-text-base-contrast-54 oui-h-[32px] oui-sticky", e2.className) } });
}, vs = (e2) => jsx(og$1, { dataSource: e2.data, className: cnBase("oui-last-trades-list", "oui-w-full oui-h-full", e2.className, "oui-overflow-auto"), contentClassName: "!oui-space-y-0 oui-pr-[-4px]", renderItem: (t, o2) => {
  var _a3, _b2, _c2;
  return jsx(br, { left: jsx(Q$1.formatted, { rule: "date", formatString: "HH:mm:ss", children: t == null ? void 0 : t.ts }), mid: E$4(t == null ? void 0 : t.price, { fix: e2.quoteDp }), right: E$4(t == null ? void 0 : t.size, { fix: e2.baseDp }), classNames: { left: cnBase("oui-text-base-contrast-80", (_a3 = e2.classNames) == null ? void 0 : _a3.left), right: cnBase(t.side === OrderSide.BUY ? "oui-text-trade-profit" : "oui-text-trade-loss", (_b2 = e2.classNames) == null ? void 0 : _b2.mid), mid: cnBase(t.side === OrderSide.BUY ? "oui-text-trade-profit" : "oui-text-trade-loss", (_c2 = e2.classNames) == null ? void 0 : _c2.right) } }, o2);
} });
var yr = (e2) => {
  var _a3;
  let { data: t, isLoading: o2 } = useMarketTradeStream(e2), i = (_a3 = useSymbolsInfo()) == null ? void 0 : _a3[e2], r3 = i == null ? void 0 : i("base"), n4 = i == null ? void 0 : i("quote"), a2 = i == null ? void 0 : i("base_dp"), s2 = i == null ? void 0 : i("quote_dp");
  return { base: r3, quote: n4, data: t, isLoading: o2, baseDp: a2, quoteDp: s2 };
};
var Me2 = (e2) => {
  let t = yr(e2.symbol);
  return jsx(so, { ...t, classNames: e2.classNames, style: e2.style });
};
function Sr(e2) {
  let { t } = ne$6();
  return e2.showFaucet ? jsx($e$6, { variant: "outlined", fullWidth: true, size: "md", onClick: e2.getFaucet, loading: e2.loading, className: "oui-text-primary-light oui-border-primary-light oui-rounded", "data-testid": "oui-testid-assetView-getFaucet-button", children: t("trading.faucet.getTestUSDC") }) : null;
}
function vr() {
  let { t: e2 } = ne$6(), { connectedChain: t, namespace: o2 } = useWalletConnector(), { state: i, account: r3 } = useAccount(), n4 = useConfig(), a2 = n4.get("operatorUrl"), [s2, { isMutating: c }] = useMutation(`${a2}/v1/faucet/usdc`), [l2, d2] = useState(false), u2 = useMemo(() => !t || !t.id ? false : (i.status === AccountStatusEnum.EnableTrading || i.status === AccountStatusEnum.EnableTradingWithoutConnected) && L$5(parseInt(t.id)), [i, t]);
  return { getFaucet: () => {
    var _a3;
    if (l2) return;
    d2(true);
    let g2 = e2("trading.faucet.getTestUSDC.success", { quantity: o2 === ChainNamespace.solana ? "100" : "1,000" });
    return s2({ chain_id: (_a3 = r3.walletAdapter) == null ? void 0 : _a3.chainId.toString(), user_address: i.address, broker_id: n4.get("brokerId") }).then((f2) => {
      if (d2(false), f2.success) return vo$4.alert({ title: e2("trading.faucet.getTestUSDC"), message: g2, onOk: () => new Promise((p2) => p2(true)) });
      f2.message && toast$2.error(f2.message);
    }, (f2) => {
      toast$2.error(f2.message);
    });
  }, showFaucet: u2, loading: l2 };
}
function lo() {
  let e2 = vr();
  return jsx(Sr, { ...e2 });
}
var js = () => {
  let { state: e2 } = useAccount(), { wrongNetwork: t, disabledConnect: o2 } = L$3(), { t: i } = ne$6();
  return useMemo(() => {
    let r3 = { wrongNetwork: { title: i("connector.wrongNetwork"), description: i("connector.wrongNetwork.tooltip"), titleColor: "warning" }, connectWallet: { title: i("connector.connectWallet"), description: i("connector.trade.connectWallet.tooltip"), titleClsName: "oui-text-transparent oui-bg-clip-text oui-gradient-brand" }, notSignedIn: { title: i("connector.signIn"), description: i("connector.trade.signIn.tooltip"), titleColor: "primary" }, disabledTrading: { title: i("connector.enableTrading"), description: i("connector.trade.enableTrading.tooltip"), titleColor: "primary" }, default: { title: "", description: "" } };
    if (o2) return r3.connectWallet;
    if (t) return r3.wrongNetwork;
    switch (e2.status) {
      case AccountStatusEnum.NotConnected:
        return r3.connectWallet;
      case AccountStatusEnum.NotSignedIn:
        return r3.notSignedIn;
      case AccountStatusEnum.DisabledTrading:
        return r3.disabledTrading;
      default:
        return r3.default;
    }
  }, [e2.status, t, i]);
}, po = ({ description: e2, formula: t }) => jsxs("div", { className: "oui-leading-[1.5] oui-text-2xs oui-text-base-contrast-80 oui-min-w-[204px] oui-max-w-[240px]", children: [jsx("span", { children: e2 }), jsx(de$5, { className: "oui-border-white/10", my: 2 }), jsx("span", { children: t })] }), el = ({ totalValue: e2, visible: t = true, onToggleVisibility: o2 }) => {
  let { t: i } = ne$6();
  return jsxs(z$3, { direction: "column", gap: 1, className: "oui-text-2xs", itemAlign: "center", children: [jsx(Q$1.numeral, { visible: t, weight: "bold", size: "2xl", className: jn$2({ color: "brand" }), as: "div", padding: false, dp: 2, children: e2 ?? "--" }), jsxs(z$3, { gap: 1, itemAlign: "center", children: [jsx(Q$1, { size: "2xs", color: "neutral", weight: "semibold", children: `${i("trading.asset.myAssets")} (USDC)` }), jsx("button", { onClick: o2, children: t ? jsx(Nn$2, { size: 18, className: "oui-text-base-contrast-54" }) : jsx(zn$1, { size: 18, className: "oui-text-base-contrast-54" }) })] })] });
}, go = ({ label: e2, description: t, formula: o2, visible: i, value: r3, unit: n4, rule: a2, isConnected: s2, showPercentage: c = false, placeholder: l2 }) => jsxs(z$3, { justify: "between", children: [jsx(xs, { content: jsx(po, { description: t, formula: o2 }), children: jsx(Q$1, { size: "2xs", color: "neutral", weight: "semibold", className: "oui-cursor-pointer oui-border-b oui-border-dashed oui-border-line-12", children: e2 }) }), jsx(Q$1.numeral, { visible: i, size: "2xs", unit: n4, unitClassName: "oui-text-base-contrast-36 oui-ml-0.5", as: "div", rule: a2, padding: false, dp: 2, placeholder: l2, children: r3 || "--" })] }), tl = ({ visible: e2 = true, freeCollateral: t, marginRatioVal: o2, renderMMR: i, isConnected: r3 }) => {
  let [n4, a2] = useLocalStorage("orderly_entry_asset_list_open", false), [s2, c] = useState(n4), { t: l2 } = ne$6(), d2 = useCallback(() => {
    c((u2) => !u2), setTimeout(() => {
      a2(!s2);
    }, 0);
  }, []);
  return jsxs(W$2, { className: "oui-group", children: [jsxs(z$3, { justify: "center", gap: 1, itemAlign: "center", className: "oui-cursor-pointer", onClick: d2, children: [jsx(de$5, { className: "oui-flex-1" }), jsx(ht$4, { size: 12, color: "white", className: cnBase("oui-transition-transform", s2 && "oui-rotate-180") }), jsx(de$5, { className: "oui-flex-1" })] }), jsxs(W$2, { style: { transform: "translateZ(0)" }, className: cnBase("oui-space-y-1.5 oui-select-none oui-overflow-hidden", "oui-transition-[max-height] oui-duration-150", "group-hover:oui-will-change-[max-height]", s2 ? "oui-max-h-[69px]" : "oui-max-h-0"), children: [jsx(go, { label: l2("trading.asset.freeCollateral"), description: l2("trading.asset.freeCollateral.tooltip"), formula: l2("trading.asset.freeCollateral.formula"), visible: e2, value: t === 0 ? "0" : t, unit: "USDC" }), jsx(go, { label: l2("trading.asset.marginRatio"), description: l2("trading.asset.marginRatio.tooltip"), formula: l2("trading.asset.marginRatio.formula"), visible: e2, value: o2, isConnected: r3, rule: "percentages", showPercentage: true, placeholder: "--%" }), jsx(go, { label: l2("trading.asset.maintenanceMarginRatio"), description: l2("trading.asset.maintenanceMarginRatio.tooltip"), formula: l2("trading.asset.maintenanceMarginRatio.formula"), visible: e2, value: i, rule: "percentages", showPercentage: true, placeholder: "--%" })] })] });
}, ho = ({ networkId: e2, isFirstTimeDeposit: t, totalValue: o2, onDeposit: i, onWithdraw: r3, toggleVisible: n4, visible: a2, freeCollateral: s2, marginRatioVal: c, renderMMR: l2, isConnected: d2 }) => {
  let { title: u2, description: m2, titleColor: g2, titleClsName: f2 } = js(), { t: p2 } = ne$6();
  return jsxs(W$2, { className: "oui-relative", children: [u2 && m2 && jsxs(z$3, { direction: "column", gap: 1, className: "oui-mb-[32px]", children: [jsx(Q$1, { size: "lg", weight: "bold", color: g2 || "inherit", className: f2, children: u2 }), jsx(Q$1, { size: "2xs", color: "neutral", weight: "semibold", className: "oui-text-center", children: m2 })] }), jsx(S, { networkId: e2, buttonProps: { size: "md", fullWidth: true }, children: t ? jsxs(Fragment$1, { children: [jsx(W$2, { children: jsxs(z$3, { direction: "column", gap: 1, className: "oui-mb-[32px]", children: [jsx(Q$1.gradient, { size: "lg", weight: "bold", color: "brand", children: p2("trading.asset.startTrading") }), jsx(Q$1, { size: "2xs", color: "neutral", weight: "semibold", children: p2("trading.asset.startTrading.description") })] }) }), jsxs($e$6, { "data-testid": "oui-testid-assetView-deposit-button", fullWidth: true, size: "md", onClick: i, children: [jsx(Hn, { color: "white", opacity: 1 }), jsx(Q$1, { children: p2("common.deposit") })] }), jsx(W$2, { className: "oui-mt-3", children: jsx(lo, {}) })] }) : jsxs(W$2, { className: "oui-space-y-4", children: [jsx(el, { totalValue: o2, visible: a2, onToggleVisibility: n4 }), jsx(tl, { visible: a2, freeCollateral: s2, marginRatioVal: c, renderMMR: l2, isConnected: d2 }), jsxs(z$3, { gap: 3, itemAlign: "center", children: [jsxs($e$6, { fullWidth: true, color: "secondary", size: "md", onClick: r3, "data-testid": "oui-testid-assetView-withdraw-button", children: [jsx(Hn, { color: "white", opacity: 1, className: "oui-rotate-180" }), jsx(Q$1, { children: p2("common.withdraw") })] }), jsxs($e$6, { "data-testid": "oui-testid-assetView-deposit-button", fullWidth: true, size: "md", onClick: i, children: [jsx(Hn, { color: "white", opacity: 1 }), jsx(Q$1, { children: p2("common.deposit") })] })] }), jsx(lo, {})] }) }), jsx("div", { className: "oui-pointer-events-none oui-rotate-180 oui-rounded-2xl oui-blur-[200px] oui-top-0 oui-bottom-0 oui-left-0 oui-right-0 oui-absolute", style: { background: "conic-gradient(from -40.91deg at 40.63% 50.41%, rgba(159, 115, 241, 0) -48.92deg, rgba(242, 98, 181, 0) 125.18deg, #5FC5FF 193.41deg, #FFAC89 216.02deg, #8155FF 236.07deg, #789DFF 259.95deg, rgba(159, 115, 241, 0) 311.08deg, rgba(242, 98, 181, 0) 485.18deg)" } })] });
};
var yo = () => {
  var _a3;
  let { state: e2 } = useAccount(), { wrongNetwork: t, disabledConnect: o2 } = L$3(), { totalValue: i } = useCollateral({ dp: 2 }), r3 = t || o2 || e2.status < AccountStatusEnum.EnableTrading && e2.status !== AccountStatusEnum.EnableTradingWithoutConnected, n4 = useMemo(() => {
    let s2 = /* @__PURE__ */ new Date(), c = /* @__PURE__ */ new Date();
    c.setDate(s2.getDate() - 90);
    let l2 = c.getTime(), d2 = s2.getTime(), u2 = new URLSearchParams();
    return u2.set("page", "1"), u2.set("size", "5"), u2.set("side", "DEPOSIT"), u2.set("status", "COMPLETED"), u2.set("startTime", l2.toString()), u2.set("endTime", d2.toString()), `/v1/asset/history?${u2.toString()}`;
  }, []), { data: a2 } = usePrivateQuery(n4, { formatter: (s2) => s2 });
  return { isFirstTimeDeposit: !r3 && i === 0 && ((_a3 = a2 == null ? void 0 : a2.meta) == null ? void 0 : _a3.total) === 0, totalValue: i };
}, Lr = () => {
  let { t: e2 } = ne$6(), t = useAccountInstance(), o2 = useMediaQuery(MEDIA_TABLET), { isFirstTimeDeposit: i, totalValue: r3 } = yo(), n4 = useConfig("networkId"), { state: a2 } = useAccount(), { freeCollateral: s2 } = useCollateral({ dp: 2 }), { marginRatio: c, mmr: l2 } = useMarginRatio(), d2 = a2.status >= AccountStatusEnum.Connected, [{ aggregated: u2, totalUnrealizedROI: m2 }, g2] = usePositionStream(), f2 = useMemo(() => Math.min(10, u2.notional === 0 ? g2.margin_ratio(10) : c), [c, u2]);
  useMemo(() => l2 ? new g$6(l2).mul(100).todp(2, 0).toFixed(2) : "", [l2]);
  let S2 = useCallback(async (O2) => {
    let _2;
    return o2 ? _2 = await vo$4.show(Xr$1, { activeTab: O2 }) : _2 = await vo$4.show(Hr$4, { activeTab: O2 }), _2;
  }, [o2]), y2 = useCallback(async () => S2("deposit"), [o2]), C2 = useEventEmitter(), N2 = useCallback(async () => S2("withdraw"), [o2]), b2 = useCallback(async () => t.settle().catch((O2) => {
    if (O2.code === -1104) return toast$2.error(e2("settle.settlement.error")), Promise.reject(O2);
    O2.message.indexOf("Signing off chain messages with Ledger is not yet supported") !== -1 && C2.emit("wallet:sign-message-with-ledger-error", { message: O2.message, userAddress: t.address });
  }).then((O2) => (toast$2.success(e2("settle.settlement.requested")), Promise.resolve(O2))), [t, e2]), [w4, q2] = useLocalStorage("orderly_assets_visible", true), x2 = useCallback(() => {
    q2((O2) => !O2);
  }, [w4]);
  useWalletSubscription({ onMessage: (O2) => {
    let { side: _2, transStatus: j2 } = O2;
    if (j2 === "COMPLETED") {
      let Ke2 = { DEPOSIT: e2("transfer.deposit.completed"), WITHDRAW: e2("transfer.withdraw.completed") }, Ae2 = `${j$4(_2)} completed`;
      toast$2.success(Ke2[_2] || Ae2);
    } else if (j2 === "FAILED") {
      let Ke2 = { DEPOSIT: e2("transfer.deposit.failed"), WITHDRAW: e2("transfer.withdraw.failed") }, Ae2 = `${j$4(_2)} failed`;
      toast$2.error(Ke2[_2] || Ae2);
    }
    C2.emit("wallet:changed", O2);
  } }), useSettleSubscription({ onMessage: (O2) => {
    let { status: _2 } = O2;
    switch (_2) {
      case "COMPLETED":
        toast$2.success(e2("settle.settlement.completed"));
        break;
      case "FAILED":
        toast$2.error(e2("settle.settlement.failed"));
        break;
    }
  } });
  let A2 = Tr$2(s2) ?? void 0, J2 = Tr$2(f2) ?? void 0, Q2 = Tr$2(l2) ?? void 0, xe2 = Tr$2(r3) ?? void 0;
  return { onDeposit: y2, onWithdraw: N2, onSettle: b2, visible: w4, toggleVisible: x2, networkId: n4, isFirstTimeDeposit: i, totalValue: xe2, status: a2.status, freeCollateral: A2, marginRatioVal: J2, renderMMR: Q2, isConnected: d2 };
};
var So = () => {
  let e2 = Lr();
  return jsx(ho, { ...e2 });
};
var Dt = createContext({ cellHeight: 22 }), Y = () => useContext(Dt), Ne2 = "orderbook_coin_type", Lt = (e2) => {
  let [t, o2] = useState("quantity"), [i, r3] = useState("quantity"), n4 = ze__default__default.useMemo(() => ({ cellHeight: e2.cellHeight, onItemClick: e2.onItemClick, mode: t, totalMode: i || "quantity", depth: e2.depth, onModeChange: o2, onTotalModeChange: r3, showTotal: e2.showTotal || false, pendingOrders: e2.pendingOrders, symbolInfo: e2.symbolInfo }), [t, e2.cellHeight, e2.depth, e2.onItemClick, e2.pendingOrders, e2.showTotal, e2.symbolInfo, i]);
  return jsx(Dt.Provider, { value: n4, children: e2.children });
};
var Ft = (e2) => {
  let { direction: t = 1 } = e2, o2 = useMemo(() => {
    let i = Math.max(e2.width, 0);
    return t === 0 ? { transform: `translateX(${i}%)` } : { transform: `translateX(-${i}%)` };
  }, [e2.width]);
  return jsx("div", { className: cnBase("oui-absolute oui-right-[-100%] oui-top-0 oui-h-full oui-w-full oui-transition-transform oui-pointer-events-none", t === 0 && "oui-left-[-100%]", e2.className), style: o2 });
};
var Rr = (e2) => {
  let { cellHeight: t, showTotal: o2, onItemClick: i, depth: r3, pendingOrders: n4 } = Y(), { symbolInfo: a2, currentHover: s2, accumulated: c, accumulatedAmount: l2, count: d2, price: u2, quantity: m2, base: g2, quote: f2 } = e2, { base_dp: p2, quote_dp: S2 } = a2, [y2] = useLocalStorage(Ne2, g2), C2 = Number.isNaN(u2) ? 0 : c / d2 * 100, N2 = useMemo(() => _$3(r3 || `${S2}`), [r3, S2]), b2 = Number.isNaN(c) ? "-" : l2 == null ? void 0 : l2.toString(), w4 = useMemo(() => {
    let q2 = Ir$1(u2, { dp: N2, padding: true });
    return n4.some((x2) => q2 === Ir$1(x2, { dp: N2, padding: true }));
  }, [n4, u2, N2]);
  return jsxs("div", { className: "oui-relative oui-flex oui-cursor-pointer oui-flex-row oui-justify-between oui-pl-3 oui-text-xs oui-tabular-nums oui-text-base-contrast-80", style: { height: `${t}px` }, onClick: () => {
    Number.isNaN(u2) || Number.isNaN(m2) || (i == null ? void 0 : i([u2, m2]));
  }, onMouseEnter: e2.onMouseEnter, onMouseLeave: e2.onMouseLeave, children: [jsxs("div", { className: cnBase("oui-mr-2 oui-flex oui-basis-7/12 oui-flex-row oui-items-center", o2 && "oui-basis-5/12"), children: [jsx("div", { className: cnBase("oui-flex-1 oui-text-left", e2.type === "ask" ? "oui-text-trade-loss" : "oui-text-trade-profit"), children: jsx(Q$1.numeral, { dp: N2, children: u2 }) }), jsx("div", { className: "oui-flex-1 oui-text-right oui-text-base-contrast-80", children: jsx(Q$1.numeral, { dp: p2, children: m2 }) })] }), jsxs("div", { className: cnBase("oui-fex-row oui-relative oui-flex oui-basis-5/12 oui-items-center oui-justify-end oui-overflow-hidden", o2 && "oui-basis-7/12"), children: [o2 ? jsxs(Fragment$1, { children: [jsx("div", { className: cnBase("oui-flex-1 oui-pr-3 oui-text-right"), children: jsx(Q$1.numeral, { dp: p2, className: "oui-z-10", children: c }) }), jsx("div", { className: cnBase("oui-flex-1 oui-pr-3 oui-text-right"), children: jsx(Q$1.numeral, { dp: N2, className: "oui-z-10", children: b2 }) })] }) : jsxs("div", { className: cnBase("oui-flex-1 oui-pr-3 oui-text-right"), children: [y2 === g2 && jsx(Q$1.numeral, { dp: p2, className: "oui-z-10", children: c }), y2 === f2 && jsx(Q$1.numeral, { dp: N2, className: "oui-z-10", children: b2 })] }), jsx(Ft, { width: C2, direction: 0, className: e2.type === "ask" ? "oui-bg-trade-loss/10" : "oui-bg-trade-profit/10" })] }), w4 && jsx("div", { className: cnBase("oui-pointer-events-none oui-absolute oui-left-[4px] oui-size-[4px] oui-rounded-full", e2.type === "ask" && "oui-bg-trade-loss", e2.type === "bid" && "oui-bg-trade-profit"), style: { top: `${t / 2 - 2}px` } }), e2.isHover && jsx("div", { className: "oui-absolute oui-inset-0 oui-bg-white oui-opacity-[.12]" }), s2 && jsx("div", { className: cnBase("oui-absolute oui-inset-x-0", e2.type === "ask" && "oui-top-0", e2.type === "bid" && "oui-bottom-0"), children: jsx(de$5, { lineStyle: "dashed", className: cnBase("oui-w-full", e2.type === "bid" && "oui-border-trade-profit", e2.type === "ask" && "oui-border-trade-loss") }) })] });
};
var Bt = (e2) => {
  let { data: t, type: o2, countQty: i } = e2, { symbolInfo: r3, depth: n4 } = Y(), a2 = useCallback(() => {
    if (((t == null ? void 0 : t.length) || 0) === 0) return null;
    if (o2 === "ask") {
      let u2 = t.findIndex((m2) => !Number.isNaN(m2[0]));
      return u2 != -1 ? t[u2] : null;
    } else {
      for (let u2 = t.length - 1; u2 >= 0; u2--) {
        let m2 = t[u2];
        if (!Number.isNaN(m2[0])) return m2;
      }
      return null;
    }
  }, [t, o2]), s2 = useMemo(() => (n4 == null ? void 0 : n4.toString().includes(".")) ? n4.toString().split(".")[1].length : 0, [n4]), c = useMemo(() => t.reduce((u2, m2) => Math.max(u2, m2[1]), 0), [t]), [l2, d2] = useState(-1);
  return jsx("div", { className: "oui-order-book-list oui-flex oui-flex-col oui-gap-px", children: t.map((u2, m2) => jsx(El, { index: m2, item: u2, countQty: i, setHoverIndex: d2, hoverIndex: l2, type: o2, maxQty: c, priceDp: s2, symbolInfo: r3, findMaxItem: a2 }, m2)) });
}, El = (e2) => {
  let { index: t, item: o2, setHoverIndex: i, type: r3, maxQty: n4, hoverIndex: a2, priceDp: s2, countQty: c, symbolInfo: l2 } = e2, { base: d2, quote: u2, base_dp: m2, quote_dp: g2 } = l2, { t: f2 } = ne$6(), p2 = a2 !== -1 ? r3 === "ask" ? t >= a2 : t <= a2 : false, [S2, y2] = useState(false), C2 = (b2) => {
    if (b2 === null) return { sumQty: 0, sumQtyAmount: 0, avgPrice: 0 };
    let w4 = { sumQty: 0, sumQtyAmount: 0 };
    return Number.isNaN(b2[2]) || (w4 = { sumQty: b2[2], sumQtyAmount: b2[3] }), { ...w4, avgPrice: w4.sumQtyAmount == 0 ? 0 : w4.sumQtyAmount / w4.sumQty };
  }, N2 = useMemo(() => {
    let b2 = C2(o2);
    return b2.avgPrice === 0 ? C2(e2.findMaxItem()) : b2;
  }, [o2, e2]);
  return jsxs(ai$1, { open: S2, onOpenChange: y2, children: [jsx(ni$3, { children: jsx(Rr, { background: "", price: o2[0], quantity: o2[1], accumulated: o2[2], count: c, type: r3, accumulatedAmount: o2[3], maxQty: n4, isHover: p2, currentHover: a2 === t, symbolInfo: l2, base: d2, quote: u2, onMouseEnter: () => {
    i(t), y2(true);
  }, onMouseLeave: () => {
    i(-1), y2(false);
  } }) }), jsxs(Ao$5, { className: cnBase("oui-rounded-base oui-flex oui-w-full oui-max-w-[400px] oui-flex-col oui-gap-2 oui-bg-base-6 oui-p-3 oui-text-2xs oui-shadow-md"), align: r3 === "ask" ? "end" : "start", alignOffset: -25.4, side: "left", sideOffset: 2, onPointerEnter: (b2) => b2.preventDefault(), children: [jsx(Co, { title: `${f2("common.avgPrice")}`, content: N2.avgPrice, contentDp: s2 }), jsx(Co, { title: `${f2("trading.orderBook.sum")} (${d2})`, content: N2.sumQty, contentDp: m2 }), jsx(Co, { title: `${f2("trading.orderBook.sum")} (${u2})`, content: N2.sumQtyAmount, contentDp: g2 }), jsx(Lt$3, { className: "oui-fill-base-6", style: { transform: r3 === "ask" ? "translateX(80%)" : "translateX(-80%)" } })] })] });
}, Co = (e2) => {
  let { title: t, content: o2, contentDp: i } = e2;
  return jsxs("div", { className: "oui-flex oui-flex-row oui-justify-between oui-gap-4", children: [jsx("div", { className: "oui-text-base-contrast-36", children: t }), jsx("div", { className: "oui-text-right", children: jsx(Q$1.numeral, { dp: i, children: o2 }) })] });
};
var Ar = (e2) => {
  let { data: t } = e2, o2 = useMemo(() => {
    let i = Number.NaN, r3 = t.length, n4 = 0;
    for (; Number.isNaN(i) && n4 < r3; ) i = t[n4][2], n4++;
    return i;
  }, [t]);
  return jsx(Bt, { type: "ask", data: t, countQty: o2 });
};
var Mr = (e2) => {
  let { data: t } = e2, o2 = useMemo(() => {
    let i = Number.NaN, r3 = t.length - 1;
    for (; Number.isNaN(i) && r3 > 0; ) i = t[r3][2], r3--;
    return i;
  }, [t]);
  return jsx(Bt, { type: "bid", data: t, countQty: o2 });
};
var Hr = (e2) => {
  let t = useMemo(() => e2.depths.map((o2) => ({ value: o2, label: `${o2}` })), [e2.depths]);
  return jsx(W$2, { pl: 3, width: 97, className: "oui-py-[10px]", children: jsx(Be$6.options, { options: t, size: "xs", value: e2.value, onValueChange: (o2) => {
    var _a3;
    (_a3 = e2.onChange) == null ? void 0 : _a3.call(e2, o2);
  } }) });
};
var Zl = (e2) => {
  let { item: t, base: o2, onClick: i } = e2, { t: r3 } = ne$6(), [n4, a2] = useLocalStorage(Ne2, o2);
  return jsxs(z$3, { justify: "between", itemAlign: "center", className: cnBase("oui-w-full oui-px-2 oui-py-[3px]", "oui-cursor-pointer", "oui-text-xs", "oui-text-base-contrast-54", "hover:oui-bg-base-6", "oui-rounded-[3px]", "oui-transition-all", n4 === t && "oui-bg-base-5"), onClick: (s2) => {
    a2(t), i(s2);
  }, children: [r3("common.total"), "(", t, ")", jsx("div", { className: cnBase("oui-transition-all", "oui-w-1", "oui-h-1", "oui-rounded-full", "oui-bg-gradient-to-r", n4 === t && "oui-from-[rgb(var(--oui-gradient-brand-start))] oui-to-[rgb(var(--oui-gradient-brand-end))]") })] });
}, Wr = (e2) => {
  let { base: t, quote: o2 } = e2, { showTotal: i } = Y(), { t: r3 } = ne$6(), [n4, a2] = ze__default__default.useState(false), [s2] = useLocalStorage(Ne2, t), c = n4 ? vt$4 : oe$7;
  return jsxs(z$3, { pl: 3, justify: "between", className: "oui-py-[6px]", children: [jsxs(z$3, { gap: 1, className: cnBase("oui-basis-7/12", i && "oui-basis-1/2"), children: [jsx(W$2, { width: "100%", children: jsx(at, { id: "oui-order-book-header-price", className: "oui-text-base-contrast-36", children: `${r3("common.price")}(${o2})` }) }), jsx(W$2, { width: "100%", children: jsx(at, { justifyEnd: true, id: "oui-order-book-header-qty", className: "oui-text-base-contrast-36", children: `${r3("common.qty")}(${t})` }) })] }), jsx(z$3, { gap: 1, pr: 3, className: cnBase("oui-basis-5/12", i && "oui-basis-1/2"), children: i ? jsxs(Fragment$1, { children: [jsx(W$2, { className: "oui-text-base-contrast-36", width: "100%", children: jsx(at, { id: "oui-order-book-header-total-quote", justifyEnd: true, children: `${r3("common.total")}(${t})` }) }), jsx(W$2, { className: "oui-text-base-contrast-36", width: "100%", children: jsx(at, { justifyEnd: true, id: "oui-order-book-header-total-base", children: `${r3("common.total")}(${o2})` }) })] }) : jsx(W$2, { width: "100%", children: jsx(Bo$3, { open: n4, onOpenChange: a2, contentProps: { className: cnBase("oui-w-28 oui-p-1") }, content: jsx(z$3, { direction: "column", itemAlign: "start", className: cnBase("oui-w-full oui-gap-0.5"), children: [t, o2].map((l2) => jsx(Zl, { item: l2, base: t, onClick: () => a2(false) }, `type-${l2}`)) }), children: jsxs(z$3, { justify: "end", itemAlign: "center", className: "oui-cursor-pointer oui-select-none oui-text-base-contrast-36 oui-transition-all hover:oui-text-base-contrast", children: [jsx(at, { justifyEnd: true, id: "oui-order-book-header-total-base", children: `${r3("common.total")}(${s2})` }), jsx(c, { color: "inherit", className: "oui-size-4 oui-text-3xs" })] }) }) }) })] });
}, at = (e2) => {
  let { children: t, className: o2, justifyEnd: i = false } = e2;
  return jsx(z$3, { id: e2.id, className: cnBase(o2, "oui-items-end oui-text-xs", i && "oui-justify-end"), children: t });
};
var Ot = (e2) => {
  let { markPrice: t = 0, lastPrice: o2, quote_dp: i, className: r3, iconSize: n4 = 18 } = e2, [a2, s2] = o2, c = s2 < a2, l2 = s2 > a2;
  return jsxs(z$3, { gap: 1, className: cnBase(l2 ? "oui-text-trade-profit" : c ? "oui-text-trade-loss" : "", r3), children: [jsx(Q$1.numeral, { dp: i, intensity: 98, children: s2 }), jsxs(W$2, { width: 19, children: [c && jsx(Hn, { size: n4, color: "danger", opacity: 1 }), l2 && jsx(On, { size: n4, color: "success", opacity: 1 })] })] });
};
var Rt = (e2) => {
  let { isMobile: t } = it$6();
  return t ? jsx(cu, { ...e2 }) : jsx(uu, { ...e2 });
}, uu = (e2) => {
  let { quote_dp: t, className: o2, iconSize: i = 18 } = e2, { t: r3 } = ne$6();
  return jsx(xs, { content: r3("trading.orderBook.markPrice.tooltip"), className: "oui-max-w-[270px]", children: jsxs(z$3, { gap: 1, className: cnBase("oui-cursor-pointer oui-text-2xs", o2), children: [jsx($r, { size: i }), jsx(Q$1.numeral, { dp: t, color: "warning", className: "oui-underline oui-text-base oui-decoration-dashed oui-decoration-1 oui-underline-offset-4 oui-decoration-warning-darken", children: e2.markPrice })] }) });
}, cu = (e2) => {
  let { quote_dp: t, className: o2, iconSize: i = 18 } = e2, [r3, n4] = useState(false), { t: a2 } = ne$6();
  return jsxs(Fragment$1, { children: [jsxs(z$3, { gap: 1, className: cnBase("oui-cursor-pointer oui-text-2xs", o2), onClick: () => {
    n4(true);
  }, children: [jsx($r, { size: i }), jsx(Q$1.numeral, { dp: t, color: "warning", className: "oui-underline oui-decoration-dashed oui-decoration-1 oui-underline-offset-4 oui-decoration-warning-darken", children: e2.markPrice })] }), jsx(Se$5, { size: "xs", open: r3, onOpenChange: n4, title: a2("common.tips"), actions: { primary: { label: a2("common.ok"), onClick: () => n4(false) } }, children: jsx(Q$1, { children: a2("trading.orderBook.markPrice.tooltip") }) })] });
}, $r = (e2) => jsx("svg", { width: e2.size, height: e2.size, viewBox: "0 0 18 18", fill: "currenColor", xmlns: "http://www.w3.org/2000/svg", className: "oui-fill-warning-darken", children: jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M3.75 1.5a.75.75 0 0 1 .75.75h6a.75.75 0 0 1 .75.75v1.5h3a.75.75 0 0 1 .75.75V12a.75.75 0 0 1-.75.75H7.5a.75.75 0 0 1-.75-.75v-1.5H4.5v5.25a.75.75 0 0 1-1.5 0V2.25a.75.75 0 0 1 .75-.75M4.5 9h5.25V3.75H4.5zm6.75-3v3.75a.75.75 0 0 1-.75.75H8.25v.75h5.25V6z" }) });
var Xr = (e2) => {
  let { markPrice: t = 0, lastPrice: o2, asks: i, bids: r3, symbolInfo: n4 } = e2, { showTotal: a2 } = Y();
  return jsxs("div", { className: "oui-flex oui-flex-row oui-pl-3 oui-tabular-nums oui-justify-between oui-text-base-contrast-80 oui-text-xs oui-relative oui-cursor-pointer oui-py-[6px]", children: [jsxs("div", { className: cnBase("oui-basis-7/12 oui-flex oui-flex-row oui-items-center oui-mr-2 oui-justify-between", a2 && "oui-basis-5/12"), children: [jsx(Ot, { markPrice: t, lastPrice: o2, quote_dp: n4.quote_dp, className: "oui-text-base" }), jsx(Rt, { markPrice: t, quote_dp: n4.quote_dp })] }), jsx("div", { className: cnBase("oui-basis-5/12 oui-flex oui-items-center oui-fex-row oui-overflow-hidden oui-relative oui-justify-end", a2 && "oui-basis-7/12", "oui-pr-3"), children: jsx(hu, { asks: i, bids: r3 }) })] });
}, hu = (e2) => {
  let { asks: t, bids: o2 } = e2, { t: i } = ne$6(), r3 = useMemo(() => {
    if (o2.length === 0 && t.length === 0) return 0;
    let n4 = Number.isNaN(o2[0][0]) ? 0 : o2[0][0], a2 = t.reverse().findIndex((l2) => !Number.isNaN(l2[0])), s2 = 0;
    a2 !== -1 && (s2 = Number.isNaN(t[a2][0]) ? 0 : t[a2][0]);
    let c = new g$6(s2).sub(n4).div(new g$6(s2).add(n4).div(2));
    return Math.ceil(c.toNumber() * 1e6 + 0.1) / 1e4;
  }, [t, o2]);
  return jsx("div", { children: jsx(xs, { content: i("trading.orderBook.spreadRatio.tooltip"), className: "oui-max-w-[240px]", children: jsx(Q$1, { size: "2xs", intensity: 36, className: "oui-cursor-pointer oui-underline oui-decoration-dashed oui-decoration-1 oui-underline-offset-4 oui-decoration-base-contrast-36", children: `${r3}%` }) }) });
};
var Jr = (e2) => {
  let { lastPrice: t, markPrice: o2, quote: i, base: r3, isLoading: n4, onDepthChange: a2 } = e2, s2 = useRef(null), [c, l2] = useState(false), [d2, u2] = useLocalStorage(Ne2, r3);
  return useEffect(() => {
    d2 !== i && r3 && u2(r3);
  }, [r3, i]), useEffect(() => {
    let m2 = new ResizeObserver((f2) => {
      for (let p2 of f2) {
        let { inlineSize: S2 } = p2.borderBoxSize[0];
        l2(S2 >= 360);
      }
    }), g2 = s2.current;
    return g2 && m2.observe(g2), () => {
      g2 && m2.unobserve(g2);
    };
  }, []), jsx(Lt, { cellHeight: e2.cellHeight ?? 20, onItemClick: e2.onItemClick, depth: e2.activeDepth, showTotal: c, pendingOrders: e2.pendingOrders || [], symbolInfo: e2.symbolInfo, children: jsxs(Sa$1, { cols: 1, rows: 5, id: "oui-orderbook-desktop", ref: s2, className: "oui-relative oui-size-full oui-grid-rows-[auto,auto,1fr,auto,1fr]", children: [jsx(Hr, { depths: e2.depths, value: e2.activeDepth, onChange: a2 }), jsx(Wr, { quote: i, base: r3 }), jsx(Ar, { data: [...e2.asks] }), jsx(Xr, { lastPrice: t, markPrice: o2, asks: [...e2.asks], bids: [...e2.bids], symbolInfo: e2.symbolInfo }), jsx(Mr, { data: [...e2.bids] }), n4 && jsx("div", { className: "oui-bg-bg-8/70 oui-absolute oui-inset-0 oui-z-10 oui-flex oui-items-center oui-justify-center", children: jsx(Ie$4, {}) })] }) });
};
var en = (e2) => {
  let { t } = ne$6(), { mode: o2, onModeChange: i } = Y(), r3 = useMemo(() => o2 === "amount" ? e2.quote : e2.base, [o2, e2.quote, e2.base]), n4 = useMemo(() => t(o2 === "amount" ? "trading.orderBook.column.value" : "common.qty"), [o2, t]);
  return jsxs(z$3, { justify: "between", width: "100%", className: "oui-text-base-contrast-36 oui-text-2xs oui-py-[5px]", children: [jsxs(z$3, { direction: "column", itemAlign: "start", id: "oui-order-book-header-price", children: [jsx(Q$1, { children: t("common.price") }), jsx(Q$1, { children: `(${e2.quote})` })] }), jsxs(z$3, { direction: "column", itemAlign: "end", className: "oui-cursor-pointer", onClick: () => i == null ? void 0 : i(o2 === "amount" ? "quantity" : "amount"), children: [jsx(Q$1, { children: n4 }), jsx(Q$1, { children: `(${r3})` })] })] });
};
var rn = (e2) => {
  let t = e2.accumulated / e2.count * 100, { cellHeight: o2, onItemClick: i, depth: r3, showTotal: n4, symbolInfo: a2 } = useContext(Dt), { base_dp: s2, quote_dp: c } = a2, l2 = Number.isNaN(e2.quantity) ? "-" : e2.mode === "amount" ? new g$6(e2.quantity).mul(e2.price).toString() : e2.quantity;
  n4 && (l2 = e2.quantity);
  let d2 = useMemo(() => _$3(r3 || `${c}`), [r3, c]);
  return jsxs(W$2, { className: cnBase("oui-overflow-hidden oui-relative oui-cursor-pointer oui-tabular-nums oui-text-2xs oui-w-full", n4 && "oui-flex-1"), style: { height: `${o2}px` }, onClick: (u2) => {
    Number.isNaN(e2.price) || Number.isNaN(e2.quantity) || (i == null ? void 0 : i([e2.price, e2.quantity]));
  }, children: [jsxs(z$3, { justify: "between", children: [jsx(Q$1.numeral, { color: e2.type === "bid" ? "buy" : "sell", dp: d2, children: e2.price }), jsx(Q$1.numeral, { dp: e2.mode === "amount" ? 2 : s2, className: "oui-text-base-contrast-80", children: l2 })] }), Number.isNaN(t) || n4 ? null : jsx(Ft, { width: t, className: e2.type === "ask" ? "oui-bg-trade-loss/20" : "oui-bg-trade-profit/20" })] });
};
var Mt2 = (e2) => {
  let { data: t } = e2, { mode: o2 } = Y();
  return jsx(W$2, { className: "oui-order-book-list oui-flex oui-flex-col oui-gap-[1px] oui-w-full", children: t.map((i, r3) => jsx(rn, { background: "", price: i[0], quantity: i[1], accumulated: i[2], count: e2.countQty, type: e2.type, mode: o2 }, r3)) });
};
var an = (e2) => {
  let { data: t } = e2, o2 = useMemo(() => {
    let i = Number.NaN, r3 = t.length - 1;
    for (; Number.isNaN(i) && r3 > 0; ) i = t[r3][2], r3--;
    return i;
  }, [t]);
  return jsx(Mt2, { type: "bid", data: t, countQty: o2 });
};
var sn = (e2) => {
  let { data: t } = e2, o2 = useMemo(() => {
    let i = Number.NaN, r3 = t.length, n4 = 0;
    for (; Number.isNaN(i) && n4 < r3; ) i = t[n4][2], n4++;
    return i;
  }, [t]);
  return jsx(Mt2, { type: "ask", data: t, countQty: o2 });
};
var un = (e2) => {
  let { symbolInfo: t } = Y(), { quote_dp: o2 } = t;
  return jsxs(z$3, { id: "oui-order-book-mark-price", className: "oui-py-[6px]", width: "100%", justify: "between", children: [jsx(Ot, { markPrice: e2.markPrice, lastPrice: e2.lastPrice, quote_dp: o2, className: "oui-text-sm", iconSize: 14 }), jsx(Rt, { markPrice: e2.markPrice, quote_dp: o2, className: "oui-text-2xs", iconSize: 12 })] });
};
var dn = (e2) => {
  let t = useMemo(() => e2.depth.map((o2) => ({ value: o2, label: `${o2}` })), [e2.depth]);
  return jsx(W$2, { id: "oui-order-book-depth", className: "oui-pt-2  oui-w-full", children: jsx(Oi$2, { options: t, fullWidth: true, size: "sm", value: e2.value, className: "oui-text-2xs oui-text-base-contrast-54", onValueChange: (o2) => {
    var _a3;
    (_a3 = e2.onChange) == null ? void 0 : _a3.call(e2, o2);
  } }) });
};
var Fo = (e2) => {
  let t = e2.data.est_funding_rate, o2 = e2.data.countDown, { t: i } = ne$6();
  return jsxs(z$3, { direction: "column", itemAlign: "start", pb: 2, children: [jsx(Q$1, { intensity: 36, size: "2xs", children: i("trading.fundingRate.predFundingRate") }), t === null ? "--" : jsxs("div", { className: "orderly-flex orderly-gap-1 oui-text-2xs oui-text-base-contrast-36", children: [jsx(Q$1.numeral, { coloring: true, suffix: "%", dp: 4, children: t ?? "--" }), jsx("span", { children: " in" }), jsx("span", { children: " " + o2 })] })] });
};
var Bo = (e2) => ({ data: useFundingRate(e2) });
var Oo = (e2) => {
  let t = Bo(e2.symbol);
  return jsx(Fo, { ...t });
};
var fn = (e2) => {
  let { lastPrice: t, markPrice: o2, quote: i, base: r3, isLoading: n4, onDepthChange: a2 } = e2, s2 = `PERP_${e2.symbolInfo.base}_${e2.symbolInfo.quote}`;
  return jsx(Lt, { cellHeight: e2.cellHeight ?? 20, onItemClick: e2.onItemClick, depth: e2.activeDepth, pendingOrders: [], showTotal: false, symbolInfo: e2.symbolInfo, children: jsxs(z$3, { direction: "column", p: 2, id: "oui-orderbook-mobile", className: cnBase("oui-h-full oui-wfull oui-relative", e2.className), justify: "start", itemAlign: "start", children: [jsx(Oo, { symbol: s2 }), jsx(en, { quote: i, base: r3 }), jsx(sn, { data: e2.asks }), jsx(un, { lastPrice: t, markPrice: o2 }), jsx(an, { data: e2.bids }), jsx(dn, { depth: e2.depths || [], value: e2.activeDepth, onChange: a2 }), n4 && jsx("div", { className: "oui-absolute oui-left-0 oui-top-0 oui-right-0 oui-bottom-0 oui-z-10 oui-flex oui-items-center oui-justify-center oui-bg-base-800/70 oui-h-full oui-min-h-[420px]", children: jsx(Ie$4, {}) })] }) });
};
var Io = (e2) => jsx(W$2, { className: "oui-font-semibold", width: "100%", height: "100%", children: e2.isMobile ? jsx(fn, { level: e2.level, asks: e2.asks, bids: e2.bids, markPrice: e2.markPrice, lastPrice: e2.lastPrice, depths: e2.depths, activeDepth: e2.selDepth, base: e2.base, quote: e2.quote, isLoading: e2.isLoading, onItemClick: e2.onItemClick, cellHeight: e2.cellHeight, onDepthChange: e2.onDepthChange, className: e2.className, symbolInfo: e2.symbolInfo }) : jsx(Jr, { level: e2.level, asks: e2.asks, bids: e2.bids, markPrice: e2.markPrice, lastPrice: e2.lastPrice, depths: e2.depths, activeDepth: e2.selDepth, base: e2.base, quote: e2.quote, isLoading: e2.isLoading, onItemClick: e2.onItemClick, cellHeight: e2.cellHeight, onDepthChange: e2.onDepthChange, className: e2.className, pendingOrders: e2.pendingOrders, symbolInfo: e2.symbolInfo }) });
var lt = 20, bn = 104, Mo = (e2) => {
  let { symbol: t, height: o2 } = e2, i = useSymbolsInfo()[e2.symbol], [r3, n4] = useState(lt), [a2, s2] = useState(10), { base: c, quote: l2, quote_dp: d2 } = et(i), [u2, { onDepthChange: m2, isLoading: g2, onItemClick: f2, depth: p2, allDepths: S2 }] = useOrderbookStream(t, void 0, { level: a2 }), y2 = oc(t);
  useEffect(() => {
    if (o2) {
      let w4 = Math.floor((o2 - bn) / ((lt + 1) * 2)), q2 = (lt + 1) * 2 * w4, x2 = o2 - bn - q2;
      x2 > 10 ? n4(lt + x2 / w4 / 2) : n4(lt), s2(w4);
    }
  }, [o2]);
  let C2 = useMemo(() => typeof p2 > "u" || typeof d2 > "u" ? void 0 : I$6(p2), [p2, d2]), N2 = useMemo(() => (S2 == null ? void 0 : S2.map((w4) => I$6(w4))) || [], [S2, d2]), { isMobile: b2 } = it$6();
  return { level: a2, asks: u2 == null ? void 0 : u2.asks, bids: u2 == null ? void 0 : u2.bids, markPrice: u2 == null ? void 0 : u2.markPrice, lastPrice: u2 == null ? void 0 : u2.middlePrice, depths: N2, selDepth: C2, base: c, quote: l2, isLoading: g2, onItemClick: f2, cellHeight: r3, onDepthChange: m2, pendingOrders: y2, symbolInfo: et(i), isMobile: b2 };
}, oc = (e2) => {
  let [t] = useOrderStream({ status: OrderStatus.INCOMPLETE, symbol: e2 });
  return useMemo(() => t == null ? void 0 : t.filter((r3) => r3.symbol === e2).reduce((r3, n4) => {
    let a2 = n4.price || n4.trigger_price || 0;
    return [...r3, a2];
  }, []), [t, e2]);
};
var We2 = (e2) => {
  let t = Mo({ symbol: e2.symbol, height: e2.height });
  return jsx(Io, { ...t, className: e2.className });
};
var Ho = (e2) => {
  let { riskRate: t, riskRateColor: o2, isConnected: i, currentLeverage: r3, maxLeverage: n4 } = e2, { isHigh: a2, isMedium: s2, isLow: c, isDefault: l2 } = o2, { wrongNetwork: d2 } = L$3(), { t: u2 } = ne$6(), m2 = d2 ? "" : a2 ? "oui-text-danger" : s2 ? "oui-text-warning-darken" : c ? jn$2({ color: "brand" }) : "";
  return jsxs(W$2, { "data-risk": "", className: "oui-space-y-2", children: [jsx(z$3, { itemAlign: "center", justify: "start", className: "oui-w-full oui-bg-base-6 oui-rounded-full oui-h-2 oui-px-[1px]", children: jsx(W$2, { className: d2 ? "oui-bg-gradient-to-r oui-opacity-20 oui-from-[#26fefe]  oui-via-[#ff7d00] oui-to-[#d92d6b] oui-h-1.5 oui-rounded-full" : a2 ? "oui-bg-gradient-to-tr oui-from-[#791438] oui-to-[#ff447c] oui-h-1.5 oui-rounded-full" : s2 ? "oui-bg-gradient-to-tr oui-from-[#792e00] oui-to-[#ffb65d] oui-h-1.5 oui-rounded-full" : c ? "oui-bg-gradient-to-tr oui-from-[#59b0fe] oui-to-[#26fefe] oui-h-1.5 oui-rounded-full" : "oui-bg-gradient-to-r oui-opacity-20 oui-from-[#26fefe]  oui-via-[#ff7d00] oui-to-[#d92d6b] oui-h-1.5 oui-rounded-full", style: t && t !== "--" ? { width: t } : { width: "100%" } }) }), jsxs(z$3, { className: "oui-gap-2", justify: "between", children: [jsxs(z$3, { direction: "column", children: [jsx(xs, { content: jsx(po, { description: u2("trading.riskRate.tooltip"), formula: u2("trading.riskRate.formula") }), children: jsx(Q$1, { size: "2xs", color: "neutral", weight: "semibold", className: cnBase("oui-cursor-pointer", "oui-border-b oui-border-dashed oui-border-b-white/10"), children: u2("trading.riskRate") }) }), jsx(Q$1, { size: "xs", color: "neutral", weight: "semibold", className: cnBase(m2), children: t ?? "--" })] }), jsxs(z$3, { direction: "column", children: [jsx(Q$1, { size: "2xs", color: "neutral", weight: "semibold", className: cnBase("oui-cursor-pointer", "oui-border-b oui-border-b-transparent"), children: u2("leverage.maxAccountLeverage") }), jsxs(z$3, { className: "oui-gap-1", children: [jsx(Q$1.numeral, { dp: 2, padding: false, suffix: r3 ? "x" : void 0, children: r3 ?? "--" }), jsx("span", { className: "oui-text-base-contrast-54", children: "/" }), jsxs("button", { className: "oui-flex oui-items-center oui-gap-1", onClick: () => {
    vo$4.show(re$3, { currentLeverage: 5 });
  }, "data-testid": "oui-testid-riskRate-leverage-button", children: [jsx(Q$1.numeral, { dp: 2, padding: false, suffix: n4 ? "x" : void 0, "data-testid": "oui-testid-riskRate-leverage-value", children: n4 ?? "--" }), typeof n4 < "u" && n4 !== null && jsx(Rn$1, { size: 12, color: "white" })] })] })] })] })] });
};
var fc = (e2) => {
  if (e2 === null) return { isHigh: false, isMedium: false, isLow: false, isDefault: true };
  let t = e2 < 40, o2 = e2 >= 40 && e2 < 80, i = e2 >= 80;
  return { isHigh: i, isMedium: o2, isLow: t, isDefault: !t && !o2 && !i };
}, wn = () => {
  let { state: e2 } = useAccount(), t = e2.status >= AccountStatusEnum.EnableTrading || e2.status === AccountStatusEnum.EnableTradingWithoutConnected, { marginRatio: o2, currentLeverage: i, mmr: r3 } = useMarginRatio(), { maxLeverage: n4 } = useLeverage(), a2 = useMemo(() => !t || o2 === null || r3 === null ? "--" : o2 === 0 || r3 === 0 ? "0%" : `${new g$6(r3).div(o2).mul(100).todp(2, g$6.ROUND_UP).toString().replace(/\.?0+$/, "")}%`, [t, o2, r3]), s2 = a2 === "--" ? null : parseFloat(a2), c = useMemo(() => fc(s2), [s2]), l2 = Tr$2(i), d2 = Tr$2(n4);
  return { riskRate: Tr$2(a2), riskRateColor: c, isConnected: t, currentLeverage: l2, maxLeverage: d2 };
};
var zo = () => {
  let e2 = wn();
  return jsx(Ho, { ...e2 });
};
var Wo = (e2) => {
  var _a3;
  return jsx("div", { ref: e2.containerRef, className: "oui-h-full", children: (((_a3 = e2.containerSize) == null ? void 0 : _a3.width) || 0) >= 572 ? jsx(Cc, { ...e2 }) : jsx(wc, { ...e2 }) });
}, Cc = (e2) => {
  var _a3;
  let { t } = ne$6();
  return jsxs(Sa$1, { cols: 2, width: "100%", gap: 3, className: "oui-auto-rows-fr", style: { height: (_a3 = e2.containerSize) == null ? void 0 : _a3.height }, children: [jsxs(z$3, { direction: "column", itemAlign: "start", pt: 3, pb: 3, r: "2xl", className: "oui-bg-base-9", children: [jsx(Pn, { title: t("trading.orderBook"), className: "oui-pl-3 oui-text-sm" }), jsx(We2, { symbol: e2.symbol, height: e2.containerSize ? e2.containerSize.height - 29 - 24 : void 0 })] }), jsxs(z$3, { direction: "column", itemAlign: "start", py: 3, r: "2xl", className: "oui-bg-base-9 oui-h-full", children: [jsx(Pn, { title: t("trading.lastTrades"), className: "oui-text-sm oui-px-3" }), jsx(Me2, { symbol: e2.symbol, style: { height: e2.containerSize && e2.containerSize.height - 29 - 24 }, classNames: { listHeader: "oui-px-3", list: "oui-px-3" } })] })] });
}, wc = (e2) => {
  var _a3;
  let { t } = ne$6();
  return jsx(W$2, { pt: 3, pb: 3, pr: 0, r: "2xl", className: "oui-bg-base-9", style: { maxHeight: (_a3 = e2.containerSize) == null ? void 0 : _a3.height }, children: jsxs(jl, { value: e2.tab, variant: "contained", onValueChange: (o2) => {
    e2.setTab(o2);
  }, classNames: { tabsList: "oui-pl-3" }, size: "lg", children: [jsx($l, { value: "orderBook", title: t("trading.orderBook"), children: jsx(We2, { symbol: e2.symbol, height: e2.containerSize ? e2.containerSize.height - 29 - 18 : void 0 }) }), jsx($l, { value: "lastTrades", title: t("trading.lastTrades"), children: jsx(Me2, { symbol: e2.symbol, style: { height: e2.containerSize && e2.containerSize.height - 29 - 18 }, classNames: { root: "oui-pt-[6px]", listHeader: "oui-px-3", list: "oui-px-3" } }) })] }) });
}, Pn = (e2) => jsx(Q$1, { size: "base", intensity: 80, className: cnBase("oui-pb-[5px]", e2.className), children: e2.title });
var Vo = (e2) => {
  let [t, o2] = useState(void 0), [i, r3] = useState("orderBook"), n4 = useRef();
  return useEffect(() => {
    let a2 = new ResizeObserver((c) => {
      for (let l2 of c) {
        let { width: d2, height: u2 } = l2.contentRect;
        o2({ width: d2, height: u2 });
      }
    }), s2 = n4.current;
    return s2 && a2.observe(s2), () => {
      s2 && a2.unobserve(s2);
    };
  }, []), { symbol: e2, containerSize: t, containerRef: n4, tab: i, setTab: r3 };
};
var qo = (e2) => {
  let t = Vo(e2.symbol);
  return jsx(Wo, { ...t });
};
var Bn = (e2) => {
  let { onMouseDown: t, mode: o2 = "horizontal", ...i } = e2, r3 = useMemo(() => {
    var _a3;
    return (_a3 = e2.className) == null ? void 0 : _a3.split(" ").includes("disable");
  }, [e2.className]), n4 = useMemo(() => {
    var _a3;
    return (_a3 = e2.className) == null ? void 0 : _a3.split(" ").filter((a2) => a2 !== "disable");
  }, [e2.className]);
  return jsx("div", { ...i, className: cnBase(n4, "!oui-transition-none", "!oui-shadow-none !oui-bg-transparent", "hover:!oui-bg-primary-light hover:!oui-shadow-[0px_0px_4px_0px] hover:!oui-shadow-primary-light/80", "active:!oui-bg-primary-light active:!oui-shadow-[0px_0px_4px_0px] active:!oui-shadow-primary-light/80", "focus:!oui-bg-primary-light focus:!oui-shadow-[0px_0px_4px_0px] focus:!oui-shadow-primary-light/80", o2 === "horizontal" ? "!oui-w-[2px] !oui-min-w-[2px]  !oui-mx-1" : "!oui-h-[2px] !oui-min-h-[2px]  !oui-my-1", r3 && "oui-pointer-events-none"), children: jsx("div", { onMouseDown: t, className: cnBase("!oui-transition-none", o2 === "horizontal" ? "after:!oui-w-[2px]" : "after:!oui-h-[2px]", "after:!oui-bg-transparent after:!oui-shadow-transparent") }) });
};
var qe2 = forwardRef((e2, t) => {
  let { onSizeChange: o2, ...i } = e2;
  return jsx(Split, { ref: t, ...i, lineBar: true, renderBar: (r3) => jsx(Bn, { ...r3, mode: e2.mode }), onDragEnd: (r3, n4, a2) => {
    o2 == null ? void 0 : o2(`${n4}`);
  } });
});
var Rn = () => jsxs("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", className: "oui-rounded-full", children: [jsxs("g", { clipPath: "url(#a)", children: [jsx("path", { d: "m31.002 14.493-8.326-22.51L.166.31l8.327 22.51z", fill: "#03435D" }), jsx("path", { d: "m4.456-8.716-18.03 15.84 15.84 18.03 18.03-15.84z", fill: "#157CF2" }), jsx("path", { d: "m17.548 38.67 22.825-7.416-7.416-22.825-22.826 7.416z", fill: "#F3E200" })] }), jsx("defs", { children: jsx("clipPath", { id: "a", children: jsx("rect", { width: "24", height: "24", rx: "12", fill: "#fff" }) }) })] }), In = () => jsx("svg", { width: "20", height: "20", viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: jsx("path", { d: "M5.832 2.492A3.333 3.333 0 0 0 2.5 5.826v5a3.333 3.333 0 0 0 3.333 3.333 3.333 3.333 0 0 0 3.334 3.333h5a3.333 3.333 0 0 0 3.333-3.333v-5a3.333 3.333 0 0 0-3.333-3.333 3.333 3.333 0 0 0-3.334-3.334zm8.334 5c.92 0 1.666.746 1.666 1.667v5c0 .92-.746 1.666-1.666 1.666h-5c-.92 0-1.667-.745-1.667-1.666h3.333a3.333 3.333 0 0 0 3.334-3.334z", fill: "rgb(var(--oui-color-primary))" }) }), Go = (e2) => {
  let { size: t = 20 } = e2;
  return jsxs("svg", { width: t, height: t, viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsxs("g", { clipPath: "url(#a)", children: [jsx("path", { d: "M10 20c5.542 0 10-4.458 10-10S15.542 0 10 0 0 4.458 0 10s4.458 10 10 10", fill: "#2775CA" }), jsx("path", { d: "M13 11.473c0-1.452-.94-1.95-2.82-2.158-1.344-.166-1.613-.498-1.613-1.078s.448-.955 1.343-.955c.806 0 1.254.25 1.478.872.045.124.18.207.313.207h.717c.179 0 .313-.125.313-.29v-.042c-.179-.913-.985-1.618-2.015-1.701v-.996c0-.166-.134-.29-.358-.332h-.671c-.18 0-.314.124-.359.332v.954c-1.343.166-2.194.996-2.194 2.034 0 1.369.896 1.908 2.776 2.116 1.254.207 1.657.456 1.657 1.12s-.627 1.12-1.477 1.12c-1.165 0-1.568-.456-1.702-1.078a.32.32 0 0 0-.313-.25h-.762c-.179 0-.313.125-.313.291v.042c.179 1.037.895 1.784 2.373 1.991v.996c0 .166.134.29.358.332h.672c.18 0 .313-.124.358-.332v-.996C12.105 13.465 13 12.593 13 11.473", fill: "#fff", fillOpacity: ".98" }), jsx("path", { d: "M7.74 16.57c-3.458-1.215-5.23-4.986-3.945-8.324.665-1.821 2.127-3.208 3.944-3.859.178-.086.266-.216.266-.433v-.607c0-.174-.088-.304-.266-.347-.044 0-.133 0-.177.043-4.21 1.3-6.516 5.68-5.186 9.798.798 2.428 2.704 4.292 5.186 5.072.177.087.355 0 .399-.173.044-.043.044-.087.044-.173v-.608c0-.13-.133-.303-.266-.39m4.698-13.527c-.178-.086-.355 0-.4.174-.043.043-.043.086-.043.173v.607c0 .174.133.347.266.434 3.457 1.213 5.23 4.985 3.944 8.323-.664 1.821-2.127 3.209-3.944 3.859-.178.086-.266.216-.266.433v.607c0 .174.088.304.266.347.044 0 .133 0 .177-.043 4.21-1.3 6.515-5.68 5.186-9.798-.798-2.471-2.748-4.335-5.186-5.116", fill: "#fff" })] }), jsx("defs", { children: jsx("clipPath", { id: "a", children: jsx("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })] });
}, An = (e2) => {
  let { size: t = 20 } = e2;
  return jsxs("svg", { width: "20", height: "20", viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsxs("g", { clipPath: "url(#clip0_6403_64483)", children: [jsx("path", { d: "M10.0245 19.9493C15.5198 19.9493 19.9747 15.4944 19.9747 9.99908C19.9747 4.50371 15.5198 0.0488281 10.0245 0.0488281C4.5291 0.0488281 0.0742188 4.50371 0.0742188 9.99908C0.0742188 15.4944 4.5291 19.9493 10.0245 19.9493Z", fill: "url(#paint0_linear_6403_64483)" }), jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M14.1553 4.89304C14.2199 4.94541 14.1821 5.04758 14.0989 5.04758H5.95035C5.86716 5.04758 5.82936 4.94541 5.894 4.89304C7.0223 3.97912 8.45953 3.43164 10.0246 3.43164C11.5898 3.43164 13.0269 3.97912 14.1553 4.89304Z", fill: "white" }), jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M7.47013 11.7869C7.42315 11.7199 7.34748 11.6777 7.26565 11.6777H3.82985C3.75113 11.6777 3.69375 11.7525 3.71563 11.8281C4.5078 14.565 7.0326 16.566 10.0247 16.566C13.017 16.566 15.5417 14.565 16.3339 11.8281C16.3558 11.7525 16.2984 11.6777 16.2197 11.6777H12.7839C12.702 11.6777 12.6264 11.7199 12.5795 11.7869C12.0155 12.5911 11.0815 13.1167 10.0248 13.1167C8.96803 13.1167 8.03406 12.5911 7.47013 11.7869Z", fill: "white" }), jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12.3347 7.90519C12.3822 7.95756 12.449 7.9891 12.5196 7.9891H16.1137C16.1952 7.9891 16.253 7.90983 16.2261 7.83301C15.9724 7.10689 15.5948 6.43893 15.1187 5.85447C15.074 5.79961 15.0067 5.76855 14.9358 5.76855H5.11323C5.04247 5.76855 4.97512 5.79961 4.93044 5.85447C4.45429 6.43893 4.0767 7.10689 3.82306 7.83301C3.79622 7.90983 3.85398 7.9891 3.93536 7.9891H7.52952C7.60022 7.9891 7.66694 7.95756 7.71445 7.90519C8.28491 7.2763 9.10861 6.88136 10.0246 6.88136C10.9405 6.88136 11.7643 7.2763 12.3347 7.90519Z", fill: "white" }), jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M13.1164 10.9586C13.0553 10.9586 13.0118 10.899 13.0284 10.8401C13.1033 10.5722 13.1433 10.2898 13.1433 9.9981C13.1433 9.58758 13.064 9.19556 12.9199 8.83657C12.8954 8.77581 12.9392 8.70801 13.0046 8.70801H16.392C16.4349 8.70801 16.472 8.73831 16.4799 8.78052C16.5538 9.17511 16.5925 9.58216 16.5925 9.9982C16.5925 10.2978 16.5724 10.5926 16.5337 10.8815C16.5277 10.9258 16.4897 10.9586 16.4451 10.9586H13.1164ZM7.02223 10.8401C7.03868 10.899 6.99532 10.9586 6.93421 10.9586H3.60551C3.56084 10.9586 3.52285 10.9258 3.5169 10.8815C3.47807 10.5926 3.45801 10.2978 3.45801 9.9982C3.45801 9.58216 3.4967 9.17511 3.57069 8.78052C3.57859 8.73831 3.61563 8.70801 3.65856 8.70801H7.04593C7.11141 8.70801 7.15516 8.77581 7.13076 8.83657C6.98657 9.19556 6.90722 9.58758 6.90722 9.9981C6.90722 10.2898 6.94728 10.5722 7.02223 10.8401Z", fill: "white" })] }), jsxs("defs", { children: [jsxs("linearGradient", { id: "paint0_linear_6403_64483", x1: "10.0245", y1: "0.0488561", x2: "10.0245", y2: "19.9493", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "#C750FF" }), jsx("stop", { offset: "1", stopColor: "#5800E8" })] }), jsx("clipPath", { id: "clip0_6403_64483", children: jsx("rect", { width: "20", height: "20", fill: "white" }) })] })] });
};
var Qo = (e2) => {
  let { t } = ne$6();
  return jsxs(z$3, { direction: "column", gap: 4, children: [jsx(Dc, { ...e2 }), jsx(Lc, { ...e2 }), jsx(Fc, { ...e2 }), jsxs(z$3, { gap: 3, width: "100%", justify: "center", children: [e2.showGetTestUSDC && jsx($e$6, { variant: "outlined", size: "md", onClick: e2.onGetTestUSDC, fullWidth: true, loading: e2.gettingTestUSDC, className: "oui-border-primary-light oui-text-primary-light", children: t("trading.faucet.getTestUSDC") }), jsx($e$6, { variant: "outlined", color: "danger", size: "md", onClick: e2.onDisconnect, className: e2.showGetTestUSDC ? "oui-w-full" : "oui-w-[50%]", children: t("connector.disconnect") })] })] });
}, Dc = (e2) => jsxs(z$3, { width: "100%", justify: "between", children: [jsxs(z$3, { gap: 3, children: [jsx(Rn, {}), jsxs(z$3, { direction: "column", justify: "start", itemAlign: "start", className: "oui-gap-[2px]", children: [jsx(Q$1.formatted, { rule: "address", children: e2.address }), jsx(Q$1.formatted, { size: "2xs", intensity: 80, prefix: jsx("div", { className: "oui-h-1 oui-w-1 oui-rounded-full oui-bg-success oui-pr-1" }), children: e2.chainName })] })] }), jsx("button", { className: "oui-cursor-pointer", onClick: () => {
  e2.onCopyAddress();
}, children: jsx(In, {}) })] }), Lc = (e2) => {
  let { t } = ne$6();
  return jsxs(z$3, { direction: "column", gap: 3, r: "lg", p: 3, className: "oui-bg-base-6", width: "100%", children: [jsx("button", { onClick: e2.onClickReferral, className: "oui-cursor-pointer oui-w-full", children: jsxs(z$3, { justify: "between", width: "100%", children: [jsx(Q$1, { size: "2xs", children: t("affiliate.referral") }), jsx(Wn$4, { color: "white", opacity: 0.98, size: 16 })] }) }), e2.isAffiliate && jsxs(z$3, { gradient: "primary", p: 4, r: "lg", width: "100%", angle: 180, justify: "between", children: [jsxs(z$3, { direction: "column", itemAlign: "start", children: [jsx(Q$1, { size: "xs", children: t("common.affiliate") }), jsxs(Q$1, { size: "2xs", intensity: 54, children: ["(", t("affiliate.commission.30d"), ")"] })] }), jsxs(z$3, { className: "oui-gap-[6px]", children: [jsx(Go, {}), jsx(Q$1.numeral, { dp: 2, padding: false, rm: g$6.ROUND_DOWN, rule: "price", children: e2.affiliateCommission30D ?? "--" })] })] }), e2.isTrader && jsxs(z$3, { gradient: "success", p: 4, r: "lg", width: "100%", angle: 180, justify: "between", children: [jsxs(z$3, { direction: "column", itemAlign: "start", children: [jsx(Q$1, { size: "xs", children: t("affiliate.trader") }), jsxs(Q$1, { size: "2xs", intensity: 54, children: ["(", t("affiliate.commission.30d"), ")"] })] }), jsxs(z$3, { className: "oui-gap-[6px]", children: [jsx(Go, {}), jsx(Q$1.numeral, { dp: 2, padding: false, rm: g$6.ROUND_DOWN, rule: "price", children: e2.traderCommission30D ?? "--" })] })] })] });
}, Fc = (e2) => {
  var _a3;
  let { t } = ne$6();
  return jsxs(z$3, { direction: "column", gap: 3, r: "lg", p: 3, className: "oui-bg-base-6", width: "100%", children: [jsx("button", { onClick: e2.onClickTradingRewards, className: "oui-cursor-pointer oui-w-full", children: jsxs(z$3, { justify: "between", width: "100%", children: [jsxs(z$3, { gap: 1, className: "oui-text-base-contrast oui-text-2xs", children: [jsx(Q$1, { children: t("common.tradingRewards") }), jsxs(Q$1, { intensity: 54, children: ["(", jsx(Q$1, { children: `${(_a3 = t("tradingRewards.epoch")) == null ? void 0 : _a3.toLowerCase()} ` }), jsx(Q$1, { intensity: 98, children: e2.curEpochId }), " )"] })] }), jsx(Wn$4, { color: "white", opacity: 0.98, size: 16 })] }) }), jsxs(z$3, { p: 4, r: "lg", width: "100%", angle: 180, justify: "between", className: "oui-bg-gradient-to-t oui-from-[#2d0061] oui-to-[#bd6bed]", children: [jsx(Q$1, { size: "2xs", intensity: 80, children: t("tradingRewards.myEstRewards") }), jsxs(z$3, { className: "oui-gap-[6px]", children: [jsx(An, {}), jsx(Q$1.numeral, { dp: 2, padding: false, rm: g$6.ROUND_DOWN, rule: "price", children: e2.estRewards })] })] })] });
};
var Yo = (e2) => {
  let { t } = ne$6(), [o2] = useLocalStorage("orderly_link_device", {}), { account: i, state: r3 } = useAccount(), n4 = i.accountId, a2 = i.address, { hide: s2 } = j$3(), c = useConfig(), { connectedChain: l2, disconnect: d2, namespace: u2 } = useWalletConnector(), m2 = i.chainId || (l2 == null ? void 0 : l2.id) || (o2 == null ? void 0 : o2.chainId), g2 = useMemo(() => m2 ? (r3.status === AccountStatusEnum.EnableTrading || r3.status === AccountStatusEnum.EnableTradingWithoutConnected) && L$5(parseInt(m2)) : false, [r3.status, m2]), f2 = Qc(m2), p2 = c.get("operatorUrl"), S2 = () => {
    navigator.clipboard.writeText(a2 ?? ""), toast$2.success(t("common.copy.copied"));
  }, { affiliateCommission30D: y2, traderCommission30D: C2, isAffiliate: N2, isTrader: b2, onClickReferral: w4 } = Uc(e2.onClickReferral), { curEpochId: q2, estRewards: x2, onClickTradingRewards: A2 } = $c(e2.onClickTradingRewards), J2 = async () => {
    var _a3;
    localStorage.removeItem("orderly_link_device"), await d2({ label: (_a3 = r3.connectWallet) == null ? void 0 : _a3.name }), await i.disconnect(), s2();
  }, [Q2, { isMutating: xe2 }] = useMutation(`${p2}/v1/faucet/usdc`);
  return { accountId: n4, address: a2, chainId: m2, chainName: f2, onCopyAddress: S2, affiliateCommission30D: y2, onClickReferral: w4, isAffiliate: N2, isTrader: b2, traderCommission30D: C2, curEpochId: q2, onClickTradingRewards: A2, estRewards: x2, onDisconnect: J2, showGetTestUSDC: g2, onGetTestUSDC: () => {
    if (r3.status < AccountStatusEnum.EnableTrading && r3.status !== AccountStatusEnum.EnableTradingWithoutConnected) return;
    let _2 = t("trading.faucet.getTestUSDC.success", { quantity: u2 === ChainNamespace.solana ? "100" : "1,000" });
    return Q2({ chain_id: m2 == null ? void 0 : m2.toString(), user_address: r3.address, broker_id: c.get("brokerId") }).then((j2) => {
      if (j2.success) return vo$4.alert({ title: t("trading.faucet.getTestUSDC"), message: _2, onOk: () => Promise.resolve(true) });
      j2.message && toast$2.error(j2.message);
    }, (j2) => {
      toast$2.error(j2.message);
    });
  }, gettingTestUSDC: xe2 };
}, Uc = (e2) => {
  let { data: t, isAffiliate: i, isTrader: r3 } = useReferralInfo(), n4 = useMemo(() => {
    if (i) return t == null ? void 0 : t.referrer_info["30d_referrer_rebate"];
  }, [t]), a2 = useMemo(() => {
    if (r3) return t == null ? void 0 : t.referee_info["30d_referee_rebate"];
  }, [t]);
  return { onClickReferral: () => {
    e2 == null ? void 0 : e2();
  }, affiliateCommission30D: n4, traderCommission30D: a2, isAffiliate: i, isTrader: r3 };
}, $c = (e2) => {
  let [t] = useCurEpochEstimate(TWType.normal), [o2, i] = useEpochInfo(TWType.normal), r3 = useMemo(() => {
    var _a3;
    return ((_a3 = i.curEpochInfo) == null ? void 0 : _a3.epoch_id) ?? "--";
  }, [i]), n4 = useMemo(() => typeof (t == null ? void 0 : t.est_r_wallet) > "u" ? "--" : t == null ? void 0 : t.est_r_wallet, [t]);
  return { curEpochId: r3, estRewards: n4, onClickTradingRewards: () => {
    e2 == null ? void 0 : e2();
  } };
};
function Qc(e2) {
  let [t, { findByChainId: o2 }] = useChains("mainnet", { pick: "network_infos", filter: (r3) => {
    var _a3, _b2;
    return ((_a3 = r3.network_infos) == null ? void 0 : _a3.bridge_enable) || ((_b2 = r3.network_infos) == null ? void 0 : _b2.bridgeless);
  } });
  return useMemo(() => {
    let r3 = o2(parseInt(e2), "network_infos");
    return r3 ? r3.name : "Unknown";
  }, [e2, o2]);
}
var Xo = (e2) => {
  let t = Yo(e2);
  return jsx(Qo, { ...t });
};
var En = () => {
  let { t: e2 } = ne$6(), { referral: t, tradingRewards: o2, bottomSheetLeading: i } = z(), { account: r3, state: n4 } = useAccount();
  return { onShowAccountSheet: () => {
    vo$4.sheet({ title: e2("common.account"), leading: i, content: jsx(Xo, { ...t, ...o2 }) });
  }, address: r3.address, state: n4 };
};
var Wn = (e2) => jsx(S, { buttonProps: { size: "sm" }, children: jsx($e$6, { variant: "gradient", size: "sm", className: "oui-max-w-[83px]", onClick: (t) => {
  e2.onShowAccountSheet();
}, children: Ju(e2.address, [4, 4]) }) });
Zo({ name: "mobile-account-menu", positions: [Yt$1.MobileAccountMenu], builder: En, __isInternal: true })((e2) => jsx(Wn, { ...e2 }));
var li = () => {
  let { account: e2 } = useAccount(), t = Ad(), o2 = Md(), i = useEventEmitter(), { t: r3 } = ne$6(), [n4, a2] = useState(false), s2 = useCallback(async () => e2.settle().catch((d2) => {
    if (d2.code == -1104) return toast$2.error(r3("settle.settlement.error")), Promise.reject(d2);
    if (d2.message.indexOf("Signing off chain messages with Ledger is not yet supported") !== -1) return i.emit("wallet:sign-message-with-ledger-error", { message: d2.message, userAddress: e2.address }), Promise.reject(d2);
    if ((d2 == null ? void 0 : d2.code) === "ACTION_REJECTED") return toast$2.error(r3("connector.userRejected")), Promise.reject(d2);
  }).then((d2) => (toast$2.success(r3("settle.settlement.requested")), Promise.resolve(d2))), [e2, r3]), c = useCallback(() => {
    vo$4.show(Xr$1, { activeTab: "deposit" });
  }, []), l2 = useCallback(() => {
    vo$4.show(Xr$1, { activeTab: "withdraw" });
  }, []);
  return { ...t, ...o2, onSettlePnL: s2, onDeposit: c, onWithdraw: l2, showSliderTip: n4, setShowSliderTip: a2 };
}, Ad = () => {
  let { hideAssets: e2, setHideAssets: t } = G(), o2 = () => {
    t(!e2);
  }, { totalCollateral: i, freeCollateral: r3, totalValue: n4, availableBalance: a2 } = useCollateral({ dp: 2 });
  return { hideAssets: e2, toggleHideAssets: o2, totalCollateral: i, freeCollateral: r3, totalValue: n4, availableBalance: a2 };
}, Md = () => {
  let { t: e2 } = ne$6(), [{ aggregated: t, totalUnrealizedROI: o2 }, i] = usePositionStream(), { marginRatio: r3, currentLeverage: n4, mmr: a2 } = useMarginRatio(), s2 = useMemo(() => Math.min(10, t.notional === 0 ? i.margin_ratio(10) : r3), [r3, t]), { update: c, curLeverage: l2, maxLeverage: d2, leverageLevers: u2 } = useLeverage(), m2 = useMemo(() => u2 == null ? void 0 : u2.map((x2) => ({ label: `${x2}x`, value: x2 })), [u2]), [g2, f2] = useState(l2 ?? 0), p2 = 100 / (((m2 == null ? void 0 : m2.length) || 0) - 1), S2 = (x2) => {
    f2(x2);
  }, y2 = async (x2) => {
    try {
      c({ leverage: x2 }).then(() => {
        toast$2.success(e2("leverage.updated"));
      }, (A2) => {
        toast$2.error(A2.message);
      });
    } catch {
    }
  }, C2 = useCallback((x2) => {
    y2(Array.isArray(x2) ? x2[0] : x2);
  }, []), N2 = useDebouncedCallback(C2, 500), b2 = useCallback((x2) => {
    let A2 = Number.parseInt(x2.target.value, 10), J2 = Number.isNaN(A2) ? 0 : A2, Q2 = Math.min(Math.max(J2, 1), d2);
    f2(Q2), N2(Q2);
  }, [N2, d2]);
  return { aggregated: t, totalUnrealizedROI: o2, positionsInfo: i, marginRatio: r3, marginRatioVal: s2, mmr: a2, currentLeverage: n4, step: p2, marks: m2, onLeverageChange: S2, onLeverageIncrease: () => {
    f2((x2) => (y2(x2 + 1), x2 + 1));
  }, onLeverageReduce: () => {
    f2((x2) => (y2(x2 - 1), x2 - 1));
  }, onInputChange: b2, isReduceDisabled: g2 <= 1, isIncreaseDisabled: g2 >= d2, onValueCommit: C2, value: g2, maxLeverage: d2, onSaveLeverage: y2 };
};
function Zn(e2, t) {
  if (t === null) return { isRed: false, isYellow: false, isGreen: true };
  let o2 = t * 2, i = e2 <= o2, r3 = e2 > o2 && e2 < 1, n4 = e2 >= 1;
  return { high: i, mid: r3, low: n4 };
}
var jn = (e2) => {
  let { size: t = 20, className: o2 } = e2;
  return jsx("div", { className: "oui-flex oui-justify-center oui-items-end", style: { background: "url(/images/riskLevelBg.png)", backgroundSize: "contain", backgroundRepeat: "no-repeat", backgroundPosition: "center bottom", width: `${t}px`, height: "14px" }, children: jsx("div", { className: cnBase("oui-relative oui-w-[2px] oui-h-[2px] oui-rounded-full oui-bg-white after:oui-block after:oui-content-[''] after:oui-absolute after:oui-right-0 after:oui-w-[10px] after:oui-h-[2px] after:oui-bg-white/50", o2) }) });
};
var di = (e2) => jsxs(z$3, { direction: "column", gap: 4, width: "100%", children: [jsx(Qd, { ...e2 }), jsx(de$5, { className: "oui-w-full" }), jsx(Kd, { ...e2 }), jsx(Yd, { ...e2 })] }), Qd = (e2) => {
  let { t } = ne$6(), o2 = useCallback(() => vo$4.confirm({ title: t("settle.settlePnl"), content: jsx(Q$1, { intensity: 54, size: "xs", children: jsx(Trans, { i18nKey: "settle.settlePnl.description" }) }), onCancel: () => Promise.reject(), onOk: () => typeof e2.onSettlePnL != "function" ? Promise.resolve() : e2.onSettlePnL().catch((r3) => {
  }) }), [t]), i = e2.totalUnrealizedROI > 0 ? "oui-text-success-darken" : "oui-text-danger-darken";
  return jsxs(z$3, { direction: "column", gap: 3, width: "100%", children: [jsxs(z$3, { direction: "column", itemAlign: "start", width: "100%", children: [jsx(Q$1.formatted, { size: "2xs", intensity: 36, suffix: e2.hideAssets ? jsx(Nn$2, { opacity: 1, size: 16, className: "oui-text-primary-light" }) : jsx(zn$1, { opacity: 1, size: 16, className: "oui-text-primary-light" }), onClick: () => {
    e2.toggleHideAssets();
  }, className: "oui-cursor-pointer", children: `${t("common.totalValue")} (USDC)` }), jsx(Q$1.numeral, { size: "base", dp: 2, padding: false, visible: !e2.hideAssets, children: e2.totalValue ?? "--" })] }), jsxs(Sa$1, { cols: 2, rows: 1, width: "100%", children: [jsx(za$1, { label: `${t("common.unrealizedPnl")} (USDC)`, classNames: { label: "oui-text-2xs oui-text-base-contrast-36" }, children: jsxs(z$3, { gap: 1, children: [jsx(Q$1.numeral, { size: "xs", coloring: true, dp: 2, padding: false, visible: !e2.hideAssets, children: e2.aggregated.unrealPnL }), !e2.hideAssets && jsx(Q$1.numeral, { size: "xs", dp: 2, padding: false, rule: "percentages", prefix: "(", suffix: ")", className: i, children: e2.totalUnrealizedROI })] }) }), jsx(za$1, { label: `${t("trading.asset.unsettledPnl")} (USDC)`, classNames: { label: "oui-text-2xs oui-text-base-contrast-36" }, children: jsxs(z$3, { justify: "between", width: "100%", children: [jsx(Q$1.numeral, { size: "xs", coloring: true, dp: 2, padding: false, visible: !e2.hideAssets, children: e2.aggregated.unsettledPnL }), jsxs("button", { className: "oui-flex oui-gap-1 oui-items-center", onClick: o2, children: [jsx(Bn$1, { opacity: 1, size: 12, className: "oui-text-primary-light" }), jsx(Q$1, { size: "2xs", color: "primary", children: t("settle.settlePnl") })] })] }) })] })] });
}, Kd = (e2) => {
  let { t } = ne$6(), { high: o2, mid: i, low: r3 } = Zn(e2.marginRatioVal, e2.mmr);
  return jsxs(Sa$1, { cols: 2, rows: 1, width: "100%", children: [jsx(za$1, { label: t("trading.asset.marginRatio"), classNames: { label: "oui-text-2xs oui-text-base-contrast-36" }, children: jsxs(z$3, { gap: 2, children: [jsx(Q$1.numeral, { size: "xs", rule: "percentages", color: "primary", dp: 2, padding: false, visible: !e2.hideAssets, children: e2.marginRatioVal }), !e2.hideAssets && jsx(jn, { className: r3 ? "oui-rotate-0" : i ? "oui-rotate-90" : o2 ? "oui-rotate-180" : "" })] }) }), jsx(za$1, { label: `${t("trading.asset.free&TotalCollateral")} (USDC)`, classNames: { label: "oui-text-2xs oui-text-base-contrast-36" }, children: jsxs(z$3, { justify: "start", width: "100%", gap: 1, children: [jsx(Q$1.numeral, { size: "xs", dp: 2, padding: false, visible: !e2.hideAssets, children: e2.freeCollateral }), jsx(Q$1, { size: "xs", children: "/" }), jsx(Q$1.numeral, { size: "xs", dp: 2, padding: false, visible: !e2.hideAssets, children: e2.totalCollateral })] }) })] });
};
var Yd = (e2) => {
  let { t } = ne$6();
  return jsxs(Sa$1, { cols: 2, rows: 1, gap: 3, className: "oui-grid-row-[1fr,1fr]", width: "100%", pt: 2, pb: 4, children: [jsx($e$6, { icon: jsx(On, { color: "white", opacity: 0.8 }), size: "md", fullWidth: true, className: "oui-bg-base-2 hover:oui-bg-base-2/50", onClick: e2.onWithdraw, children: t("common.withdraw") }), jsx($e$6, { icon: jsx(Hn, { color: "white", opacity: 0.8 }), size: "md", fullWidth: true, onClick: e2.onDeposit, children: t("common.deposit") })] });
};
var mi = () => {
  let e2 = li();
  return jsx(di, { ...e2 });
};
var gi = (e2) => {
  let { symbol: t, sharePnLConfig: o2 } = e2, [i, r3] = useState("Position"), [n4, a2] = useState("Position history"), { t: s2 } = ne$6(), { onSymbolChange: c } = z(), l2 = G(), [d2, { cancelAllOrders: u2, cancelAllTPSLOrders: m2 }] = useOrderStream({}), { positionCount: g2 } = Je(t), { pendingOrderCount: f2, tpSlOrderCount: p2 } = je2(t);
  return { tab: i, setTab: r3, subTab: n4, setSubTab: a2, sharePnLConfig: o2, symbol: t, positionCount: g2, pendingOrderCount: f2, tpSlOrderCount: p2, ...l2, onCloseAll: (y2) => {
    let C2 = y2 === Pe.pending ? s2("orders.pending.cancelAll") : y2 === Pe.tp_sl ? s2("orders.tpsl.cancelAll") : "", N2 = y2 === Pe.pending ? s2("orders.pending.cancelAll.description") : y2 === Pe.tp_sl ? s2("orders.tpsl.cancelAll.description") : "";
    vo$4.confirm({ title: C2, content: jsx(Q$1, { size: "2xs", children: N2 }), onOk: async () => {
      try {
        return i === "TP/SL" ? await m2() : await u2(), Promise.resolve(true);
      } catch (b2) {
        return (b2 == null ? void 0 : b2.message) !== void 0 && toast.error(b2.message), Promise.resolve(false);
      } finally {
        Promise.resolve();
      }
    } });
  }, onSymbolChange: c };
};
var hi = (e2) => {
  let { t } = ne$6();
  return jsxs(jl, { value: e2.tab, onValueChange: (o2) => e2.setTab(o2), size: "lg", className: e2.className, classNames: { tabsList: "oui-bg-base-9 oui-rounded-t-xl oui-p-2 oui-overflow-x-scroll oui-hide-scrollbar" }, children: [jsx($l, { title: `${t("common.positions")} ${(e2.positionCount ?? 0) > 0 ? `(${e2.positionCount})` : ""}`, value: "Position", children: jsx(cm, { ...e2 }) }), jsx($l, { title: `${t("orders.status.pending")} ${(e2.pendingOrderCount ?? 0) > 0 ? `(${e2.pendingOrderCount})` : ""}`, value: "Pending", children: jsx(fi, { type: Pe.pending, ordersStatus: OrderStatus.INCOMPLETE, ...e2 }) }), jsx($l, { title: `${t("common.tpsl")} ${(e2.tpSlOrderCount ?? 0) > 0 ? `(${e2.tpSlOrderCount})` : ""}`, value: "TP/SL", children: jsx(fi, { type: Pe.tp_sl, ordersStatus: OrderStatus.INCOMPLETE, ...e2 }) }), jsx($l, { title: t("trading.history"), value: "History", children: jsx(mm, { ...e2 }) }), jsx($l, { title: t("positions.liquidation"), value: "Liquidation", children: jsx(ta$1, { enableLoadMore: true, symbol: e2.showAllSymbol ? void 0 : e2.symbol, classNames: { cell: "oui-p-2 oui-bg-base-9 oui-rounded-xl" } }) })] });
}, cm = (e2) => jsxs(z$3, { direction: "column", gap: 2, children: [jsx(Ze, { pnlNotionalDecimalPrecision: e2.pnlNotionalDecimalPrecision, symbol: e2.showAllSymbol ? void 0 : e2.symbol, unPnlPriceBasis: e2.unPnlPriceBasis }), jsx(Kr$2, { symbol: e2.showAllSymbol ? void 0 : e2.symbol, onSymbolChange: e2.onSymbolChange, sharePnLConfig: e2.sharePnLConfig, pnlNotionalDecimalPrecision: e2.pnlNotionalDecimalPrecision })] }), fi = (e2) => jsxs(z$3, { direction: "column", pb: 2, width: "100%", children: [jsx(de$5, { className: "oui-w-full" }), e2.type !== Pe.orderHistory && jsx(dm, { ...e2 }), jsx(Ms, { symbol: e2.showAllSymbol ? void 0 : e2.symbol, onSymbolChange: e2.onSymbolChange, type: e2.type, ordersStatus: e2.ordersStatus, classNames: { root: "oui-w-full oui-hide-scrollbar oui-overflow-y-hidden", content: "!oui-space-y-1", cell: "oui-py-2 oui-bg-base-9 oui-p-2 oui-rounded-xl" }, sharePnLConfig: e2.sharePnLConfig, showFilter: e2.type === Pe.orderHistory, filterConfig: { range: { from: void 0, to: void 0 } } })] }), dm = (e2) => {
  let { t } = ne$6();
  return jsxs(z$3, { px: 2, py: 2, width: "100%", justify: "between", gap: 2, className: "oui-rounded-b-xl oui-bg-base-9", children: [jsxs(z$3, { className: "oui-gap-[2px] oui-cursor-pointer", children: [jsx(pi$1, { color: "white", checked: !e2.showAllSymbol, onCheckedChange: (o2) => {
    e2.setShowAllSymbol(!o2);
  } }), jsx(Q$1, { size: "2xs", intensity: 54, onClick: () => {
    e2.setShowAllSymbol(!e2.showAllSymbol);
  }, children: t("trading.hideOtherSymbols") })] }), jsx($e$6, { variant: "outlined", size: "xs", color: "secondary", onClick: (o2) => {
    e2.onCloseAll(e2.type);
  }, children: t("trading.orders.closeAll") })] });
}, mm = (e2) => {
  let { t } = ne$6();
  return jsx("div", { className: "oui-min-h-[300px]", children: jsxs(jl, { value: e2.subTab, onValueChange: (o2) => e2.setSubTab(o2), size: "md", classNames: { tabsList: "oui-bg-base-9 oui-rounded-t-xl oui-p-2" }, children: [jsx($l, { title: t("positions.positionHistory"), value: "Position history", children: jsx(qs$1, { symbol: e2.showAllSymbol ? void 0 : e2.symbol, onSymbolChange: e2.onSymbolChange, classNames: { cell: "oui-p-2 oui-bg-base-9 oui-rounded-xl" }, sharePnLConfig: e2.sharePnLConfig }) }), jsx($l, { title: t("orders.orderHistory"), value: "Order history", children: jsx(fi, { type: Pe.orderHistory, ...e2 }) })] }) });
};
var bi = (e2) => {
  let t = gi(e2);
  return jsx(hi, { ...t, className: e2.className });
};
var xi = (e2) => {
  let [t, o2] = useState(0), i = useRef(null);
  return useEffect(() => {
    let r3 = i.current;
    if (!r3) return;
    let n4 = new ResizeObserver((a2) => {
      for (let s2 of a2) o2(s2.contentRect.height);
    });
    return n4.observe(r3), () => {
      n4.unobserve(r3);
    };
  }, []), jsxs("div", { className: cnBase("oui-grid oui-grid-cols-[4fr,6fr] oui-gap-1 oui-mx-1 ", e2.className), children: [jsx("div", { className: "oui-bg-base-9 oui-rounded-xl", style: { height: `${t + 16}px` }, children: jsx(We2, { symbol: e2.symbol, height: t ? t - 44 : void 0 }) }), jsx("div", { className: "oui-bg-base-9 oui-rounded-xl oui-p-2", children: jsx(uo, { symbol: e2.symbol, containerRef: i }) })] });
};
var yi = () => {
  let { symbol: e2 } = z();
  return { symbol: e2 };
};
var Si = (e2) => {
  let t = yi();
  return jsx(xi, { className: e2.className, ...t });
};
var Ci = () => {
  let [e2, t] = useState("chart"), { symbol: o2 } = z(), [i, r3] = useState(true);
  return { tab: e2, setTab: t, symbol: o2, toggleContentVisible: () => {
    r3((a2) => !a2);
  }, setVisible: r3, visible: i };
};
var na = (e2) => jsx(Me2, { symbol: e2.symbol, classNames: { root: "oui-px-3 ", list: "oui-min-h-[141px] oui-max-h-[202px] oui-w-full", listHeader: "oui-text-xs oui-text-base-contrast-36", listItem: { left: "oui-text-xs", mid: "oui-text-xs", right: "oui-text-xs" } } });
var Pi = (e2) => {
  var _a3, _b2, _c2, _d3;
  let { t } = ne$6();
  return jsxs(z$3, { direction: "column", gap: 2, children: [jsx($e, { title: t("common.markPrice"), value: (_a3 = e2.ticker) == null ? void 0 : _a3.mark_price, dp: e2.symbolInfo.quote_dp }), jsx($e, { title: t("common.indexPrice"), value: (_b2 = e2.ticker) == null ? void 0 : _b2.index_price, dp: e2.symbolInfo.quote_dp }), jsx($e, { title: t("markets.column.24hVolume"), value: e2.vol_24h, dp: e2.symbolInfo.quote_dp, rule: "human", showUSDC: true }), jsx($e, { title: t("trading.column.24High"), value: (_c2 = e2.ticker) == null ? void 0 : _c2["24h_high"], dp: e2.symbolInfo.quote_dp }), jsx($e, { title: t("trading.column.24Low"), value: (_d3 = e2.ticker) == null ? void 0 : _d3["24h_low"], dp: e2.symbolInfo.quote_dp }), jsx($e, { title: t("markets.openInterest"), value: e2.openInterest, dp: e2.symbolInfo.quote_dp, rule: "human", showUSDC: true })] });
}, $e = (e2) => {
  let { title: t, value: o2, showUSDC: i, dp: r3, rule: n4 = "price" } = e2;
  return jsxs(z$3, { justify: "between", width: "100%", className: "oui-text-xs", children: [jsx(Q$1, { intensity: 36, children: t }), jsxs(z$3, { gap: 1, children: [jsx(Q$1.numeral, { rule: n4, dp: r3, intensity: 80, children: o2 }), i && jsx(Q$1, { intensity: 36, children: "USDC" })] })] });
};
var Ni = (e2) => {
  let { symbol: t } = e2, o2 = useTickerStream(t), { symbolInfo: i } = z(), r3 = useMemo(() => {
    let a2 = o2 == null ? void 0 : o2["24h_close"], s2 = o2 == null ? void 0 : o2["24h_volume"];
    if (a2 && s2 && !isNaN(a2) && !isNaN(s2)) return new g$6(a2).mul(s2).toFixed(i.quote_dp, g$6.ROUND_DOWN);
  }, [o2]), n4 = useMemo(() => {
    let a2 = o2 == null ? void 0 : o2.mark_price, s2 = o2 == null ? void 0 : o2.open_interest;
    if (a2 && s2 && !isNaN(a2)) return new g$6(a2).mul(Number(s2)).toFixed(i.quote_dp, g$6.ROUND_DOWN);
  }, [o2]);
  return { ticker: o2, symbolInfo: i, vol_24h: r3, openInterest: n4 };
};
var ki = (e2) => {
  let t = Ni(e2);
  return jsx(Pi, { ...t });
};
var sa = (e2) => jsx("svg", { width: "12", height: "12", viewBox: "0 0 12 12", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...e2, children: jsx("g", { id: "Arrows-expand", children: jsx("path", { id: "Vector", d: "M5.9989 1.00708C5.8709 1.00708 5.7369 1.05008 5.6394 1.14758L3.7959 3.00708L4.4989 3.71008L5.4989 2.72607V4.50708C5.4989 4.78308 5.7229 5.00708 5.9989 5.00708C6.2749 5.00708 6.4989 4.78308 6.4989 4.50708V2.72607L7.4989 3.71008L8.2019 3.00708L6.3584 1.14758C6.2604 1.05008 6.1269 1.00708 5.9989 1.00708ZM5.9989 7.00707C5.7229 7.00707 5.4989 7.23107 5.4989 7.50707V9.28808L4.4989 8.30407L3.7959 9.00707L5.6394 10.8666C5.8349 11.0616 6.1629 11.0616 6.3584 10.8666L8.2019 9.00707L7.4989 8.30407L6.4989 9.28808V7.50707C6.4989 7.23107 6.2749 7.00707 5.9989 7.00707Z" }) }) });
function ua(e2) {
  var _a3, _b2, _c2;
  return jsxs("div", { className: "oui-pb-1 oui-flex oui-flex-col oui-gap-1", style: { height: e2.height }, ref: e2.boxRef, children: [jsx("div", { className: "oui-w-full oui-h-full", children: jsx(Si$1, { symbol: e2.symbol, libraryPath: (_a3 = e2.tradingViewConfig) == null ? void 0 : _a3.library_path, mode: 3, scriptSRC: (_b2 = e2.tradingViewConfig) == null ? void 0 : _b2.scriptSRC, customCssUrl: (_c2 = e2.tradingViewConfig) == null ? void 0 : _c2.customCssUrl, ...e2.tradingViewConfig }) }), jsx("div", { className: "oui-relative oui-w-full", children: jsx("div", { ref: e2.dragRef, className: cnBase("oui-h-[1px] oui-absolute oui-left-0 oui-right-0 oui-bottom-0 oui-top-0 oui-z-10 oui-mt-[7px] oui-bg-base-contrast-12", e2.dragging && "oui-bg-primary "), children: jsx(sa, { className: cnBase("oui-w-3 oui-h-3 oui-absolute oui-left-1/2 -oui-top-[5px] -oui-translate-y-[0.5px] oui-text-base-contrast-12", e2.dragging && " oui-text-primary") }) }) })] });
}
var Dm = 354, ma = 234, Lm = "TRADINGVIEW_MOBILE_HEIGHT";
function ga(e2) {
  let [t, o2] = useLocalStorage(Lm, ma), [i, r3] = useState(false), n4 = useRef(null), a2 = useRef(null), [s2, c] = useState(0), l2 = useRef(0), d2 = useCallback((g2) => {
    if (!a2.current) return;
    r3(true);
    let f2 = g2.touches[0], p2 = a2.current.getBoundingClientRect();
    g2.stopPropagation(), g2.preventDefault();
    let S2 = f2.clientY - p2.bottom;
    l2.current = p2.top, c(S2);
  }, []), u2 = useCallback((g2) => {
    if (a2.current && i) {
      g2.stopPropagation(), g2.preventDefault();
      let p2 = g2.touches[0].clientY - l2.current - s2;
      return o2(Math.min(Math.max(Math.round(p2), ma), Dm)), false;
    }
  }, [i, s2]), m2 = useCallback(() => {
    r3(false);
  }, []);
  return useEffect(() => {
    let g2 = n4.current;
    if (g2) return g2.addEventListener("touchstart", d2), () => {
      g2.removeEventListener("touchstart", d2);
    };
  }, [d2]), useEffect(() => (document.addEventListener("touchmove", u2, { passive: false }), document.addEventListener("touchend", m2), () => {
    document.removeEventListener("touchmove", u2), document.removeEventListener("touchend", m2);
  }), [i, u2, m2]), { ...e2, height: t, dragging: i, dragRef: n4, boxRef: a2 };
}
function fa(e2) {
  let t = ga(e2);
  return jsx(ua, { ...t });
}
var Oi = (e2) => {
  let { t } = ne$6(), { tradingViewConfig: o2 } = z();
  return jsxs(jl, { variant: "contained", value: e2.tab, contentVisible: e2.visible, onValueChange: (i) => {
    e2.setTab(i), e2.setVisible(true);
  }, className: e2.className, classNames: { tabsList: "oui-p-2", tabsContent: "oui-min-h-[176px] oui-max-h-[396px]" }, style: { marginBottom: e2.tab === "chart" ? "8px" : 0 }, trailing: jsx("button", { className: "oui-px-5", onClick: e2.toggleContentVisible, children: jsx(Am, { className: e2.visible ? "oui-rotate-0" : "oui-rotate-180" }) }), children: [jsx($l, { title: t("trading.tabs.chart"), value: "chart", children: jsx(fa, { symbol: e2.symbol, tradingViewConfig: o2 }) }), jsx($l, { title: t("trading.tabs.trades"), value: "trades", children: jsx(na, { symbol: e2.symbol }) }), jsx($l, { title: t("trading.tabs.data"), value: "data", children: jsx(W$2, { px: 3, children: jsx(ki, { symbol: e2.symbol }) }) })] });
}, Am = (e2) => jsxs("svg", { width: "12", height: "12", viewBox: "0 0 12 12", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", className: cnBase("oui-fill-base-contrast-54 hover:oui-fill-base-contrast-80", e2.className), children: [jsx("path", { d: "M5.721 4.585 2.726 6.578a.51.51 0 0 0-.14.7.51.51 0 0 0 .702.14l2.714-1.806 2.715 1.806c.23.153.549.089.702-.14a.51.51 0 0 0-.14-.7L6.283 4.585a.51.51 0 0 0-.562 0" }), jsx("defs", {})] });
var Ri = (e2) => {
  let t = Ci();
  return jsx(Oi, { className: e2.className, ...t });
};
var Gm = () => jsx("svg", { width: "8", height: "8", viewBox: "0 0 8 8", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: jsx("path", { d: "M6.456 3.48a3.5 3.5 0 0 0 .431-.567 9 9 0 0 0 .361-.654l-.648-.66-.107.185q-.071.12-.142.244a3 3 0 0 1-.27.396 1.4 1.4 0 0 1-.318.29.67.67 0 0 1-.38.114q-.307 0-.666-.194t-.742-.42q-.383-.227-.777-.42a1.7 1.7 0 0 0-.771-.194q-.401.001-.72.154a2.1 2.1 0 0 0-.57.404 2.6 2.6 0 0 0-.43.574 5 5 0 0 0-.307.646l.649.66q.165-.437.464-.833.298-.395.742-.396.347 0 .7.194.354.193.721.42.37.227.763.42.396.195.826.195.374.001.665-.155.29-.151.526-.404m.352 2.941a3.5 3.5 0 0 0 .431-.566q.196-.315.361-.654l-.648-.66-.107.184-.142.244a3 3 0 0 1-.27.396 1.4 1.4 0 0 1-.318.29.67.67 0 0 1-.38.115q-.307 0-.666-.195-.36-.193-.742-.42-.383-.226-.778-.42a1.7 1.7 0 0 0-.77-.194q-.401.001-.72.154a2.1 2.1 0 0 0-.57.405 2.6 2.6 0 0 0-.43.574 5 5 0 0 0-.307.646l.649.66q.165-.437.464-.833.297-.395.742-.396.347 0 .7.194.354.193.721.42.369.226.763.42.396.194.826.194.374.001.665-.154.29-.152.526-.404", fill: "#fff", fillOpacity: ".54" }) }), ba = (e2) => {
  let { t } = ne$6(), o2 = jsxs(W$2, { intensity: 900, px: 3, height: 54, children: [jsx(Xn, { symbol: e2.symbol, onSymbol: () => e2.onOpenMarketsSheetChange(true), trailing: jsxs(z$3, { direction: "column", itemAlign: "end", className: "oui-cursor-pointer oui-text-[11px]", onClick: e2.onShowPortfolioSheet, children: [jsxs(z$3, { children: [jsx(Q$1, { intensity: 54, children: t("common.totalValue") }), jsx("button", { onClick: (i) => {
    i.stopPropagation(), i.preventDefault(), e2.setHideAssets(!e2.hideAssets);
  }, className: "oui-px-1", children: e2.hideAssets ? jsx(Nn$2, { color: "primary", opacity: 1, size: 16, className: "oui-text-primary-light" }) : jsx(zn$1, { color: "primary", opacity: 1, size: 16, className: "oui-text-primary-light" }) }), jsx(Gm, {})] }), jsx(Q$1.numeral, { suffix: jsx(Q$1, { intensity: 20, children: "USDC" }), dp: 2, visible: !e2.hideAssets, children: e2.canTrade ? e2.total ?? "--" : "--" })] }) }), jsx(Jo, { open: e2.openMarketsSheet, onOpenChange: e2.onOpenMarketsSheetChange, classNames: { body: "oui-h-full oui-pb-[env(safe-area-inset-bottom)]", content: "oui-w-[280px] !oui-p-0 oui-rounded-bl-[40px] oui-h-full " }, contentProps: { side: "left", closeable: false }, children: jsx(Wn$1, { symbol: e2.symbol, onSymbolChange: (i) => {
    var _a3;
    e2.onOpenMarketsSheetChange(false), (_a3 = e2.onSymbolChange) == null ? void 0 : _a3.call(e2, i);
  } }) })] });
  return jsx("div", { style: { paddingBottom: "calc(64px + env(safe-area-inset-bottom))" }, className: "oui-relative oui-grid oui-h-[calc(100vh-44px)] oui-gap-1 oui-bg-base-10", children: jsxs("main", { className: "oui-hide-scrollbar oui-space-y-1 oui-overflow-y-auto", children: [o2, jsx(Ri, { className: "oui-mx-1 oui-rounded-xl oui-bg-base-9" }), jsx(Si, {}), jsx(bi, { symbol: e2.symbol, className: "oui-mx-1 oui-rounded-xl", sharePnLConfig: e2.sharePnLConfig })] }) });
};
var Qe = (e2, t, o2) => [useMemo(() => {
  let n4 = localStorage.getItem(e2);
  return n4 ? `${n4}%` : t;
}, [e2, t, o2]), (n4) => {
  localStorage.setItem(e2, n4);
}];
var Hi = 6, Ei = 48, zi = 29, ee = 12, we = 54, Qt = 280, ya = 360, bt = 280, Sa = 732, me = 464, Re = 728, Ie2 = 320, xt = 540, Wi = 800, Vi = () => {
  let [e2, t] = useState(false), o2 = z(), { state: i } = useAccount(), { t: r3 } = ne$6(), { wrongNetwork: n4, disabledConnect: a2, restrictedInfo: s2 } = L$3(), { hideAssets: c, setHideAssets: l2 } = G(), { isFirstTimeDeposit: d2 } = yo(), { totalValue: u2 } = useCollateral(), m2 = Tr$2(u2), g2 = useMediaQuery("(max-width: 1279px)"), f2 = useMediaQuery("(min-width: 1440px)"), p2 = useMediaQuery("(max-width: 1680px)"), [S2, y2] = useLocalStorage("orderly_order_entry_side_markets_layout", "right"), C2 = useMemo(() => !n4 && !a2 && (i.status >= AccountStatusEnum.EnableTrading || i.status === AccountStatusEnum.EnableTradingWithoutConnected), [i.status, n4, a2]), N2 = () => {
    C2 && vo$4.sheet({ title: r3("trading.asset&Margin"), leading: o2.bottomSheetLeading, content: jsx(mi, {}) });
  }, b2 = useMemo(() => f2, [f2]), w4 = eg({ canTrade: C2, isFirstTimeDeposit: d2 }), q2 = jm({ collapsable: f2 }), x2 = tg(S2), A2 = og({ max2XL: g2 }), J2 = q2.collapsed ? 70 : 280, Q2 = g2 ? 1200 : 600, xe2 = C2 ? 379 : 277, O2 = ig({ orderEntryViewRef: A2.orderEntryViewRef, tradindviewMaxHeight: Q2, dataListMinHeight: xe2 }), _2 = { layout: S2, onLayout: y2, max2XL: g2, min3XL: f2, max4XL: p2, canTrade: C2, openMarketsSheet: e2, onOpenMarketsSheetChange: t, horizontalDraggable: b2, ...q2, ...w4, ...x2, ...A2, restrictedInfo: s2, ...O2, marketsWidth: J2, tradindviewMaxHeight: Q2, dataListMinHeight: xe2, total: m2, hideAssets: c, setHideAssets: l2, onShowPortfolioSheet: N2 };
  return { ...o2, ..._2 };
};
function jm(e2) {
  let { collapsable: t } = e2, [o2, i] = useState(false), [r3, n4] = useLocalStorage("orderly_side_markets_collapsed", void 0), a2 = (c) => {
    n4(c), i(true);
  }, s2 = useMemo(() => t ? r3 : true, [t, r3]);
  return { collapsable: t, collapsed: s2, onCollapse: a2, animating: o2, setAnimating: i };
}
function eg(e2) {
  let { canTrade: t, isFirstTimeDeposit: o2 } = e2, [i, r3] = useLocalStorage("orderly_assets_orderEntry_margin_positions", [0, 1, 2]), n4 = (c, l2) => {
    let d2 = [...i];
    if (c === 0 && l2 === d2.length - 1) {
      d2[l2] = i[c];
      for (let u2 = 0; u2 < d2.length - 1; u2++) d2[u2] = i[u2 + 1];
    } else if (c === d2.length - 1 && l2 === 0) {
      d2[l2] = i[c];
      for (let u2 = 1; u2 < d2.length; u2++) d2[u2] = i[u2 - 1];
    } else [d2[c], d2[l2]] = [d2[l2], d2[c]];
    r3(d2);
  }, a2 = useMemo(() => t && !o2, [t, o2]);
  return { positions: useMemo(() => a2 ? i : [0, 1, 2], [a2, i]), showPositionIcon: a2, updatePositions: n4 };
}
function tg(e2) {
  let [t, o2] = Qe("orderly_main_split_size", void 0, e2), [i, r3] = Qe("orderly_datalist_split_size", "350px"), [n4, a2] = Qe("orderly_orderbook_split_size", "280px", e2), [s2, c] = Qe("orderly_datalist_split_height_sm", "350px"), [l2, d2] = Qe("orderly_orderbook_split_height_sm", "280px");
  return { orderBookSplitSize: n4, setOrderbookSplitSize: a2, dataListSplitSize: i, setDataListSplitSize: r3, mainSplitSize: t, setMainSplitSize: o2, dataListSplitHeightSM: s2, setDataListSplitHeightSM: c, orderBookSplitHeightSM: l2, setOrderbookSplitHeightSM: d2 };
}
function og(e2) {
  let { max2XL: t } = e2, [o2, i] = useState(0), r3 = useRef(null);
  return useEffect(() => {
    let n4 = r3.current;
    if (!n4 || !t) return;
    let a2 = new ResizeObserver((s2) => {
      for (let c of s2) {
        let l2 = c.contentRect.height;
        l2 && i(l2);
      }
    });
    return a2.observe(n4), () => {
      a2.unobserve(n4);
    };
  }, [r3, t]), { orderEntryViewRef: r3, orderEntryHeight: o2 };
}
function Ca(e2) {
  return e2 ? `${100 - Math.min(Number(e2), 100)}` : "";
}
function ig(e2) {
  let { tradindviewMaxHeight: t, dataListMinHeight: o2 } = e2, i = useRef(null), r3 = useRef(null), [n4, a2] = useLocalStorage("orderly_order_entry_extra_height", 0), s2 = 22, [c, l2] = useLocalStorage("orderly_trading_data_list_height", o2);
  return { max2XLSplitRef: r3, tradingviewAndOrderbookSplitRef: i, onTradingviewAndOrderbookDragging: (m2, g2) => {
    var _a3, _b2;
    let f2 = (_a3 = i == null ? void 0 : i.current) == null ? void 0 : _a3.boxHeight;
    if (!f2) return;
    let p2 = f2 * m2 / 100, S2 = f2 * g2 / 100, y2 = Math.min(Math.max(p2, Ie2), t), C2 = Math.min(Math.max(S2, me), Re), N2 = ((_b2 = e2.orderEntryViewRef.current) == null ? void 0 : _b2.clientHeight) || 0;
    if (S2 >= C2) {
      let b2 = S2 - C2;
      a2(Math.max(0, n4 - b2));
    } else if (y2 + C2 < t + Re) {
      let b2 = y2 + C2 + s2 + we, w4 = Math.max(0, b2 - N2);
      a2(n4 + w4);
    }
  }, onDataListSplitHeightDragging: (m2, g2) => {
    var _a3;
    let f2 = (_a3 = r3 == null ? void 0 : r3.current) == null ? void 0 : _a3.boxHeight;
    if (!f2) return;
    let p2 = f2 * g2 / 100;
    if (p2 >= o2 && p2 <= Wi) {
      l2(p2);
      let S2 = p2 - c;
      S2 > 0 && a2(Math.max(0, n4 - S2));
    }
  }, extraHeight: n4, dataListHeight: c };
}
var va = (e2) => {
  let { t } = ne$6();
  return jsx(gg, { ...e2, children: jsxs(z$3, { px: 3, className: cnBase("oui-rounded-md", "oui-h-[28px]", "oui-cursor-pointer oui-transition-all", "oui-bg-base-6 hover:oui-bg-base-4", "oui-text-base-contrast-54 hover:oui-text-base-contrast-80"), gapX: 1, ml: 3, justify: "center", itemAlign: "center", children: [jsx(fg, {}), jsx(Q$1, { size: "2xs", weight: "semibold", children: t("trading.layout") })] }) });
}, gg = (e2) => {
  let [t, o2] = useState(false), { t: i } = ne$6(), r3 = (a2) => jsxs(z$3, { direction: "column", gapY: 2, onClick: () => {
    var _a3;
    (_a3 = e2.onLayout) == null ? void 0 : _a3.call(e2, a2), o2(false);
  }, className: "oui-group", children: [jsx(z$3, { justify: a2 === "right" ? "end" : "start", className: cnBase("oui-w-[148px] oui-h-[100px]", "oui-bg-base-10 oui-rounded-[10px]", "oui-border-[4px] oui-border-base-5 group-hover:oui-border-primary-light", e2.layout === a2 && "!oui-border-primary-light"), children: jsx(W$2, { p: 1, children: jsx(pg, {}) }) }), jsx(Q$1, { size: "2xs", intensity: 54, className: cnBase("oui-text-base-contrast-54 group-hover:oui-text-base-contrast-80", e2.layout === a2 && "oui-text-base-contrast-80"), children: i(a2 === "right" ? "trading.layout.right" : "trading.layout.left") })] }), n4 = jsxs(Fragment$1, { children: [jsxs(z$3, { itemAlign: "center", justify: "between", mt: 3, className: "oui-mb-[10px]", children: [jsx(Q$1, { size: "base", intensity: 98, children: i("trading.layout") }), jsx(De$4, { size: 16, className: "oui-text-base-contrast-80 oui-cursor-pointer", opacity: 0.98, onClick: () => {
    o2(false);
  } })] }), jsx(de$5, {}), jsxs(z$3, { gapX: 6, mt: 5, children: [r3("right"), r3("left")] })] });
  return jsxs(la$1, { open: t, onOpenChange: o2, children: [jsx(ua$2, { asChild: true, children: e2.children }), jsx(ca$1, { children: jsx(xr$3, { onCloseAutoFocus: (a2) => a2.preventDefault(), onClick: (a2) => a2.stopPropagation(), align: "end", className: cnBase("oui-bg-base-8 oui-p-5 oui-pt-0 oui-w-[360px] oui-font-semibold"), children: n4 }) })] });
}, fg = (e2) => jsx("svg", { width: "17", height: "16", viewBox: "0 0 17 16", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...e2, children: jsx("path", { d: "M3.832 1.994c-.736 0-1.333.597-1.333 1.333v9.334c0 .737.597 1.333 1.333 1.333H6.5c.737 0 1.333-.596 1.333-1.333V3.327c0-.736-.596-1.333-1.333-1.333zm6.667 0c-.737 0-1.333.597-1.333 1.333v2.667c0 .737.596 1.333 1.333 1.333h2.667c.736 0 1.333-.596 1.333-1.333V3.327c0-.736-.597-1.333-1.333-1.333zm.437 6.679a2.7 2.7 0 0 0-1.033.607.284.284 0 0 0-.061.339c.222.411-.01.851-.512.876a.29.29 0 0 0-.26.217c-.05.207-.07.38-.07.608 0 .19.02.407.06.599a.28.28 0 0 0 .252.217c.506.044.756.429.53.92a.28.28 0 0 0 .06.321c.296.273.635.466 1.034.59a.285.285 0 0 0 .312-.104c.31-.427.757-.428 1.05 0a.28.28 0 0 0 .313.113 2.8 2.8 0 0 0 1.042-.599.28.28 0 0 0 .06-.33c-.23-.466.035-.894.513-.902a.28.28 0 0 0 .269-.209c.048-.199.06-.372.06-.616q0-.316-.069-.616a.276.276 0 0 0-.27-.217c-.469-.001-.732-.463-.502-.868a.27.27 0 0 0-.053-.339 2.8 2.8 0 0 0-1.059-.607.274.274 0 0 0-.312.112c-.268.417-.77.425-1.033.009a.284.284 0 0 0-.321-.121m.842 1.536a1.111 1.111 0 1 1 0 2.222 1.111 1.111 0 0 1 0-2.222" }) }), pg = (e2) => jsxs("svg", { width: "36", height: "84", viewBox: "0 0 36 84", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsx("rect", { width: "36", height: "17", rx: "2", fill: "#181C23" }), jsx("rect", { y: "19", width: "36", height: "54", rx: "2", fill: "#181C23" }), jsx("rect", { y: "75", width: "36", height: "9", rx: "2", fill: "#181C23" }), jsx("rect", { x: "3", y: "79", width: "30", height: "1", rx: "0.5", fill: "url(#paint0_linear_17647_26849)" }), jsx("rect", { x: "3", y: "22", width: "14", height: "6", rx: "2", fill: "#008676" }), jsx("rect", { x: "19", y: "22", width: "14", height: "6", rx: "2", fill: "#D92D6B" }), jsx("rect", { x: "3", y: "11", width: "14", height: "3", rx: "1.5", fill: "#333948" }), jsx("rect", { x: "19", y: "11", width: "14", height: "3", rx: "1.5", fill: "#335FFC" }), jsx("rect", { x: "3", y: "62", width: "30", height: "8", rx: "2", fill: "#008676" }), jsx("defs", { children: jsxs("linearGradient", { id: "paint0_linear_17647_26849", x1: "33", y1: "79.5", x2: "3", y2: "79.5", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "#59B0FE" }), jsx("stop", { offset: "1", stopColor: "#26FEFE" })] }) })] });
var Xt = (e2) => {
  let { showIndicator: t = true } = e2, [o2, i] = useState(false);
  return jsxs(W$2, { intensity: 900, r: "2xl", p: 3, width: "100%", className: cnBase("oui-relative", e2.className), children: [e2.children, jsx(xs, { open: o2, onOpenChange: i, side: "left", align: "start", sideOffset: -4, alignOffset: -4, content: jsx(z$3, { direction: "column", gapY: 2, children: [wg, vg, Tg].map((r3, n4) => jsx(r3, { className: cnBase("oui-rounded oui-cursor-pointer hover:oui-bg-base-5", e2.index === n4 && "oui-bg-base-5"), onClick: () => {
    var _a3;
    (_a3 = e2.onLayout) == null ? void 0 : _a3.call(e2, e2.index, n4), i(false);
  } }, n4)) }), delayDuration: 0, className: cnBase("oui-bg-base-9 oui-rounded", "oui-border oui-border-line-12", "oui-p-1"), arrow: { className: "oui-fill-transparent" }, children: t && jsx("div", { className: "oui-absolute oui-right-[1px] oui-top-[18px]", children: jsx(Cg, { className: cnBase("oui-text-base-contrast-20 hover:oui-text-base-contrast-80", "oui-cursor-pointer") }) }) })] });
}, Cg = (e2) => jsxs("svg", { width: "10", height: "16", viewBox: "0 0 10 16", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...e2, children: [jsx("rect", { x: "2", y: "2", width: "6", height: "2", rx: "1" }), jsx("rect", { x: "2", y: "7", width: "6", height: "2", rx: "1" }), jsx("rect", { x: "2", y: "12", width: "6", height: "2", rx: "1" })] }), wg = (e2) => jsxs("svg", { width: "16", height: "16", viewBox: "0 0 16 16", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...e2, children: [jsx("rect", { x: "1.333", y: "2.667", width: "13.333", height: "4", rx: "2", fill: "rgb(var(--oui-color-primary))" }), jsx("rect", { x: "2.667", y: "12", width: "10.667", height: "1.333", rx: ".667", fill: "#fff", fillOpacity: ".2" }), jsx("rect", { x: "2.667", y: "8.667", width: "10.667", height: "1.333", rx: ".667", fill: "#fff", fillOpacity: ".2" })] }), vg = (e2) => jsxs("svg", { width: "16", height: "16", viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...e2, children: [jsx("rect", { x: "1.333", y: "6", width: "13.333", height: "4", rx: "2", fill: "rgb(var(--oui-color-primary))" }), jsx("rect", { x: "2.667", y: "12", width: "10.667", height: "1.333", rx: ".667", fill: "#fff", fillOpacity: ".2" }), jsx("rect", { x: "2.667", y: "2.667", width: "10.667", height: "1.333", rx: ".667", fill: "#fff", fillOpacity: ".2" })] }), Tg = (e2) => jsxs("svg", { width: "16", height: "16", viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...e2, children: [jsx("rect", { x: "1.333", y: "9.333", width: "13.333", height: "4", rx: "2", fill: "rgb(var(--oui-color-primary))" }), jsx("rect", { x: "2.667", y: "6", width: "10.667", height: "1.333", rx: ".667", fill: "#fff", fillOpacity: ".2" }), jsx("rect", { x: "2.667", y: "2.667", width: "10.667", height: "1.333", rx: ".667", fill: "#fff", fillOpacity: ".2" })] });
var Ta = (e2) => {
  let { collapsable: t, collapsed: o2, onCollapse: i, layout: r3, onLayout: n4, orderBookSplitSize: a2, setOrderbookSplitSize: s2, dataListSplitSize: c, setDataListSplitSize: l2, mainSplitSize: d2, setMainSplitSize: u2, dataListSplitHeightSM: m2, setDataListSplitHeightSM: g2, orderBookSplitHeightSM: f2, setOrderbookSplitHeightSM: p2, max2XL: S2, max4XL: y2, animating: C2, setAnimating: N2, positions: b2, updatePositions: w4, showPositionIcon: q2, horizontalDraggable: x2, marketsWidth: A2, tradindviewMaxHeight: J2, dataListMinHeight: Q2 } = e2, xe2 = Ei + zi + we + me + Q2 + ee * 4, O2 = Ei + zi + we + Ie2 + me + Q2 + ee * 4, _2 = jsx(mn, { collapsable: t, collapsed: o2, onCollapse: i, symbol: e2.symbol, onSymbolChange: e2.onSymbolChange }), j2 = jsx(W$2, { intensity: 900, pt: 3, r: "2xl", height: "100%", width: A2, style: { minWidth: A2 }, className: "oui-transition-all oui-duration-150", onTransitionEnd: () => {
    N2(false);
  }, children: !C2 && _2 }), Ke2 = useMemo(() => jsx(va, { layout: r3, onLayout: n4 }), [r3, n4]), Ae2 = jsx(W$2, { intensity: 900, r: "2xl", px: 3, width: "100%", style: { minHeight: we, height: we }, children: jsx(ni$1, { symbol: e2.symbol, onSymbolChange: e2.onSymbolChange, trailing: Ke2 }) }), { library_path: ka2, ...Da2 } = e2.tradingViewConfig, $i2 = jsx(Si$1, { symbol: e2.symbol, ...Da2, libraryPath: ka2 }), Qi2 = jsx(W$2, { width: "100%", height: "100%", intensity: 900, r: "2xl", style: { flex: 1, minWidth: xt }, className: "oui-overflow-hidden", children: $i2 }), Ki = jsx(qo, { symbol: e2.symbol }), La2 = jsx(W$2, { r: "2xl", height: "100%", style: { minWidth: bt, maxWidth: x2 ? Sa : bt, width: a2 }, className: "oui-overflow-hidden", children: Ki }), Yi2 = jsx(ao, { current: void 0, symbol: e2.symbol, sharePnLConfig: e2.sharePnLConfig }), Fa2 = jsx(W$2, { intensity: 900, r: "2xl", p: 3, style: { height: c, minHeight: Q2 }, className: "oui-overflow-hidden", children: Yi2 }), Ba2 = [jsx(Xt, { className: "oui-border oui-border-line-12", index: b2.findIndex((le2) => le2 === 0), onLayout: w4, showIndicator: q2, children: jsx(So, {}) }, "assets"), jsx(Xt, { index: b2.findIndex((le2) => le2 === 1), onLayout: w4, showIndicator: q2, children: jsx(uo, { symbol: e2.symbol }) }, "orderEntry"), jsx(Xt, { index: b2.findIndex((le2) => le2 === 2), onLayout: w4, showIndicator: q2, children: jsx(zo, {}) }, "margin")], Xi2 = b2.map((le2) => Ba2[le2]), Zi2 = jsx(z$3, { gapY: 3, direction: "column", height: "100%", style: { minWidth: Qt, maxWidth: x2 ? ya : Qt, width: d2 }, children: Xi2 }), Ji2 = jsxs(qe2, { style: { flex: 1, minHeight: me }, onSizeChange: s2, disable: !x2, children: [y2 && r3 === "right" ? jsxs(z$3, { gap: 3, className: "oui-flex-1 oui-overflow-hidden", style: { minWidth: A2 + xt + ee }, children: [j2, Qi2] }) : Qi2, La2] }), Oa = () => y2 && r3 === "left" ? jsxs(z$3, { gapX: 3, style: { minHeight: me }, height: "100%", children: [Ji2, j2] }) : Ji2, Ra2 = jsxs(z$3, { direction: "column", className: "oui-flex-1 oui-overflow-hidden", gap: 3, style: { minWidth: y2 ? A2 + xt + bt + ee * 2 : xt + bt + ee }, children: [Ae2, jsxs(qe2, { className: "oui-w-full !oui-h-[calc(100%_-_54px_-_12px)]", mode: "vertical", onSizeChange: l2, children: [Oa(), Fa2] })] }), Ia2 = (le2) => u2(r3 === "left" ? Ca(le2) : le2);
  return S2 ? jsxs(qe2, { ref: e2.max2XLSplitRef, style: { minHeight: O2, minWidth: 1024 - Hi }, className: cnBase("oui-flex oui-flex-1 ", "oui-min-w-[1018px] oui-h-full oui-w-full", "oui-p-3", e2.className), onSizeChange: g2, onDragging: e2.onDataListSplitHeightDragging, mode: "vertical", children: [jsxs(z$3, { gapX: 3, itemAlign: "stretch", className: cnBase("oui-flex-1", r3 === "left" && "oui-flex-row-reverse"), style: { minHeight: Math.max(we + Ie2 + me + ee * 2, e2.orderEntryHeight), maxHeight: we + J2 + Re + ee * 2 }, children: [jsxs(z$3, { height: "100%", className: "oui-flex-1 oui-w-[calc(100%_-_280px_-_12px)]", direction: "column", gapY: 3, children: [Ae2, jsxs(z$3, { width: "100%", height: "100%", gapX: 3, itemAlign: "stretch", style: { minHeight: Ie2 + me + ee, maxHeight: J2 + Re + ee }, className: cnBase("oui-flex-1", r3 === "left" && "oui-flex-row-reverse"), children: [jsx(W$2, { intensity: 900, pt: 3, r: "2xl", width: A2, style: { minHeight: Ie2 + me + ee, maxHeight: J2 + Re + ee }, children: _2 }), jsxs(qe2, { ref: e2.tradingviewAndOrderbookSplitRef, mode: "vertical", style: { width: `calc(100% - ${A2}px)` }, className: "oui-flex-1", onSizeChange: p2, onDragging: e2.onTradingviewAndOrderbookDragging, children: [jsx(W$2, { width: "100%", intensity: 900, r: "2xl", style: { minHeight: Ie2, maxHeight: J2, height: 1200 }, children: $i2 }), jsx(W$2, { r: "2xl", height: "100%", width: "100%", style: { minHeight: me, maxHeight: Re, height: f2 }, className: "oui-flex-1", children: Ki })] })] })] }), jsxs(z$3, { ref: e2.orderEntryViewRef, gapY: 3, direction: "column", style: { width: Qt, height: "max-content" }, children: [Xi2, jsx(W$2, { height: e2.extraHeight })] })] }), jsx(W$2, { intensity: 900, r: "2xl", p: 3, style: { height: m2, minHeight: Math.max(Q2, e2.dataListHeight), maxHeight: Wi }, className: "oui-overflow-hidden", children: Yi2 })] }) : jsxs(z$3, { style: { minHeight: xe2, minWidth: 1440 - Hi }, className: cnBase(e2.className, r3 === "left" && "oui-flex-row-reverse"), width: "100%", p: 3, gap: 3, children: [!y2 && j2, jsxs(qe2, { className: "oui-flex oui-flex-1 oui-overflow-hidden", onSizeChange: Ia2, disable: !x2, children: [r3 === "left" && Zi2, Ra2, r3 === "right" && Zi2] })] });
};
var Gi = (e2) => {
  let { isMobile: t } = it$6();
  return t ? jsx(ba, { ...e2 }) : jsx(Ta, { className: "oui-h-[calc(100vh_-_48px_-_29px)] oui-bg-base-10", ...e2 });
};
var Ui = () => {
  let e2 = Vi();
  return jsx(Gi, { ...e2 });
};
var Og = (e2) => jsx(lr, { symbol: e2.symbol, tradingViewConfig: e2.tradingViewConfig, onSymbolChange: e2.onSymbolChange, disableFeatures: e2.disableFeatures, overrideFeatures: e2.overrideFeatures, referral: e2.referral, tradingRewards: e2.tradingRewards, bottomSheetLeading: e2.bottomSheetLeading, sharePnLConfig: e2.sharePnLConfig, children: jsx(Ui, {}) });
const DEFAULT_SYMBOL = "PERP_ETH_USDC";
const ORDERLY_SYMBOL_KEY = "orderly-current-symbol";
function getSymbol() {
  return localStorage.getItem(ORDERLY_SYMBOL_KEY) || DEFAULT_SYMBOL;
}
function updateSymbol(symbol) {
  localStorage.setItem(ORDERLY_SYMBOL_KEY, symbol || DEFAULT_SYMBOL);
}
const meta$8 = () => {
  return [{ title: generatePageTitle("Positions") }];
};
function PositionsPage() {
  const local = G();
  const navigate = useNavigate();
  const [searchParams] = useSearchParams();
  const onSymbolChange = useCallback(
    (data) => {
      const symbol = data.symbol;
      updateSymbol(symbol);
      const searchParamsString = searchParams.toString();
      const queryString = searchParamsString ? `?${searchParamsString}` : "";
      navigate(`/perp/${symbol}${queryString}`);
    },
    [navigate, searchParams]
  );
  return /* @__PURE__ */ jsx(
    W$2,
    {
      p: 6,
      pb: 0,
      intensity: 900,
      r: "xl",
      width: "100%",
      style: {
        minHeight: 379,
        maxHeight: 2560,
        overflow: "hidden",
        // Make the table scroll instead of the page scroll
        height: "calc(100vh - 48px - 29px - 48px)"
      },
      children: /* @__PURE__ */ jsx(
        sr$2.PositionsPage,
        {
          sharePnLConfig: config.tradingPage.sharePnLConfig,
          pnlNotionalDecimalPrecision: local.pnlNotionalDecimalPrecision,
          calcMode: local.unPnlPriceBasis,
          onSymbolChange
        }
      )
    }
  );
}
const route1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: PositionsPage,
  meta: meta$8
}, Symbol.toStringTag, { value: "Module" }));
const meta$7 = () => {
  return [{ title: generatePageTitle("API keys") }];
};
function APIKeyPage() {
  return /* @__PURE__ */ jsx(Ar$1.APIManagerPage, {});
}
const route2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: APIKeyPage,
  meta: meta$7
}, Symbol.toStringTag, { value: "Module" }));
const meta$6 = () => {
  return [{ title: generatePageTitle("Settings") }];
};
function SettingsPage() {
  return /* @__PURE__ */ jsx(Mr$1.SettingPage, {});
}
const route3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: SettingsPage,
  meta: meta$6
}, Symbol.toStringTag, { value: "Module" }));
const meta$5 = () => {
  return [{ title: generatePageTitle("Portfolio") }];
};
function PortfolioPage() {
  return /* @__PURE__ */ jsx(Qi.OverviewPage, {});
}
const route4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: PortfolioPage,
  meta: meta$5
}, Symbol.toStringTag, { value: "Module" }));
const meta$4 = () => {
  return [{ title: generatePageTitle("Orders") }];
};
function OrdersPage() {
  return /* @__PURE__ */ jsx(
    W$2,
    {
      p: 6,
      pb: 0,
      intensity: 900,
      r: "xl",
      width: "100%",
      style: {
        minHeight: 379,
        maxHeight: 2560,
        overflow: "hidden",
        // Make the table scroll instead of the page scroll
        height: "calc(100vh - 48px - 29px - 48px)"
      },
      children: /* @__PURE__ */ jsx(ur$2.OrdersPage, {})
    }
  );
}
const route5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: OrdersPage,
  meta: meta$4
}, Symbol.toStringTag, { value: "Module" }));
const meta$3 = () => {
  return [{ title: generatePageTitle("Markets") }];
};
function MarketsPage$1() {
  return /* @__PURE__ */ jsx(qi, { className: "overflow-x-auto" });
}
const route6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: MarketsPage$1,
  meta: meta$3
}, Symbol.toStringTag, { value: "Module" }));
const meta$2 = () => {
  return [{ title: generatePageTitle("Fee tier") }];
};
function FeeTierPage() {
  return /* @__PURE__ */ jsx(rr.FeeTierPage, { dataAdapter: () => ({
    columns: [],
    dataSource: []
  }) });
}
const route7 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: FeeTierPage,
  meta: meta$2
}, Symbol.toStringTag, { value: "Module" }));
const meta$1 = ({ params }) => {
  return [{ title: generatePageTitle(formatSymbol(params.symbol)) }];
};
function PerpPage$1() {
  const params = useParams();
  const [symbol, setSymbol] = useState(params.symbol);
  const navigate = useNavigate();
  const [searchParams] = useSearchParams();
  useEffect(() => {
    updateSymbol(symbol);
  }, [symbol]);
  const onSymbolChange = useCallback(
    (data) => {
      const symbol2 = data.symbol;
      setSymbol(symbol2);
      const searchParamsString = searchParams.toString();
      const queryString = searchParamsString ? `?${searchParamsString}` : "";
      navigate(`/perp/${symbol2}${queryString}`);
    },
    [navigate, searchParams]
  );
  return /* @__PURE__ */ jsx(
    Og,
    {
      symbol,
      onSymbolChange,
      tradingViewConfig: config.tradingPage.tradingViewConfig,
      sharePnLConfig: config.tradingPage.sharePnLConfig
    }
  );
}
const route8 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: PerpPage$1,
  meta: meta$1
}, Symbol.toStringTag, { value: "Module" }));
function useNav() {
  const navigate = useNavigate();
  const [searchParams] = useSearchParams();
  const onRouteChange = useCallback(
    (option) => {
      const searchParamsString = searchParams.toString();
      const queryString = searchParamsString ? `?${searchParamsString}` : "";
      if (option.target === "_blank") {
        window.open(option.href);
        return;
      }
      if (option.href === "/") {
        const symbol = getSymbol();
        navigate(`/perp/${symbol}${queryString}`);
        return;
      }
      const routeMap = {
        //   "/portfolio": "/portfolio",
        "/portfolio/feeTier": "/portfolio/fee",
        "/portfolio/apiKey": "/portfolio/api-key"
        //   "/portfolio/positions": "/portfolio/positions",
        //   "/portfolio/orders": "/portfolio/orders",
        //   "/portfolio/setting": "/portfolio/setting",
      };
      const path2 = routeMap[option.href] || option.href;
      navigate(`${path2}${queryString}`);
    },
    [navigate, searchParams]
  );
  return { onRouteChange };
}
function PortfolioLayout() {
  const location = useLocation();
  const pathname = location.pathname;
  const { onRouteChange } = useNav();
  const currentPath = useMemo(() => {
    if (pathname.endsWith("/portfolio")) return "/portfolio";
    if (pathname.endsWith("/portfolio/fee")) return "/portfolio/feeTier";
    if (pathname.endsWith("/portfolio/api-key")) return "/portfolio/apiKey";
    return pathname;
  }, [pathname]);
  return /* @__PURE__ */ jsx(
    Aa,
    {
      footerProps: config.scaffold.footerProps,
      mainNavProps: {
        ...config.scaffold.mainNavProps,
        initialMenu: "/portfolio"
      },
      routerAdapter: {
        onRouteChange
      },
      leftSideProps: {
        current: currentPath
      },
      bottomNavProps: {
        ...config.scaffold.bottomNavProps,
        current: "/portfolio"
      },
      children: /* @__PURE__ */ jsx(Outlet, {})
    }
  );
}
const route9 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: PortfolioLayout
}, Symbol.toStringTag, { value: "Module" }));
function MarketsPage() {
  const { onRouteChange } = useNav();
  return /* @__PURE__ */ jsx(
    Sn$1,
    {
      mainNavProps: {
        ...config.scaffold.mainNavProps,
        initialMenu: "/markets"
      },
      footerProps: config.scaffold.footerProps,
      bottomNavProps: {
        ...config.scaffold.bottomNavProps,
        current: "/markets"
      },
      routerAdapter: {
        onRouteChange
      },
      children: /* @__PURE__ */ jsx(Outlet, {})
    }
  );
}
const route10 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: MarketsPage
}, Symbol.toStringTag, { value: "Module" }));
const meta = () => {
  return [
    { title: "NincoFi" },
    { name: "description", content: "NincoFi" }
  ];
};
const loader = ({ request: request2 }) => {
  const url = new URL(request2.url);
  const searchParamsString = url.search;
  const queryString = searchParamsString || "";
  return redirect(`/perp/${DEFAULT_SYMBOL}${queryString}`);
};
const route11 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  loader,
  meta
}, Symbol.toStringTag, { value: "Module" }));
function PerpPage() {
  const { onRouteChange } = useNav();
  return /* @__PURE__ */ jsx(
    Sn$1,
    {
      mainNavProps: config.scaffold.mainNavProps,
      footerProps: config.scaffold.footerProps,
      routerAdapter: {
        onRouteChange,
        currentPath: "/"
      },
      bottomNavProps: config.scaffold.bottomNavProps,
      children: /* @__PURE__ */ jsx(Outlet, {})
    }
  );
}
const route12 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: PerpPage
}, Symbol.toStringTag, { value: "Module" }));
const serverManifest = { "entry": { "module": "/assets/entry.client-Jc1UIblO.js", "imports": ["/assets/index-_b-vxSi4.js", "/assets/client-Df-1iYcO.js", "/assets/components-GEXnQvz7.js"], "css": [] }, "routes": { "root": { "id": "root", "parentId": void 0, "path": "", "index": void 0, "caseSensitive": void 0, "hasAction": false, "hasLoader": false, "hasClientAction": false, "hasClientLoader": false, "hasErrorBoundary": false, "module": "/assets/root-CzQDrqJr.js", "imports": ["/assets/index-_b-vxSi4.js", "/assets/client-Df-1iYcO.js", "/assets/components-GEXnQvz7.js", "/assets/root-BQhSKGNt.js", "/assets/index-CCYrsEij.js", "/assets/index-DpsezUsw.js", "/assets/config-waRDqy7G.js", "/assets/utils-CryvheNm.js"], "css": ["/assets/root-RPrduSxJ.css"] }, "routes/portfolio.positions": { "id": "routes/portfolio.positions", "parentId": "routes/portfolio", "path": "positions", "index": void 0, "caseSensitive": void 0, "hasAction": false, "hasLoader": false, "hasClientAction": false, "hasClientLoader": false, "hasErrorBoundary": false, "module": "/assets/portfolio.positions-C3jkQLY0.js", "imports": ["/assets/index-_b-vxSi4.js", "/assets/index-CCYrsEij.js", "/assets/index-C_p0Ylx7.js", "/assets/index-Ba_HO5IA.js", "/assets/storage-CT6iC30N.js", "/assets/config-waRDqy7G.js", "/assets/utils-CryvheNm.js", "/assets/components-GEXnQvz7.js", "/assets/index-DDwcgkyU.js", "/assets/index-DpsezUsw.js", "/assets/Trans-uQ8RFcOU.js", "/assets/index-w6nujGiB.js", "/assets/embla-carousel-react.esm-DDFcFn3T.js", "/assets/index-B7YROe-e.js"], "css": ["/assets/index-CTpUD00e.css"] }, "routes/portfolio.api-key": { "id": "routes/portfolio.api-key", "parentId": "routes/portfolio", "path": "api-key", "index": void 0, "caseSensitive": void 0, "hasAction": false, "hasLoader": false, "hasClientAction": false, "hasClientLoader": false, "hasErrorBoundary": false, "module": "/assets/portfolio.api-key-B11MX-TB.js", "imports": ["/assets/index-_b-vxSi4.js", "/assets/index-C_p0Ylx7.js", "/assets/utils-CryvheNm.js", "/assets/index-CCYrsEij.js", "/assets/index-DDwcgkyU.js", "/assets/index-DpsezUsw.js", "/assets/Trans-uQ8RFcOU.js", "/assets/index-w6nujGiB.js", "/assets/embla-carousel-react.esm-DDFcFn3T.js"], "css": [] }, "routes/portfolio.setting": { "id": "routes/portfolio.setting", "parentId": "routes/portfolio", "path": "setting", "index": void 0, "caseSensitive": void 0, "hasAction": false, "hasLoader": false, "hasClientAction": false, "hasClientLoader": false, "hasErrorBoundary": false, "module": "/assets/portfolio.setting-BhP2hBXy.js", "imports": ["/assets/index-_b-vxSi4.js", "/assets/index-C_p0Ylx7.js", "/assets/utils-CryvheNm.js", "/assets/index-CCYrsEij.js", "/assets/index-DDwcgkyU.js", "/assets/index-DpsezUsw.js", "/assets/Trans-uQ8RFcOU.js", "/assets/index-w6nujGiB.js", "/assets/embla-carousel-react.esm-DDFcFn3T.js"], "css": [] }, "routes/portfolio._index": { "id": "routes/portfolio._index", "parentId": "routes/portfolio", "path": void 0, "index": true, "caseSensitive": void 0, "hasAction": false, "hasLoader": false, "hasClientAction": false, "hasClientLoader": false, "hasErrorBoundary": false, "module": "/assets/portfolio._index-Bq60gsfe.js", "imports": ["/assets/index-_b-vxSi4.js", "/assets/index-C_p0Ylx7.js", "/assets/utils-CryvheNm.js", "/assets/index-CCYrsEij.js", "/assets/index-DDwcgkyU.js", "/assets/index-DpsezUsw.js", "/assets/Trans-uQ8RFcOU.js", "/assets/index-w6nujGiB.js", "/assets/embla-carousel-react.esm-DDFcFn3T.js"], "css": [] }, "routes/portfolio.orders": { "id": "routes/portfolio.orders", "parentId": "routes/portfolio", "path": "orders", "index": void 0, "caseSensitive": void 0, "hasAction": false, "hasLoader": false, "hasClientAction": false, "hasClientLoader": false, "hasErrorBoundary": false, "module": "/assets/portfolio.orders-xd8C8wNz.js", "imports": ["/assets/index-_b-vxSi4.js", "/assets/index-CCYrsEij.js", "/assets/index-C_p0Ylx7.js", "/assets/utils-CryvheNm.js", "/assets/index-DDwcgkyU.js", "/assets/index-DpsezUsw.js", "/assets/Trans-uQ8RFcOU.js", "/assets/index-w6nujGiB.js", "/assets/embla-carousel-react.esm-DDFcFn3T.js"], "css": [] }, "routes/markets._index": { "id": "routes/markets._index", "parentId": "routes/markets", "path": void 0, "index": true, "caseSensitive": void 0, "hasAction": false, "hasLoader": false, "hasClientAction": false, "hasClientLoader": false, "hasErrorBoundary": false, "module": "/assets/markets._index-BNQhwxRu.js", "imports": ["/assets/index-_b-vxSi4.js", "/assets/index-B7YROe-e.js", "/assets/utils-CryvheNm.js", "/assets/index-CCYrsEij.js", "/assets/embla-carousel-react.esm-DDFcFn3T.js", "/assets/Trans-uQ8RFcOU.js"], "css": [] }, "routes/portfolio.fee": { "id": "routes/portfolio.fee", "parentId": "routes/portfolio", "path": "fee", "index": void 0, "caseSensitive": void 0, "hasAction": false, "hasLoader": false, "hasClientAction": false, "hasClientLoader": false, "hasErrorBoundary": false, "module": "/assets/portfolio.fee-B9kU_f3R.js", "imports": ["/assets/index-_b-vxSi4.js", "/assets/index-C_p0Ylx7.js", "/assets/utils-CryvheNm.js", "/assets/index-CCYrsEij.js", "/assets/index-DDwcgkyU.js", "/assets/index-DpsezUsw.js", "/assets/Trans-uQ8RFcOU.js", "/assets/index-w6nujGiB.js", "/assets/embla-carousel-react.esm-DDFcFn3T.js"], "css": [] }, "routes/perp.$symbol": { "id": "routes/perp.$symbol", "parentId": "routes/perp", "path": ":symbol", "index": void 0, "caseSensitive": void 0, "hasAction": false, "hasLoader": false, "hasClientAction": false, "hasClientLoader": false, "hasErrorBoundary": false, "module": "/assets/perp._symbol-BGy0KxZ_.js", "imports": ["/assets/index-_b-vxSi4.js", "/assets/index-Ba_HO5IA.js", "/assets/config-waRDqy7G.js", "/assets/storage-CT6iC30N.js", "/assets/utils-CryvheNm.js", "/assets/components-GEXnQvz7.js", "/assets/index-CCYrsEij.js", "/assets/index-w6nujGiB.js", "/assets/index-DpsezUsw.js", "/assets/index-DDwcgkyU.js", "/assets/Trans-uQ8RFcOU.js", "/assets/embla-carousel-react.esm-DDFcFn3T.js", "/assets/index-B7YROe-e.js"], "css": ["/assets/index-CTpUD00e.css"] }, "routes/portfolio": { "id": "routes/portfolio", "parentId": "root", "path": "portfolio", "index": void 0, "caseSensitive": void 0, "hasAction": false, "hasLoader": false, "hasClientAction": false, "hasClientLoader": false, "hasErrorBoundary": false, "module": "/assets/portfolio-DcWSB9Y7.js", "imports": ["/assets/index-_b-vxSi4.js", "/assets/index-C_p0Ylx7.js", "/assets/config-waRDqy7G.js", "/assets/useNav-bs4hxWmT.js", "/assets/components-GEXnQvz7.js", "/assets/index-CCYrsEij.js", "/assets/index-DDwcgkyU.js", "/assets/index-DpsezUsw.js", "/assets/Trans-uQ8RFcOU.js", "/assets/index-w6nujGiB.js", "/assets/embla-carousel-react.esm-DDFcFn3T.js", "/assets/storage-CT6iC30N.js"], "css": [] }, "routes/markets": { "id": "routes/markets", "parentId": "root", "path": "markets", "index": void 0, "caseSensitive": void 0, "hasAction": false, "hasLoader": false, "hasClientAction": false, "hasClientLoader": false, "hasErrorBoundary": false, "module": "/assets/markets-D7QeaUYG.js", "imports": ["/assets/index-_b-vxSi4.js", "/assets/index-DDwcgkyU.js", "/assets/config-waRDqy7G.js", "/assets/useNav-bs4hxWmT.js", "/assets/components-GEXnQvz7.js", "/assets/index-CCYrsEij.js", "/assets/index-DpsezUsw.js", "/assets/Trans-uQ8RFcOU.js", "/assets/storage-CT6iC30N.js"], "css": [] }, "routes/_index": { "id": "routes/_index", "parentId": "root", "path": void 0, "index": true, "caseSensitive": void 0, "hasAction": false, "hasLoader": true, "hasClientAction": false, "hasClientLoader": false, "hasErrorBoundary": false, "module": "/assets/_index-DcRuBjQm.js", "imports": [], "css": [] }, "routes/perp": { "id": "routes/perp", "parentId": "root", "path": "perp", "index": void 0, "caseSensitive": void 0, "hasAction": false, "hasLoader": false, "hasClientAction": false, "hasClientLoader": false, "hasErrorBoundary": false, "module": "/assets/perp-BnDTpAsw.js", "imports": ["/assets/index-_b-vxSi4.js", "/assets/index-DDwcgkyU.js", "/assets/config-waRDqy7G.js", "/assets/useNav-bs4hxWmT.js", "/assets/components-GEXnQvz7.js", "/assets/index-CCYrsEij.js", "/assets/index-DpsezUsw.js", "/assets/Trans-uQ8RFcOU.js", "/assets/storage-CT6iC30N.js"], "css": [] } }, "url": "/assets/manifest-c7b7ff26.js", "version": "c7b7ff26" };
const mode = "production";
const assetsBuildDirectory = "build/client";
const basename = "/";
const future = { "v3_fetcherPersist": true, "v3_relativeSplatPath": true, "v3_throwAbortReason": true, "v3_routeConfig": false, "v3_singleFetch": true, "v3_lazyRouteDiscovery": true, "unstable_optimizeDeps": false };
const isSpaMode = false;
const publicPath = "/";
const entry = { module: entryServer };
const routes = {
  "root": {
    id: "root",
    parentId: void 0,
    path: "",
    index: void 0,
    caseSensitive: void 0,
    module: route0
  },
  "routes/portfolio.positions": {
    id: "routes/portfolio.positions",
    parentId: "routes/portfolio",
    path: "positions",
    index: void 0,
    caseSensitive: void 0,
    module: route1
  },
  "routes/portfolio.api-key": {
    id: "routes/portfolio.api-key",
    parentId: "routes/portfolio",
    path: "api-key",
    index: void 0,
    caseSensitive: void 0,
    module: route2
  },
  "routes/portfolio.setting": {
    id: "routes/portfolio.setting",
    parentId: "routes/portfolio",
    path: "setting",
    index: void 0,
    caseSensitive: void 0,
    module: route3
  },
  "routes/portfolio._index": {
    id: "routes/portfolio._index",
    parentId: "routes/portfolio",
    path: void 0,
    index: true,
    caseSensitive: void 0,
    module: route4
  },
  "routes/portfolio.orders": {
    id: "routes/portfolio.orders",
    parentId: "routes/portfolio",
    path: "orders",
    index: void 0,
    caseSensitive: void 0,
    module: route5
  },
  "routes/markets._index": {
    id: "routes/markets._index",
    parentId: "routes/markets",
    path: void 0,
    index: true,
    caseSensitive: void 0,
    module: route6
  },
  "routes/portfolio.fee": {
    id: "routes/portfolio.fee",
    parentId: "routes/portfolio",
    path: "fee",
    index: void 0,
    caseSensitive: void 0,
    module: route7
  },
  "routes/perp.$symbol": {
    id: "routes/perp.$symbol",
    parentId: "routes/perp",
    path: ":symbol",
    index: void 0,
    caseSensitive: void 0,
    module: route8
  },
  "routes/portfolio": {
    id: "routes/portfolio",
    parentId: "root",
    path: "portfolio",
    index: void 0,
    caseSensitive: void 0,
    module: route9
  },
  "routes/markets": {
    id: "routes/markets",
    parentId: "root",
    path: "markets",
    index: void 0,
    caseSensitive: void 0,
    module: route10
  },
  "routes/_index": {
    id: "routes/_index",
    parentId: "root",
    path: void 0,
    index: true,
    caseSensitive: void 0,
    module: route11
  },
  "routes/perp": {
    id: "routes/perp",
    parentId: "root",
    path: "perp",
    index: void 0,
    caseSensitive: void 0,
    module: route12
  }
};
export {
  serverManifest as assets,
  assetsBuildDirectory,
  basename,
  entry,
  future,
  isSpaMode,
  mode,
  publicPath,
  routes
};
