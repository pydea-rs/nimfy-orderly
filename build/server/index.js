var __defProp = Object.defineProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var __privateWrapper = (obj, member, setter, getter) => ({
  set _(value) {
    __privateSet(obj, member, value, setter);
  },
  get _() {
    return __privateGet(obj, member, getter);
  }
});
var _listener, _listeners, _cancelled, _allowInsecure, _gzip, _headers, _method, _timeout, _url, _body, _bodyType, _creds, _preflight, _process, _retry, _signal, _throttle, _getUrlFunc, _FetchRequest_instances, send_fn, _statusCode, _statusMessage, _headers2, _body2, _request, _error, _format, _val, _tens, _FixedNumber_instances, checkFormat_fn, checkValue_fn, add_fn, sub_fn, mul_fn, div_fn, _names, _data, _dataLength, _Writer_instances, writeData_fn, _data2, _offset, _bytesRead, _parent, _maxInflation, _Reader_instances, incrementBytesRead_fn, peekBytes_fn, _r2, _s, _v, _networkV, _privateKey, _options, _type, _to, _data3, _nonce, _gasLimit, _gasPrice, _maxPriorityFeePerGas, _maxFeePerGas, _value, _chainId, _sig, _accessList, _maxFeePerBlobGas, _blobVersionedHashes, _kzg, _blobs, _Transaction_instances, getSerialized_fn, _types, _fullTypes, _encoderCache, _TypedDataEncoder_instances, getEncoder_fn, _offset2, _tokens, _TokenString_instances, subTokenString_fn, _ParamType_instances, walkAsync_fn, _AbiCoder_instances, getCoder_fn, _errors, _events, _functions, _abiCoder, _Interface_instances, getFunction_fn, getEvent_fn, _transactions, _logs, _startBlock, _iface, _iface2, _filter, _a, _supports2544, _resolver, _EnsResolver_instances, fetch_fn, _EnsResolver_static, getResolver_fn, _url2, _processFunc, _name, _chainId2, _plugins, _provider, _poller, _interval, _blockNumber, _PollingBlockSubscriber_instances, poll_fn, _provider2, _poll, _running, _tag, _lastBlock, _filter2, _hash, _provider3, _filter3, _poller2, _running2, _blockNumber2, _PollingEventSubscriber_instances, poll_fn2, _subs, _plugins2, _pausedState, _destroyed, _networkPromise, _anyNetwork, _performCache, _lastBlockNumber, _nextTimer, _timers, _disableCcipRead, _options2, _AbstractProvider_instances, perform_fn, call_fn, checkNetwork_fn, getAccountValue_fn, getBlock_fn, hasSub_fn, getSub_fn, _provider4, _filterIdPromise, _poller3, _running3, _network, _hault, _FilterIdSubscriber_instances, poll_fn3, teardown_fn, _event, _options3, _nextId, _payloads, _drainTimer, _notReady, _network2, _pendingDetectNetwork, _JsonRpcApiProvider_instances, scheduleDrain_fn, _pollingInterval, _connect, _request2, _b, _c, _d, _e3, _f, _g2, _h, _i2, _j, _k, _l, _m;
import { jsx, jsxs, Fragment as Fragment$1 } from "react/jsx-runtime";
import { PassThrough } from "node:stream";
import { createReadableStreamFromReadable, redirect } from "@remix-run/node";
import { RemixServer, Outlet, Meta, Links, ScrollRestoration, Scripts, useNavigate, useSearchParams, useParams, useLocation } from "@remix-run/react";
import * as isbotModule from "isbot";
import { renderToPipeableStream } from "react-dom/server";
import * as Ce__default from "react";
import Ce__default__default, { createContext, useContext, useState, useEffect, useCallback, useRef, useMemo, useLayoutEffect, useId, forwardRef, Fragment as Fragment$2, memo, useImperativeHandle, useReducer, cloneElement, isValidElement } from "react";
import useSWR, { mutate as mutate$1, useSWRConfig, unstable_serialize as unstable_serialize$1 } from "swr";
import useSWRMutation from "swr/mutation";
import useConstant from "use-constant";
import Jr$5 from "eventemitter3";
import { PublicKey, Connection, clusterApiUrl, Transaction as Transaction$1, TransactionInstruction, SystemProgram, ComputeBudgetProgram, TransactionMessage, VersionedTransaction } from "@solana/web3.js";
import { keccak_256 } from "@noble/hashes/sha3";
import require$$0 from "buffer-polyfill";
import require$$1 from "process";
import a from "decimal.js-light";
import "dayjs";
import __cjsInterop1__$2 from "lodash";
import useSWRInfinite, { unstable_serialize } from "swr/infinite";
import * as amplitude from "@amplitude/analytics-browser";
import { pathOr, prop, omit, propOr, isNil, mergeDeepRight, path, pick, compose, head, lensIndex, over, min } from "ramda";
import { create } from "zustand";
import { immer } from "zustand/middleware/immer";
import useSWRSubscription from "swr/subscription";
import { useDebouncedCallback, useThrottledCallback } from "use-debounce";
import { produce } from "immer";
import * as P$3 from "@noble/ed25519";
import __cjsInterop1__ from "bs58";
import { bytesToHex, hexToBytes } from "ethereum-cryptography/utils";
import { keccak256 as keccak256$1 } from "ethereum-cryptography/keccak";
import __cjsInterop1__$1 from "@coral-xyz/anchor";
import { getAssociatedTokenAddressSync, getAccount } from "@solana/spl-token";
import { addressToBytes32 } from "@layerzerolabs/lz-v2-utilities";
import { OAPP_SEED, PEER_SEED, ENFORCED_OPTIONS_SEED, MESSAGE_LIB_SEED, SEND_LIBRARY_CONFIG_SEED, ENDPOINT_SEED, NONCE_SEED, EVENT_SEED, ULN_SEED, SEND_CONFIG_SEED, EXECUTOR_CONFIG_SEED, PRICE_FEED_SEED, DVN_CONFIG_SEED } from "@layerzerolabs/lz-solana-sdk-v2";
import { WalletAdapterNetwork, WalletNotReadyError, WalletReadyState } from "@solana/wallet-adapter-base";
import { getParsedEthersError } from "@enzoferey/ethers-error-parser";
import { ens_normalize } from "@adraffy/ens-normalize";
import http from "http";
import https from "https";
import { gunzipSync } from "zlib";
import "randombytes";
import require$$1$1 from "create-hash";
import "create-hmac";
import "browserify-sign/algos.js";
import require$$4 from "pbkdf2";
import require$$5 from "browserify-cipher";
import require$$6 from "diffie-hellman";
import require$$7 from "browserify-sign";
import "create-ecdh";
import require$$9 from "public-encrypt";
import require$$10 from "randomfill";
import { secp256k1 } from "@noble/curves/secp256k1";
import { qrcode } from "@akamfoad/qr";
import { WalletProvider, useWallet } from "@solana/wallet-adapter-react";
import { WalletModalProvider, useWalletModal } from "@solana/wallet-adapter-react-ui";
import { createTV, tv, cnBase, cn as cn$3 } from "tailwind-variants";
import { Slot } from "@radix-ui/react-slot";
import { format, isValid, subDays, differenceInDays, getYear, getMonth, getDate, set, addDays, setHours, startOfSecond, startOfMinute, startOfHour, startOfDay, startOfMonth, startOfYear, startOfWeek } from "date-fns";
import * as le$8 from "@radix-ui/react-avatar";
import Sc from "ethereum-blockies-base64";
import * as P$4 from "@radix-ui/react-select";
import { SelectItem, SelectItemText, ItemIndicator } from "@radix-ui/react-select";
import * as j$4 from "@radix-ui/react-popover";
import * as Z$4 from "@radix-ui/react-scroll-area";
import * as Y$5 from "@radix-ui/react-tooltip";
import * as To$2 from "@radix-ui/react-checkbox";
import * as Io$4 from "@radix-ui/react-switch";
import { useReactTable, getFilteredRowModel, getSortedRowModel, getExpandedRowModel, getCoreRowModel, getPaginationRowModel, createColumnHelper, flexRender } from "@tanstack/react-table";
import { enUS, zhCN } from "date-fns/locale";
import { ErrorBoundary } from "react-error-boundary";
import { DayPicker } from "react-day-picker";
import * as B$8 from "@radix-ui/react-dialog";
import * as ee$2 from "@radix-ui/react-tabs";
import * as oe$6 from "@radix-ui/react-hover-card";
import * as xe$5 from "@radix-ui/react-slider";
import toast$2, { Toaster, ToastBar, toast as toast$1 } from "react-hot-toast";
import * as T$1 from "@radix-ui/react-dropdown-menu";
import injectedModule from "@web3-onboard/injected-wallets";
import { init, useConnectWallet, useSetChain } from "@web3-onboard/react";
import binanceModule from "@binance/w3w-blocknative-connector";
import { SolanaMobileWalletAdapter, createDefaultAuthorizationResultCache, createDefaultAddressSelector } from "@solana-mobile/wallet-adapter-mobile";
import { PhantomWalletAdapter } from "@solana/wallet-adapter-wallets";
import { createInstance } from "i18next";
import { I18nContext, useTranslation, Trans } from "react-i18next";
import W$3 from "i18next-browser-languagedetector";
import "@web3-onboard/walletconnect";
import { UTCDateMini } from "@date-fns/utc";
import { ResponsiveContainer, BarChart, Tooltip, CartesianGrid, ReferenceLine, Bar, Cell, YAxis, XAxis, LineChart, Line, Cross } from "recharts";
import nt$4 from "embla-carousel-react";
import _extends from "@babel/runtime/helpers/extends";
import _objectWithoutPropertiesLoose from "@babel/runtime/helpers/objectWithoutPropertiesLoose";
import Rm from "jsqr";
const ABORT_DELAY = 5e3;
function handleRequest(request2, responseStatusCode, responseHeaders, remixContext, loadContext) {
  let prohibitOutOfOrderStreaming = isBotRequest(request2.headers.get("user-agent")) || remixContext.isSpaMode;
  return prohibitOutOfOrderStreaming ? handleBotRequest(
    request2,
    responseStatusCode,
    responseHeaders,
    remixContext
  ) : handleBrowserRequest(
    request2,
    responseStatusCode,
    responseHeaders,
    remixContext
  );
}
function isBotRequest(userAgent) {
  if (!userAgent) {
    return false;
  }
  if ("isbot" in isbotModule && typeof isbotModule.isbot === "function") {
    return isbotModule.isbot(userAgent);
  }
  if ("default" in isbotModule && typeof isbotModule.default === "function") {
    return isbotModule.default(userAgent);
  }
  return false;
}
function handleBotRequest(request2, responseStatusCode, responseHeaders, remixContext) {
  return new Promise((resolve, reject) => {
    let shellRendered = false;
    const { pipe, abort } = renderToPipeableStream(
      /* @__PURE__ */ jsx(
        RemixServer,
        {
          context: remixContext,
          url: request2.url,
          abortDelay: ABORT_DELAY
        }
      ),
      {
        onAllReady() {
          shellRendered = true;
          const body = new PassThrough();
          const stream = createReadableStreamFromReadable(body);
          responseHeaders.set("Content-Type", "text/html");
          resolve(
            new Response(stream, {
              headers: responseHeaders,
              status: responseStatusCode
            })
          );
          pipe(body);
        },
        onShellError(error) {
          reject(error);
        },
        onError(error) {
          responseStatusCode = 500;
          if (shellRendered) {
            console.error(error);
          }
        }
      }
    );
    setTimeout(abort, ABORT_DELAY);
  });
}
function handleBrowserRequest(request2, responseStatusCode, responseHeaders, remixContext) {
  return new Promise((resolve, reject) => {
    let shellRendered = false;
    const { pipe, abort } = renderToPipeableStream(
      /* @__PURE__ */ jsx(
        RemixServer,
        {
          context: remixContext,
          url: request2.url,
          abortDelay: ABORT_DELAY
        }
      ),
      {
        onShellReady() {
          shellRendered = true;
          const body = new PassThrough();
          const stream = createReadableStreamFromReadable(body);
          responseHeaders.set("Content-Type", "text/html");
          resolve(
            new Response(stream, {
              headers: responseHeaders,
              status: responseStatusCode
            })
          );
          pipe(body);
        },
        onShellError(error) {
          reject(error);
        },
        onError(error) {
          responseStatusCode = 500;
          if (shellRendered) {
            console.error(error);
          }
        }
      }
    );
    setTimeout(abort, ABORT_DELAY);
  });
}
const entryServer = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: handleRequest
}, Symbol.toStringTag, { value: "Module" }));
var __defProp$2 = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a2, b2) => {
  for (var prop2 in b2 || (b2 = {}))
    if (__hasOwnProp.call(b2, prop2))
      __defNormalProp2(a2, prop2, b2[prop2]);
  if (__getOwnPropSymbols)
    for (var prop2 of __getOwnPropSymbols(b2)) {
      if (__propIsEnum.call(b2, prop2))
        __defNormalProp2(a2, prop2, b2[prop2]);
    }
  return a2;
};
var __spreadProps = (a2, b2) => __defProps(a2, __getOwnPropDescs(b2));
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e3) {
        reject(e3);
      }
    };
    var step = (x2) => x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
if (typeof window !== "undefined") {
  window.__ORDERLY_VERSION__ = window.__ORDERLY_VERSION__ || {};
  window.__ORDERLY_VERSION__["@orderly.network/net"] = "2.1.0";
}
var ApiError$1 = class ApiError extends Error {
  constructor(message, code) {
    super(message);
    this.code = code;
    this.name = "ApiError";
  }
};
function request(url, options) {
  return __async(this, null, function* () {
    if (!url.startsWith("http")) {
      throw new Error("url must start with http(s)");
    }
    const response = yield fetch(url, __spreadProps(__spreadValues({}, options), {
      // mode: "cors",
      // credentials: "include",
      headers: _createHeaders(options.headers, options.method)
    }));
    if (response.ok) {
      const res = yield response.json();
      return res;
    } else {
      try {
        const errorMsg = yield response.json();
        if (response.status === 400) {
          throw new ApiError$1(
            errorMsg.message || errorMsg.code || response.statusText,
            errorMsg.code
          );
        }
        throw new Error(errorMsg.message || errorMsg.code || response.statusText);
      } catch (e3) {
        throw e3;
      }
    }
  });
}
function _createHeaders(headers = {}, method) {
  const _headers3 = new Headers(headers);
  if (!_headers3.has("Content-Type")) {
    if (method !== "DELETE") {
      _headers3.append("Content-Type", "application/json;charset=utf-8");
    } else {
      _headers3.append("Content-Type", "application/x-www-form-urlencoded");
    }
  }
  return _headers3;
}
function get(url, options, formatter) {
  return __async(this, null, function* () {
    const res = yield request(url, __spreadValues({
      method: "GET"
    }, options));
    if (res.success) {
      if (typeof formatter === "function") {
        return formatter(res.data);
      }
      if (Array.isArray(res.data["rows"])) {
        return res.data["rows"];
      }
      return res.data;
    }
    throw new Error(res.message);
  });
}
function mutate(url, init2) {
  return __async(this, null, function* () {
    const res = yield request(url, init2);
    return res;
  });
}
var BaseHandler = class {
  handle(message, webSocket) {
    throw new Error("Method not implemented.");
  }
};
var PingHandler = class extends BaseHandler {
  handle(_2, webSocket) {
    webSocket.send(JSON.stringify({ event: "pong", ts: Date.now() }));
  }
};
var messageHandlers = /* @__PURE__ */ new Map([
  ["ping", new PingHandler()]
]);
var defaultMessageFormatter = (message) => message.data;
var COMMON_ID = "OqdphuyCtYWxwzhxyLLjOWNdFP7sQt8RPWzmb5xY";
var TIME_OUT = 1e3 * 60 * 2;
var CONNECT_LIMIT = 5;
var WS = class {
  constructor(options) {
    this.options = options;
    this._eventContainer = /* @__PURE__ */ new Map();
    this.publicIsReconnecting = false;
    this.privateIsReconnecting = false;
    this.reconnectInterval = 1e3;
    this.authenticated = false;
    this._pendingPrivateSubscribe = [];
    this._pendingPublicSubscribe = [];
    this._eventHandlers = /* @__PURE__ */ new Map();
    this._eventPrivateHandlers = /* @__PURE__ */ new Map();
    this._publicRetryCount = 0;
    this._privateRetryCount = 0;
    this.send = (message) => {
      if (typeof message !== "string") {
        message = JSON.stringify(message);
      }
      if (typeof message === "undefined")
        return;
      if (this._publicSocket.readyState === WebSocket.OPEN) {
        this._publicSocket.send(message);
      } else {
        console.warn("WebSocket connection is not open. Cannot send message.");
      }
    };
    this.createPublicSC(options);
    if (!!options.accountId) {
      this.createPrivateSC(options);
    }
    this.bindEvents();
  }
  bindEvents() {
    var _a2, _b2;
    if (typeof document !== "undefined") {
      (_a2 = document.addEventListener) == null ? void 0 : _a2.call(
        document,
        "visibilitychange",
        this.onVisibilityChange.bind(this)
      );
    }
    if (typeof window !== "undefined") {
      (_b2 = window.addEventListener) == null ? void 0 : _b2.call(window, "online", this.onNetworkStatusChange.bind(this));
    }
  }
  onVisibilityChange() {
    if (document.visibilityState === "visible") {
      this.checkSocketStatus();
    }
  }
  onNetworkStatusChange() {
    if (navigator.onLine) {
      this.checkSocketStatus();
    }
  }
  /**
   * Determine the current connection status,
   * 1. If it is disconnected, reconnect
   * 2. If no message is received for too long, disconnect and reconnect actively
   * 3. When returning from the background and the network status changes, the following process is followed
   */
  checkSocketStatus() {
    var _a2, _b2;
    const now = Date.now();
    if (document.visibilityState !== "visible")
      return;
    if (!navigator.onLine)
      return;
    if (!this.publicIsReconnecting) {
      if (this._publicSocket.readyState === WebSocket.CLOSED) {
        this.reconnectPublic();
      } else {
        if (now - this._publicHeartbeatTime > TIME_OUT) {
          this._publicSocket.close();
        }
      }
    }
    if (!this.privateIsReconnecting) {
      if (((_a2 = this.privateSocket) == null ? void 0 : _a2.readyState) === WebSocket.CLOSED) {
        this.reconnectPrivate();
      } else {
        if (this._privateHeartbeatTime && now - this._privateHeartbeatTime > TIME_OUT) {
          (_b2 = this.privateSocket) == null ? void 0 : _b2.close();
        }
      }
    }
  }
  openPrivate(accountId) {
    var _a2;
    if (((_a2 = this.privateSocket) == null ? void 0 : _a2.readyState) === WebSocket.OPEN) {
      return;
    }
    this.createPrivateSC(__spreadProps(__spreadValues({}, this.options), {
      accountId
    }));
  }
  closePrivate(code, reason) {
    var _a2, _b2;
    if (((_a2 = this.privateSocket) == null ? void 0 : _a2.readyState) !== WebSocket.OPEN) {
      return;
    }
    this.authenticated = false;
    this._pendingPrivateSubscribe = [];
    this._eventPrivateHandlers.clear();
    (_b2 = this.privateSocket) == null ? void 0 : _b2.close(code, reason);
  }
  createPublicSC(options) {
    if (this._publicSocket && this._publicSocket.readyState === WebSocket.OPEN)
      return;
    this._publicSocket = new WebSocket(
      `${this.options.publicUrl}/ws/stream/${COMMON_ID}`
    );
    this._publicSocket.onopen = this.onOpen.bind(this);
    this._publicSocket.addEventListener(
      "message",
      this.onPublicMessage.bind(this)
    );
    this._publicSocket.addEventListener("close", this.onPublicClose.bind(this));
    this._publicSocket.addEventListener("error", this.onPublicError.bind(this));
  }
  createPrivateSC(options) {
    if (this.privateSocket && this.privateSocket.readyState === WebSocket.OPEN)
      return;
    this.options = options;
    this.privateSocket = new WebSocket(
      `${this.options.privateUrl}/v2/ws/private/stream/${options.accountId}`
    );
    this.privateSocket.onopen = this.onPrivateOpen.bind(this);
    this.privateSocket.onmessage = this.onPrivateMessage.bind(this);
    this.privateSocket.onclose = this.onPrivateClose.bind(this);
    this.privateSocket.onerror = this.onPrivateError.bind(this);
  }
  onOpen(event) {
    if (this._pendingPublicSubscribe.length > 0) {
      this._pendingPublicSubscribe.forEach(([params, cb, isOnce]) => {
        this.subscribe(params, cb, isOnce);
      });
      this._pendingPublicSubscribe = [];
    }
    this.publicIsReconnecting = false;
    this._publicRetryCount = 0;
    this.emit("status:change", { type: "open", isPrivate: false });
  }
  onPrivateOpen(event) {
    this.authenticate(this.options.accountId);
    this.privateIsReconnecting = false;
    this._privateRetryCount = 0;
    this.emit("status:change", { type: "open", isPrivate: true });
  }
  onMessage(event, socket, handlerMap) {
    try {
      const message = JSON.parse(event.data);
      const commoneHandler = messageHandlers.get(message.event);
      if (message.event === "auth" && message.success) {
        this.authenticated = true;
        this.handlePendingPrivateTopic();
        return;
      }
      if (commoneHandler) {
        commoneHandler.handle(message, socket);
      } else {
        const topicKey = this.getTopicKeyFromMessage(message);
        const eventhandler = handlerMap.get(topicKey);
        if (eventhandler == null ? void 0 : eventhandler.callback) {
          eventhandler.callback.forEach((cb) => {
            const data = cb.formatter ? cb.formatter(message) : defaultMessageFormatter(message);
            if (data) {
              cb.onMessage(data);
            }
          });
        }
        this._eventContainer.forEach((_2, key) => {
          const reg = new RegExp(key);
          if (reg.test(topicKey)) {
            this.emit(key, message);
          }
        });
      }
    } catch (e3) {
    }
  }
  onPublicMessage(event) {
    this.onMessage(event, this._publicSocket, this._eventHandlers);
    this._publicHeartbeatTime = Date.now();
  }
  onPrivateMessage(event) {
    this.onMessage(event, this.privateSocket, this._eventPrivateHandlers);
    this._privateHeartbeatTime = Date.now();
  }
  handlePendingPrivateTopic() {
    if (this._pendingPrivateSubscribe.length > 0) {
      this._pendingPrivateSubscribe.forEach(([params, cb]) => {
        this.privateSubscribe(params, cb);
      });
      this._pendingPrivateSubscribe = [];
    }
  }
  onPublicClose(event) {
    this._eventHandlers.forEach((value, key) => {
      value.callback.forEach((cb) => {
        this._pendingPublicSubscribe.push([value.params, cb, value.isOnce]);
      });
      this._eventHandlers.delete(key);
    });
    this.emit("status:change", {
      type: "close",
      isPrivate: false
    });
    setTimeout(() => this.checkSocketStatus(), 0);
  }
  onPrivateClose(event) {
    if (event.code === 1e3)
      return;
    if (this.privateIsReconnecting)
      return;
    this._eventPrivateHandlers.forEach((value, key) => {
      value.callback.forEach((cb) => {
        this._pendingPrivateSubscribe.push([value.params, cb, value.isOnce]);
      });
      this._eventPrivateHandlers.delete(key);
    });
    this.authenticated = false;
    this.emit("status:change", {
      type: "close",
      isPrivate: true,
      event
    });
    setTimeout(() => this.checkSocketStatus(), 0);
  }
  onPublicError(event) {
    console.error("public WebSocket error:", event);
    this.publicIsReconnecting = false;
    if (this._publicSocket.readyState === WebSocket.OPEN) {
      this._publicSocket.close();
    } else {
      if (this._publicRetryCount > CONNECT_LIMIT)
        return;
      setTimeout(() => {
        this.reconnectPublic();
        this._publicRetryCount++;
      }, this._publicRetryCount * 1e3);
    }
    this.errorBoardscast(event, this._eventHandlers);
    this.emit("status:change", {
      type: "error",
      isPrivate: false
    });
  }
  onPrivateError(event) {
    var _a2;
    console.error("Private WebSocket error:", event);
    this.privateIsReconnecting = false;
    if (((_a2 = this.privateSocket) == null ? void 0 : _a2.readyState) === WebSocket.OPEN) {
      this.privateSocket.close();
    } else {
      if (this._privateRetryCount > CONNECT_LIMIT)
        return;
      setTimeout(() => {
        this.reconnectPrivate();
        this._privateRetryCount++;
      }, this._privateRetryCount * 1e3);
    }
    this.errorBoardscast(event, this._eventPrivateHandlers);
    this.emit("status:change", { type: "error", isPrivate: true });
  }
  errorBoardscast(error, eventHandlers) {
    eventHandlers.forEach((value) => {
      value.callback.forEach((cb) => {
        var _a2;
        (_a2 = cb.onError) == null ? void 0 : _a2.call(cb, error);
      });
    });
  }
  close() {
    var _a2;
    this._publicSocket.close();
    (_a2 = this.privateSocket) == null ? void 0 : _a2.close();
  }
  set accountId(accountId) {
  }
  authenticate(accountId) {
    return __async(this, null, function* () {
      var _a2, _b2;
      if (this.authenticated)
        return;
      if (!this.privateSocket) {
        console.error("private ws not connected");
        return;
      }
      if (this.privateSocket.readyState !== WebSocket.OPEN) {
        return;
      }
      const message = yield (_b2 = (_a2 = this.options).onSigntureRequest) == null ? void 0 : _b2.call(_a2, accountId);
      this.privateSocket.send(
        JSON.stringify({
          id: "auth",
          event: "auth",
          params: {
            orderly_key: message.publicKey,
            sign: message.signature,
            timestamp: message.timestamp
          }
        })
      );
    });
  }
  privateSubscribe(params, callback) {
    var _a2;
    const [subscribeMessage, onUnsubscribe] = this.generateMessage(
      params,
      callback.onUnsubscribe
    );
    if (((_a2 = this.privateSocket) == null ? void 0 : _a2.readyState) !== WebSocket.OPEN) {
      this._pendingPrivateSubscribe.push([params, callback]);
      return () => {
        this.unsubscribePrivate(subscribeMessage);
      };
    }
    const topic = subscribeMessage.topic || subscribeMessage.event;
    const handler = this._eventPrivateHandlers.get(topic);
    const callbacks = __spreadProps(__spreadValues({}, callback), {
      onUnsubscribe
    });
    if (!handler) {
      this._eventPrivateHandlers.set(topic, {
        params,
        callback: [callbacks]
      });
      this.privateSocket.send(JSON.stringify(subscribeMessage));
    } else {
      handler.callback.push(callbacks);
    }
    return () => {
      this.unsubscribePrivate(subscribeMessage);
    };
  }
  subscribe(params, callback, once, id2) {
    const [subscribeMessage, onUnsubscribe] = this.generateMessage(
      params,
      callback.onUnsubscribe,
      callback.onMessage
    );
    if (this._publicSocket.readyState !== WebSocket.OPEN) {
      this._pendingPublicSubscribe.push([params, callback, once, id2]);
      if (!once) {
        return () => {
          this.unsubscribePublic(subscribeMessage);
        };
      }
      return;
    }
    let topic = this.getTopicKeyFromParams(subscribeMessage);
    const handler = this._eventHandlers.get(topic);
    const callbacks = __spreadProps(__spreadValues({}, callback), {
      onUnsubscribe
    });
    if (!handler) {
      this._eventHandlers.set(topic, {
        params,
        isOnce: once,
        callback: [callbacks]
      });
      this._publicSocket.send(JSON.stringify(subscribeMessage));
    } else {
      if (once) {
        handler.callback = [callbacks];
        this._publicSocket.send(JSON.stringify(subscribeMessage));
      } else {
        handler.callback.push(callbacks);
      }
    }
    if (!once) {
      return () => {
        this.unsubscribePublic(subscribeMessage);
      };
    }
  }
  getTopicKeyFromParams(params) {
    let topic;
    if (params.topic) {
      topic = params.topic;
    } else {
      params.event;
      topic = params.event;
      if (params.id) {
        topic += `_${params.id}`;
      }
    }
    return topic;
  }
  getTopicKeyFromMessage(message) {
    let topic;
    if (message.topic) {
      topic = message.topic;
    } else {
      if (message.event) {
        topic = `${message.event}`;
        if (message.id) {
          topic += `_${message.id}`;
        }
      }
    }
    return topic;
  }
  // sendPublicMessage(){
  //   if(this.publicSocket.readyState !== )
  // }
  onceSubscribe(params, callback) {
    this.subscribe(params, callback, true);
  }
  unsubscribe(parmas, webSocket, handlerMap) {
    const topic = parmas.topic || parmas.event;
    const handler = handlerMap.get(topic);
    if (!!handler && Array.isArray(handler == null ? void 0 : handler.callback)) {
      if (handler.callback.length === 1) {
        const unsubscribeMessage = handler.callback[0].onUnsubscribe(topic);
        webSocket.send(JSON.stringify(unsubscribeMessage));
        handlerMap.delete(topic);
      } else {
        const index = handler.callback.findIndex(
          (cb) => cb.onMessage === parmas.onMessage
        );
        if (index === -1)
          return;
        handler.callback.splice(index, 1);
      }
    }
  }
  unsubscribePrivate(parmas) {
    this.unsubscribe(parmas, this.privateSocket, this._eventPrivateHandlers);
  }
  unsubscribePublic(parmas) {
    this.unsubscribe(parmas, this._publicSocket, this._eventHandlers);
  }
  generateMessage(params, onUnsubscribe, onMessage) {
    let subscribeMessage;
    if (typeof params === "string") {
      subscribeMessage = { event: "subscribe", topic: params };
    } else {
      subscribeMessage = params;
    }
    if (typeof onUnsubscribe !== "function") {
      if (typeof params === "string") {
        onUnsubscribe = () => ({ event: "unsubscribe", topic: params });
      } else {
        onUnsubscribe = () => ({ event: "unsubscribe", topic: params.topic });
      }
    }
    return [__spreadProps(__spreadValues({}, subscribeMessage), { onMessage }), onUnsubscribe];
  }
  reconnectPublic() {
    if (this.publicIsReconnecting)
      return;
    this.publicIsReconnecting = true;
    if (typeof window === "undefined")
      return;
    window.setTimeout(() => {
      this.createPublicSC(this.options);
      this.emit("status:change", {
        type: "reconnecting",
        isPrivate: false,
        count: this._publicRetryCount
      });
    }, this.reconnectInterval);
  }
  reconnectPrivate() {
    if (!this.options.accountId)
      return;
    if (this.privateIsReconnecting)
      return;
    this.privateIsReconnecting = true;
    if (typeof window === "undefined")
      return;
    window.setTimeout(() => {
      this.createPrivateSC(this.options);
      this.emit("status:change", {
        type: "reconnecting",
        isPrivate: true,
        count: this._privateRetryCount
      });
    }, this.reconnectInterval);
  }
  // get publicSocket(): WebSocket {
  //   return this._publicSocket;
  // }
  get client() {
    return {
      public: this._publicSocket,
      private: this.privateSocket
    };
  }
  on(eventName, callback) {
    var _a2;
    if (this._eventContainer.has(eventName)) {
      (_a2 = this._eventContainer.get(eventName)) == null ? void 0 : _a2.add(callback);
    }
    this._eventContainer.set(eventName, /* @__PURE__ */ new Set([callback]));
  }
  off(eventName, callback) {
    var _a2;
    if (this._eventContainer.has(eventName)) {
      (_a2 = this._eventContainer.get(eventName)) == null ? void 0 : _a2.delete(callback);
    }
  }
  emit(eventName, message) {
    var _a2;
    if (this._eventContainer.has(eventName)) {
      (_a2 = this._eventContainer.get(eventName)) == null ? void 0 : _a2.forEach((cb) => cb(message));
    }
  }
};
if (typeof window !== "undefined") {
  window.__ORDERLY_VERSION__ = window.__ORDERLY_VERSION__ || {};
  window.__ORDERLY_VERSION__["@orderly.network/types"] = "2.1.0";
}
var AccountStatusEnum = /* @__PURE__ */ ((AccountStatusEnum2) => {
  AccountStatusEnum2[AccountStatusEnum2["EnableTradingWithoutConnected"] = -1] = "EnableTradingWithoutConnected";
  AccountStatusEnum2[AccountStatusEnum2["NotConnected"] = 0] = "NotConnected";
  AccountStatusEnum2[AccountStatusEnum2["Connected"] = 1] = "Connected";
  AccountStatusEnum2[AccountStatusEnum2["NotSignedIn"] = 2] = "NotSignedIn";
  AccountStatusEnum2[AccountStatusEnum2["SignedIn"] = 3] = "SignedIn";
  AccountStatusEnum2[AccountStatusEnum2["DisabledTrading"] = 4] = "DisabledTrading";
  AccountStatusEnum2[AccountStatusEnum2["EnableTrading"] = 5] = "EnableTrading";
  return AccountStatusEnum2;
})(AccountStatusEnum || {});
var ARBITRUM_TESTNET_CHAINID = 421614;
var SOLANA_TESTNET_CHAINID = 901901901;
var STORY_TESTNET_CHAINID = 1516;
var MONAD_TESTNET_CHAINID = 10143;
var ARBITRUM_MAINNET_CHAINID = 42161;
var MEDIA_TABLET = "(max-width: 768px)";
var DEPOSIT_FEE_RATE = 1.05;
var MaxUint256 = BigInt(
  "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
);
var nativeTokenAddress = "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE";
var isNativeTokenChecker = (address) => address === nativeTokenAddress;
var ArbitrumSepoliaChainInfo = {
  name: "Arbitrum Sepolia",
  public_rpc_url: "https://arbitrum-sepolia.gateway.tenderly.co",
  chain_id: "421614",
  currency_symbol: "ETH",
  currency_decimal: 18,
  explorer_base_url: "https://sepolia.arbiscan.io",
  vault_address: "0x0EaC556c0C2321BA25b9DC01e4e3c95aD5CDCd2f"
};
var SolanaDevnetChainInfo = {
  chain_id: "901901901",
  currency_decimal: 9,
  currency_symbol: "SOL",
  explorer_base_url: "https://explorer.solana.com/?cluster=devnet",
  name: "Solana-Devnet",
  public_rpc_url: "https://api.devnet.solana.com",
  vault_address: "9shwxWDUNhtwkHocsUAmrNAQfBH2DHh4njdAEdHZZkF2"
};
var SolanaDevnetTokenInfo = {
  chain_id: "901901901",
  contract_address: "4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU",
  decimals: 6,
  withdrawal_fee: 1,
  cross_chain_withdrawal_fee: 5,
  display_name: "USDC"
};
var ArbitrumSepoliaTokenInfo = {
  chain_id: "421614",
  contract_address: "0x75faf114eafb1BDbe2F0316DF893fd58CE46AA4d",
  decimals: 6,
  withdrawal_fee: 1,
  cross_chain_withdrawal_fee: 2,
  display_name: "USDC"
};
var TesntTokenFallback = (testnetTokens) => [
  {
    token: "USDC",
    token_hash: "0xd6aca1be9729c13d677335161321649cccae6a591554772516700f986f942eaa",
    decimals: 6,
    minimum_withdraw_amount: 1e-6,
    chain_details: testnetTokens
  }
];
var OrderType = /* @__PURE__ */ ((OrderType2) => {
  OrderType2["LIMIT"] = "LIMIT";
  OrderType2["MARKET"] = "MARKET";
  OrderType2["IOC"] = "IOC";
  OrderType2["FOK"] = "FOK";
  OrderType2["POST_ONLY"] = "POST_ONLY";
  OrderType2["ASK"] = "ASK";
  OrderType2["BID"] = "BID";
  OrderType2["STOP_LIMIT"] = "STOP_LIMIT";
  OrderType2["STOP_MARKET"] = "STOP_MARKET";
  OrderType2["CLOSE_POSITION"] = "CLOSE_POSITION";
  return OrderType2;
})(OrderType || {});
var BBOOrderType = /* @__PURE__ */ ((BBOOrderType2) => {
  BBOOrderType2["COUNTERPARTY1"] = "counterparty1";
  BBOOrderType2["COUNTERPARTY5"] = "counterparty5";
  BBOOrderType2["QUEUE1"] = "queue1";
  BBOOrderType2["QUEUE5"] = "queue5";
  return BBOOrderType2;
})(BBOOrderType || {});
var OrderLevel = /* @__PURE__ */ ((OrderLevel2) => {
  OrderLevel2[OrderLevel2["ONE"] = 0] = "ONE";
  OrderLevel2[OrderLevel2["TWO"] = 1] = "TWO";
  OrderLevel2[OrderLevel2["THREE"] = 2] = "THREE";
  OrderLevel2[OrderLevel2["FOUR"] = 3] = "FOUR";
  OrderLevel2[OrderLevel2["FIVE"] = 4] = "FIVE";
  return OrderLevel2;
})(OrderLevel || {});
var AlgoOrderRootType = /* @__PURE__ */ ((AlgoOrderRootType2) => {
  AlgoOrderRootType2["TP_SL"] = "TP_SL";
  AlgoOrderRootType2["POSITIONAL_TP_SL"] = "POSITIONAL_TP_SL";
  AlgoOrderRootType2["STOP"] = "STOP";
  AlgoOrderRootType2["BRACKET"] = "BRACKET";
  return AlgoOrderRootType2;
})(AlgoOrderRootType || {});
var TriggerPriceType = /* @__PURE__ */ ((TriggerPriceType2) => {
  TriggerPriceType2["MARK_PRICE"] = "MARK_PRICE";
  return TriggerPriceType2;
})(TriggerPriceType || {});
var AlgoOrderType = /* @__PURE__ */ ((AlgoOrderType2) => {
  AlgoOrderType2["TAKE_PROFIT"] = "TAKE_PROFIT";
  AlgoOrderType2["STOP_LOSS"] = "STOP_LOSS";
  return AlgoOrderType2;
})(AlgoOrderType || {});
var OrderSide = /* @__PURE__ */ ((OrderSide2) => {
  OrderSide2["BUY"] = "BUY";
  OrderSide2["SELL"] = "SELL";
  return OrderSide2;
})(OrderSide || {});
var OrderStatus = /* @__PURE__ */ ((OrderStatus2) => {
  OrderStatus2["OPEN"] = "OPEN";
  OrderStatus2["NEW"] = "NEW";
  OrderStatus2["FILLED"] = "FILLED";
  OrderStatus2["PARTIAL_FILLED"] = "PARTIAL_FILLED";
  OrderStatus2["CANCELLED"] = "CANCELLED";
  OrderStatus2["REPLACED"] = "REPLACED";
  OrderStatus2["COMPLETED"] = "COMPLETED";
  OrderStatus2["INCOMPLETE"] = "INCOMPLETE";
  OrderStatus2["REJECTED"] = "REJECTED";
  return OrderStatus2;
})(OrderStatus || {});
var ChainNamespace = /* @__PURE__ */ ((ChainNamespace2) => {
  ChainNamespace2["evm"] = "EVM";
  ChainNamespace2["solana"] = "SOL";
  return ChainNamespace2;
})(ChainNamespace || {});
var SolanaChains$1 = /* @__PURE__ */ new Set([901901901, 900900900]);
var EnumTrackerKeys = /* @__PURE__ */ ((EnumTrackerKeys2) => {
  EnumTrackerKeys2["withdrawSuccess"] = "withdraw:success";
  EnumTrackerKeys2["withdrawFailed"] = "withdraw:failed";
  EnumTrackerKeys2["depositSuccess"] = "deposit:success";
  EnumTrackerKeys2["depositFailed"] = "deposit:failed";
  EnumTrackerKeys2["signinSuccess"] = "signin:success";
  EnumTrackerKeys2["placeorderSuccess"] = "place_order:success";
  EnumTrackerKeys2["walletConnect"] = "wallet:connected";
  EnumTrackerKeys2["clickLinkDeviceButton"] = "click_link_device_button";
  EnumTrackerKeys2["signLinkDeviceMessageSuccess"] = "sign_link_device_message_success";
  EnumTrackerKeys2["linkDeviceModalClickConfirm"] = "link_device_modal_click_confirm";
  EnumTrackerKeys2["socialLoginSuccess"] = "social_login_success";
  EnumTrackerKeys2["clickSwitchWallet"] = "click_switch_wallet";
  EnumTrackerKeys2["clickSwitchNetwork"] = "click_switch_network";
  EnumTrackerKeys2["switchNetworkSuccess"] = "switch_network_success";
  EnumTrackerKeys2["clickExportPrivateKey"] = "click_export_private_key";
  EnumTrackerKeys2["trackIdentifyUserId"] = "track_identify_user_id";
  return EnumTrackerKeys2;
})(EnumTrackerKeys || {});
var TrackerListenerKeyMap = {
  [
    "withdraw:success"
    /* withdrawSuccess */
  ]: "withdraw_request_success",
  [
    "withdraw:failed"
    /* withdrawFailed */
  ]: "withdraw_request_failure",
  [
    "deposit:success"
    /* depositSuccess */
  ]: "deposit_request_success",
  [
    "deposit:failed"
    /* depositFailed */
  ]: "deposit_request_failure",
  [
    "signin:success"
    /* signinSuccess */
  ]: "sign_message_success",
  [
    "wallet:connected"
    /* walletConnect */
  ]: "connect_wallet_success",
  [
    "place_order:success"
    /* placeorderSuccess */
  ]: "place_order_success",
  [
    "click_link_device_button"
    /* clickLinkDeviceButton */
  ]: "click_link_device_button",
  [
    "sign_link_device_message_success"
    /* signLinkDeviceMessageSuccess */
  ]: "sign_link_device_message_success",
  [
    "link_device_modal_click_confirm"
    /* linkDeviceModalClickConfirm */
  ]: "link_device_modal_click_confirm",
  [
    "social_login_success"
    /* socialLoginSuccess */
  ]: "social_login_success",
  [
    "click_switch_network"
    /* clickSwitchNetwork */
  ]: "click_switch_network",
  [
    "switch_network_success"
    /* switchNetworkSuccess */
  ]: "switch_network_success",
  [
    "click_export_private_key"
    /* clickExportPrivateKey */
  ]: "click_export_private_key",
  [
    "click_switch_wallet"
    /* clickSwitchWallet */
  ]: "click_switch_wallet",
  [
    "track_identify_user_id"
    /* trackIdentifyUserId */
  ]: "track_identify_user_id"
};
var LedgerWalletKey = "orderly:ledger-wallet";
var ChainKey = "order:chain";
var ApiError2 = class extends Error {
  constructor(message, code) {
    super(message);
    this.code = code;
    this.name = "ApiError";
  }
};
var SDKError = class extends Error {
  constructor(message) {
    super(`[ORDERLY SDK ERROR]:${message}`);
    this.name = "SDKError";
  }
};
var definedTypes = {
  EIP712Domain: [
    { name: "name", type: "string" },
    { name: "version", type: "string" },
    { name: "chainId", type: "uint256" },
    { name: "verifyingContract", type: "address" }
  ],
  Registration: [
    { name: "brokerId", type: "string" },
    { name: "chainId", type: "uint256" },
    { name: "timestamp", type: "uint64" },
    { name: "registrationNonce", type: "uint256" }
  ],
  Withdraw: [
    { name: "brokerId", type: "string" },
    { name: "chainId", type: "uint256" },
    { name: "receiver", type: "address" },
    { name: "token", type: "string" },
    { name: "amount", type: "uint256" },
    { name: "withdrawNonce", type: "uint64" },
    { name: "timestamp", type: "uint64" }
  ],
  AddOrderlyKey: [
    { name: "brokerId", type: "string" },
    { name: "chainId", type: "uint256" },
    { name: "orderlyKey", type: "string" },
    { name: "scope", type: "string" },
    { name: "timestamp", type: "uint64" },
    { name: "expiration", type: "uint64" }
  ],
  SettlePnl: [
    { name: "brokerId", type: "string" },
    { name: "chainId", type: "uint256" },
    { name: "settleNonce", type: "uint64" },
    { name: "timestamp", type: "uint64" }
  ]
};
var AssetHistoryStatusEnum = /* @__PURE__ */ ((AssetHistoryStatusEnum2) => {
  AssetHistoryStatusEnum2["NEW"] = "NEW";
  AssetHistoryStatusEnum2["CONFIRM"] = "CONFIRM";
  AssetHistoryStatusEnum2["PROCESSING"] = "PROCESSING";
  AssetHistoryStatusEnum2["COMPLETED"] = "COMPLETED";
  AssetHistoryStatusEnum2["FAILED"] = "FAILED";
  AssetHistoryStatusEnum2["PENDING_REBALANCE"] = "PENDING_REBALANCE";
  return AssetHistoryStatusEnum2;
})(AssetHistoryStatusEnum || {});
const version = "6.13.5";
function checkType(value, type, name) {
  const types = type.split("|").map((t) => t.trim());
  for (let i = 0; i < types.length; i++) {
    switch (type) {
      case "any":
        return;
      case "bigint":
      case "boolean":
      case "number":
      case "string":
        if (typeof value === type) {
          return;
        }
    }
  }
  const error = new Error(`invalid value for type ${type}`);
  error.code = "INVALID_ARGUMENT";
  error.argument = `value.${name}`;
  error.value = value;
  throw error;
}
async function resolveProperties(value) {
  const keys = Object.keys(value);
  const results = await Promise.all(keys.map((k2) => Promise.resolve(value[k2])));
  return results.reduce((accum, v2, index) => {
    accum[keys[index]] = v2;
    return accum;
  }, {});
}
function defineProperties(target, values, types) {
  for (let key in values) {
    let value = values[key];
    const type = types ? types[key] : null;
    if (type) {
      checkType(value, type, key);
    }
    Object.defineProperty(target, key, { enumerable: true, value, writable: false });
  }
}
function stringify(value) {
  if (value == null) {
    return "null";
  }
  if (Array.isArray(value)) {
    return "[ " + value.map(stringify).join(", ") + " ]";
  }
  if (value instanceof Uint8Array) {
    const HEX = "0123456789abcdef";
    let result = "0x";
    for (let i = 0; i < value.length; i++) {
      result += HEX[value[i] >> 4];
      result += HEX[value[i] & 15];
    }
    return result;
  }
  if (typeof value === "object" && typeof value.toJSON === "function") {
    return stringify(value.toJSON());
  }
  switch (typeof value) {
    case "boolean":
    case "symbol":
      return value.toString();
    case "bigint":
      return BigInt(value).toString();
    case "number":
      return value.toString();
    case "string":
      return JSON.stringify(value);
    case "object": {
      const keys = Object.keys(value);
      keys.sort();
      return "{ " + keys.map((k2) => `${stringify(k2)}: ${stringify(value[k2])}`).join(", ") + " }";
    }
  }
  return `[ COULD NOT SERIALIZE ]`;
}
function isError(error, code) {
  return error && error.code === code;
}
function isCallException(error) {
  return isError(error, "CALL_EXCEPTION");
}
function makeError(message, code, info) {
  let shortMessage = message;
  {
    const details = [];
    if (info) {
      if ("message" in info || "code" in info || "name" in info) {
        throw new Error(`value will overwrite populated values: ${stringify(info)}`);
      }
      for (const key in info) {
        if (key === "shortMessage") {
          continue;
        }
        const value = info[key];
        details.push(key + "=" + stringify(value));
      }
    }
    details.push(`code=${code}`);
    details.push(`version=${version}`);
    if (details.length) {
      message += " (" + details.join(", ") + ")";
    }
  }
  let error;
  switch (code) {
    case "INVALID_ARGUMENT":
      error = new TypeError(message);
      break;
    case "NUMERIC_FAULT":
    case "BUFFER_OVERRUN":
      error = new RangeError(message);
      break;
    default:
      error = new Error(message);
  }
  defineProperties(error, { code });
  if (info) {
    Object.assign(error, info);
  }
  if (error.shortMessage == null) {
    defineProperties(error, { shortMessage });
  }
  return error;
}
function assert(check, message, code, info) {
  if (!check) {
    throw makeError(message, code, info);
  }
}
function assertArgument(check, message, name, value) {
  assert(check, message, "INVALID_ARGUMENT", { argument: name, value });
}
function assertArgumentCount(count, expectedCount, message) {
  if (message == null) {
    message = "";
  }
  if (message) {
    message = ": " + message;
  }
  assert(count >= expectedCount, "missing argument" + message, "MISSING_ARGUMENT", {
    count,
    expectedCount
  });
  assert(count <= expectedCount, "too many arguments" + message, "UNEXPECTED_ARGUMENT", {
    count,
    expectedCount
  });
}
["NFD", "NFC", "NFKD", "NFKC"].reduce((accum, form) => {
  try {
    if ("test".normalize(form) !== "test") {
      throw new Error("bad");
    }
    ;
    if (form === "NFD") {
      const check = String.fromCharCode(233).normalize("NFD");
      const expected = String.fromCharCode(101, 769);
      if (check !== expected) {
        throw new Error("broken");
      }
    }
    accum.push(form);
  } catch (error) {
  }
  return accum;
}, []);
function assertPrivate(givenGuard, guard, className) {
  if (className == null) {
    className = "";
  }
  if (givenGuard !== guard) {
    let method = className, operation = "new";
    if (className) {
      method += ".";
      operation += " " + className;
    }
    assert(false, `private constructor; use ${method}from* methods`, "UNSUPPORTED_OPERATION", {
      operation
    });
  }
}
function _getBytes(value, name, copy2) {
  if (value instanceof Uint8Array) {
    if (copy2) {
      return new Uint8Array(value);
    }
    return value;
  }
  if (typeof value === "string" && value.match(/^0x(?:[0-9a-f][0-9a-f])*$/i)) {
    const result = new Uint8Array((value.length - 2) / 2);
    let offset = 2;
    for (let i = 0; i < result.length; i++) {
      result[i] = parseInt(value.substring(offset, offset + 2), 16);
      offset += 2;
    }
    return result;
  }
  assertArgument(false, "invalid BytesLike value", name || "value", value);
}
function getBytes(value, name) {
  return _getBytes(value, name, false);
}
function getBytesCopy(value, name) {
  return _getBytes(value, name, true);
}
function isHexString(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (typeof length === "number" && value.length !== 2 + 2 * length) {
    return false;
  }
  if (length === true && value.length % 2 !== 0) {
    return false;
  }
  return true;
}
function isBytesLike(value) {
  return isHexString(value, true) || value instanceof Uint8Array;
}
const HexCharacters = "0123456789abcdef";
function hexlify(data) {
  const bytes = getBytes(data);
  let result = "0x";
  for (let i = 0; i < bytes.length; i++) {
    const v2 = bytes[i];
    result += HexCharacters[(v2 & 240) >> 4] + HexCharacters[v2 & 15];
  }
  return result;
}
function concat(datas) {
  return "0x" + datas.map((d2) => hexlify(d2).substring(2)).join("");
}
function dataLength(data) {
  if (isHexString(data, true)) {
    return (data.length - 2) / 2;
  }
  return getBytes(data).length;
}
function dataSlice(data, start, end) {
  const bytes = getBytes(data);
  if (end != null && end > bytes.length) {
    assert(false, "cannot slice beyond data bounds", "BUFFER_OVERRUN", {
      buffer: bytes,
      length: bytes.length,
      offset: end
    });
  }
  return hexlify(bytes.slice(start == null ? 0 : start, end == null ? bytes.length : end));
}
function zeroPad(data, length, left) {
  const bytes = getBytes(data);
  assert(length >= bytes.length, "padding exceeds data length", "BUFFER_OVERRUN", {
    buffer: new Uint8Array(bytes),
    length,
    offset: length + 1
  });
  const result = new Uint8Array(length);
  result.fill(0);
  if (left) {
    result.set(bytes, length - bytes.length);
  } else {
    result.set(bytes, 0);
  }
  return hexlify(result);
}
function zeroPadValue(data, length) {
  return zeroPad(data, length, true);
}
function zeroPadBytes(data, length) {
  return zeroPad(data, length, false);
}
const BN_0$9 = BigInt(0);
const BN_1$4 = BigInt(1);
const maxValue = 9007199254740991;
function fromTwos(_value2, _width) {
  const value = getUint(_value2, "value");
  const width = BigInt(getNumber(_width, "width"));
  assert(value >> width === BN_0$9, "overflow", "NUMERIC_FAULT", {
    operation: "fromTwos",
    fault: "overflow",
    value: _value2
  });
  if (value >> width - BN_1$4) {
    const mask2 = (BN_1$4 << width) - BN_1$4;
    return -((~value & mask2) + BN_1$4);
  }
  return value;
}
function toTwos(_value2, _width) {
  let value = getBigInt(_value2, "value");
  const width = BigInt(getNumber(_width, "width"));
  const limit = BN_1$4 << width - BN_1$4;
  if (value < BN_0$9) {
    value = -value;
    assert(value <= limit, "too low", "NUMERIC_FAULT", {
      operation: "toTwos",
      fault: "overflow",
      value: _value2
    });
    const mask2 = (BN_1$4 << width) - BN_1$4;
    return (~value & mask2) + BN_1$4;
  } else {
    assert(value < limit, "too high", "NUMERIC_FAULT", {
      operation: "toTwos",
      fault: "overflow",
      value: _value2
    });
  }
  return value;
}
function mask(_value2, _bits) {
  const value = getUint(_value2, "value");
  const bits = BigInt(getNumber(_bits, "bits"));
  return value & (BN_1$4 << bits) - BN_1$4;
}
function getBigInt(value, name) {
  switch (typeof value) {
    case "bigint":
      return value;
    case "number":
      assertArgument(Number.isInteger(value), "underflow", name || "value", value);
      assertArgument(value >= -9007199254740991 && value <= maxValue, "overflow", name || "value", value);
      return BigInt(value);
    case "string":
      try {
        if (value === "") {
          throw new Error("empty string");
        }
        if (value[0] === "-" && value[1] !== "-") {
          return -BigInt(value.substring(1));
        }
        return BigInt(value);
      } catch (e3) {
        assertArgument(false, `invalid BigNumberish string: ${e3.message}`, name || "value", value);
      }
  }
  assertArgument(false, "invalid BigNumberish value", name || "value", value);
}
function getUint(value, name) {
  const result = getBigInt(value, name);
  assert(result >= BN_0$9, "unsigned value cannot be negative", "NUMERIC_FAULT", {
    fault: "overflow",
    operation: "getUint",
    value
  });
  return result;
}
const Nibbles = "0123456789abcdef";
function toBigInt(value) {
  if (value instanceof Uint8Array) {
    let result = "0x0";
    for (const v2 of value) {
      result += Nibbles[v2 >> 4];
      result += Nibbles[v2 & 15];
    }
    return BigInt(result);
  }
  return getBigInt(value);
}
function getNumber(value, name) {
  switch (typeof value) {
    case "bigint":
      assertArgument(value >= -9007199254740991 && value <= maxValue, "overflow", name || "value", value);
      return Number(value);
    case "number":
      assertArgument(Number.isInteger(value), "underflow", name || "value", value);
      assertArgument(value >= -9007199254740991 && value <= maxValue, "overflow", name || "value", value);
      return value;
    case "string":
      try {
        if (value === "") {
          throw new Error("empty string");
        }
        return getNumber(BigInt(value), name);
      } catch (e3) {
        assertArgument(false, `invalid numeric string: ${e3.message}`, name || "value", value);
      }
  }
  assertArgument(false, "invalid numeric value", name || "value", value);
}
function toNumber(value) {
  return getNumber(toBigInt(value));
}
function toBeHex(_value2, _width) {
  const value = getUint(_value2, "value");
  let result = value.toString(16);
  if (_width == null) {
    if (result.length % 2) {
      result = "0" + result;
    }
  } else {
    const width = getNumber(_width, "width");
    assert(width * 2 >= result.length, `value exceeds width (${width} bytes)`, "NUMERIC_FAULT", {
      operation: "toBeHex",
      fault: "overflow",
      value: _value2
    });
    while (result.length < width * 2) {
      result = "0" + result;
    }
  }
  return "0x" + result;
}
function toBeArray(_value2) {
  const value = getUint(_value2, "value");
  if (value === BN_0$9) {
    return new Uint8Array([]);
  }
  let hex = value.toString(16);
  if (hex.length % 2) {
    hex = "0" + hex;
  }
  const result = new Uint8Array(hex.length / 2);
  for (let i = 0; i < result.length; i++) {
    const offset = i * 2;
    result[i] = parseInt(hex.substring(offset, offset + 2), 16);
  }
  return result;
}
function toQuantity(value) {
  let result = hexlify(isBytesLike(value) ? value : toBeArray(value)).substring(2);
  while (result.startsWith("0")) {
    result = result.substring(1);
  }
  if (result === "") {
    result = "0";
  }
  return "0x" + result;
}
const Alphabet = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
BigInt(0);
const BN_58 = BigInt(58);
function encodeBase58(_value2) {
  const bytes = getBytes(_value2);
  let value = toBigInt(bytes);
  let result = "";
  while (value) {
    result = Alphabet[Number(value % BN_58)] + result;
    value /= BN_58;
  }
  for (let i = 0; i < bytes.length; i++) {
    if (bytes[i]) {
      break;
    }
    result = Alphabet[0] + result;
  }
  return result;
}
var dist = {};
(function(exports) {
  Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
  const t = require$$0, r3 = require$$1, o = (e3) => e3 && e3.__esModule ? e3 : { default: e3 }, l2 = o(r3), u2 = globalThis || void 0 || self;
  Object.defineProperty(exports, "Buffer", { enumerable: true, get: () => t.Buffer });
  Object.defineProperty(exports, "process", { enumerable: true, get: () => l2.default });
  exports.global = u2;
})(dist);
function decodeBase64(value) {
  return getBytesCopy(dist.Buffer.from(value, "base64"));
}
function encodeBase64(data) {
  return dist.Buffer.from(getBytes(data)).toString("base64");
}
class EventPayload {
  /**
   *  Create a new **EventPayload** for %%emitter%% with
   *  the %%listener%% and for %%filter%%.
   */
  constructor(emitter, listener, filter) {
    /**
     *  The event filter.
     */
    __publicField(this, "filter");
    /**
     *  The **EventEmitterable**.
     */
    __publicField(this, "emitter");
    __privateAdd(this, _listener);
    __privateSet(this, _listener, listener);
    defineProperties(this, { emitter, filter });
  }
  /**
   *  Unregister the triggered listener for future events.
   */
  async removeListener() {
    if (__privateGet(this, _listener) == null) {
      return;
    }
    await this.emitter.off(this.filter, __privateGet(this, _listener));
  }
}
_listener = new WeakMap();
function errorFunc(reason, offset, bytes, output, badCodepoint) {
  assertArgument(false, `invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes);
}
function ignoreFunc(reason, offset, bytes, output, badCodepoint) {
  if (reason === "BAD_PREFIX" || reason === "UNEXPECTED_CONTINUE") {
    let i = 0;
    for (let o = offset + 1; o < bytes.length; o++) {
      if (bytes[o] >> 6 !== 2) {
        break;
      }
      i++;
    }
    return i;
  }
  if (reason === "OVERRUN") {
    return bytes.length - offset - 1;
  }
  return 0;
}
function replaceFunc(reason, offset, bytes, output, badCodepoint) {
  if (reason === "OVERLONG") {
    assertArgument(typeof badCodepoint === "number", "invalid bad code point for replacement", "badCodepoint", badCodepoint);
    output.push(badCodepoint);
    return 0;
  }
  output.push(65533);
  return ignoreFunc(reason, offset, bytes);
}
const Utf8ErrorFuncs = Object.freeze({
  error: errorFunc,
  ignore: ignoreFunc,
  replace: replaceFunc
});
function getUtf8CodePoints(_bytes, onError) {
  if (onError == null) {
    onError = Utf8ErrorFuncs.error;
  }
  const bytes = getBytes(_bytes, "bytes");
  const result = [];
  let i = 0;
  while (i < bytes.length) {
    const c2 = bytes[i++];
    if (c2 >> 7 === 0) {
      result.push(c2);
      continue;
    }
    let extraLength = null;
    let overlongMask = null;
    if ((c2 & 224) === 192) {
      extraLength = 1;
      overlongMask = 127;
    } else if ((c2 & 240) === 224) {
      extraLength = 2;
      overlongMask = 2047;
    } else if ((c2 & 248) === 240) {
      extraLength = 3;
      overlongMask = 65535;
    } else {
      if ((c2 & 192) === 128) {
        i += onError("UNEXPECTED_CONTINUE", i - 1, bytes, result);
      } else {
        i += onError("BAD_PREFIX", i - 1, bytes, result);
      }
      continue;
    }
    if (i - 1 + extraLength >= bytes.length) {
      i += onError("OVERRUN", i - 1, bytes, result);
      continue;
    }
    let res = c2 & (1 << 8 - extraLength - 1) - 1;
    for (let j2 = 0; j2 < extraLength; j2++) {
      let nextChar = bytes[i];
      if ((nextChar & 192) != 128) {
        i += onError("MISSING_CONTINUE", i, bytes, result);
        res = null;
        break;
      }
      res = res << 6 | nextChar & 63;
      i++;
    }
    if (res === null) {
      continue;
    }
    if (res > 1114111) {
      i += onError("OUT_OF_RANGE", i - 1 - extraLength, bytes, result, res);
      continue;
    }
    if (res >= 55296 && res <= 57343) {
      i += onError("UTF16_SURROGATE", i - 1 - extraLength, bytes, result, res);
      continue;
    }
    if (res <= overlongMask) {
      i += onError("OVERLONG", i - 1 - extraLength, bytes, result, res);
      continue;
    }
    result.push(res);
  }
  return result;
}
function toUtf8Bytes(str, form) {
  assertArgument(typeof str === "string", "invalid string value", "str", str);
  let result = [];
  for (let i = 0; i < str.length; i++) {
    const c2 = str.charCodeAt(i);
    if (c2 < 128) {
      result.push(c2);
    } else if (c2 < 2048) {
      result.push(c2 >> 6 | 192);
      result.push(c2 & 63 | 128);
    } else if ((c2 & 64512) == 55296) {
      i++;
      const c22 = str.charCodeAt(i);
      assertArgument(i < str.length && (c22 & 64512) === 56320, "invalid surrogate pair", "str", str);
      const pair = 65536 + ((c2 & 1023) << 10) + (c22 & 1023);
      result.push(pair >> 18 | 240);
      result.push(pair >> 12 & 63 | 128);
      result.push(pair >> 6 & 63 | 128);
      result.push(pair & 63 | 128);
    } else {
      result.push(c2 >> 12 | 224);
      result.push(c2 >> 6 & 63 | 128);
      result.push(c2 & 63 | 128);
    }
  }
  return new Uint8Array(result);
}
function _toUtf8String(codePoints) {
  return codePoints.map((codePoint) => {
    if (codePoint <= 65535) {
      return String.fromCharCode(codePoint);
    }
    codePoint -= 65536;
    return String.fromCharCode((codePoint >> 10 & 1023) + 55296, (codePoint & 1023) + 56320);
  }).join("");
}
function toUtf8String(bytes, onError) {
  return _toUtf8String(getUtf8CodePoints(bytes, onError));
}
function createGetUrl(options) {
  async function getUrl(req, signal) {
    assert(signal == null || !signal.cancelled, "request cancelled before sending", "CANCELLED");
    const protocol = req.url.split(":")[0].toLowerCase();
    assert(protocol === "http" || protocol === "https", `unsupported protocol ${protocol}`, "UNSUPPORTED_OPERATION", {
      info: { protocol },
      operation: "request"
    });
    assert(protocol === "https" || !req.credentials || req.allowInsecureAuthentication, "insecure authorized connections unsupported", "UNSUPPORTED_OPERATION", {
      operation: "request"
    });
    const method = req.method;
    const headers = Object.assign({}, req.headers);
    const reqOptions = { method, headers };
    if (options) {
      if (options.agent) {
        reqOptions.agent = options.agent;
      }
    }
    let abort = null;
    try {
      abort = new AbortController();
      reqOptions.abort = abort.signal;
    } catch (e3) {
      console.log(e3);
    }
    const request2 = (protocol === "http" ? http : https).request(req.url, reqOptions);
    request2.setTimeout(req.timeout);
    const body = req.body;
    if (body) {
      request2.write(dist.Buffer.from(body));
    }
    request2.end();
    return new Promise((resolve, reject) => {
      if (signal) {
        signal.addListener(() => {
          if (abort) {
            abort.abort();
          }
          reject(makeError("request cancelled", "CANCELLED"));
        });
      }
      request2.on("timeout", () => {
        reject(makeError("request timeout", "TIMEOUT"));
      });
      request2.once("response", (resp) => {
        const statusCode = resp.statusCode || 0;
        const statusMessage = resp.statusMessage || "";
        const headers2 = Object.keys(resp.headers || {}).reduce((accum, name) => {
          let value = resp.headers[name] || "";
          if (Array.isArray(value)) {
            value = value.join(", ");
          }
          accum[name] = value;
          return accum;
        }, {});
        let body2 = null;
        resp.on("data", (chunk) => {
          if (signal) {
            try {
              signal.checkSignal();
            } catch (error) {
              return reject(error);
            }
          }
          if (body2 == null) {
            body2 = chunk;
          } else {
            const newBody = new Uint8Array(body2.length + chunk.length);
            newBody.set(body2, 0);
            newBody.set(chunk, body2.length);
            body2 = newBody;
          }
        });
        resp.on("end", () => {
          if (headers2["content-encoding"] === "gzip" && body2) {
            body2 = getBytes(gunzipSync(body2));
          }
          resolve({ statusCode, statusMessage, headers: headers2, body: body2 });
        });
        resp.on("error", (error) => {
          error.response = { statusCode, statusMessage, headers: headers2, body: body2 };
          reject(error);
        });
      });
      request2.on("error", (error) => {
        reject(error);
      });
    });
  }
  return getUrl;
}
const MAX_ATTEMPTS = 12;
const SLOT_INTERVAL = 250;
let defaultGetUrlFunc = createGetUrl();
const reData = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i");
const reIpfs = new RegExp("^ipfs://(ipfs/)?(.*)$", "i");
let locked$1 = false;
async function dataGatewayFunc(url, signal) {
  try {
    const match = url.match(reData);
    if (!match) {
      throw new Error("invalid data");
    }
    return new FetchResponse(200, "OK", {
      "content-type": match[1] || "text/plain"
    }, match[2] ? decodeBase64(match[3]) : unpercent(match[3]));
  } catch (error) {
    return new FetchResponse(599, "BAD REQUEST (invalid data: URI)", {}, null, new FetchRequest(url));
  }
}
function getIpfsGatewayFunc(baseUrl) {
  async function gatewayIpfs(url, signal) {
    try {
      const match = url.match(reIpfs);
      if (!match) {
        throw new Error("invalid link");
      }
      return new FetchRequest(`${baseUrl}${match[2]}`);
    } catch (error) {
      return new FetchResponse(599, "BAD REQUEST (invalid IPFS URI)", {}, null, new FetchRequest(url));
    }
  }
  return gatewayIpfs;
}
const Gateways = {
  "data": dataGatewayFunc,
  "ipfs": getIpfsGatewayFunc("https://gateway.ipfs.io/ipfs/")
};
const fetchSignals = /* @__PURE__ */ new WeakMap();
class FetchCancelSignal {
  constructor(request2) {
    __privateAdd(this, _listeners);
    __privateAdd(this, _cancelled);
    __privateSet(this, _listeners, []);
    __privateSet(this, _cancelled, false);
    fetchSignals.set(request2, () => {
      if (__privateGet(this, _cancelled)) {
        return;
      }
      __privateSet(this, _cancelled, true);
      for (const listener of __privateGet(this, _listeners)) {
        setTimeout(() => {
          listener();
        }, 0);
      }
      __privateSet(this, _listeners, []);
    });
  }
  addListener(listener) {
    assert(!__privateGet(this, _cancelled), "singal already cancelled", "UNSUPPORTED_OPERATION", {
      operation: "fetchCancelSignal.addCancelListener"
    });
    __privateGet(this, _listeners).push(listener);
  }
  get cancelled() {
    return __privateGet(this, _cancelled);
  }
  checkSignal() {
    assert(!this.cancelled, "cancelled", "CANCELLED", {});
  }
}
_listeners = new WeakMap();
_cancelled = new WeakMap();
function checkSignal(signal) {
  if (signal == null) {
    throw new Error("missing signal; should not happen");
  }
  signal.checkSignal();
  return signal;
}
const _FetchRequest = class _FetchRequest {
  /**
   *  Create a new FetchRequest instance with default values.
   *
   *  Once created, each property may be set before issuing a
   *  ``.send()`` to make the request.
   */
  constructor(url) {
    __privateAdd(this, _FetchRequest_instances);
    __privateAdd(this, _allowInsecure);
    __privateAdd(this, _gzip);
    __privateAdd(this, _headers);
    __privateAdd(this, _method);
    __privateAdd(this, _timeout);
    __privateAdd(this, _url);
    __privateAdd(this, _body);
    __privateAdd(this, _bodyType);
    __privateAdd(this, _creds);
    // Hooks
    __privateAdd(this, _preflight);
    __privateAdd(this, _process);
    __privateAdd(this, _retry);
    __privateAdd(this, _signal);
    __privateAdd(this, _throttle);
    __privateAdd(this, _getUrlFunc);
    __privateSet(this, _url, String(url));
    __privateSet(this, _allowInsecure, false);
    __privateSet(this, _gzip, true);
    __privateSet(this, _headers, {});
    __privateSet(this, _method, "");
    __privateSet(this, _timeout, 3e5);
    __privateSet(this, _throttle, {
      slotInterval: SLOT_INTERVAL,
      maxAttempts: MAX_ATTEMPTS
    });
    __privateSet(this, _getUrlFunc, null);
  }
  /**
   *  The fetch URL to request.
   */
  get url() {
    return __privateGet(this, _url);
  }
  set url(url) {
    __privateSet(this, _url, String(url));
  }
  /**
   *  The fetch body, if any, to send as the request body. //(default: null)//
   *
   *  When setting a body, the intrinsic ``Content-Type`` is automatically
   *  set and will be used if **not overridden** by setting a custom
   *  header.
   *
   *  If %%body%% is null, the body is cleared (along with the
   *  intrinsic ``Content-Type``).
   *
   *  If %%body%% is a string, the intrinsic ``Content-Type`` is set to
   *  ``text/plain``.
   *
   *  If %%body%% is a Uint8Array, the intrinsic ``Content-Type`` is set to
   *  ``application/octet-stream``.
   *
   *  If %%body%% is any other object, the intrinsic ``Content-Type`` is
   *  set to ``application/json``.
   */
  get body() {
    if (__privateGet(this, _body) == null) {
      return null;
    }
    return new Uint8Array(__privateGet(this, _body));
  }
  set body(body) {
    if (body == null) {
      __privateSet(this, _body, void 0);
      __privateSet(this, _bodyType, void 0);
    } else if (typeof body === "string") {
      __privateSet(this, _body, toUtf8Bytes(body));
      __privateSet(this, _bodyType, "text/plain");
    } else if (body instanceof Uint8Array) {
      __privateSet(this, _body, body);
      __privateSet(this, _bodyType, "application/octet-stream");
    } else if (typeof body === "object") {
      __privateSet(this, _body, toUtf8Bytes(JSON.stringify(body)));
      __privateSet(this, _bodyType, "application/json");
    } else {
      throw new Error("invalid body");
    }
  }
  /**
   *  Returns true if the request has a body.
   */
  hasBody() {
    return __privateGet(this, _body) != null;
  }
  /**
   *  The HTTP method to use when requesting the URI. If no method
   *  has been explicitly set, then ``GET`` is used if the body is
   *  null and ``POST`` otherwise.
   */
  get method() {
    if (__privateGet(this, _method)) {
      return __privateGet(this, _method);
    }
    if (this.hasBody()) {
      return "POST";
    }
    return "GET";
  }
  set method(method) {
    if (method == null) {
      method = "";
    }
    __privateSet(this, _method, String(method).toUpperCase());
  }
  /**
   *  The headers that will be used when requesting the URI. All
   *  keys are lower-case.
   *
   *  This object is a copy, so any changes will **NOT** be reflected
   *  in the ``FetchRequest``.
   *
   *  To set a header entry, use the ``setHeader`` method.
   */
  get headers() {
    const headers = Object.assign({}, __privateGet(this, _headers));
    if (__privateGet(this, _creds)) {
      headers["authorization"] = `Basic ${encodeBase64(toUtf8Bytes(__privateGet(this, _creds)))}`;
    }
    if (this.allowGzip) {
      headers["accept-encoding"] = "gzip";
    }
    if (headers["content-type"] == null && __privateGet(this, _bodyType)) {
      headers["content-type"] = __privateGet(this, _bodyType);
    }
    if (this.body) {
      headers["content-length"] = String(this.body.length);
    }
    return headers;
  }
  /**
   *  Get the header for %%key%%, ignoring case.
   */
  getHeader(key) {
    return this.headers[key.toLowerCase()];
  }
  /**
   *  Set the header for %%key%% to %%value%%. All values are coerced
   *  to a string.
   */
  setHeader(key, value) {
    __privateGet(this, _headers)[String(key).toLowerCase()] = String(value);
  }
  /**
   *  Clear all headers, resetting all intrinsic headers.
   */
  clearHeaders() {
    __privateSet(this, _headers, {});
  }
  [Symbol.iterator]() {
    const headers = this.headers;
    const keys = Object.keys(headers);
    let index = 0;
    return {
      next: () => {
        if (index < keys.length) {
          const key = keys[index++];
          return {
            value: [key, headers[key]],
            done: false
          };
        }
        return { value: void 0, done: true };
      }
    };
  }
  /**
   *  The value that will be sent for the ``Authorization`` header.
   *
   *  To set the credentials, use the ``setCredentials`` method.
   */
  get credentials() {
    return __privateGet(this, _creds) || null;
  }
  /**
   *  Sets an ``Authorization`` for %%username%% with %%password%%.
   */
  setCredentials(username, password) {
    assertArgument(!username.match(/:/), "invalid basic authentication username", "username", "[REDACTED]");
    __privateSet(this, _creds, `${username}:${password}`);
  }
  /**
   *  Enable and request gzip-encoded responses. The response will
   *  automatically be decompressed. //(default: true)//
   */
  get allowGzip() {
    return __privateGet(this, _gzip);
  }
  set allowGzip(value) {
    __privateSet(this, _gzip, !!value);
  }
  /**
   *  Allow ``Authentication`` credentials to be sent over insecure
   *  channels. //(default: false)//
   */
  get allowInsecureAuthentication() {
    return !!__privateGet(this, _allowInsecure);
  }
  set allowInsecureAuthentication(value) {
    __privateSet(this, _allowInsecure, !!value);
  }
  /**
   *  The timeout (in milliseconds) to wait for a complete response.
   *  //(default: 5 minutes)//
   */
  get timeout() {
    return __privateGet(this, _timeout);
  }
  set timeout(timeout) {
    assertArgument(timeout >= 0, "timeout must be non-zero", "timeout", timeout);
    __privateSet(this, _timeout, timeout);
  }
  /**
   *  This function is called prior to each request, for example
   *  during a redirection or retry in case of server throttling.
   *
   *  This offers an opportunity to populate headers or update
   *  content before sending a request.
   */
  get preflightFunc() {
    return __privateGet(this, _preflight) || null;
  }
  set preflightFunc(preflight) {
    __privateSet(this, _preflight, preflight);
  }
  /**
   *  This function is called after each response, offering an
   *  opportunity to provide client-level throttling or updating
   *  response data.
   *
   *  Any error thrown in this causes the ``send()`` to throw.
   *
   *  To schedule a retry attempt (assuming the maximum retry limit
   *  has not been reached), use [[response.throwThrottleError]].
   */
  get processFunc() {
    return __privateGet(this, _process) || null;
  }
  set processFunc(process) {
    __privateSet(this, _process, process);
  }
  /**
   *  This function is called on each retry attempt.
   */
  get retryFunc() {
    return __privateGet(this, _retry) || null;
  }
  set retryFunc(retry) {
    __privateSet(this, _retry, retry);
  }
  /**
   *  This function is called to fetch content from HTTP and
   *  HTTPS URLs and is platform specific (e.g. nodejs vs
   *  browsers).
   *
   *  This is by default the currently registered global getUrl
   *  function, which can be changed using [[registerGetUrl]].
   *  If this has been set, setting is to ``null`` will cause
   *  this FetchRequest (and any future clones) to revert back to
   *  using the currently registered global getUrl function.
   *
   *  Setting this is generally not necessary, but may be useful
   *  for developers that wish to intercept requests or to
   *  configurege a proxy or other agent.
   */
  get getUrlFunc() {
    return __privateGet(this, _getUrlFunc) || defaultGetUrlFunc;
  }
  set getUrlFunc(value) {
    __privateSet(this, _getUrlFunc, value);
  }
  toString() {
    return `<FetchRequest method=${JSON.stringify(this.method)} url=${JSON.stringify(this.url)} headers=${JSON.stringify(this.headers)} body=${__privateGet(this, _body) ? hexlify(__privateGet(this, _body)) : "null"}>`;
  }
  /**
   *  Update the throttle parameters used to determine maximum
   *  attempts and exponential-backoff properties.
   */
  setThrottleParams(params) {
    if (params.slotInterval != null) {
      __privateGet(this, _throttle).slotInterval = params.slotInterval;
    }
    if (params.maxAttempts != null) {
      __privateGet(this, _throttle).maxAttempts = params.maxAttempts;
    }
  }
  /**
   *  Resolves to the response by sending the request.
   */
  send() {
    assert(__privateGet(this, _signal) == null, "request already sent", "UNSUPPORTED_OPERATION", { operation: "fetchRequest.send" });
    __privateSet(this, _signal, new FetchCancelSignal(this));
    return __privateMethod(this, _FetchRequest_instances, send_fn).call(this, 0, getTime$1() + this.timeout, 0, this, new FetchResponse(0, "", {}, null, this));
  }
  /**
   *  Cancels the inflight response, causing a ``CANCELLED``
   *  error to be rejected from the [[send]].
   */
  cancel() {
    assert(__privateGet(this, _signal) != null, "request has not been sent", "UNSUPPORTED_OPERATION", { operation: "fetchRequest.cancel" });
    const signal = fetchSignals.get(this);
    if (!signal) {
      throw new Error("missing signal; should not happen");
    }
    signal();
  }
  /**
   *  Returns a new [[FetchRequest]] that represents the redirection
   *  to %%location%%.
   */
  redirect(location) {
    const current = this.url.split(":")[0].toLowerCase();
    const target = location.split(":")[0].toLowerCase();
    assert(this.method === "GET" && (current !== "https" || target !== "http") && location.match(/^https?:/), `unsupported redirect`, "UNSUPPORTED_OPERATION", {
      operation: `redirect(${this.method} ${JSON.stringify(this.url)} => ${JSON.stringify(location)})`
    });
    const req = new _FetchRequest(location);
    req.method = "GET";
    req.allowGzip = this.allowGzip;
    req.timeout = this.timeout;
    __privateSet(req, _headers, Object.assign({}, __privateGet(this, _headers)));
    if (__privateGet(this, _body)) {
      __privateSet(req, _body, new Uint8Array(__privateGet(this, _body)));
    }
    __privateSet(req, _bodyType, __privateGet(this, _bodyType));
    return req;
  }
  /**
   *  Create a new copy of this request.
   */
  clone() {
    const clone = new _FetchRequest(this.url);
    __privateSet(clone, _method, __privateGet(this, _method));
    if (__privateGet(this, _body)) {
      __privateSet(clone, _body, __privateGet(this, _body));
    }
    __privateSet(clone, _bodyType, __privateGet(this, _bodyType));
    __privateSet(clone, _headers, Object.assign({}, __privateGet(this, _headers)));
    __privateSet(clone, _creds, __privateGet(this, _creds));
    if (this.allowGzip) {
      clone.allowGzip = true;
    }
    clone.timeout = this.timeout;
    if (this.allowInsecureAuthentication) {
      clone.allowInsecureAuthentication = true;
    }
    __privateSet(clone, _preflight, __privateGet(this, _preflight));
    __privateSet(clone, _process, __privateGet(this, _process));
    __privateSet(clone, _retry, __privateGet(this, _retry));
    __privateSet(clone, _throttle, Object.assign({}, __privateGet(this, _throttle)));
    __privateSet(clone, _getUrlFunc, __privateGet(this, _getUrlFunc));
    return clone;
  }
  /**
   *  Locks all static configuration for gateways and FetchGetUrlFunc
   *  registration.
   */
  static lockConfig() {
    locked$1 = true;
  }
  /**
   *  Get the current Gateway function for %%scheme%%.
   */
  static getGateway(scheme) {
    return Gateways[scheme.toLowerCase()] || null;
  }
  /**
   *  Use the %%func%% when fetching URIs using %%scheme%%.
   *
   *  This method affects all requests globally.
   *
   *  If [[lockConfig]] has been called, no change is made and this
   *  throws.
   */
  static registerGateway(scheme, func) {
    scheme = scheme.toLowerCase();
    if (scheme === "http" || scheme === "https") {
      throw new Error(`cannot intercept ${scheme}; use registerGetUrl`);
    }
    if (locked$1) {
      throw new Error("gateways locked");
    }
    Gateways[scheme] = func;
  }
  /**
   *  Use %%getUrl%% when fetching URIs over HTTP and HTTPS requests.
   *
   *  This method affects all requests globally.
   *
   *  If [[lockConfig]] has been called, no change is made and this
   *  throws.
   */
  static registerGetUrl(getUrl) {
    if (locked$1) {
      throw new Error("gateways locked");
    }
    defaultGetUrlFunc = getUrl;
  }
  /**
   *  Creates a getUrl function that fetches content from HTTP and
   *  HTTPS URLs.
   *
   *  The available %%options%% are dependent on the platform
   *  implementation of the default getUrl function.
   *
   *  This is not generally something that is needed, but is useful
   *  when trying to customize simple behaviour when fetching HTTP
   *  content.
   */
  static createGetUrlFunc(options) {
    return createGetUrl(options);
  }
  /**
   *  Creates a function that can "fetch" data URIs.
   *
   *  Note that this is automatically done internally to support
   *  data URIs, so it is not necessary to register it.
   *
   *  This is not generally something that is needed, but may
   *  be useful in a wrapper to perfom custom data URI functionality.
   */
  static createDataGateway() {
    return dataGatewayFunc;
  }
  /**
   *  Creates a function that will fetch IPFS (unvalidated) from
   *  a custom gateway baseUrl.
   *
   *  The default IPFS gateway used internally is
   *  ``"https:/\/gateway.ipfs.io/ipfs/"``.
   */
  static createIpfsGatewayFunc(baseUrl) {
    return getIpfsGatewayFunc(baseUrl);
  }
};
_allowInsecure = new WeakMap();
_gzip = new WeakMap();
_headers = new WeakMap();
_method = new WeakMap();
_timeout = new WeakMap();
_url = new WeakMap();
_body = new WeakMap();
_bodyType = new WeakMap();
_creds = new WeakMap();
_preflight = new WeakMap();
_process = new WeakMap();
_retry = new WeakMap();
_signal = new WeakMap();
_throttle = new WeakMap();
_getUrlFunc = new WeakMap();
_FetchRequest_instances = new WeakSet();
send_fn = async function(attempt, expires, delay, _request3, _response) {
  var _a2, _b2, _c2;
  if (attempt >= __privateGet(this, _throttle).maxAttempts) {
    return _response.makeServerError("exceeded maximum retry limit");
  }
  assert(getTime$1() <= expires, "timeout", "TIMEOUT", {
    operation: "request.send",
    reason: "timeout",
    request: _request3
  });
  if (delay > 0) {
    await wait(delay);
  }
  let req = this.clone();
  const scheme = (req.url.split(":")[0] || "").toLowerCase();
  if (scheme in Gateways) {
    const result = await Gateways[scheme](req.url, checkSignal(__privateGet(_request3, _signal)));
    if (result instanceof FetchResponse) {
      let response2 = result;
      if (this.processFunc) {
        checkSignal(__privateGet(_request3, _signal));
        try {
          response2 = await this.processFunc(req, response2);
        } catch (error) {
          if (error.throttle == null || typeof error.stall !== "number") {
            response2.makeServerError("error in post-processing function", error).assertOk();
          }
        }
      }
      return response2;
    }
    req = result;
  }
  if (this.preflightFunc) {
    req = await this.preflightFunc(req);
  }
  const resp = await this.getUrlFunc(req, checkSignal(__privateGet(_request3, _signal)));
  let response = new FetchResponse(resp.statusCode, resp.statusMessage, resp.headers, resp.body, _request3);
  if (response.statusCode === 301 || response.statusCode === 302) {
    try {
      const location = response.headers.location || "";
      return __privateMethod(_a2 = req.redirect(location), _FetchRequest_instances, send_fn).call(_a2, attempt + 1, expires, 0, _request3, response);
    } catch (error) {
    }
    return response;
  } else if (response.statusCode === 429) {
    if (this.retryFunc == null || await this.retryFunc(req, response, attempt)) {
      const retryAfter = response.headers["retry-after"];
      let delay2 = __privateGet(this, _throttle).slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));
      if (typeof retryAfter === "string" && retryAfter.match(/^[1-9][0-9]*$/)) {
        delay2 = parseInt(retryAfter);
      }
      return __privateMethod(_b2 = req.clone(), _FetchRequest_instances, send_fn).call(_b2, attempt + 1, expires, delay2, _request3, response);
    }
  }
  if (this.processFunc) {
    checkSignal(__privateGet(_request3, _signal));
    try {
      response = await this.processFunc(req, response);
    } catch (error) {
      if (error.throttle == null || typeof error.stall !== "number") {
        response.makeServerError("error in post-processing function", error).assertOk();
      }
      let delay2 = __privateGet(this, _throttle).slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));
      if (error.stall >= 0) {
        delay2 = error.stall;
      }
      return __privateMethod(_c2 = req.clone(), _FetchRequest_instances, send_fn).call(_c2, attempt + 1, expires, delay2, _request3, response);
    }
  }
  return response;
};
let FetchRequest = _FetchRequest;
const _FetchResponse = class _FetchResponse {
  constructor(statusCode, statusMessage, headers, body, request2) {
    __privateAdd(this, _statusCode);
    __privateAdd(this, _statusMessage);
    __privateAdd(this, _headers2);
    __privateAdd(this, _body2);
    __privateAdd(this, _request);
    __privateAdd(this, _error);
    __privateSet(this, _statusCode, statusCode);
    __privateSet(this, _statusMessage, statusMessage);
    __privateSet(this, _headers2, Object.keys(headers).reduce((accum, k2) => {
      accum[k2.toLowerCase()] = String(headers[k2]);
      return accum;
    }, {}));
    __privateSet(this, _body2, body == null ? null : new Uint8Array(body));
    __privateSet(this, _request, request2 || null);
    __privateSet(this, _error, { message: "" });
  }
  toString() {
    return `<FetchResponse status=${this.statusCode} body=${__privateGet(this, _body2) ? hexlify(__privateGet(this, _body2)) : "null"}>`;
  }
  /**
   *  The response status code.
   */
  get statusCode() {
    return __privateGet(this, _statusCode);
  }
  /**
   *  The response status message.
   */
  get statusMessage() {
    return __privateGet(this, _statusMessage);
  }
  /**
   *  The response headers. All keys are lower-case.
   */
  get headers() {
    return Object.assign({}, __privateGet(this, _headers2));
  }
  /**
   *  The response body, or ``null`` if there was no body.
   */
  get body() {
    return __privateGet(this, _body2) == null ? null : new Uint8Array(__privateGet(this, _body2));
  }
  /**
   *  The response body as a UTF-8 encoded string, or the empty
   *  string (i.e. ``""``) if there was no body.
   *
   *  An error is thrown if the body is invalid UTF-8 data.
   */
  get bodyText() {
    try {
      return __privateGet(this, _body2) == null ? "" : toUtf8String(__privateGet(this, _body2));
    } catch (error) {
      assert(false, "response body is not valid UTF-8 data", "UNSUPPORTED_OPERATION", {
        operation: "bodyText",
        info: { response: this }
      });
    }
  }
  /**
   *  The response body, decoded as JSON.
   *
   *  An error is thrown if the body is invalid JSON-encoded data
   *  or if there was no body.
   */
  get bodyJson() {
    try {
      return JSON.parse(this.bodyText);
    } catch (error) {
      assert(false, "response body is not valid JSON", "UNSUPPORTED_OPERATION", {
        operation: "bodyJson",
        info: { response: this }
      });
    }
  }
  [Symbol.iterator]() {
    const headers = this.headers;
    const keys = Object.keys(headers);
    let index = 0;
    return {
      next: () => {
        if (index < keys.length) {
          const key = keys[index++];
          return {
            value: [key, headers[key]],
            done: false
          };
        }
        return { value: void 0, done: true };
      }
    };
  }
  /**
   *  Return a Response with matching headers and body, but with
   *  an error status code (i.e. 599) and %%message%% with an
   *  optional %%error%%.
   */
  makeServerError(message, error) {
    let statusMessage;
    if (!message) {
      message = `${this.statusCode} ${this.statusMessage}`;
      statusMessage = `CLIENT ESCALATED SERVER ERROR (${message})`;
    } else {
      statusMessage = `CLIENT ESCALATED SERVER ERROR (${this.statusCode} ${this.statusMessage}; ${message})`;
    }
    const response = new _FetchResponse(599, statusMessage, this.headers, this.body, __privateGet(this, _request) || void 0);
    __privateSet(response, _error, { message, error });
    return response;
  }
  /**
   *  If called within a [request.processFunc](FetchRequest-processFunc)
   *  call, causes the request to retry as if throttled for %%stall%%
   *  milliseconds.
   */
  throwThrottleError(message, stall2) {
    if (stall2 == null) {
      stall2 = -1;
    } else {
      assertArgument(Number.isInteger(stall2) && stall2 >= 0, "invalid stall timeout", "stall", stall2);
    }
    const error = new Error(message || "throttling requests");
    defineProperties(error, { stall: stall2, throttle: true });
    throw error;
  }
  /**
   *  Get the header value for %%key%%, ignoring case.
   */
  getHeader(key) {
    return this.headers[key.toLowerCase()];
  }
  /**
   *  Returns true if the response has a body.
   */
  hasBody() {
    return __privateGet(this, _body2) != null;
  }
  /**
   *  The request made for this response.
   */
  get request() {
    return __privateGet(this, _request);
  }
  /**
   *  Returns true if this response was a success statusCode.
   */
  ok() {
    return __privateGet(this, _error).message === "" && this.statusCode >= 200 && this.statusCode < 300;
  }
  /**
   *  Throws a ``SERVER_ERROR`` if this response is not ok.
   */
  assertOk() {
    if (this.ok()) {
      return;
    }
    let { message, error } = __privateGet(this, _error);
    if (message === "") {
      message = `server response ${this.statusCode} ${this.statusMessage}`;
    }
    let requestUrl = null;
    if (this.request) {
      requestUrl = this.request.url;
    }
    let responseBody = null;
    try {
      if (__privateGet(this, _body2)) {
        responseBody = toUtf8String(__privateGet(this, _body2));
      }
    } catch (e3) {
    }
    assert(false, message, "SERVER_ERROR", {
      request: this.request || "unknown request",
      response: this,
      error,
      info: {
        requestUrl,
        responseBody,
        responseStatus: `${this.statusCode} ${this.statusMessage}`
      }
    });
  }
};
_statusCode = new WeakMap();
_statusMessage = new WeakMap();
_headers2 = new WeakMap();
_body2 = new WeakMap();
_request = new WeakMap();
_error = new WeakMap();
let FetchResponse = _FetchResponse;
function getTime$1() {
  return (/* @__PURE__ */ new Date()).getTime();
}
function unpercent(value) {
  return toUtf8Bytes(value.replace(/%([0-9a-f][0-9a-f])/gi, (all, code) => {
    return String.fromCharCode(parseInt(code, 16));
  }));
}
function wait(delay) {
  return new Promise((resolve) => setTimeout(resolve, delay));
}
const BN_N1 = BigInt(-1);
const BN_0$8 = BigInt(0);
const BN_1$3 = BigInt(1);
const BN_5 = BigInt(5);
const _guard$3 = {};
let Zeros$1 = "0000";
while (Zeros$1.length < 80) {
  Zeros$1 += Zeros$1;
}
function getTens(decimals) {
  let result = Zeros$1;
  while (result.length < decimals) {
    result += result;
  }
  return BigInt("1" + result.substring(0, decimals));
}
function checkValue(val, format2, safeOp) {
  const width = BigInt(format2.width);
  if (format2.signed) {
    const limit = BN_1$3 << width - BN_1$3;
    assert(safeOp == null || val >= -limit && val < limit, "overflow", "NUMERIC_FAULT", {
      operation: safeOp,
      fault: "overflow",
      value: val
    });
    if (val > BN_0$8) {
      val = fromTwos(mask(val, width), width);
    } else {
      val = -fromTwos(mask(-val, width), width);
    }
  } else {
    const limit = BN_1$3 << width;
    assert(safeOp == null || val >= 0 && val < limit, "overflow", "NUMERIC_FAULT", {
      operation: safeOp,
      fault: "overflow",
      value: val
    });
    val = (val % limit + limit) % limit & limit - BN_1$3;
  }
  return val;
}
function getFormat(value) {
  if (typeof value === "number") {
    value = `fixed128x${value}`;
  }
  let signed = true;
  let width = 128;
  let decimals = 18;
  if (typeof value === "string") {
    if (value === "fixed") ;
    else if (value === "ufixed") {
      signed = false;
    } else {
      const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
      assertArgument(match, "invalid fixed format", "format", value);
      signed = match[1] !== "u";
      width = parseInt(match[2]);
      decimals = parseInt(match[3]);
    }
  } else if (value) {
    const v2 = value;
    const check = (key, type, defaultValue) => {
      if (v2[key] == null) {
        return defaultValue;
      }
      assertArgument(typeof v2[key] === type, "invalid fixed format (" + key + " not " + type + ")", "format." + key, v2[key]);
      return v2[key];
    };
    signed = check("signed", "boolean", signed);
    width = check("width", "number", width);
    decimals = check("decimals", "number", decimals);
  }
  assertArgument(width % 8 === 0, "invalid FixedNumber width (not byte aligned)", "format.width", width);
  assertArgument(decimals <= 80, "invalid FixedNumber decimals (too large)", "format.decimals", decimals);
  const name = (signed ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
  return { signed, width, decimals, name };
}
function toString(val, decimals) {
  let negative = "";
  if (val < BN_0$8) {
    negative = "-";
    val *= BN_N1;
  }
  let str = val.toString();
  if (decimals === 0) {
    return negative + str;
  }
  while (str.length <= decimals) {
    str = Zeros$1 + str;
  }
  const index = str.length - decimals;
  str = str.substring(0, index) + "." + str.substring(index);
  while (str[0] === "0" && str[1] !== ".") {
    str = str.substring(1);
  }
  while (str[str.length - 1] === "0" && str[str.length - 2] !== ".") {
    str = str.substring(0, str.length - 1);
  }
  return negative + str;
}
const _FixedNumber = class _FixedNumber {
  // Use this when changing this file to get some typing info,
  // but then switch to any to mask the internal type
  //constructor(guard: any, value: bigint, format: _FixedFormat) {
  /**
   *  @private
   */
  constructor(guard, value, format2) {
    __privateAdd(this, _FixedNumber_instances);
    /**
     *  The specific fixed-point arithmetic field for this value.
     */
    __publicField(this, "format");
    __privateAdd(this, _format);
    // The actual value (accounting for decimals)
    __privateAdd(this, _val);
    // A base-10 value to multiple values by to maintain the magnitude
    __privateAdd(this, _tens);
    /**
     *  This is a property so console.log shows a human-meaningful value.
     *
     *  @private
     */
    __publicField(this, "_value");
    assertPrivate(guard, _guard$3, "FixedNumber");
    __privateSet(this, _val, value);
    __privateSet(this, _format, format2);
    const _value2 = toString(value, format2.decimals);
    defineProperties(this, { format: format2.name, _value: _value2 });
    __privateSet(this, _tens, getTens(format2.decimals));
  }
  /**
   *  If true, negative values are permitted, otherwise only
   *  positive values and zero are allowed.
   */
  get signed() {
    return __privateGet(this, _format).signed;
  }
  /**
   *  The number of bits available to store the value.
   */
  get width() {
    return __privateGet(this, _format).width;
  }
  /**
   *  The number of decimal places in the fixed-point arithment field.
   */
  get decimals() {
    return __privateGet(this, _format).decimals;
  }
  /**
   *  The value as an integer, based on the smallest unit the
   *  [[decimals]] allow.
   */
  get value() {
    return __privateGet(this, _val);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% added
   *  to %%other%%, ignoring overflow.
   */
  addUnsafe(other) {
    return __privateMethod(this, _FixedNumber_instances, add_fn).call(this, other);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% added
   *  to %%other%%. A [[NumericFaultError]] is thrown if overflow
   *  occurs.
   */
  add(other) {
    return __privateMethod(this, _FixedNumber_instances, add_fn).call(this, other, "add");
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted
   *  from %%this%%, ignoring overflow.
   */
  subUnsafe(other) {
    return __privateMethod(this, _FixedNumber_instances, sub_fn).call(this, other);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted
   *  from %%this%%. A [[NumericFaultError]] is thrown if overflow
   *  occurs.
   */
  sub(other) {
    return __privateMethod(this, _FixedNumber_instances, sub_fn).call(this, other, "sub");
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied
   *  by %%other%%, ignoring overflow and underflow (precision loss).
   */
  mulUnsafe(other) {
    return __privateMethod(this, _FixedNumber_instances, mul_fn).call(this, other);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied
   *  by %%other%%. A [[NumericFaultError]] is thrown if overflow
   *  occurs.
   */
  mul(other) {
    return __privateMethod(this, _FixedNumber_instances, mul_fn).call(this, other, "mul");
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied
   *  by %%other%%. A [[NumericFaultError]] is thrown if overflow
   *  occurs or if underflow (precision loss) occurs.
   */
  mulSignal(other) {
    __privateMethod(this, _FixedNumber_instances, checkFormat_fn).call(this, other);
    const value = __privateGet(this, _val) * __privateGet(other, _val);
    assert(value % __privateGet(this, _tens) === BN_0$8, "precision lost during signalling mul", "NUMERIC_FAULT", {
      operation: "mulSignal",
      fault: "underflow",
      value: this
    });
    return __privateMethod(this, _FixedNumber_instances, checkValue_fn).call(this, value / __privateGet(this, _tens), "mulSignal");
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% divided
   *  by %%other%%, ignoring underflow (precision loss). A
   *  [[NumericFaultError]] is thrown if overflow occurs.
   */
  divUnsafe(other) {
    return __privateMethod(this, _FixedNumber_instances, div_fn).call(this, other);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% divided
   *  by %%other%%, ignoring underflow (precision loss). A
   *  [[NumericFaultError]] is thrown if overflow occurs.
   */
  div(other) {
    return __privateMethod(this, _FixedNumber_instances, div_fn).call(this, other, "div");
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% divided
   *  by %%other%%. A [[NumericFaultError]] is thrown if underflow
   *  (precision loss) occurs.
   */
  divSignal(other) {
    assert(__privateGet(other, _val) !== BN_0$8, "division by zero", "NUMERIC_FAULT", {
      operation: "div",
      fault: "divide-by-zero",
      value: this
    });
    __privateMethod(this, _FixedNumber_instances, checkFormat_fn).call(this, other);
    const value = __privateGet(this, _val) * __privateGet(this, _tens);
    assert(value % __privateGet(other, _val) === BN_0$8, "precision lost during signalling div", "NUMERIC_FAULT", {
      operation: "divSignal",
      fault: "underflow",
      value: this
    });
    return __privateMethod(this, _FixedNumber_instances, checkValue_fn).call(this, value / __privateGet(other, _val), "divSignal");
  }
  /**
   *  Returns a comparison result between %%this%% and %%other%%.
   *
   *  This is suitable for use in sorting, where ``-1`` implies %%this%%
   *  is smaller, ``1`` implies %%this%% is larger and ``0`` implies
   *  both are equal.
   */
  cmp(other) {
    let a2 = this.value, b2 = other.value;
    const delta = this.decimals - other.decimals;
    if (delta > 0) {
      b2 *= getTens(delta);
    } else if (delta < 0) {
      a2 *= getTens(-delta);
    }
    if (a2 < b2) {
      return -1;
    }
    if (a2 > b2) {
      return 1;
    }
    return 0;
  }
  /**
   *  Returns true if %%other%% is equal to %%this%%.
   */
  eq(other) {
    return this.cmp(other) === 0;
  }
  /**
   *  Returns true if %%other%% is less than to %%this%%.
   */
  lt(other) {
    return this.cmp(other) < 0;
  }
  /**
   *  Returns true if %%other%% is less than or equal to %%this%%.
   */
  lte(other) {
    return this.cmp(other) <= 0;
  }
  /**
   *  Returns true if %%other%% is greater than to %%this%%.
   */
  gt(other) {
    return this.cmp(other) > 0;
  }
  /**
   *  Returns true if %%other%% is greater than or equal to %%this%%.
   */
  gte(other) {
    return this.cmp(other) >= 0;
  }
  /**
   *  Returns a new [[FixedNumber]] which is the largest **integer**
   *  that is less than or equal to %%this%%.
   *
   *  The decimal component of the result will always be ``0``.
   */
  floor() {
    let val = __privateGet(this, _val);
    if (__privateGet(this, _val) < BN_0$8) {
      val -= __privateGet(this, _tens) - BN_1$3;
    }
    val = __privateGet(this, _val) / __privateGet(this, _tens) * __privateGet(this, _tens);
    return __privateMethod(this, _FixedNumber_instances, checkValue_fn).call(this, val, "floor");
  }
  /**
   *  Returns a new [[FixedNumber]] which is the smallest **integer**
   *  that is greater than or equal to %%this%%.
   *
   *  The decimal component of the result will always be ``0``.
   */
  ceiling() {
    let val = __privateGet(this, _val);
    if (__privateGet(this, _val) > BN_0$8) {
      val += __privateGet(this, _tens) - BN_1$3;
    }
    val = __privateGet(this, _val) / __privateGet(this, _tens) * __privateGet(this, _tens);
    return __privateMethod(this, _FixedNumber_instances, checkValue_fn).call(this, val, "ceiling");
  }
  /**
   *  Returns a new [[FixedNumber]] with the decimal component
   *  rounded up on ties at %%decimals%% places.
   */
  round(decimals) {
    if (decimals == null) {
      decimals = 0;
    }
    if (decimals >= this.decimals) {
      return this;
    }
    const delta = this.decimals - decimals;
    const bump = BN_5 * getTens(delta - 1);
    let value = this.value + bump;
    const tens = getTens(delta);
    value = value / tens * tens;
    checkValue(value, __privateGet(this, _format), "round");
    return new _FixedNumber(_guard$3, value, __privateGet(this, _format));
  }
  /**
   *  Returns true if %%this%% is equal to ``0``.
   */
  isZero() {
    return __privateGet(this, _val) === BN_0$8;
  }
  /**
   *  Returns true if %%this%% is less than ``0``.
   */
  isNegative() {
    return __privateGet(this, _val) < BN_0$8;
  }
  /**
   *  Returns the string representation of %%this%%.
   */
  toString() {
    return this._value;
  }
  /**
   *  Returns a float approximation.
   *
   *  Due to IEEE 754 precission (or lack thereof), this function
   *  can only return an approximation and most values will contain
   *  rounding errors.
   */
  toUnsafeFloat() {
    return parseFloat(this.toString());
  }
  /**
   *  Return a new [[FixedNumber]] with the same value but has had
   *  its field set to %%format%%.
   *
   *  This will throw if the value cannot fit into %%format%%.
   */
  toFormat(format2) {
    return _FixedNumber.fromString(this.toString(), format2);
  }
  /**
   *  Creates a new [[FixedNumber]] for %%value%% divided by
   *  %%decimal%% places with %%format%%.
   *
   *  This will throw a [[NumericFaultError]] if %%value%% (once adjusted
   *  for %%decimals%%) cannot fit in %%format%%, either due to overflow
   *  or underflow (precision loss).
   */
  static fromValue(_value2, _decimals, _format2) {
    const decimals = _decimals == null ? 0 : getNumber(_decimals);
    const format2 = getFormat(_format2);
    let value = getBigInt(_value2, "value");
    const delta = decimals - format2.decimals;
    if (delta > 0) {
      const tens = getTens(delta);
      assert(value % tens === BN_0$8, "value loses precision for format", "NUMERIC_FAULT", {
        operation: "fromValue",
        fault: "underflow",
        value: _value2
      });
      value /= tens;
    } else if (delta < 0) {
      value *= getTens(-delta);
    }
    checkValue(value, format2, "fromValue");
    return new _FixedNumber(_guard$3, value, format2);
  }
  /**
   *  Creates a new [[FixedNumber]] for %%value%% with %%format%%.
   *
   *  This will throw a [[NumericFaultError]] if %%value%% cannot fit
   *  in %%format%%, either due to overflow or underflow (precision loss).
   */
  static fromString(_value2, _format2) {
    const match = _value2.match(/^(-?)([0-9]*)\.?([0-9]*)$/);
    assertArgument(match && match[2].length + match[3].length > 0, "invalid FixedNumber string value", "value", _value2);
    const format2 = getFormat(_format2);
    let whole = match[2] || "0", decimal = match[3] || "";
    while (decimal.length < format2.decimals) {
      decimal += Zeros$1;
    }
    assert(decimal.substring(format2.decimals).match(/^0*$/), "too many decimals for format", "NUMERIC_FAULT", {
      operation: "fromString",
      fault: "underflow",
      value: _value2
    });
    decimal = decimal.substring(0, format2.decimals);
    const value = BigInt(match[1] + whole + decimal);
    checkValue(value, format2, "fromString");
    return new _FixedNumber(_guard$3, value, format2);
  }
  /**
   *  Creates a new [[FixedNumber]] with the big-endian representation
   *  %%value%% with %%format%%.
   *
   *  This will throw a [[NumericFaultError]] if %%value%% cannot fit
   *  in %%format%% due to overflow.
   */
  static fromBytes(_value2, _format2) {
    let value = toBigInt(getBytes(_value2, "value"));
    const format2 = getFormat(_format2);
    if (format2.signed) {
      value = fromTwos(value, format2.width);
    }
    checkValue(value, format2, "fromBytes");
    return new _FixedNumber(_guard$3, value, format2);
  }
};
_format = new WeakMap();
_val = new WeakMap();
_tens = new WeakMap();
_FixedNumber_instances = new WeakSet();
checkFormat_fn = function(other) {
  assertArgument(this.format === other.format, "incompatible format; use fixedNumber.toFormat", "other", other);
};
checkValue_fn = function(val, safeOp) {
  val = checkValue(val, __privateGet(this, _format), safeOp);
  return new _FixedNumber(_guard$3, val, __privateGet(this, _format));
};
add_fn = function(o, safeOp) {
  __privateMethod(this, _FixedNumber_instances, checkFormat_fn).call(this, o);
  return __privateMethod(this, _FixedNumber_instances, checkValue_fn).call(this, __privateGet(this, _val) + __privateGet(o, _val), safeOp);
};
sub_fn = function(o, safeOp) {
  __privateMethod(this, _FixedNumber_instances, checkFormat_fn).call(this, o);
  return __privateMethod(this, _FixedNumber_instances, checkValue_fn).call(this, __privateGet(this, _val) - __privateGet(o, _val), safeOp);
};
mul_fn = function(o, safeOp) {
  __privateMethod(this, _FixedNumber_instances, checkFormat_fn).call(this, o);
  return __privateMethod(this, _FixedNumber_instances, checkValue_fn).call(this, __privateGet(this, _val) * __privateGet(o, _val) / __privateGet(this, _tens), safeOp);
};
div_fn = function(o, safeOp) {
  assert(__privateGet(o, _val) !== BN_0$8, "division by zero", "NUMERIC_FAULT", {
    operation: "div",
    fault: "divide-by-zero",
    value: this
  });
  __privateMethod(this, _FixedNumber_instances, checkFormat_fn).call(this, o);
  return __privateMethod(this, _FixedNumber_instances, checkValue_fn).call(this, __privateGet(this, _val) * __privateGet(this, _tens) / __privateGet(o, _val), safeOp);
};
let FixedNumber = _FixedNumber;
function hexlifyByte(value) {
  let result = value.toString(16);
  while (result.length < 2) {
    result = "0" + result;
  }
  return "0x" + result;
}
function unarrayifyInteger(data, offset, length) {
  let result = 0;
  for (let i = 0; i < length; i++) {
    result = result * 256 + data[offset + i];
  }
  return result;
}
function _decodeChildren(data, offset, childOffset, length) {
  const result = [];
  while (childOffset < offset + 1 + length) {
    const decoded = _decode(data, childOffset);
    result.push(decoded.result);
    childOffset += decoded.consumed;
    assert(childOffset <= offset + 1 + length, "child data too short", "BUFFER_OVERRUN", {
      buffer: data,
      length,
      offset
    });
  }
  return { consumed: 1 + length, result };
}
function _decode(data, offset) {
  assert(data.length !== 0, "data too short", "BUFFER_OVERRUN", {
    buffer: data,
    length: 0,
    offset: 1
  });
  const checkOffset = (offset2) => {
    assert(offset2 <= data.length, "data short segment too short", "BUFFER_OVERRUN", {
      buffer: data,
      length: data.length,
      offset: offset2
    });
  };
  if (data[offset] >= 248) {
    const lengthLength = data[offset] - 247;
    checkOffset(offset + 1 + lengthLength);
    const length = unarrayifyInteger(data, offset + 1, lengthLength);
    checkOffset(offset + 1 + lengthLength + length);
    return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);
  } else if (data[offset] >= 192) {
    const length = data[offset] - 192;
    checkOffset(offset + 1 + length);
    return _decodeChildren(data, offset, offset + 1, length);
  } else if (data[offset] >= 184) {
    const lengthLength = data[offset] - 183;
    checkOffset(offset + 1 + lengthLength);
    const length = unarrayifyInteger(data, offset + 1, lengthLength);
    checkOffset(offset + 1 + lengthLength + length);
    const result = hexlify(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));
    return { consumed: 1 + lengthLength + length, result };
  } else if (data[offset] >= 128) {
    const length = data[offset] - 128;
    checkOffset(offset + 1 + length);
    const result = hexlify(data.slice(offset + 1, offset + 1 + length));
    return { consumed: 1 + length, result };
  }
  return { consumed: 1, result: hexlifyByte(data[offset]) };
}
function decodeRlp(_data4) {
  const data = getBytes(_data4, "data");
  const decoded = _decode(data, 0);
  assertArgument(decoded.consumed === data.length, "unexpected junk after rlp payload", "data", _data4);
  return decoded.result;
}
function arrayifyInteger(value) {
  const result = [];
  while (value) {
    result.unshift(value & 255);
    value >>= 8;
  }
  return result;
}
function _encode(object2) {
  if (Array.isArray(object2)) {
    let payload = [];
    object2.forEach(function(child) {
      payload = payload.concat(_encode(child));
    });
    if (payload.length <= 55) {
      payload.unshift(192 + payload.length);
      return payload;
    }
    const length2 = arrayifyInteger(payload.length);
    length2.unshift(247 + length2.length);
    return length2.concat(payload);
  }
  const data = Array.prototype.slice.call(getBytes(object2, "object"));
  if (data.length === 1 && data[0] <= 127) {
    return data;
  } else if (data.length <= 55) {
    data.unshift(128 + data.length);
    return data;
  }
  const length = arrayifyInteger(data.length);
  length.unshift(183 + length.length);
  return length.concat(data);
}
const nibbles = "0123456789abcdef";
function encodeRlp(object2) {
  let result = "0x";
  for (const v2 of _encode(object2)) {
    result += nibbles[v2 >> 4];
    result += nibbles[v2 & 15];
  }
  return result;
}
const names = [
  "wei",
  "kwei",
  "mwei",
  "gwei",
  "szabo",
  "finney",
  "ether"
];
function formatUnits(value, unit) {
  let decimals = 18;
  if (typeof unit === "string") {
    const index = names.indexOf(unit);
    assertArgument(index >= 0, "invalid unit", "unit", unit);
    decimals = 3 * index;
  } else if (unit != null) {
    decimals = getNumber(unit, "unit");
  }
  return FixedNumber.fromValue(value, decimals, { decimals, width: 512 }).toString();
}
function parseUnits$1(value, unit) {
  assertArgument(typeof value === "string", "value must be a string", "value", value);
  let decimals = 18;
  if (typeof unit === "string") {
    const index = names.indexOf(unit);
    assertArgument(index >= 0, "invalid unit", "unit", unit);
    decimals = 3 * index;
  } else if (unit != null) {
    decimals = getNumber(unit, "unit");
  }
  return FixedNumber.fromString(value, { decimals, width: 512 }).value;
}
const WordSize = 32;
const Padding = new Uint8Array(WordSize);
const passProperties$1 = ["then"];
const _guard$2 = {};
const resultNames = /* @__PURE__ */ new WeakMap();
function getNames(result) {
  return resultNames.get(result);
}
function setNames(result, names2) {
  resultNames.set(result, names2);
}
function throwError(name, error) {
  const wrapped = new Error(`deferred error during ABI decoding triggered accessing ${name}`);
  wrapped.error = error;
  throw wrapped;
}
function toObject(names2, items, deep) {
  if (names2.indexOf(null) >= 0) {
    return items.map((item, index) => {
      if (item instanceof Result) {
        return toObject(getNames(item), item, deep);
      }
      return item;
    });
  }
  return names2.reduce((accum, name, index) => {
    let item = items.getValue(name);
    if (!(name in accum)) {
      if (deep && item instanceof Result) {
        item = toObject(getNames(item), item, deep);
      }
      accum[name] = item;
    }
    return accum;
  }, {});
}
const _Result = class _Result extends Array {
  /**
   *  @private
   */
  constructor(...args) {
    const guard = args[0];
    let items = args[1];
    let names2 = (args[2] || []).slice();
    let wrap = true;
    if (guard !== _guard$2) {
      items = args;
      names2 = [];
      wrap = false;
    }
    super(items.length);
    // No longer used; but cannot be removed as it will remove the
    // #private field from the .d.ts which may break backwards
    // compatibility
    __privateAdd(this, _names);
    items.forEach((item, index) => {
      this[index] = item;
    });
    const nameCounts = names2.reduce((accum, name) => {
      if (typeof name === "string") {
        accum.set(name, (accum.get(name) || 0) + 1);
      }
      return accum;
    }, /* @__PURE__ */ new Map());
    setNames(this, Object.freeze(items.map((item, index) => {
      const name = names2[index];
      if (name != null && nameCounts.get(name) === 1) {
        return name;
      }
      return null;
    })));
    __privateSet(this, _names, []);
    if (__privateGet(this, _names) == null) {
      void __privateGet(this, _names);
    }
    if (!wrap) {
      return;
    }
    Object.freeze(this);
    const proxy = new Proxy(this, {
      get: (target, prop2, receiver) => {
        if (typeof prop2 === "string") {
          if (prop2.match(/^[0-9]+$/)) {
            const index = getNumber(prop2, "%index");
            if (index < 0 || index >= this.length) {
              throw new RangeError("out of result range");
            }
            const item = target[index];
            if (item instanceof Error) {
              throwError(`index ${index}`, item);
            }
            return item;
          }
          if (passProperties$1.indexOf(prop2) >= 0) {
            return Reflect.get(target, prop2, receiver);
          }
          const value = target[prop2];
          if (value instanceof Function) {
            return function(...args2) {
              return value.apply(this === receiver ? target : this, args2);
            };
          } else if (!(prop2 in target)) {
            return target.getValue.apply(this === receiver ? target : this, [prop2]);
          }
        }
        return Reflect.get(target, prop2, receiver);
      }
    });
    setNames(proxy, getNames(this));
    return proxy;
  }
  /**
   *  Returns the Result as a normal Array. If %%deep%%, any children
   *  which are Result objects are also converted to a normal Array.
   *
   *  This will throw if there are any outstanding deferred
   *  errors.
   */
  toArray(deep) {
    const result = [];
    this.forEach((item, index) => {
      if (item instanceof Error) {
        throwError(`index ${index}`, item);
      }
      if (deep && item instanceof _Result) {
        item = item.toArray(deep);
      }
      result.push(item);
    });
    return result;
  }
  /**
   *  Returns the Result as an Object with each name-value pair. If
   *  %%deep%%, any children which are Result objects are also
   *  converted to an Object.
   *
   *  This will throw if any value is unnamed, or if there are
   *  any outstanding deferred errors.
   */
  toObject(deep) {
    const names2 = getNames(this);
    return names2.reduce((accum, name, index) => {
      assert(name != null, `value at index ${index} unnamed`, "UNSUPPORTED_OPERATION", {
        operation: "toObject()"
      });
      return toObject(names2, this, deep);
    }, {});
  }
  /**
   *  @_ignore
   */
  slice(start, end) {
    if (start == null) {
      start = 0;
    }
    if (start < 0) {
      start += this.length;
      if (start < 0) {
        start = 0;
      }
    }
    if (end == null) {
      end = this.length;
    }
    if (end < 0) {
      end += this.length;
      if (end < 0) {
        end = 0;
      }
    }
    if (end > this.length) {
      end = this.length;
    }
    const _names2 = getNames(this);
    const result = [], names2 = [];
    for (let i = start; i < end; i++) {
      result.push(this[i]);
      names2.push(_names2[i]);
    }
    return new _Result(_guard$2, result, names2);
  }
  /**
   *  @_ignore
   */
  filter(callback, thisArg) {
    const _names2 = getNames(this);
    const result = [], names2 = [];
    for (let i = 0; i < this.length; i++) {
      const item = this[i];
      if (item instanceof Error) {
        throwError(`index ${i}`, item);
      }
      if (callback.call(thisArg, item, i, this)) {
        result.push(item);
        names2.push(_names2[i]);
      }
    }
    return new _Result(_guard$2, result, names2);
  }
  /**
   *  @_ignore
   */
  map(callback, thisArg) {
    const result = [];
    for (let i = 0; i < this.length; i++) {
      const item = this[i];
      if (item instanceof Error) {
        throwError(`index ${i}`, item);
      }
      result.push(callback.call(thisArg, item, i, this));
    }
    return result;
  }
  /**
   *  Returns the value for %%name%%.
   *
   *  Since it is possible to have a key whose name conflicts with
   *  a method on a [[Result]] or its superclass Array, or any
   *  JavaScript keyword, this ensures all named values are still
   *  accessible by name.
   */
  getValue(name) {
    const index = getNames(this).indexOf(name);
    if (index === -1) {
      return void 0;
    }
    const value = this[index];
    if (value instanceof Error) {
      throwError(`property ${JSON.stringify(name)}`, value.error);
    }
    return value;
  }
  /**
   *  Creates a new [[Result]] for %%items%% with each entry
   *  also accessible by its corresponding name in %%keys%%.
   */
  static fromItems(items, keys) {
    return new _Result(_guard$2, items, keys);
  }
};
_names = new WeakMap();
let Result = _Result;
function getValue$1(value) {
  let bytes = toBeArray(value);
  assert(bytes.length <= WordSize, "value out-of-bounds", "BUFFER_OVERRUN", { buffer: bytes, length: WordSize, offset: bytes.length });
  if (bytes.length !== WordSize) {
    bytes = getBytesCopy(concat([Padding.slice(bytes.length % WordSize), bytes]));
  }
  return bytes;
}
class Coder {
  constructor(name, type, localName, dynamic) {
    // The coder name:
    //   - address, uint256, tuple, array, etc.
    __publicField(this, "name");
    // The fully expanded type, including composite types:
    //   - address, uint256, tuple(address,bytes), uint256[3][4][],  etc.
    __publicField(this, "type");
    // The localName bound in the signature, in this example it is "baz":
    //   - tuple(address foo, uint bar) baz
    __publicField(this, "localName");
    // Whether this type is dynamic:
    //  - Dynamic: bytes, string, address[], tuple(boolean[]), etc.
    //  - Not Dynamic: address, uint256, boolean[3], tuple(address, uint8)
    __publicField(this, "dynamic");
    defineProperties(this, { name, type, localName, dynamic }, {
      name: "string",
      type: "string",
      localName: "string",
      dynamic: "boolean"
    });
  }
  _throwError(message, value) {
    assertArgument(false, message, this.localName, value);
  }
}
class Writer {
  constructor() {
    __privateAdd(this, _Writer_instances);
    // An array of WordSize lengthed objects to concatenation
    __privateAdd(this, _data);
    __privateAdd(this, _dataLength);
    __privateSet(this, _data, []);
    __privateSet(this, _dataLength, 0);
  }
  get data() {
    return concat(__privateGet(this, _data));
  }
  get length() {
    return __privateGet(this, _dataLength);
  }
  appendWriter(writer) {
    return __privateMethod(this, _Writer_instances, writeData_fn).call(this, getBytesCopy(writer.data));
  }
  // Arrayish item; pad on the right to *nearest* WordSize
  writeBytes(value) {
    let bytes = getBytesCopy(value);
    const paddingOffset = bytes.length % WordSize;
    if (paddingOffset) {
      bytes = getBytesCopy(concat([bytes, Padding.slice(paddingOffset)]));
    }
    return __privateMethod(this, _Writer_instances, writeData_fn).call(this, bytes);
  }
  // Numeric item; pad on the left *to* WordSize
  writeValue(value) {
    return __privateMethod(this, _Writer_instances, writeData_fn).call(this, getValue$1(value));
  }
  // Inserts a numeric place-holder, returning a callback that can
  // be used to asjust the value later
  writeUpdatableValue() {
    const offset = __privateGet(this, _data).length;
    __privateGet(this, _data).push(Padding);
    __privateSet(this, _dataLength, __privateGet(this, _dataLength) + WordSize);
    return (value) => {
      __privateGet(this, _data)[offset] = getValue$1(value);
    };
  }
}
_data = new WeakMap();
_dataLength = new WeakMap();
_Writer_instances = new WeakSet();
writeData_fn = function(data) {
  __privateGet(this, _data).push(data);
  __privateSet(this, _dataLength, __privateGet(this, _dataLength) + data.length);
  return data.length;
};
const _Reader = class _Reader {
  constructor(data, allowLoose, maxInflation) {
    __privateAdd(this, _Reader_instances);
    // Allows incomplete unpadded data to be read; otherwise an error
    // is raised if attempting to overrun the buffer. This is required
    // to deal with an old Solidity bug, in which event data for
    // external (not public thoguh) was tightly packed.
    __publicField(this, "allowLoose");
    __privateAdd(this, _data2);
    __privateAdd(this, _offset);
    __privateAdd(this, _bytesRead);
    __privateAdd(this, _parent);
    __privateAdd(this, _maxInflation);
    defineProperties(this, { allowLoose: !!allowLoose });
    __privateSet(this, _data2, getBytesCopy(data));
    __privateSet(this, _bytesRead, 0);
    __privateSet(this, _parent, null);
    __privateSet(this, _maxInflation, maxInflation != null ? maxInflation : 1024);
    __privateSet(this, _offset, 0);
  }
  get data() {
    return hexlify(__privateGet(this, _data2));
  }
  get dataLength() {
    return __privateGet(this, _data2).length;
  }
  get consumed() {
    return __privateGet(this, _offset);
  }
  get bytes() {
    return new Uint8Array(__privateGet(this, _data2));
  }
  // Create a sub-reader with the same underlying data, but offset
  subReader(offset) {
    const reader = new _Reader(__privateGet(this, _data2).slice(__privateGet(this, _offset) + offset), this.allowLoose, __privateGet(this, _maxInflation));
    __privateSet(reader, _parent, this);
    return reader;
  }
  // Read bytes
  readBytes(length, loose) {
    let bytes = __privateMethod(this, _Reader_instances, peekBytes_fn).call(this, 0, length, !!loose);
    __privateMethod(this, _Reader_instances, incrementBytesRead_fn).call(this, length);
    __privateSet(this, _offset, __privateGet(this, _offset) + bytes.length);
    return bytes.slice(0, length);
  }
  // Read a numeric values
  readValue() {
    return toBigInt(this.readBytes(WordSize));
  }
  readIndex() {
    return toNumber(this.readBytes(WordSize));
  }
};
_data2 = new WeakMap();
_offset = new WeakMap();
_bytesRead = new WeakMap();
_parent = new WeakMap();
_maxInflation = new WeakMap();
_Reader_instances = new WeakSet();
incrementBytesRead_fn = function(count) {
  var _a2;
  if (__privateGet(this, _parent)) {
    return __privateMethod(_a2 = __privateGet(this, _parent), _Reader_instances, incrementBytesRead_fn).call(_a2, count);
  }
  __privateSet(this, _bytesRead, __privateGet(this, _bytesRead) + count);
  assert(__privateGet(this, _maxInflation) < 1 || __privateGet(this, _bytesRead) <= __privateGet(this, _maxInflation) * this.dataLength, `compressed ABI data exceeds inflation ratio of ${__privateGet(this, _maxInflation)} ( see: https://github.com/ethers-io/ethers.js/issues/4537 )`, "BUFFER_OVERRUN", {
    buffer: getBytesCopy(__privateGet(this, _data2)),
    offset: __privateGet(this, _offset),
    length: count,
    info: {
      bytesRead: __privateGet(this, _bytesRead),
      dataLength: this.dataLength
    }
  });
};
peekBytes_fn = function(offset, length, loose) {
  let alignedLength = Math.ceil(length / WordSize) * WordSize;
  if (__privateGet(this, _offset) + alignedLength > __privateGet(this, _data2).length) {
    if (this.allowLoose && loose && __privateGet(this, _offset) + length <= __privateGet(this, _data2).length) {
      alignedLength = length;
    } else {
      assert(false, "data out-of-bounds", "BUFFER_OVERRUN", {
        buffer: getBytesCopy(__privateGet(this, _data2)),
        length: __privateGet(this, _data2).length,
        offset: __privateGet(this, _offset) + alignedLength
      });
    }
  }
  return __privateGet(this, _data2).slice(__privateGet(this, _offset), __privateGet(this, _offset) + alignedLength);
};
let Reader = _Reader;
var createHash = require$$1$1;
var p$3 = require$$4;
p$3.pbkdf2;
p$3.pbkdf2Sync;
var aes = require$$5;
aes.Cipher;
aes.createCipher;
aes.Cipheriv;
aes.createCipheriv;
aes.Decipher;
aes.createDecipher;
aes.Decipheriv;
aes.createDecipheriv;
aes.getCiphers;
aes.listCiphers;
var dh = require$$6;
dh.DiffieHellmanGroup;
dh.createDiffieHellmanGroup;
dh.getDiffieHellman;
dh.createDiffieHellman;
dh.DiffieHellman;
var sign = require$$7;
sign.createSign;
sign.Sign;
sign.createVerify;
sign.Verify;
var publicEncrypt = require$$9;
publicEncrypt.publicEncrypt;
publicEncrypt.privateEncrypt;
publicEncrypt.publicDecrypt;
publicEncrypt.privateDecrypt;
var rf = require$$10;
rf.randomFill;
rf.randomFillSync;
let locked = false;
const _keccak256 = function(data) {
  return keccak_256(data);
};
let __keccak256 = _keccak256;
function keccak256(_data4) {
  const data = getBytes(_data4, "data");
  return hexlify(__keccak256(data));
}
keccak256._ = _keccak256;
keccak256.lock = function() {
  locked = true;
};
keccak256.register = function(func) {
  if (locked) {
    throw new TypeError("keccak256 is locked");
  }
  __keccak256 = func;
};
Object.freeze(keccak256);
const _sha256 = function(data) {
  return createHash("sha256").update(data).digest();
};
let __sha256 = _sha256;
let locked256 = false;
function sha256(_data4) {
  const data = getBytes(_data4, "data");
  return hexlify(__sha256(data));
}
sha256._ = _sha256;
sha256.lock = function() {
  locked256 = true;
};
sha256.register = function(func) {
  if (locked256) {
    throw new Error("sha256 is locked");
  }
  __sha256 = func;
};
Object.freeze(sha256);
Object.freeze(sha256);
const ZeroAddress = "0x0000000000000000000000000000000000000000";
const ZeroHash = "0x0000000000000000000000000000000000000000000000000000000000000000";
const BN_0$7 = BigInt(0);
const BN_1$2 = BigInt(1);
const BN_2$2 = BigInt(2);
const BN_27$1 = BigInt(27);
const BN_28$1 = BigInt(28);
const BN_35$1 = BigInt(35);
const _guard$1 = {};
function toUint256(value) {
  return zeroPadValue(toBeArray(value), 32);
}
const _Signature = class _Signature {
  /**
   *  @private
   */
  constructor(guard, r3, s, v2) {
    __privateAdd(this, _r2);
    __privateAdd(this, _s);
    __privateAdd(this, _v);
    __privateAdd(this, _networkV);
    assertPrivate(guard, _guard$1, "Signature");
    __privateSet(this, _r2, r3);
    __privateSet(this, _s, s);
    __privateSet(this, _v, v2);
    __privateSet(this, _networkV, null);
  }
  /**
   *  The ``r`` value for a signautre.
   *
   *  This represents the ``x`` coordinate of a "reference" or
   *  challenge point, from which the ``y`` can be computed.
   */
  get r() {
    return __privateGet(this, _r2);
  }
  set r(value) {
    assertArgument(dataLength(value) === 32, "invalid r", "value", value);
    __privateSet(this, _r2, hexlify(value));
  }
  /**
   *  The ``s`` value for a signature.
   */
  get s() {
    return __privateGet(this, _s);
  }
  set s(_value2) {
    assertArgument(dataLength(_value2) === 32, "invalid s", "value", _value2);
    const value = hexlify(_value2);
    assertArgument(parseInt(value.substring(0, 3)) < 8, "non-canonical s", "value", value);
    __privateSet(this, _s, value);
  }
  /**
   *  The ``v`` value for a signature.
   *
   *  Since a given ``x`` value for ``r`` has two possible values for
   *  its correspondin ``y``, the ``v`` indicates which of the two ``y``
   *  values to use.
   *
   *  It is normalized to the values ``27`` or ``28`` for legacy
   *  purposes.
   */
  get v() {
    return __privateGet(this, _v);
  }
  set v(value) {
    const v2 = getNumber(value, "value");
    assertArgument(v2 === 27 || v2 === 28, "invalid v", "v", value);
    __privateSet(this, _v, v2);
  }
  /**
   *  The EIP-155 ``v`` for legacy transactions. For non-legacy
   *  transactions, this value is ``null``.
   */
  get networkV() {
    return __privateGet(this, _networkV);
  }
  /**
   *  The chain ID for EIP-155 legacy transactions. For non-legacy
   *  transactions, this value is ``null``.
   */
  get legacyChainId() {
    const v2 = this.networkV;
    if (v2 == null) {
      return null;
    }
    return _Signature.getChainId(v2);
  }
  /**
   *  The ``yParity`` for the signature.
   *
   *  See ``v`` for more details on how this value is used.
   */
  get yParity() {
    return this.v === 27 ? 0 : 1;
  }
  /**
   *  The [[link-eip-2098]] compact representation of the ``yParity``
   *  and ``s`` compacted into a single ``bytes32``.
   */
  get yParityAndS() {
    const yParityAndS = getBytes(this.s);
    if (this.yParity) {
      yParityAndS[0] |= 128;
    }
    return hexlify(yParityAndS);
  }
  /**
   *  The [[link-eip-2098]] compact representation.
   */
  get compactSerialized() {
    return concat([this.r, this.yParityAndS]);
  }
  /**
   *  The serialized representation.
   */
  get serialized() {
    return concat([this.r, this.s, this.yParity ? "0x1c" : "0x1b"]);
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `Signature { r: "${this.r}", s: "${this.s}", yParity: ${this.yParity}, networkV: ${this.networkV} }`;
  }
  /**
   *  Returns a new identical [[Signature]].
   */
  clone() {
    const clone = new _Signature(_guard$1, this.r, this.s, this.v);
    if (this.networkV) {
      __privateSet(clone, _networkV, this.networkV);
    }
    return clone;
  }
  /**
   *  Returns a representation that is compatible with ``JSON.stringify``.
   */
  toJSON() {
    const networkV = this.networkV;
    return {
      _type: "signature",
      networkV: networkV != null ? networkV.toString() : null,
      r: this.r,
      s: this.s,
      v: this.v
    };
  }
  /**
   *  Compute the chain ID from the ``v`` in a legacy EIP-155 transactions.
   *
   *  @example:
   *    Signature.getChainId(45)
   *    //_result:
   *
   *    Signature.getChainId(46)
   *    //_result:
   */
  static getChainId(v2) {
    const bv = getBigInt(v2, "v");
    if (bv == BN_27$1 || bv == BN_28$1) {
      return BN_0$7;
    }
    assertArgument(bv >= BN_35$1, "invalid EIP-155 v", "v", v2);
    return (bv - BN_35$1) / BN_2$2;
  }
  /**
   *  Compute the ``v`` for a chain ID for a legacy EIP-155 transactions.
   *
   *  Legacy transactions which use [[link-eip-155]] hijack the ``v``
   *  property to include the chain ID.
   *
   *  @example:
   *    Signature.getChainIdV(5, 27)
   *    //_result:
   *
   *    Signature.getChainIdV(5, 28)
   *    //_result:
   *
   */
  static getChainIdV(chainId, v2) {
    return getBigInt(chainId) * BN_2$2 + BigInt(35 + v2 - 27);
  }
  /**
   *  Compute the normalized legacy transaction ``v`` from a ``yParirty``,
   *  a legacy transaction ``v`` or a legacy [[link-eip-155]] transaction.
   *
   *  @example:
   *    // The values 0 and 1 imply v is actually yParity
   *    Signature.getNormalizedV(0)
   *    //_result:
   *
   *    // Legacy non-EIP-1559 transaction (i.e. 27 or 28)
   *    Signature.getNormalizedV(27)
   *    //_result:
   *
   *    // Legacy EIP-155 transaction (i.e. >= 35)
   *    Signature.getNormalizedV(46)
   *    //_result:
   *
   *    // Invalid values throw
   *    Signature.getNormalizedV(5)
   *    //_error:
   */
  static getNormalizedV(v2) {
    const bv = getBigInt(v2);
    if (bv === BN_0$7 || bv === BN_27$1) {
      return 27;
    }
    if (bv === BN_1$2 || bv === BN_28$1) {
      return 28;
    }
    assertArgument(bv >= BN_35$1, "invalid v", "v", v2);
    return bv & BN_1$2 ? 27 : 28;
  }
  /**
   *  Creates a new [[Signature]].
   *
   *  If no %%sig%% is provided, a new [[Signature]] is created
   *  with default values.
   *
   *  If %%sig%% is a string, it is parsed.
   */
  static from(sig) {
    function assertError(check, message) {
      assertArgument(check, message, "signature", sig);
    }
    if (sig == null) {
      return new _Signature(_guard$1, ZeroHash, ZeroHash, 27);
    }
    if (typeof sig === "string") {
      const bytes = getBytes(sig, "signature");
      if (bytes.length === 64) {
        const r4 = hexlify(bytes.slice(0, 32));
        const s2 = bytes.slice(32, 64);
        const v3 = s2[0] & 128 ? 28 : 27;
        s2[0] &= 127;
        return new _Signature(_guard$1, r4, hexlify(s2), v3);
      }
      if (bytes.length === 65) {
        const r4 = hexlify(bytes.slice(0, 32));
        const s2 = bytes.slice(32, 64);
        assertError((s2[0] & 128) === 0, "non-canonical s");
        const v3 = _Signature.getNormalizedV(bytes[64]);
        return new _Signature(_guard$1, r4, hexlify(s2), v3);
      }
      assertError(false, "invalid raw signature length");
    }
    if (sig instanceof _Signature) {
      return sig.clone();
    }
    const _r3 = sig.r;
    assertError(_r3 != null, "missing r");
    const r3 = toUint256(_r3);
    const s = function(s2, yParityAndS) {
      if (s2 != null) {
        return toUint256(s2);
      }
      if (yParityAndS != null) {
        assertError(isHexString(yParityAndS, 32), "invalid yParityAndS");
        const bytes = getBytes(yParityAndS);
        bytes[0] &= 127;
        return hexlify(bytes);
      }
      assertError(false, "missing s");
    }(sig.s, sig.yParityAndS);
    assertError((getBytes(s)[0] & 128) == 0, "non-canonical s");
    const { networkV, v: v2 } = function(_v2, yParityAndS, yParity) {
      if (_v2 != null) {
        const v3 = getBigInt(_v2);
        return {
          networkV: v3 >= BN_35$1 ? v3 : void 0,
          v: _Signature.getNormalizedV(v3)
        };
      }
      if (yParityAndS != null) {
        assertError(isHexString(yParityAndS, 32), "invalid yParityAndS");
        return { v: getBytes(yParityAndS)[0] & 128 ? 28 : 27 };
      }
      if (yParity != null) {
        switch (getNumber(yParity, "sig.yParity")) {
          case 0:
            return { v: 27 };
          case 1:
            return { v: 28 };
        }
        assertError(false, "invalid yParity");
      }
      assertError(false, "missing v");
    }(sig.v, sig.yParityAndS, sig.yParity);
    const result = new _Signature(_guard$1, r3, s, v2);
    if (networkV) {
      __privateSet(result, _networkV, networkV);
    }
    assertError(sig.yParity == null || getNumber(sig.yParity, "sig.yParity") === result.yParity, "yParity mismatch");
    assertError(sig.yParityAndS == null || sig.yParityAndS === result.yParityAndS, "yParityAndS mismatch");
    return result;
  }
};
_r2 = new WeakMap();
_s = new WeakMap();
_v = new WeakMap();
_networkV = new WeakMap();
let Signature = _Signature;
const _SigningKey = class _SigningKey {
  /**
   *  Creates a new **SigningKey** for %%privateKey%%.
   */
  constructor(privateKey) {
    __privateAdd(this, _privateKey);
    assertArgument(dataLength(privateKey) === 32, "invalid private key", "privateKey", "[REDACTED]");
    __privateSet(this, _privateKey, hexlify(privateKey));
  }
  /**
   *  The private key.
   */
  get privateKey() {
    return __privateGet(this, _privateKey);
  }
  /**
   *  The uncompressed public key.
   *
   * This will always begin with the prefix ``0x04`` and be 132
   * characters long (the ``0x`` prefix and 130 hexadecimal nibbles).
   */
  get publicKey() {
    return _SigningKey.computePublicKey(__privateGet(this, _privateKey));
  }
  /**
   *  The compressed public key.
   *
   *  This will always begin with either the prefix ``0x02`` or ``0x03``
   *  and be 68 characters long (the ``0x`` prefix and 33 hexadecimal
   *  nibbles)
   */
  get compressedPublicKey() {
    return _SigningKey.computePublicKey(__privateGet(this, _privateKey), true);
  }
  /**
   *  Return the signature of the signed %%digest%%.
   */
  sign(digest) {
    assertArgument(dataLength(digest) === 32, "invalid digest length", "digest", digest);
    const sig = secp256k1.sign(getBytesCopy(digest), getBytesCopy(__privateGet(this, _privateKey)), {
      lowS: true
    });
    return Signature.from({
      r: toBeHex(sig.r, 32),
      s: toBeHex(sig.s, 32),
      v: sig.recovery ? 28 : 27
    });
  }
  /**
   *  Returns the [[link-wiki-ecdh]] shared secret between this
   *  private key and the %%other%% key.
   *
   *  The %%other%% key may be any type of key, a raw public key,
   *  a compressed/uncompressed pubic key or aprivate key.
   *
   *  Best practice is usually to use a cryptographic hash on the
   *  returned value before using it as a symetric secret.
   *
   *  @example:
   *    sign1 = new SigningKey(id("some-secret-1"))
   *    sign2 = new SigningKey(id("some-secret-2"))
   *
   *    // Notice that privA.computeSharedSecret(pubB)...
   *    sign1.computeSharedSecret(sign2.publicKey)
   *    //_result:
   *
   *    // ...is equal to privB.computeSharedSecret(pubA).
   *    sign2.computeSharedSecret(sign1.publicKey)
   *    //_result:
   */
  computeSharedSecret(other) {
    const pubKey = _SigningKey.computePublicKey(other);
    return hexlify(secp256k1.getSharedSecret(getBytesCopy(__privateGet(this, _privateKey)), getBytes(pubKey), false));
  }
  /**
   *  Compute the public key for %%key%%, optionally %%compressed%%.
   *
   *  The %%key%% may be any type of key, a raw public key, a
   *  compressed/uncompressed public key or private key.
   *
   *  @example:
   *    sign = new SigningKey(id("some-secret"));
   *
   *    // Compute the uncompressed public key for a private key
   *    SigningKey.computePublicKey(sign.privateKey)
   *    //_result:
   *
   *    // Compute the compressed public key for a private key
   *    SigningKey.computePublicKey(sign.privateKey, true)
   *    //_result:
   *
   *    // Compute the uncompressed public key
   *    SigningKey.computePublicKey(sign.publicKey, false);
   *    //_result:
   *
   *    // Compute the Compressed a public key
   *    SigningKey.computePublicKey(sign.publicKey, true);
   *    //_result:
   */
  static computePublicKey(key, compressed) {
    let bytes = getBytes(key, "key");
    if (bytes.length === 32) {
      const pubKey = secp256k1.getPublicKey(bytes, !!compressed);
      return hexlify(pubKey);
    }
    if (bytes.length === 64) {
      const pub = new Uint8Array(65);
      pub[0] = 4;
      pub.set(bytes, 1);
      bytes = pub;
    }
    const point = secp256k1.ProjectivePoint.fromHex(bytes);
    return hexlify(point.toRawBytes(compressed));
  }
  /**
   *  Returns the public key for the private key which produced the
   *  %%signature%% for the given %%digest%%.
   *
   *  @example:
   *    key = new SigningKey(id("some-secret"))
   *    digest = id("hello world")
   *    sig = key.sign(digest)
   *
   *    // Notice the signer public key...
   *    key.publicKey
   *    //_result:
   *
   *    // ...is equal to the recovered public key
   *    SigningKey.recoverPublicKey(digest, sig)
   *    //_result:
   *
   */
  static recoverPublicKey(digest, signature) {
    assertArgument(dataLength(digest) === 32, "invalid digest length", "digest", digest);
    const sig = Signature.from(signature);
    let secpSig = secp256k1.Signature.fromCompact(getBytesCopy(concat([sig.r, sig.s])));
    secpSig = secpSig.addRecoveryBit(sig.yParity);
    const pubKey = secpSig.recoverPublicKey(getBytesCopy(digest));
    assertArgument(pubKey != null, "invalid signautre for digest", "signature", signature);
    return "0x" + pubKey.toHex(false);
  }
  /**
   *  Returns the point resulting from adding the ellipic curve points
   *  %%p0%% and %%p1%%.
   *
   *  This is not a common function most developers should require, but
   *  can be useful for certain privacy-specific techniques.
   *
   *  For example, it is used by [[HDNodeWallet]] to compute child
   *  addresses from parent public keys and chain codes.
   */
  static addPoints(p0, p1, compressed) {
    const pub0 = secp256k1.ProjectivePoint.fromHex(_SigningKey.computePublicKey(p0).substring(2));
    const pub1 = secp256k1.ProjectivePoint.fromHex(_SigningKey.computePublicKey(p1).substring(2));
    return "0x" + pub0.add(pub1).toHex(!!compressed);
  }
};
_privateKey = new WeakMap();
let SigningKey = _SigningKey;
const BN_0$6 = BigInt(0);
const BN_36 = BigInt(36);
function getChecksumAddress(address) {
  address = address.toLowerCase();
  const chars = address.substring(2).split("");
  const expanded = new Uint8Array(40);
  for (let i = 0; i < 40; i++) {
    expanded[i] = chars[i].charCodeAt(0);
  }
  const hashed = getBytes(keccak256(expanded));
  for (let i = 0; i < 40; i += 2) {
    if (hashed[i >> 1] >> 4 >= 8) {
      chars[i] = chars[i].toUpperCase();
    }
    if ((hashed[i >> 1] & 15) >= 8) {
      chars[i + 1] = chars[i + 1].toUpperCase();
    }
  }
  return "0x" + chars.join("");
}
const ibanLookup = {};
for (let i = 0; i < 10; i++) {
  ibanLookup[String(i)] = String(i);
}
for (let i = 0; i < 26; i++) {
  ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);
}
const safeDigits = 15;
function ibanChecksum(address) {
  address = address.toUpperCase();
  address = address.substring(4) + address.substring(0, 2) + "00";
  let expanded = address.split("").map((c2) => {
    return ibanLookup[c2];
  }).join("");
  while (expanded.length >= safeDigits) {
    let block = expanded.substring(0, safeDigits);
    expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
  }
  let checksum = String(98 - parseInt(expanded, 10) % 97);
  while (checksum.length < 2) {
    checksum = "0" + checksum;
  }
  return checksum;
}
const Base36 = function() {
  const result = {};
  for (let i = 0; i < 36; i++) {
    const key = "0123456789abcdefghijklmnopqrstuvwxyz"[i];
    result[key] = BigInt(i);
  }
  return result;
}();
function fromBase36(value) {
  value = value.toLowerCase();
  let result = BN_0$6;
  for (let i = 0; i < value.length; i++) {
    result = result * BN_36 + Base36[value[i]];
  }
  return result;
}
function getAddress(address) {
  assertArgument(typeof address === "string", "invalid address", "address", address);
  if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    if (!address.startsWith("0x")) {
      address = "0x" + address;
    }
    const result = getChecksumAddress(address);
    assertArgument(!address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || result === address, "bad address checksum", "address", address);
    return result;
  }
  if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    assertArgument(address.substring(2, 4) === ibanChecksum(address), "bad icap checksum", "address", address);
    let result = fromBase36(address.substring(4)).toString(16);
    while (result.length < 40) {
      result = "0" + result;
    }
    return getChecksumAddress("0x" + result);
  }
  assertArgument(false, "invalid address", "address", address);
}
function getCreateAddress(tx) {
  const from = getAddress(tx.from);
  const nonce = getBigInt(tx.nonce, "tx.nonce");
  let nonceHex = nonce.toString(16);
  if (nonceHex === "0") {
    nonceHex = "0x";
  } else if (nonceHex.length % 2) {
    nonceHex = "0x0" + nonceHex;
  } else {
    nonceHex = "0x" + nonceHex;
  }
  return getAddress(dataSlice(keccak256(encodeRlp([from, nonceHex])), 12));
}
function isAddressable(value) {
  return value && typeof value.getAddress === "function";
}
async function checkAddress(target, promise) {
  const result = await promise;
  if (result == null || result === "0x0000000000000000000000000000000000000000") {
    assert(typeof target !== "string", "unconfigured name", "UNCONFIGURED_NAME", { value: target });
    assertArgument(false, "invalid AddressLike value; did not resolve to a value address", "target", target);
  }
  return getAddress(result);
}
function resolveAddress(target, resolver) {
  if (typeof target === "string") {
    if (target.match(/^0x[0-9a-f]{40}$/i)) {
      return getAddress(target);
    }
    assert(resolver != null, "ENS resolution requires a provider", "UNSUPPORTED_OPERATION", { operation: "resolveName" });
    return checkAddress(target, resolver.resolveName(target));
  } else if (isAddressable(target)) {
    return checkAddress(target, target.getAddress());
  } else if (target && typeof target.then === "function") {
    return checkAddress(target, target);
  }
  assertArgument(false, "unsupported addressable value", "target", target);
}
const _gaurd = {};
function n$1(value, width) {
  let signed = false;
  if (width < 0) {
    signed = true;
    width *= -1;
  }
  return new Typed(_gaurd, `${signed ? "" : "u"}int${width}`, value, { signed, width });
}
function b$5(value, size) {
  return new Typed(_gaurd, `bytes${size ? size : ""}`, value, { size });
}
const _typedSymbol = Symbol.for("_ethers_typed");
const _Typed = class _Typed {
  /**
   *  @_ignore:
   */
  constructor(gaurd, type, value, options) {
    /**
     *  The type, as a Solidity-compatible type.
     */
    __publicField(this, "type");
    /**
     *  The actual value.
     */
    __publicField(this, "value");
    __privateAdd(this, _options);
    /**
     *  @_ignore:
     */
    __publicField(this, "_typedSymbol");
    if (options == null) {
      options = null;
    }
    assertPrivate(_gaurd, gaurd, "Typed");
    defineProperties(this, { _typedSymbol, type, value });
    __privateSet(this, _options, options);
    this.format();
  }
  /**
   *  Format the type as a Human-Readable type.
   */
  format() {
    if (this.type === "array") {
      throw new Error("");
    } else if (this.type === "dynamicArray") {
      throw new Error("");
    } else if (this.type === "tuple") {
      return `tuple(${this.value.map((v2) => v2.format()).join(",")})`;
    }
    return this.type;
  }
  /**
   *  The default value returned by this type.
   */
  defaultValue() {
    return 0;
  }
  /**
   *  The minimum value for numeric types.
   */
  minValue() {
    return 0;
  }
  /**
   *  The maximum value for numeric types.
   */
  maxValue() {
    return 0;
  }
  /**
   *  Returns ``true`` and provides a type guard is this is a [[TypedBigInt]].
   */
  isBigInt() {
    return !!this.type.match(/^u?int[0-9]+$/);
  }
  /**
   *  Returns ``true`` and provides a type guard is this is a [[TypedData]].
   */
  isData() {
    return this.type.startsWith("bytes");
  }
  /**
   *  Returns ``true`` and provides a type guard is this is a [[TypedString]].
   */
  isString() {
    return this.type === "string";
  }
  /**
   *  Returns the tuple name, if this is a tuple. Throws otherwise.
   */
  get tupleName() {
    if (this.type !== "tuple") {
      throw TypeError("not a tuple");
    }
    return __privateGet(this, _options);
  }
  // Returns the length of this type as an array
  // - `null` indicates the length is unforced, it could be dynamic
  // - `-1` indicates the length is dynamic
  // - any other value indicates it is a static array and is its length
  /**
   *  Returns the length of the array type or ``-1`` if it is dynamic.
   *
   *  Throws if the type is not an array.
   */
  get arrayLength() {
    if (this.type !== "array") {
      throw TypeError("not an array");
    }
    if (__privateGet(this, _options) === true) {
      return -1;
    }
    if (__privateGet(this, _options) === false) {
      return this.value.length;
    }
    return null;
  }
  /**
   *  Returns a new **Typed** of %%type%% with the %%value%%.
   */
  static from(type, value) {
    return new _Typed(_gaurd, type, value);
  }
  /**
   *  Return a new ``uint8`` type for %%v%%.
   */
  static uint8(v2) {
    return n$1(v2, 8);
  }
  /**
   *  Return a new ``uint16`` type for %%v%%.
   */
  static uint16(v2) {
    return n$1(v2, 16);
  }
  /**
   *  Return a new ``uint24`` type for %%v%%.
   */
  static uint24(v2) {
    return n$1(v2, 24);
  }
  /**
   *  Return a new ``uint32`` type for %%v%%.
   */
  static uint32(v2) {
    return n$1(v2, 32);
  }
  /**
   *  Return a new ``uint40`` type for %%v%%.
   */
  static uint40(v2) {
    return n$1(v2, 40);
  }
  /**
   *  Return a new ``uint48`` type for %%v%%.
   */
  static uint48(v2) {
    return n$1(v2, 48);
  }
  /**
   *  Return a new ``uint56`` type for %%v%%.
   */
  static uint56(v2) {
    return n$1(v2, 56);
  }
  /**
   *  Return a new ``uint64`` type for %%v%%.
   */
  static uint64(v2) {
    return n$1(v2, 64);
  }
  /**
   *  Return a new ``uint72`` type for %%v%%.
   */
  static uint72(v2) {
    return n$1(v2, 72);
  }
  /**
   *  Return a new ``uint80`` type for %%v%%.
   */
  static uint80(v2) {
    return n$1(v2, 80);
  }
  /**
   *  Return a new ``uint88`` type for %%v%%.
   */
  static uint88(v2) {
    return n$1(v2, 88);
  }
  /**
   *  Return a new ``uint96`` type for %%v%%.
   */
  static uint96(v2) {
    return n$1(v2, 96);
  }
  /**
   *  Return a new ``uint104`` type for %%v%%.
   */
  static uint104(v2) {
    return n$1(v2, 104);
  }
  /**
   *  Return a new ``uint112`` type for %%v%%.
   */
  static uint112(v2) {
    return n$1(v2, 112);
  }
  /**
   *  Return a new ``uint120`` type for %%v%%.
   */
  static uint120(v2) {
    return n$1(v2, 120);
  }
  /**
   *  Return a new ``uint128`` type for %%v%%.
   */
  static uint128(v2) {
    return n$1(v2, 128);
  }
  /**
   *  Return a new ``uint136`` type for %%v%%.
   */
  static uint136(v2) {
    return n$1(v2, 136);
  }
  /**
   *  Return a new ``uint144`` type for %%v%%.
   */
  static uint144(v2) {
    return n$1(v2, 144);
  }
  /**
   *  Return a new ``uint152`` type for %%v%%.
   */
  static uint152(v2) {
    return n$1(v2, 152);
  }
  /**
   *  Return a new ``uint160`` type for %%v%%.
   */
  static uint160(v2) {
    return n$1(v2, 160);
  }
  /**
   *  Return a new ``uint168`` type for %%v%%.
   */
  static uint168(v2) {
    return n$1(v2, 168);
  }
  /**
   *  Return a new ``uint176`` type for %%v%%.
   */
  static uint176(v2) {
    return n$1(v2, 176);
  }
  /**
   *  Return a new ``uint184`` type for %%v%%.
   */
  static uint184(v2) {
    return n$1(v2, 184);
  }
  /**
   *  Return a new ``uint192`` type for %%v%%.
   */
  static uint192(v2) {
    return n$1(v2, 192);
  }
  /**
   *  Return a new ``uint200`` type for %%v%%.
   */
  static uint200(v2) {
    return n$1(v2, 200);
  }
  /**
   *  Return a new ``uint208`` type for %%v%%.
   */
  static uint208(v2) {
    return n$1(v2, 208);
  }
  /**
   *  Return a new ``uint216`` type for %%v%%.
   */
  static uint216(v2) {
    return n$1(v2, 216);
  }
  /**
   *  Return a new ``uint224`` type for %%v%%.
   */
  static uint224(v2) {
    return n$1(v2, 224);
  }
  /**
   *  Return a new ``uint232`` type for %%v%%.
   */
  static uint232(v2) {
    return n$1(v2, 232);
  }
  /**
   *  Return a new ``uint240`` type for %%v%%.
   */
  static uint240(v2) {
    return n$1(v2, 240);
  }
  /**
   *  Return a new ``uint248`` type for %%v%%.
   */
  static uint248(v2) {
    return n$1(v2, 248);
  }
  /**
   *  Return a new ``uint256`` type for %%v%%.
   */
  static uint256(v2) {
    return n$1(v2, 256);
  }
  /**
   *  Return a new ``uint256`` type for %%v%%.
   */
  static uint(v2) {
    return n$1(v2, 256);
  }
  /**
   *  Return a new ``int8`` type for %%v%%.
   */
  static int8(v2) {
    return n$1(v2, -8);
  }
  /**
   *  Return a new ``int16`` type for %%v%%.
   */
  static int16(v2) {
    return n$1(v2, -16);
  }
  /**
   *  Return a new ``int24`` type for %%v%%.
   */
  static int24(v2) {
    return n$1(v2, -24);
  }
  /**
   *  Return a new ``int32`` type for %%v%%.
   */
  static int32(v2) {
    return n$1(v2, -32);
  }
  /**
   *  Return a new ``int40`` type for %%v%%.
   */
  static int40(v2) {
    return n$1(v2, -40);
  }
  /**
   *  Return a new ``int48`` type for %%v%%.
   */
  static int48(v2) {
    return n$1(v2, -48);
  }
  /**
   *  Return a new ``int56`` type for %%v%%.
   */
  static int56(v2) {
    return n$1(v2, -56);
  }
  /**
   *  Return a new ``int64`` type for %%v%%.
   */
  static int64(v2) {
    return n$1(v2, -64);
  }
  /**
   *  Return a new ``int72`` type for %%v%%.
   */
  static int72(v2) {
    return n$1(v2, -72);
  }
  /**
   *  Return a new ``int80`` type for %%v%%.
   */
  static int80(v2) {
    return n$1(v2, -80);
  }
  /**
   *  Return a new ``int88`` type for %%v%%.
   */
  static int88(v2) {
    return n$1(v2, -88);
  }
  /**
   *  Return a new ``int96`` type for %%v%%.
   */
  static int96(v2) {
    return n$1(v2, -96);
  }
  /**
   *  Return a new ``int104`` type for %%v%%.
   */
  static int104(v2) {
    return n$1(v2, -104);
  }
  /**
   *  Return a new ``int112`` type for %%v%%.
   */
  static int112(v2) {
    return n$1(v2, -112);
  }
  /**
   *  Return a new ``int120`` type for %%v%%.
   */
  static int120(v2) {
    return n$1(v2, -120);
  }
  /**
   *  Return a new ``int128`` type for %%v%%.
   */
  static int128(v2) {
    return n$1(v2, -128);
  }
  /**
   *  Return a new ``int136`` type for %%v%%.
   */
  static int136(v2) {
    return n$1(v2, -136);
  }
  /**
   *  Return a new ``int144`` type for %%v%%.
   */
  static int144(v2) {
    return n$1(v2, -144);
  }
  /**
   *  Return a new ``int52`` type for %%v%%.
   */
  static int152(v2) {
    return n$1(v2, -152);
  }
  /**
   *  Return a new ``int160`` type for %%v%%.
   */
  static int160(v2) {
    return n$1(v2, -160);
  }
  /**
   *  Return a new ``int168`` type for %%v%%.
   */
  static int168(v2) {
    return n$1(v2, -168);
  }
  /**
   *  Return a new ``int176`` type for %%v%%.
   */
  static int176(v2) {
    return n$1(v2, -176);
  }
  /**
   *  Return a new ``int184`` type for %%v%%.
   */
  static int184(v2) {
    return n$1(v2, -184);
  }
  /**
   *  Return a new ``int92`` type for %%v%%.
   */
  static int192(v2) {
    return n$1(v2, -192);
  }
  /**
   *  Return a new ``int200`` type for %%v%%.
   */
  static int200(v2) {
    return n$1(v2, -200);
  }
  /**
   *  Return a new ``int208`` type for %%v%%.
   */
  static int208(v2) {
    return n$1(v2, -208);
  }
  /**
   *  Return a new ``int216`` type for %%v%%.
   */
  static int216(v2) {
    return n$1(v2, -216);
  }
  /**
   *  Return a new ``int224`` type for %%v%%.
   */
  static int224(v2) {
    return n$1(v2, -224);
  }
  /**
   *  Return a new ``int232`` type for %%v%%.
   */
  static int232(v2) {
    return n$1(v2, -232);
  }
  /**
   *  Return a new ``int240`` type for %%v%%.
   */
  static int240(v2) {
    return n$1(v2, -240);
  }
  /**
   *  Return a new ``int248`` type for %%v%%.
   */
  static int248(v2) {
    return n$1(v2, -248);
  }
  /**
   *  Return a new ``int256`` type for %%v%%.
   */
  static int256(v2) {
    return n$1(v2, -256);
  }
  /**
   *  Return a new ``int256`` type for %%v%%.
   */
  static int(v2) {
    return n$1(v2, -256);
  }
  /**
   *  Return a new ``bytes1`` type for %%v%%.
   */
  static bytes1(v2) {
    return b$5(v2, 1);
  }
  /**
   *  Return a new ``bytes2`` type for %%v%%.
   */
  static bytes2(v2) {
    return b$5(v2, 2);
  }
  /**
   *  Return a new ``bytes3`` type for %%v%%.
   */
  static bytes3(v2) {
    return b$5(v2, 3);
  }
  /**
   *  Return a new ``bytes4`` type for %%v%%.
   */
  static bytes4(v2) {
    return b$5(v2, 4);
  }
  /**
   *  Return a new ``bytes5`` type for %%v%%.
   */
  static bytes5(v2) {
    return b$5(v2, 5);
  }
  /**
   *  Return a new ``bytes6`` type for %%v%%.
   */
  static bytes6(v2) {
    return b$5(v2, 6);
  }
  /**
   *  Return a new ``bytes7`` type for %%v%%.
   */
  static bytes7(v2) {
    return b$5(v2, 7);
  }
  /**
   *  Return a new ``bytes8`` type for %%v%%.
   */
  static bytes8(v2) {
    return b$5(v2, 8);
  }
  /**
   *  Return a new ``bytes9`` type for %%v%%.
   */
  static bytes9(v2) {
    return b$5(v2, 9);
  }
  /**
   *  Return a new ``bytes10`` type for %%v%%.
   */
  static bytes10(v2) {
    return b$5(v2, 10);
  }
  /**
   *  Return a new ``bytes11`` type for %%v%%.
   */
  static bytes11(v2) {
    return b$5(v2, 11);
  }
  /**
   *  Return a new ``bytes12`` type for %%v%%.
   */
  static bytes12(v2) {
    return b$5(v2, 12);
  }
  /**
   *  Return a new ``bytes13`` type for %%v%%.
   */
  static bytes13(v2) {
    return b$5(v2, 13);
  }
  /**
   *  Return a new ``bytes14`` type for %%v%%.
   */
  static bytes14(v2) {
    return b$5(v2, 14);
  }
  /**
   *  Return a new ``bytes15`` type for %%v%%.
   */
  static bytes15(v2) {
    return b$5(v2, 15);
  }
  /**
   *  Return a new ``bytes16`` type for %%v%%.
   */
  static bytes16(v2) {
    return b$5(v2, 16);
  }
  /**
   *  Return a new ``bytes17`` type for %%v%%.
   */
  static bytes17(v2) {
    return b$5(v2, 17);
  }
  /**
   *  Return a new ``bytes18`` type for %%v%%.
   */
  static bytes18(v2) {
    return b$5(v2, 18);
  }
  /**
   *  Return a new ``bytes19`` type for %%v%%.
   */
  static bytes19(v2) {
    return b$5(v2, 19);
  }
  /**
   *  Return a new ``bytes20`` type for %%v%%.
   */
  static bytes20(v2) {
    return b$5(v2, 20);
  }
  /**
   *  Return a new ``bytes21`` type for %%v%%.
   */
  static bytes21(v2) {
    return b$5(v2, 21);
  }
  /**
   *  Return a new ``bytes22`` type for %%v%%.
   */
  static bytes22(v2) {
    return b$5(v2, 22);
  }
  /**
   *  Return a new ``bytes23`` type for %%v%%.
   */
  static bytes23(v2) {
    return b$5(v2, 23);
  }
  /**
   *  Return a new ``bytes24`` type for %%v%%.
   */
  static bytes24(v2) {
    return b$5(v2, 24);
  }
  /**
   *  Return a new ``bytes25`` type for %%v%%.
   */
  static bytes25(v2) {
    return b$5(v2, 25);
  }
  /**
   *  Return a new ``bytes26`` type for %%v%%.
   */
  static bytes26(v2) {
    return b$5(v2, 26);
  }
  /**
   *  Return a new ``bytes27`` type for %%v%%.
   */
  static bytes27(v2) {
    return b$5(v2, 27);
  }
  /**
   *  Return a new ``bytes28`` type for %%v%%.
   */
  static bytes28(v2) {
    return b$5(v2, 28);
  }
  /**
   *  Return a new ``bytes29`` type for %%v%%.
   */
  static bytes29(v2) {
    return b$5(v2, 29);
  }
  /**
   *  Return a new ``bytes30`` type for %%v%%.
   */
  static bytes30(v2) {
    return b$5(v2, 30);
  }
  /**
   *  Return a new ``bytes31`` type for %%v%%.
   */
  static bytes31(v2) {
    return b$5(v2, 31);
  }
  /**
   *  Return a new ``bytes32`` type for %%v%%.
   */
  static bytes32(v2) {
    return b$5(v2, 32);
  }
  /**
   *  Return a new ``address`` type for %%v%%.
   */
  static address(v2) {
    return new _Typed(_gaurd, "address", v2);
  }
  /**
   *  Return a new ``bool`` type for %%v%%.
   */
  static bool(v2) {
    return new _Typed(_gaurd, "bool", !!v2);
  }
  /**
   *  Return a new ``bytes`` type for %%v%%.
   */
  static bytes(v2) {
    return new _Typed(_gaurd, "bytes", v2);
  }
  /**
   *  Return a new ``string`` type for %%v%%.
   */
  static string(v2) {
    return new _Typed(_gaurd, "string", v2);
  }
  /**
   *  Return a new ``array`` type for %%v%%, allowing %%dynamic%% length.
   */
  static array(v2, dynamic) {
    throw new Error("not implemented yet");
  }
  /**
   *  Return a new ``tuple`` type for %%v%%, with the optional %%name%%.
   */
  static tuple(v2, name) {
    throw new Error("not implemented yet");
  }
  /**
   *  Return a new ``uint8`` type for %%v%%.
   */
  static overrides(v2) {
    return new _Typed(_gaurd, "overrides", Object.assign({}, v2));
  }
  /**
   *  Returns true only if %%value%% is a [[Typed]] instance.
   */
  static isTyped(value) {
    return value && typeof value === "object" && "_typedSymbol" in value && value._typedSymbol === _typedSymbol;
  }
  /**
   *  If the value is a [[Typed]] instance, validates the underlying value
   *  and returns it, otherwise returns value directly.
   *
   *  This is useful for functions that with to accept either a [[Typed]]
   *  object or values.
   */
  static dereference(value, type) {
    if (_Typed.isTyped(value)) {
      if (value.type !== type) {
        throw new Error(`invalid type: expecetd ${type}, got ${value.type}`);
      }
      return value.value;
    }
    return value;
  }
};
_options = new WeakMap();
let Typed = _Typed;
class AddressCoder extends Coder {
  constructor(localName) {
    super("address", "address", localName, false);
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000";
  }
  encode(writer, _value2) {
    let value = Typed.dereference(_value2, "string");
    try {
      value = getAddress(value);
    } catch (error) {
      return this._throwError(error.message, _value2);
    }
    return writer.writeValue(value);
  }
  decode(reader) {
    return getAddress(toBeHex(reader.readValue(), 20));
  }
}
class AnonymousCoder extends Coder {
  constructor(coder) {
    super(coder.name, coder.type, "_", coder.dynamic);
    __publicField(this, "coder");
    this.coder = coder;
  }
  defaultValue() {
    return this.coder.defaultValue();
  }
  encode(writer, value) {
    return this.coder.encode(writer, value);
  }
  decode(reader) {
    return this.coder.decode(reader);
  }
}
function pack(writer, coders, values) {
  let arrayValues = [];
  if (Array.isArray(values)) {
    arrayValues = values;
  } else if (values && typeof values === "object") {
    let unique = {};
    arrayValues = coders.map((coder) => {
      const name = coder.localName;
      assert(name, "cannot encode object for signature with missing names", "INVALID_ARGUMENT", { argument: "values", info: { coder }, value: values });
      assert(!unique[name], "cannot encode object for signature with duplicate names", "INVALID_ARGUMENT", { argument: "values", info: { coder }, value: values });
      unique[name] = true;
      return values[name];
    });
  } else {
    assertArgument(false, "invalid tuple value", "tuple", values);
  }
  assertArgument(coders.length === arrayValues.length, "types/value length mismatch", "tuple", values);
  let staticWriter = new Writer();
  let dynamicWriter = new Writer();
  let updateFuncs = [];
  coders.forEach((coder, index) => {
    let value = arrayValues[index];
    if (coder.dynamic) {
      let dynamicOffset = dynamicWriter.length;
      coder.encode(dynamicWriter, value);
      let updateFunc = staticWriter.writeUpdatableValue();
      updateFuncs.push((baseOffset) => {
        updateFunc(baseOffset + dynamicOffset);
      });
    } else {
      coder.encode(staticWriter, value);
    }
  });
  updateFuncs.forEach((func) => {
    func(staticWriter.length);
  });
  let length = writer.appendWriter(staticWriter);
  length += writer.appendWriter(dynamicWriter);
  return length;
}
function unpack(reader, coders) {
  let values = [];
  let keys = [];
  let baseReader = reader.subReader(0);
  coders.forEach((coder) => {
    let value = null;
    if (coder.dynamic) {
      let offset = reader.readIndex();
      let offsetReader = baseReader.subReader(offset);
      try {
        value = coder.decode(offsetReader);
      } catch (error) {
        if (isError(error, "BUFFER_OVERRUN")) {
          throw error;
        }
        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    } else {
      try {
        value = coder.decode(reader);
      } catch (error) {
        if (isError(error, "BUFFER_OVERRUN")) {
          throw error;
        }
        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    }
    if (value == void 0) {
      throw new Error("investigate");
    }
    values.push(value);
    keys.push(coder.localName || null);
  });
  return Result.fromItems(values, keys);
}
class ArrayCoder extends Coder {
  constructor(coder, length, localName) {
    const type = coder.type + "[" + (length >= 0 ? length : "") + "]";
    const dynamic = length === -1 || coder.dynamic;
    super("array", type, localName, dynamic);
    __publicField(this, "coder");
    __publicField(this, "length");
    defineProperties(this, { coder, length });
  }
  defaultValue() {
    const defaultChild = this.coder.defaultValue();
    const result = [];
    for (let i = 0; i < this.length; i++) {
      result.push(defaultChild);
    }
    return result;
  }
  encode(writer, _value2) {
    const value = Typed.dereference(_value2, "array");
    if (!Array.isArray(value)) {
      this._throwError("expected array value", value);
    }
    let count = this.length;
    if (count === -1) {
      count = value.length;
      writer.writeValue(value.length);
    }
    assertArgumentCount(value.length, count, "coder array" + (this.localName ? " " + this.localName : ""));
    let coders = [];
    for (let i = 0; i < value.length; i++) {
      coders.push(this.coder);
    }
    return pack(writer, coders, value);
  }
  decode(reader) {
    let count = this.length;
    if (count === -1) {
      count = reader.readIndex();
      assert(count * WordSize <= reader.dataLength, "insufficient data length", "BUFFER_OVERRUN", { buffer: reader.bytes, offset: count * WordSize, length: reader.dataLength });
    }
    let coders = [];
    for (let i = 0; i < count; i++) {
      coders.push(new AnonymousCoder(this.coder));
    }
    return unpack(reader, coders);
  }
}
class BooleanCoder extends Coder {
  constructor(localName) {
    super("bool", "bool", localName, false);
  }
  defaultValue() {
    return false;
  }
  encode(writer, _value2) {
    const value = Typed.dereference(_value2, "bool");
    return writer.writeValue(value ? 1 : 0);
  }
  decode(reader) {
    return !!reader.readValue();
  }
}
class DynamicBytesCoder extends Coder {
  constructor(type, localName) {
    super(type, type, localName, true);
  }
  defaultValue() {
    return "0x";
  }
  encode(writer, value) {
    value = getBytesCopy(value);
    let length = writer.writeValue(value.length);
    length += writer.writeBytes(value);
    return length;
  }
  decode(reader) {
    return reader.readBytes(reader.readIndex(), true);
  }
}
class BytesCoder extends DynamicBytesCoder {
  constructor(localName) {
    super("bytes", localName);
  }
  decode(reader) {
    return hexlify(super.decode(reader));
  }
}
class FixedBytesCoder extends Coder {
  constructor(size, localName) {
    let name = "bytes" + String(size);
    super(name, name, localName, false);
    __publicField(this, "size");
    defineProperties(this, { size }, { size: "number" });
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
  }
  encode(writer, _value2) {
    let data = getBytesCopy(Typed.dereference(_value2, this.type));
    if (data.length !== this.size) {
      this._throwError("incorrect data length", _value2);
    }
    return writer.writeBytes(data);
  }
  decode(reader) {
    return hexlify(reader.readBytes(this.size));
  }
}
const Empty = new Uint8Array([]);
class NullCoder extends Coder {
  constructor(localName) {
    super("null", "", localName, false);
  }
  defaultValue() {
    return null;
  }
  encode(writer, value) {
    if (value != null) {
      this._throwError("not null", value);
    }
    return writer.writeBytes(Empty);
  }
  decode(reader) {
    reader.readBytes(0);
    return null;
  }
}
const BN_0$5 = BigInt(0);
const BN_1$1 = BigInt(1);
const BN_MAX_UINT256$1 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
class NumberCoder extends Coder {
  constructor(size, signed, localName) {
    const name = (signed ? "int" : "uint") + size * 8;
    super(name, name, localName, false);
    __publicField(this, "size");
    __publicField(this, "signed");
    defineProperties(this, { size, signed }, { size: "number", signed: "boolean" });
  }
  defaultValue() {
    return 0;
  }
  encode(writer, _value2) {
    let value = getBigInt(Typed.dereference(_value2, this.type));
    let maxUintValue = mask(BN_MAX_UINT256$1, WordSize * 8);
    if (this.signed) {
      let bounds = mask(maxUintValue, this.size * 8 - 1);
      if (value > bounds || value < -(bounds + BN_1$1)) {
        this._throwError("value out-of-bounds", _value2);
      }
      value = toTwos(value, 8 * WordSize);
    } else if (value < BN_0$5 || value > mask(maxUintValue, this.size * 8)) {
      this._throwError("value out-of-bounds", _value2);
    }
    return writer.writeValue(value);
  }
  decode(reader) {
    let value = mask(reader.readValue(), this.size * 8);
    if (this.signed) {
      value = fromTwos(value, this.size * 8);
    }
    return value;
  }
}
class StringCoder extends DynamicBytesCoder {
  constructor(localName) {
    super("string", localName);
  }
  defaultValue() {
    return "";
  }
  encode(writer, _value2) {
    return super.encode(writer, toUtf8Bytes(Typed.dereference(_value2, "string")));
  }
  decode(reader) {
    return toUtf8String(super.decode(reader));
  }
}
class TupleCoder extends Coder {
  constructor(coders, localName) {
    let dynamic = false;
    const types = [];
    coders.forEach((coder) => {
      if (coder.dynamic) {
        dynamic = true;
      }
      types.push(coder.type);
    });
    const type = "tuple(" + types.join(",") + ")";
    super("tuple", type, localName, dynamic);
    __publicField(this, "coders");
    defineProperties(this, { coders: Object.freeze(coders.slice()) });
  }
  defaultValue() {
    const values = [];
    this.coders.forEach((coder) => {
      values.push(coder.defaultValue());
    });
    const uniqueNames = this.coders.reduce((accum, coder) => {
      const name = coder.localName;
      if (name) {
        if (!accum[name]) {
          accum[name] = 0;
        }
        accum[name]++;
      }
      return accum;
    }, {});
    this.coders.forEach((coder, index) => {
      let name = coder.localName;
      if (!name || uniqueNames[name] !== 1) {
        return;
      }
      if (name === "length") {
        name = "_length";
      }
      if (values[name] != null) {
        return;
      }
      values[name] = values[index];
    });
    return Object.freeze(values);
  }
  encode(writer, _value2) {
    const value = Typed.dereference(_value2, "tuple");
    return pack(writer, this.coders, value);
  }
  decode(reader) {
    return unpack(reader, this.coders);
  }
}
function id(value) {
  return keccak256(toUtf8Bytes(value));
}
const Zeros = new Uint8Array(32);
Zeros.fill(0);
function checkComponent(comp) {
  assertArgument(comp.length !== 0, "invalid ENS name; empty component", "comp", comp);
  return comp;
}
function ensNameSplit(name) {
  const bytes = toUtf8Bytes(ensNormalize(name));
  const comps = [];
  if (name.length === 0) {
    return comps;
  }
  let last = 0;
  for (let i = 0; i < bytes.length; i++) {
    const d2 = bytes[i];
    if (d2 === 46) {
      comps.push(checkComponent(bytes.slice(last, i)));
      last = i + 1;
    }
  }
  assertArgument(last < bytes.length, "invalid ENS name; empty component", "name", name);
  comps.push(checkComponent(bytes.slice(last)));
  return comps;
}
function ensNormalize(name) {
  try {
    if (name.length === 0) {
      throw new Error("empty label");
    }
    return ens_normalize(name);
  } catch (error) {
    assertArgument(false, `invalid ENS name (${error.message})`, "name", name);
  }
}
function namehash(name) {
  assertArgument(typeof name === "string", "invalid ENS name; not a string", "name", name);
  assertArgument(name.length, `invalid ENS name (empty label)`, "name", name);
  let result = Zeros;
  const comps = ensNameSplit(name);
  while (comps.length) {
    result = keccak256(concat([result, keccak256(comps.pop())]));
  }
  return hexlify(result);
}
function dnsEncode(name, _maxLength) {
  const length = _maxLength;
  assertArgument(length <= 255, "DNS encoded label cannot exceed 255", "length", length);
  return hexlify(concat(ensNameSplit(name).map((comp) => {
    assertArgument(comp.length <= length, `label ${JSON.stringify(name)} exceeds ${length} bytes`, "name", name);
    const bytes = new Uint8Array(comp.length + 1);
    bytes.set(comp, 1);
    bytes[0] = bytes.length - 1;
    return bytes;
  }))) + "00";
}
function accessSetify(addr, storageKeys) {
  return {
    address: getAddress(addr),
    storageKeys: storageKeys.map((storageKey, index) => {
      assertArgument(isHexString(storageKey, 32), "invalid slot", `storageKeys[${index}]`, storageKey);
      return storageKey.toLowerCase();
    })
  };
}
function accessListify(value) {
  if (Array.isArray(value)) {
    return value.map((set2, index) => {
      if (Array.isArray(set2)) {
        assertArgument(set2.length === 2, "invalid slot set", `value[${index}]`, set2);
        return accessSetify(set2[0], set2[1]);
      }
      assertArgument(set2 != null && typeof set2 === "object", "invalid address-slot set", "value", value);
      return accessSetify(set2.address, set2.storageKeys);
    });
  }
  assertArgument(value != null && typeof value === "object", "invalid access list", "value", value);
  const result = Object.keys(value).map((addr) => {
    const storageKeys = value[addr].reduce((accum, storageKey) => {
      accum[storageKey] = true;
      return accum;
    }, {});
    return accessSetify(addr, Object.keys(storageKeys).sort());
  });
  result.sort((a2, b2) => a2.address.localeCompare(b2.address));
  return result;
}
function computeAddress(key) {
  let pubkey;
  if (typeof key === "string") {
    pubkey = SigningKey.computePublicKey(key, false);
  } else {
    pubkey = key.publicKey;
  }
  return getAddress(keccak256("0x" + pubkey.substring(4)).substring(26));
}
function recoverAddress(digest, signature) {
  return computeAddress(SigningKey.recoverPublicKey(digest, signature));
}
const BN_0$4 = BigInt(0);
const BN_2$1 = BigInt(2);
const BN_27 = BigInt(27);
const BN_28 = BigInt(28);
const BN_35 = BigInt(35);
const BN_MAX_UINT = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
const BLOB_SIZE = 4096 * 32;
function getVersionedHash(version2, hash) {
  let versioned = version2.toString(16);
  while (versioned.length < 2) {
    versioned = "0" + versioned;
  }
  versioned += sha256(hash).substring(4);
  return "0x" + versioned;
}
function handleAddress(value) {
  if (value === "0x") {
    return null;
  }
  return getAddress(value);
}
function handleAccessList(value, param) {
  try {
    return accessListify(value);
  } catch (error) {
    assertArgument(false, error.message, param, value);
  }
}
function handleNumber(_value2, param) {
  if (_value2 === "0x") {
    return 0;
  }
  return getNumber(_value2, param);
}
function handleUint(_value2, param) {
  if (_value2 === "0x") {
    return BN_0$4;
  }
  const value = getBigInt(_value2, param);
  assertArgument(value <= BN_MAX_UINT, "value exceeds uint size", param, value);
  return value;
}
function formatNumber$1(_value2, name) {
  const value = getBigInt(_value2, "value");
  const result = toBeArray(value);
  assertArgument(result.length <= 32, `value too large`, `tx.${name}`, value);
  return result;
}
function formatAccessList(value) {
  return accessListify(value).map((set2) => [set2.address, set2.storageKeys]);
}
function formatHashes(value, param) {
  assertArgument(Array.isArray(value), `invalid ${param}`, "value", value);
  for (let i = 0; i < value.length; i++) {
    assertArgument(isHexString(value[i], 32), "invalid ${ param } hash", `value[${i}]`, value[i]);
  }
  return value;
}
function _parseLegacy(data) {
  const fields = decodeRlp(data);
  assertArgument(Array.isArray(fields) && (fields.length === 9 || fields.length === 6), "invalid field count for legacy transaction", "data", data);
  const tx = {
    type: 0,
    nonce: handleNumber(fields[0], "nonce"),
    gasPrice: handleUint(fields[1], "gasPrice"),
    gasLimit: handleUint(fields[2], "gasLimit"),
    to: handleAddress(fields[3]),
    value: handleUint(fields[4], "value"),
    data: hexlify(fields[5]),
    chainId: BN_0$4
  };
  if (fields.length === 6) {
    return tx;
  }
  const v2 = handleUint(fields[6], "v");
  const r3 = handleUint(fields[7], "r");
  const s = handleUint(fields[8], "s");
  if (r3 === BN_0$4 && s === BN_0$4) {
    tx.chainId = v2;
  } else {
    let chainId = (v2 - BN_35) / BN_2$1;
    if (chainId < BN_0$4) {
      chainId = BN_0$4;
    }
    tx.chainId = chainId;
    assertArgument(chainId !== BN_0$4 || (v2 === BN_27 || v2 === BN_28), "non-canonical legacy v", "v", fields[6]);
    tx.signature = Signature.from({
      r: zeroPadValue(fields[7], 32),
      s: zeroPadValue(fields[8], 32),
      v: v2
    });
  }
  return tx;
}
function _serializeLegacy(tx, sig) {
  const fields = [
    formatNumber$1(tx.nonce, "nonce"),
    formatNumber$1(tx.gasPrice || 0, "gasPrice"),
    formatNumber$1(tx.gasLimit, "gasLimit"),
    tx.to || "0x",
    formatNumber$1(tx.value, "value"),
    tx.data
  ];
  let chainId = BN_0$4;
  if (tx.chainId != BN_0$4) {
    chainId = getBigInt(tx.chainId, "tx.chainId");
    assertArgument(!sig || sig.networkV == null || sig.legacyChainId === chainId, "tx.chainId/sig.v mismatch", "sig", sig);
  } else if (tx.signature) {
    const legacy = tx.signature.legacyChainId;
    if (legacy != null) {
      chainId = legacy;
    }
  }
  if (!sig) {
    if (chainId !== BN_0$4) {
      fields.push(toBeArray(chainId));
      fields.push("0x");
      fields.push("0x");
    }
    return encodeRlp(fields);
  }
  let v2 = BigInt(27 + sig.yParity);
  if (chainId !== BN_0$4) {
    v2 = Signature.getChainIdV(chainId, sig.v);
  } else if (BigInt(sig.v) !== v2) {
    assertArgument(false, "tx.chainId/sig.v mismatch", "sig", sig);
  }
  fields.push(toBeArray(v2));
  fields.push(toBeArray(sig.r));
  fields.push(toBeArray(sig.s));
  return encodeRlp(fields);
}
function _parseEipSignature(tx, fields) {
  let yParity;
  try {
    yParity = handleNumber(fields[0], "yParity");
    if (yParity !== 0 && yParity !== 1) {
      throw new Error("bad yParity");
    }
  } catch (error) {
    assertArgument(false, "invalid yParity", "yParity", fields[0]);
  }
  const r3 = zeroPadValue(fields[1], 32);
  const s = zeroPadValue(fields[2], 32);
  const signature = Signature.from({ r: r3, s, yParity });
  tx.signature = signature;
}
function _parseEip1559(data) {
  const fields = decodeRlp(getBytes(data).slice(1));
  assertArgument(Array.isArray(fields) && (fields.length === 9 || fields.length === 12), "invalid field count for transaction type: 2", "data", hexlify(data));
  const tx = {
    type: 2,
    chainId: handleUint(fields[0], "chainId"),
    nonce: handleNumber(fields[1], "nonce"),
    maxPriorityFeePerGas: handleUint(fields[2], "maxPriorityFeePerGas"),
    maxFeePerGas: handleUint(fields[3], "maxFeePerGas"),
    gasPrice: null,
    gasLimit: handleUint(fields[4], "gasLimit"),
    to: handleAddress(fields[5]),
    value: handleUint(fields[6], "value"),
    data: hexlify(fields[7]),
    accessList: handleAccessList(fields[8], "accessList")
  };
  if (fields.length === 9) {
    return tx;
  }
  _parseEipSignature(tx, fields.slice(9));
  return tx;
}
function _serializeEip1559(tx, sig) {
  const fields = [
    formatNumber$1(tx.chainId, "chainId"),
    formatNumber$1(tx.nonce, "nonce"),
    formatNumber$1(tx.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    formatNumber$1(tx.maxFeePerGas || 0, "maxFeePerGas"),
    formatNumber$1(tx.gasLimit, "gasLimit"),
    tx.to || "0x",
    formatNumber$1(tx.value, "value"),
    tx.data,
    formatAccessList(tx.accessList || [])
  ];
  if (sig) {
    fields.push(formatNumber$1(sig.yParity, "yParity"));
    fields.push(toBeArray(sig.r));
    fields.push(toBeArray(sig.s));
  }
  return concat(["0x02", encodeRlp(fields)]);
}
function _parseEip2930(data) {
  const fields = decodeRlp(getBytes(data).slice(1));
  assertArgument(Array.isArray(fields) && (fields.length === 8 || fields.length === 11), "invalid field count for transaction type: 1", "data", hexlify(data));
  const tx = {
    type: 1,
    chainId: handleUint(fields[0], "chainId"),
    nonce: handleNumber(fields[1], "nonce"),
    gasPrice: handleUint(fields[2], "gasPrice"),
    gasLimit: handleUint(fields[3], "gasLimit"),
    to: handleAddress(fields[4]),
    value: handleUint(fields[5], "value"),
    data: hexlify(fields[6]),
    accessList: handleAccessList(fields[7], "accessList")
  };
  if (fields.length === 8) {
    return tx;
  }
  _parseEipSignature(tx, fields.slice(8));
  return tx;
}
function _serializeEip2930(tx, sig) {
  const fields = [
    formatNumber$1(tx.chainId, "chainId"),
    formatNumber$1(tx.nonce, "nonce"),
    formatNumber$1(tx.gasPrice || 0, "gasPrice"),
    formatNumber$1(tx.gasLimit, "gasLimit"),
    tx.to || "0x",
    formatNumber$1(tx.value, "value"),
    tx.data,
    formatAccessList(tx.accessList || [])
  ];
  if (sig) {
    fields.push(formatNumber$1(sig.yParity, "recoveryParam"));
    fields.push(toBeArray(sig.r));
    fields.push(toBeArray(sig.s));
  }
  return concat(["0x01", encodeRlp(fields)]);
}
function _parseEip4844(data) {
  let fields = decodeRlp(getBytes(data).slice(1));
  let typeName = "3";
  let blobs = null;
  if (fields.length === 4 && Array.isArray(fields[0])) {
    typeName = "3 (network format)";
    const fBlobs = fields[1], fCommits = fields[2], fProofs = fields[3];
    assertArgument(Array.isArray(fBlobs), "invalid network format: blobs not an array", "fields[1]", fBlobs);
    assertArgument(Array.isArray(fCommits), "invalid network format: commitments not an array", "fields[2]", fCommits);
    assertArgument(Array.isArray(fProofs), "invalid network format: proofs not an array", "fields[3]", fProofs);
    assertArgument(fBlobs.length === fCommits.length, "invalid network format: blobs/commitments length mismatch", "fields", fields);
    assertArgument(fBlobs.length === fProofs.length, "invalid network format: blobs/proofs length mismatch", "fields", fields);
    blobs = [];
    for (let i = 0; i < fields[1].length; i++) {
      blobs.push({
        data: fBlobs[i],
        commitment: fCommits[i],
        proof: fProofs[i]
      });
    }
    fields = fields[0];
  }
  assertArgument(Array.isArray(fields) && (fields.length === 11 || fields.length === 14), `invalid field count for transaction type: ${typeName}`, "data", hexlify(data));
  const tx = {
    type: 3,
    chainId: handleUint(fields[0], "chainId"),
    nonce: handleNumber(fields[1], "nonce"),
    maxPriorityFeePerGas: handleUint(fields[2], "maxPriorityFeePerGas"),
    maxFeePerGas: handleUint(fields[3], "maxFeePerGas"),
    gasPrice: null,
    gasLimit: handleUint(fields[4], "gasLimit"),
    to: handleAddress(fields[5]),
    value: handleUint(fields[6], "value"),
    data: hexlify(fields[7]),
    accessList: handleAccessList(fields[8], "accessList"),
    maxFeePerBlobGas: handleUint(fields[9], "maxFeePerBlobGas"),
    blobVersionedHashes: fields[10]
  };
  if (blobs) {
    tx.blobs = blobs;
  }
  assertArgument(tx.to != null, `invalid address for transaction type: ${typeName}`, "data", data);
  assertArgument(Array.isArray(tx.blobVersionedHashes), "invalid blobVersionedHashes: must be an array", "data", data);
  for (let i = 0; i < tx.blobVersionedHashes.length; i++) {
    assertArgument(isHexString(tx.blobVersionedHashes[i], 32), `invalid blobVersionedHash at index ${i}: must be length 32`, "data", data);
  }
  if (fields.length === 11) {
    return tx;
  }
  _parseEipSignature(tx, fields.slice(11));
  return tx;
}
function _serializeEip4844(tx, sig, blobs) {
  const fields = [
    formatNumber$1(tx.chainId, "chainId"),
    formatNumber$1(tx.nonce, "nonce"),
    formatNumber$1(tx.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    formatNumber$1(tx.maxFeePerGas || 0, "maxFeePerGas"),
    formatNumber$1(tx.gasLimit, "gasLimit"),
    tx.to || ZeroAddress,
    formatNumber$1(tx.value, "value"),
    tx.data,
    formatAccessList(tx.accessList || []),
    formatNumber$1(tx.maxFeePerBlobGas || 0, "maxFeePerBlobGas"),
    formatHashes(tx.blobVersionedHashes || [], "blobVersionedHashes")
  ];
  if (sig) {
    fields.push(formatNumber$1(sig.yParity, "yParity"));
    fields.push(toBeArray(sig.r));
    fields.push(toBeArray(sig.s));
    if (blobs) {
      return concat([
        "0x03",
        encodeRlp([
          fields,
          blobs.map((b2) => b2.data),
          blobs.map((b2) => b2.commitment),
          blobs.map((b2) => b2.proof)
        ])
      ]);
    }
  }
  return concat(["0x03", encodeRlp(fields)]);
}
const _Transaction = class _Transaction {
  /**
   *  Creates a new Transaction with default values.
   */
  constructor() {
    __privateAdd(this, _Transaction_instances);
    __privateAdd(this, _type);
    __privateAdd(this, _to);
    __privateAdd(this, _data3);
    __privateAdd(this, _nonce);
    __privateAdd(this, _gasLimit);
    __privateAdd(this, _gasPrice);
    __privateAdd(this, _maxPriorityFeePerGas);
    __privateAdd(this, _maxFeePerGas);
    __privateAdd(this, _value);
    __privateAdd(this, _chainId);
    __privateAdd(this, _sig);
    __privateAdd(this, _accessList);
    __privateAdd(this, _maxFeePerBlobGas);
    __privateAdd(this, _blobVersionedHashes);
    __privateAdd(this, _kzg);
    __privateAdd(this, _blobs);
    __privateSet(this, _type, null);
    __privateSet(this, _to, null);
    __privateSet(this, _nonce, 0);
    __privateSet(this, _gasLimit, BN_0$4);
    __privateSet(this, _gasPrice, null);
    __privateSet(this, _maxPriorityFeePerGas, null);
    __privateSet(this, _maxFeePerGas, null);
    __privateSet(this, _data3, "0x");
    __privateSet(this, _value, BN_0$4);
    __privateSet(this, _chainId, BN_0$4);
    __privateSet(this, _sig, null);
    __privateSet(this, _accessList, null);
    __privateSet(this, _maxFeePerBlobGas, null);
    __privateSet(this, _blobVersionedHashes, null);
    __privateSet(this, _blobs, null);
    __privateSet(this, _kzg, null);
  }
  /**
   *  The transaction type.
   *
   *  If null, the type will be automatically inferred based on
   *  explicit properties.
   */
  get type() {
    return __privateGet(this, _type);
  }
  set type(value) {
    switch (value) {
      case null:
        __privateSet(this, _type, null);
        break;
      case 0:
      case "legacy":
        __privateSet(this, _type, 0);
        break;
      case 1:
      case "berlin":
      case "eip-2930":
        __privateSet(this, _type, 1);
        break;
      case 2:
      case "london":
      case "eip-1559":
        __privateSet(this, _type, 2);
        break;
      case 3:
      case "cancun":
      case "eip-4844":
        __privateSet(this, _type, 3);
        break;
      default:
        assertArgument(false, "unsupported transaction type", "type", value);
    }
  }
  /**
   *  The name of the transaction type.
   */
  get typeName() {
    switch (this.type) {
      case 0:
        return "legacy";
      case 1:
        return "eip-2930";
      case 2:
        return "eip-1559";
      case 3:
        return "eip-4844";
    }
    return null;
  }
  /**
   *  The ``to`` address for the transaction or ``null`` if the
   *  transaction is an ``init`` transaction.
   */
  get to() {
    const value = __privateGet(this, _to);
    if (value == null && this.type === 3) {
      return ZeroAddress;
    }
    return value;
  }
  set to(value) {
    __privateSet(this, _to, value == null ? null : getAddress(value));
  }
  /**
   *  The transaction nonce.
   */
  get nonce() {
    return __privateGet(this, _nonce);
  }
  set nonce(value) {
    __privateSet(this, _nonce, getNumber(value, "value"));
  }
  /**
   *  The gas limit.
   */
  get gasLimit() {
    return __privateGet(this, _gasLimit);
  }
  set gasLimit(value) {
    __privateSet(this, _gasLimit, getBigInt(value));
  }
  /**
   *  The gas price.
   *
   *  On legacy networks this defines the fee that will be paid. On
   *  EIP-1559 networks, this should be ``null``.
   */
  get gasPrice() {
    const value = __privateGet(this, _gasPrice);
    if (value == null && (this.type === 0 || this.type === 1)) {
      return BN_0$4;
    }
    return value;
  }
  set gasPrice(value) {
    __privateSet(this, _gasPrice, value == null ? null : getBigInt(value, "gasPrice"));
  }
  /**
   *  The maximum priority fee per unit of gas to pay. On legacy
   *  networks this should be ``null``.
   */
  get maxPriorityFeePerGas() {
    const value = __privateGet(this, _maxPriorityFeePerGas);
    if (value == null) {
      if (this.type === 2 || this.type === 3) {
        return BN_0$4;
      }
      return null;
    }
    return value;
  }
  set maxPriorityFeePerGas(value) {
    __privateSet(this, _maxPriorityFeePerGas, value == null ? null : getBigInt(value, "maxPriorityFeePerGas"));
  }
  /**
   *  The maximum total fee per unit of gas to pay. On legacy
   *  networks this should be ``null``.
   */
  get maxFeePerGas() {
    const value = __privateGet(this, _maxFeePerGas);
    if (value == null) {
      if (this.type === 2 || this.type === 3) {
        return BN_0$4;
      }
      return null;
    }
    return value;
  }
  set maxFeePerGas(value) {
    __privateSet(this, _maxFeePerGas, value == null ? null : getBigInt(value, "maxFeePerGas"));
  }
  /**
   *  The transaction data. For ``init`` transactions this is the
   *  deployment code.
   */
  get data() {
    return __privateGet(this, _data3);
  }
  set data(value) {
    __privateSet(this, _data3, hexlify(value));
  }
  /**
   *  The amount of ether (in wei) to send in this transactions.
   */
  get value() {
    return __privateGet(this, _value);
  }
  set value(value) {
    __privateSet(this, _value, getBigInt(value, "value"));
  }
  /**
   *  The chain ID this transaction is valid on.
   */
  get chainId() {
    return __privateGet(this, _chainId);
  }
  set chainId(value) {
    __privateSet(this, _chainId, getBigInt(value));
  }
  /**
   *  If signed, the signature for this transaction.
   */
  get signature() {
    return __privateGet(this, _sig) || null;
  }
  set signature(value) {
    __privateSet(this, _sig, value == null ? null : Signature.from(value));
  }
  /**
   *  The access list.
   *
   *  An access list permits discounted (but pre-paid) access to
   *  bytecode and state variable access within contract execution.
   */
  get accessList() {
    const value = __privateGet(this, _accessList) || null;
    if (value == null) {
      if (this.type === 1 || this.type === 2 || this.type === 3) {
        return [];
      }
      return null;
    }
    return value;
  }
  set accessList(value) {
    __privateSet(this, _accessList, value == null ? null : accessListify(value));
  }
  /**
   *  The max fee per blob gas for Cancun transactions.
   */
  get maxFeePerBlobGas() {
    const value = __privateGet(this, _maxFeePerBlobGas);
    if (value == null && this.type === 3) {
      return BN_0$4;
    }
    return value;
  }
  set maxFeePerBlobGas(value) {
    __privateSet(this, _maxFeePerBlobGas, value == null ? null : getBigInt(value, "maxFeePerBlobGas"));
  }
  /**
   *  The BLOb versioned hashes for Cancun transactions.
   */
  get blobVersionedHashes() {
    let value = __privateGet(this, _blobVersionedHashes);
    if (value == null && this.type === 3) {
      return [];
    }
    return value;
  }
  set blobVersionedHashes(value) {
    if (value != null) {
      assertArgument(Array.isArray(value), "blobVersionedHashes must be an Array", "value", value);
      value = value.slice();
      for (let i = 0; i < value.length; i++) {
        assertArgument(isHexString(value[i], 32), "invalid blobVersionedHash", `value[${i}]`, value[i]);
      }
    }
    __privateSet(this, _blobVersionedHashes, value);
  }
  /**
   *  The BLObs for the Transaction, if any.
   *
   *  If ``blobs`` is non-``null``, then the [[seriailized]]
   *  will return the network formatted sidecar, otherwise it
   *  will return the standard [[link-eip-2718]] payload. The
   *  [[unsignedSerialized]] is unaffected regardless.
   *
   *  When setting ``blobs``, either fully valid [[Blob]] objects
   *  may be specified (i.e. correctly padded, with correct
   *  committments and proofs) or a raw [[BytesLike]] may
   *  be provided.
   *
   *  If raw [[BytesLike]] are provided, the [[kzg]] property **must**
   *  be already set. The blob will be correctly padded and the
   *  [[KzgLibrary]] will be used to compute the committment and
   *  proof for the blob.
   *
   *  A BLOb is a sequence of field elements, each of which must
   *  be within the BLS field modulo, so some additional processing
   *  may be required to encode arbitrary data to ensure each 32 byte
   *  field is within the valid range.
   *
   *  Setting this automatically populates [[blobVersionedHashes]],
   *  overwriting any existing values. Setting this to ``null``
   *  does **not** remove the [[blobVersionedHashes]], leaving them
   *  present.
   */
  get blobs() {
    if (__privateGet(this, _blobs) == null) {
      return null;
    }
    return __privateGet(this, _blobs).map((b2) => Object.assign({}, b2));
  }
  set blobs(_blobs2) {
    if (_blobs2 == null) {
      __privateSet(this, _blobs, null);
      return;
    }
    const blobs = [];
    const versionedHashes = [];
    for (let i = 0; i < _blobs2.length; i++) {
      const blob = _blobs2[i];
      if (isBytesLike(blob)) {
        assert(__privateGet(this, _kzg), "adding a raw blob requires a KZG library", "UNSUPPORTED_OPERATION", {
          operation: "set blobs()"
        });
        let data = getBytes(blob);
        assertArgument(data.length <= BLOB_SIZE, "blob is too large", `blobs[${i}]`, blob);
        if (data.length !== BLOB_SIZE) {
          const padded = new Uint8Array(BLOB_SIZE);
          padded.set(data);
          data = padded;
        }
        const commit = __privateGet(this, _kzg).blobToKzgCommitment(data);
        const proof = hexlify(__privateGet(this, _kzg).computeBlobKzgProof(data, commit));
        blobs.push({
          data: hexlify(data),
          commitment: hexlify(commit),
          proof
        });
        versionedHashes.push(getVersionedHash(1, commit));
      } else {
        const commit = hexlify(blob.commitment);
        blobs.push({
          data: hexlify(blob.data),
          commitment: commit,
          proof: hexlify(blob.proof)
        });
        versionedHashes.push(getVersionedHash(1, commit));
      }
    }
    __privateSet(this, _blobs, blobs);
    __privateSet(this, _blobVersionedHashes, versionedHashes);
  }
  get kzg() {
    return __privateGet(this, _kzg);
  }
  set kzg(kzg) {
    __privateSet(this, _kzg, kzg);
  }
  /**
   *  The transaction hash, if signed. Otherwise, ``null``.
   */
  get hash() {
    if (this.signature == null) {
      return null;
    }
    return keccak256(__privateMethod(this, _Transaction_instances, getSerialized_fn).call(this, true, false));
  }
  /**
   *  The pre-image hash of this transaction.
   *
   *  This is the digest that a [[Signer]] must sign to authorize
   *  this transaction.
   */
  get unsignedHash() {
    return keccak256(this.unsignedSerialized);
  }
  /**
   *  The sending address, if signed. Otherwise, ``null``.
   */
  get from() {
    if (this.signature == null) {
      return null;
    }
    return recoverAddress(this.unsignedHash, this.signature);
  }
  /**
   *  The public key of the sender, if signed. Otherwise, ``null``.
   */
  get fromPublicKey() {
    if (this.signature == null) {
      return null;
    }
    return SigningKey.recoverPublicKey(this.unsignedHash, this.signature);
  }
  /**
   *  Returns true if signed.
   *
   *  This provides a Type Guard that properties requiring a signed
   *  transaction are non-null.
   */
  isSigned() {
    return this.signature != null;
  }
  /**
   *  The serialized transaction.
   *
   *  This throws if the transaction is unsigned. For the pre-image,
   *  use [[unsignedSerialized]].
   */
  get serialized() {
    return __privateMethod(this, _Transaction_instances, getSerialized_fn).call(this, true, true);
  }
  /**
   *  The transaction pre-image.
   *
   *  The hash of this is the digest which needs to be signed to
   *  authorize this transaction.
   */
  get unsignedSerialized() {
    return __privateMethod(this, _Transaction_instances, getSerialized_fn).call(this, false, false);
  }
  /**
   *  Return the most "likely" type; currently the highest
   *  supported transaction type.
   */
  inferType() {
    const types = this.inferTypes();
    if (types.indexOf(2) >= 0) {
      return 2;
    }
    return types.pop();
  }
  /**
   *  Validates the explicit properties and returns a list of compatible
   *  transaction types.
   */
  inferTypes() {
    const hasGasPrice = this.gasPrice != null;
    const hasFee = this.maxFeePerGas != null || this.maxPriorityFeePerGas != null;
    const hasAccessList = this.accessList != null;
    const hasBlob = __privateGet(this, _maxFeePerBlobGas) != null || __privateGet(this, _blobVersionedHashes);
    if (this.maxFeePerGas != null && this.maxPriorityFeePerGas != null) {
      assert(this.maxFeePerGas >= this.maxPriorityFeePerGas, "priorityFee cannot be more than maxFee", "BAD_DATA", { value: this });
    }
    assert(!hasFee || this.type !== 0 && this.type !== 1, "transaction type cannot have maxFeePerGas or maxPriorityFeePerGas", "BAD_DATA", { value: this });
    assert(this.type !== 0 || !hasAccessList, "legacy transaction cannot have accessList", "BAD_DATA", { value: this });
    const types = [];
    if (this.type != null) {
      types.push(this.type);
    } else {
      if (hasFee) {
        types.push(2);
      } else if (hasGasPrice) {
        types.push(1);
        if (!hasAccessList) {
          types.push(0);
        }
      } else if (hasAccessList) {
        types.push(1);
        types.push(2);
      } else if (hasBlob && this.to) {
        types.push(3);
      } else {
        types.push(0);
        types.push(1);
        types.push(2);
        types.push(3);
      }
    }
    types.sort();
    return types;
  }
  /**
   *  Returns true if this transaction is a legacy transaction (i.e.
   *  ``type === 0``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isLegacy() {
    return this.type === 0;
  }
  /**
   *  Returns true if this transaction is berlin hardform transaction (i.e.
   *  ``type === 1``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isBerlin() {
    return this.type === 1;
  }
  /**
   *  Returns true if this transaction is london hardform transaction (i.e.
   *  ``type === 2``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isLondon() {
    return this.type === 2;
  }
  /**
   *  Returns true if this transaction is an [[link-eip-4844]] BLOB
   *  transaction.
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isCancun() {
    return this.type === 3;
  }
  /**
   *  Create a copy of this transaciton.
   */
  clone() {
    return _Transaction.from(this);
  }
  /**
   *  Return a JSON-friendly object.
   */
  toJSON() {
    const s = (v2) => {
      if (v2 == null) {
        return null;
      }
      return v2.toString();
    };
    return {
      type: this.type,
      to: this.to,
      //            from: this.from,
      data: this.data,
      nonce: this.nonce,
      gasLimit: s(this.gasLimit),
      gasPrice: s(this.gasPrice),
      maxPriorityFeePerGas: s(this.maxPriorityFeePerGas),
      maxFeePerGas: s(this.maxFeePerGas),
      value: s(this.value),
      chainId: s(this.chainId),
      sig: this.signature ? this.signature.toJSON() : null,
      accessList: this.accessList
    };
  }
  /**
   *  Create a **Transaction** from a serialized transaction or a
   *  Transaction-like object.
   */
  static from(tx) {
    if (tx == null) {
      return new _Transaction();
    }
    if (typeof tx === "string") {
      const payload = getBytes(tx);
      if (payload[0] >= 127) {
        return _Transaction.from(_parseLegacy(payload));
      }
      switch (payload[0]) {
        case 1:
          return _Transaction.from(_parseEip2930(payload));
        case 2:
          return _Transaction.from(_parseEip1559(payload));
        case 3:
          return _Transaction.from(_parseEip4844(payload));
      }
      assert(false, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: "from" });
    }
    const result = new _Transaction();
    if (tx.type != null) {
      result.type = tx.type;
    }
    if (tx.to != null) {
      result.to = tx.to;
    }
    if (tx.nonce != null) {
      result.nonce = tx.nonce;
    }
    if (tx.gasLimit != null) {
      result.gasLimit = tx.gasLimit;
    }
    if (tx.gasPrice != null) {
      result.gasPrice = tx.gasPrice;
    }
    if (tx.maxPriorityFeePerGas != null) {
      result.maxPriorityFeePerGas = tx.maxPriorityFeePerGas;
    }
    if (tx.maxFeePerGas != null) {
      result.maxFeePerGas = tx.maxFeePerGas;
    }
    if (tx.maxFeePerBlobGas != null) {
      result.maxFeePerBlobGas = tx.maxFeePerBlobGas;
    }
    if (tx.data != null) {
      result.data = tx.data;
    }
    if (tx.value != null) {
      result.value = tx.value;
    }
    if (tx.chainId != null) {
      result.chainId = tx.chainId;
    }
    if (tx.signature != null) {
      result.signature = Signature.from(tx.signature);
    }
    if (tx.accessList != null) {
      result.accessList = tx.accessList;
    }
    if (tx.blobVersionedHashes != null) {
      result.blobVersionedHashes = tx.blobVersionedHashes;
    }
    if (tx.kzg != null) {
      result.kzg = tx.kzg;
    }
    if (tx.blobs != null) {
      result.blobs = tx.blobs;
    }
    if (tx.hash != null) {
      assertArgument(result.isSigned(), "unsigned transaction cannot define '.hash'", "tx", tx);
      assertArgument(result.hash === tx.hash, "hash mismatch", "tx", tx);
    }
    if (tx.from != null) {
      assertArgument(result.isSigned(), "unsigned transaction cannot define '.from'", "tx", tx);
      assertArgument(result.from.toLowerCase() === (tx.from || "").toLowerCase(), "from mismatch", "tx", tx);
    }
    return result;
  }
};
_type = new WeakMap();
_to = new WeakMap();
_data3 = new WeakMap();
_nonce = new WeakMap();
_gasLimit = new WeakMap();
_gasPrice = new WeakMap();
_maxPriorityFeePerGas = new WeakMap();
_maxFeePerGas = new WeakMap();
_value = new WeakMap();
_chainId = new WeakMap();
_sig = new WeakMap();
_accessList = new WeakMap();
_maxFeePerBlobGas = new WeakMap();
_blobVersionedHashes = new WeakMap();
_kzg = new WeakMap();
_blobs = new WeakMap();
_Transaction_instances = new WeakSet();
getSerialized_fn = function(signed, sidecar) {
  assert(!signed || this.signature != null, "cannot serialize unsigned transaction; maybe you meant .unsignedSerialized", "UNSUPPORTED_OPERATION", { operation: ".serialized" });
  const sig = signed ? this.signature : null;
  switch (this.inferType()) {
    case 0:
      return _serializeLegacy(this, sig);
    case 1:
      return _serializeEip2930(this, sig);
    case 2:
      return _serializeEip1559(this, sig);
    case 3:
      return _serializeEip4844(this, sig, sidecar ? this.blobs : null);
  }
  assert(false, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: ".serialized" });
};
let Transaction = _Transaction;
const regexBytes = new RegExp("^bytes([0-9]+)$");
const regexNumber = new RegExp("^(u?int)([0-9]*)$");
const regexArray = new RegExp("^(.*)\\[([0-9]*)\\]$");
function _pack(type, value, isArray) {
  switch (type) {
    case "address":
      if (isArray) {
        return getBytes(zeroPadValue(value, 32));
      }
      return getBytes(getAddress(value));
    case "string":
      return toUtf8Bytes(value);
    case "bytes":
      return getBytes(value);
    case "bool":
      value = !!value ? "0x01" : "0x00";
      if (isArray) {
        return getBytes(zeroPadValue(value, 32));
      }
      return getBytes(value);
  }
  let match = type.match(regexNumber);
  if (match) {
    let signed = match[1] === "int";
    let size = parseInt(match[2] || "256");
    assertArgument((!match[2] || match[2] === String(size)) && size % 8 === 0 && size !== 0 && size <= 256, "invalid number type", "type", type);
    if (isArray) {
      size = 256;
    }
    if (signed) {
      value = toTwos(value, size);
    }
    return getBytes(zeroPadValue(toBeArray(value), size / 8));
  }
  match = type.match(regexBytes);
  if (match) {
    const size = parseInt(match[1]);
    assertArgument(String(size) === match[1] && size !== 0 && size <= 32, "invalid bytes type", "type", type);
    assertArgument(dataLength(value) === size, `invalid value for ${type}`, "value", value);
    if (isArray) {
      return getBytes(zeroPadBytes(value, 32));
    }
    return value;
  }
  match = type.match(regexArray);
  if (match && Array.isArray(value)) {
    const baseType = match[1];
    const count = parseInt(match[2] || String(value.length));
    assertArgument(count === value.length, `invalid array length for ${type}`, "value", value);
    const result = [];
    value.forEach(function(value2) {
      result.push(_pack(baseType, value2, true));
    });
    return getBytes(concat(result));
  }
  assertArgument(false, "invalid type", "type", type);
}
function solidityPacked(types, values) {
  assertArgument(types.length === values.length, "wrong number of values; expected ${ types.length }", "values", values);
  const tight = [];
  types.forEach(function(type, index) {
    tight.push(_pack(type, values[index]));
  });
  return hexlify(concat(tight));
}
function solidityPackedKeccak256(types, values) {
  return keccak256(solidityPacked(types, values));
}
const padding = new Uint8Array(32);
padding.fill(0);
const BN__1 = BigInt(-1);
const BN_0$3 = BigInt(0);
const BN_1 = BigInt(1);
const BN_MAX_UINT256 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function hexPadRight(value) {
  const bytes = getBytes(value);
  const padOffset = bytes.length % 32;
  if (padOffset) {
    return concat([bytes, padding.slice(padOffset)]);
  }
  return hexlify(bytes);
}
const hexTrue = toBeHex(BN_1, 32);
const hexFalse = toBeHex(BN_0$3, 32);
const domainFieldTypes = {
  name: "string",
  version: "string",
  chainId: "uint256",
  verifyingContract: "address",
  salt: "bytes32"
};
const domainFieldNames = [
  "name",
  "version",
  "chainId",
  "verifyingContract",
  "salt"
];
function checkString(key) {
  return function(value) {
    assertArgument(typeof value === "string", `invalid domain value for ${JSON.stringify(key)}`, `domain.${key}`, value);
    return value;
  };
}
const domainChecks = {
  name: checkString("name"),
  version: checkString("version"),
  chainId: function(_value2) {
    const value = getBigInt(_value2, "domain.chainId");
    assertArgument(value >= 0, "invalid chain ID", "domain.chainId", _value2);
    if (Number.isSafeInteger(value)) {
      return Number(value);
    }
    return toQuantity(value);
  },
  verifyingContract: function(value) {
    try {
      return getAddress(value).toLowerCase();
    } catch (error) {
    }
    assertArgument(false, `invalid domain value "verifyingContract"`, "domain.verifyingContract", value);
  },
  salt: function(value) {
    const bytes = getBytes(value, "domain.salt");
    assertArgument(bytes.length === 32, `invalid domain value "salt"`, "domain.salt", value);
    return hexlify(bytes);
  }
};
function getBaseEncoder(type) {
  {
    const match = type.match(/^(u?)int(\d+)$/);
    if (match) {
      const signed = match[1] === "";
      const width = parseInt(match[2]);
      assertArgument(width % 8 === 0 && width !== 0 && width <= 256 && match[2] === String(width), "invalid numeric width", "type", type);
      const boundsUpper = mask(BN_MAX_UINT256, signed ? width - 1 : width);
      const boundsLower = signed ? (boundsUpper + BN_1) * BN__1 : BN_0$3;
      return function(_value2) {
        const value = getBigInt(_value2, "value");
        assertArgument(value >= boundsLower && value <= boundsUpper, `value out-of-bounds for ${type}`, "value", value);
        return toBeHex(signed ? toTwos(value, 256) : value, 32);
      };
    }
  }
  {
    const match = type.match(/^bytes(\d+)$/);
    if (match) {
      const width = parseInt(match[1]);
      assertArgument(width !== 0 && width <= 32 && match[1] === String(width), "invalid bytes width", "type", type);
      return function(value) {
        const bytes = getBytes(value);
        assertArgument(bytes.length === width, `invalid length for ${type}`, "value", value);
        return hexPadRight(value);
      };
    }
  }
  switch (type) {
    case "address":
      return function(value) {
        return zeroPadValue(getAddress(value), 32);
      };
    case "bool":
      return function(value) {
        return !value ? hexFalse : hexTrue;
      };
    case "bytes":
      return function(value) {
        return keccak256(value);
      };
    case "string":
      return function(value) {
        return id(value);
      };
  }
  return null;
}
function encodeType(name, fields) {
  return `${name}(${fields.map(({ name: name2, type }) => type + " " + name2).join(",")})`;
}
function splitArray(type) {
  const match = type.match(/^([^\x5b]*)((\x5b\d*\x5d)*)(\x5b(\d*)\x5d)$/);
  if (match) {
    return {
      base: match[1],
      index: match[2] + match[4],
      array: {
        base: match[1],
        prefix: match[1] + match[2],
        count: match[5] ? parseInt(match[5]) : -1
      }
    };
  }
  return { base: type };
}
const _TypedDataEncoder = class _TypedDataEncoder {
  /**
   *  Create a new **TypedDataEncoder** for %%types%%.
   *
   *  This performs all necessary checking that types are valid and
   *  do not violate the [[link-eip-712]] structural constraints as
   *  well as computes the [[primaryType]].
   */
  constructor(_types2) {
    __privateAdd(this, _TypedDataEncoder_instances);
    /**
     *  The primary type for the structured [[types]].
     *
     *  This is derived automatically from the [[types]], since no
     *  recursion is possible, once the DAG for the types is consturcted
     *  internally, the primary type must be the only remaining type with
     *  no parent nodes.
     */
    __publicField(this, "primaryType");
    __privateAdd(this, _types);
    __privateAdd(this, _fullTypes);
    __privateAdd(this, _encoderCache);
    __privateSet(this, _fullTypes, /* @__PURE__ */ new Map());
    __privateSet(this, _encoderCache, /* @__PURE__ */ new Map());
    const links = /* @__PURE__ */ new Map();
    const parents = /* @__PURE__ */ new Map();
    const subtypes = /* @__PURE__ */ new Map();
    const types = {};
    Object.keys(_types2).forEach((type) => {
      types[type] = _types2[type].map(({ name, type: type2 }) => {
        let { base, index } = splitArray(type2);
        if (base === "int" && !_types2["int"]) {
          base = "int256";
        }
        if (base === "uint" && !_types2["uint"]) {
          base = "uint256";
        }
        return { name, type: base + (index || "") };
      });
      links.set(type, /* @__PURE__ */ new Set());
      parents.set(type, []);
      subtypes.set(type, /* @__PURE__ */ new Set());
    });
    __privateSet(this, _types, JSON.stringify(types));
    for (const name in types) {
      const uniqueNames = /* @__PURE__ */ new Set();
      for (const field of types[name]) {
        assertArgument(!uniqueNames.has(field.name), `duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name)}`, "types", _types2);
        uniqueNames.add(field.name);
        const baseType = splitArray(field.type).base;
        assertArgument(baseType !== name, `circular type reference to ${JSON.stringify(baseType)}`, "types", _types2);
        const encoder = getBaseEncoder(baseType);
        if (encoder) {
          continue;
        }
        assertArgument(parents.has(baseType), `unknown type ${JSON.stringify(baseType)}`, "types", _types2);
        parents.get(baseType).push(name);
        links.get(name).add(baseType);
      }
    }
    const primaryTypes = Array.from(parents.keys()).filter((n4) => parents.get(n4).length === 0);
    assertArgument(primaryTypes.length !== 0, "missing primary type", "types", _types2);
    assertArgument(primaryTypes.length === 1, `ambiguous primary types or unused types: ${primaryTypes.map((t) => JSON.stringify(t)).join(", ")}`, "types", _types2);
    defineProperties(this, { primaryType: primaryTypes[0] });
    function checkCircular(type, found) {
      assertArgument(!found.has(type), `circular type reference to ${JSON.stringify(type)}`, "types", _types2);
      found.add(type);
      for (const child of links.get(type)) {
        if (!parents.has(child)) {
          continue;
        }
        checkCircular(child, found);
        for (const subtype of found) {
          subtypes.get(subtype).add(child);
        }
      }
      found.delete(type);
    }
    checkCircular(this.primaryType, /* @__PURE__ */ new Set());
    for (const [name, set2] of subtypes) {
      const st2 = Array.from(set2);
      st2.sort();
      __privateGet(this, _fullTypes).set(name, encodeType(name, types[name]) + st2.map((t) => encodeType(t, types[t])).join(""));
    }
  }
  /**
   *  The types.
   */
  get types() {
    return JSON.parse(__privateGet(this, _types));
  }
  /**
   *  Returnthe encoder for the specific %%type%%.
   */
  getEncoder(type) {
    let encoder = __privateGet(this, _encoderCache).get(type);
    if (!encoder) {
      encoder = __privateMethod(this, _TypedDataEncoder_instances, getEncoder_fn).call(this, type);
      __privateGet(this, _encoderCache).set(type, encoder);
    }
    return encoder;
  }
  /**
   *  Return the full type for %%name%%.
   */
  encodeType(name) {
    const result = __privateGet(this, _fullTypes).get(name);
    assertArgument(result, `unknown type: ${JSON.stringify(name)}`, "name", name);
    return result;
  }
  /**
   *  Return the encoded %%value%% for the %%type%%.
   */
  encodeData(type, value) {
    return this.getEncoder(type)(value);
  }
  /**
   *  Returns the hash of %%value%% for the type of %%name%%.
   */
  hashStruct(name, value) {
    return keccak256(this.encodeData(name, value));
  }
  /**
   *  Return the fulled encoded %%value%% for the [[types]].
   */
  encode(value) {
    return this.encodeData(this.primaryType, value);
  }
  /**
   *  Return the hash of the fully encoded %%value%% for the [[types]].
   */
  hash(value) {
    return this.hashStruct(this.primaryType, value);
  }
  /**
   *  @_ignore:
   */
  _visit(type, value, callback) {
    {
      const encoder = getBaseEncoder(type);
      if (encoder) {
        return callback(type, value);
      }
    }
    const array = splitArray(type).array;
    if (array) {
      assertArgument(array.count === -1 || array.count === value.length, `array length mismatch; expected length ${array.count}`, "value", value);
      return value.map((v2) => this._visit(array.prefix, v2, callback));
    }
    const fields = this.types[type];
    if (fields) {
      return fields.reduce((accum, { name, type: type2 }) => {
        accum[name] = this._visit(type2, value[name], callback);
        return accum;
      }, {});
    }
    assertArgument(false, `unknown type: ${type}`, "type", type);
  }
  /**
   *  Call %%calback%% for each value in %%value%%, passing the type and
   *  component within %%value%%.
   *
   *  This is useful for replacing addresses or other transformation that
   *  may be desired on each component, based on its type.
   */
  visit(value, callback) {
    return this._visit(this.primaryType, value, callback);
  }
  /**
   *  Create a new **TypedDataEncoder** for %%types%%.
   */
  static from(types) {
    return new _TypedDataEncoder(types);
  }
  /**
   *  Return the primary type for %%types%%.
   */
  static getPrimaryType(types) {
    return _TypedDataEncoder.from(types).primaryType;
  }
  /**
   *  Return the hashed struct for %%value%% using %%types%% and %%name%%.
   */
  static hashStruct(name, types, value) {
    return _TypedDataEncoder.from(types).hashStruct(name, value);
  }
  /**
   *  Return the domain hash for %%domain%%.
   */
  static hashDomain(domain) {
    const domainFields = [];
    for (const name in domain) {
      if (domain[name] == null) {
        continue;
      }
      const type = domainFieldTypes[name];
      assertArgument(type, `invalid typed-data domain key: ${JSON.stringify(name)}`, "domain", domain);
      domainFields.push({ name, type });
    }
    domainFields.sort((a2, b2) => {
      return domainFieldNames.indexOf(a2.name) - domainFieldNames.indexOf(b2.name);
    });
    return _TypedDataEncoder.hashStruct("EIP712Domain", { EIP712Domain: domainFields }, domain);
  }
  /**
   *  Return the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.
   */
  static encode(domain, types, value) {
    return concat([
      "0x1901",
      _TypedDataEncoder.hashDomain(domain),
      _TypedDataEncoder.from(types).hash(value)
    ]);
  }
  /**
   *  Return the hash of the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.
   */
  static hash(domain, types, value) {
    return keccak256(_TypedDataEncoder.encode(domain, types, value));
  }
  // Replaces all address types with ENS names with their looked up address
  /**
   * Resolves to the value from resolving all addresses in %%value%% for
   * %%types%% and the %%domain%%.
   */
  static async resolveNames(domain, types, value, resolveName) {
    domain = Object.assign({}, domain);
    for (const key in domain) {
      if (domain[key] == null) {
        delete domain[key];
      }
    }
    const ensCache = {};
    if (domain.verifyingContract && !isHexString(domain.verifyingContract, 20)) {
      ensCache[domain.verifyingContract] = "0x";
    }
    const encoder = _TypedDataEncoder.from(types);
    encoder.visit(value, (type, value2) => {
      if (type === "address" && !isHexString(value2, 20)) {
        ensCache[value2] = "0x";
      }
      return value2;
    });
    for (const name in ensCache) {
      ensCache[name] = await resolveName(name);
    }
    if (domain.verifyingContract && ensCache[domain.verifyingContract]) {
      domain.verifyingContract = ensCache[domain.verifyingContract];
    }
    value = encoder.visit(value, (type, value2) => {
      if (type === "address" && ensCache[value2]) {
        return ensCache[value2];
      }
      return value2;
    });
    return { domain, value };
  }
  /**
   *  Returns the JSON-encoded payload expected by nodes which implement
   *  the JSON-RPC [[link-eip-712]] method.
   */
  static getPayload(domain, types, value) {
    _TypedDataEncoder.hashDomain(domain);
    const domainValues = {};
    const domainTypes = [];
    domainFieldNames.forEach((name) => {
      const value2 = domain[name];
      if (value2 == null) {
        return;
      }
      domainValues[name] = domainChecks[name](value2);
      domainTypes.push({ name, type: domainFieldTypes[name] });
    });
    const encoder = _TypedDataEncoder.from(types);
    types = encoder.types;
    const typesWithDomain = Object.assign({}, types);
    assertArgument(typesWithDomain.EIP712Domain == null, "types must not contain EIP712Domain type", "types.EIP712Domain", types);
    typesWithDomain.EIP712Domain = domainTypes;
    encoder.encode(value);
    return {
      types: typesWithDomain,
      domain: domainValues,
      primaryType: encoder.primaryType,
      message: encoder.visit(value, (type, value2) => {
        if (type.match(/^bytes(\d*)/)) {
          return hexlify(getBytes(value2));
        }
        if (type.match(/^u?int/)) {
          return getBigInt(value2).toString();
        }
        switch (type) {
          case "address":
            return value2.toLowerCase();
          case "bool":
            return !!value2;
          case "string":
            assertArgument(typeof value2 === "string", "invalid string", "value", value2);
            return value2;
        }
        assertArgument(false, "unsupported type", "type", type);
      })
    };
  }
};
_types = new WeakMap();
_fullTypes = new WeakMap();
_encoderCache = new WeakMap();
_TypedDataEncoder_instances = new WeakSet();
getEncoder_fn = function(type) {
  {
    const encoder = getBaseEncoder(type);
    if (encoder) {
      return encoder;
    }
  }
  const array = splitArray(type).array;
  if (array) {
    const subtype = array.prefix;
    const subEncoder = this.getEncoder(subtype);
    return (value) => {
      assertArgument(array.count === -1 || array.count === value.length, `array length mismatch; expected length ${array.count}`, "value", value);
      let result = value.map(subEncoder);
      if (__privateGet(this, _fullTypes).has(subtype)) {
        result = result.map(keccak256);
      }
      return keccak256(concat(result));
    };
  }
  const fields = this.types[type];
  if (fields) {
    const encodedType = id(__privateGet(this, _fullTypes).get(type));
    return (value) => {
      const values = fields.map(({ name, type: type2 }) => {
        const result = this.getEncoder(type2)(value[name]);
        if (__privateGet(this, _fullTypes).has(type2)) {
          return keccak256(result);
        }
        return result;
      });
      values.unshift(encodedType);
      return concat(values);
    };
  }
  assertArgument(false, `unknown type: ${type}`, "type", type);
};
let TypedDataEncoder = _TypedDataEncoder;
function setify(items) {
  const result = /* @__PURE__ */ new Set();
  items.forEach((k2) => result.add(k2));
  return Object.freeze(result);
}
const _kwVisibDeploy = "external public payable override";
const KwVisibDeploy = setify(_kwVisibDeploy.split(" "));
const _kwVisib = "constant external internal payable private public pure view override";
const KwVisib = setify(_kwVisib.split(" "));
const _kwTypes = "constructor error event fallback function receive struct";
const KwTypes = setify(_kwTypes.split(" "));
const _kwModifiers = "calldata memory storage payable indexed";
const KwModifiers = setify(_kwModifiers.split(" "));
const _kwOther = "tuple returns";
const _keywords = [_kwTypes, _kwModifiers, _kwOther, _kwVisib].join(" ");
const Keywords = setify(_keywords.split(" "));
const SimpleTokens = {
  "(": "OPEN_PAREN",
  ")": "CLOSE_PAREN",
  "[": "OPEN_BRACKET",
  "]": "CLOSE_BRACKET",
  ",": "COMMA",
  "@": "AT"
};
const regexWhitespacePrefix = new RegExp("^(\\s*)");
const regexNumberPrefix = new RegExp("^([0-9]+)");
const regexIdPrefix = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)");
const regexId = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)$");
const regexType = new RegExp("^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$");
const _TokenString = class _TokenString {
  constructor(tokens) {
    __privateAdd(this, _TokenString_instances);
    __privateAdd(this, _offset2);
    __privateAdd(this, _tokens);
    __privateSet(this, _offset2, 0);
    __privateSet(this, _tokens, tokens.slice());
  }
  get offset() {
    return __privateGet(this, _offset2);
  }
  get length() {
    return __privateGet(this, _tokens).length - __privateGet(this, _offset2);
  }
  clone() {
    return new _TokenString(__privateGet(this, _tokens));
  }
  reset() {
    __privateSet(this, _offset2, 0);
  }
  // Pops and returns the value of the next token, if it is a keyword in allowed; throws if out of tokens
  popKeyword(allowed) {
    const top = this.peek();
    if (top.type !== "KEYWORD" || !allowed.has(top.text)) {
      throw new Error(`expected keyword ${top.text}`);
    }
    return this.pop().text;
  }
  // Pops and returns the value of the next token if it is `type`; throws if out of tokens
  popType(type) {
    if (this.peek().type !== type) {
      const top = this.peek();
      throw new Error(`expected ${type}; got ${top.type} ${JSON.stringify(top.text)}`);
    }
    return this.pop().text;
  }
  // Pops and returns a "(" TOKENS ")"
  popParen() {
    const top = this.peek();
    if (top.type !== "OPEN_PAREN") {
      throw new Error("bad start");
    }
    const result = __privateMethod(this, _TokenString_instances, subTokenString_fn).call(this, __privateGet(this, _offset2) + 1, top.match + 1);
    __privateSet(this, _offset2, top.match + 1);
    return result;
  }
  // Pops and returns the items within "(" ITEM1 "," ITEM2 "," ... ")"
  popParams() {
    const top = this.peek();
    if (top.type !== "OPEN_PAREN") {
      throw new Error("bad start");
    }
    const result = [];
    while (__privateGet(this, _offset2) < top.match - 1) {
      const link = this.peek().linkNext;
      result.push(__privateMethod(this, _TokenString_instances, subTokenString_fn).call(this, __privateGet(this, _offset2) + 1, link));
      __privateSet(this, _offset2, link);
    }
    __privateSet(this, _offset2, top.match + 1);
    return result;
  }
  // Returns the top Token, throwing if out of tokens
  peek() {
    if (__privateGet(this, _offset2) >= __privateGet(this, _tokens).length) {
      throw new Error("out-of-bounds");
    }
    return __privateGet(this, _tokens)[__privateGet(this, _offset2)];
  }
  // Returns the next value, if it is a keyword in `allowed`
  peekKeyword(allowed) {
    const top = this.peekType("KEYWORD");
    return top != null && allowed.has(top) ? top : null;
  }
  // Returns the value of the next token if it is `type`
  peekType(type) {
    if (this.length === 0) {
      return null;
    }
    const top = this.peek();
    return top.type === type ? top.text : null;
  }
  // Returns the next token; throws if out of tokens
  pop() {
    const result = this.peek();
    __privateWrapper(this, _offset2)._++;
    return result;
  }
  toString() {
    const tokens = [];
    for (let i = __privateGet(this, _offset2); i < __privateGet(this, _tokens).length; i++) {
      const token = __privateGet(this, _tokens)[i];
      tokens.push(`${token.type}:${token.text}`);
    }
    return `<TokenString ${tokens.join(" ")}>`;
  }
};
_offset2 = new WeakMap();
_tokens = new WeakMap();
_TokenString_instances = new WeakSet();
subTokenString_fn = function(from = 0, to2 = 0) {
  return new _TokenString(__privateGet(this, _tokens).slice(from, to2).map((t) => {
    return Object.freeze(Object.assign({}, t, {
      match: t.match - from,
      linkBack: t.linkBack - from,
      linkNext: t.linkNext - from
    }));
  }));
};
let TokenString = _TokenString;
function lex(text) {
  const tokens = [];
  const throwError2 = (message) => {
    const token = offset < text.length ? JSON.stringify(text[offset]) : "$EOI";
    throw new Error(`invalid token ${token} at ${offset}: ${message}`);
  };
  let brackets = [];
  let commas = [];
  let offset = 0;
  while (offset < text.length) {
    let cur = text.substring(offset);
    let match = cur.match(regexWhitespacePrefix);
    if (match) {
      offset += match[1].length;
      cur = text.substring(offset);
    }
    const token = { depth: brackets.length, linkBack: -1, linkNext: -1, match: -1, type: "", text: "", offset, value: -1 };
    tokens.push(token);
    let type = SimpleTokens[cur[0]] || "";
    if (type) {
      token.type = type;
      token.text = cur[0];
      offset++;
      if (type === "OPEN_PAREN") {
        brackets.push(tokens.length - 1);
        commas.push(tokens.length - 1);
      } else if (type == "CLOSE_PAREN") {
        if (brackets.length === 0) {
          throwError2("no matching open bracket");
        }
        token.match = brackets.pop();
        tokens[token.match].match = tokens.length - 1;
        token.depth--;
        token.linkBack = commas.pop();
        tokens[token.linkBack].linkNext = tokens.length - 1;
      } else if (type === "COMMA") {
        token.linkBack = commas.pop();
        tokens[token.linkBack].linkNext = tokens.length - 1;
        commas.push(tokens.length - 1);
      } else if (type === "OPEN_BRACKET") {
        token.type = "BRACKET";
      } else if (type === "CLOSE_BRACKET") {
        let suffix = tokens.pop().text;
        if (tokens.length > 0 && tokens[tokens.length - 1].type === "NUMBER") {
          const value = tokens.pop().text;
          suffix = value + suffix;
          tokens[tokens.length - 1].value = getNumber(value);
        }
        if (tokens.length === 0 || tokens[tokens.length - 1].type !== "BRACKET") {
          throw new Error("missing opening bracket");
        }
        tokens[tokens.length - 1].text += suffix;
      }
      continue;
    }
    match = cur.match(regexIdPrefix);
    if (match) {
      token.text = match[1];
      offset += token.text.length;
      if (Keywords.has(token.text)) {
        token.type = "KEYWORD";
        continue;
      }
      if (token.text.match(regexType)) {
        token.type = "TYPE";
        continue;
      }
      token.type = "ID";
      continue;
    }
    match = cur.match(regexNumberPrefix);
    if (match) {
      token.text = match[1];
      token.type = "NUMBER";
      offset += token.text.length;
      continue;
    }
    throw new Error(`unexpected token ${JSON.stringify(cur[0])} at position ${offset}`);
  }
  return new TokenString(tokens.map((t) => Object.freeze(t)));
}
function allowSingle(set2, allowed) {
  let included = [];
  for (const key in allowed.keys()) {
    if (set2.has(key)) {
      included.push(key);
    }
  }
  if (included.length > 1) {
    throw new Error(`conflicting types: ${included.join(", ")}`);
  }
}
function consumeName(type, tokens) {
  if (tokens.peekKeyword(KwTypes)) {
    const keyword = tokens.pop().text;
    if (keyword !== type) {
      throw new Error(`expected ${type}, got ${keyword}`);
    }
  }
  return tokens.popType("ID");
}
function consumeKeywords(tokens, allowed) {
  const keywords = /* @__PURE__ */ new Set();
  while (true) {
    const keyword = tokens.peekType("KEYWORD");
    if (keyword == null || allowed && !allowed.has(keyword)) {
      break;
    }
    tokens.pop();
    if (keywords.has(keyword)) {
      throw new Error(`duplicate keywords: ${JSON.stringify(keyword)}`);
    }
    keywords.add(keyword);
  }
  return Object.freeze(keywords);
}
function consumeMutability(tokens) {
  let modifiers = consumeKeywords(tokens, KwVisib);
  allowSingle(modifiers, setify("constant payable nonpayable".split(" ")));
  allowSingle(modifiers, setify("pure view payable nonpayable".split(" ")));
  if (modifiers.has("view")) {
    return "view";
  }
  if (modifiers.has("pure")) {
    return "pure";
  }
  if (modifiers.has("payable")) {
    return "payable";
  }
  if (modifiers.has("nonpayable")) {
    return "nonpayable";
  }
  if (modifiers.has("constant")) {
    return "view";
  }
  return "nonpayable";
}
function consumeParams(tokens, allowIndexed) {
  return tokens.popParams().map((t) => ParamType.from(t, allowIndexed));
}
function consumeGas(tokens) {
  if (tokens.peekType("AT")) {
    tokens.pop();
    if (tokens.peekType("NUMBER")) {
      return getBigInt(tokens.pop().text);
    }
    throw new Error("invalid gas");
  }
  return null;
}
function consumeEoi(tokens) {
  if (tokens.length) {
    throw new Error(`unexpected tokens at offset ${tokens.offset}: ${tokens.toString()}`);
  }
}
const regexArrayType = new RegExp(/^(.*)\[([0-9]*)\]$/);
function verifyBasicType(type) {
  const match = type.match(regexType);
  assertArgument(match, "invalid type", "type", type);
  if (type === "uint") {
    return "uint256";
  }
  if (type === "int") {
    return "int256";
  }
  if (match[2]) {
    const length = parseInt(match[2]);
    assertArgument(length !== 0 && length <= 32, "invalid bytes length", "type", type);
  } else if (match[3]) {
    const size = parseInt(match[3]);
    assertArgument(size !== 0 && size <= 256 && size % 8 === 0, "invalid numeric width", "type", type);
  }
  return type;
}
const _guard = {};
const internal$1 = Symbol.for("_ethers_internal");
const ParamTypeInternal = "_ParamTypeInternal";
const ErrorFragmentInternal = "_ErrorInternal";
const EventFragmentInternal = "_EventInternal";
const ConstructorFragmentInternal = "_ConstructorInternal";
const FallbackFragmentInternal = "_FallbackInternal";
const FunctionFragmentInternal = "_FunctionInternal";
const StructFragmentInternal = "_StructInternal";
const _ParamType = class _ParamType {
  /**
   *  @private
   */
  constructor(guard, name, type, baseType, indexed, components, arrayLength, arrayChildren) {
    __privateAdd(this, _ParamType_instances);
    /**
     *  The local name of the parameter (or ``""`` if unbound)
     */
    __publicField(this, "name");
    /**
     *  The fully qualified type (e.g. ``"address"``, ``"tuple(address)"``,
     *  ``"uint256[3][]"``)
     */
    __publicField(this, "type");
    /**
     *  The base type (e.g. ``"address"``, ``"tuple"``, ``"array"``)
     */
    __publicField(this, "baseType");
    /**
     *  True if the parameters is indexed.
     *
     *  For non-indexable types this is ``null``.
     */
    __publicField(this, "indexed");
    /**
     *  The components for the tuple.
     *
     *  For non-tuple types this is ``null``.
     */
    __publicField(this, "components");
    /**
     *  The array length, or ``-1`` for dynamic-lengthed arrays.
     *
     *  For non-array types this is ``null``.
     */
    __publicField(this, "arrayLength");
    /**
     *  The type of each child in the array.
     *
     *  For non-array types this is ``null``.
     */
    __publicField(this, "arrayChildren");
    assertPrivate(guard, _guard, "ParamType");
    Object.defineProperty(this, internal$1, { value: ParamTypeInternal });
    if (components) {
      components = Object.freeze(components.slice());
    }
    if (baseType === "array") {
      if (arrayLength == null || arrayChildren == null) {
        throw new Error("");
      }
    } else if (arrayLength != null || arrayChildren != null) {
      throw new Error("");
    }
    if (baseType === "tuple") {
      if (components == null) {
        throw new Error("");
      }
    } else if (components != null) {
      throw new Error("");
    }
    defineProperties(this, {
      name,
      type,
      baseType,
      indexed,
      components,
      arrayLength,
      arrayChildren
    });
  }
  /**
   *  Return a string representation of this type.
   *
   *  For example,
   *
   *  ``sighash" => "(uint256,address)"``
   *
   *  ``"minimal" => "tuple(uint256,address) indexed"``
   *
   *  ``"full" => "tuple(uint256 foo, address bar) indexed baz"``
   */
  format(format2) {
    if (format2 == null) {
      format2 = "sighash";
    }
    if (format2 === "json") {
      const name = this.name || "";
      if (this.isArray()) {
        const result3 = JSON.parse(this.arrayChildren.format("json"));
        result3.name = name;
        result3.type += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`;
        return JSON.stringify(result3);
      }
      const result2 = {
        type: this.baseType === "tuple" ? "tuple" : this.type,
        name
      };
      if (typeof this.indexed === "boolean") {
        result2.indexed = this.indexed;
      }
      if (this.isTuple()) {
        result2.components = this.components.map((c2) => JSON.parse(c2.format(format2)));
      }
      return JSON.stringify(result2);
    }
    let result = "";
    if (this.isArray()) {
      result += this.arrayChildren.format(format2);
      result += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`;
    } else {
      if (this.isTuple()) {
        result += "(" + this.components.map((comp) => comp.format(format2)).join(format2 === "full" ? ", " : ",") + ")";
      } else {
        result += this.type;
      }
    }
    if (format2 !== "sighash") {
      if (this.indexed === true) {
        result += " indexed";
      }
      if (format2 === "full" && this.name) {
        result += " " + this.name;
      }
    }
    return result;
  }
  /**
   *  Returns true if %%this%% is an Array type.
   *
   *  This provides a type gaurd ensuring that [[arrayChildren]]
   *  and [[arrayLength]] are non-null.
   */
  isArray() {
    return this.baseType === "array";
  }
  /**
   *  Returns true if %%this%% is a Tuple type.
   *
   *  This provides a type gaurd ensuring that [[components]]
   *  is non-null.
   */
  isTuple() {
    return this.baseType === "tuple";
  }
  /**
   *  Returns true if %%this%% is an Indexable type.
   *
   *  This provides a type gaurd ensuring that [[indexed]]
   *  is non-null.
   */
  isIndexable() {
    return this.indexed != null;
  }
  /**
   *  Walks the **ParamType** with %%value%%, calling %%process%%
   *  on each type, destructing the %%value%% recursively.
   */
  walk(value, process) {
    if (this.isArray()) {
      if (!Array.isArray(value)) {
        throw new Error("invalid array value");
      }
      if (this.arrayLength !== -1 && value.length !== this.arrayLength) {
        throw new Error("array is wrong length");
      }
      const _this = this;
      return value.map((v2) => _this.arrayChildren.walk(v2, process));
    }
    if (this.isTuple()) {
      if (!Array.isArray(value)) {
        throw new Error("invalid tuple value");
      }
      if (value.length !== this.components.length) {
        throw new Error("array is wrong length");
      }
      const _this = this;
      return value.map((v2, i) => _this.components[i].walk(v2, process));
    }
    return process(this.type, value);
  }
  /**
   *  Walks the **ParamType** with %%value%%, asynchronously calling
   *  %%process%% on each type, destructing the %%value%% recursively.
   *
   *  This can be used to resolve ENS names by walking and resolving each
   *  ``"address"`` type.
   */
  async walkAsync(value, process) {
    const promises = [];
    const result = [value];
    __privateMethod(this, _ParamType_instances, walkAsync_fn).call(this, promises, value, process, (value2) => {
      result[0] = value2;
    });
    if (promises.length) {
      await Promise.all(promises);
    }
    return result[0];
  }
  /**
   *  Creates a new **ParamType** for %%obj%%.
   *
   *  If %%allowIndexed%% then the ``indexed`` keyword is permitted,
   *  otherwise the ``indexed`` keyword will throw an error.
   */
  static from(obj, allowIndexed) {
    if (_ParamType.isParamType(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return _ParamType.from(lex(obj), allowIndexed);
      } catch (error) {
        assertArgument(false, "invalid param type", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      let type2 = "", baseType = "";
      let comps = null;
      if (consumeKeywords(obj, setify(["tuple"])).has("tuple") || obj.peekType("OPEN_PAREN")) {
        baseType = "tuple";
        comps = obj.popParams().map((t) => _ParamType.from(t));
        type2 = `tuple(${comps.map((c2) => c2.format()).join(",")})`;
      } else {
        type2 = verifyBasicType(obj.popType("TYPE"));
        baseType = type2;
      }
      let arrayChildren = null;
      let arrayLength = null;
      while (obj.length && obj.peekType("BRACKET")) {
        const bracket = obj.pop();
        arrayChildren = new _ParamType(_guard, "", type2, baseType, null, comps, arrayLength, arrayChildren);
        arrayLength = bracket.value;
        type2 += bracket.text;
        baseType = "array";
        comps = null;
      }
      let indexed2 = null;
      const keywords = consumeKeywords(obj, KwModifiers);
      if (keywords.has("indexed")) {
        if (!allowIndexed) {
          throw new Error("");
        }
        indexed2 = true;
      }
      const name2 = obj.peekType("ID") ? obj.pop().text : "";
      if (obj.length) {
        throw new Error("leftover tokens");
      }
      return new _ParamType(_guard, name2, type2, baseType, indexed2, comps, arrayLength, arrayChildren);
    }
    const name = obj.name;
    assertArgument(!name || typeof name === "string" && name.match(regexId), "invalid name", "obj.name", name);
    let indexed = obj.indexed;
    if (indexed != null) {
      assertArgument(allowIndexed, "parameter cannot be indexed", "obj.indexed", obj.indexed);
      indexed = !!indexed;
    }
    let type = obj.type;
    let arrayMatch = type.match(regexArrayType);
    if (arrayMatch) {
      const arrayLength = parseInt(arrayMatch[2] || "-1");
      const arrayChildren = _ParamType.from({
        type: arrayMatch[1],
        components: obj.components
      });
      return new _ParamType(_guard, name || "", type, "array", indexed, null, arrayLength, arrayChildren);
    }
    if (type === "tuple" || type.startsWith(
      "tuple("
      /* fix: ) */
    ) || type.startsWith(
      "("
      /* fix: ) */
    )) {
      const comps = obj.components != null ? obj.components.map((c2) => _ParamType.from(c2)) : null;
      const tuple = new _ParamType(_guard, name || "", type, "tuple", indexed, comps, null, null);
      return tuple;
    }
    type = verifyBasicType(obj.type);
    return new _ParamType(_guard, name || "", type, type, indexed, null, null, null);
  }
  /**
   *  Returns true if %%value%% is a **ParamType**.
   */
  static isParamType(value) {
    return value && value[internal$1] === ParamTypeInternal;
  }
};
_ParamType_instances = new WeakSet();
walkAsync_fn = function(promises, value, process, setValue) {
  if (this.isArray()) {
    if (!Array.isArray(value)) {
      throw new Error("invalid array value");
    }
    if (this.arrayLength !== -1 && value.length !== this.arrayLength) {
      throw new Error("array is wrong length");
    }
    const childType = this.arrayChildren;
    const result2 = value.slice();
    result2.forEach((value2, index) => {
      var _a2;
      __privateMethod(_a2 = childType, _ParamType_instances, walkAsync_fn).call(_a2, promises, value2, process, (value3) => {
        result2[index] = value3;
      });
    });
    setValue(result2);
    return;
  }
  if (this.isTuple()) {
    const components = this.components;
    let result2;
    if (Array.isArray(value)) {
      result2 = value.slice();
    } else {
      if (value == null || typeof value !== "object") {
        throw new Error("invalid tuple value");
      }
      result2 = components.map((param) => {
        if (!param.name) {
          throw new Error("cannot use object value with unnamed components");
        }
        if (!(param.name in value)) {
          throw new Error(`missing value for component ${param.name}`);
        }
        return value[param.name];
      });
    }
    if (result2.length !== this.components.length) {
      throw new Error("array is wrong length");
    }
    result2.forEach((value2, index) => {
      var _a2;
      __privateMethod(_a2 = components[index], _ParamType_instances, walkAsync_fn).call(_a2, promises, value2, process, (value3) => {
        result2[index] = value3;
      });
    });
    setValue(result2);
    return;
  }
  const result = process(this.type, value);
  if (result.then) {
    promises.push(async function() {
      setValue(await result);
    }());
  } else {
    setValue(result);
  }
};
let ParamType = _ParamType;
class Fragment {
  /**
   *  @private
   */
  constructor(guard, type, inputs) {
    /**
     *  The type of the fragment.
     */
    __publicField(this, "type");
    /**
     *  The inputs for the fragment.
     */
    __publicField(this, "inputs");
    assertPrivate(guard, _guard, "Fragment");
    inputs = Object.freeze(inputs.slice());
    defineProperties(this, { type, inputs });
  }
  /**
   *  Creates a new **Fragment** for %%obj%%, wich can be any supported
   *  ABI frgament type.
   */
  static from(obj) {
    if (typeof obj === "string") {
      try {
        Fragment.from(JSON.parse(obj));
      } catch (e3) {
      }
      return Fragment.from(lex(obj));
    }
    if (obj instanceof TokenString) {
      const type = obj.peekKeyword(KwTypes);
      switch (type) {
        case "constructor":
          return ConstructorFragment.from(obj);
        case "error":
          return ErrorFragment.from(obj);
        case "event":
          return EventFragment.from(obj);
        case "fallback":
        case "receive":
          return FallbackFragment.from(obj);
        case "function":
          return FunctionFragment.from(obj);
        case "struct":
          return StructFragment.from(obj);
      }
    } else if (typeof obj === "object") {
      switch (obj.type) {
        case "constructor":
          return ConstructorFragment.from(obj);
        case "error":
          return ErrorFragment.from(obj);
        case "event":
          return EventFragment.from(obj);
        case "fallback":
        case "receive":
          return FallbackFragment.from(obj);
        case "function":
          return FunctionFragment.from(obj);
        case "struct":
          return StructFragment.from(obj);
      }
      assert(false, `unsupported type: ${obj.type}`, "UNSUPPORTED_OPERATION", {
        operation: "Fragment.from"
      });
    }
    assertArgument(false, "unsupported frgament object", "obj", obj);
  }
  /**
   *  Returns true if %%value%% is a [[ConstructorFragment]].
   */
  static isConstructor(value) {
    return ConstructorFragment.isFragment(value);
  }
  /**
   *  Returns true if %%value%% is an [[ErrorFragment]].
   */
  static isError(value) {
    return ErrorFragment.isFragment(value);
  }
  /**
   *  Returns true if %%value%% is an [[EventFragment]].
   */
  static isEvent(value) {
    return EventFragment.isFragment(value);
  }
  /**
   *  Returns true if %%value%% is a [[FunctionFragment]].
   */
  static isFunction(value) {
    return FunctionFragment.isFragment(value);
  }
  /**
   *  Returns true if %%value%% is a [[StructFragment]].
   */
  static isStruct(value) {
    return StructFragment.isFragment(value);
  }
}
class NamedFragment extends Fragment {
  /**
   *  @private
   */
  constructor(guard, type, name, inputs) {
    super(guard, type, inputs);
    /**
     *  The name of the fragment.
     */
    __publicField(this, "name");
    assertArgument(typeof name === "string" && name.match(regexId), "invalid identifier", "name", name);
    inputs = Object.freeze(inputs.slice());
    defineProperties(this, { name });
  }
}
function joinParams(format2, params) {
  return "(" + params.map((p2) => p2.format(format2)).join(format2 === "full" ? ", " : ",") + ")";
}
class ErrorFragment extends NamedFragment {
  /**
   *  @private
   */
  constructor(guard, name, inputs) {
    super(guard, "error", name, inputs);
    Object.defineProperty(this, internal$1, { value: ErrorFragmentInternal });
  }
  /**
   *  The Custom Error selector.
   */
  get selector() {
    return id(this.format("sighash")).substring(0, 10);
  }
  /**
   *  Returns a string representation of this fragment as %%format%%.
   */
  format(format2) {
    if (format2 == null) {
      format2 = "sighash";
    }
    if (format2 === "json") {
      return JSON.stringify({
        type: "error",
        name: this.name,
        inputs: this.inputs.map((input) => JSON.parse(input.format(format2)))
      });
    }
    const result = [];
    if (format2 !== "sighash") {
      result.push("error");
    }
    result.push(this.name + joinParams(format2, this.inputs));
    return result.join(" ");
  }
  /**
   *  Returns a new **ErrorFragment** for %%obj%%.
   */
  static from(obj) {
    if (ErrorFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      return ErrorFragment.from(lex(obj));
    } else if (obj instanceof TokenString) {
      const name = consumeName("error", obj);
      const inputs = consumeParams(obj);
      consumeEoi(obj);
      return new ErrorFragment(_guard, name, inputs);
    }
    return new ErrorFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is an
   *  **ErrorFragment**.
   */
  static isFragment(value) {
    return value && value[internal$1] === ErrorFragmentInternal;
  }
}
class EventFragment extends NamedFragment {
  /**
   *  @private
   */
  constructor(guard, name, inputs, anonymous) {
    super(guard, "event", name, inputs);
    /**
     *  Whether this event is anonymous.
     */
    __publicField(this, "anonymous");
    Object.defineProperty(this, internal$1, { value: EventFragmentInternal });
    defineProperties(this, { anonymous });
  }
  /**
   *  The Event topic hash.
   */
  get topicHash() {
    return id(this.format("sighash"));
  }
  /**
   *  Returns a string representation of this event as %%format%%.
   */
  format(format2) {
    if (format2 == null) {
      format2 = "sighash";
    }
    if (format2 === "json") {
      return JSON.stringify({
        type: "event",
        anonymous: this.anonymous,
        name: this.name,
        inputs: this.inputs.map((i) => JSON.parse(i.format(format2)))
      });
    }
    const result = [];
    if (format2 !== "sighash") {
      result.push("event");
    }
    result.push(this.name + joinParams(format2, this.inputs));
    if (format2 !== "sighash" && this.anonymous) {
      result.push("anonymous");
    }
    return result.join(" ");
  }
  /**
   *  Return the topic hash for an event with %%name%% and %%params%%.
   */
  static getTopicHash(name, params) {
    params = (params || []).map((p2) => ParamType.from(p2));
    const fragment = new EventFragment(_guard, name, params, false);
    return fragment.topicHash;
  }
  /**
   *  Returns a new **EventFragment** for %%obj%%.
   */
  static from(obj) {
    if (EventFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return EventFragment.from(lex(obj));
      } catch (error) {
        assertArgument(false, "invalid event fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      const name = consumeName("event", obj);
      const inputs = consumeParams(obj, true);
      const anonymous = !!consumeKeywords(obj, setify(["anonymous"])).has("anonymous");
      consumeEoi(obj);
      return new EventFragment(_guard, name, inputs, anonymous);
    }
    return new EventFragment(_guard, obj.name, obj.inputs ? obj.inputs.map((p2) => ParamType.from(p2, true)) : [], !!obj.anonymous);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is an
   *  **EventFragment**.
   */
  static isFragment(value) {
    return value && value[internal$1] === EventFragmentInternal;
  }
}
class ConstructorFragment extends Fragment {
  /**
   *  @private
   */
  constructor(guard, type, inputs, payable, gas) {
    super(guard, type, inputs);
    /**
     *  Whether the constructor can receive an endowment.
     */
    __publicField(this, "payable");
    /**
     *  The recommended gas limit for deployment or ``null``.
     */
    __publicField(this, "gas");
    Object.defineProperty(this, internal$1, { value: ConstructorFragmentInternal });
    defineProperties(this, { payable, gas });
  }
  /**
   *  Returns a string representation of this constructor as %%format%%.
   */
  format(format2) {
    assert(format2 != null && format2 !== "sighash", "cannot format a constructor for sighash", "UNSUPPORTED_OPERATION", { operation: "format(sighash)" });
    if (format2 === "json") {
      return JSON.stringify({
        type: "constructor",
        stateMutability: this.payable ? "payable" : "undefined",
        payable: this.payable,
        gas: this.gas != null ? this.gas : void 0,
        inputs: this.inputs.map((i) => JSON.parse(i.format(format2)))
      });
    }
    const result = [`constructor${joinParams(format2, this.inputs)}`];
    if (this.payable) {
      result.push("payable");
    }
    if (this.gas != null) {
      result.push(`@${this.gas.toString()}`);
    }
    return result.join(" ");
  }
  /**
   *  Returns a new **ConstructorFragment** for %%obj%%.
   */
  static from(obj) {
    if (ConstructorFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return ConstructorFragment.from(lex(obj));
      } catch (error) {
        assertArgument(false, "invalid constuctor fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      consumeKeywords(obj, setify(["constructor"]));
      const inputs = consumeParams(obj);
      const payable = !!consumeKeywords(obj, KwVisibDeploy).has("payable");
      const gas = consumeGas(obj);
      consumeEoi(obj);
      return new ConstructorFragment(_guard, "constructor", inputs, payable, gas);
    }
    return new ConstructorFragment(_guard, "constructor", obj.inputs ? obj.inputs.map(ParamType.from) : [], !!obj.payable, obj.gas != null ? obj.gas : null);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **ConstructorFragment**.
   */
  static isFragment(value) {
    return value && value[internal$1] === ConstructorFragmentInternal;
  }
}
class FallbackFragment extends Fragment {
  constructor(guard, inputs, payable) {
    super(guard, "fallback", inputs);
    /**
     *  If the function can be sent value during invocation.
     */
    __publicField(this, "payable");
    Object.defineProperty(this, internal$1, { value: FallbackFragmentInternal });
    defineProperties(this, { payable });
  }
  /**
   *  Returns a string representation of this fallback as %%format%%.
   */
  format(format2) {
    const type = this.inputs.length === 0 ? "receive" : "fallback";
    if (format2 === "json") {
      const stateMutability = this.payable ? "payable" : "nonpayable";
      return JSON.stringify({ type, stateMutability });
    }
    return `${type}()${this.payable ? " payable" : ""}`;
  }
  /**
   *  Returns a new **FallbackFragment** for %%obj%%.
   */
  static from(obj) {
    if (FallbackFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return FallbackFragment.from(lex(obj));
      } catch (error) {
        assertArgument(false, "invalid fallback fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      const errorObj = obj.toString();
      const topIsValid = obj.peekKeyword(setify(["fallback", "receive"]));
      assertArgument(topIsValid, "type must be fallback or receive", "obj", errorObj);
      const type = obj.popKeyword(setify(["fallback", "receive"]));
      if (type === "receive") {
        const inputs2 = consumeParams(obj);
        assertArgument(inputs2.length === 0, `receive cannot have arguments`, "obj.inputs", inputs2);
        consumeKeywords(obj, setify(["payable"]));
        consumeEoi(obj);
        return new FallbackFragment(_guard, [], true);
      }
      let inputs = consumeParams(obj);
      if (inputs.length) {
        assertArgument(inputs.length === 1 && inputs[0].type === "bytes", "invalid fallback inputs", "obj.inputs", inputs.map((i) => i.format("minimal")).join(", "));
      } else {
        inputs = [ParamType.from("bytes")];
      }
      const mutability = consumeMutability(obj);
      assertArgument(mutability === "nonpayable" || mutability === "payable", "fallback cannot be constants", "obj.stateMutability", mutability);
      if (consumeKeywords(obj, setify(["returns"])).has("returns")) {
        const outputs = consumeParams(obj);
        assertArgument(outputs.length === 1 && outputs[0].type === "bytes", "invalid fallback outputs", "obj.outputs", outputs.map((i) => i.format("minimal")).join(", "));
      }
      consumeEoi(obj);
      return new FallbackFragment(_guard, inputs, mutability === "payable");
    }
    if (obj.type === "receive") {
      return new FallbackFragment(_guard, [], true);
    }
    if (obj.type === "fallback") {
      const inputs = [ParamType.from("bytes")];
      const payable = obj.stateMutability === "payable";
      return new FallbackFragment(_guard, inputs, payable);
    }
    assertArgument(false, "invalid fallback description", "obj", obj);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **FallbackFragment**.
   */
  static isFragment(value) {
    return value && value[internal$1] === FallbackFragmentInternal;
  }
}
class FunctionFragment extends NamedFragment {
  /**
   *  @private
   */
  constructor(guard, name, stateMutability, inputs, outputs, gas) {
    super(guard, "function", name, inputs);
    /**
     *  If the function is constant (e.g. ``pure`` or ``view`` functions).
     */
    __publicField(this, "constant");
    /**
     *  The returned types for the result of calling this function.
     */
    __publicField(this, "outputs");
    /**
     *  The state mutability (e.g. ``payable``, ``nonpayable``, ``view``
     *  or ``pure``)
     */
    __publicField(this, "stateMutability");
    /**
     *  If the function can be sent value during invocation.
     */
    __publicField(this, "payable");
    /**
     *  The recommended gas limit to send when calling this function.
     */
    __publicField(this, "gas");
    Object.defineProperty(this, internal$1, { value: FunctionFragmentInternal });
    outputs = Object.freeze(outputs.slice());
    const constant = stateMutability === "view" || stateMutability === "pure";
    const payable = stateMutability === "payable";
    defineProperties(this, { constant, gas, outputs, payable, stateMutability });
  }
  /**
   *  The Function selector.
   */
  get selector() {
    return id(this.format("sighash")).substring(0, 10);
  }
  /**
   *  Returns a string representation of this function as %%format%%.
   */
  format(format2) {
    if (format2 == null) {
      format2 = "sighash";
    }
    if (format2 === "json") {
      return JSON.stringify({
        type: "function",
        name: this.name,
        constant: this.constant,
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas != null ? this.gas : void 0,
        inputs: this.inputs.map((i) => JSON.parse(i.format(format2))),
        outputs: this.outputs.map((o) => JSON.parse(o.format(format2)))
      });
    }
    const result = [];
    if (format2 !== "sighash") {
      result.push("function");
    }
    result.push(this.name + joinParams(format2, this.inputs));
    if (format2 !== "sighash") {
      if (this.stateMutability !== "nonpayable") {
        result.push(this.stateMutability);
      }
      if (this.outputs && this.outputs.length) {
        result.push("returns");
        result.push(joinParams(format2, this.outputs));
      }
      if (this.gas != null) {
        result.push(`@${this.gas.toString()}`);
      }
    }
    return result.join(" ");
  }
  /**
   *  Return the selector for a function with %%name%% and %%params%%.
   */
  static getSelector(name, params) {
    params = (params || []).map((p2) => ParamType.from(p2));
    const fragment = new FunctionFragment(_guard, name, "view", params, [], null);
    return fragment.selector;
  }
  /**
   *  Returns a new **FunctionFragment** for %%obj%%.
   */
  static from(obj) {
    if (FunctionFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return FunctionFragment.from(lex(obj));
      } catch (error) {
        assertArgument(false, "invalid function fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      const name = consumeName("function", obj);
      const inputs = consumeParams(obj);
      const mutability = consumeMutability(obj);
      let outputs = [];
      if (consumeKeywords(obj, setify(["returns"])).has("returns")) {
        outputs = consumeParams(obj);
      }
      const gas = consumeGas(obj);
      consumeEoi(obj);
      return new FunctionFragment(_guard, name, mutability, inputs, outputs, gas);
    }
    let stateMutability = obj.stateMutability;
    if (stateMutability == null) {
      stateMutability = "payable";
      if (typeof obj.constant === "boolean") {
        stateMutability = "view";
        if (!obj.constant) {
          stateMutability = "payable";
          if (typeof obj.payable === "boolean" && !obj.payable) {
            stateMutability = "nonpayable";
          }
        }
      } else if (typeof obj.payable === "boolean" && !obj.payable) {
        stateMutability = "nonpayable";
      }
    }
    return new FunctionFragment(_guard, obj.name, stateMutability, obj.inputs ? obj.inputs.map(ParamType.from) : [], obj.outputs ? obj.outputs.map(ParamType.from) : [], obj.gas != null ? obj.gas : null);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **FunctionFragment**.
   */
  static isFragment(value) {
    return value && value[internal$1] === FunctionFragmentInternal;
  }
}
class StructFragment extends NamedFragment {
  /**
   *  @private
   */
  constructor(guard, name, inputs) {
    super(guard, "struct", name, inputs);
    Object.defineProperty(this, internal$1, { value: StructFragmentInternal });
  }
  /**
   *  Returns a string representation of this struct as %%format%%.
   */
  format() {
    throw new Error("@TODO");
  }
  /**
   *  Returns a new **StructFragment** for %%obj%%.
   */
  static from(obj) {
    if (typeof obj === "string") {
      try {
        return StructFragment.from(lex(obj));
      } catch (error) {
        assertArgument(false, "invalid struct fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      const name = consumeName("struct", obj);
      const inputs = consumeParams(obj);
      consumeEoi(obj);
      return new StructFragment(_guard, name, inputs);
    }
    return new StructFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);
  }
  // @TODO: fix this return type
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **StructFragment**.
   */
  static isFragment(value) {
    return value && value[internal$1] === StructFragmentInternal;
  }
}
const PanicReasons$1 = /* @__PURE__ */ new Map();
PanicReasons$1.set(0, "GENERIC_PANIC");
PanicReasons$1.set(1, "ASSERT_FALSE");
PanicReasons$1.set(17, "OVERFLOW");
PanicReasons$1.set(18, "DIVIDE_BY_ZERO");
PanicReasons$1.set(33, "ENUM_RANGE_ERROR");
PanicReasons$1.set(34, "BAD_STORAGE_DATA");
PanicReasons$1.set(49, "STACK_UNDERFLOW");
PanicReasons$1.set(50, "ARRAY_RANGE_ERROR");
PanicReasons$1.set(65, "OUT_OF_MEMORY");
PanicReasons$1.set(81, "UNINITIALIZED_FUNCTION_CALL");
const paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
const paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
let defaultCoder = null;
let defaultMaxInflation = 1024;
function getBuiltinCallException(action, tx, data, abiCoder) {
  let message = "missing revert data";
  let reason = null;
  const invocation = null;
  let revert = null;
  if (data) {
    message = "execution reverted";
    const bytes = getBytes(data);
    data = hexlify(data);
    if (bytes.length === 0) {
      message += " (no data present; likely require(false) occurred";
      reason = "require(false)";
    } else if (bytes.length % 32 !== 4) {
      message += " (could not decode reason; invalid data length)";
    } else if (hexlify(bytes.slice(0, 4)) === "0x08c379a0") {
      try {
        reason = abiCoder.decode(["string"], bytes.slice(4))[0];
        revert = {
          signature: "Error(string)",
          name: "Error",
          args: [reason]
        };
        message += `: ${JSON.stringify(reason)}`;
      } catch (error) {
        message += " (could not decode reason; invalid string data)";
      }
    } else if (hexlify(bytes.slice(0, 4)) === "0x4e487b71") {
      try {
        const code = Number(abiCoder.decode(["uint256"], bytes.slice(4))[0]);
        revert = {
          signature: "Panic(uint256)",
          name: "Panic",
          args: [code]
        };
        reason = `Panic due to ${PanicReasons$1.get(code) || "UNKNOWN"}(${code})`;
        message += `: ${reason}`;
      } catch (error) {
        message += " (could not decode panic code)";
      }
    } else {
      message += " (unknown custom error)";
    }
  }
  const transaction = {
    to: tx.to ? getAddress(tx.to) : null,
    data: tx.data || "0x"
  };
  if (tx.from) {
    transaction.from = getAddress(tx.from);
  }
  return makeError(message, "CALL_EXCEPTION", {
    action,
    data,
    reason,
    transaction,
    invocation,
    revert
  });
}
const _AbiCoder = class _AbiCoder {
  constructor() {
    __privateAdd(this, _AbiCoder_instances);
  }
  /**
   *  Get the default values for the given %%types%%.
   *
   *  For example, a ``uint`` is by default ``0`` and ``bool``
   *  is by default ``false``.
   */
  getDefaultValue(types) {
    const coders = types.map((type) => __privateMethod(this, _AbiCoder_instances, getCoder_fn).call(this, ParamType.from(type)));
    const coder = new TupleCoder(coders, "_");
    return coder.defaultValue();
  }
  /**
   *  Encode the %%values%% as the %%types%% into ABI data.
   *
   *  @returns DataHexstring
   */
  encode(types, values) {
    assertArgumentCount(values.length, types.length, "types/values length mismatch");
    const coders = types.map((type) => __privateMethod(this, _AbiCoder_instances, getCoder_fn).call(this, ParamType.from(type)));
    const coder = new TupleCoder(coders, "_");
    const writer = new Writer();
    coder.encode(writer, values);
    return writer.data;
  }
  /**
   *  Decode the ABI %%data%% as the %%types%% into values.
   *
   *  If %%loose%% decoding is enabled, then strict padding is
   *  not enforced. Some older versions of Solidity incorrectly
   *  padded event data emitted from ``external`` functions.
   */
  decode(types, data, loose) {
    const coders = types.map((type) => __privateMethod(this, _AbiCoder_instances, getCoder_fn).call(this, ParamType.from(type)));
    const coder = new TupleCoder(coders, "_");
    return coder.decode(new Reader(data, loose, defaultMaxInflation));
  }
  static _setDefaultMaxInflation(value) {
    assertArgument(typeof value === "number" && Number.isInteger(value), "invalid defaultMaxInflation factor", "value", value);
    defaultMaxInflation = value;
  }
  /**
   *  Returns the shared singleton instance of a default [[AbiCoder]].
   *
   *  On the first call, the instance is created internally.
   */
  static defaultAbiCoder() {
    if (defaultCoder == null) {
      defaultCoder = new _AbiCoder();
    }
    return defaultCoder;
  }
  /**
   *  Returns an ethers-compatible [[CallExceptionError]] Error for the given
   *  result %%data%% for the [[CallExceptionAction]] %%action%% against
   *  the Transaction %%tx%%.
   */
  static getBuiltinCallException(action, tx, data) {
    return getBuiltinCallException(action, tx, data, _AbiCoder.defaultAbiCoder());
  }
};
_AbiCoder_instances = new WeakSet();
getCoder_fn = function(param) {
  if (param.isArray()) {
    return new ArrayCoder(__privateMethod(this, _AbiCoder_instances, getCoder_fn).call(this, param.arrayChildren), param.arrayLength, param.name);
  }
  if (param.isTuple()) {
    return new TupleCoder(param.components.map((c2) => __privateMethod(this, _AbiCoder_instances, getCoder_fn).call(this, c2)), param.name);
  }
  switch (param.baseType) {
    case "address":
      return new AddressCoder(param.name);
    case "bool":
      return new BooleanCoder(param.name);
    case "string":
      return new StringCoder(param.name);
    case "bytes":
      return new BytesCoder(param.name);
    case "":
      return new NullCoder(param.name);
  }
  let match = param.type.match(paramTypeNumber);
  if (match) {
    let size = parseInt(match[2] || "256");
    assertArgument(size !== 0 && size <= 256 && size % 8 === 0, "invalid " + match[1] + " bit length", "param", param);
    return new NumberCoder(size / 8, match[1] === "int", param.name);
  }
  match = param.type.match(paramTypeBytes);
  if (match) {
    let size = parseInt(match[1]);
    assertArgument(size !== 0 && size <= 32, "invalid bytes length", "param", param);
    return new FixedBytesCoder(size, param.name);
  }
  assertArgument(false, "invalid type", "type", param.type);
};
let AbiCoder = _AbiCoder;
class LogDescription {
  /**
   *  @_ignore:
   */
  constructor(fragment, topic, args) {
    /**
     *  The matching fragment for the ``topic0``.
     */
    __publicField(this, "fragment");
    /**
     *  The name of the Event.
     */
    __publicField(this, "name");
    /**
     *  The full Event signature.
     */
    __publicField(this, "signature");
    /**
     *  The topic hash for the Event.
     */
    __publicField(this, "topic");
    /**
     *  The arguments passed into the Event with ``emit``.
     */
    __publicField(this, "args");
    const name = fragment.name, signature = fragment.format();
    defineProperties(this, {
      fragment,
      name,
      signature,
      topic,
      args
    });
  }
}
class TransactionDescription {
  /**
   *  @_ignore:
   */
  constructor(fragment, selector, args, value) {
    /**
     *  The matching fragment from the transaction ``data``.
     */
    __publicField(this, "fragment");
    /**
     *  The name of the Function from the transaction ``data``.
     */
    __publicField(this, "name");
    /**
     *  The arguments passed to the Function from the transaction ``data``.
     */
    __publicField(this, "args");
    /**
     *  The full Function signature from the transaction ``data``.
     */
    __publicField(this, "signature");
    /**
     *  The selector for the Function from the transaction ``data``.
     */
    __publicField(this, "selector");
    /**
     *  The ``value`` (in wei) from the transaction.
     */
    __publicField(this, "value");
    const name = fragment.name, signature = fragment.format();
    defineProperties(this, {
      fragment,
      name,
      args,
      signature,
      selector,
      value
    });
  }
}
class ErrorDescription {
  /**
   *  @_ignore:
   */
  constructor(fragment, selector, args) {
    /**
     *  The matching fragment.
     */
    __publicField(this, "fragment");
    /**
     *  The name of the Error.
     */
    __publicField(this, "name");
    /**
     *  The arguments passed to the Error with ``revert``.
     */
    __publicField(this, "args");
    /**
     *  The full Error signature.
     */
    __publicField(this, "signature");
    /**
     *  The selector for the Error.
     */
    __publicField(this, "selector");
    const name = fragment.name, signature = fragment.format();
    defineProperties(this, {
      fragment,
      name,
      args,
      signature,
      selector
    });
  }
}
class Indexed {
  /**
   *  @_ignore:
   */
  constructor(hash) {
    /**
     *  The ``keccak256`` of the value logged.
     */
    __publicField(this, "hash");
    /**
     *  @_ignore:
     */
    __publicField(this, "_isIndexed");
    defineProperties(this, { hash, _isIndexed: true });
  }
  /**
   *  Returns ``true`` if %%value%% is an **Indexed**.
   *
   *  This provides a Type Guard for property access.
   */
  static isIndexed(value) {
    return !!(value && value._isIndexed);
  }
}
const PanicReasons = {
  "0": "generic panic",
  "1": "assert(false)",
  "17": "arithmetic overflow",
  "18": "division or modulo by zero",
  "33": "enum overflow",
  "34": "invalid encoded storage byte array accessed",
  "49": "out-of-bounds array access; popping on an empty array",
  "50": "out-of-bounds access of an array or bytesN",
  "65": "out of memory",
  "81": "uninitialized function"
};
const BuiltinErrors = {
  "0x08c379a0": {
    signature: "Error(string)",
    name: "Error",
    inputs: ["string"],
    reason: (message) => {
      return `reverted with reason string ${JSON.stringify(message)}`;
    }
  },
  "0x4e487b71": {
    signature: "Panic(uint256)",
    name: "Panic",
    inputs: ["uint256"],
    reason: (code) => {
      let reason = "unknown panic code";
      if (code >= 0 && code <= 255 && PanicReasons[code.toString()]) {
        reason = PanicReasons[code.toString()];
      }
      return `reverted with panic code 0x${code.toString(16)} (${reason})`;
    }
  }
};
const _Interface = class _Interface {
  /**
   *  Create a new Interface for the %%fragments%%.
   */
  constructor(fragments) {
    __privateAdd(this, _Interface_instances);
    /**
     *  All the Contract ABI members (i.e. methods, events, errors, etc).
     */
    __publicField(this, "fragments");
    /**
     *  The Contract constructor.
     */
    __publicField(this, "deploy");
    /**
     *  The Fallback method, if any.
     */
    __publicField(this, "fallback");
    /**
     *  If receiving ether is supported.
     */
    __publicField(this, "receive");
    __privateAdd(this, _errors);
    __privateAdd(this, _events);
    __privateAdd(this, _functions);
    //    #structs: Map<string, StructFragment>;
    __privateAdd(this, _abiCoder);
    let abi = [];
    if (typeof fragments === "string") {
      abi = JSON.parse(fragments);
    } else {
      abi = fragments;
    }
    __privateSet(this, _functions, /* @__PURE__ */ new Map());
    __privateSet(this, _errors, /* @__PURE__ */ new Map());
    __privateSet(this, _events, /* @__PURE__ */ new Map());
    const frags = [];
    for (const a2 of abi) {
      try {
        frags.push(Fragment.from(a2));
      } catch (error) {
        console.log(`[Warning] Invalid Fragment ${JSON.stringify(a2)}:`, error.message);
      }
    }
    defineProperties(this, {
      fragments: Object.freeze(frags)
    });
    let fallback = null;
    let receive = false;
    __privateSet(this, _abiCoder, this.getAbiCoder());
    this.fragments.forEach((fragment, index) => {
      let bucket;
      switch (fragment.type) {
        case "constructor":
          if (this.deploy) {
            console.log("duplicate definition - constructor");
            return;
          }
          defineProperties(this, { deploy: fragment });
          return;
        case "fallback":
          if (fragment.inputs.length === 0) {
            receive = true;
          } else {
            assertArgument(!fallback || fragment.payable !== fallback.payable, "conflicting fallback fragments", `fragments[${index}]`, fragment);
            fallback = fragment;
            receive = fallback.payable;
          }
          return;
        case "function":
          bucket = __privateGet(this, _functions);
          break;
        case "event":
          bucket = __privateGet(this, _events);
          break;
        case "error":
          bucket = __privateGet(this, _errors);
          break;
        default:
          return;
      }
      const signature = fragment.format();
      if (bucket.has(signature)) {
        return;
      }
      bucket.set(signature, fragment);
    });
    if (!this.deploy) {
      defineProperties(this, {
        deploy: ConstructorFragment.from("constructor()")
      });
    }
    defineProperties(this, { fallback, receive });
  }
  /**
   *  Returns the entire Human-Readable ABI, as an array of
   *  signatures, optionally as %%minimal%% strings, which
   *  removes parameter names and unneceesary spaces.
   */
  format(minimal) {
    const format2 = minimal ? "minimal" : "full";
    const abi = this.fragments.map((f2) => f2.format(format2));
    return abi;
  }
  /**
   *  Return the JSON-encoded ABI. This is the format Solidiy
   *  returns.
   */
  formatJson() {
    const abi = this.fragments.map((f2) => f2.format("json"));
    return JSON.stringify(abi.map((j2) => JSON.parse(j2)));
  }
  /**
   *  The ABI coder that will be used to encode and decode binary
   *  data.
   */
  getAbiCoder() {
    return AbiCoder.defaultAbiCoder();
  }
  /**
   *  Get the function name for %%key%%, which may be a function selector,
   *  function name or function signature that belongs to the ABI.
   */
  getFunctionName(key) {
    const fragment = __privateMethod(this, _Interface_instances, getFunction_fn).call(this, key, null, false);
    assertArgument(fragment, "no matching function", "key", key);
    return fragment.name;
  }
  /**
   *  Returns true if %%key%% (a function selector, function name or
   *  function signature) is present in the ABI.
   *
   *  In the case of a function name, the name may be ambiguous, so
   *  accessing the [[FunctionFragment]] may require refinement.
   */
  hasFunction(key) {
    return !!__privateMethod(this, _Interface_instances, getFunction_fn).call(this, key, null, false);
  }
  /**
   *  Get the [[FunctionFragment]] for %%key%%, which may be a function
   *  selector, function name or function signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple functions match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single function in
   *  the ABI, this will throw.
   */
  getFunction(key, values) {
    return __privateMethod(this, _Interface_instances, getFunction_fn).call(this, key, values || null, true);
  }
  /**
   *  Iterate over all functions, calling %%callback%%, sorted by their name.
   */
  forEachFunction(callback) {
    const names2 = Array.from(__privateGet(this, _functions).keys());
    names2.sort((a2, b2) => a2.localeCompare(b2));
    for (let i = 0; i < names2.length; i++) {
      const name = names2[i];
      callback(__privateGet(this, _functions).get(name), i);
    }
  }
  /**
   *  Get the event name for %%key%%, which may be a topic hash,
   *  event name or event signature that belongs to the ABI.
   */
  getEventName(key) {
    const fragment = __privateMethod(this, _Interface_instances, getEvent_fn).call(this, key, null, false);
    assertArgument(fragment, "no matching event", "key", key);
    return fragment.name;
  }
  /**
   *  Returns true if %%key%% (an event topic hash, event name or
   *  event signature) is present in the ABI.
   *
   *  In the case of an event name, the name may be ambiguous, so
   *  accessing the [[EventFragment]] may require refinement.
   */
  hasEvent(key) {
    return !!__privateMethod(this, _Interface_instances, getEvent_fn).call(this, key, null, false);
  }
  /**
   *  Get the [[EventFragment]] for %%key%%, which may be a topic hash,
   *  event name or event signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple events match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single event in
   *  the ABI, this will throw.
   */
  getEvent(key, values) {
    return __privateMethod(this, _Interface_instances, getEvent_fn).call(this, key, values || null, true);
  }
  /**
   *  Iterate over all events, calling %%callback%%, sorted by their name.
   */
  forEachEvent(callback) {
    const names2 = Array.from(__privateGet(this, _events).keys());
    names2.sort((a2, b2) => a2.localeCompare(b2));
    for (let i = 0; i < names2.length; i++) {
      const name = names2[i];
      callback(__privateGet(this, _events).get(name), i);
    }
  }
  /**
   *  Get the [[ErrorFragment]] for %%key%%, which may be an error
   *  selector, error name or error signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple errors match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single error in
   *  the ABI, this will throw.
   */
  getError(key, values) {
    if (isHexString(key)) {
      const selector = key.toLowerCase();
      if (BuiltinErrors[selector]) {
        return ErrorFragment.from(BuiltinErrors[selector].signature);
      }
      for (const fragment of __privateGet(this, _errors).values()) {
        if (selector === fragment.selector) {
          return fragment;
        }
      }
      return null;
    }
    if (key.indexOf("(") === -1) {
      const matching = [];
      for (const [name, fragment] of __privateGet(this, _errors)) {
        if (name.split(
          "("
          /* fix:) */
        )[0] === key) {
          matching.push(fragment);
        }
      }
      if (matching.length === 0) {
        if (key === "Error") {
          return ErrorFragment.from("error Error(string)");
        }
        if (key === "Panic") {
          return ErrorFragment.from("error Panic(uint256)");
        }
        return null;
      } else if (matching.length > 1) {
        const matchStr = matching.map((m2) => JSON.stringify(m2.format())).join(", ");
        assertArgument(false, `ambiguous error description (i.e. ${matchStr})`, "name", key);
      }
      return matching[0];
    }
    key = ErrorFragment.from(key).format();
    if (key === "Error(string)") {
      return ErrorFragment.from("error Error(string)");
    }
    if (key === "Panic(uint256)") {
      return ErrorFragment.from("error Panic(uint256)");
    }
    const result = __privateGet(this, _errors).get(key);
    if (result) {
      return result;
    }
    return null;
  }
  /**
   *  Iterate over all errors, calling %%callback%%, sorted by their name.
   */
  forEachError(callback) {
    const names2 = Array.from(__privateGet(this, _errors).keys());
    names2.sort((a2, b2) => a2.localeCompare(b2));
    for (let i = 0; i < names2.length; i++) {
      const name = names2[i];
      callback(__privateGet(this, _errors).get(name), i);
    }
  }
  // Get the 4-byte selector used by Solidity to identify a function
  /*
  getSelector(fragment: ErrorFragment | FunctionFragment): string {
      if (typeof(fragment) === "string") {
          const matches: Array<Fragment> = [ ];
  
          try { matches.push(this.getFunction(fragment)); } catch (error) { }
          try { matches.push(this.getError(<string>fragment)); } catch (_) { }
  
          if (matches.length === 0) {
              logger.throwArgumentError("unknown fragment", "key", fragment);
          } else if (matches.length > 1) {
              logger.throwArgumentError("ambiguous fragment matches function and error", "key", fragment);
          }
  
          fragment = matches[0];
      }
  
      return dataSlice(id(fragment.format()), 0, 4);
  }
      */
  // Get the 32-byte topic hash used by Solidity to identify an event
  /*
  getEventTopic(fragment: EventFragment): string {
      //if (typeof(fragment) === "string") { fragment = this.getEvent(eventFragment); }
      return id(fragment.format());
  }
  */
  _decodeParams(params, data) {
    return __privateGet(this, _abiCoder).decode(params, data);
  }
  _encodeParams(params, values) {
    return __privateGet(this, _abiCoder).encode(params, values);
  }
  /**
   *  Encodes a ``tx.data`` object for deploying the Contract with
   *  the %%values%% as the constructor arguments.
   */
  encodeDeploy(values) {
    return this._encodeParams(this.deploy.inputs, values || []);
  }
  /**
   *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the
   *  specified error (see [[getError]] for valid values for
   *  %%key%%).
   *
   *  Most developers should prefer the [[parseCallResult]] method instead,
   *  which will automatically detect a ``CALL_EXCEPTION`` and throw the
   *  corresponding error.
   */
  decodeErrorResult(fragment, data) {
    if (typeof fragment === "string") {
      const f2 = this.getError(fragment);
      assertArgument(f2, "unknown error", "fragment", fragment);
      fragment = f2;
    }
    assertArgument(dataSlice(data, 0, 4) === fragment.selector, `data signature does not match error ${fragment.name}.`, "data", data);
    return this._decodeParams(fragment.inputs, dataSlice(data, 4));
  }
  /**
   *  Encodes the transaction revert data for a call result that
   *  reverted from the the Contract with the sepcified %%error%%
   *  (see [[getError]] for valid values for %%fragment%%) with the %%values%%.
   *
   *  This is generally not used by most developers, unless trying to mock
   *  a result from a Contract.
   */
  encodeErrorResult(fragment, values) {
    if (typeof fragment === "string") {
      const f2 = this.getError(fragment);
      assertArgument(f2, "unknown error", "fragment", fragment);
      fragment = f2;
    }
    return concat([
      fragment.selector,
      this._encodeParams(fragment.inputs, values || [])
    ]);
  }
  /**
   *  Decodes the %%data%% from a transaction ``tx.data`` for
   *  the function specified (see [[getFunction]] for valid values
   *  for %%fragment%%).
   *
   *  Most developers should prefer the [[parseTransaction]] method
   *  instead, which will automatically detect the fragment.
   */
  decodeFunctionData(fragment, data) {
    if (typeof fragment === "string") {
      const f2 = this.getFunction(fragment);
      assertArgument(f2, "unknown function", "fragment", fragment);
      fragment = f2;
    }
    assertArgument(dataSlice(data, 0, 4) === fragment.selector, `data signature does not match function ${fragment.name}.`, "data", data);
    return this._decodeParams(fragment.inputs, dataSlice(data, 4));
  }
  /**
   *  Encodes the ``tx.data`` for a transaction that calls the function
   *  specified (see [[getFunction]] for valid values for %%fragment%%) with
   *  the %%values%%.
   */
  encodeFunctionData(fragment, values) {
    if (typeof fragment === "string") {
      const f2 = this.getFunction(fragment);
      assertArgument(f2, "unknown function", "fragment", fragment);
      fragment = f2;
    }
    return concat([
      fragment.selector,
      this._encodeParams(fragment.inputs, values || [])
    ]);
  }
  /**
   *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the
   *  specified function (see [[getFunction]] for valid values for
   *  %%key%%).
   *
   *  Most developers should prefer the [[parseCallResult]] method instead,
   *  which will automatically detect a ``CALL_EXCEPTION`` and throw the
   *  corresponding error.
   */
  decodeFunctionResult(fragment, data) {
    if (typeof fragment === "string") {
      const f2 = this.getFunction(fragment);
      assertArgument(f2, "unknown function", "fragment", fragment);
      fragment = f2;
    }
    let message = "invalid length for result data";
    const bytes = getBytesCopy(data);
    if (bytes.length % 32 === 0) {
      try {
        return __privateGet(this, _abiCoder).decode(fragment.outputs, bytes);
      } catch (error) {
        message = "could not decode result data";
      }
    }
    assert(false, message, "BAD_DATA", {
      value: hexlify(bytes),
      info: { method: fragment.name, signature: fragment.format() }
    });
  }
  makeError(_data4, tx) {
    const data = getBytes(_data4, "data");
    const error = AbiCoder.getBuiltinCallException("call", tx, data);
    const customPrefix = "execution reverted (unknown custom error)";
    if (error.message.startsWith(customPrefix)) {
      const selector = hexlify(data.slice(0, 4));
      const ef2 = this.getError(selector);
      if (ef2) {
        try {
          const args = __privateGet(this, _abiCoder).decode(ef2.inputs, data.slice(4));
          error.revert = {
            name: ef2.name,
            signature: ef2.format(),
            args
          };
          error.reason = error.revert.signature;
          error.message = `execution reverted: ${error.reason}`;
        } catch (e3) {
          error.message = `execution reverted (coult not decode custom error)`;
        }
      }
    }
    const parsed = this.parseTransaction(tx);
    if (parsed) {
      error.invocation = {
        method: parsed.name,
        signature: parsed.signature,
        args: parsed.args
      };
    }
    return error;
  }
  /**
   *  Encodes the result data (e.g. from an ``eth_call``) for the
   *  specified function (see [[getFunction]] for valid values
   *  for %%fragment%%) with %%values%%.
   *
   *  This is generally not used by most developers, unless trying to mock
   *  a result from a Contract.
   */
  encodeFunctionResult(fragment, values) {
    if (typeof fragment === "string") {
      const f2 = this.getFunction(fragment);
      assertArgument(f2, "unknown function", "fragment", fragment);
      fragment = f2;
    }
    return hexlify(__privateGet(this, _abiCoder).encode(fragment.outputs, values || []));
  }
  /*
      spelunk(inputs: Array<ParamType>, values: ReadonlyArray<any>, processfunc: (type: string, value: any) => Promise<any>): Promise<Array<any>> {
          const promises: Array<Promise<>> = [ ];
          const process = function(type: ParamType, value: any): any {
              if (type.baseType === "array") {
                  return descend(type.child
              }
              if (type. === "address") {
              }
          };
  
          const descend = function (inputs: Array<ParamType>, values: ReadonlyArray<any>) {
              if (inputs.length !== values.length) { throw new Error("length mismatch"); }
              
          };
  
          const result: Array<any> = [ ];
          values.forEach((value, index) => {
              if (value == null) {
                  topics.push(null);
              } else if (param.baseType === "array" || param.baseType === "tuple") {
                  logger.throwArgumentError("filtering with tuples or arrays not supported", ("contract." + param.name), value);
              } else if (Array.isArray(value)) {
                  topics.push(value.map((value) => encodeTopic(param, value)));
              } else {
                  topics.push(encodeTopic(param, value));
              }
          });
      }
  */
  // Create the filter for the event with search criteria (e.g. for eth_filterLog)
  encodeFilterTopics(fragment, values) {
    if (typeof fragment === "string") {
      const f2 = this.getEvent(fragment);
      assertArgument(f2, "unknown event", "eventFragment", fragment);
      fragment = f2;
    }
    assert(values.length <= fragment.inputs.length, `too many arguments for ${fragment.format()}`, "UNEXPECTED_ARGUMENT", { count: values.length, expectedCount: fragment.inputs.length });
    const topics = [];
    if (!fragment.anonymous) {
      topics.push(fragment.topicHash);
    }
    const encodeTopic = (param, value) => {
      if (param.type === "string") {
        return id(value);
      } else if (param.type === "bytes") {
        return keccak256(hexlify(value));
      }
      if (param.type === "bool" && typeof value === "boolean") {
        value = value ? "0x01" : "0x00";
      } else if (param.type.match(/^u?int/)) {
        value = toBeHex(value);
      } else if (param.type.match(/^bytes/)) {
        value = zeroPadBytes(value, 32);
      } else if (param.type === "address") {
        __privateGet(this, _abiCoder).encode(["address"], [value]);
      }
      return zeroPadValue(hexlify(value), 32);
    };
    values.forEach((value, index) => {
      const param = fragment.inputs[index];
      if (!param.indexed) {
        assertArgument(value == null, "cannot filter non-indexed parameters; must be null", "contract." + param.name, value);
        return;
      }
      if (value == null) {
        topics.push(null);
      } else if (param.baseType === "array" || param.baseType === "tuple") {
        assertArgument(false, "filtering with tuples or arrays not supported", "contract." + param.name, value);
      } else if (Array.isArray(value)) {
        topics.push(value.map((value2) => encodeTopic(param, value2)));
      } else {
        topics.push(encodeTopic(param, value));
      }
    });
    while (topics.length && topics[topics.length - 1] === null) {
      topics.pop();
    }
    return topics;
  }
  encodeEventLog(fragment, values) {
    if (typeof fragment === "string") {
      const f2 = this.getEvent(fragment);
      assertArgument(f2, "unknown event", "eventFragment", fragment);
      fragment = f2;
    }
    const topics = [];
    const dataTypes = [];
    const dataValues = [];
    if (!fragment.anonymous) {
      topics.push(fragment.topicHash);
    }
    assertArgument(values.length === fragment.inputs.length, "event arguments/values mismatch", "values", values);
    fragment.inputs.forEach((param, index) => {
      const value = values[index];
      if (param.indexed) {
        if (param.type === "string") {
          topics.push(id(value));
        } else if (param.type === "bytes") {
          topics.push(keccak256(value));
        } else if (param.baseType === "tuple" || param.baseType === "array") {
          throw new Error("not implemented");
        } else {
          topics.push(__privateGet(this, _abiCoder).encode([param.type], [value]));
        }
      } else {
        dataTypes.push(param);
        dataValues.push(value);
      }
    });
    return {
      data: __privateGet(this, _abiCoder).encode(dataTypes, dataValues),
      topics
    };
  }
  // Decode a filter for the event and the search criteria
  decodeEventLog(fragment, data, topics) {
    if (typeof fragment === "string") {
      const f2 = this.getEvent(fragment);
      assertArgument(f2, "unknown event", "eventFragment", fragment);
      fragment = f2;
    }
    if (topics != null && !fragment.anonymous) {
      const eventTopic = fragment.topicHash;
      assertArgument(isHexString(topics[0], 32) && topics[0].toLowerCase() === eventTopic, "fragment/topic mismatch", "topics[0]", topics[0]);
      topics = topics.slice(1);
    }
    const indexed = [];
    const nonIndexed = [];
    const dynamic = [];
    fragment.inputs.forEach((param, index) => {
      if (param.indexed) {
        if (param.type === "string" || param.type === "bytes" || param.baseType === "tuple" || param.baseType === "array") {
          indexed.push(ParamType.from({ type: "bytes32", name: param.name }));
          dynamic.push(true);
        } else {
          indexed.push(param);
          dynamic.push(false);
        }
      } else {
        nonIndexed.push(param);
        dynamic.push(false);
      }
    });
    const resultIndexed = topics != null ? __privateGet(this, _abiCoder).decode(indexed, concat(topics)) : null;
    const resultNonIndexed = __privateGet(this, _abiCoder).decode(nonIndexed, data, true);
    const values = [];
    const keys = [];
    let nonIndexedIndex = 0, indexedIndex = 0;
    fragment.inputs.forEach((param, index) => {
      let value = null;
      if (param.indexed) {
        if (resultIndexed == null) {
          value = new Indexed(null);
        } else if (dynamic[index]) {
          value = new Indexed(resultIndexed[indexedIndex++]);
        } else {
          try {
            value = resultIndexed[indexedIndex++];
          } catch (error) {
            value = error;
          }
        }
      } else {
        try {
          value = resultNonIndexed[nonIndexedIndex++];
        } catch (error) {
          value = error;
        }
      }
      values.push(value);
      keys.push(param.name || null);
    });
    return Result.fromItems(values, keys);
  }
  /**
   *  Parses a transaction, finding the matching function and extracts
   *  the parameter values along with other useful function details.
   *
   *  If the matching function cannot be found, return null.
   */
  parseTransaction(tx) {
    const data = getBytes(tx.data, "tx.data");
    const value = getBigInt(tx.value != null ? tx.value : 0, "tx.value");
    const fragment = this.getFunction(hexlify(data.slice(0, 4)));
    if (!fragment) {
      return null;
    }
    const args = __privateGet(this, _abiCoder).decode(fragment.inputs, data.slice(4));
    return new TransactionDescription(fragment, fragment.selector, args, value);
  }
  parseCallResult(data) {
    throw new Error("@TODO");
  }
  /**
   *  Parses a receipt log, finding the matching event and extracts
   *  the parameter values along with other useful event details.
   *
   *  If the matching event cannot be found, returns null.
   */
  parseLog(log) {
    const fragment = this.getEvent(log.topics[0]);
    if (!fragment || fragment.anonymous) {
      return null;
    }
    return new LogDescription(fragment, fragment.topicHash, this.decodeEventLog(fragment, log.data, log.topics));
  }
  /**
   *  Parses a revert data, finding the matching error and extracts
   *  the parameter values along with other useful error details.
   *
   *  If the matching error cannot be found, returns null.
   */
  parseError(data) {
    const hexData = hexlify(data);
    const fragment = this.getError(dataSlice(hexData, 0, 4));
    if (!fragment) {
      return null;
    }
    const args = __privateGet(this, _abiCoder).decode(fragment.inputs, dataSlice(hexData, 4));
    return new ErrorDescription(fragment, fragment.selector, args);
  }
  /**
   *  Creates a new [[Interface]] from the ABI %%value%%.
   *
   *  The %%value%% may be provided as an existing [[Interface]] object,
   *  a JSON-encoded ABI or any Human-Readable ABI format.
   */
  static from(value) {
    if (value instanceof _Interface) {
      return value;
    }
    if (typeof value === "string") {
      return new _Interface(JSON.parse(value));
    }
    if (typeof value.formatJson === "function") {
      return new _Interface(value.formatJson());
    }
    if (typeof value.format === "function") {
      return new _Interface(value.format("json"));
    }
    return new _Interface(value);
  }
};
_errors = new WeakMap();
_events = new WeakMap();
_functions = new WeakMap();
_abiCoder = new WeakMap();
_Interface_instances = new WeakSet();
// Find a function definition by any means necessary (unless it is ambiguous)
getFunction_fn = function(key, values, forceUnique) {
  if (isHexString(key)) {
    const selector = key.toLowerCase();
    for (const fragment of __privateGet(this, _functions).values()) {
      if (selector === fragment.selector) {
        return fragment;
      }
    }
    return null;
  }
  if (key.indexOf("(") === -1) {
    const matching = [];
    for (const [name, fragment] of __privateGet(this, _functions)) {
      if (name.split(
        "("
        /* fix:) */
      )[0] === key) {
        matching.push(fragment);
      }
    }
    if (values) {
      const lastValue = values.length > 0 ? values[values.length - 1] : null;
      let valueLength = values.length;
      let allowOptions = true;
      if (Typed.isTyped(lastValue) && lastValue.type === "overrides") {
        allowOptions = false;
        valueLength--;
      }
      for (let i = matching.length - 1; i >= 0; i--) {
        const inputs = matching[i].inputs.length;
        if (inputs !== valueLength && (!allowOptions || inputs !== valueLength - 1)) {
          matching.splice(i, 1);
        }
      }
      for (let i = matching.length - 1; i >= 0; i--) {
        const inputs = matching[i].inputs;
        for (let j2 = 0; j2 < values.length; j2++) {
          if (!Typed.isTyped(values[j2])) {
            continue;
          }
          if (j2 >= inputs.length) {
            if (values[j2].type === "overrides") {
              continue;
            }
            matching.splice(i, 1);
            break;
          }
          if (values[j2].type !== inputs[j2].baseType) {
            matching.splice(i, 1);
            break;
          }
        }
      }
    }
    if (matching.length === 1 && values && values.length !== matching[0].inputs.length) {
      const lastArg = values[values.length - 1];
      if (lastArg == null || Array.isArray(lastArg) || typeof lastArg !== "object") {
        matching.splice(0, 1);
      }
    }
    if (matching.length === 0) {
      return null;
    }
    if (matching.length > 1 && forceUnique) {
      const matchStr = matching.map((m2) => JSON.stringify(m2.format())).join(", ");
      assertArgument(false, `ambiguous function description (i.e. matches ${matchStr})`, "key", key);
    }
    return matching[0];
  }
  const result = __privateGet(this, _functions).get(FunctionFragment.from(key).format());
  if (result) {
    return result;
  }
  return null;
};
// Find an event definition by any means necessary (unless it is ambiguous)
getEvent_fn = function(key, values, forceUnique) {
  if (isHexString(key)) {
    const eventTopic = key.toLowerCase();
    for (const fragment of __privateGet(this, _events).values()) {
      if (eventTopic === fragment.topicHash) {
        return fragment;
      }
    }
    return null;
  }
  if (key.indexOf("(") === -1) {
    const matching = [];
    for (const [name, fragment] of __privateGet(this, _events)) {
      if (name.split(
        "("
        /* fix:) */
      )[0] === key) {
        matching.push(fragment);
      }
    }
    if (values) {
      for (let i = matching.length - 1; i >= 0; i--) {
        if (matching[i].inputs.length < values.length) {
          matching.splice(i, 1);
        }
      }
      for (let i = matching.length - 1; i >= 0; i--) {
        const inputs = matching[i].inputs;
        for (let j2 = 0; j2 < values.length; j2++) {
          if (!Typed.isTyped(values[j2])) {
            continue;
          }
          if (values[j2].type !== inputs[j2].baseType) {
            matching.splice(i, 1);
            break;
          }
        }
      }
    }
    if (matching.length === 0) {
      return null;
    }
    if (matching.length > 1 && forceUnique) {
      const matchStr = matching.map((m2) => JSON.stringify(m2.format())).join(", ");
      assertArgument(false, `ambiguous event description (i.e. matches ${matchStr})`, "key", key);
    }
    return matching[0];
  }
  const result = __privateGet(this, _events).get(EventFragment.from(key).format());
  if (result) {
    return result;
  }
  return null;
};
let Interface = _Interface;
const BN_0$2 = BigInt(0);
function getValue(value) {
  if (value == null) {
    return null;
  }
  return value;
}
function toJson(value) {
  if (value == null) {
    return null;
  }
  return value.toString();
}
class FeeData {
  /**
   *  Creates a new FeeData for %%gasPrice%%, %%maxFeePerGas%% and
   *  %%maxPriorityFeePerGas%%.
   */
  constructor(gasPrice, maxFeePerGas, maxPriorityFeePerGas) {
    /**
     *  The gas price for legacy networks.
     */
    __publicField(this, "gasPrice");
    /**
     *  The maximum fee to pay per gas.
     *
     *  The base fee per gas is defined by the network and based on
     *  congestion, increasing the cost during times of heavy load
     *  and lowering when less busy.
     *
     *  The actual fee per gas will be the base fee for the block
     *  and the priority fee, up to the max fee per gas.
     *
     *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))
     */
    __publicField(this, "maxFeePerGas");
    /**
     *  The additional amout to pay per gas to encourage a validator
     *  to include the transaction.
     *
     *  The purpose of this is to compensate the validator for the
     *  adjusted risk for including a given transaction.
     *
     *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))
     */
    __publicField(this, "maxPriorityFeePerGas");
    defineProperties(this, {
      gasPrice: getValue(gasPrice),
      maxFeePerGas: getValue(maxFeePerGas),
      maxPriorityFeePerGas: getValue(maxPriorityFeePerGas)
    });
  }
  /**
   *  Returns a JSON-friendly value.
   */
  toJSON() {
    const { gasPrice, maxFeePerGas, maxPriorityFeePerGas } = this;
    return {
      _type: "FeeData",
      gasPrice: toJson(gasPrice),
      maxFeePerGas: toJson(maxFeePerGas),
      maxPriorityFeePerGas: toJson(maxPriorityFeePerGas)
    };
  }
}
function copyRequest(req) {
  const result = {};
  if (req.to) {
    result.to = req.to;
  }
  if (req.from) {
    result.from = req.from;
  }
  if (req.data) {
    result.data = hexlify(req.data);
  }
  const bigIntKeys = "chainId,gasLimit,gasPrice,maxFeePerBlobGas,maxFeePerGas,maxPriorityFeePerGas,value".split(/,/);
  for (const key of bigIntKeys) {
    if (!(key in req) || req[key] == null) {
      continue;
    }
    result[key] = getBigInt(req[key], `request.${key}`);
  }
  const numberKeys = "type,nonce".split(/,/);
  for (const key of numberKeys) {
    if (!(key in req) || req[key] == null) {
      continue;
    }
    result[key] = getNumber(req[key], `request.${key}`);
  }
  if (req.accessList) {
    result.accessList = accessListify(req.accessList);
  }
  if ("blockTag" in req) {
    result.blockTag = req.blockTag;
  }
  if ("enableCcipRead" in req) {
    result.enableCcipRead = !!req.enableCcipRead;
  }
  if ("customData" in req) {
    result.customData = req.customData;
  }
  if ("blobVersionedHashes" in req && req.blobVersionedHashes) {
    result.blobVersionedHashes = req.blobVersionedHashes.slice();
  }
  if ("kzg" in req) {
    result.kzg = req.kzg;
  }
  if ("blobs" in req && req.blobs) {
    result.blobs = req.blobs.map((b2) => {
      if (isBytesLike(b2)) {
        return hexlify(b2);
      }
      return Object.assign({}, b2);
    });
  }
  return result;
}
class Block {
  /**
   *  Create a new **Block** object.
   *
   *  This should generally not be necessary as the unless implementing a
   *  low-level library.
   */
  constructor(block, provider) {
    /**
     *  The provider connected to the block used to fetch additional details
     *  if necessary.
     */
    __publicField(this, "provider");
    /**
     *  The block number, sometimes called the block height. This is a
     *  sequential number that is one higher than the parent block.
     */
    __publicField(this, "number");
    /**
     *  The block hash.
     *
     *  This hash includes all properties, so can be safely used to identify
     *  an exact set of block properties.
     */
    __publicField(this, "hash");
    /**
     *  The timestamp for this block, which is the number of seconds since
     *  epoch that this block was included.
     */
    __publicField(this, "timestamp");
    /**
     *  The block hash of the parent block.
     */
    __publicField(this, "parentHash");
    /**
     *  The hash tree root of the parent beacon block for the given
     *  execution block. See [[link-eip-4788]].
     */
    __publicField(this, "parentBeaconBlockRoot");
    /**
     *  The nonce.
     *
     *  On legacy networks, this is the random number inserted which
     *  permitted the difficulty target to be reached.
     */
    __publicField(this, "nonce");
    /**
     *  The difficulty target.
     *
     *  On legacy networks, this is the proof-of-work target required
     *  for a block to meet the protocol rules to be included.
     *
     *  On modern networks, this is a random number arrived at using
     *  randao.  @TODO: Find links?
     */
    __publicField(this, "difficulty");
    /**
     *  The total gas limit for this block.
     */
    __publicField(this, "gasLimit");
    /**
     *  The total gas used in this block.
     */
    __publicField(this, "gasUsed");
    /**
     *  The root hash for the global state after applying changes
     *  in this block.
     */
    __publicField(this, "stateRoot");
    /**
     *  The hash of the transaction receipts trie.
     */
    __publicField(this, "receiptsRoot");
    /**
     *  The total amount of blob gas consumed by the transactions
     *  within the block. See [[link-eip-4844]].
     */
    __publicField(this, "blobGasUsed");
    /**
     *  The running total of blob gas consumed in excess of the
     *  target, prior to the block. See [[link-eip-4844]].
     */
    __publicField(this, "excessBlobGas");
    /**
     *  The miner coinbase address, wihch receives any subsidies for
     *  including this block.
     */
    __publicField(this, "miner");
    /**
     *  The latest RANDAO mix of the post beacon state of
     *  the previous block.
     */
    __publicField(this, "prevRandao");
    /**
     *  Any extra data the validator wished to include.
     */
    __publicField(this, "extraData");
    /**
     *  The base fee per gas that all transactions in this block were
     *  charged.
     *
     *  This adjusts after each block, depending on how congested the network
     *  is.
     */
    __publicField(this, "baseFeePerGas");
    __privateAdd(this, _transactions);
    __privateSet(this, _transactions, block.transactions.map((tx) => {
      if (typeof tx !== "string") {
        return new TransactionResponse(tx, provider);
      }
      return tx;
    }));
    defineProperties(this, {
      provider,
      hash: getValue(block.hash),
      number: block.number,
      timestamp: block.timestamp,
      parentHash: block.parentHash,
      parentBeaconBlockRoot: block.parentBeaconBlockRoot,
      nonce: block.nonce,
      difficulty: block.difficulty,
      gasLimit: block.gasLimit,
      gasUsed: block.gasUsed,
      blobGasUsed: block.blobGasUsed,
      excessBlobGas: block.excessBlobGas,
      miner: block.miner,
      prevRandao: getValue(block.prevRandao),
      extraData: block.extraData,
      baseFeePerGas: getValue(block.baseFeePerGas),
      stateRoot: block.stateRoot,
      receiptsRoot: block.receiptsRoot
    });
  }
  /**
   *  Returns the list of transaction hashes, in the order
   *  they were executed within the block.
   */
  get transactions() {
    return __privateGet(this, _transactions).map((tx) => {
      if (typeof tx === "string") {
        return tx;
      }
      return tx.hash;
    });
  }
  /**
   *  Returns the complete transactions, in the order they
   *  were executed within the block.
   *
   *  This is only available for blocks which prefetched
   *  transactions, by passing ``true`` to %%prefetchTxs%%
   *  into [[Provider-getBlock]].
   */
  get prefetchedTransactions() {
    const txs = __privateGet(this, _transactions).slice();
    if (txs.length === 0) {
      return [];
    }
    assert(typeof txs[0] === "object", "transactions were not prefetched with block request", "UNSUPPORTED_OPERATION", {
      operation: "transactionResponses()"
    });
    return txs;
  }
  /**
   *  Returns a JSON-friendly value.
   */
  toJSON() {
    const { baseFeePerGas, difficulty, extraData, gasLimit, gasUsed, hash, miner, prevRandao, nonce, number, parentHash, parentBeaconBlockRoot, stateRoot, receiptsRoot, timestamp, transactions } = this;
    return {
      _type: "Block",
      baseFeePerGas: toJson(baseFeePerGas),
      difficulty: toJson(difficulty),
      extraData,
      gasLimit: toJson(gasLimit),
      gasUsed: toJson(gasUsed),
      blobGasUsed: toJson(this.blobGasUsed),
      excessBlobGas: toJson(this.excessBlobGas),
      hash,
      miner,
      prevRandao,
      nonce,
      number,
      parentHash,
      timestamp,
      parentBeaconBlockRoot,
      stateRoot,
      receiptsRoot,
      transactions
    };
  }
  [Symbol.iterator]() {
    let index = 0;
    const txs = this.transactions;
    return {
      next: () => {
        if (index < this.length) {
          return {
            value: txs[index++],
            done: false
          };
        }
        return { value: void 0, done: true };
      }
    };
  }
  /**
   *  The number of transactions in this block.
   */
  get length() {
    return __privateGet(this, _transactions).length;
  }
  /**
   *  The [[link-js-date]] this block was included at.
   */
  get date() {
    if (this.timestamp == null) {
      return null;
    }
    return new Date(this.timestamp * 1e3);
  }
  /**
   *  Get the transaction at %%indexe%% within this block.
   */
  async getTransaction(indexOrHash) {
    let tx = void 0;
    if (typeof indexOrHash === "number") {
      tx = __privateGet(this, _transactions)[indexOrHash];
    } else {
      const hash = indexOrHash.toLowerCase();
      for (const v2 of __privateGet(this, _transactions)) {
        if (typeof v2 === "string") {
          if (v2 !== hash) {
            continue;
          }
          tx = v2;
          break;
        } else {
          if (v2.hash !== hash) {
            continue;
          }
          tx = v2;
          break;
        }
      }
    }
    if (tx == null) {
      throw new Error("no such tx");
    }
    if (typeof tx === "string") {
      return await this.provider.getTransaction(tx);
    } else {
      return tx;
    }
  }
  /**
   *  If a **Block** was fetched with a request to include the transactions
   *  this will allow synchronous access to those transactions.
   *
   *  If the transactions were not prefetched, this will throw.
   */
  getPrefetchedTransaction(indexOrHash) {
    const txs = this.prefetchedTransactions;
    if (typeof indexOrHash === "number") {
      return txs[indexOrHash];
    }
    indexOrHash = indexOrHash.toLowerCase();
    for (const tx of txs) {
      if (tx.hash === indexOrHash) {
        return tx;
      }
    }
    assertArgument(false, "no matching transaction", "indexOrHash", indexOrHash);
  }
  /**
   *  Returns true if this block been mined. This provides a type guard
   *  for all properties on a [[MinedBlock]].
   */
  isMined() {
    return !!this.hash;
  }
  /**
   *  Returns true if this block is an [[link-eip-2930]] block.
   */
  isLondon() {
    return !!this.baseFeePerGas;
  }
  /**
   *  @_ignore:
   */
  orphanedEvent() {
    if (!this.isMined()) {
      throw new Error("");
    }
    return createOrphanedBlockFilter(this);
  }
}
_transactions = new WeakMap();
class Log {
  /**
   *  @_ignore:
   */
  constructor(log, provider) {
    /**
     *  The provider connected to the log used to fetch additional details
     *  if necessary.
     */
    __publicField(this, "provider");
    /**
     *  The transaction hash of the transaction this log occurred in. Use the
     *  [[Log-getTransaction]] to get the [[TransactionResponse]].
     */
    __publicField(this, "transactionHash");
    /**
     *  The block hash of the block this log occurred in. Use the
     *  [[Log-getBlock]] to get the [[Block]].
     */
    __publicField(this, "blockHash");
    /**
     *  The block number of the block this log occurred in. It is preferred
     *  to use the [[Block-hash]] when fetching the related [[Block]],
     *  since in the case of an orphaned block, the block at that height may
     *  have changed.
     */
    __publicField(this, "blockNumber");
    /**
     *  If the **Log** represents a block that was removed due to an orphaned
     *  block, this will be true.
     *
     *  This can only happen within an orphan event listener.
     */
    __publicField(this, "removed");
    /**
     *  The address of the contract that emitted this log.
     */
    __publicField(this, "address");
    /**
     *  The data included in this log when it was emitted.
     */
    __publicField(this, "data");
    /**
     *  The indexed topics included in this log when it was emitted.
     *
     *  All topics are included in the bloom filters, so they can be
     *  efficiently filtered using the [[Provider-getLogs]] method.
     */
    __publicField(this, "topics");
    /**
     *  The index within the block this log occurred at. This is generally
     *  not useful to developers, but can be used with the various roots
     *  to proof inclusion within a block.
     */
    __publicField(this, "index");
    /**
     *  The index within the transaction of this log.
     */
    __publicField(this, "transactionIndex");
    this.provider = provider;
    const topics = Object.freeze(log.topics.slice());
    defineProperties(this, {
      transactionHash: log.transactionHash,
      blockHash: log.blockHash,
      blockNumber: log.blockNumber,
      removed: log.removed,
      address: log.address,
      data: log.data,
      topics,
      index: log.index,
      transactionIndex: log.transactionIndex
    });
  }
  /**
   *  Returns a JSON-compatible object.
   */
  toJSON() {
    const { address, blockHash, blockNumber, data, index, removed, topics, transactionHash, transactionIndex } = this;
    return {
      _type: "log",
      address,
      blockHash,
      blockNumber,
      data,
      index,
      removed,
      topics,
      transactionHash,
      transactionIndex
    };
  }
  /**
   *  Returns the block that this log occurred in.
   */
  async getBlock() {
    const block = await this.provider.getBlock(this.blockHash);
    assert(!!block, "failed to find transaction", "UNKNOWN_ERROR", {});
    return block;
  }
  /**
   *  Returns the transaction that this log occurred in.
   */
  async getTransaction() {
    const tx = await this.provider.getTransaction(this.transactionHash);
    assert(!!tx, "failed to find transaction", "UNKNOWN_ERROR", {});
    return tx;
  }
  /**
   *  Returns the transaction receipt fot the transaction that this
   *  log occurred in.
   */
  async getTransactionReceipt() {
    const receipt = await this.provider.getTransactionReceipt(this.transactionHash);
    assert(!!receipt, "failed to find transaction receipt", "UNKNOWN_ERROR", {});
    return receipt;
  }
  /**
   *  @_ignore:
   */
  removedEvent() {
    return createRemovedLogFilter(this);
  }
}
class TransactionReceipt {
  /**
   *  @_ignore:
   */
  constructor(tx, provider) {
    /**
     *  The provider connected to the log used to fetch additional details
     *  if necessary.
     */
    __publicField(this, "provider");
    /**
     *  The address the transaction was sent to.
     */
    __publicField(this, "to");
    /**
     *  The sender of the transaction.
     */
    __publicField(this, "from");
    /**
     *  The address of the contract if the transaction was directly
     *  responsible for deploying one.
     *
     *  This is non-null **only** if the ``to`` is empty and the ``data``
     *  was successfully executed as initcode.
     */
    __publicField(this, "contractAddress");
    /**
     *  The transaction hash.
     */
    __publicField(this, "hash");
    /**
     *  The index of this transaction within the block transactions.
     */
    __publicField(this, "index");
    /**
     *  The block hash of the [[Block]] this transaction was included in.
     */
    __publicField(this, "blockHash");
    /**
     *  The block number of the [[Block]] this transaction was included in.
     */
    __publicField(this, "blockNumber");
    /**
     *  The bloom filter bytes that represent all logs that occurred within
     *  this transaction. This is generally not useful for most developers,
     *  but can be used to validate the included logs.
     */
    __publicField(this, "logsBloom");
    /**
     *  The actual amount of gas used by this transaction.
     *
     *  When creating a transaction, the amount of gas that will be used can
     *  only be approximated, but the sender must pay the gas fee for the
     *  entire gas limit. After the transaction, the difference is refunded.
     */
    __publicField(this, "gasUsed");
    /**
     *  The gas used for BLObs. See [[link-eip-4844]].
     */
    __publicField(this, "blobGasUsed");
    /**
     *  The amount of gas used by all transactions within the block for this
     *  and all transactions with a lower ``index``.
     *
     *  This is generally not useful for developers but can be used to
     *  validate certain aspects of execution.
     */
    __publicField(this, "cumulativeGasUsed");
    /**
     *  The actual gas price used during execution.
     *
     *  Due to the complexity of [[link-eip-1559]] this value can only
     *  be caluclated after the transaction has been mined, snce the base
     *  fee is protocol-enforced.
     */
    __publicField(this, "gasPrice");
    /**
     *  The price paid per BLOB in gas. See [[link-eip-4844]].
     */
    __publicField(this, "blobGasPrice");
    /**
     *  The [[link-eip-2718]] transaction type.
     */
    __publicField(this, "type");
    //readonly byzantium!: boolean;
    /**
     *  The status of this transaction, indicating success (i.e. ``1``) or
     *  a revert (i.e. ``0``).
     *
     *  This is available in post-byzantium blocks, but some backends may
     *  backfill this value.
     */
    __publicField(this, "status");
    /**
     *  The root hash of this transaction.
     *
     *  This is no present and was only included in pre-byzantium blocks, but
     *  could be used to validate certain parts of the receipt.
     */
    __publicField(this, "root");
    __privateAdd(this, _logs);
    __privateSet(this, _logs, Object.freeze(tx.logs.map((log) => {
      return new Log(log, provider);
    })));
    let gasPrice = BN_0$2;
    if (tx.effectiveGasPrice != null) {
      gasPrice = tx.effectiveGasPrice;
    } else if (tx.gasPrice != null) {
      gasPrice = tx.gasPrice;
    }
    defineProperties(this, {
      provider,
      to: tx.to,
      from: tx.from,
      contractAddress: tx.contractAddress,
      hash: tx.hash,
      index: tx.index,
      blockHash: tx.blockHash,
      blockNumber: tx.blockNumber,
      logsBloom: tx.logsBloom,
      gasUsed: tx.gasUsed,
      cumulativeGasUsed: tx.cumulativeGasUsed,
      blobGasUsed: tx.blobGasUsed,
      gasPrice,
      blobGasPrice: tx.blobGasPrice,
      type: tx.type,
      //byzantium: tx.byzantium,
      status: tx.status,
      root: tx.root
    });
  }
  /**
   *  The logs for this transaction.
   */
  get logs() {
    return __privateGet(this, _logs);
  }
  /**
   *  Returns a JSON-compatible representation.
   */
  toJSON() {
    const {
      to: to2,
      from,
      contractAddress,
      hash,
      index,
      blockHash,
      blockNumber,
      logsBloom,
      logs,
      //byzantium, 
      status,
      root
    } = this;
    return {
      _type: "TransactionReceipt",
      blockHash,
      blockNumber,
      //byzantium, 
      contractAddress,
      cumulativeGasUsed: toJson(this.cumulativeGasUsed),
      from,
      gasPrice: toJson(this.gasPrice),
      blobGasUsed: toJson(this.blobGasUsed),
      blobGasPrice: toJson(this.blobGasPrice),
      gasUsed: toJson(this.gasUsed),
      hash,
      index,
      logs,
      logsBloom,
      root,
      status,
      to: to2
    };
  }
  /**
   *  @_ignore:
   */
  get length() {
    return this.logs.length;
  }
  [Symbol.iterator]() {
    let index = 0;
    return {
      next: () => {
        if (index < this.length) {
          return { value: this.logs[index++], done: false };
        }
        return { value: void 0, done: true };
      }
    };
  }
  /**
   *  The total fee for this transaction, in wei.
   */
  get fee() {
    return this.gasUsed * this.gasPrice;
  }
  /**
   *  Resolves to the block this transaction occurred in.
   */
  async getBlock() {
    const block = await this.provider.getBlock(this.blockHash);
    if (block == null) {
      throw new Error("TODO");
    }
    return block;
  }
  /**
   *  Resolves to the transaction this transaction occurred in.
   */
  async getTransaction() {
    const tx = await this.provider.getTransaction(this.hash);
    if (tx == null) {
      throw new Error("TODO");
    }
    return tx;
  }
  /**
   *  Resolves to the return value of the execution of this transaction.
   *
   *  Support for this feature is limited, as it requires an archive node
   *  with the ``debug_`` or ``trace_`` API enabled.
   */
  async getResult() {
    return await this.provider.getTransactionResult(this.hash);
  }
  /**
   *  Resolves to the number of confirmations this transaction has.
   */
  async confirmations() {
    return await this.provider.getBlockNumber() - this.blockNumber + 1;
  }
  /**
   *  @_ignore:
   */
  removedEvent() {
    return createRemovedTransactionFilter(this);
  }
  /**
   *  @_ignore:
   */
  reorderedEvent(other) {
    assert(!other || other.isMined(), "unmined 'other' transction cannot be orphaned", "UNSUPPORTED_OPERATION", { operation: "reorderedEvent(other)" });
    return createReorderedTransactionFilter(this, other);
  }
}
_logs = new WeakMap();
const _TransactionResponse = class _TransactionResponse {
  /**
   *  @_ignore:
   */
  constructor(tx, provider) {
    /**
     *  The provider this is connected to, which will influence how its
     *  methods will resolve its async inspection methods.
     */
    __publicField(this, "provider");
    /**
     *  The block number of the block that this transaction was included in.
     *
     *  This is ``null`` for pending transactions.
     */
    __publicField(this, "blockNumber");
    /**
     *  The blockHash of the block that this transaction was included in.
     *
     *  This is ``null`` for pending transactions.
     */
    __publicField(this, "blockHash");
    /**
     *  The index within the block that this transaction resides at.
     */
    __publicField(this, "index");
    /**
     *  The transaction hash.
     */
    __publicField(this, "hash");
    /**
     *  The [[link-eip-2718]] transaction envelope type. This is
     *  ``0`` for legacy transactions types.
     */
    __publicField(this, "type");
    /**
     *  The receiver of this transaction.
     *
     *  If ``null``, then the transaction is an initcode transaction.
     *  This means the result of executing the [[data]] will be deployed
     *  as a new contract on chain (assuming it does not revert) and the
     *  address may be computed using [[getCreateAddress]].
     */
    __publicField(this, "to");
    /**
     *  The sender of this transaction. It is implicitly computed
     *  from the transaction pre-image hash (as the digest) and the
     *  [[signature]] using ecrecover.
     */
    __publicField(this, "from");
    /**
     *  The nonce, which is used to prevent replay attacks and offer
     *  a method to ensure transactions from a given sender are explicitly
     *  ordered.
     *
     *  When sending a transaction, this must be equal to the number of
     *  transactions ever sent by [[from]].
     */
    __publicField(this, "nonce");
    /**
     *  The maximum units of gas this transaction can consume. If execution
     *  exceeds this, the entries transaction is reverted and the sender
     *  is charged for the full amount, despite not state changes being made.
     */
    __publicField(this, "gasLimit");
    /**
     *  The gas price can have various values, depending on the network.
     *
     *  In modern networks, for transactions that are included this is
     *  the //effective gas price// (the fee per gas that was actually
     *  charged), while for transactions that have not been included yet
     *  is the [[maxFeePerGas]].
     *
     *  For legacy transactions, or transactions on legacy networks, this
     *  is the fee that will be charged per unit of gas the transaction
     *  consumes.
     */
    __publicField(this, "gasPrice");
    /**
     *  The maximum priority fee (per unit of gas) to allow a
     *  validator to charge the sender. This is inclusive of the
     *  [[maxFeeFeePerGas]].
     */
    __publicField(this, "maxPriorityFeePerGas");
    /**
     *  The maximum fee (per unit of gas) to allow this transaction
     *  to charge the sender.
     */
    __publicField(this, "maxFeePerGas");
    /**
     *  The [[link-eip-4844]] max fee per BLOb gas.
     */
    __publicField(this, "maxFeePerBlobGas");
    /**
     *  The data.
     */
    __publicField(this, "data");
    /**
     *  The value, in wei. Use [[formatEther]] to format this value
     *  as ether.
     */
    __publicField(this, "value");
    /**
     *  The chain ID.
     */
    __publicField(this, "chainId");
    /**
     *  The signature.
     */
    __publicField(this, "signature");
    /**
     *  The [[link-eip-2930]] access list for transaction types that
     *  support it, otherwise ``null``.
     */
    __publicField(this, "accessList");
    /**
     *  The [[link-eip-4844]] BLOb versioned hashes.
     */
    __publicField(this, "blobVersionedHashes");
    __privateAdd(this, _startBlock);
    this.provider = provider;
    this.blockNumber = tx.blockNumber != null ? tx.blockNumber : null;
    this.blockHash = tx.blockHash != null ? tx.blockHash : null;
    this.hash = tx.hash;
    this.index = tx.index;
    this.type = tx.type;
    this.from = tx.from;
    this.to = tx.to || null;
    this.gasLimit = tx.gasLimit;
    this.nonce = tx.nonce;
    this.data = tx.data;
    this.value = tx.value;
    this.gasPrice = tx.gasPrice;
    this.maxPriorityFeePerGas = tx.maxPriorityFeePerGas != null ? tx.maxPriorityFeePerGas : null;
    this.maxFeePerGas = tx.maxFeePerGas != null ? tx.maxFeePerGas : null;
    this.maxFeePerBlobGas = tx.maxFeePerBlobGas != null ? tx.maxFeePerBlobGas : null;
    this.chainId = tx.chainId;
    this.signature = tx.signature;
    this.accessList = tx.accessList != null ? tx.accessList : null;
    this.blobVersionedHashes = tx.blobVersionedHashes != null ? tx.blobVersionedHashes : null;
    __privateSet(this, _startBlock, -1);
  }
  /**
   *  Returns a JSON-compatible representation of this transaction.
   */
  toJSON() {
    const { blockNumber, blockHash, index, hash, type, to: to2, from, nonce, data, signature, accessList, blobVersionedHashes } = this;
    return {
      _type: "TransactionResponse",
      accessList,
      blockNumber,
      blockHash,
      blobVersionedHashes,
      chainId: toJson(this.chainId),
      data,
      from,
      gasLimit: toJson(this.gasLimit),
      gasPrice: toJson(this.gasPrice),
      hash,
      maxFeePerGas: toJson(this.maxFeePerGas),
      maxPriorityFeePerGas: toJson(this.maxPriorityFeePerGas),
      maxFeePerBlobGas: toJson(this.maxFeePerBlobGas),
      nonce,
      signature,
      to: to2,
      index,
      type,
      value: toJson(this.value)
    };
  }
  /**
   *  Resolves to the Block that this transaction was included in.
   *
   *  This will return null if the transaction has not been included yet.
   */
  async getBlock() {
    let blockNumber = this.blockNumber;
    if (blockNumber == null) {
      const tx = await this.getTransaction();
      if (tx) {
        blockNumber = tx.blockNumber;
      }
    }
    if (blockNumber == null) {
      return null;
    }
    const block = this.provider.getBlock(blockNumber);
    if (block == null) {
      throw new Error("TODO");
    }
    return block;
  }
  /**
   *  Resolves to this transaction being re-requested from the
   *  provider. This can be used if you have an unmined transaction
   *  and wish to get an up-to-date populated instance.
   */
  async getTransaction() {
    return this.provider.getTransaction(this.hash);
  }
  /**
   *  Resolve to the number of confirmations this transaction has.
   */
  async confirmations() {
    if (this.blockNumber == null) {
      const { tx, blockNumber: blockNumber2 } = await resolveProperties({
        tx: this.getTransaction(),
        blockNumber: this.provider.getBlockNumber()
      });
      if (tx == null || tx.blockNumber == null) {
        return 0;
      }
      return blockNumber2 - tx.blockNumber + 1;
    }
    const blockNumber = await this.provider.getBlockNumber();
    return blockNumber - this.blockNumber + 1;
  }
  /**
   *  Resolves once this transaction has been mined and has
   *  %%confirms%% blocks including it (default: ``1``) with an
   *  optional %%timeout%%.
   *
   *  This can resolve to ``null`` only if %%confirms%% is ``0``
   *  and the transaction has not been mined, otherwise this will
   *  wait until enough confirmations have completed.
   */
  async wait(_confirms, _timeout2) {
    const confirms = _confirms == null ? 1 : _confirms;
    const timeout = _timeout2 == null ? 0 : _timeout2;
    let startBlock = __privateGet(this, _startBlock);
    let nextScan = -1;
    let stopScanning = startBlock === -1 ? true : false;
    const checkReplacement = async () => {
      if (stopScanning) {
        return null;
      }
      const { blockNumber, nonce } = await resolveProperties({
        blockNumber: this.provider.getBlockNumber(),
        nonce: this.provider.getTransactionCount(this.from)
      });
      if (nonce < this.nonce) {
        startBlock = blockNumber;
        return;
      }
      if (stopScanning) {
        return null;
      }
      const mined = await this.getTransaction();
      if (mined && mined.blockNumber != null) {
        return;
      }
      if (nextScan === -1) {
        nextScan = startBlock - 3;
        if (nextScan < __privateGet(this, _startBlock)) {
          nextScan = __privateGet(this, _startBlock);
        }
      }
      while (nextScan <= blockNumber) {
        if (stopScanning) {
          return null;
        }
        const block = await this.provider.getBlock(nextScan, true);
        if (block == null) {
          return;
        }
        for (const hash of block) {
          if (hash === this.hash) {
            return;
          }
        }
        for (let i = 0; i < block.length; i++) {
          const tx = await block.getTransaction(i);
          if (tx.from === this.from && tx.nonce === this.nonce) {
            if (stopScanning) {
              return null;
            }
            const receipt2 = await this.provider.getTransactionReceipt(tx.hash);
            if (receipt2 == null) {
              return;
            }
            if (blockNumber - receipt2.blockNumber + 1 < confirms) {
              return;
            }
            let reason = "replaced";
            if (tx.data === this.data && tx.to === this.to && tx.value === this.value) {
              reason = "repriced";
            } else if (tx.data === "0x" && tx.from === tx.to && tx.value === BN_0$2) {
              reason = "cancelled";
            }
            assert(false, "transaction was replaced", "TRANSACTION_REPLACED", {
              cancelled: reason === "replaced" || reason === "cancelled",
              reason,
              replacement: tx.replaceableTransaction(startBlock),
              hash: tx.hash,
              receipt: receipt2
            });
          }
        }
        nextScan++;
      }
      return;
    };
    const checkReceipt = (receipt2) => {
      if (receipt2 == null || receipt2.status !== 0) {
        return receipt2;
      }
      assert(false, "transaction execution reverted", "CALL_EXCEPTION", {
        action: "sendTransaction",
        data: null,
        reason: null,
        invocation: null,
        revert: null,
        transaction: {
          to: receipt2.to,
          from: receipt2.from,
          data: ""
          // @TODO: in v7, split out sendTransaction properties
        },
        receipt: receipt2
      });
    };
    const receipt = await this.provider.getTransactionReceipt(this.hash);
    if (confirms === 0) {
      return checkReceipt(receipt);
    }
    if (receipt) {
      if (await receipt.confirmations() >= confirms) {
        return checkReceipt(receipt);
      }
    } else {
      await checkReplacement();
      if (confirms === 0) {
        return null;
      }
    }
    const waiter = new Promise((resolve, reject) => {
      const cancellers = [];
      const cancel = () => {
        cancellers.forEach((c2) => c2());
      };
      cancellers.push(() => {
        stopScanning = true;
      });
      if (timeout > 0) {
        const timer = setTimeout(() => {
          cancel();
          reject(makeError("wait for transaction timeout", "TIMEOUT"));
        }, timeout);
        cancellers.push(() => {
          clearTimeout(timer);
        });
      }
      const txListener = async (receipt2) => {
        if (await receipt2.confirmations() >= confirms) {
          cancel();
          try {
            resolve(checkReceipt(receipt2));
          } catch (error) {
            reject(error);
          }
        }
      };
      cancellers.push(() => {
        this.provider.off(this.hash, txListener);
      });
      this.provider.on(this.hash, txListener);
      if (startBlock >= 0) {
        const replaceListener = async () => {
          try {
            await checkReplacement();
          } catch (error) {
            if (isError(error, "TRANSACTION_REPLACED")) {
              cancel();
              reject(error);
              return;
            }
          }
          if (!stopScanning) {
            this.provider.once("block", replaceListener);
          }
        };
        cancellers.push(() => {
          this.provider.off("block", replaceListener);
        });
        this.provider.once("block", replaceListener);
      }
    });
    return await waiter;
  }
  /**
   *  Returns ``true`` if this transaction has been included.
   *
   *  This is effective only as of the time the TransactionResponse
   *  was instantiated. To get up-to-date information, use
   *  [[getTransaction]].
   *
   *  This provides a Type Guard that this transaction will have
   *  non-null property values for properties that are null for
   *  unmined transactions.
   */
  isMined() {
    return this.blockHash != null;
  }
  /**
   *  Returns true if the transaction is a legacy (i.e. ``type == 0``)
   *  transaction.
   *
   *  This provides a Type Guard that this transaction will have
   *  the ``null``-ness for hardfork-specific properties set correctly.
   */
  isLegacy() {
    return this.type === 0;
  }
  /**
   *  Returns true if the transaction is a Berlin (i.e. ``type == 1``)
   *  transaction. See [[link-eip-2070]].
   *
   *  This provides a Type Guard that this transaction will have
   *  the ``null``-ness for hardfork-specific properties set correctly.
   */
  isBerlin() {
    return this.type === 1;
  }
  /**
   *  Returns true if the transaction is a London (i.e. ``type == 2``)
   *  transaction. See [[link-eip-1559]].
   *
   *  This provides a Type Guard that this transaction will have
   *  the ``null``-ness for hardfork-specific properties set correctly.
   */
  isLondon() {
    return this.type === 2;
  }
  /**
   *  Returns true if hte transaction is a Cancun (i.e. ``type == 3``)
   *  transaction. See [[link-eip-4844]].
   */
  isCancun() {
    return this.type === 3;
  }
  /**
   *  Returns a filter which can be used to listen for orphan events
   *  that evict this transaction.
   */
  removedEvent() {
    assert(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" });
    return createRemovedTransactionFilter(this);
  }
  /**
   *  Returns a filter which can be used to listen for orphan events
   *  that re-order this event against %%other%%.
   */
  reorderedEvent(other) {
    assert(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" });
    assert(!other || other.isMined(), "unmined 'other' transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" });
    return createReorderedTransactionFilter(this, other);
  }
  /**
   *  Returns a new TransactionResponse instance which has the ability to
   *  detect (and throw an error) if the transaction is replaced, which
   *  will begin scanning at %%startBlock%%.
   *
   *  This should generally not be used by developers and is intended
   *  primarily for internal use. Setting an incorrect %%startBlock%% can
   *  have devastating performance consequences if used incorrectly.
   */
  replaceableTransaction(startBlock) {
    assertArgument(Number.isInteger(startBlock) && startBlock >= 0, "invalid startBlock", "startBlock", startBlock);
    const tx = new _TransactionResponse(this, this.provider);
    __privateSet(tx, _startBlock, startBlock);
    return tx;
  }
};
_startBlock = new WeakMap();
let TransactionResponse = _TransactionResponse;
function createOrphanedBlockFilter(block) {
  return { orphan: "drop-block", hash: block.hash, number: block.number };
}
function createReorderedTransactionFilter(tx, other) {
  return { orphan: "reorder-transaction", tx, other };
}
function createRemovedTransactionFilter(tx) {
  return { orphan: "drop-transaction", tx };
}
function createRemovedLogFilter(log) {
  return { orphan: "drop-log", log: {
    transactionHash: log.transactionHash,
    blockHash: log.blockHash,
    blockNumber: log.blockNumber,
    address: log.address,
    data: log.data,
    topics: Object.freeze(log.topics.slice()),
    index: log.index
  } };
}
class EventLog extends Log {
  /**
   * @_ignore:
   */
  constructor(log, iface, fragment) {
    super(log, log.provider);
    /**
     *  The Contract Interface.
     */
    __publicField(this, "interface");
    /**
     *  The matching event.
     */
    __publicField(this, "fragment");
    /**
     *  The parsed arguments passed to the event by ``emit``.
     */
    __publicField(this, "args");
    const args = iface.decodeEventLog(fragment, log.data, log.topics);
    defineProperties(this, { args, fragment, interface: iface });
  }
  /**
   *  The name of the event.
   */
  get eventName() {
    return this.fragment.name;
  }
  /**
   *  The signature of the event.
   */
  get eventSignature() {
    return this.fragment.format();
  }
}
class UndecodedEventLog extends Log {
  /**
   * @_ignore:
   */
  constructor(log, error) {
    super(log, log.provider);
    /**
     *  The error encounted when trying to decode the log.
     */
    __publicField(this, "error");
    defineProperties(this, { error });
  }
}
class ContractTransactionReceipt extends TransactionReceipt {
  /**
   *  @_ignore:
   */
  constructor(iface, provider, tx) {
    super(tx, provider);
    __privateAdd(this, _iface);
    __privateSet(this, _iface, iface);
  }
  /**
   *  The parsed logs for any [[Log]] which has a matching event in the
   *  Contract ABI.
   */
  get logs() {
    return super.logs.map((log) => {
      const fragment = log.topics.length ? __privateGet(this, _iface).getEvent(log.topics[0]) : null;
      if (fragment) {
        try {
          return new EventLog(log, __privateGet(this, _iface), fragment);
        } catch (error) {
          return new UndecodedEventLog(log, error);
        }
      }
      return log;
    });
  }
}
_iface = new WeakMap();
class ContractTransactionResponse extends TransactionResponse {
  /**
   *  @_ignore:
   */
  constructor(iface, provider, tx) {
    super(tx, provider);
    __privateAdd(this, _iface2);
    __privateSet(this, _iface2, iface);
  }
  /**
   *  Resolves once this transaction has been mined and has
   *  %%confirms%% blocks including it (default: ``1``) with an
   *  optional %%timeout%%.
   *
   *  This can resolve to ``null`` only if %%confirms%% is ``0``
   *  and the transaction has not been mined, otherwise this will
   *  wait until enough confirmations have completed.
   */
  async wait(confirms, timeout) {
    const receipt = await super.wait(confirms, timeout);
    if (receipt == null) {
      return null;
    }
    return new ContractTransactionReceipt(__privateGet(this, _iface2), this.provider, receipt);
  }
}
_iface2 = new WeakMap();
class ContractUnknownEventPayload extends EventPayload {
  /**
   *  @_event:
   */
  constructor(contract, listener, filter, log) {
    super(contract, listener, filter);
    /**
     *  The log with no matching events.
     */
    __publicField(this, "log");
    defineProperties(this, { log });
  }
  /**
   *  Resolves to the block the event occured in.
   */
  async getBlock() {
    return await this.log.getBlock();
  }
  /**
   *  Resolves to the transaction the event occured in.
   */
  async getTransaction() {
    return await this.log.getTransaction();
  }
  /**
   *  Resolves to the transaction receipt the event occured in.
   */
  async getTransactionReceipt() {
    return await this.log.getTransactionReceipt();
  }
}
class ContractEventPayload extends ContractUnknownEventPayload {
  /**
   *  @_ignore:
   */
  constructor(contract, listener, filter, fragment, _log) {
    super(contract, listener, filter, new EventLog(_log, contract.interface, fragment));
    const args = contract.interface.decodeEventLog(fragment, this.log.data, this.log.topics);
    defineProperties(this, { args, fragment });
  }
  /**
   *  The event name.
   */
  get eventName() {
    return this.fragment.name;
  }
  /**
   *  The event signature.
   */
  get eventSignature() {
    return this.fragment.format();
  }
}
const BN_0$1 = BigInt(0);
function canCall(value) {
  return value && typeof value.call === "function";
}
function canEstimate(value) {
  return value && typeof value.estimateGas === "function";
}
function canResolve(value) {
  return value && typeof value.resolveName === "function";
}
function canSend(value) {
  return value && typeof value.sendTransaction === "function";
}
function getResolver(value) {
  if (value != null) {
    if (canResolve(value)) {
      return value;
    }
    if (value.provider) {
      return value.provider;
    }
  }
  return void 0;
}
class PreparedTopicFilter {
  constructor(contract, fragment, args) {
    __privateAdd(this, _filter);
    __publicField(this, "fragment");
    defineProperties(this, { fragment });
    if (fragment.inputs.length < args.length) {
      throw new Error("too many arguments");
    }
    const runner = getRunner(contract.runner, "resolveName");
    const resolver = canResolve(runner) ? runner : null;
    __privateSet(this, _filter, async function() {
      const resolvedArgs = await Promise.all(fragment.inputs.map((param, index) => {
        const arg = args[index];
        if (arg == null) {
          return null;
        }
        return param.walkAsync(args[index], (type, value) => {
          if (type === "address") {
            if (Array.isArray(value)) {
              return Promise.all(value.map((v2) => resolveAddress(v2, resolver)));
            }
            return resolveAddress(value, resolver);
          }
          return value;
        });
      }));
      return contract.interface.encodeFilterTopics(fragment, resolvedArgs);
    }());
  }
  getTopicFilter() {
    return __privateGet(this, _filter);
  }
}
_filter = new WeakMap();
function getRunner(value, feature) {
  if (value == null) {
    return null;
  }
  if (typeof value[feature] === "function") {
    return value;
  }
  if (value.provider && typeof value.provider[feature] === "function") {
    return value.provider;
  }
  return null;
}
function getProvider(value) {
  if (value == null) {
    return null;
  }
  return value.provider || null;
}
async function copyOverrides(arg, allowed) {
  const _overrides = Typed.dereference(arg, "overrides");
  assertArgument(typeof _overrides === "object", "invalid overrides parameter", "overrides", arg);
  const overrides = copyRequest(_overrides);
  assertArgument(overrides.to == null || (allowed || []).indexOf("to") >= 0, "cannot override to", "overrides.to", overrides.to);
  assertArgument(overrides.data == null || (allowed || []).indexOf("data") >= 0, "cannot override data", "overrides.data", overrides.data);
  if (overrides.from) {
    overrides.from = overrides.from;
  }
  return overrides;
}
async function resolveArgs(_runner, inputs, args) {
  const runner = getRunner(_runner, "resolveName");
  const resolver = canResolve(runner) ? runner : null;
  return await Promise.all(inputs.map((param, index) => {
    return param.walkAsync(args[index], (type, value) => {
      value = Typed.dereference(value, type);
      if (type === "address") {
        return resolveAddress(value, resolver);
      }
      return value;
    });
  }));
}
function buildWrappedFallback(contract) {
  const populateTransaction = async function(overrides) {
    const tx = await copyOverrides(overrides, ["data"]);
    tx.to = await contract.getAddress();
    if (tx.from) {
      tx.from = await resolveAddress(tx.from, getResolver(contract.runner));
    }
    const iface = contract.interface;
    const noValue = getBigInt(tx.value || BN_0$1, "overrides.value") === BN_0$1;
    const noData = (tx.data || "0x") === "0x";
    if (iface.fallback && !iface.fallback.payable && iface.receive && !noData && !noValue) {
      assertArgument(false, "cannot send data to receive or send value to non-payable fallback", "overrides", overrides);
    }
    assertArgument(iface.fallback || noData, "cannot send data to receive-only contract", "overrides.data", tx.data);
    const payable = iface.receive || iface.fallback && iface.fallback.payable;
    assertArgument(payable || noValue, "cannot send value to non-payable fallback", "overrides.value", tx.value);
    assertArgument(iface.fallback || noData, "cannot send data to receive-only contract", "overrides.data", tx.data);
    return tx;
  };
  const staticCall = async function(overrides) {
    const runner = getRunner(contract.runner, "call");
    assert(canCall(runner), "contract runner does not support calling", "UNSUPPORTED_OPERATION", { operation: "call" });
    const tx = await populateTransaction(overrides);
    try {
      return await runner.call(tx);
    } catch (error) {
      if (isCallException(error) && error.data) {
        throw contract.interface.makeError(error.data, tx);
      }
      throw error;
    }
  };
  const send = async function(overrides) {
    const runner = contract.runner;
    assert(canSend(runner), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", { operation: "sendTransaction" });
    const tx = await runner.sendTransaction(await populateTransaction(overrides));
    const provider = getProvider(contract.runner);
    return new ContractTransactionResponse(contract.interface, provider, tx);
  };
  const estimateGas = async function(overrides) {
    const runner = getRunner(contract.runner, "estimateGas");
    assert(canEstimate(runner), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", { operation: "estimateGas" });
    return await runner.estimateGas(await populateTransaction(overrides));
  };
  const method = async (overrides) => {
    return await send(overrides);
  };
  defineProperties(method, {
    _contract: contract,
    estimateGas,
    populateTransaction,
    send,
    staticCall
  });
  return method;
}
function buildWrappedMethod(contract, key) {
  const getFragment = function(...args) {
    const fragment = contract.interface.getFunction(key, args);
    assert(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
      operation: "fragment",
      info: { key, args }
    });
    return fragment;
  };
  const populateTransaction = async function(...args) {
    const fragment = getFragment(...args);
    let overrides = {};
    if (fragment.inputs.length + 1 === args.length) {
      overrides = await copyOverrides(args.pop());
      if (overrides.from) {
        overrides.from = await resolveAddress(overrides.from, getResolver(contract.runner));
      }
    }
    if (fragment.inputs.length !== args.length) {
      throw new Error("internal error: fragment inputs doesn't match arguments; should not happen");
    }
    const resolvedArgs = await resolveArgs(contract.runner, fragment.inputs, args);
    return Object.assign({}, overrides, await resolveProperties({
      to: contract.getAddress(),
      data: contract.interface.encodeFunctionData(fragment, resolvedArgs)
    }));
  };
  const staticCall = async function(...args) {
    const result = await staticCallResult(...args);
    if (result.length === 1) {
      return result[0];
    }
    return result;
  };
  const send = async function(...args) {
    const runner = contract.runner;
    assert(canSend(runner), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", { operation: "sendTransaction" });
    const tx = await runner.sendTransaction(await populateTransaction(...args));
    const provider = getProvider(contract.runner);
    return new ContractTransactionResponse(contract.interface, provider, tx);
  };
  const estimateGas = async function(...args) {
    const runner = getRunner(contract.runner, "estimateGas");
    assert(canEstimate(runner), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", { operation: "estimateGas" });
    return await runner.estimateGas(await populateTransaction(...args));
  };
  const staticCallResult = async function(...args) {
    const runner = getRunner(contract.runner, "call");
    assert(canCall(runner), "contract runner does not support calling", "UNSUPPORTED_OPERATION", { operation: "call" });
    const tx = await populateTransaction(...args);
    let result = "0x";
    try {
      result = await runner.call(tx);
    } catch (error) {
      if (isCallException(error) && error.data) {
        throw contract.interface.makeError(error.data, tx);
      }
      throw error;
    }
    const fragment = getFragment(...args);
    return contract.interface.decodeFunctionResult(fragment, result);
  };
  const method = async (...args) => {
    const fragment = getFragment(...args);
    if (fragment.constant) {
      return await staticCall(...args);
    }
    return await send(...args);
  };
  defineProperties(method, {
    name: contract.interface.getFunctionName(key),
    _contract: contract,
    _key: key,
    getFragment,
    estimateGas,
    populateTransaction,
    send,
    staticCall,
    staticCallResult
  });
  Object.defineProperty(method, "fragment", {
    configurable: false,
    enumerable: true,
    get: () => {
      const fragment = contract.interface.getFunction(key);
      assert(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
        operation: "fragment",
        info: { key }
      });
      return fragment;
    }
  });
  return method;
}
function buildWrappedEvent(contract, key) {
  const getFragment = function(...args) {
    const fragment = contract.interface.getEvent(key, args);
    assert(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
      operation: "fragment",
      info: { key, args }
    });
    return fragment;
  };
  const method = function(...args) {
    return new PreparedTopicFilter(contract, getFragment(...args), args);
  };
  defineProperties(method, {
    name: contract.interface.getEventName(key),
    _contract: contract,
    _key: key,
    getFragment
  });
  Object.defineProperty(method, "fragment", {
    configurable: false,
    enumerable: true,
    get: () => {
      const fragment = contract.interface.getEvent(key);
      assert(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
        operation: "fragment",
        info: { key }
      });
      return fragment;
    }
  });
  return method;
}
const internal = Symbol.for("_ethersInternal_contract");
const internalValues = /* @__PURE__ */ new WeakMap();
function setInternal(contract, values) {
  internalValues.set(contract[internal], values);
}
function getInternal(contract) {
  return internalValues.get(contract[internal]);
}
function isDeferred(value) {
  return value && typeof value === "object" && "getTopicFilter" in value && typeof value.getTopicFilter === "function" && value.fragment;
}
async function getSubInfo(contract, event) {
  let topics;
  let fragment = null;
  if (Array.isArray(event)) {
    const topicHashify = function(name) {
      if (isHexString(name, 32)) {
        return name;
      }
      const fragment2 = contract.interface.getEvent(name);
      assertArgument(fragment2, "unknown fragment", "name", name);
      return fragment2.topicHash;
    };
    topics = event.map((e3) => {
      if (e3 == null) {
        return null;
      }
      if (Array.isArray(e3)) {
        return e3.map(topicHashify);
      }
      return topicHashify(e3);
    });
  } else if (event === "*") {
    topics = [null];
  } else if (typeof event === "string") {
    if (isHexString(event, 32)) {
      topics = [event];
    } else {
      fragment = contract.interface.getEvent(event);
      assertArgument(fragment, "unknown fragment", "event", event);
      topics = [fragment.topicHash];
    }
  } else if (isDeferred(event)) {
    topics = await event.getTopicFilter();
  } else if ("fragment" in event) {
    fragment = event.fragment;
    topics = [fragment.topicHash];
  } else {
    assertArgument(false, "unknown event name", "event", event);
  }
  topics = topics.map((t) => {
    if (t == null) {
      return null;
    }
    if (Array.isArray(t)) {
      const items = Array.from(new Set(t.map((t2) => t2.toLowerCase())).values());
      if (items.length === 1) {
        return items[0];
      }
      items.sort();
      return items;
    }
    return t.toLowerCase();
  });
  const tag = topics.map((t) => {
    if (t == null) {
      return "null";
    }
    if (Array.isArray(t)) {
      return t.join("|");
    }
    return t;
  }).join("&");
  return { fragment, tag, topics };
}
async function hasSub(contract, event) {
  const { subs } = getInternal(contract);
  return subs.get((await getSubInfo(contract, event)).tag) || null;
}
async function getSub(contract, operation, event) {
  const provider = getProvider(contract.runner);
  assert(provider, "contract runner does not support subscribing", "UNSUPPORTED_OPERATION", { operation });
  const { fragment, tag, topics } = await getSubInfo(contract, event);
  const { addr, subs } = getInternal(contract);
  let sub = subs.get(tag);
  if (!sub) {
    const address = addr ? addr : contract;
    const filter = { address, topics };
    const listener = (log) => {
      let foundFragment = fragment;
      if (foundFragment == null) {
        try {
          foundFragment = contract.interface.getEvent(log.topics[0]);
        } catch (error) {
        }
      }
      if (foundFragment) {
        const _foundFragment = foundFragment;
        const args = fragment ? contract.interface.decodeEventLog(fragment, log.data, log.topics) : [];
        emit(contract, event, args, (listener2) => {
          return new ContractEventPayload(contract, listener2, event, _foundFragment, log);
        });
      } else {
        emit(contract, event, [], (listener2) => {
          return new ContractUnknownEventPayload(contract, listener2, event, log);
        });
      }
    };
    let starting = [];
    const start = () => {
      if (starting.length) {
        return;
      }
      starting.push(provider.on(filter, listener));
    };
    const stop = async () => {
      if (starting.length == 0) {
        return;
      }
      let started = starting;
      starting = [];
      await Promise.all(started);
      provider.off(filter, listener);
    };
    sub = { tag, listeners: [], start, stop };
    subs.set(tag, sub);
  }
  return sub;
}
let lastEmit = Promise.resolve();
async function _emit(contract, event, args, payloadFunc) {
  await lastEmit;
  const sub = await hasSub(contract, event);
  if (!sub) {
    return false;
  }
  const count = sub.listeners.length;
  sub.listeners = sub.listeners.filter(({ listener, once }) => {
    const passArgs = Array.from(args);
    if (payloadFunc) {
      passArgs.push(payloadFunc(once ? null : listener));
    }
    try {
      listener.call(contract, ...passArgs);
    } catch (error) {
    }
    return !once;
  });
  if (sub.listeners.length === 0) {
    sub.stop();
    getInternal(contract).subs.delete(sub.tag);
  }
  return count > 0;
}
async function emit(contract, event, args, payloadFunc) {
  try {
    await lastEmit;
  } catch (error) {
  }
  const resultPromise = _emit(contract, event, args, payloadFunc);
  lastEmit = resultPromise;
  return await resultPromise;
}
const passProperties = ["then"];
_a = internal;
const _BaseContract = class _BaseContract {
  /**
   *  Creates a new contract connected to %%target%% with the %%abi%% and
   *  optionally connected to a %%runner%% to perform operations on behalf
   *  of.
   */
  constructor(target, abi, runner, _deployTx) {
    /**
     *  The target to connect to.
     *
     *  This can be an address, ENS name or any [[Addressable]], such as
     *  another contract. To get the resovled address, use the ``getAddress``
     *  method.
     */
    __publicField(this, "target");
    /**
     *  The contract Interface.
     */
    __publicField(this, "interface");
    /**
     *  The connected runner. This is generally a [[Provider]] or a
     *  [[Signer]], which dictates what operations are supported.
     *
     *  For example, a **Contract** connected to a [[Provider]] may
     *  only execute read-only operations.
     */
    __publicField(this, "runner");
    /**
     *  All the Events available on this contract.
     */
    __publicField(this, "filters");
    /**
     *  @_ignore:
     */
    __publicField(this, _a);
    /**
     *  The fallback or receive function if any.
     */
    __publicField(this, "fallback");
    assertArgument(typeof target === "string" || isAddressable(target), "invalid value for Contract target", "target", target);
    if (runner == null) {
      runner = null;
    }
    const iface = Interface.from(abi);
    defineProperties(this, { target, runner, interface: iface });
    Object.defineProperty(this, internal, { value: {} });
    let addrPromise;
    let addr = null;
    let deployTx = null;
    if (_deployTx) {
      const provider = getProvider(runner);
      deployTx = new ContractTransactionResponse(this.interface, provider, _deployTx);
    }
    let subs = /* @__PURE__ */ new Map();
    if (typeof target === "string") {
      if (isHexString(target)) {
        addr = target;
        addrPromise = Promise.resolve(target);
      } else {
        const resolver = getRunner(runner, "resolveName");
        if (!canResolve(resolver)) {
          throw makeError("contract runner does not support name resolution", "UNSUPPORTED_OPERATION", {
            operation: "resolveName"
          });
        }
        addrPromise = resolver.resolveName(target).then((addr2) => {
          if (addr2 == null) {
            throw makeError("an ENS name used for a contract target must be correctly configured", "UNCONFIGURED_NAME", {
              value: target
            });
          }
          getInternal(this).addr = addr2;
          return addr2;
        });
      }
    } else {
      addrPromise = target.getAddress().then((addr2) => {
        if (addr2 == null) {
          throw new Error("TODO");
        }
        getInternal(this).addr = addr2;
        return addr2;
      });
    }
    setInternal(this, { addrPromise, addr, deployTx, subs });
    const filters = new Proxy({}, {
      get: (target2, prop2, receiver) => {
        if (typeof prop2 === "symbol" || passProperties.indexOf(prop2) >= 0) {
          return Reflect.get(target2, prop2, receiver);
        }
        try {
          return this.getEvent(prop2);
        } catch (error) {
          if (!isError(error, "INVALID_ARGUMENT") || error.argument !== "key") {
            throw error;
          }
        }
        return void 0;
      },
      has: (target2, prop2) => {
        if (passProperties.indexOf(prop2) >= 0) {
          return Reflect.has(target2, prop2);
        }
        return Reflect.has(target2, prop2) || this.interface.hasEvent(String(prop2));
      }
    });
    defineProperties(this, { filters });
    defineProperties(this, {
      fallback: iface.receive || iface.fallback ? buildWrappedFallback(this) : null
    });
    return new Proxy(this, {
      get: (target2, prop2, receiver) => {
        if (typeof prop2 === "symbol" || prop2 in target2 || passProperties.indexOf(prop2) >= 0) {
          return Reflect.get(target2, prop2, receiver);
        }
        try {
          return target2.getFunction(prop2);
        } catch (error) {
          if (!isError(error, "INVALID_ARGUMENT") || error.argument !== "key") {
            throw error;
          }
        }
        return void 0;
      },
      has: (target2, prop2) => {
        if (typeof prop2 === "symbol" || prop2 in target2 || passProperties.indexOf(prop2) >= 0) {
          return Reflect.has(target2, prop2);
        }
        return target2.interface.hasFunction(prop2);
      }
    });
  }
  /**
   *  Return a new Contract instance with the same target and ABI, but
   *  a different %%runner%%.
   */
  connect(runner) {
    return new _BaseContract(this.target, this.interface, runner);
  }
  /**
   *  Return a new Contract instance with the same ABI and runner, but
   *  a different %%target%%.
   */
  attach(target) {
    return new _BaseContract(target, this.interface, this.runner);
  }
  /**
   *  Return the resolved address of this Contract.
   */
  async getAddress() {
    return await getInternal(this).addrPromise;
  }
  /**
   *  Return the deployed bytecode or null if no bytecode is found.
   */
  async getDeployedCode() {
    const provider = getProvider(this.runner);
    assert(provider, "runner does not support .provider", "UNSUPPORTED_OPERATION", { operation: "getDeployedCode" });
    const code = await provider.getCode(await this.getAddress());
    if (code === "0x") {
      return null;
    }
    return code;
  }
  /**
   *  Resolve to this Contract once the bytecode has been deployed, or
   *  resolve immediately if already deployed.
   */
  async waitForDeployment() {
    const deployTx = this.deploymentTransaction();
    if (deployTx) {
      await deployTx.wait();
      return this;
    }
    const code = await this.getDeployedCode();
    if (code != null) {
      return this;
    }
    const provider = getProvider(this.runner);
    assert(provider != null, "contract runner does not support .provider", "UNSUPPORTED_OPERATION", { operation: "waitForDeployment" });
    return new Promise((resolve, reject) => {
      const checkCode = async () => {
        try {
          const code2 = await this.getDeployedCode();
          if (code2 != null) {
            return resolve(this);
          }
          provider.once("block", checkCode);
        } catch (error) {
          reject(error);
        }
      };
      checkCode();
    });
  }
  /**
   *  Return the transaction used to deploy this contract.
   *
   *  This is only available if this instance was returned from a
   *  [[ContractFactory]].
   */
  deploymentTransaction() {
    return getInternal(this).deployTx;
  }
  /**
   *  Return the function for a given name. This is useful when a contract
   *  method name conflicts with a JavaScript name such as ``prototype`` or
   *  when using a Contract programatically.
   */
  getFunction(key) {
    if (typeof key !== "string") {
      key = key.format();
    }
    const func = buildWrappedMethod(this, key);
    return func;
  }
  /**
   *  Return the event for a given name. This is useful when a contract
   *  event name conflicts with a JavaScript name such as ``prototype`` or
   *  when using a Contract programatically.
   */
  getEvent(key) {
    if (typeof key !== "string") {
      key = key.format();
    }
    return buildWrappedEvent(this, key);
  }
  /**
   *  @_ignore:
   */
  async queryTransaction(hash) {
    throw new Error("@TODO");
  }
  /*
      // @TODO: this is a non-backwards compatible change, but will be added
      //        in v7 and in a potential SmartContract class in an upcoming
      //        v6 release
      async getTransactionReceipt(hash: string): Promise<null | ContractTransactionReceipt> {
          const provider = getProvider(this.runner);
          assert(provider, "contract runner does not have a provider",
              "UNSUPPORTED_OPERATION", { operation: "queryTransaction" });
  
          const receipt = await provider.getTransactionReceipt(hash);
          if (receipt == null) { return null; }
  
          return new ContractTransactionReceipt(this.interface, provider, receipt);
      }
      */
  /**
   *  Provide historic access to event data for %%event%% in the range
   *  %%fromBlock%% (default: ``0``) to %%toBlock%% (default: ``"latest"``)
   *  inclusive.
   */
  async queryFilter(event, fromBlock, toBlock) {
    if (fromBlock == null) {
      fromBlock = 0;
    }
    if (toBlock == null) {
      toBlock = "latest";
    }
    const { addr, addrPromise } = getInternal(this);
    const address = addr ? addr : await addrPromise;
    const { fragment, topics } = await getSubInfo(this, event);
    const filter = { address, topics, fromBlock, toBlock };
    const provider = getProvider(this.runner);
    assert(provider, "contract runner does not have a provider", "UNSUPPORTED_OPERATION", { operation: "queryFilter" });
    return (await provider.getLogs(filter)).map((log) => {
      let foundFragment = fragment;
      if (foundFragment == null) {
        try {
          foundFragment = this.interface.getEvent(log.topics[0]);
        } catch (error) {
        }
      }
      if (foundFragment) {
        try {
          return new EventLog(log, this.interface, foundFragment);
        } catch (error) {
          return new UndecodedEventLog(log, error);
        }
      }
      return new Log(log, provider);
    });
  }
  /**
   *  Add an event %%listener%% for the %%event%%.
   */
  async on(event, listener) {
    const sub = await getSub(this, "on", event);
    sub.listeners.push({ listener, once: false });
    sub.start();
    return this;
  }
  /**
   *  Add an event %%listener%% for the %%event%%, but remove the listener
   *  after it is fired once.
   */
  async once(event, listener) {
    const sub = await getSub(this, "once", event);
    sub.listeners.push({ listener, once: true });
    sub.start();
    return this;
  }
  /**
   *  Emit an %%event%% calling all listeners with %%args%%.
   *
   *  Resolves to ``true`` if any listeners were called.
   */
  async emit(event, ...args) {
    return await emit(this, event, args, null);
  }
  /**
   *  Resolves to the number of listeners of %%event%% or the total number
   *  of listeners if unspecified.
   */
  async listenerCount(event) {
    if (event) {
      const sub = await hasSub(this, event);
      if (!sub) {
        return 0;
      }
      return sub.listeners.length;
    }
    const { subs } = getInternal(this);
    let total = 0;
    for (const { listeners } of subs.values()) {
      total += listeners.length;
    }
    return total;
  }
  /**
   *  Resolves to the listeners subscribed to %%event%% or all listeners
   *  if unspecified.
   */
  async listeners(event) {
    if (event) {
      const sub = await hasSub(this, event);
      if (!sub) {
        return [];
      }
      return sub.listeners.map(({ listener }) => listener);
    }
    const { subs } = getInternal(this);
    let result = [];
    for (const { listeners } of subs.values()) {
      result = result.concat(listeners.map(({ listener }) => listener));
    }
    return result;
  }
  /**
   *  Remove the %%listener%% from the listeners for %%event%% or remove
   *  all listeners if unspecified.
   */
  async off(event, listener) {
    const sub = await hasSub(this, event);
    if (!sub) {
      return this;
    }
    if (listener) {
      const index = sub.listeners.map(({ listener: listener2 }) => listener2).indexOf(listener);
      if (index >= 0) {
        sub.listeners.splice(index, 1);
      }
    }
    if (listener == null || sub.listeners.length === 0) {
      sub.stop();
      getInternal(this).subs.delete(sub.tag);
    }
    return this;
  }
  /**
   *  Remove all the listeners for %%event%% or remove all listeners if
   *  unspecified.
   */
  async removeAllListeners(event) {
    if (event) {
      const sub = await hasSub(this, event);
      if (!sub) {
        return this;
      }
      sub.stop();
      getInternal(this).subs.delete(sub.tag);
    } else {
      const { subs } = getInternal(this);
      for (const { tag, stop } of subs.values()) {
        stop();
        subs.delete(tag);
      }
    }
    return this;
  }
  /**
   *  Alias for [on].
   */
  async addListener(event, listener) {
    return await this.on(event, listener);
  }
  /**
   *  Alias for [off].
   */
  async removeListener(event, listener) {
    return await this.off(event, listener);
  }
  /**
   *  Create a new Class for the %%abi%%.
   */
  static buildClass(abi) {
    class CustomContract extends _BaseContract {
      constructor(address, runner = null) {
        super(address, abi, runner);
      }
    }
    return CustomContract;
  }
  /**
   *  Create a new BaseContract with a specified Interface.
   */
  static from(target, abi, runner) {
    if (runner == null) {
      runner = null;
    }
    const contract = new this(target, abi, runner);
    return contract;
  }
};
let BaseContract = _BaseContract;
function _ContractBase() {
  return BaseContract;
}
class Contract extends _ContractBase() {
}
function getIpfsLink(link) {
  if (link.match(/^ipfs:\/\/ipfs\//i)) {
    link = link.substring(12);
  } else if (link.match(/^ipfs:\/\//i)) {
    link = link.substring(7);
  } else {
    assertArgument(false, "unsupported IPFS format", "link", link);
  }
  return `https://gateway.ipfs.io/ipfs/${link}`;
}
class MulticoinProviderPlugin {
  /**
   *  Creates a new **MulticoinProviderPluing** for %%name%%.
   */
  constructor(name) {
    /**
     *  The name.
     */
    __publicField(this, "name");
    defineProperties(this, { name });
  }
  connect(proivder) {
    return this;
  }
  /**
   *  Returns ``true`` if %%coinType%% is supported by this plugin.
   */
  supportsCoinType(coinType) {
    return false;
  }
  /**
   *  Resolves to the encoded %%address%% for %%coinType%%.
   */
  async encodeAddress(coinType, address) {
    throw new Error("unsupported coin");
  }
  /**
   *  Resolves to the decoded %%data%% for %%coinType%%.
   */
  async decodeAddress(coinType, data) {
    throw new Error("unsupported coin");
  }
}
const matcherIpfs = new RegExp("^(ipfs)://(.*)$", "i");
const matchers = [
  new RegExp("^(https)://(.*)$", "i"),
  new RegExp("^(data):(.*)$", "i"),
  matcherIpfs,
  new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")
];
const _EnsResolver = class _EnsResolver {
  constructor(provider, address, name) {
    __privateAdd(this, _EnsResolver_instances);
    /**
     *  The connected provider.
     */
    __publicField(this, "provider");
    /**
     *  The address of the resolver.
     */
    __publicField(this, "address");
    /**
     *  The name this resolver was resolved against.
     */
    __publicField(this, "name");
    // For EIP-2544 names, the ancestor that provided the resolver
    __privateAdd(this, _supports2544);
    __privateAdd(this, _resolver);
    defineProperties(this, { provider, address, name });
    __privateSet(this, _supports2544, null);
    __privateSet(this, _resolver, new Contract(address, [
      "function supportsInterface(bytes4) view returns (bool)",
      "function resolve(bytes, bytes) view returns (bytes)",
      "function addr(bytes32) view returns (address)",
      "function addr(bytes32, uint) view returns (bytes)",
      "function text(bytes32, string) view returns (string)",
      "function contenthash(bytes32) view returns (bytes)"
    ], provider));
  }
  /**
   *  Resolves to true if the resolver supports wildcard resolution.
   */
  async supportsWildcard() {
    if (__privateGet(this, _supports2544) == null) {
      __privateSet(this, _supports2544, (async () => {
        try {
          return await __privateGet(this, _resolver).supportsInterface("0x9061b923");
        } catch (error) {
          if (isError(error, "CALL_EXCEPTION")) {
            return false;
          }
          __privateSet(this, _supports2544, null);
          throw error;
        }
      })());
    }
    return await __privateGet(this, _supports2544);
  }
  /**
   *  Resolves to the address for %%coinType%% or null if the
   *  provided %%coinType%% has not been configured.
   */
  async getAddress(coinType) {
    if (coinType == null) {
      coinType = 60;
    }
    if (coinType === 60) {
      try {
        const result = await __privateMethod(this, _EnsResolver_instances, fetch_fn).call(this, "addr(bytes32)");
        if (result == null || result === ZeroAddress) {
          return null;
        }
        return result;
      } catch (error) {
        if (isError(error, "CALL_EXCEPTION")) {
          return null;
        }
        throw error;
      }
    }
    if (coinType >= 0 && coinType < 2147483648) {
      let ethCoinType = coinType + 2147483648;
      const data2 = await __privateMethod(this, _EnsResolver_instances, fetch_fn).call(this, "addr(bytes32,uint)", [ethCoinType]);
      if (isHexString(data2, 20)) {
        return getAddress(data2);
      }
    }
    let coinPlugin = null;
    for (const plugin of this.provider.plugins) {
      if (!(plugin instanceof MulticoinProviderPlugin)) {
        continue;
      }
      if (plugin.supportsCoinType(coinType)) {
        coinPlugin = plugin;
        break;
      }
    }
    if (coinPlugin == null) {
      return null;
    }
    const data = await __privateMethod(this, _EnsResolver_instances, fetch_fn).call(this, "addr(bytes32,uint)", [coinType]);
    if (data == null || data === "0x") {
      return null;
    }
    const address = await coinPlugin.decodeAddress(coinType, data);
    if (address != null) {
      return address;
    }
    assert(false, `invalid coin data`, "UNSUPPORTED_OPERATION", {
      operation: `getAddress(${coinType})`,
      info: { coinType, data }
    });
  }
  /**
   *  Resolves to the EIP-634 text record for %%key%%, or ``null``
   *  if unconfigured.
   */
  async getText(key) {
    const data = await __privateMethod(this, _EnsResolver_instances, fetch_fn).call(this, "text(bytes32,string)", [key]);
    if (data == null || data === "0x") {
      return null;
    }
    return data;
  }
  /**
   *  Rsolves to the content-hash or ``null`` if unconfigured.
   */
  async getContentHash() {
    const data = await __privateMethod(this, _EnsResolver_instances, fetch_fn).call(this, "contenthash(bytes32)");
    if (data == null || data === "0x") {
      return null;
    }
    const ipfs = data.match(/^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
    if (ipfs) {
      const scheme = ipfs[1] === "e3010170" ? "ipfs" : "ipns";
      const length = parseInt(ipfs[4], 16);
      if (ipfs[5].length === length * 2) {
        return `${scheme}://${encodeBase58("0x" + ipfs[2])}`;
      }
    }
    const swarm = data.match(/^0xe40101fa011b20([0-9a-f]*)$/);
    if (swarm && swarm[1].length === 64) {
      return `bzz://${swarm[1]}`;
    }
    assert(false, `invalid or unsupported content hash data`, "UNSUPPORTED_OPERATION", {
      operation: "getContentHash()",
      info: { data }
    });
  }
  /**
   *  Resolves to the avatar url or ``null`` if the avatar is either
   *  unconfigured or incorrectly configured (e.g. references an NFT
   *  not owned by the address).
   *
   *  If diagnosing issues with configurations, the [[_getAvatar]]
   *  method may be useful.
   */
  async getAvatar() {
    const avatar = await this._getAvatar();
    return avatar.url;
  }
  /**
   *  When resolving an avatar, there are many steps involved, such
   *  fetching metadata and possibly validating ownership of an
   *  NFT.
   *
   *  This method can be used to examine each step and the value it
   *  was working from.
   */
  async _getAvatar() {
    const linkage = [{ type: "name", value: this.name }];
    try {
      const avatar = await this.getText("avatar");
      if (avatar == null) {
        linkage.push({ type: "!avatar", value: "" });
        return { url: null, linkage };
      }
      linkage.push({ type: "avatar", value: avatar });
      for (let i = 0; i < matchers.length; i++) {
        const match = avatar.match(matchers[i]);
        if (match == null) {
          continue;
        }
        const scheme = match[1].toLowerCase();
        switch (scheme) {
          case "https":
          case "data":
            linkage.push({ type: "url", value: avatar });
            return { linkage, url: avatar };
          case "ipfs": {
            const url = getIpfsLink(avatar);
            linkage.push({ type: "ipfs", value: avatar });
            linkage.push({ type: "url", value: url });
            return { linkage, url };
          }
          case "erc721":
          case "erc1155": {
            const selector = scheme === "erc721" ? "tokenURI(uint256)" : "uri(uint256)";
            linkage.push({ type: scheme, value: avatar });
            const owner = await this.getAddress();
            if (owner == null) {
              linkage.push({ type: "!owner", value: "" });
              return { url: null, linkage };
            }
            const comps = (match[2] || "").split("/");
            if (comps.length !== 2) {
              linkage.push({ type: `!${scheme}caip`, value: match[2] || "" });
              return { url: null, linkage };
            }
            const tokenId = comps[1];
            const contract = new Contract(comps[0], [
              // ERC-721
              "function tokenURI(uint) view returns (string)",
              "function ownerOf(uint) view returns (address)",
              // ERC-1155
              "function uri(uint) view returns (string)",
              "function balanceOf(address, uint256) view returns (uint)"
            ], this.provider);
            if (scheme === "erc721") {
              const tokenOwner = await contract.ownerOf(tokenId);
              if (owner !== tokenOwner) {
                linkage.push({ type: "!owner", value: tokenOwner });
                return { url: null, linkage };
              }
              linkage.push({ type: "owner", value: tokenOwner });
            } else if (scheme === "erc1155") {
              const balance = await contract.balanceOf(owner, tokenId);
              if (!balance) {
                linkage.push({ type: "!balance", value: "0" });
                return { url: null, linkage };
              }
              linkage.push({ type: "balance", value: balance.toString() });
            }
            let metadataUrl = await contract[selector](tokenId);
            if (metadataUrl == null || metadataUrl === "0x") {
              linkage.push({ type: "!metadata-url", value: "" });
              return { url: null, linkage };
            }
            linkage.push({ type: "metadata-url-base", value: metadataUrl });
            if (scheme === "erc1155") {
              metadataUrl = metadataUrl.replace("{id}", toBeHex(tokenId, 32).substring(2));
              linkage.push({ type: "metadata-url-expanded", value: metadataUrl });
            }
            if (metadataUrl.match(/^ipfs:/i)) {
              metadataUrl = getIpfsLink(metadataUrl);
            }
            linkage.push({ type: "metadata-url", value: metadataUrl });
            let metadata = {};
            const response = await new FetchRequest(metadataUrl).send();
            response.assertOk();
            try {
              metadata = response.bodyJson;
            } catch (error) {
              try {
                linkage.push({ type: "!metadata", value: response.bodyText });
              } catch (error2) {
                const bytes = response.body;
                if (bytes) {
                  linkage.push({ type: "!metadata", value: hexlify(bytes) });
                }
                return { url: null, linkage };
              }
              return { url: null, linkage };
            }
            if (!metadata) {
              linkage.push({ type: "!metadata", value: "" });
              return { url: null, linkage };
            }
            linkage.push({ type: "metadata", value: JSON.stringify(metadata) });
            let imageUrl = metadata.image;
            if (typeof imageUrl !== "string") {
              linkage.push({ type: "!imageUrl", value: "" });
              return { url: null, linkage };
            }
            if (imageUrl.match(/^(https:\/\/|data:)/i)) {
            } else {
              const ipfs = imageUrl.match(matcherIpfs);
              if (ipfs == null) {
                linkage.push({ type: "!imageUrl-ipfs", value: imageUrl });
                return { url: null, linkage };
              }
              linkage.push({ type: "imageUrl-ipfs", value: imageUrl });
              imageUrl = getIpfsLink(imageUrl);
            }
            linkage.push({ type: "url", value: imageUrl });
            return { linkage, url: imageUrl };
          }
        }
      }
    } catch (error) {
    }
    return { linkage, url: null };
  }
  static async getEnsAddress(provider) {
    const network = await provider.getNetwork();
    const ensPlugin = network.getPlugin("org.ethers.plugins.network.Ens");
    assert(ensPlugin, "network does not support ENS", "UNSUPPORTED_OPERATION", {
      operation: "getEnsAddress",
      info: { network }
    });
    return ensPlugin.address;
  }
  /**
   *  Resolve to the ENS resolver for %%name%% using %%provider%% or
   *  ``null`` if unconfigured.
   */
  static async fromName(provider, name) {
    var _a2;
    let currentName = name;
    while (true) {
      if (currentName === "" || currentName === ".") {
        return null;
      }
      if (name !== "eth" && currentName === "eth") {
        return null;
      }
      const addr = await __privateMethod(_a2 = _EnsResolver, _EnsResolver_static, getResolver_fn).call(_a2, provider, currentName);
      if (addr != null) {
        const resolver = new _EnsResolver(provider, addr, name);
        if (currentName !== name && !await resolver.supportsWildcard()) {
          return null;
        }
        return resolver;
      }
      currentName = currentName.split(".").slice(1).join(".");
    }
  }
};
_supports2544 = new WeakMap();
_resolver = new WeakMap();
_EnsResolver_instances = new WeakSet();
fetch_fn = async function(funcName, params) {
  params = (params || []).slice();
  const iface = __privateGet(this, _resolver).interface;
  params.unshift(namehash(this.name));
  let fragment = null;
  if (await this.supportsWildcard()) {
    fragment = iface.getFunction(funcName);
    assert(fragment, "missing fragment", "UNKNOWN_ERROR", {
      info: { funcName }
    });
    params = [
      dnsEncode(this.name, 255),
      iface.encodeFunctionData(fragment, params)
    ];
    funcName = "resolve(bytes,bytes)";
  }
  params.push({
    enableCcipRead: true
  });
  try {
    const result = await __privateGet(this, _resolver)[funcName](...params);
    if (fragment) {
      return iface.decodeFunctionResult(fragment, result)[0];
    }
    return result;
  } catch (error) {
    if (!isError(error, "CALL_EXCEPTION")) {
      throw error;
    }
  }
  return null;
};
_EnsResolver_static = new WeakSet();
getResolver_fn = async function(provider, name) {
  const ensAddr = await _EnsResolver.getEnsAddress(provider);
  try {
    const contract = new Contract(ensAddr, [
      "function resolver(bytes32) view returns (address)"
    ], provider);
    const addr = await contract.resolver(namehash(name), {
      enableCcipRead: true
    });
    if (addr === ZeroAddress) {
      return null;
    }
    return addr;
  } catch (error) {
    throw error;
  }
  return null;
};
__privateAdd(_EnsResolver, _EnsResolver_static);
let EnsResolver = _EnsResolver;
const BN_0 = BigInt(0);
function allowNull(format2, nullValue) {
  return function(value) {
    if (value == null) {
      return nullValue;
    }
    return format2(value);
  };
}
function arrayOf(format2, allowNull2) {
  return (array) => {
    if (allowNull2 && array == null) {
      return null;
    }
    if (!Array.isArray(array)) {
      throw new Error("not an array");
    }
    return array.map((i) => format2(i));
  };
}
function object(format2, altNames) {
  return (value) => {
    const result = {};
    for (const key in format2) {
      let srcKey = key;
      if (altNames && key in altNames && !(srcKey in value)) {
        for (const altKey of altNames[key]) {
          if (altKey in value) {
            srcKey = altKey;
            break;
          }
        }
      }
      try {
        const nv = format2[key](value[srcKey]);
        if (nv !== void 0) {
          result[key] = nv;
        }
      } catch (error) {
        const message = error instanceof Error ? error.message : "not-an-error";
        assert(false, `invalid value for value.${key} (${message})`, "BAD_DATA", { value });
      }
    }
    return result;
  };
}
function formatBoolean(value) {
  switch (value) {
    case true:
    case "true":
      return true;
    case false:
    case "false":
      return false;
  }
  assertArgument(false, `invalid boolean; ${JSON.stringify(value)}`, "value", value);
}
function formatData(value) {
  assertArgument(isHexString(value, true), "invalid data", "value", value);
  return value;
}
function formatHash(value) {
  assertArgument(isHexString(value, 32), "invalid hash", "value", value);
  return value;
}
const _formatLog = object({
  address: getAddress,
  blockHash: formatHash,
  blockNumber: getNumber,
  data: formatData,
  index: getNumber,
  removed: allowNull(formatBoolean, false),
  topics: arrayOf(formatHash),
  transactionHash: formatHash,
  transactionIndex: getNumber
}, {
  index: ["logIndex"]
});
function formatLog(value) {
  return _formatLog(value);
}
const _formatBlock = object({
  hash: allowNull(formatHash),
  parentHash: formatHash,
  parentBeaconBlockRoot: allowNull(formatHash, null),
  number: getNumber,
  timestamp: getNumber,
  nonce: allowNull(formatData),
  difficulty: getBigInt,
  gasLimit: getBigInt,
  gasUsed: getBigInt,
  stateRoot: allowNull(formatHash, null),
  receiptsRoot: allowNull(formatHash, null),
  blobGasUsed: allowNull(getBigInt, null),
  excessBlobGas: allowNull(getBigInt, null),
  miner: allowNull(getAddress),
  prevRandao: allowNull(formatHash, null),
  extraData: formatData,
  baseFeePerGas: allowNull(getBigInt)
}, {
  prevRandao: ["mixHash"]
});
function formatBlock(value) {
  const result = _formatBlock(value);
  result.transactions = value.transactions.map((tx) => {
    if (typeof tx === "string") {
      return tx;
    }
    return formatTransactionResponse(tx);
  });
  return result;
}
const _formatReceiptLog = object({
  transactionIndex: getNumber,
  blockNumber: getNumber,
  transactionHash: formatHash,
  address: getAddress,
  topics: arrayOf(formatHash),
  data: formatData,
  index: getNumber,
  blockHash: formatHash
}, {
  index: ["logIndex"]
});
function formatReceiptLog(value) {
  return _formatReceiptLog(value);
}
const _formatTransactionReceipt = object({
  to: allowNull(getAddress, null),
  from: allowNull(getAddress, null),
  contractAddress: allowNull(getAddress, null),
  // should be allowNull(hash), but broken-EIP-658 support is handled in receipt
  index: getNumber,
  root: allowNull(hexlify),
  gasUsed: getBigInt,
  blobGasUsed: allowNull(getBigInt, null),
  logsBloom: allowNull(formatData),
  blockHash: formatHash,
  hash: formatHash,
  logs: arrayOf(formatReceiptLog),
  blockNumber: getNumber,
  //confirmations: allowNull(getNumber, null),
  cumulativeGasUsed: getBigInt,
  effectiveGasPrice: allowNull(getBigInt),
  blobGasPrice: allowNull(getBigInt, null),
  status: allowNull(getNumber),
  type: allowNull(getNumber, 0)
}, {
  effectiveGasPrice: ["gasPrice"],
  hash: ["transactionHash"],
  index: ["transactionIndex"]
});
function formatTransactionReceipt(value) {
  return _formatTransactionReceipt(value);
}
function formatTransactionResponse(value) {
  if (value.to && getBigInt(value.to) === BN_0) {
    value.to = "0x0000000000000000000000000000000000000000";
  }
  const result = object({
    hash: formatHash,
    // Some nodes do not return this, usually test nodes (like Ganache)
    index: allowNull(getNumber, void 0),
    type: (value2) => {
      if (value2 === "0x" || value2 == null) {
        return 0;
      }
      return getNumber(value2);
    },
    accessList: allowNull(accessListify, null),
    blobVersionedHashes: allowNull(arrayOf(formatHash, true), null),
    blockHash: allowNull(formatHash, null),
    blockNumber: allowNull(getNumber, null),
    transactionIndex: allowNull(getNumber, null),
    from: getAddress,
    // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas) must be set
    gasPrice: allowNull(getBigInt),
    maxPriorityFeePerGas: allowNull(getBigInt),
    maxFeePerGas: allowNull(getBigInt),
    maxFeePerBlobGas: allowNull(getBigInt, null),
    gasLimit: getBigInt,
    to: allowNull(getAddress, null),
    value: getBigInt,
    nonce: getNumber,
    data: formatData,
    creates: allowNull(getAddress, null),
    chainId: allowNull(getBigInt, null)
  }, {
    data: ["input"],
    gasLimit: ["gas"],
    index: ["transactionIndex"]
  })(value);
  if (result.to == null && result.creates == null) {
    result.creates = getCreateAddress(result);
  }
  if ((value.type === 1 || value.type === 2) && value.accessList == null) {
    result.accessList = [];
  }
  if (value.signature) {
    result.signature = Signature.from(value.signature);
  } else {
    result.signature = Signature.from(value);
  }
  if (result.chainId == null) {
    const chainId = result.signature.legacyChainId;
    if (chainId != null) {
      result.chainId = chainId;
    }
  }
  if (result.blockHash && getBigInt(result.blockHash) === BN_0) {
    result.blockHash = null;
  }
  return result;
}
const EnsAddress = "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e";
class NetworkPlugin {
  /**
   *  Creates a new **NetworkPlugin**.
   */
  constructor(name) {
    /**
     *  The name of the plugin.
     *
     *  It is recommended to use reverse-domain-notation, which permits
     *  unique names with a known authority as well as hierarchal entries.
     */
    __publicField(this, "name");
    defineProperties(this, { name });
  }
  /**
   *  Creates a copy of this plugin.
   */
  clone() {
    return new NetworkPlugin(this.name);
  }
}
class GasCostPlugin extends NetworkPlugin {
  /**
   *  Creates a new GasCostPlugin from %%effectiveBlock%% until the
   *  latest block or another GasCostPlugin supercedes that block number,
   *  with the associated %%costs%%.
   */
  constructor(effectiveBlock, costs) {
    if (effectiveBlock == null) {
      effectiveBlock = 0;
    }
    super(`org.ethers.network.plugins.GasCost#${effectiveBlock || 0}`);
    /**
     *  The block number to treat these values as valid from.
     *
     *  This allows a hardfork to have updated values included as well as
     *  mulutiple hardforks to be supported.
     */
    __publicField(this, "effectiveBlock");
    /**
     *  The transactions base fee.
     */
    __publicField(this, "txBase");
    /**
     *  The fee for creating a new account.
     */
    __publicField(this, "txCreate");
    /**
     *  The fee per zero-byte in the data.
     */
    __publicField(this, "txDataZero");
    /**
     *  The fee per non-zero-byte in the data.
     */
    __publicField(this, "txDataNonzero");
    /**
     *  The fee per storage key in the [[link-eip-2930]] access list.
     */
    __publicField(this, "txAccessListStorageKey");
    /**
     *  The fee per address in the [[link-eip-2930]] access list.
     */
    __publicField(this, "txAccessListAddress");
    const props = { effectiveBlock };
    function set2(name, nullish) {
      let value = (costs || {})[name];
      if (value == null) {
        value = nullish;
      }
      assertArgument(typeof value === "number", `invalud value for ${name}`, "costs", costs);
      props[name] = value;
    }
    set2("txBase", 21e3);
    set2("txCreate", 32e3);
    set2("txDataZero", 4);
    set2("txDataNonzero", 16);
    set2("txAccessListStorageKey", 1900);
    set2("txAccessListAddress", 2400);
    defineProperties(this, props);
  }
  clone() {
    return new GasCostPlugin(this.effectiveBlock, this);
  }
}
class EnsPlugin extends NetworkPlugin {
  /**
   *  Creates a new **EnsPlugin** connected to %%address%% on the
   *  %%targetNetwork%%. The default ENS address and mainnet is used
   *  if unspecified.
   */
  constructor(address, targetNetwork) {
    super("org.ethers.plugins.network.Ens");
    /**
     *  The ENS Registrty Contract address.
     */
    __publicField(this, "address");
    /**
     *  The chain ID that the ENS contract lives on.
     */
    __publicField(this, "targetNetwork");
    defineProperties(this, {
      address: address || EnsAddress,
      targetNetwork: targetNetwork == null ? 1 : targetNetwork
    });
  }
  clone() {
    return new EnsPlugin(this.address, this.targetNetwork);
  }
}
class FetchUrlFeeDataNetworkPlugin extends NetworkPlugin {
  /**
   *  Creates a new **FetchUrlFeeDataNetworkPlugin** which will
   *  be used when computing the fee data for the network.
   */
  constructor(url, processFunc) {
    super("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
    __privateAdd(this, _url2);
    __privateAdd(this, _processFunc);
    __privateSet(this, _url2, url);
    __privateSet(this, _processFunc, processFunc);
  }
  /**
   *  The URL to initialize the FetchRequest with in %%processFunc%%.
   */
  get url() {
    return __privateGet(this, _url2);
  }
  /**
   *  The callback to use when computing the FeeData.
   */
  get processFunc() {
    return __privateGet(this, _processFunc);
  }
  // We are immutable, so we can serve as our own clone
  clone() {
    return this;
  }
}
_url2 = new WeakMap();
_processFunc = new WeakMap();
const Networks = /* @__PURE__ */ new Map();
const _Network = class _Network {
  /**
   *  Creates a new **Network** for %%name%% and %%chainId%%.
   */
  constructor(name, chainId) {
    __privateAdd(this, _name);
    __privateAdd(this, _chainId2);
    __privateAdd(this, _plugins);
    __privateSet(this, _name, name);
    __privateSet(this, _chainId2, getBigInt(chainId));
    __privateSet(this, _plugins, /* @__PURE__ */ new Map());
  }
  /**
   *  Returns a JSON-compatible representation of a Network.
   */
  toJSON() {
    return { name: this.name, chainId: String(this.chainId) };
  }
  /**
   *  The network common name.
   *
   *  This is the canonical name, as networks migh have multiple
   *  names.
   */
  get name() {
    return __privateGet(this, _name);
  }
  set name(value) {
    __privateSet(this, _name, value);
  }
  /**
   *  The network chain ID.
   */
  get chainId() {
    return __privateGet(this, _chainId2);
  }
  set chainId(value) {
    __privateSet(this, _chainId2, getBigInt(value, "chainId"));
  }
  /**
   *  Returns true if %%other%% matches this network. Any chain ID
   *  must match, and if no chain ID is present, the name must match.
   *
   *  This method does not currently check for additional properties,
   *  such as ENS address or plug-in compatibility.
   */
  matches(other) {
    if (other == null) {
      return false;
    }
    if (typeof other === "string") {
      try {
        return this.chainId === getBigInt(other);
      } catch (error) {
      }
      return this.name === other;
    }
    if (typeof other === "number" || typeof other === "bigint") {
      try {
        return this.chainId === getBigInt(other);
      } catch (error) {
      }
      return false;
    }
    if (typeof other === "object") {
      if (other.chainId != null) {
        try {
          return this.chainId === getBigInt(other.chainId);
        } catch (error) {
        }
        return false;
      }
      if (other.name != null) {
        return this.name === other.name;
      }
      return false;
    }
    return false;
  }
  /**
   *  Returns the list of plugins currently attached to this Network.
   */
  get plugins() {
    return Array.from(__privateGet(this, _plugins).values());
  }
  /**
   *  Attach a new %%plugin%% to this Network. The network name
   *  must be unique, excluding any fragment.
   */
  attachPlugin(plugin) {
    if (__privateGet(this, _plugins).get(plugin.name)) {
      throw new Error(`cannot replace existing plugin: ${plugin.name} `);
    }
    __privateGet(this, _plugins).set(plugin.name, plugin.clone());
    return this;
  }
  /**
   *  Return the plugin, if any, matching %%name%% exactly. Plugins
   *  with fragments will not be returned unless %%name%% includes
   *  a fragment.
   */
  getPlugin(name) {
    return __privateGet(this, _plugins).get(name) || null;
  }
  /**
   *  Gets a list of all plugins that match %%name%%, with otr without
   *  a fragment.
   */
  getPlugins(basename2) {
    return this.plugins.filter((p2) => p2.name.split("#")[0] === basename2);
  }
  /**
   *  Create a copy of this Network.
   */
  clone() {
    const clone = new _Network(this.name, this.chainId);
    this.plugins.forEach((plugin) => {
      clone.attachPlugin(plugin.clone());
    });
    return clone;
  }
  /**
   *  Compute the intrinsic gas required for a transaction.
   *
   *  A GasCostPlugin can be attached to override the default
   *  values.
   */
  computeIntrinsicGas(tx) {
    const costs = this.getPlugin("org.ethers.plugins.network.GasCost") || new GasCostPlugin();
    let gas = costs.txBase;
    if (tx.to == null) {
      gas += costs.txCreate;
    }
    if (tx.data) {
      for (let i = 2; i < tx.data.length; i += 2) {
        if (tx.data.substring(i, i + 2) === "00") {
          gas += costs.txDataZero;
        } else {
          gas += costs.txDataNonzero;
        }
      }
    }
    if (tx.accessList) {
      const accessList = accessListify(tx.accessList);
      for (const addr in accessList) {
        gas += costs.txAccessListAddress + costs.txAccessListStorageKey * accessList[addr].storageKeys.length;
      }
    }
    return gas;
  }
  /**
   *  Returns a new Network for the %%network%% name or chainId.
   */
  static from(network) {
    injectCommonNetworks();
    if (network == null) {
      return _Network.from("mainnet");
    }
    if (typeof network === "number") {
      network = BigInt(network);
    }
    if (typeof network === "string" || typeof network === "bigint") {
      const networkFunc = Networks.get(network);
      if (networkFunc) {
        return networkFunc();
      }
      if (typeof network === "bigint") {
        return new _Network("unknown", network);
      }
      assertArgument(false, "unknown network", "network", network);
    }
    if (typeof network.clone === "function") {
      const clone = network.clone();
      return clone;
    }
    if (typeof network === "object") {
      assertArgument(typeof network.name === "string" && typeof network.chainId === "number", "invalid network object name or chainId", "network", network);
      const custom = new _Network(network.name, network.chainId);
      if (network.ensAddress || network.ensNetwork != null) {
        custom.attachPlugin(new EnsPlugin(network.ensAddress, network.ensNetwork));
      }
      return custom;
    }
    assertArgument(false, "invalid network", "network", network);
  }
  /**
   *  Register %%nameOrChainId%% with a function which returns
   *  an instance of a Network representing that chain.
   */
  static register(nameOrChainId, networkFunc) {
    if (typeof nameOrChainId === "number") {
      nameOrChainId = BigInt(nameOrChainId);
    }
    const existing = Networks.get(nameOrChainId);
    if (existing) {
      assertArgument(false, `conflicting network for ${JSON.stringify(existing.name)}`, "nameOrChainId", nameOrChainId);
    }
    Networks.set(nameOrChainId, networkFunc);
  }
};
_name = new WeakMap();
_chainId2 = new WeakMap();
_plugins = new WeakMap();
let Network = _Network;
function parseUnits(_value2, decimals) {
  const value = String(_value2);
  if (!value.match(/^[0-9.]+$/)) {
    throw new Error(`invalid gwei value: ${_value2}`);
  }
  const comps = value.split(".");
  if (comps.length === 1) {
    comps.push("");
  }
  if (comps.length !== 2) {
    throw new Error(`invalid gwei value: ${_value2}`);
  }
  while (comps[1].length < decimals) {
    comps[1] += "0";
  }
  if (comps[1].length > 9) {
    let frac = BigInt(comps[1].substring(0, 9));
    if (!comps[1].substring(9).match(/^0+$/)) {
      frac++;
    }
    comps[1] = frac.toString();
  }
  return BigInt(comps[0] + comps[1]);
}
function getGasStationPlugin(url) {
  return new FetchUrlFeeDataNetworkPlugin(url, async (fetchFeeData, provider, request2) => {
    request2.setHeader("User-Agent", "ethers");
    let response;
    try {
      const [_response, _feeData] = await Promise.all([
        request2.send(),
        fetchFeeData()
      ]);
      response = _response;
      const payload = response.bodyJson.standard;
      const feeData = {
        gasPrice: _feeData.gasPrice,
        maxFeePerGas: parseUnits(payload.maxFee, 9),
        maxPriorityFeePerGas: parseUnits(payload.maxPriorityFee, 9)
      };
      return feeData;
    } catch (error) {
      assert(false, `error encountered with polygon gas station (${JSON.stringify(request2.url)})`, "SERVER_ERROR", { request: request2, response, error });
    }
  });
}
let injected = false;
function injectCommonNetworks() {
  if (injected) {
    return;
  }
  injected = true;
  function registerEth(name, chainId, options) {
    const func = function() {
      const network = new Network(name, chainId);
      if (options.ensNetwork != null) {
        network.attachPlugin(new EnsPlugin(null, options.ensNetwork));
      }
      network.attachPlugin(new GasCostPlugin());
      (options.plugins || []).forEach((plugin) => {
        network.attachPlugin(plugin);
      });
      return network;
    };
    Network.register(name, func);
    Network.register(chainId, func);
    if (options.altNames) {
      options.altNames.forEach((name2) => {
        Network.register(name2, func);
      });
    }
  }
  registerEth("mainnet", 1, { ensNetwork: 1, altNames: ["homestead"] });
  registerEth("ropsten", 3, { ensNetwork: 3 });
  registerEth("rinkeby", 4, { ensNetwork: 4 });
  registerEth("goerli", 5, { ensNetwork: 5 });
  registerEth("kovan", 42, { ensNetwork: 42 });
  registerEth("sepolia", 11155111, { ensNetwork: 11155111 });
  registerEth("holesky", 17e3, { ensNetwork: 17e3 });
  registerEth("classic", 61, {});
  registerEth("classicKotti", 6, {});
  registerEth("arbitrum", 42161, {
    ensNetwork: 1
  });
  registerEth("arbitrum-goerli", 421613, {});
  registerEth("arbitrum-sepolia", 421614, {});
  registerEth("base", 8453, { ensNetwork: 1 });
  registerEth("base-goerli", 84531, {});
  registerEth("base-sepolia", 84532, {});
  registerEth("bnb", 56, { ensNetwork: 1 });
  registerEth("bnbt", 97, {});
  registerEth("linea", 59144, { ensNetwork: 1 });
  registerEth("linea-goerli", 59140, {});
  registerEth("linea-sepolia", 59141, {});
  registerEth("matic", 137, {
    ensNetwork: 1,
    plugins: [
      getGasStationPlugin("https://gasstation.polygon.technology/v2")
    ]
  });
  registerEth("matic-amoy", 80002, {});
  registerEth("matic-mumbai", 80001, {
    altNames: ["maticMumbai", "maticmum"],
    plugins: [
      getGasStationPlugin("https://gasstation-testnet.polygon.technology/v2")
    ]
  });
  registerEth("optimism", 10, {
    ensNetwork: 1,
    plugins: []
  });
  registerEth("optimism-goerli", 420, {});
  registerEth("optimism-sepolia", 11155420, {});
  registerEth("xdai", 100, { ensNetwork: 1 });
}
function copy$2(obj) {
  return JSON.parse(JSON.stringify(obj));
}
class PollingBlockSubscriber {
  /**
   *  Create a new **PollingBlockSubscriber** attached to %%provider%%.
   */
  constructor(provider) {
    __privateAdd(this, _PollingBlockSubscriber_instances);
    __privateAdd(this, _provider);
    __privateAdd(this, _poller);
    __privateAdd(this, _interval);
    // The most recent block we have scanned for events. The value -2
    // indicates we still need to fetch an initial block number
    __privateAdd(this, _blockNumber);
    __privateSet(this, _provider, provider);
    __privateSet(this, _poller, null);
    __privateSet(this, _interval, 4e3);
    __privateSet(this, _blockNumber, -2);
  }
  /**
   *  The polling interval.
   */
  get pollingInterval() {
    return __privateGet(this, _interval);
  }
  set pollingInterval(value) {
    __privateSet(this, _interval, value);
  }
  start() {
    if (__privateGet(this, _poller)) {
      return;
    }
    __privateSet(this, _poller, __privateGet(this, _provider)._setTimeout(__privateMethod(this, _PollingBlockSubscriber_instances, poll_fn).bind(this), __privateGet(this, _interval)));
    __privateMethod(this, _PollingBlockSubscriber_instances, poll_fn).call(this);
  }
  stop() {
    if (!__privateGet(this, _poller)) {
      return;
    }
    __privateGet(this, _provider)._clearTimeout(__privateGet(this, _poller));
    __privateSet(this, _poller, null);
  }
  pause(dropWhilePaused) {
    this.stop();
    if (dropWhilePaused) {
      __privateSet(this, _blockNumber, -2);
    }
  }
  resume() {
    this.start();
  }
}
_provider = new WeakMap();
_poller = new WeakMap();
_interval = new WeakMap();
_blockNumber = new WeakMap();
_PollingBlockSubscriber_instances = new WeakSet();
poll_fn = async function() {
  try {
    const blockNumber = await __privateGet(this, _provider).getBlockNumber();
    if (__privateGet(this, _blockNumber) === -2) {
      __privateSet(this, _blockNumber, blockNumber);
      return;
    }
    if (blockNumber !== __privateGet(this, _blockNumber)) {
      for (let b2 = __privateGet(this, _blockNumber) + 1; b2 <= blockNumber; b2++) {
        if (__privateGet(this, _poller) == null) {
          return;
        }
        await __privateGet(this, _provider).emit("block", b2);
      }
      __privateSet(this, _blockNumber, blockNumber);
    }
  } catch (error) {
  }
  if (__privateGet(this, _poller) == null) {
    return;
  }
  __privateSet(this, _poller, __privateGet(this, _provider)._setTimeout(__privateMethod(this, _PollingBlockSubscriber_instances, poll_fn).bind(this), __privateGet(this, _interval)));
};
class OnBlockSubscriber {
  /**
   *  Create a new **OnBlockSubscriber** attached to %%provider%%.
   */
  constructor(provider) {
    __privateAdd(this, _provider2);
    __privateAdd(this, _poll);
    __privateAdd(this, _running);
    __privateSet(this, _provider2, provider);
    __privateSet(this, _running, false);
    __privateSet(this, _poll, (blockNumber) => {
      this._poll(blockNumber, __privateGet(this, _provider2));
    });
  }
  /**
   *  Called on every new block.
   */
  async _poll(blockNumber, provider) {
    throw new Error("sub-classes must override this");
  }
  start() {
    if (__privateGet(this, _running)) {
      return;
    }
    __privateSet(this, _running, true);
    __privateGet(this, _poll).call(this, -2);
    __privateGet(this, _provider2).on("block", __privateGet(this, _poll));
  }
  stop() {
    if (!__privateGet(this, _running)) {
      return;
    }
    __privateSet(this, _running, false);
    __privateGet(this, _provider2).off("block", __privateGet(this, _poll));
  }
  pause(dropWhilePaused) {
    this.stop();
  }
  resume() {
    this.start();
  }
}
_provider2 = new WeakMap();
_poll = new WeakMap();
_running = new WeakMap();
class PollingBlockTagSubscriber extends OnBlockSubscriber {
  constructor(provider, tag) {
    super(provider);
    __privateAdd(this, _tag);
    __privateAdd(this, _lastBlock);
    __privateSet(this, _tag, tag);
    __privateSet(this, _lastBlock, -2);
  }
  pause(dropWhilePaused) {
    if (dropWhilePaused) {
      __privateSet(this, _lastBlock, -2);
    }
    super.pause(dropWhilePaused);
  }
  async _poll(blockNumber, provider) {
    const block = await provider.getBlock(__privateGet(this, _tag));
    if (block == null) {
      return;
    }
    if (__privateGet(this, _lastBlock) === -2) {
      __privateSet(this, _lastBlock, block.number);
    } else if (block.number > __privateGet(this, _lastBlock)) {
      provider.emit(__privateGet(this, _tag), block.number);
      __privateSet(this, _lastBlock, block.number);
    }
  }
}
_tag = new WeakMap();
_lastBlock = new WeakMap();
class PollingOrphanSubscriber extends OnBlockSubscriber {
  constructor(provider, filter) {
    super(provider);
    __privateAdd(this, _filter2);
    __privateSet(this, _filter2, copy$2(filter));
  }
  async _poll(blockNumber, provider) {
    throw new Error("@TODO");
  }
}
_filter2 = new WeakMap();
class PollingTransactionSubscriber extends OnBlockSubscriber {
  /**
   *  Create a new **PollingTransactionSubscriber** attached to
   *  %%provider%%, listening for %%hash%%.
   */
  constructor(provider, hash) {
    super(provider);
    __privateAdd(this, _hash);
    __privateSet(this, _hash, hash);
  }
  async _poll(blockNumber, provider) {
    const tx = await provider.getTransactionReceipt(__privateGet(this, _hash));
    if (tx) {
      provider.emit(__privateGet(this, _hash), tx);
    }
  }
}
_hash = new WeakMap();
class PollingEventSubscriber {
  /**
   *  Create a new **PollingTransactionSubscriber** attached to
   *  %%provider%%, listening for %%filter%%.
   */
  constructor(provider, filter) {
    __privateAdd(this, _PollingEventSubscriber_instances);
    __privateAdd(this, _provider3);
    __privateAdd(this, _filter3);
    __privateAdd(this, _poller2);
    __privateAdd(this, _running2);
    // The most recent block we have scanned for events. The value -2
    // indicates we still need to fetch an initial block number
    __privateAdd(this, _blockNumber2);
    __privateSet(this, _provider3, provider);
    __privateSet(this, _filter3, copy$2(filter));
    __privateSet(this, _poller2, __privateMethod(this, _PollingEventSubscriber_instances, poll_fn2).bind(this));
    __privateSet(this, _running2, false);
    __privateSet(this, _blockNumber2, -2);
  }
  start() {
    if (__privateGet(this, _running2)) {
      return;
    }
    __privateSet(this, _running2, true);
    if (__privateGet(this, _blockNumber2) === -2) {
      __privateGet(this, _provider3).getBlockNumber().then((blockNumber) => {
        __privateSet(this, _blockNumber2, blockNumber);
      });
    }
    __privateGet(this, _provider3).on("block", __privateGet(this, _poller2));
  }
  stop() {
    if (!__privateGet(this, _running2)) {
      return;
    }
    __privateSet(this, _running2, false);
    __privateGet(this, _provider3).off("block", __privateGet(this, _poller2));
  }
  pause(dropWhilePaused) {
    this.stop();
    if (dropWhilePaused) {
      __privateSet(this, _blockNumber2, -2);
    }
  }
  resume() {
    this.start();
  }
}
_provider3 = new WeakMap();
_filter3 = new WeakMap();
_poller2 = new WeakMap();
_running2 = new WeakMap();
_blockNumber2 = new WeakMap();
_PollingEventSubscriber_instances = new WeakSet();
poll_fn2 = async function(blockNumber) {
  if (__privateGet(this, _blockNumber2) === -2) {
    return;
  }
  const filter = copy$2(__privateGet(this, _filter3));
  filter.fromBlock = __privateGet(this, _blockNumber2) + 1;
  filter.toBlock = blockNumber;
  const logs = await __privateGet(this, _provider3).getLogs(filter);
  if (logs.length === 0) {
    if (__privateGet(this, _blockNumber2) < blockNumber - 60) {
      __privateSet(this, _blockNumber2, blockNumber - 60);
    }
    return;
  }
  for (const log of logs) {
    __privateGet(this, _provider3).emit(__privateGet(this, _filter3), log);
    __privateSet(this, _blockNumber2, log.blockNumber);
  }
};
const BN_2 = BigInt(2);
const MAX_CCIP_REDIRECTS = 10;
function isPromise(value) {
  return value && typeof value.then === "function";
}
function getTag(prefix, value) {
  return prefix + ":" + JSON.stringify(value, (k2, v2) => {
    if (v2 == null) {
      return "null";
    }
    if (typeof v2 === "bigint") {
      return `bigint:${v2.toString()}`;
    }
    if (typeof v2 === "string") {
      return v2.toLowerCase();
    }
    if (typeof v2 === "object" && !Array.isArray(v2)) {
      const keys = Object.keys(v2);
      keys.sort();
      return keys.reduce((accum, key) => {
        accum[key] = v2[key];
        return accum;
      }, {});
    }
    return v2;
  });
}
class UnmanagedSubscriber {
  /**
   *  Create a new UnmanagedSubscriber with %%name%%.
   */
  constructor(name) {
    /**
     *  The name fof the event.
     */
    __publicField(this, "name");
    defineProperties(this, { name });
  }
  start() {
  }
  stop() {
  }
  pause(dropWhilePaused) {
  }
  resume() {
  }
}
function copy$1(value) {
  return JSON.parse(JSON.stringify(value));
}
function concisify(items) {
  items = Array.from(new Set(items).values());
  items.sort();
  return items;
}
async function getSubscription(_event2, provider) {
  if (_event2 == null) {
    throw new Error("invalid event");
  }
  if (Array.isArray(_event2)) {
    _event2 = { topics: _event2 };
  }
  if (typeof _event2 === "string") {
    switch (_event2) {
      case "block":
      case "debug":
      case "error":
      case "finalized":
      case "network":
      case "pending":
      case "safe": {
        return { type: _event2, tag: _event2 };
      }
    }
  }
  if (isHexString(_event2, 32)) {
    const hash = _event2.toLowerCase();
    return { type: "transaction", tag: getTag("tx", { hash }), hash };
  }
  if (_event2.orphan) {
    const event = _event2;
    return { type: "orphan", tag: getTag("orphan", event), filter: copy$1(event) };
  }
  if (_event2.address || _event2.topics) {
    const event = _event2;
    const filter = {
      topics: (event.topics || []).map((t) => {
        if (t == null) {
          return null;
        }
        if (Array.isArray(t)) {
          return concisify(t.map((t2) => t2.toLowerCase()));
        }
        return t.toLowerCase();
      })
    };
    if (event.address) {
      const addresses = [];
      const promises = [];
      const addAddress = (addr) => {
        if (isHexString(addr)) {
          addresses.push(addr);
        } else {
          promises.push((async () => {
            addresses.push(await resolveAddress(addr, provider));
          })());
        }
      };
      if (Array.isArray(event.address)) {
        event.address.forEach(addAddress);
      } else {
        addAddress(event.address);
      }
      if (promises.length) {
        await Promise.all(promises);
      }
      filter.address = concisify(addresses.map((a2) => a2.toLowerCase()));
    }
    return { filter, tag: getTag("event", filter), type: "event" };
  }
  assertArgument(false, "unknown ProviderEvent", "event", _event2);
}
function getTime() {
  return (/* @__PURE__ */ new Date()).getTime();
}
const defaultOptions$1 = {
  cacheTimeout: 250,
  pollingInterval: 4e3
};
class AbstractProvider {
  /**
   *  Create a new **AbstractProvider** connected to %%network%%, or
   *  use the various network detection capabilities to discover the
   *  [[Network]] if necessary.
   */
  constructor(_network3, options) {
    __privateAdd(this, _AbstractProvider_instances);
    __privateAdd(this, _subs);
    __privateAdd(this, _plugins2);
    // null=unpaused, true=paused+dropWhilePaused, false=paused
    __privateAdd(this, _pausedState);
    __privateAdd(this, _destroyed);
    __privateAdd(this, _networkPromise);
    __privateAdd(this, _anyNetwork);
    __privateAdd(this, _performCache);
    // The most recent block number if running an event or -1 if no "block" event
    __privateAdd(this, _lastBlockNumber);
    __privateAdd(this, _nextTimer);
    __privateAdd(this, _timers);
    __privateAdd(this, _disableCcipRead);
    __privateAdd(this, _options2);
    __privateSet(this, _options2, Object.assign({}, defaultOptions$1, options || {}));
    if (_network3 === "any") {
      __privateSet(this, _anyNetwork, true);
      __privateSet(this, _networkPromise, null);
    } else if (_network3) {
      const network = Network.from(_network3);
      __privateSet(this, _anyNetwork, false);
      __privateSet(this, _networkPromise, Promise.resolve(network));
      setTimeout(() => {
        this.emit("network", network, null);
      }, 0);
    } else {
      __privateSet(this, _anyNetwork, false);
      __privateSet(this, _networkPromise, null);
    }
    __privateSet(this, _lastBlockNumber, -1);
    __privateSet(this, _performCache, /* @__PURE__ */ new Map());
    __privateSet(this, _subs, /* @__PURE__ */ new Map());
    __privateSet(this, _plugins2, /* @__PURE__ */ new Map());
    __privateSet(this, _pausedState, null);
    __privateSet(this, _destroyed, false);
    __privateSet(this, _nextTimer, 1);
    __privateSet(this, _timers, /* @__PURE__ */ new Map());
    __privateSet(this, _disableCcipRead, false);
  }
  get pollingInterval() {
    return __privateGet(this, _options2).pollingInterval;
  }
  /**
   *  Returns ``this``, to allow an **AbstractProvider** to implement
   *  the [[ContractRunner]] interface.
   */
  get provider() {
    return this;
  }
  /**
   *  Returns all the registered plug-ins.
   */
  get plugins() {
    return Array.from(__privateGet(this, _plugins2).values());
  }
  /**
   *  Attach a new plug-in.
   */
  attachPlugin(plugin) {
    if (__privateGet(this, _plugins2).get(plugin.name)) {
      throw new Error(`cannot replace existing plugin: ${plugin.name} `);
    }
    __privateGet(this, _plugins2).set(plugin.name, plugin.connect(this));
    return this;
  }
  /**
   *  Get a plugin by name.
   */
  getPlugin(name) {
    return __privateGet(this, _plugins2).get(name) || null;
  }
  /**
   *  Prevent any CCIP-read operation, regardless of whether requested
   *  in a [[call]] using ``enableCcipRead``.
   */
  get disableCcipRead() {
    return __privateGet(this, _disableCcipRead);
  }
  set disableCcipRead(value) {
    __privateSet(this, _disableCcipRead, !!value);
  }
  /**
   *  Resolves to the data for executing the CCIP-read operations.
   */
  async ccipReadFetch(tx, calldata, urls) {
    if (this.disableCcipRead || urls.length === 0 || tx.to == null) {
      return null;
    }
    const sender = tx.to.toLowerCase();
    const data = calldata.toLowerCase();
    const errorMessages = [];
    for (let i = 0; i < urls.length; i++) {
      const url = urls[i];
      const href = url.replace("{sender}", sender).replace("{data}", data);
      const request2 = new FetchRequest(href);
      if (url.indexOf("{data}") === -1) {
        request2.body = { data, sender };
      }
      this.emit("debug", { action: "sendCcipReadFetchRequest", request: request2, index: i, urls });
      let errorMessage = "unknown error";
      let resp;
      try {
        resp = await request2.send();
      } catch (error) {
        errorMessages.push(error.message);
        this.emit("debug", { action: "receiveCcipReadFetchError", request: request2, result: { error } });
        continue;
      }
      try {
        const result = resp.bodyJson;
        if (result.data) {
          this.emit("debug", { action: "receiveCcipReadFetchResult", request: request2, result });
          return result.data;
        }
        if (result.message) {
          errorMessage = result.message;
        }
        this.emit("debug", { action: "receiveCcipReadFetchError", request: request2, result });
      } catch (error) {
      }
      assert(resp.statusCode < 400 || resp.statusCode >= 500, `response not found during CCIP fetch: ${errorMessage}`, "OFFCHAIN_FAULT", { reason: "404_MISSING_RESOURCE", transaction: tx, info: { url, errorMessage } });
      errorMessages.push(errorMessage);
    }
    assert(false, `error encountered during CCIP fetch: ${errorMessages.map((m2) => JSON.stringify(m2)).join(", ")}`, "OFFCHAIN_FAULT", {
      reason: "500_SERVER_ERROR",
      transaction: tx,
      info: { urls, errorMessages }
    });
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a block before
   *  returning it, to add additional properties or an alternate
   *  sub-class of [[Block]].
   */
  _wrapBlock(value, network) {
    return new Block(formatBlock(value), this);
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a log before
   *  returning it, to add additional properties or an alternate
   *  sub-class of [[Log]].
   */
  _wrapLog(value, network) {
    return new Log(formatLog(value), this);
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a transaction
   *  receipt before returning it, to add additional properties or an
   *  alternate sub-class of [[TransactionReceipt]].
   */
  _wrapTransactionReceipt(value, network) {
    return new TransactionReceipt(formatTransactionReceipt(value), this);
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a transaction
   *  response before returning it, to add additional properties or an
   *  alternate sub-class of [[TransactionResponse]].
   */
  _wrapTransactionResponse(tx, network) {
    return new TransactionResponse(formatTransactionResponse(tx), this);
  }
  /**
   *  Resolves to the Network, forcing a network detection using whatever
   *  technique the sub-class requires.
   *
   *  Sub-classes **must** override this.
   */
  _detectNetwork() {
    assert(false, "sub-classes must implement this", "UNSUPPORTED_OPERATION", {
      operation: "_detectNetwork"
    });
  }
  /**
   *  Sub-classes should use this to perform all built-in operations. All
   *  methods sanitizes and normalizes the values passed into this.
   *
   *  Sub-classes **must** override this.
   */
  async _perform(req) {
    assert(false, `unsupported method: ${req.method}`, "UNSUPPORTED_OPERATION", {
      operation: req.method,
      info: req
    });
  }
  // State
  async getBlockNumber() {
    const blockNumber = getNumber(await __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, { method: "getBlockNumber" }), "%response");
    if (__privateGet(this, _lastBlockNumber) >= 0) {
      __privateSet(this, _lastBlockNumber, blockNumber);
    }
    return blockNumber;
  }
  /**
   *  Returns or resolves to the address for %%address%%, resolving ENS
   *  names and [[Addressable]] objects and returning if already an
   *  address.
   */
  _getAddress(address) {
    return resolveAddress(address, this);
  }
  /**
   *  Returns or resolves to a valid block tag for %%blockTag%%, resolving
   *  negative values and returning if already a valid block tag.
   */
  _getBlockTag(blockTag) {
    if (blockTag == null) {
      return "latest";
    }
    switch (blockTag) {
      case "earliest":
        return "0x0";
      case "finalized":
      case "latest":
      case "pending":
      case "safe":
        return blockTag;
    }
    if (isHexString(blockTag)) {
      if (isHexString(blockTag, 32)) {
        return blockTag;
      }
      return toQuantity(blockTag);
    }
    if (typeof blockTag === "bigint") {
      blockTag = getNumber(blockTag, "blockTag");
    }
    if (typeof blockTag === "number") {
      if (blockTag >= 0) {
        return toQuantity(blockTag);
      }
      if (__privateGet(this, _lastBlockNumber) >= 0) {
        return toQuantity(__privateGet(this, _lastBlockNumber) + blockTag);
      }
      return this.getBlockNumber().then((b2) => toQuantity(b2 + blockTag));
    }
    assertArgument(false, "invalid blockTag", "blockTag", blockTag);
  }
  /**
   *  Returns or resolves to a filter for %%filter%%, resolving any ENS
   *  names or [[Addressable]] object and returning if already a valid
   *  filter.
   */
  _getFilter(filter) {
    const topics = (filter.topics || []).map((t) => {
      if (t == null) {
        return null;
      }
      if (Array.isArray(t)) {
        return concisify(t.map((t2) => t2.toLowerCase()));
      }
      return t.toLowerCase();
    });
    const blockHash = "blockHash" in filter ? filter.blockHash : void 0;
    const resolve = (_address, fromBlock2, toBlock2) => {
      let address2 = void 0;
      switch (_address.length) {
        case 0:
          break;
        case 1:
          address2 = _address[0];
          break;
        default:
          _address.sort();
          address2 = _address;
      }
      if (blockHash) {
        if (fromBlock2 != null || toBlock2 != null) {
          throw new Error("invalid filter");
        }
      }
      const filter2 = {};
      if (address2) {
        filter2.address = address2;
      }
      if (topics.length) {
        filter2.topics = topics;
      }
      if (fromBlock2) {
        filter2.fromBlock = fromBlock2;
      }
      if (toBlock2) {
        filter2.toBlock = toBlock2;
      }
      if (blockHash) {
        filter2.blockHash = blockHash;
      }
      return filter2;
    };
    let address = [];
    if (filter.address) {
      if (Array.isArray(filter.address)) {
        for (const addr of filter.address) {
          address.push(this._getAddress(addr));
        }
      } else {
        address.push(this._getAddress(filter.address));
      }
    }
    let fromBlock = void 0;
    if ("fromBlock" in filter) {
      fromBlock = this._getBlockTag(filter.fromBlock);
    }
    let toBlock = void 0;
    if ("toBlock" in filter) {
      toBlock = this._getBlockTag(filter.toBlock);
    }
    if (address.filter((a2) => typeof a2 !== "string").length || fromBlock != null && typeof fromBlock !== "string" || toBlock != null && typeof toBlock !== "string") {
      return Promise.all([Promise.all(address), fromBlock, toBlock]).then((result) => {
        return resolve(result[0], result[1], result[2]);
      });
    }
    return resolve(address, fromBlock, toBlock);
  }
  /**
   *  Returns or resolves to a transaction for %%request%%, resolving
   *  any ENS names or [[Addressable]] and returning if already a valid
   *  transaction.
   */
  _getTransactionRequest(_request3) {
    const request2 = copyRequest(_request3);
    const promises = [];
    ["to", "from"].forEach((key) => {
      if (request2[key] == null) {
        return;
      }
      const addr = resolveAddress(request2[key], this);
      if (isPromise(addr)) {
        promises.push(async function() {
          request2[key] = await addr;
        }());
      } else {
        request2[key] = addr;
      }
    });
    if (request2.blockTag != null) {
      const blockTag = this._getBlockTag(request2.blockTag);
      if (isPromise(blockTag)) {
        promises.push(async function() {
          request2.blockTag = await blockTag;
        }());
      } else {
        request2.blockTag = blockTag;
      }
    }
    if (promises.length) {
      return async function() {
        await Promise.all(promises);
        return request2;
      }();
    }
    return request2;
  }
  async getNetwork() {
    if (__privateGet(this, _networkPromise) == null) {
      const detectNetwork = (async () => {
        try {
          const network = await this._detectNetwork();
          this.emit("network", network, null);
          return network;
        } catch (error) {
          if (__privateGet(this, _networkPromise) === detectNetwork) {
            __privateSet(this, _networkPromise, null);
          }
          throw error;
        }
      })();
      __privateSet(this, _networkPromise, detectNetwork);
      return (await detectNetwork).clone();
    }
    const networkPromise = __privateGet(this, _networkPromise);
    const [expected, actual] = await Promise.all([
      networkPromise,
      this._detectNetwork()
      // The actual connected network
    ]);
    if (expected.chainId !== actual.chainId) {
      if (__privateGet(this, _anyNetwork)) {
        this.emit("network", actual, expected);
        if (__privateGet(this, _networkPromise) === networkPromise) {
          __privateSet(this, _networkPromise, Promise.resolve(actual));
        }
      } else {
        assert(false, `network changed: ${expected.chainId} => ${actual.chainId} `, "NETWORK_ERROR", {
          event: "changed"
        });
      }
    }
    return expected.clone();
  }
  async getFeeData() {
    const network = await this.getNetwork();
    const getFeeDataFunc = async () => {
      const { _block, gasPrice, priorityFee } = await resolveProperties({
        _block: __privateMethod(this, _AbstractProvider_instances, getBlock_fn).call(this, "latest", false),
        gasPrice: (async () => {
          try {
            const value = await __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, { method: "getGasPrice" });
            return getBigInt(value, "%response");
          } catch (error) {
          }
          return null;
        })(),
        priorityFee: (async () => {
          try {
            const value = await __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, { method: "getPriorityFee" });
            return getBigInt(value, "%response");
          } catch (error) {
          }
          return null;
        })()
      });
      let maxFeePerGas = null;
      let maxPriorityFeePerGas = null;
      const block = this._wrapBlock(_block, network);
      if (block && block.baseFeePerGas) {
        maxPriorityFeePerGas = priorityFee != null ? priorityFee : BigInt("1000000000");
        maxFeePerGas = block.baseFeePerGas * BN_2 + maxPriorityFeePerGas;
      }
      return new FeeData(gasPrice, maxFeePerGas, maxPriorityFeePerGas);
    };
    const plugin = network.getPlugin("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
    if (plugin) {
      const req = new FetchRequest(plugin.url);
      const feeData = await plugin.processFunc(getFeeDataFunc, this, req);
      return new FeeData(feeData.gasPrice, feeData.maxFeePerGas, feeData.maxPriorityFeePerGas);
    }
    return await getFeeDataFunc();
  }
  async estimateGas(_tx) {
    let tx = this._getTransactionRequest(_tx);
    if (isPromise(tx)) {
      tx = await tx;
    }
    return getBigInt(await __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, {
      method: "estimateGas",
      transaction: tx
    }), "%response");
  }
  async call(_tx) {
    const { tx, blockTag } = await resolveProperties({
      tx: this._getTransactionRequest(_tx),
      blockTag: this._getBlockTag(_tx.blockTag)
    });
    return await __privateMethod(this, _AbstractProvider_instances, checkNetwork_fn).call(this, __privateMethod(this, _AbstractProvider_instances, call_fn).call(this, tx, blockTag, _tx.enableCcipRead ? 0 : -1));
  }
  async getBalance(address, blockTag) {
    return getBigInt(await __privateMethod(this, _AbstractProvider_instances, getAccountValue_fn).call(this, { method: "getBalance" }, address, blockTag), "%response");
  }
  async getTransactionCount(address, blockTag) {
    return getNumber(await __privateMethod(this, _AbstractProvider_instances, getAccountValue_fn).call(this, { method: "getTransactionCount" }, address, blockTag), "%response");
  }
  async getCode(address, blockTag) {
    return hexlify(await __privateMethod(this, _AbstractProvider_instances, getAccountValue_fn).call(this, { method: "getCode" }, address, blockTag));
  }
  async getStorage(address, _position, blockTag) {
    const position = getBigInt(_position, "position");
    return hexlify(await __privateMethod(this, _AbstractProvider_instances, getAccountValue_fn).call(this, { method: "getStorage", position }, address, blockTag));
  }
  // Write
  async broadcastTransaction(signedTx) {
    const { blockNumber, hash, network } = await resolveProperties({
      blockNumber: this.getBlockNumber(),
      hash: this._perform({
        method: "broadcastTransaction",
        signedTransaction: signedTx
      }),
      network: this.getNetwork()
    });
    const tx = Transaction.from(signedTx);
    if (tx.hash !== hash) {
      throw new Error("@TODO: the returned hash did not match");
    }
    return this._wrapTransactionResponse(tx, network).replaceableTransaction(blockNumber);
  }
  // Queries
  async getBlock(block, prefetchTxs) {
    const { network, params } = await resolveProperties({
      network: this.getNetwork(),
      params: __privateMethod(this, _AbstractProvider_instances, getBlock_fn).call(this, block, !!prefetchTxs)
    });
    if (params == null) {
      return null;
    }
    return this._wrapBlock(params, network);
  }
  async getTransaction(hash) {
    const { network, params } = await resolveProperties({
      network: this.getNetwork(),
      params: __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, { method: "getTransaction", hash })
    });
    if (params == null) {
      return null;
    }
    return this._wrapTransactionResponse(params, network);
  }
  async getTransactionReceipt(hash) {
    const { network, params } = await resolveProperties({
      network: this.getNetwork(),
      params: __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, { method: "getTransactionReceipt", hash })
    });
    if (params == null) {
      return null;
    }
    if (params.gasPrice == null && params.effectiveGasPrice == null) {
      const tx = await __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, { method: "getTransaction", hash });
      if (tx == null) {
        throw new Error("report this; could not find tx or effectiveGasPrice");
      }
      params.effectiveGasPrice = tx.gasPrice;
    }
    return this._wrapTransactionReceipt(params, network);
  }
  async getTransactionResult(hash) {
    const { result } = await resolveProperties({
      network: this.getNetwork(),
      result: __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, { method: "getTransactionResult", hash })
    });
    if (result == null) {
      return null;
    }
    return hexlify(result);
  }
  // Bloom-filter Queries
  async getLogs(_filter4) {
    let filter = this._getFilter(_filter4);
    if (isPromise(filter)) {
      filter = await filter;
    }
    const { network, params } = await resolveProperties({
      network: this.getNetwork(),
      params: __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, { method: "getLogs", filter })
    });
    return params.map((p2) => this._wrapLog(p2, network));
  }
  // ENS
  _getProvider(chainId) {
    assert(false, "provider cannot connect to target network", "UNSUPPORTED_OPERATION", {
      operation: "_getProvider()"
    });
  }
  async getResolver(name) {
    return await EnsResolver.fromName(this, name);
  }
  async getAvatar(name) {
    const resolver = await this.getResolver(name);
    if (resolver) {
      return await resolver.getAvatar();
    }
    return null;
  }
  async resolveName(name) {
    const resolver = await this.getResolver(name);
    if (resolver) {
      return await resolver.getAddress();
    }
    return null;
  }
  async lookupAddress(address) {
    address = getAddress(address);
    const node = namehash(address.substring(2).toLowerCase() + ".addr.reverse");
    try {
      const ensAddr = await EnsResolver.getEnsAddress(this);
      const ensContract = new Contract(ensAddr, [
        "function resolver(bytes32) view returns (address)"
      ], this);
      const resolver = await ensContract.resolver(node);
      if (resolver == null || resolver === ZeroAddress) {
        return null;
      }
      const resolverContract = new Contract(resolver, [
        "function name(bytes32) view returns (string)"
      ], this);
      const name = await resolverContract.name(node);
      const check = await this.resolveName(name);
      if (check !== address) {
        return null;
      }
      return name;
    } catch (error) {
      if (isError(error, "BAD_DATA") && error.value === "0x") {
        return null;
      }
      if (isError(error, "CALL_EXCEPTION")) {
        return null;
      }
      throw error;
    }
    return null;
  }
  async waitForTransaction(hash, _confirms, timeout) {
    const confirms = _confirms != null ? _confirms : 1;
    if (confirms === 0) {
      return this.getTransactionReceipt(hash);
    }
    return new Promise(async (resolve, reject) => {
      let timer = null;
      const listener = async (blockNumber) => {
        try {
          const receipt = await this.getTransactionReceipt(hash);
          if (receipt != null) {
            if (blockNumber - receipt.blockNumber + 1 >= confirms) {
              resolve(receipt);
              if (timer) {
                clearTimeout(timer);
                timer = null;
              }
              return;
            }
          }
        } catch (error) {
          console.log("EEE", error);
        }
        this.once("block", listener);
      };
      if (timeout != null) {
        timer = setTimeout(() => {
          if (timer == null) {
            return;
          }
          timer = null;
          this.off("block", listener);
          reject(makeError("timeout", "TIMEOUT", { reason: "timeout" }));
        }, timeout);
      }
      listener(await this.getBlockNumber());
    });
  }
  async waitForBlock(blockTag) {
    assert(false, "not implemented yet", "NOT_IMPLEMENTED", {
      operation: "waitForBlock"
    });
  }
  /**
   *  Clear a timer created using the [[_setTimeout]] method.
   */
  _clearTimeout(timerId) {
    const timer = __privateGet(this, _timers).get(timerId);
    if (!timer) {
      return;
    }
    if (timer.timer) {
      clearTimeout(timer.timer);
    }
    __privateGet(this, _timers).delete(timerId);
  }
  /**
   *  Create a timer that will execute %%func%% after at least %%timeout%%
   *  (in ms). If %%timeout%% is unspecified, then %%func%% will execute
   *  in the next event loop.
   *
   *  [Pausing](AbstractProvider-paused) the provider will pause any
   *  associated timers.
   */
  _setTimeout(_func, timeout) {
    if (timeout == null) {
      timeout = 0;
    }
    const timerId = __privateWrapper(this, _nextTimer)._++;
    const func = () => {
      __privateGet(this, _timers).delete(timerId);
      _func();
    };
    if (this.paused) {
      __privateGet(this, _timers).set(timerId, { timer: null, func, time: timeout });
    } else {
      const timer = setTimeout(func, timeout);
      __privateGet(this, _timers).set(timerId, { timer, func, time: getTime() });
    }
    return timerId;
  }
  /**
   *  Perform %%func%% on each subscriber.
   */
  _forEachSubscriber(func) {
    for (const sub of __privateGet(this, _subs).values()) {
      func(sub.subscriber);
    }
  }
  /**
   *  Sub-classes may override this to customize subscription
   *  implementations.
   */
  _getSubscriber(sub) {
    switch (sub.type) {
      case "debug":
      case "error":
      case "network":
        return new UnmanagedSubscriber(sub.type);
      case "block": {
        const subscriber = new PollingBlockSubscriber(this);
        subscriber.pollingInterval = this.pollingInterval;
        return subscriber;
      }
      case "safe":
      case "finalized":
        return new PollingBlockTagSubscriber(this, sub.type);
      case "event":
        return new PollingEventSubscriber(this, sub.filter);
      case "transaction":
        return new PollingTransactionSubscriber(this, sub.hash);
      case "orphan":
        return new PollingOrphanSubscriber(this, sub.filter);
    }
    throw new Error(`unsupported event: ${sub.type}`);
  }
  /**
   *  If a [[Subscriber]] fails and needs to replace itself, this
   *  method may be used.
   *
   *  For example, this is used for providers when using the
   *  ``eth_getFilterChanges`` method, which can return null if state
   *  filters are not supported by the backend, allowing the Subscriber
   *  to swap in a [[PollingEventSubscriber]].
   */
  _recoverSubscriber(oldSub, newSub) {
    for (const sub of __privateGet(this, _subs).values()) {
      if (sub.subscriber === oldSub) {
        if (sub.started) {
          sub.subscriber.stop();
        }
        sub.subscriber = newSub;
        if (sub.started) {
          newSub.start();
        }
        if (__privateGet(this, _pausedState) != null) {
          newSub.pause(__privateGet(this, _pausedState));
        }
        break;
      }
    }
  }
  async on(event, listener) {
    const sub = await __privateMethod(this, _AbstractProvider_instances, getSub_fn).call(this, event);
    sub.listeners.push({ listener, once: false });
    if (!sub.started) {
      sub.subscriber.start();
      sub.started = true;
      if (__privateGet(this, _pausedState) != null) {
        sub.subscriber.pause(__privateGet(this, _pausedState));
      }
    }
    return this;
  }
  async once(event, listener) {
    const sub = await __privateMethod(this, _AbstractProvider_instances, getSub_fn).call(this, event);
    sub.listeners.push({ listener, once: true });
    if (!sub.started) {
      sub.subscriber.start();
      sub.started = true;
      if (__privateGet(this, _pausedState) != null) {
        sub.subscriber.pause(__privateGet(this, _pausedState));
      }
    }
    return this;
  }
  async emit(event, ...args) {
    const sub = await __privateMethod(this, _AbstractProvider_instances, hasSub_fn).call(this, event, args);
    if (!sub || sub.listeners.length === 0) {
      return false;
    }
    const count = sub.listeners.length;
    sub.listeners = sub.listeners.filter(({ listener, once }) => {
      const payload = new EventPayload(this, once ? null : listener, event);
      try {
        listener.call(this, ...args, payload);
      } catch (error) {
      }
      return !once;
    });
    if (sub.listeners.length === 0) {
      if (sub.started) {
        sub.subscriber.stop();
      }
      __privateGet(this, _subs).delete(sub.tag);
    }
    return count > 0;
  }
  async listenerCount(event) {
    if (event) {
      const sub = await __privateMethod(this, _AbstractProvider_instances, hasSub_fn).call(this, event);
      if (!sub) {
        return 0;
      }
      return sub.listeners.length;
    }
    let total = 0;
    for (const { listeners } of __privateGet(this, _subs).values()) {
      total += listeners.length;
    }
    return total;
  }
  async listeners(event) {
    if (event) {
      const sub = await __privateMethod(this, _AbstractProvider_instances, hasSub_fn).call(this, event);
      if (!sub) {
        return [];
      }
      return sub.listeners.map(({ listener }) => listener);
    }
    let result = [];
    for (const { listeners } of __privateGet(this, _subs).values()) {
      result = result.concat(listeners.map(({ listener }) => listener));
    }
    return result;
  }
  async off(event, listener) {
    const sub = await __privateMethod(this, _AbstractProvider_instances, hasSub_fn).call(this, event);
    if (!sub) {
      return this;
    }
    if (listener) {
      const index = sub.listeners.map(({ listener: listener2 }) => listener2).indexOf(listener);
      if (index >= 0) {
        sub.listeners.splice(index, 1);
      }
    }
    if (!listener || sub.listeners.length === 0) {
      if (sub.started) {
        sub.subscriber.stop();
      }
      __privateGet(this, _subs).delete(sub.tag);
    }
    return this;
  }
  async removeAllListeners(event) {
    if (event) {
      const { tag, started, subscriber } = await __privateMethod(this, _AbstractProvider_instances, getSub_fn).call(this, event);
      if (started) {
        subscriber.stop();
      }
      __privateGet(this, _subs).delete(tag);
    } else {
      for (const [tag, { started, subscriber }] of __privateGet(this, _subs)) {
        if (started) {
          subscriber.stop();
        }
        __privateGet(this, _subs).delete(tag);
      }
    }
    return this;
  }
  // Alias for "on"
  async addListener(event, listener) {
    return await this.on(event, listener);
  }
  // Alias for "off"
  async removeListener(event, listener) {
    return this.off(event, listener);
  }
  /**
   *  If this provider has been destroyed using the [[destroy]] method.
   *
   *  Once destroyed, all resources are reclaimed, internal event loops
   *  and timers are cleaned up and no further requests may be sent to
   *  the provider.
   */
  get destroyed() {
    return __privateGet(this, _destroyed);
  }
  /**
   *  Sub-classes may use this to shutdown any sockets or release their
   *  resources and reject any pending requests.
   *
   *  Sub-classes **must** call ``super.destroy()``.
   */
  destroy() {
    this.removeAllListeners();
    for (const timerId of __privateGet(this, _timers).keys()) {
      this._clearTimeout(timerId);
    }
    __privateSet(this, _destroyed, true);
  }
  /**
   *  Whether the provider is currently paused.
   *
   *  A paused provider will not emit any events, and generally should
   *  not make any requests to the network, but that is up to sub-classes
   *  to manage.
   *
   *  Setting ``paused = true`` is identical to calling ``.pause(false)``,
   *  which will buffer any events that occur while paused until the
   *  provider is unpaused.
   */
  get paused() {
    return __privateGet(this, _pausedState) != null;
  }
  set paused(pause) {
    if (!!pause === this.paused) {
      return;
    }
    if (this.paused) {
      this.resume();
    } else {
      this.pause(false);
    }
  }
  /**
   *  Pause the provider. If %%dropWhilePaused%%, any events that occur
   *  while paused are dropped, otherwise all events will be emitted once
   *  the provider is unpaused.
   */
  pause(dropWhilePaused) {
    __privateSet(this, _lastBlockNumber, -1);
    if (__privateGet(this, _pausedState) != null) {
      if (__privateGet(this, _pausedState) == !!dropWhilePaused) {
        return;
      }
      assert(false, "cannot change pause type; resume first", "UNSUPPORTED_OPERATION", {
        operation: "pause"
      });
    }
    this._forEachSubscriber((s) => s.pause(dropWhilePaused));
    __privateSet(this, _pausedState, !!dropWhilePaused);
    for (const timer of __privateGet(this, _timers).values()) {
      if (timer.timer) {
        clearTimeout(timer.timer);
      }
      timer.time = getTime() - timer.time;
    }
  }
  /**
   *  Resume the provider.
   */
  resume() {
    if (__privateGet(this, _pausedState) == null) {
      return;
    }
    this._forEachSubscriber((s) => s.resume());
    __privateSet(this, _pausedState, null);
    for (const timer of __privateGet(this, _timers).values()) {
      let timeout = timer.time;
      if (timeout < 0) {
        timeout = 0;
      }
      timer.time = getTime();
      setTimeout(timer.func, timeout);
    }
  }
}
_subs = new WeakMap();
_plugins2 = new WeakMap();
_pausedState = new WeakMap();
_destroyed = new WeakMap();
_networkPromise = new WeakMap();
_anyNetwork = new WeakMap();
_performCache = new WeakMap();
_lastBlockNumber = new WeakMap();
_nextTimer = new WeakMap();
_timers = new WeakMap();
_disableCcipRead = new WeakMap();
_options2 = new WeakMap();
_AbstractProvider_instances = new WeakSet();
perform_fn = async function(req) {
  const timeout = __privateGet(this, _options2).cacheTimeout;
  if (timeout < 0) {
    return await this._perform(req);
  }
  const tag = getTag(req.method, req);
  let perform = __privateGet(this, _performCache).get(tag);
  if (!perform) {
    perform = this._perform(req);
    __privateGet(this, _performCache).set(tag, perform);
    setTimeout(() => {
      if (__privateGet(this, _performCache).get(tag) === perform) {
        __privateGet(this, _performCache).delete(tag);
      }
    }, timeout);
  }
  return await perform;
};
call_fn = async function(tx, blockTag, attempt) {
  assert(attempt < MAX_CCIP_REDIRECTS, "CCIP read exceeded maximum redirections", "OFFCHAIN_FAULT", {
    reason: "TOO_MANY_REDIRECTS",
    transaction: Object.assign({}, tx, { blockTag, enableCcipRead: true })
  });
  const transaction = copyRequest(tx);
  try {
    return hexlify(await this._perform({ method: "call", transaction, blockTag }));
  } catch (error) {
    if (!this.disableCcipRead && isCallException(error) && error.data && attempt >= 0 && blockTag === "latest" && transaction.to != null && dataSlice(error.data, 0, 4) === "0x556f1830") {
      const data = error.data;
      const txSender = await resolveAddress(transaction.to, this);
      let ccipArgs;
      try {
        ccipArgs = parseOffchainLookup(dataSlice(error.data, 4));
      } catch (error2) {
        assert(false, error2.message, "OFFCHAIN_FAULT", {
          reason: "BAD_DATA",
          transaction,
          info: { data }
        });
      }
      assert(ccipArgs.sender.toLowerCase() === txSender.toLowerCase(), "CCIP Read sender mismatch", "CALL_EXCEPTION", {
        action: "call",
        data,
        reason: "OffchainLookup",
        transaction,
        invocation: null,
        revert: {
          signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
          name: "OffchainLookup",
          args: ccipArgs.errorArgs
        }
      });
      const ccipResult = await this.ccipReadFetch(transaction, ccipArgs.calldata, ccipArgs.urls);
      assert(ccipResult != null, "CCIP Read failed to fetch data", "OFFCHAIN_FAULT", {
        reason: "FETCH_FAILED",
        transaction,
        info: { data: error.data, errorArgs: ccipArgs.errorArgs }
      });
      const tx2 = {
        to: txSender,
        data: concat([ccipArgs.selector, encodeBytes([ccipResult, ccipArgs.extraData])])
      };
      this.emit("debug", { action: "sendCcipReadCall", transaction: tx2 });
      try {
        const result = await __privateMethod(this, _AbstractProvider_instances, call_fn).call(this, tx2, blockTag, attempt + 1);
        this.emit("debug", { action: "receiveCcipReadCallResult", transaction: Object.assign({}, tx2), result });
        return result;
      } catch (error2) {
        this.emit("debug", { action: "receiveCcipReadCallError", transaction: Object.assign({}, tx2), error: error2 });
        throw error2;
      }
    }
    throw error;
  }
};
checkNetwork_fn = async function(promise) {
  const { value } = await resolveProperties({
    network: this.getNetwork(),
    value: promise
  });
  return value;
};
getAccountValue_fn = async function(request2, _address, _blockTag) {
  let address = this._getAddress(_address);
  let blockTag = this._getBlockTag(_blockTag);
  if (typeof address !== "string" || typeof blockTag !== "string") {
    [address, blockTag] = await Promise.all([address, blockTag]);
  }
  return await __privateMethod(this, _AbstractProvider_instances, checkNetwork_fn).call(this, __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, Object.assign(request2, { address, blockTag })));
};
getBlock_fn = async function(block, includeTransactions) {
  if (isHexString(block, 32)) {
    return await __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, {
      method: "getBlock",
      blockHash: block,
      includeTransactions
    });
  }
  let blockTag = this._getBlockTag(block);
  if (typeof blockTag !== "string") {
    blockTag = await blockTag;
  }
  return await __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, {
    method: "getBlock",
    blockTag,
    includeTransactions
  });
};
hasSub_fn = async function(event, emitArgs) {
  let sub = await getSubscription(event, this);
  if (sub.type === "event" && emitArgs && emitArgs.length > 0 && emitArgs[0].removed === true) {
    sub = await getSubscription({ orphan: "drop-log", log: emitArgs[0] }, this);
  }
  return __privateGet(this, _subs).get(sub.tag) || null;
};
getSub_fn = async function(event) {
  const subscription = await getSubscription(event, this);
  const tag = subscription.tag;
  let sub = __privateGet(this, _subs).get(tag);
  if (!sub) {
    const subscriber = this._getSubscriber(subscription);
    const addressableMap = /* @__PURE__ */ new WeakMap();
    const nameMap = /* @__PURE__ */ new Map();
    sub = { subscriber, tag, addressableMap, nameMap, started: false, listeners: [] };
    __privateGet(this, _subs).set(tag, sub);
  }
  return sub;
};
function _parseString(result, start) {
  try {
    const bytes = _parseBytes(result, start);
    if (bytes) {
      return toUtf8String(bytes);
    }
  } catch (error) {
  }
  return null;
}
function _parseBytes(result, start) {
  if (result === "0x") {
    return null;
  }
  try {
    const offset = getNumber(dataSlice(result, start, start + 32));
    const length = getNumber(dataSlice(result, offset, offset + 32));
    return dataSlice(result, offset + 32, offset + 32 + length);
  } catch (error) {
  }
  return null;
}
function numPad(value) {
  const result = toBeArray(value);
  if (result.length > 32) {
    throw new Error("internal; should not happen");
  }
  const padded = new Uint8Array(32);
  padded.set(result, 32 - result.length);
  return padded;
}
function bytesPad(value) {
  if (value.length % 32 === 0) {
    return value;
  }
  const result = new Uint8Array(Math.ceil(value.length / 32) * 32);
  result.set(value);
  return result;
}
const empty = new Uint8Array([]);
function encodeBytes(datas) {
  const result = [];
  let byteCount = 0;
  for (let i = 0; i < datas.length; i++) {
    result.push(empty);
    byteCount += 32;
  }
  for (let i = 0; i < datas.length; i++) {
    const data = getBytes(datas[i]);
    result[i] = numPad(byteCount);
    result.push(numPad(data.length));
    result.push(bytesPad(data));
    byteCount += 32 + Math.ceil(data.length / 32) * 32;
  }
  return concat(result);
}
const zeros = "0x0000000000000000000000000000000000000000000000000000000000000000";
function parseOffchainLookup(data) {
  const result = {
    sender: "",
    urls: [],
    calldata: "",
    selector: "",
    extraData: "",
    errorArgs: []
  };
  assert(dataLength(data) >= 5 * 32, "insufficient OffchainLookup data", "OFFCHAIN_FAULT", {
    reason: "insufficient OffchainLookup data"
  });
  const sender = dataSlice(data, 0, 32);
  assert(dataSlice(sender, 0, 12) === dataSlice(zeros, 0, 12), "corrupt OffchainLookup sender", "OFFCHAIN_FAULT", {
    reason: "corrupt OffchainLookup sender"
  });
  result.sender = dataSlice(sender, 12);
  try {
    const urls = [];
    const urlsOffset = getNumber(dataSlice(data, 32, 64));
    const urlsLength = getNumber(dataSlice(data, urlsOffset, urlsOffset + 32));
    const urlsData = dataSlice(data, urlsOffset + 32);
    for (let u2 = 0; u2 < urlsLength; u2++) {
      const url = _parseString(urlsData, u2 * 32);
      if (url == null) {
        throw new Error("abort");
      }
      urls.push(url);
    }
    result.urls = urls;
  } catch (error) {
    assert(false, "corrupt OffchainLookup urls", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup urls"
    });
  }
  try {
    const calldata = _parseBytes(data, 64);
    if (calldata == null) {
      throw new Error("abort");
    }
    result.calldata = calldata;
  } catch (error) {
    assert(false, "corrupt OffchainLookup calldata", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup calldata"
    });
  }
  assert(dataSlice(data, 100, 128) === dataSlice(zeros, 0, 28), "corrupt OffchainLookup callbaackSelector", "OFFCHAIN_FAULT", {
    reason: "corrupt OffchainLookup callbaackSelector"
  });
  result.selector = dataSlice(data, 96, 100);
  try {
    const extraData = _parseBytes(data, 128);
    if (extraData == null) {
      throw new Error("abort");
    }
    result.extraData = extraData;
  } catch (error) {
    assert(false, "corrupt OffchainLookup extraData", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup extraData"
    });
  }
  result.errorArgs = "sender,urls,calldata,selector,extraData".split(/,/).map((k2) => result[k2]);
  return result;
}
function checkProvider(signer, operation) {
  if (signer.provider) {
    return signer.provider;
  }
  assert(false, "missing provider", "UNSUPPORTED_OPERATION", { operation });
}
async function populate(signer, tx) {
  let pop = copyRequest(tx);
  if (pop.to != null) {
    pop.to = resolveAddress(pop.to, signer);
  }
  if (pop.from != null) {
    const from = pop.from;
    pop.from = Promise.all([
      signer.getAddress(),
      resolveAddress(from, signer)
    ]).then(([address, from2]) => {
      assertArgument(address.toLowerCase() === from2.toLowerCase(), "transaction from mismatch", "tx.from", from2);
      return address;
    });
  } else {
    pop.from = signer.getAddress();
  }
  return await resolveProperties(pop);
}
class AbstractSigner {
  /**
   *  Creates a new Signer connected to %%provider%%.
   */
  constructor(provider) {
    /**
     *  The provider this signer is connected to.
     */
    __publicField(this, "provider");
    defineProperties(this, { provider: provider || null });
  }
  async getNonce(blockTag) {
    return checkProvider(this, "getTransactionCount").getTransactionCount(await this.getAddress(), blockTag);
  }
  async populateCall(tx) {
    const pop = await populate(this, tx);
    return pop;
  }
  async populateTransaction(tx) {
    const provider = checkProvider(this, "populateTransaction");
    const pop = await populate(this, tx);
    if (pop.nonce == null) {
      pop.nonce = await this.getNonce("pending");
    }
    if (pop.gasLimit == null) {
      pop.gasLimit = await this.estimateGas(pop);
    }
    const network = await this.provider.getNetwork();
    if (pop.chainId != null) {
      const chainId = getBigInt(pop.chainId);
      assertArgument(chainId === network.chainId, "transaction chainId mismatch", "tx.chainId", tx.chainId);
    } else {
      pop.chainId = network.chainId;
    }
    const hasEip1559 = pop.maxFeePerGas != null || pop.maxPriorityFeePerGas != null;
    if (pop.gasPrice != null && (pop.type === 2 || hasEip1559)) {
      assertArgument(false, "eip-1559 transaction do not support gasPrice", "tx", tx);
    } else if ((pop.type === 0 || pop.type === 1) && hasEip1559) {
      assertArgument(false, "pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "tx", tx);
    }
    if ((pop.type === 2 || pop.type == null) && (pop.maxFeePerGas != null && pop.maxPriorityFeePerGas != null)) {
      pop.type = 2;
    } else if (pop.type === 0 || pop.type === 1) {
      const feeData = await provider.getFeeData();
      assert(feeData.gasPrice != null, "network does not support gasPrice", "UNSUPPORTED_OPERATION", {
        operation: "getGasPrice"
      });
      if (pop.gasPrice == null) {
        pop.gasPrice = feeData.gasPrice;
      }
    } else {
      const feeData = await provider.getFeeData();
      if (pop.type == null) {
        if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {
          pop.type = 2;
          if (pop.gasPrice != null) {
            const gasPrice = pop.gasPrice;
            delete pop.gasPrice;
            pop.maxFeePerGas = gasPrice;
            pop.maxPriorityFeePerGas = gasPrice;
          } else {
            if (pop.maxFeePerGas == null) {
              pop.maxFeePerGas = feeData.maxFeePerGas;
            }
            if (pop.maxPriorityFeePerGas == null) {
              pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
            }
          }
        } else if (feeData.gasPrice != null) {
          assert(!hasEip1559, "network does not support EIP-1559", "UNSUPPORTED_OPERATION", {
            operation: "populateTransaction"
          });
          if (pop.gasPrice == null) {
            pop.gasPrice = feeData.gasPrice;
          }
          pop.type = 0;
        } else {
          assert(false, "failed to get consistent fee data", "UNSUPPORTED_OPERATION", {
            operation: "signer.getFeeData"
          });
        }
      } else if (pop.type === 2 || pop.type === 3) {
        if (pop.maxFeePerGas == null) {
          pop.maxFeePerGas = feeData.maxFeePerGas;
        }
        if (pop.maxPriorityFeePerGas == null) {
          pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
        }
      }
    }
    return await resolveProperties(pop);
  }
  async estimateGas(tx) {
    return checkProvider(this, "estimateGas").estimateGas(await this.populateCall(tx));
  }
  async call(tx) {
    return checkProvider(this, "call").call(await this.populateCall(tx));
  }
  async resolveName(name) {
    const provider = checkProvider(this, "resolveName");
    return await provider.resolveName(name);
  }
  async sendTransaction(tx) {
    const provider = checkProvider(this, "sendTransaction");
    const pop = await this.populateTransaction(tx);
    delete pop.from;
    const txObj = Transaction.from(pop);
    return await provider.broadcastTransaction(await this.signTransaction(txObj));
  }
}
function copy(obj) {
  return JSON.parse(JSON.stringify(obj));
}
class FilterIdSubscriber {
  /**
   *  Creates a new **FilterIdSubscriber** which will used [[_subscribe]]
   *  and [[_emitResults]] to setup the subscription and provide the event
   *  to the %%provider%%.
   */
  constructor(provider) {
    __privateAdd(this, _FilterIdSubscriber_instances);
    __privateAdd(this, _provider4);
    __privateAdd(this, _filterIdPromise);
    __privateAdd(this, _poller3);
    __privateAdd(this, _running3);
    __privateAdd(this, _network);
    __privateAdd(this, _hault);
    __privateSet(this, _provider4, provider);
    __privateSet(this, _filterIdPromise, null);
    __privateSet(this, _poller3, __privateMethod(this, _FilterIdSubscriber_instances, poll_fn3).bind(this));
    __privateSet(this, _running3, false);
    __privateSet(this, _network, null);
    __privateSet(this, _hault, false);
  }
  /**
   *  Sub-classes **must** override this to begin the subscription.
   */
  _subscribe(provider) {
    throw new Error("subclasses must override this");
  }
  /**
   *  Sub-classes **must** override this handle the events.
   */
  _emitResults(provider, result) {
    throw new Error("subclasses must override this");
  }
  /**
   *  Sub-classes **must** override this handle recovery on errors.
   */
  _recover(provider) {
    throw new Error("subclasses must override this");
  }
  start() {
    if (__privateGet(this, _running3)) {
      return;
    }
    __privateSet(this, _running3, true);
    __privateMethod(this, _FilterIdSubscriber_instances, poll_fn3).call(this, -2);
  }
  stop() {
    if (!__privateGet(this, _running3)) {
      return;
    }
    __privateSet(this, _running3, false);
    __privateSet(this, _hault, true);
    __privateMethod(this, _FilterIdSubscriber_instances, teardown_fn).call(this);
    __privateGet(this, _provider4).off("block", __privateGet(this, _poller3));
  }
  pause(dropWhilePaused) {
    if (dropWhilePaused) {
      __privateMethod(this, _FilterIdSubscriber_instances, teardown_fn).call(this);
    }
    __privateGet(this, _provider4).off("block", __privateGet(this, _poller3));
  }
  resume() {
    this.start();
  }
}
_provider4 = new WeakMap();
_filterIdPromise = new WeakMap();
_poller3 = new WeakMap();
_running3 = new WeakMap();
_network = new WeakMap();
_hault = new WeakMap();
_FilterIdSubscriber_instances = new WeakSet();
poll_fn3 = async function(blockNumber) {
  try {
    if (__privateGet(this, _filterIdPromise) == null) {
      __privateSet(this, _filterIdPromise, this._subscribe(__privateGet(this, _provider4)));
    }
    let filterId = null;
    try {
      filterId = await __privateGet(this, _filterIdPromise);
    } catch (error) {
      if (!isError(error, "UNSUPPORTED_OPERATION") || error.operation !== "eth_newFilter") {
        throw error;
      }
    }
    if (filterId == null) {
      __privateSet(this, _filterIdPromise, null);
      __privateGet(this, _provider4)._recoverSubscriber(this, this._recover(__privateGet(this, _provider4)));
      return;
    }
    const network = await __privateGet(this, _provider4).getNetwork();
    if (!__privateGet(this, _network)) {
      __privateSet(this, _network, network);
    }
    if (__privateGet(this, _network).chainId !== network.chainId) {
      throw new Error("chaid changed");
    }
    if (__privateGet(this, _hault)) {
      return;
    }
    const result = await __privateGet(this, _provider4).send("eth_getFilterChanges", [filterId]);
    await this._emitResults(__privateGet(this, _provider4), result);
  } catch (error) {
    console.log("@TODO", error);
  }
  __privateGet(this, _provider4).once("block", __privateGet(this, _poller3));
};
teardown_fn = function() {
  const filterIdPromise = __privateGet(this, _filterIdPromise);
  if (filterIdPromise) {
    __privateSet(this, _filterIdPromise, null);
    filterIdPromise.then((filterId) => {
      if (__privateGet(this, _provider4).destroyed) {
        return;
      }
      __privateGet(this, _provider4).send("eth_uninstallFilter", [filterId]);
    });
  }
};
class FilterIdEventSubscriber extends FilterIdSubscriber {
  /**
   *  Creates a new **FilterIdEventSubscriber** attached to %%provider%%
   *  listening for %%filter%%.
   */
  constructor(provider, filter) {
    super(provider);
    __privateAdd(this, _event);
    __privateSet(this, _event, copy(filter));
  }
  _recover(provider) {
    return new PollingEventSubscriber(provider, __privateGet(this, _event));
  }
  async _subscribe(provider) {
    const filterId = await provider.send("eth_newFilter", [__privateGet(this, _event)]);
    return filterId;
  }
  async _emitResults(provider, results) {
    for (const result of results) {
      provider.emit(__privateGet(this, _event), provider._wrapLog(result, provider._network));
    }
  }
}
_event = new WeakMap();
class FilterIdPendingSubscriber extends FilterIdSubscriber {
  async _subscribe(provider) {
    return await provider.send("eth_newPendingTransactionFilter", []);
  }
  async _emitResults(provider, results) {
    for (const result of results) {
      provider.emit("pending", result);
    }
  }
}
const Primitive = "bigint,boolean,function,number,string,symbol".split(/,/g);
function deepCopy(value) {
  if (value == null || Primitive.indexOf(typeof value) >= 0) {
    return value;
  }
  if (typeof value.getAddress === "function") {
    return value;
  }
  if (Array.isArray(value)) {
    return value.map(deepCopy);
  }
  if (typeof value === "object") {
    return Object.keys(value).reduce((accum, key) => {
      accum[key] = value[key];
      return accum;
    }, {});
  }
  throw new Error(`should not happen: ${value} (${typeof value})`);
}
function stall(duration) {
  return new Promise((resolve) => {
    setTimeout(resolve, duration);
  });
}
function getLowerCase(value) {
  if (value) {
    return value.toLowerCase();
  }
  return value;
}
function isPollable(value) {
  return value && typeof value.pollingInterval === "number";
}
const defaultOptions = {
  polling: false,
  staticNetwork: null,
  batchStallTime: 10,
  batchMaxSize: 1 << 20,
  batchMaxCount: 100,
  cacheTimeout: 250,
  pollingInterval: 4e3
};
class JsonRpcSigner extends AbstractSigner {
  constructor(provider, address) {
    super(provider);
    __publicField(this, "address");
    address = getAddress(address);
    defineProperties(this, { address });
  }
  connect(provider) {
    assert(false, "cannot reconnect JsonRpcSigner", "UNSUPPORTED_OPERATION", {
      operation: "signer.connect"
    });
  }
  async getAddress() {
    return this.address;
  }
  // JSON-RPC will automatially fill in nonce, etc. so we just check from
  async populateTransaction(tx) {
    return await this.populateCall(tx);
  }
  // Returns just the hash of the transaction after sent, which is what
  // the bare JSON-RPC API does;
  async sendUncheckedTransaction(_tx) {
    const tx = deepCopy(_tx);
    const promises = [];
    if (tx.from) {
      const _from = tx.from;
      promises.push((async () => {
        const from = await resolveAddress(_from, this.provider);
        assertArgument(from != null && from.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", _tx);
        tx.from = from;
      })());
    } else {
      tx.from = this.address;
    }
    if (tx.gasLimit == null) {
      promises.push((async () => {
        tx.gasLimit = await this.provider.estimateGas({ ...tx, from: this.address });
      })());
    }
    if (tx.to != null) {
      const _to2 = tx.to;
      promises.push((async () => {
        tx.to = await resolveAddress(_to2, this.provider);
      })());
    }
    if (promises.length) {
      await Promise.all(promises);
    }
    const hexTx = this.provider.getRpcTransaction(tx);
    return this.provider.send("eth_sendTransaction", [hexTx]);
  }
  async sendTransaction(tx) {
    const blockNumber = await this.provider.getBlockNumber();
    const hash = await this.sendUncheckedTransaction(tx);
    return await new Promise((resolve, reject) => {
      const timeouts = [1e3, 100];
      let invalids = 0;
      const checkTx = async () => {
        try {
          const tx2 = await this.provider.getTransaction(hash);
          if (tx2 != null) {
            resolve(tx2.replaceableTransaction(blockNumber));
            return;
          }
        } catch (error) {
          if (isError(error, "CANCELLED") || isError(error, "BAD_DATA") || isError(error, "NETWORK_ERROR") || isError(error, "UNSUPPORTED_OPERATION")) {
            if (error.info == null) {
              error.info = {};
            }
            error.info.sendTransactionHash = hash;
            reject(error);
            return;
          }
          if (isError(error, "INVALID_ARGUMENT")) {
            invalids++;
            if (error.info == null) {
              error.info = {};
            }
            error.info.sendTransactionHash = hash;
            if (invalids > 10) {
              reject(error);
              return;
            }
          }
          this.provider.emit("error", makeError("failed to fetch transation after sending (will try again)", "UNKNOWN_ERROR", { error }));
        }
        this.provider._setTimeout(() => {
          checkTx();
        }, timeouts.pop() || 4e3);
      };
      checkTx();
    });
  }
  async signTransaction(_tx) {
    const tx = deepCopy(_tx);
    if (tx.from) {
      const from = await resolveAddress(tx.from, this.provider);
      assertArgument(from != null && from.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", _tx);
      tx.from = from;
    } else {
      tx.from = this.address;
    }
    const hexTx = this.provider.getRpcTransaction(tx);
    return await this.provider.send("eth_signTransaction", [hexTx]);
  }
  async signMessage(_message) {
    const message = typeof _message === "string" ? toUtf8Bytes(_message) : _message;
    return await this.provider.send("personal_sign", [
      hexlify(message),
      this.address.toLowerCase()
    ]);
  }
  async signTypedData(domain, types, _value2) {
    const value = deepCopy(_value2);
    const populated = await TypedDataEncoder.resolveNames(domain, types, value, async (value2) => {
      const address = await resolveAddress(value2);
      assertArgument(address != null, "TypedData does not support null address", "value", value2);
      return address;
    });
    return await this.provider.send("eth_signTypedData_v4", [
      this.address.toLowerCase(),
      JSON.stringify(TypedDataEncoder.getPayload(populated.domain, types, populated.value))
    ]);
  }
  async unlock(password) {
    return this.provider.send("personal_unlockAccount", [
      this.address.toLowerCase(),
      password,
      null
    ]);
  }
  // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign
  async _legacySignMessage(_message) {
    const message = typeof _message === "string" ? toUtf8Bytes(_message) : _message;
    return await this.provider.send("eth_sign", [
      this.address.toLowerCase(),
      hexlify(message)
    ]);
  }
}
class JsonRpcApiProvider extends AbstractProvider {
  constructor(network, options) {
    super(network, options);
    __privateAdd(this, _JsonRpcApiProvider_instances);
    __privateAdd(this, _options3);
    // The next ID to use for the JSON-RPC ID field
    __privateAdd(this, _nextId);
    // Payloads are queued and triggered in batches using the drainTimer
    __privateAdd(this, _payloads);
    __privateAdd(this, _drainTimer);
    __privateAdd(this, _notReady);
    __privateAdd(this, _network2);
    __privateAdd(this, _pendingDetectNetwork);
    __privateSet(this, _nextId, 1);
    __privateSet(this, _options3, Object.assign({}, defaultOptions, options || {}));
    __privateSet(this, _payloads, []);
    __privateSet(this, _drainTimer, null);
    __privateSet(this, _network2, null);
    __privateSet(this, _pendingDetectNetwork, null);
    {
      let resolve = null;
      const promise = new Promise((_resolve) => {
        resolve = _resolve;
      });
      __privateSet(this, _notReady, { promise, resolve });
    }
    const staticNetwork = this._getOption("staticNetwork");
    if (typeof staticNetwork === "boolean") {
      assertArgument(!staticNetwork || network !== "any", "staticNetwork cannot be used on special network 'any'", "options", options);
      if (staticNetwork && network != null) {
        __privateSet(this, _network2, Network.from(network));
      }
    } else if (staticNetwork) {
      assertArgument(network == null || staticNetwork.matches(network), "staticNetwork MUST match network object", "options", options);
      __privateSet(this, _network2, staticNetwork);
    }
  }
  /**
   *  Returns the value associated with the option %%key%%.
   *
   *  Sub-classes can use this to inquire about configuration options.
   */
  _getOption(key) {
    return __privateGet(this, _options3)[key];
  }
  /**
   *  Gets the [[Network]] this provider has committed to. On each call, the network
   *  is detected, and if it has changed, the call will reject.
   */
  get _network() {
    assert(__privateGet(this, _network2), "network is not available yet", "NETWORK_ERROR");
    return __privateGet(this, _network2);
  }
  /**
   *  Resolves to the non-normalized value by performing %%req%%.
   *
   *  Sub-classes may override this to modify behavior of actions,
   *  and should generally call ``super._perform`` as a fallback.
   */
  async _perform(req) {
    if (req.method === "call" || req.method === "estimateGas") {
      let tx = req.transaction;
      if (tx && tx.type != null && getBigInt(tx.type)) {
        if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {
          const feeData = await this.getFeeData();
          if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {
            req = Object.assign({}, req, {
              transaction: Object.assign({}, tx, { type: void 0 })
            });
          }
        }
      }
    }
    const request2 = this.getRpcRequest(req);
    if (request2 != null) {
      return await this.send(request2.method, request2.args);
    }
    return super._perform(req);
  }
  /**
   *  Sub-classes may override this; it detects the *actual* network that
   *  we are **currently** connected to.
   *
   *  Keep in mind that [[send]] may only be used once [[ready]], otherwise the
   *  _send primitive must be used instead.
   */
  async _detectNetwork() {
    const network = this._getOption("staticNetwork");
    if (network) {
      if (network === true) {
        if (__privateGet(this, _network2)) {
          return __privateGet(this, _network2);
        }
      } else {
        return network;
      }
    }
    if (__privateGet(this, _pendingDetectNetwork)) {
      return await __privateGet(this, _pendingDetectNetwork);
    }
    if (this.ready) {
      __privateSet(this, _pendingDetectNetwork, (async () => {
        try {
          const result = Network.from(getBigInt(await this.send("eth_chainId", [])));
          __privateSet(this, _pendingDetectNetwork, null);
          return result;
        } catch (error) {
          __privateSet(this, _pendingDetectNetwork, null);
          throw error;
        }
      })());
      return await __privateGet(this, _pendingDetectNetwork);
    }
    __privateSet(this, _pendingDetectNetwork, (async () => {
      const payload = {
        id: __privateWrapper(this, _nextId)._++,
        method: "eth_chainId",
        params: [],
        jsonrpc: "2.0"
      };
      this.emit("debug", { action: "sendRpcPayload", payload });
      let result;
      try {
        result = (await this._send(payload))[0];
        __privateSet(this, _pendingDetectNetwork, null);
      } catch (error) {
        __privateSet(this, _pendingDetectNetwork, null);
        this.emit("debug", { action: "receiveRpcError", error });
        throw error;
      }
      this.emit("debug", { action: "receiveRpcResult", result });
      if ("result" in result) {
        return Network.from(getBigInt(result.result));
      }
      throw this.getRpcError(payload, result);
    })());
    return await __privateGet(this, _pendingDetectNetwork);
  }
  /**
   *  Sub-classes **MUST** call this. Until [[_start]] has been called, no calls
   *  will be passed to [[_send]] from [[send]]. If it is overridden, then
   *  ``super._start()`` **MUST** be called.
   *
   *  Calling it multiple times is safe and has no effect.
   */
  _start() {
    if (__privateGet(this, _notReady) == null || __privateGet(this, _notReady).resolve == null) {
      return;
    }
    __privateGet(this, _notReady).resolve();
    __privateSet(this, _notReady, null);
    (async () => {
      while (__privateGet(this, _network2) == null && !this.destroyed) {
        try {
          __privateSet(this, _network2, await this._detectNetwork());
        } catch (error) {
          if (this.destroyed) {
            break;
          }
          console.log("JsonRpcProvider failed to detect network and cannot start up; retry in 1s (perhaps the URL is wrong or the node is not started)");
          this.emit("error", makeError("failed to bootstrap network detection", "NETWORK_ERROR", { event: "initial-network-discovery", info: { error } }));
          await stall(1e3);
        }
      }
      __privateMethod(this, _JsonRpcApiProvider_instances, scheduleDrain_fn).call(this);
    })();
  }
  /**
   *  Resolves once the [[_start]] has been called. This can be used in
   *  sub-classes to defer sending data until the connection has been
   *  established.
   */
  async _waitUntilReady() {
    if (__privateGet(this, _notReady) == null) {
      return;
    }
    return await __privateGet(this, _notReady).promise;
  }
  /**
   *  Return a Subscriber that will manage the %%sub%%.
   *
   *  Sub-classes may override this to modify the behavior of
   *  subscription management.
   */
  _getSubscriber(sub) {
    if (sub.type === "pending") {
      return new FilterIdPendingSubscriber(this);
    }
    if (sub.type === "event") {
      if (this._getOption("polling")) {
        return new PollingEventSubscriber(this, sub.filter);
      }
      return new FilterIdEventSubscriber(this, sub.filter);
    }
    if (sub.type === "orphan" && sub.filter.orphan === "drop-log") {
      return new UnmanagedSubscriber("orphan");
    }
    return super._getSubscriber(sub);
  }
  /**
   *  Returns true only if the [[_start]] has been called.
   */
  get ready() {
    return __privateGet(this, _notReady) == null;
  }
  /**
   *  Returns %%tx%% as a normalized JSON-RPC transaction request,
   *  which has all values hexlified and any numeric values converted
   *  to Quantity values.
   */
  getRpcTransaction(tx) {
    const result = {};
    ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach((key) => {
      if (tx[key] == null) {
        return;
      }
      let dstKey = key;
      if (key === "gasLimit") {
        dstKey = "gas";
      }
      result[dstKey] = toQuantity(getBigInt(tx[key], `tx.${key}`));
    });
    ["from", "to", "data"].forEach((key) => {
      if (tx[key] == null) {
        return;
      }
      result[key] = hexlify(tx[key]);
    });
    if (tx.accessList) {
      result["accessList"] = accessListify(tx.accessList);
    }
    if (tx.blobVersionedHashes) {
      result["blobVersionedHashes"] = tx.blobVersionedHashes.map((h2) => h2.toLowerCase());
    }
    return result;
  }
  /**
   *  Returns the request method and arguments required to perform
   *  %%req%%.
   */
  getRpcRequest(req) {
    switch (req.method) {
      case "chainId":
        return { method: "eth_chainId", args: [] };
      case "getBlockNumber":
        return { method: "eth_blockNumber", args: [] };
      case "getGasPrice":
        return { method: "eth_gasPrice", args: [] };
      case "getPriorityFee":
        return { method: "eth_maxPriorityFeePerGas", args: [] };
      case "getBalance":
        return {
          method: "eth_getBalance",
          args: [getLowerCase(req.address), req.blockTag]
        };
      case "getTransactionCount":
        return {
          method: "eth_getTransactionCount",
          args: [getLowerCase(req.address), req.blockTag]
        };
      case "getCode":
        return {
          method: "eth_getCode",
          args: [getLowerCase(req.address), req.blockTag]
        };
      case "getStorage":
        return {
          method: "eth_getStorageAt",
          args: [
            getLowerCase(req.address),
            "0x" + req.position.toString(16),
            req.blockTag
          ]
        };
      case "broadcastTransaction":
        return {
          method: "eth_sendRawTransaction",
          args: [req.signedTransaction]
        };
      case "getBlock":
        if ("blockTag" in req) {
          return {
            method: "eth_getBlockByNumber",
            args: [req.blockTag, !!req.includeTransactions]
          };
        } else if ("blockHash" in req) {
          return {
            method: "eth_getBlockByHash",
            args: [req.blockHash, !!req.includeTransactions]
          };
        }
        break;
      case "getTransaction":
        return {
          method: "eth_getTransactionByHash",
          args: [req.hash]
        };
      case "getTransactionReceipt":
        return {
          method: "eth_getTransactionReceipt",
          args: [req.hash]
        };
      case "call":
        return {
          method: "eth_call",
          args: [this.getRpcTransaction(req.transaction), req.blockTag]
        };
      case "estimateGas": {
        return {
          method: "eth_estimateGas",
          args: [this.getRpcTransaction(req.transaction)]
        };
      }
      case "getLogs":
        if (req.filter && req.filter.address != null) {
          if (Array.isArray(req.filter.address)) {
            req.filter.address = req.filter.address.map(getLowerCase);
          } else {
            req.filter.address = getLowerCase(req.filter.address);
          }
        }
        return { method: "eth_getLogs", args: [req.filter] };
    }
    return null;
  }
  /**
   *  Returns an ethers-style Error for the given JSON-RPC error
   *  %%payload%%, coalescing the various strings and error shapes
   *  that different nodes return, coercing them into a machine-readable
   *  standardized error.
   */
  getRpcError(payload, _error2) {
    const { method } = payload;
    const { error } = _error2;
    if (method === "eth_estimateGas" && error.message) {
      const msg = error.message;
      if (!msg.match(/revert/i) && msg.match(/insufficient funds/i)) {
        return makeError("insufficient funds", "INSUFFICIENT_FUNDS", {
          transaction: payload.params[0],
          info: { payload, error }
        });
      }
    }
    if (method === "eth_call" || method === "eth_estimateGas") {
      const result = spelunkData(error);
      const e3 = AbiCoder.getBuiltinCallException(method === "eth_call" ? "call" : "estimateGas", payload.params[0], result ? result.data : null);
      e3.info = { error, payload };
      return e3;
    }
    const message = JSON.stringify(spelunkMessage(error));
    if (typeof error.message === "string" && error.message.match(/user denied|ethers-user-denied/i)) {
      const actionMap = {
        eth_sign: "signMessage",
        personal_sign: "signMessage",
        eth_signTypedData_v4: "signTypedData",
        eth_signTransaction: "signTransaction",
        eth_sendTransaction: "sendTransaction",
        eth_requestAccounts: "requestAccess",
        wallet_requestAccounts: "requestAccess"
      };
      return makeError(`user rejected action`, "ACTION_REJECTED", {
        action: actionMap[method] || "unknown",
        reason: "rejected",
        info: { payload, error }
      });
    }
    if (method === "eth_sendRawTransaction" || method === "eth_sendTransaction") {
      const transaction = payload.params[0];
      if (message.match(/insufficient funds|base fee exceeds gas limit/i)) {
        return makeError("insufficient funds for intrinsic transaction cost", "INSUFFICIENT_FUNDS", {
          transaction,
          info: { error }
        });
      }
      if (message.match(/nonce/i) && message.match(/too low/i)) {
        return makeError("nonce has already been used", "NONCE_EXPIRED", { transaction, info: { error } });
      }
      if (message.match(/replacement transaction/i) && message.match(/underpriced/i)) {
        return makeError("replacement fee too low", "REPLACEMENT_UNDERPRICED", { transaction, info: { error } });
      }
      if (message.match(/only replay-protected/i)) {
        return makeError("legacy pre-eip-155 transactions not supported", "UNSUPPORTED_OPERATION", {
          operation: method,
          info: { transaction, info: { error } }
        });
      }
    }
    let unsupported = !!message.match(/the method .* does not exist/i);
    if (!unsupported) {
      if (error && error.details && error.details.startsWith("Unauthorized method:")) {
        unsupported = true;
      }
    }
    if (unsupported) {
      return makeError("unsupported operation", "UNSUPPORTED_OPERATION", {
        operation: payload.method,
        info: { error, payload }
      });
    }
    return makeError("could not coalesce error", "UNKNOWN_ERROR", { error, payload });
  }
  /**
   *  Requests the %%method%% with %%params%% via the JSON-RPC protocol
   *  over the underlying channel. This can be used to call methods
   *  on the backend that do not have a high-level API within the Provider
   *  API.
   *
   *  This method queues requests according to the batch constraints
   *  in the options, assigns the request a unique ID.
   *
   *  **Do NOT override** this method in sub-classes; instead
   *  override [[_send]] or force the options values in the
   *  call to the constructor to modify this method's behavior.
   */
  send(method, params) {
    if (this.destroyed) {
      return Promise.reject(makeError("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: method }));
    }
    const id2 = __privateWrapper(this, _nextId)._++;
    const promise = new Promise((resolve, reject) => {
      __privateGet(this, _payloads).push({
        resolve,
        reject,
        payload: { method, params, id: id2, jsonrpc: "2.0" }
      });
    });
    __privateMethod(this, _JsonRpcApiProvider_instances, scheduleDrain_fn).call(this);
    return promise;
  }
  /**
   *  Resolves to the [[Signer]] account for  %%address%% managed by
   *  the client.
   *
   *  If the %%address%% is a number, it is used as an index in the
   *  the accounts from [[listAccounts]].
   *
   *  This can only be used on clients which manage accounts (such as
   *  Geth with imported account or MetaMask).
   *
   *  Throws if the account doesn't exist.
   */
  async getSigner(address) {
    if (address == null) {
      address = 0;
    }
    const accountsPromise = this.send("eth_accounts", []);
    if (typeof address === "number") {
      const accounts2 = await accountsPromise;
      if (address >= accounts2.length) {
        throw new Error("no such account");
      }
      return new JsonRpcSigner(this, accounts2[address]);
    }
    const { accounts } = await resolveProperties({
      network: this.getNetwork(),
      accounts: accountsPromise
    });
    address = getAddress(address);
    for (const account of accounts) {
      if (getAddress(account) === address) {
        return new JsonRpcSigner(this, address);
      }
    }
    throw new Error("invalid account");
  }
  async listAccounts() {
    const accounts = await this.send("eth_accounts", []);
    return accounts.map((a2) => new JsonRpcSigner(this, a2));
  }
  destroy() {
    if (__privateGet(this, _drainTimer)) {
      clearTimeout(__privateGet(this, _drainTimer));
      __privateSet(this, _drainTimer, null);
    }
    for (const { payload, reject } of __privateGet(this, _payloads)) {
      reject(makeError("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: payload.method }));
    }
    __privateSet(this, _payloads, []);
    super.destroy();
  }
}
_options3 = new WeakMap();
_nextId = new WeakMap();
_payloads = new WeakMap();
_drainTimer = new WeakMap();
_notReady = new WeakMap();
_network2 = new WeakMap();
_pendingDetectNetwork = new WeakMap();
_JsonRpcApiProvider_instances = new WeakSet();
scheduleDrain_fn = function() {
  if (__privateGet(this, _drainTimer)) {
    return;
  }
  const stallTime = this._getOption("batchMaxCount") === 1 ? 0 : this._getOption("batchStallTime");
  __privateSet(this, _drainTimer, setTimeout(() => {
    __privateSet(this, _drainTimer, null);
    const payloads = __privateGet(this, _payloads);
    __privateSet(this, _payloads, []);
    while (payloads.length) {
      const batch = [payloads.shift()];
      while (payloads.length) {
        if (batch.length === __privateGet(this, _options3).batchMaxCount) {
          break;
        }
        batch.push(payloads.shift());
        const bytes = JSON.stringify(batch.map((p2) => p2.payload));
        if (bytes.length > __privateGet(this, _options3).batchMaxSize) {
          payloads.unshift(batch.pop());
          break;
        }
      }
      (async () => {
        const payload = batch.length === 1 ? batch[0].payload : batch.map((p2) => p2.payload);
        this.emit("debug", { action: "sendRpcPayload", payload });
        try {
          const result = await this._send(payload);
          this.emit("debug", { action: "receiveRpcResult", result });
          for (const { resolve, reject, payload: payload2 } of batch) {
            if (this.destroyed) {
              reject(makeError("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: payload2.method }));
              continue;
            }
            const resp = result.filter((r3) => r3.id === payload2.id)[0];
            if (resp == null) {
              const error = makeError("missing response for request", "BAD_DATA", {
                value: result,
                info: { payload: payload2 }
              });
              this.emit("error", error);
              reject(error);
              continue;
            }
            if ("error" in resp) {
              reject(this.getRpcError(payload2, resp));
              continue;
            }
            resolve(resp.result);
          }
        } catch (error) {
          this.emit("debug", { action: "receiveRpcError", error });
          for (const { reject } of batch) {
            reject(error);
          }
        }
      })();
    }
  }, stallTime));
};
class JsonRpcApiPollingProvider extends JsonRpcApiProvider {
  constructor(network, options) {
    super(network, options);
    __privateAdd(this, _pollingInterval);
    let pollingInterval = this._getOption("pollingInterval");
    if (pollingInterval == null) {
      pollingInterval = defaultOptions.pollingInterval;
    }
    __privateSet(this, _pollingInterval, pollingInterval);
  }
  _getSubscriber(sub) {
    const subscriber = super._getSubscriber(sub);
    if (isPollable(subscriber)) {
      subscriber.pollingInterval = __privateGet(this, _pollingInterval);
    }
    return subscriber;
  }
  /**
   *  The polling interval (default: 4000 ms)
   */
  get pollingInterval() {
    return __privateGet(this, _pollingInterval);
  }
  set pollingInterval(value) {
    if (!Number.isInteger(value) || value < 0) {
      throw new Error("invalid interval");
    }
    __privateSet(this, _pollingInterval, value);
    this._forEachSubscriber((sub) => {
      if (isPollable(sub)) {
        sub.pollingInterval = __privateGet(this, _pollingInterval);
      }
    });
  }
}
_pollingInterval = new WeakMap();
class JsonRpcProvider extends JsonRpcApiPollingProvider {
  constructor(url, network, options) {
    if (url == null) {
      url = "http://localhost:8545";
    }
    super(network, options);
    __privateAdd(this, _connect);
    if (typeof url === "string") {
      __privateSet(this, _connect, new FetchRequest(url));
    } else {
      __privateSet(this, _connect, url.clone());
    }
  }
  _getConnection() {
    return __privateGet(this, _connect).clone();
  }
  async send(method, params) {
    await this._start();
    return await super.send(method, params);
  }
  async _send(payload) {
    const request2 = this._getConnection();
    request2.body = JSON.stringify(payload);
    request2.setHeader("content-type", "application/json");
    const response = await request2.send();
    response.assertOk();
    let resp = response.bodyJson;
    if (!Array.isArray(resp)) {
      resp = [resp];
    }
    return resp;
  }
}
_connect = new WeakMap();
function spelunkData(value) {
  if (value == null) {
    return null;
  }
  if (typeof value.message === "string" && value.message.match(/revert/i) && isHexString(value.data)) {
    return { message: value.message, data: value.data };
  }
  if (typeof value === "object") {
    for (const key in value) {
      const result = spelunkData(value[key]);
      if (result) {
        return result;
      }
    }
    return null;
  }
  if (typeof value === "string") {
    try {
      return spelunkData(JSON.parse(value));
    } catch (error) {
    }
  }
  return null;
}
function _spelunkMessage(value, result) {
  if (value == null) {
    return;
  }
  if (typeof value.message === "string") {
    result.push(value.message);
  }
  if (typeof value === "object") {
    for (const key in value) {
      _spelunkMessage(value[key], result);
    }
  }
  if (typeof value === "string") {
    try {
      return _spelunkMessage(JSON.parse(value), result);
    } catch (error) {
    }
  }
}
function spelunkMessage(value) {
  const result = [];
  _spelunkMessage(value, result);
  return result;
}
class BrowserProvider extends JsonRpcApiPollingProvider {
  /**
   *  Connect to the %%ethereum%% provider, optionally forcing the
   *  %%network%%.
   */
  constructor(ethereum, network, _options4) {
    const options = Object.assign({}, _options4 != null ? _options4 : {}, { batchMaxCount: 1 });
    assertArgument(ethereum && ethereum.request, "invalid EIP-1193 provider", "ethereum", ethereum);
    super(network, options);
    __privateAdd(this, _request2);
    __privateSet(this, _request2, async (method, params) => {
      const payload = { method, params };
      this.emit("debug", { action: "sendEip1193Request", payload });
      try {
        const result = await ethereum.request(payload);
        this.emit("debug", { action: "receiveEip1193Result", result });
        return result;
      } catch (e3) {
        const error = new Error(e3.message);
        error.code = e3.code;
        error.data = e3.data;
        error.payload = payload;
        this.emit("debug", { action: "receiveEip1193Error", error });
        throw error;
      }
    });
  }
  async send(method, params) {
    await this._start();
    return await super.send(method, params);
  }
  async _send(payload) {
    assertArgument(!Array.isArray(payload), "EIP-1193 does not support batch request", "payload", payload);
    try {
      const result = await __privateGet(this, _request2).call(this, payload.method, payload.params || []);
      return [{ id: payload.id, result }];
    } catch (e3) {
      return [{
        id: payload.id,
        error: { code: e3.code, data: e3.data, message: e3.message }
      }];
    }
  }
  getRpcError(payload, error) {
    error = JSON.parse(JSON.stringify(error));
    switch (error.error.code || -1) {
      case 4001:
        error.error.message = `ethers-user-denied: ${error.error.message}`;
        break;
      case 4200:
        error.error.message = `ethers-unsupported: ${error.error.message}`;
        break;
    }
    return super.getRpcError(payload, error);
  }
  /**
   *  Resolves to ``true`` if the provider manages the %%address%%.
   */
  async hasSigner(address) {
    if (address == null) {
      address = 0;
    }
    const accounts = await this.send("eth_accounts", []);
    if (typeof address === "number") {
      return accounts.length > address;
    }
    address = address.toLowerCase();
    return accounts.filter((a2) => a2.toLowerCase() === address).length !== 0;
  }
  async getSigner(address) {
    if (address == null) {
      address = 0;
    }
    if (!await this.hasSigner(address)) {
      try {
        await __privateGet(this, _request2).call(this, "eth_requestAccounts", []);
      } catch (error) {
        const payload = error.payload;
        throw this.getRpcError(payload, { id: payload.id, error });
      }
    }
    return await super.getSigner(address);
  }
}
_request2 = new WeakMap();
var Bn$1 = Object.create;
var ze$7 = Object.defineProperty;
var Fn$2 = Object.getOwnPropertyDescriptor;
var On$1 = Object.getOwnPropertyNames;
var Dn$1 = Object.getPrototypeOf, Pn$1 = Object.prototype.hasOwnProperty;
var Kn$1 = (n4, e3) => () => (n4 && (e3 = n4(n4 = 0)), e3);
var se$4 = (n4, e3) => () => (e3 || n4((e3 = { exports: {} }).exports, e3), e3.exports), Vn$3 = (n4, e3) => {
  for (var t in e3) ze$7(n4, t, { get: e3[t], enumerable: true });
}, Hn = (n4, e3, t, r3) => {
  if (e3 && typeof e3 == "object" || typeof e3 == "function") for (let a2 of On$1(e3)) !Pn$1.call(n4, a2) && a2 !== t && ze$7(n4, a2, { get: () => e3[a2], enumerable: !(r3 = Fn$2(e3, a2)) || r3.enumerable });
  return n4;
};
var fe$5 = (n4, e3, t) => (t = n4 != null ? Bn$1(Dn$1(n4)) : {}, Hn(!n4 || !n4.__esModule ? ze$7(t, "default", { value: n4, enumerable: true }) : t, n4));
var Ct$5 = se$4((Ee2) => {
  c();
  Ee2.byteLength = Wn2;
  Ee2.toByteArray = zn2;
  Ee2.fromByteArray = jn2;
  var H2 = [], D2 = [], Ln2 = typeof Uint8Array < "u" ? Uint8Array : Array, Xe2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (Q2 = 0, xt2 = Xe2.length; Q2 < xt2; ++Q2) H2[Q2] = Xe2[Q2], D2[Xe2.charCodeAt(Q2)] = Q2;
  var Q2, xt2;
  D2[45] = 62;
  D2[95] = 63;
  function Et2(n4) {
    var e3 = n4.length;
    if (e3 % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
    var t = n4.indexOf("=");
    t === -1 && (t = e3);
    var r3 = t === e3 ? 0 : 4 - t % 4;
    return [t, r3];
  }
  function Wn2(n4) {
    var e3 = Et2(n4), t = e3[0], r3 = e3[1];
    return (t + r3) * 3 / 4 - r3;
  }
  function Gn2(n4, e3, t) {
    return (e3 + t) * 3 / 4 - t;
  }
  function zn2(n4) {
    var e3, t = Et2(n4), r3 = t[0], a2 = t[1], s = new Ln2(Gn2(n4, r3, a2)), i = 0, o = a2 > 0 ? r3 - 4 : r3, p2;
    for (p2 = 0; p2 < o; p2 += 4) e3 = D2[n4.charCodeAt(p2)] << 18 | D2[n4.charCodeAt(p2 + 1)] << 12 | D2[n4.charCodeAt(p2 + 2)] << 6 | D2[n4.charCodeAt(p2 + 3)], s[i++] = e3 >> 16 & 255, s[i++] = e3 >> 8 & 255, s[i++] = e3 & 255;
    return a2 === 2 && (e3 = D2[n4.charCodeAt(p2)] << 2 | D2[n4.charCodeAt(p2 + 1)] >> 4, s[i++] = e3 & 255), a2 === 1 && (e3 = D2[n4.charCodeAt(p2)] << 10 | D2[n4.charCodeAt(p2 + 1)] << 4 | D2[n4.charCodeAt(p2 + 2)] >> 2, s[i++] = e3 >> 8 & 255, s[i++] = e3 & 255), s;
  }
  function Xn2(n4) {
    return H2[n4 >> 18 & 63] + H2[n4 >> 12 & 63] + H2[n4 >> 6 & 63] + H2[n4 & 63];
  }
  function qn2(n4, e3, t) {
    for (var r3, a2 = [], s = e3; s < t; s += 3) r3 = (n4[s] << 16 & 16711680) + (n4[s + 1] << 8 & 65280) + (n4[s + 2] & 255), a2.push(Xn2(r3));
    return a2.join("");
  }
  function jn2(n4) {
    for (var e3, t = n4.length, r3 = t % 3, a2 = [], s = 16383, i = 0, o = t - r3; i < o; i += s) a2.push(qn2(n4, i, i + s > o ? o : i + s));
    return r3 === 1 ? (e3 = n4[t - 1], a2.push(H2[e3 >> 2] + H2[e3 << 4 & 63] + "==")) : r3 === 2 && (e3 = (n4[t - 2] << 8) + n4[t - 1], a2.push(H2[e3 >> 10] + H2[e3 >> 4 & 63] + H2[e3 << 2 & 63] + "=")), a2.join("");
  }
});
var It$2 = se$4((qe2) => {
  c();
  qe2.read = function(n4, e3, t, r3, a2) {
    var s, i, o = a2 * 8 - r3 - 1, p2 = (1 << o) - 1, y2 = p2 >> 1, d2 = -7, l2 = t ? a2 - 1 : 0, h2 = t ? -1 : 1, f2 = n4[e3 + l2];
    for (l2 += h2, s = f2 & (1 << -d2) - 1, f2 >>= -d2, d2 += o; d2 > 0; s = s * 256 + n4[e3 + l2], l2 += h2, d2 -= 8) ;
    for (i = s & (1 << -d2) - 1, s >>= -d2, d2 += r3; d2 > 0; i = i * 256 + n4[e3 + l2], l2 += h2, d2 -= 8) ;
    if (s === 0) s = 1 - y2;
    else {
      if (s === p2) return i ? NaN : (f2 ? -1 : 1) * (1 / 0);
      i = i + Math.pow(2, r3), s = s - y2;
    }
    return (f2 ? -1 : 1) * i * Math.pow(2, s - r3);
  };
  qe2.write = function(n4, e3, t, r3, a2, s) {
    var i, o, p2, y2 = s * 8 - a2 - 1, d2 = (1 << y2) - 1, l2 = d2 >> 1, h2 = a2 === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f2 = r3 ? 0 : s - 1, g2 = r3 ? 1 : -1, A2 = e3 < 0 || e3 === 0 && 1 / e3 < 0 ? 1 : 0;
    for (e3 = Math.abs(e3), isNaN(e3) || e3 === 1 / 0 ? (o = isNaN(e3) ? 1 : 0, i = d2) : (i = Math.floor(Math.log(e3) / Math.LN2), e3 * (p2 = Math.pow(2, -i)) < 1 && (i--, p2 *= 2), i + l2 >= 1 ? e3 += h2 / p2 : e3 += h2 * Math.pow(2, 1 - l2), e3 * p2 >= 2 && (i++, p2 /= 2), i + l2 >= d2 ? (o = 0, i = d2) : i + l2 >= 1 ? (o = (e3 * p2 - 1) * Math.pow(2, a2), i = i + l2) : (o = e3 * Math.pow(2, l2 - 1) * Math.pow(2, a2), i = 0)); a2 >= 8; n4[t + f2] = o & 255, f2 += g2, o /= 256, a2 -= 8) ;
    for (i = i << a2 | o, y2 += a2; y2 > 0; n4[t + f2] = i & 255, f2 += g2, i /= 256, y2 -= 8) ;
    n4[t + f2 - g2] |= A2 * 128;
  };
});
var tt$4 = se$4((oe2) => {
  c();
  var je2 = Ct$5(), ie2 = It$2(), _t2 = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  oe2.Buffer = u2;
  oe2.SlowBuffer = er2;
  oe2.INSPECT_MAX_BYTES = 50;
  var Ce2 = 2147483647;
  oe2.kMaxLength = Ce2;
  u2.TYPED_ARRAY_SUPPORT = Yn();
  !u2.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
  function Yn() {
    try {
      var n4 = new Uint8Array(1), e3 = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(e3, Uint8Array.prototype), Object.setPrototypeOf(n4, e3), n4.foo() === 42;
    } catch {
      return false;
    }
  }
  Object.defineProperty(u2.prototype, "parent", { enumerable: true, get: function() {
    if (u2.isBuffer(this)) return this.buffer;
  } });
  Object.defineProperty(u2.prototype, "offset", { enumerable: true, get: function() {
    if (u2.isBuffer(this)) return this.byteOffset;
  } });
  function q2(n4) {
    if (n4 > Ce2) throw new RangeError('The value "' + n4 + '" is invalid for option "size"');
    var e3 = new Uint8Array(n4);
    return Object.setPrototypeOf(e3, u2.prototype), e3;
  }
  function u2(n4, e3, t) {
    if (typeof n4 == "number") {
      if (typeof e3 == "string") throw new TypeError('The "string" argument must be of type string. Received type number');
      return $e2(n4);
    }
    return kt2(n4, e3, t);
  }
  u2.poolSize = 8192;
  function kt2(n4, e3, t) {
    if (typeof n4 == "string") return Zn2(n4, e3);
    if (ArrayBuffer.isView(n4)) return $n2(n4);
    if (n4 == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof n4);
    if (L2(n4, ArrayBuffer) || n4 && L2(n4.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (L2(n4, SharedArrayBuffer) || n4 && L2(n4.buffer, SharedArrayBuffer))) return Je2(n4, e3, t);
    if (typeof n4 == "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
    var r3 = n4.valueOf && n4.valueOf();
    if (r3 != null && r3 !== n4) return u2.from(r3, e3, t);
    var a2 = Qn2(n4);
    if (a2) return a2;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof n4[Symbol.toPrimitive] == "function") return u2.from(n4[Symbol.toPrimitive]("string"), e3, t);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof n4);
  }
  u2.from = function(n4, e3, t) {
    return kt2(n4, e3, t);
  };
  Object.setPrototypeOf(u2.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(u2, Uint8Array);
  function Nt2(n4) {
    if (typeof n4 != "number") throw new TypeError('"size" argument must be of type number');
    if (n4 < 0) throw new RangeError('The value "' + n4 + '" is invalid for option "size"');
  }
  function Jn2(n4, e3, t) {
    return Nt2(n4), n4 <= 0 ? q2(n4) : e3 !== void 0 ? typeof t == "string" ? q2(n4).fill(e3, t) : q2(n4).fill(e3) : q2(n4);
  }
  u2.alloc = function(n4, e3, t) {
    return Jn2(n4, e3, t);
  };
  function $e2(n4) {
    return Nt2(n4), q2(n4 < 0 ? 0 : Qe2(n4) | 0);
  }
  u2.allocUnsafe = function(n4) {
    return $e2(n4);
  };
  u2.allocUnsafeSlow = function(n4) {
    return $e2(n4);
  };
  function Zn2(n4, e3) {
    if ((typeof e3 != "string" || e3 === "") && (e3 = "utf8"), !u2.isEncoding(e3)) throw new TypeError("Unknown encoding: " + e3);
    var t = Rt2(n4, e3) | 0, r3 = q2(t), a2 = r3.write(n4, e3);
    return a2 !== t && (r3 = r3.slice(0, a2)), r3;
  }
  function Ye2(n4) {
    for (var e3 = n4.length < 0 ? 0 : Qe2(n4.length) | 0, t = q2(e3), r3 = 0; r3 < e3; r3 += 1) t[r3] = n4[r3] & 255;
    return t;
  }
  function $n2(n4) {
    if (L2(n4, Uint8Array)) {
      var e3 = new Uint8Array(n4);
      return Je2(e3.buffer, e3.byteOffset, e3.byteLength);
    }
    return Ye2(n4);
  }
  function Je2(n4, e3, t) {
    if (e3 < 0 || n4.byteLength < e3) throw new RangeError('"offset" is outside of buffer bounds');
    if (n4.byteLength < e3 + (t || 0)) throw new RangeError('"length" is outside of buffer bounds');
    var r3;
    return e3 === void 0 && t === void 0 ? r3 = new Uint8Array(n4) : t === void 0 ? r3 = new Uint8Array(n4, e3) : r3 = new Uint8Array(n4, e3, t), Object.setPrototypeOf(r3, u2.prototype), r3;
  }
  function Qn2(n4) {
    if (u2.isBuffer(n4)) {
      var e3 = Qe2(n4.length) | 0, t = q2(e3);
      return t.length === 0 || n4.copy(t, 0, 0, e3), t;
    }
    if (n4.length !== void 0) return typeof n4.length != "number" || et2(n4.length) ? q2(0) : Ye2(n4);
    if (n4.type === "Buffer" && Array.isArray(n4.data)) return Ye2(n4.data);
  }
  function Qe2(n4) {
    if (n4 >= Ce2) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + Ce2.toString(16) + " bytes");
    return n4 | 0;
  }
  function er2(n4) {
    return +n4 != n4 && (n4 = 0), u2.alloc(+n4);
  }
  u2.isBuffer = function(e3) {
    return e3 != null && e3._isBuffer === true && e3 !== u2.prototype;
  };
  u2.compare = function(e3, t) {
    if (L2(e3, Uint8Array) && (e3 = u2.from(e3, e3.offset, e3.byteLength)), L2(t, Uint8Array) && (t = u2.from(t, t.offset, t.byteLength)), !u2.isBuffer(e3) || !u2.isBuffer(t)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (e3 === t) return 0;
    for (var r3 = e3.length, a2 = t.length, s = 0, i = Math.min(r3, a2); s < i; ++s) if (e3[s] !== t[s]) {
      r3 = e3[s], a2 = t[s];
      break;
    }
    return r3 < a2 ? -1 : a2 < r3 ? 1 : 0;
  };
  u2.isEncoding = function(e3) {
    switch (String(e3).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  u2.concat = function(e3, t) {
    if (!Array.isArray(e3)) throw new TypeError('"list" argument must be an Array of Buffers');
    if (e3.length === 0) return u2.alloc(0);
    var r3;
    if (t === void 0) for (t = 0, r3 = 0; r3 < e3.length; ++r3) t += e3[r3].length;
    var a2 = u2.allocUnsafe(t), s = 0;
    for (r3 = 0; r3 < e3.length; ++r3) {
      var i = e3[r3];
      if (L2(i, Uint8Array)) s + i.length > a2.length ? u2.from(i).copy(a2, s) : Uint8Array.prototype.set.call(a2, i, s);
      else if (u2.isBuffer(i)) i.copy(a2, s);
      else throw new TypeError('"list" argument must be an Array of Buffers');
      s += i.length;
    }
    return a2;
  };
  function Rt2(n4, e3) {
    if (u2.isBuffer(n4)) return n4.length;
    if (ArrayBuffer.isView(n4) || L2(n4, ArrayBuffer)) return n4.byteLength;
    if (typeof n4 != "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof n4);
    var t = n4.length, r3 = arguments.length > 2 && arguments[2] === true;
    if (!r3 && t === 0) return 0;
    for (var a2 = false; ; ) switch (e3) {
      case "ascii":
      case "latin1":
      case "binary":
        return t;
      case "utf8":
      case "utf-8":
        return Ze2(n4).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return t * 2;
      case "hex":
        return t >>> 1;
      case "base64":
        return Pt2(n4).length;
      default:
        if (a2) return r3 ? -1 : Ze2(n4).length;
        e3 = ("" + e3).toLowerCase(), a2 = true;
    }
  }
  u2.byteLength = Rt2;
  function tr2(n4, e3, t) {
    var r3 = false;
    if ((e3 === void 0 || e3 < 0) && (e3 = 0), e3 > this.length || ((t === void 0 || t > this.length) && (t = this.length), t <= 0) || (t >>>= 0, e3 >>>= 0, t <= e3)) return "";
    for (n4 || (n4 = "utf8"); ; ) switch (n4) {
      case "hex":
        return yr2(this, e3, t);
      case "utf8":
      case "utf-8":
        return Bt2(this, e3, t);
      case "ascii":
        return pr2(this, e3, t);
      case "latin1":
      case "binary":
        return dr2(this, e3, t);
      case "base64":
        return or2(this, e3, t);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return lr2(this, e3, t);
      default:
        if (r3) throw new TypeError("Unknown encoding: " + n4);
        n4 = (n4 + "").toLowerCase(), r3 = true;
    }
  }
  u2.prototype._isBuffer = true;
  function ee2(n4, e3, t) {
    var r3 = n4[e3];
    n4[e3] = n4[t], n4[t] = r3;
  }
  u2.prototype.swap16 = function() {
    var e3 = this.length;
    if (e3 % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (var t = 0; t < e3; t += 2) ee2(this, t, t + 1);
    return this;
  };
  u2.prototype.swap32 = function() {
    var e3 = this.length;
    if (e3 % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (var t = 0; t < e3; t += 4) ee2(this, t, t + 3), ee2(this, t + 1, t + 2);
    return this;
  };
  u2.prototype.swap64 = function() {
    var e3 = this.length;
    if (e3 % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (var t = 0; t < e3; t += 8) ee2(this, t, t + 7), ee2(this, t + 1, t + 6), ee2(this, t + 2, t + 5), ee2(this, t + 3, t + 4);
    return this;
  };
  u2.prototype.toString = function() {
    var e3 = this.length;
    return e3 === 0 ? "" : arguments.length === 0 ? Bt2(this, 0, e3) : tr2.apply(this, arguments);
  };
  u2.prototype.toLocaleString = u2.prototype.toString;
  u2.prototype.equals = function(e3) {
    if (!u2.isBuffer(e3)) throw new TypeError("Argument must be a Buffer");
    return this === e3 ? true : u2.compare(this, e3) === 0;
  };
  u2.prototype.inspect = function() {
    var e3 = "", t = oe2.INSPECT_MAX_BYTES;
    return e3 = this.toString("hex", 0, t).replace(/(.{2})/g, "$1 ").trim(), this.length > t && (e3 += " ... "), "<Buffer " + e3 + ">";
  };
  _t2 && (u2.prototype[_t2] = u2.prototype.inspect);
  u2.prototype.compare = function(e3, t, r3, a2, s) {
    if (L2(e3, Uint8Array) && (e3 = u2.from(e3, e3.offset, e3.byteLength)), !u2.isBuffer(e3)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e3);
    if (t === void 0 && (t = 0), r3 === void 0 && (r3 = e3 ? e3.length : 0), a2 === void 0 && (a2 = 0), s === void 0 && (s = this.length), t < 0 || r3 > e3.length || a2 < 0 || s > this.length) throw new RangeError("out of range index");
    if (a2 >= s && t >= r3) return 0;
    if (a2 >= s) return -1;
    if (t >= r3) return 1;
    if (t >>>= 0, r3 >>>= 0, a2 >>>= 0, s >>>= 0, this === e3) return 0;
    for (var i = s - a2, o = r3 - t, p2 = Math.min(i, o), y2 = this.slice(a2, s), d2 = e3.slice(t, r3), l2 = 0; l2 < p2; ++l2) if (y2[l2] !== d2[l2]) {
      i = y2[l2], o = d2[l2];
      break;
    }
    return i < o ? -1 : o < i ? 1 : 0;
  };
  function Ut2(n4, e3, t, r3, a2) {
    if (n4.length === 0) return -1;
    if (typeof t == "string" ? (r3 = t, t = 0) : t > 2147483647 ? t = 2147483647 : t < -2147483648 && (t = -2147483648), t = +t, et2(t) && (t = a2 ? 0 : n4.length - 1), t < 0 && (t = n4.length + t), t >= n4.length) {
      if (a2) return -1;
      t = n4.length - 1;
    } else if (t < 0) if (a2) t = 0;
    else return -1;
    if (typeof e3 == "string" && (e3 = u2.from(e3, r3)), u2.isBuffer(e3)) return e3.length === 0 ? -1 : St2(n4, e3, t, r3, a2);
    if (typeof e3 == "number") return e3 = e3 & 255, typeof Uint8Array.prototype.indexOf == "function" ? a2 ? Uint8Array.prototype.indexOf.call(n4, e3, t) : Uint8Array.prototype.lastIndexOf.call(n4, e3, t) : St2(n4, [e3], t, r3, a2);
    throw new TypeError("val must be string, number or Buffer");
  }
  function St2(n4, e3, t, r3, a2) {
    var s = 1, i = n4.length, o = e3.length;
    if (r3 !== void 0 && (r3 = String(r3).toLowerCase(), r3 === "ucs2" || r3 === "ucs-2" || r3 === "utf16le" || r3 === "utf-16le")) {
      if (n4.length < 2 || e3.length < 2) return -1;
      s = 2, i /= 2, o /= 2, t /= 2;
    }
    function p2(f2, g2) {
      return s === 1 ? f2[g2] : f2.readUInt16BE(g2 * s);
    }
    var y2;
    if (a2) {
      var d2 = -1;
      for (y2 = t; y2 < i; y2++) if (p2(n4, y2) === p2(e3, d2 === -1 ? 0 : y2 - d2)) {
        if (d2 === -1 && (d2 = y2), y2 - d2 + 1 === o) return d2 * s;
      } else d2 !== -1 && (y2 -= y2 - d2), d2 = -1;
    } else for (t + o > i && (t = i - o), y2 = t; y2 >= 0; y2--) {
      for (var l2 = true, h2 = 0; h2 < o; h2++) if (p2(n4, y2 + h2) !== p2(e3, h2)) {
        l2 = false;
        break;
      }
      if (l2) return y2;
    }
    return -1;
  }
  u2.prototype.includes = function(e3, t, r3) {
    return this.indexOf(e3, t, r3) !== -1;
  };
  u2.prototype.indexOf = function(e3, t, r3) {
    return Ut2(this, e3, t, r3, true);
  };
  u2.prototype.lastIndexOf = function(e3, t, r3) {
    return Ut2(this, e3, t, r3, false);
  };
  function nr2(n4, e3, t, r3) {
    t = Number(t) || 0;
    var a2 = n4.length - t;
    r3 ? (r3 = Number(r3), r3 > a2 && (r3 = a2)) : r3 = a2;
    var s = e3.length;
    r3 > s / 2 && (r3 = s / 2);
    for (var i = 0; i < r3; ++i) {
      var o = parseInt(e3.substr(i * 2, 2), 16);
      if (et2(o)) return i;
      n4[t + i] = o;
    }
    return i;
  }
  function rr2(n4, e3, t, r3) {
    return Ie2(Ze2(e3, n4.length - t), n4, t, r3);
  }
  function ar2(n4, e3, t, r3) {
    return Ie2(fr2(e3), n4, t, r3);
  }
  function sr2(n4, e3, t, r3) {
    return Ie2(Pt2(e3), n4, t, r3);
  }
  function ir2(n4, e3, t, r3) {
    return Ie2(hr2(e3, n4.length - t), n4, t, r3);
  }
  u2.prototype.write = function(e3, t, r3, a2) {
    if (t === void 0) a2 = "utf8", r3 = this.length, t = 0;
    else if (r3 === void 0 && typeof t == "string") a2 = t, r3 = this.length, t = 0;
    else if (isFinite(t)) t = t >>> 0, isFinite(r3) ? (r3 = r3 >>> 0, a2 === void 0 && (a2 = "utf8")) : (a2 = r3, r3 = void 0);
    else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    var s = this.length - t;
    if ((r3 === void 0 || r3 > s) && (r3 = s), e3.length > 0 && (r3 < 0 || t < 0) || t > this.length) throw new RangeError("Attempt to write outside buffer bounds");
    a2 || (a2 = "utf8");
    for (var i = false; ; ) switch (a2) {
      case "hex":
        return nr2(this, e3, t, r3);
      case "utf8":
      case "utf-8":
        return rr2(this, e3, t, r3);
      case "ascii":
      case "latin1":
      case "binary":
        return ar2(this, e3, t, r3);
      case "base64":
        return sr2(this, e3, t, r3);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return ir2(this, e3, t, r3);
      default:
        if (i) throw new TypeError("Unknown encoding: " + a2);
        a2 = ("" + a2).toLowerCase(), i = true;
    }
  };
  u2.prototype.toJSON = function() {
    return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
  };
  function or2(n4, e3, t) {
    return e3 === 0 && t === n4.length ? je2.fromByteArray(n4) : je2.fromByteArray(n4.slice(e3, t));
  }
  function Bt2(n4, e3, t) {
    t = Math.min(n4.length, t);
    for (var r3 = [], a2 = e3; a2 < t; ) {
      var s = n4[a2], i = null, o = s > 239 ? 4 : s > 223 ? 3 : s > 191 ? 2 : 1;
      if (a2 + o <= t) {
        var p2, y2, d2, l2;
        switch (o) {
          case 1:
            s < 128 && (i = s);
            break;
          case 2:
            p2 = n4[a2 + 1], (p2 & 192) === 128 && (l2 = (s & 31) << 6 | p2 & 63, l2 > 127 && (i = l2));
            break;
          case 3:
            p2 = n4[a2 + 1], y2 = n4[a2 + 2], (p2 & 192) === 128 && (y2 & 192) === 128 && (l2 = (s & 15) << 12 | (p2 & 63) << 6 | y2 & 63, l2 > 2047 && (l2 < 55296 || l2 > 57343) && (i = l2));
            break;
          case 4:
            p2 = n4[a2 + 1], y2 = n4[a2 + 2], d2 = n4[a2 + 3], (p2 & 192) === 128 && (y2 & 192) === 128 && (d2 & 192) === 128 && (l2 = (s & 15) << 18 | (p2 & 63) << 12 | (y2 & 63) << 6 | d2 & 63, l2 > 65535 && l2 < 1114112 && (i = l2));
        }
      }
      i === null ? (i = 65533, o = 1) : i > 65535 && (i -= 65536, r3.push(i >>> 10 & 1023 | 55296), i = 56320 | i & 1023), r3.push(i), a2 += o;
    }
    return ur2(r3);
  }
  var Mt2 = 4096;
  function ur2(n4) {
    var e3 = n4.length;
    if (e3 <= Mt2) return String.fromCharCode.apply(String, n4);
    for (var t = "", r3 = 0; r3 < e3; ) t += String.fromCharCode.apply(String, n4.slice(r3, r3 += Mt2));
    return t;
  }
  function pr2(n4, e3, t) {
    var r3 = "";
    t = Math.min(n4.length, t);
    for (var a2 = e3; a2 < t; ++a2) r3 += String.fromCharCode(n4[a2] & 127);
    return r3;
  }
  function dr2(n4, e3, t) {
    var r3 = "";
    t = Math.min(n4.length, t);
    for (var a2 = e3; a2 < t; ++a2) r3 += String.fromCharCode(n4[a2]);
    return r3;
  }
  function yr2(n4, e3, t) {
    var r3 = n4.length;
    (!e3 || e3 < 0) && (e3 = 0), (!t || t < 0 || t > r3) && (t = r3);
    for (var a2 = "", s = e3; s < t; ++s) a2 += gr2[n4[s]];
    return a2;
  }
  function lr2(n4, e3, t) {
    for (var r3 = n4.slice(e3, t), a2 = "", s = 0; s < r3.length - 1; s += 2) a2 += String.fromCharCode(r3[s] + r3[s + 1] * 256);
    return a2;
  }
  u2.prototype.slice = function(e3, t) {
    var r3 = this.length;
    e3 = ~~e3, t = t === void 0 ? r3 : ~~t, e3 < 0 ? (e3 += r3, e3 < 0 && (e3 = 0)) : e3 > r3 && (e3 = r3), t < 0 ? (t += r3, t < 0 && (t = 0)) : t > r3 && (t = r3), t < e3 && (t = e3);
    var a2 = this.subarray(e3, t);
    return Object.setPrototypeOf(a2, u2.prototype), a2;
  };
  function I2(n4, e3, t) {
    if (n4 % 1 !== 0 || n4 < 0) throw new RangeError("offset is not uint");
    if (n4 + e3 > t) throw new RangeError("Trying to access beyond buffer length");
  }
  u2.prototype.readUintLE = u2.prototype.readUIntLE = function(e3, t, r3) {
    e3 = e3 >>> 0, t = t >>> 0, r3 || I2(e3, t, this.length);
    for (var a2 = this[e3], s = 1, i = 0; ++i < t && (s *= 256); ) a2 += this[e3 + i] * s;
    return a2;
  };
  u2.prototype.readUintBE = u2.prototype.readUIntBE = function(e3, t, r3) {
    e3 = e3 >>> 0, t = t >>> 0, r3 || I2(e3, t, this.length);
    for (var a2 = this[e3 + --t], s = 1; t > 0 && (s *= 256); ) a2 += this[e3 + --t] * s;
    return a2;
  };
  u2.prototype.readUint8 = u2.prototype.readUInt8 = function(e3, t) {
    return e3 = e3 >>> 0, t || I2(e3, 1, this.length), this[e3];
  };
  u2.prototype.readUint16LE = u2.prototype.readUInt16LE = function(e3, t) {
    return e3 = e3 >>> 0, t || I2(e3, 2, this.length), this[e3] | this[e3 + 1] << 8;
  };
  u2.prototype.readUint16BE = u2.prototype.readUInt16BE = function(e3, t) {
    return e3 = e3 >>> 0, t || I2(e3, 2, this.length), this[e3] << 8 | this[e3 + 1];
  };
  u2.prototype.readUint32LE = u2.prototype.readUInt32LE = function(e3, t) {
    return e3 = e3 >>> 0, t || I2(e3, 4, this.length), (this[e3] | this[e3 + 1] << 8 | this[e3 + 2] << 16) + this[e3 + 3] * 16777216;
  };
  u2.prototype.readUint32BE = u2.prototype.readUInt32BE = function(e3, t) {
    return e3 = e3 >>> 0, t || I2(e3, 4, this.length), this[e3] * 16777216 + (this[e3 + 1] << 16 | this[e3 + 2] << 8 | this[e3 + 3]);
  };
  u2.prototype.readIntLE = function(e3, t, r3) {
    e3 = e3 >>> 0, t = t >>> 0, r3 || I2(e3, t, this.length);
    for (var a2 = this[e3], s = 1, i = 0; ++i < t && (s *= 256); ) a2 += this[e3 + i] * s;
    return s *= 128, a2 >= s && (a2 -= Math.pow(2, 8 * t)), a2;
  };
  u2.prototype.readIntBE = function(e3, t, r3) {
    e3 = e3 >>> 0, t = t >>> 0, r3 || I2(e3, t, this.length);
    for (var a2 = t, s = 1, i = this[e3 + --a2]; a2 > 0 && (s *= 256); ) i += this[e3 + --a2] * s;
    return s *= 128, i >= s && (i -= Math.pow(2, 8 * t)), i;
  };
  u2.prototype.readInt8 = function(e3, t) {
    return e3 = e3 >>> 0, t || I2(e3, 1, this.length), this[e3] & 128 ? (255 - this[e3] + 1) * -1 : this[e3];
  };
  u2.prototype.readInt16LE = function(e3, t) {
    e3 = e3 >>> 0, t || I2(e3, 2, this.length);
    var r3 = this[e3] | this[e3 + 1] << 8;
    return r3 & 32768 ? r3 | 4294901760 : r3;
  };
  u2.prototype.readInt16BE = function(e3, t) {
    e3 = e3 >>> 0, t || I2(e3, 2, this.length);
    var r3 = this[e3 + 1] | this[e3] << 8;
    return r3 & 32768 ? r3 | 4294901760 : r3;
  };
  u2.prototype.readInt32LE = function(e3, t) {
    return e3 = e3 >>> 0, t || I2(e3, 4, this.length), this[e3] | this[e3 + 1] << 8 | this[e3 + 2] << 16 | this[e3 + 3] << 24;
  };
  u2.prototype.readInt32BE = function(e3, t) {
    return e3 = e3 >>> 0, t || I2(e3, 4, this.length), this[e3] << 24 | this[e3 + 1] << 16 | this[e3 + 2] << 8 | this[e3 + 3];
  };
  u2.prototype.readFloatLE = function(e3, t) {
    return e3 = e3 >>> 0, t || I2(e3, 4, this.length), ie2.read(this, e3, true, 23, 4);
  };
  u2.prototype.readFloatBE = function(e3, t) {
    return e3 = e3 >>> 0, t || I2(e3, 4, this.length), ie2.read(this, e3, false, 23, 4);
  };
  u2.prototype.readDoubleLE = function(e3, t) {
    return e3 = e3 >>> 0, t || I2(e3, 8, this.length), ie2.read(this, e3, true, 52, 8);
  };
  u2.prototype.readDoubleBE = function(e3, t) {
    return e3 = e3 >>> 0, t || I2(e3, 8, this.length), ie2.read(this, e3, false, 52, 8);
  };
  function B2(n4, e3, t, r3, a2, s) {
    if (!u2.isBuffer(n4)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (e3 > a2 || e3 < s) throw new RangeError('"value" argument is out of bounds');
    if (t + r3 > n4.length) throw new RangeError("Index out of range");
  }
  u2.prototype.writeUintLE = u2.prototype.writeUIntLE = function(e3, t, r3, a2) {
    if (e3 = +e3, t = t >>> 0, r3 = r3 >>> 0, !a2) {
      var s = Math.pow(2, 8 * r3) - 1;
      B2(this, e3, t, r3, s, 0);
    }
    var i = 1, o = 0;
    for (this[t] = e3 & 255; ++o < r3 && (i *= 256); ) this[t + o] = e3 / i & 255;
    return t + r3;
  };
  u2.prototype.writeUintBE = u2.prototype.writeUIntBE = function(e3, t, r3, a2) {
    if (e3 = +e3, t = t >>> 0, r3 = r3 >>> 0, !a2) {
      var s = Math.pow(2, 8 * r3) - 1;
      B2(this, e3, t, r3, s, 0);
    }
    var i = r3 - 1, o = 1;
    for (this[t + i] = e3 & 255; --i >= 0 && (o *= 256); ) this[t + i] = e3 / o & 255;
    return t + r3;
  };
  u2.prototype.writeUint8 = u2.prototype.writeUInt8 = function(e3, t, r3) {
    return e3 = +e3, t = t >>> 0, r3 || B2(this, e3, t, 1, 255, 0), this[t] = e3 & 255, t + 1;
  };
  u2.prototype.writeUint16LE = u2.prototype.writeUInt16LE = function(e3, t, r3) {
    return e3 = +e3, t = t >>> 0, r3 || B2(this, e3, t, 2, 65535, 0), this[t] = e3 & 255, this[t + 1] = e3 >>> 8, t + 2;
  };
  u2.prototype.writeUint16BE = u2.prototype.writeUInt16BE = function(e3, t, r3) {
    return e3 = +e3, t = t >>> 0, r3 || B2(this, e3, t, 2, 65535, 0), this[t] = e3 >>> 8, this[t + 1] = e3 & 255, t + 2;
  };
  u2.prototype.writeUint32LE = u2.prototype.writeUInt32LE = function(e3, t, r3) {
    return e3 = +e3, t = t >>> 0, r3 || B2(this, e3, t, 4, 4294967295, 0), this[t + 3] = e3 >>> 24, this[t + 2] = e3 >>> 16, this[t + 1] = e3 >>> 8, this[t] = e3 & 255, t + 4;
  };
  u2.prototype.writeUint32BE = u2.prototype.writeUInt32BE = function(e3, t, r3) {
    return e3 = +e3, t = t >>> 0, r3 || B2(this, e3, t, 4, 4294967295, 0), this[t] = e3 >>> 24, this[t + 1] = e3 >>> 16, this[t + 2] = e3 >>> 8, this[t + 3] = e3 & 255, t + 4;
  };
  u2.prototype.writeIntLE = function(e3, t, r3, a2) {
    if (e3 = +e3, t = t >>> 0, !a2) {
      var s = Math.pow(2, 8 * r3 - 1);
      B2(this, e3, t, r3, s - 1, -s);
    }
    var i = 0, o = 1, p2 = 0;
    for (this[t] = e3 & 255; ++i < r3 && (o *= 256); ) e3 < 0 && p2 === 0 && this[t + i - 1] !== 0 && (p2 = 1), this[t + i] = (e3 / o >> 0) - p2 & 255;
    return t + r3;
  };
  u2.prototype.writeIntBE = function(e3, t, r3, a2) {
    if (e3 = +e3, t = t >>> 0, !a2) {
      var s = Math.pow(2, 8 * r3 - 1);
      B2(this, e3, t, r3, s - 1, -s);
    }
    var i = r3 - 1, o = 1, p2 = 0;
    for (this[t + i] = e3 & 255; --i >= 0 && (o *= 256); ) e3 < 0 && p2 === 0 && this[t + i + 1] !== 0 && (p2 = 1), this[t + i] = (e3 / o >> 0) - p2 & 255;
    return t + r3;
  };
  u2.prototype.writeInt8 = function(e3, t, r3) {
    return e3 = +e3, t = t >>> 0, r3 || B2(this, e3, t, 1, 127, -128), e3 < 0 && (e3 = 255 + e3 + 1), this[t] = e3 & 255, t + 1;
  };
  u2.prototype.writeInt16LE = function(e3, t, r3) {
    return e3 = +e3, t = t >>> 0, r3 || B2(this, e3, t, 2, 32767, -32768), this[t] = e3 & 255, this[t + 1] = e3 >>> 8, t + 2;
  };
  u2.prototype.writeInt16BE = function(e3, t, r3) {
    return e3 = +e3, t = t >>> 0, r3 || B2(this, e3, t, 2, 32767, -32768), this[t] = e3 >>> 8, this[t + 1] = e3 & 255, t + 2;
  };
  u2.prototype.writeInt32LE = function(e3, t, r3) {
    return e3 = +e3, t = t >>> 0, r3 || B2(this, e3, t, 4, 2147483647, -2147483648), this[t] = e3 & 255, this[t + 1] = e3 >>> 8, this[t + 2] = e3 >>> 16, this[t + 3] = e3 >>> 24, t + 4;
  };
  u2.prototype.writeInt32BE = function(e3, t, r3) {
    return e3 = +e3, t = t >>> 0, r3 || B2(this, e3, t, 4, 2147483647, -2147483648), e3 < 0 && (e3 = 4294967295 + e3 + 1), this[t] = e3 >>> 24, this[t + 1] = e3 >>> 16, this[t + 2] = e3 >>> 8, this[t + 3] = e3 & 255, t + 4;
  };
  function Ft2(n4, e3, t, r3, a2, s) {
    if (t + r3 > n4.length) throw new RangeError("Index out of range");
    if (t < 0) throw new RangeError("Index out of range");
  }
  function Ot2(n4, e3, t, r3, a2) {
    return e3 = +e3, t = t >>> 0, a2 || Ft2(n4, e3, t, 4), ie2.write(n4, e3, t, r3, 23, 4), t + 4;
  }
  u2.prototype.writeFloatLE = function(e3, t, r3) {
    return Ot2(this, e3, t, true, r3);
  };
  u2.prototype.writeFloatBE = function(e3, t, r3) {
    return Ot2(this, e3, t, false, r3);
  };
  function Dt2(n4, e3, t, r3, a2) {
    return e3 = +e3, t = t >>> 0, a2 || Ft2(n4, e3, t, 8), ie2.write(n4, e3, t, r3, 52, 8), t + 8;
  }
  u2.prototype.writeDoubleLE = function(e3, t, r3) {
    return Dt2(this, e3, t, true, r3);
  };
  u2.prototype.writeDoubleBE = function(e3, t, r3) {
    return Dt2(this, e3, t, false, r3);
  };
  u2.prototype.copy = function(e3, t, r3, a2) {
    if (!u2.isBuffer(e3)) throw new TypeError("argument should be a Buffer");
    if (r3 || (r3 = 0), !a2 && a2 !== 0 && (a2 = this.length), t >= e3.length && (t = e3.length), t || (t = 0), a2 > 0 && a2 < r3 && (a2 = r3), a2 === r3 || e3.length === 0 || this.length === 0) return 0;
    if (t < 0) throw new RangeError("targetStart out of bounds");
    if (r3 < 0 || r3 >= this.length) throw new RangeError("Index out of range");
    if (a2 < 0) throw new RangeError("sourceEnd out of bounds");
    a2 > this.length && (a2 = this.length), e3.length - t < a2 - r3 && (a2 = e3.length - t + r3);
    var s = a2 - r3;
    return this === e3 && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(t, r3, a2) : Uint8Array.prototype.set.call(e3, this.subarray(r3, a2), t), s;
  };
  u2.prototype.fill = function(e3, t, r3, a2) {
    if (typeof e3 == "string") {
      if (typeof t == "string" ? (a2 = t, t = 0, r3 = this.length) : typeof r3 == "string" && (a2 = r3, r3 = this.length), a2 !== void 0 && typeof a2 != "string") throw new TypeError("encoding must be a string");
      if (typeof a2 == "string" && !u2.isEncoding(a2)) throw new TypeError("Unknown encoding: " + a2);
      if (e3.length === 1) {
        var s = e3.charCodeAt(0);
        (a2 === "utf8" && s < 128 || a2 === "latin1") && (e3 = s);
      }
    } else typeof e3 == "number" ? e3 = e3 & 255 : typeof e3 == "boolean" && (e3 = Number(e3));
    if (t < 0 || this.length < t || this.length < r3) throw new RangeError("Out of range index");
    if (r3 <= t) return this;
    t = t >>> 0, r3 = r3 === void 0 ? this.length : r3 >>> 0, e3 || (e3 = 0);
    var i;
    if (typeof e3 == "number") for (i = t; i < r3; ++i) this[i] = e3;
    else {
      var o = u2.isBuffer(e3) ? e3 : u2.from(e3, a2), p2 = o.length;
      if (p2 === 0) throw new TypeError('The value "' + e3 + '" is invalid for argument "value"');
      for (i = 0; i < r3 - t; ++i) this[i + t] = o[i % p2];
    }
    return this;
  };
  var cr2 = /[^+/0-9A-Za-z-_]/g;
  function mr2(n4) {
    if (n4 = n4.split("=")[0], n4 = n4.trim().replace(cr2, ""), n4.length < 2) return "";
    for (; n4.length % 4 !== 0; ) n4 = n4 + "=";
    return n4;
  }
  function Ze2(n4, e3) {
    e3 = e3 || 1 / 0;
    for (var t, r3 = n4.length, a2 = null, s = [], i = 0; i < r3; ++i) {
      if (t = n4.charCodeAt(i), t > 55295 && t < 57344) {
        if (!a2) {
          if (t > 56319) {
            (e3 -= 3) > -1 && s.push(239, 191, 189);
            continue;
          } else if (i + 1 === r3) {
            (e3 -= 3) > -1 && s.push(239, 191, 189);
            continue;
          }
          a2 = t;
          continue;
        }
        if (t < 56320) {
          (e3 -= 3) > -1 && s.push(239, 191, 189), a2 = t;
          continue;
        }
        t = (a2 - 55296 << 10 | t - 56320) + 65536;
      } else a2 && (e3 -= 3) > -1 && s.push(239, 191, 189);
      if (a2 = null, t < 128) {
        if ((e3 -= 1) < 0) break;
        s.push(t);
      } else if (t < 2048) {
        if ((e3 -= 2) < 0) break;
        s.push(t >> 6 | 192, t & 63 | 128);
      } else if (t < 65536) {
        if ((e3 -= 3) < 0) break;
        s.push(t >> 12 | 224, t >> 6 & 63 | 128, t & 63 | 128);
      } else if (t < 1114112) {
        if ((e3 -= 4) < 0) break;
        s.push(t >> 18 | 240, t >> 12 & 63 | 128, t >> 6 & 63 | 128, t & 63 | 128);
      } else throw new Error("Invalid code point");
    }
    return s;
  }
  function fr2(n4) {
    for (var e3 = [], t = 0; t < n4.length; ++t) e3.push(n4.charCodeAt(t) & 255);
    return e3;
  }
  function hr2(n4, e3) {
    for (var t, r3, a2, s = [], i = 0; i < n4.length && !((e3 -= 2) < 0); ++i) t = n4.charCodeAt(i), r3 = t >> 8, a2 = t % 256, s.push(a2), s.push(r3);
    return s;
  }
  function Pt2(n4) {
    return je2.toByteArray(mr2(n4));
  }
  function Ie2(n4, e3, t, r3) {
    for (var a2 = 0; a2 < r3 && !(a2 + t >= e3.length || a2 >= n4.length); ++a2) e3[a2 + t] = n4[a2];
    return a2;
  }
  function L2(n4, e3) {
    return n4 instanceof e3 || n4 != null && n4.constructor != null && n4.constructor.name != null && n4.constructor.name === e3.name;
  }
  function et2(n4) {
    return n4 !== n4;
  }
  var gr2 = function() {
    for (var n4 = "0123456789abcdef", e3 = new Array(256), t = 0; t < 16; ++t) for (var r3 = t * 16, a2 = 0; a2 < 16; ++a2) e3[r3 + a2] = n4[t] + n4[a2];
    return e3;
  }();
});
var Wt$6 = se$4((ma2, Lt2) => {
  c();
  var v2 = Lt2.exports = {}, W2, G2;
  function nt2() {
    throw new Error("setTimeout has not been defined");
  }
  function rt2() {
    throw new Error("clearTimeout has not been defined");
  }
  (function() {
    try {
      typeof setTimeout == "function" ? W2 = setTimeout : W2 = nt2;
    } catch {
      W2 = nt2;
    }
    try {
      typeof clearTimeout == "function" ? G2 = clearTimeout : G2 = rt2;
    } catch {
      G2 = rt2;
    }
  })();
  function Kt2(n4) {
    if (W2 === setTimeout) return setTimeout(n4, 0);
    if ((W2 === nt2 || !W2) && setTimeout) return W2 = setTimeout, setTimeout(n4, 0);
    try {
      return W2(n4, 0);
    } catch {
      try {
        return W2.call(null, n4, 0);
      } catch {
        return W2.call(this, n4, 0);
      }
    }
  }
  function br2(n4) {
    if (G2 === clearTimeout) return clearTimeout(n4);
    if ((G2 === rt2 || !G2) && clearTimeout) return G2 = clearTimeout, clearTimeout(n4);
    try {
      return G2(n4);
    } catch {
      try {
        return G2.call(null, n4);
      } catch {
        return G2.call(this, n4);
      }
    }
  }
  var j2 = [], ue3 = false, te2, _e4 = -1;
  function wr2() {
    !ue3 || !te2 || (ue3 = false, te2.length ? j2 = te2.concat(j2) : _e4 = -1, j2.length && Vt2());
  }
  function Vt2() {
    if (!ue3) {
      var n4 = Kt2(wr2);
      ue3 = true;
      for (var e3 = j2.length; e3; ) {
        for (te2 = j2, j2 = []; ++_e4 < e3; ) te2 && te2[_e4].run();
        _e4 = -1, e3 = j2.length;
      }
      te2 = null, ue3 = false, br2(n4);
    }
  }
  v2.nextTick = function(n4) {
    var e3 = new Array(arguments.length - 1);
    if (arguments.length > 1) for (var t = 1; t < arguments.length; t++) e3[t - 1] = arguments[t];
    j2.push(new Ht2(n4, e3)), j2.length === 1 && !ue3 && Kt2(Vt2);
  };
  function Ht2(n4, e3) {
    this.fun = n4, this.array = e3;
  }
  Ht2.prototype.run = function() {
    this.fun.apply(null, this.array);
  };
  v2.title = "browser";
  v2.browser = true;
  v2.env = {};
  v2.argv = [];
  v2.version = "";
  v2.versions = {};
  function Y2() {
  }
  v2.on = Y2;
  v2.addListener = Y2;
  v2.once = Y2;
  v2.off = Y2;
  v2.removeListener = Y2;
  v2.removeAllListeners = Y2;
  v2.emit = Y2;
  v2.prependListener = Y2;
  v2.prependOnceListener = Y2;
  v2.listeners = function(n4) {
    return [];
  };
  v2.binding = function(n4) {
    throw new Error("process.binding is not supported");
  };
  v2.cwd = function() {
    return "/";
  };
  v2.chdir = function(n4) {
    throw new Error("process.chdir is not supported");
  };
  v2.umask = function() {
    return 0;
  };
});
var w$5, Tr$3, b$4, c = Kn$1(() => {
  w$5 = fe$5(tt$4()), fe$5(Wt$6()), Tr$3 = function(n4) {
    function e3() {
      var r3 = this || self;
      return delete n4.prototype.__magic__, r3;
    }
    if (typeof globalThis == "object") return globalThis;
    if (this) return e3();
    n4.defineProperty(n4.prototype, "__magic__", { configurable: true, get: e3 });
    var t = __magic__;
    return t;
  }(Object), b$4 = Tr$3;
});
var zt$5 = se$4((ga, Gt2) => {
  c();
  function Ar2(n4) {
    if (n4.length >= 255) throw new TypeError("Alphabet too long");
    for (var e3 = new Uint8Array(256), t = 0; t < e3.length; t++) e3[t] = 255;
    for (var r3 = 0; r3 < n4.length; r3++) {
      var a2 = n4.charAt(r3), s = a2.charCodeAt(0);
      if (e3[s] !== 255) throw new TypeError(a2 + " is ambiguous");
      e3[s] = r3;
    }
    var i = n4.length, o = n4.charAt(0), p2 = Math.log(i) / Math.log(256), y2 = Math.log(256) / Math.log(i);
    function d2(f2) {
      if (f2 instanceof Uint8Array || (ArrayBuffer.isView(f2) ? f2 = new Uint8Array(f2.buffer, f2.byteOffset, f2.byteLength) : Array.isArray(f2) && (f2 = Uint8Array.from(f2))), !(f2 instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
      if (f2.length === 0) return "";
      for (var g2 = 0, A2 = 0, C2 = 0, k2 = f2.length; C2 !== k2 && f2[C2] === 0; ) C2++, g2++;
      for (var O2 = (k2 - C2) * y2 + 1 >>> 0, V2 = new Uint8Array(O2); C2 !== k2; ) {
        for (var M2 = f2[C2], X2 = 0, P2 = O2 - 1; (M2 !== 0 || X2 < A2) && P2 !== -1; P2--, X2++) M2 += 256 * V2[P2] >>> 0, V2[P2] = M2 % i >>> 0, M2 = M2 / i >>> 0;
        if (M2 !== 0) throw new Error("Non-zero carry");
        A2 = X2, C2++;
      }
      for (var N2 = O2 - A2; N2 !== O2 && V2[N2] === 0; ) N2++;
      for (var me2 = o.repeat(g2); N2 < O2; ++N2) me2 += n4.charAt(V2[N2]);
      return me2;
    }
    function l2(f2) {
      if (typeof f2 != "string") throw new TypeError("Expected String");
      if (f2.length === 0) return new Uint8Array();
      for (var g2 = 0, A2 = 0, C2 = 0; f2[g2] === o; ) A2++, g2++;
      for (var k2 = (f2.length - g2) * p2 + 1 >>> 0, O2 = new Uint8Array(k2); f2[g2]; ) {
        var V2 = f2.charCodeAt(g2);
        if (V2 > 255) return;
        var M2 = e3[V2];
        if (M2 === 255) return;
        for (var X2 = 0, P2 = k2 - 1; (M2 !== 0 || X2 < C2) && P2 !== -1; P2--, X2++) M2 += i * O2[P2] >>> 0, O2[P2] = M2 % 256 >>> 0, M2 = M2 / 256 >>> 0;
        if (M2 !== 0) throw new Error("Non-zero carry");
        C2 = X2, g2++;
      }
      for (var N2 = k2 - C2; N2 !== k2 && O2[N2] === 0; ) N2++;
      for (var me2 = new Uint8Array(A2 + (k2 - N2)), Un2 = A2; N2 !== k2; ) me2[Un2++] = O2[N2++];
      return me2;
    }
    function h2(f2) {
      var g2 = l2(f2);
      if (g2) return g2;
      throw new Error("Non-base" + i + " character");
    }
    return { encode: d2, decodeUnsafe: l2, decode: h2 };
  }
  Gt2.exports = Ar2;
});
var at$4 = se$4((wa, Xt2) => {
  c();
  var vr2 = zt$5(), xr2 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
  Xt2.exports = vr2(xr2);
});
c();
c();
c();
var ge$5 = fe$5(at$4());
c();
var S$5 = 2n ** 255n - 19n, pe$5 = 2n ** 252n + 27742317777372353535851937790883648493n, st$3 = 0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51an, it$3 = 0x6666666666666666666666666666666666666666666666666666666666666658n, Se$7 = { a: -1n, d: 37095705934669439343138083508754565189542113879843219016388785533085940283555n, h: 8 }, R$2 = (n4 = "") => {
  throw new Error(n4);
}, Zt$4 = (n4) => typeof n4 == "string", Ne$5 = (n4, e3) => !(n4 instanceof Uint8Array) || typeof e3 == "number" && e3 > 0 && n4.length !== e3 ? R$2("Uint8Array expected") : n4, de$2 = (n4) => new Uint8Array(n4), Re$6 = (n4, e3) => Ne$5(Zt$4(n4) ? pt$6(n4) : de$2(n4), e3), m$3 = (n4, e3 = S$5) => {
  let t = n4 % e3;
  return t >= 0n ? t : e3 + t;
}, qt$4 = (n4) => n4 instanceof J$2 ? n4 : R$2("Point expected"), jt$5, J$2 = class n {
  constructor(e3, t, r3, a2) {
    this.ex = e3, this.ey = t, this.ez = r3, this.et = a2;
  }
  static fromAffine(e3) {
    return new n(e3.x, e3.y, 1n, m$3(e3.x * e3.y));
  }
  static fromHex(e3, t = true) {
    let { d: r3 } = Se$7;
    e3 = Re$6(e3, 32);
    let a2 = e3.slice();
    a2[31] = e3[31] & -129;
    let s = en$2(a2);
    s === 0n || (t && !(0n < s && s < S$5) && R$2("bad y coord 1"), !t && !(0n < s && s < 2n ** 256n) && R$2("bad y coord 2"));
    let i = m$3(s * s), o = m$3(i - 1n), p2 = m$3(r3 * i + 1n), { isValid: y2, value: d2 } = Cr$2(o, p2);
    y2 || R$2("bad y coordinate 3");
    let l2 = (d2 & 1n) === 1n;
    return (e3[31] & 128) !== 0 !== l2 && (d2 = m$3(-d2)), new n(d2, s, 1n, m$3(d2 * s));
  }
  get x() {
    return this.toAffine().x;
  }
  get y() {
    return this.toAffine().y;
  }
  equals(e3) {
    let { ex: t, ey: r3, ez: a2 } = this, { ex: s, ey: i, ez: o } = qt$4(e3), p2 = m$3(t * o), y2 = m$3(s * a2), d2 = m$3(r3 * o), l2 = m$3(i * a2);
    return p2 === y2 && d2 === l2;
  }
  is0() {
    return this.equals(Me$7);
  }
  negate() {
    return new n(m$3(-this.ex), this.ey, this.ez, m$3(-this.et));
  }
  double() {
    let { ex: e3, ey: t, ez: r3 } = this, { a: a2 } = Se$7, s = m$3(e3 * e3), i = m$3(t * t), o = m$3(2n * m$3(r3 * r3)), p2 = m$3(a2 * s), y2 = e3 + t, d2 = m$3(m$3(y2 * y2) - s - i), l2 = p2 + i, h2 = l2 - o, f2 = p2 - i, g2 = m$3(d2 * h2), A2 = m$3(l2 * f2), C2 = m$3(d2 * f2), k2 = m$3(h2 * l2);
    return new n(g2, A2, k2, C2);
  }
  add(e3) {
    let { ex: t, ey: r3, ez: a2, et: s } = this, { ex: i, ey: o, ez: p2, et: y2 } = qt$4(e3), { a: d2, d: l2 } = Se$7, h2 = m$3(t * i), f2 = m$3(r3 * o), g2 = m$3(s * l2 * y2), A2 = m$3(a2 * p2), C2 = m$3((t + r3) * (i + o) - h2 - f2), k2 = m$3(A2 - g2), O2 = m$3(A2 + g2), V2 = m$3(f2 - d2 * h2), M2 = m$3(C2 * k2), X2 = m$3(O2 * V2), P2 = m$3(C2 * V2), N2 = m$3(k2 * O2);
    return new n(M2, X2, N2, P2);
  }
  mul(e3, t = true) {
    if (e3 === 0n) return t === true ? R$2("cannot multiply by 0") : Me$7;
    if (typeof e3 == "bigint" && 0n < e3 && e3 < pe$5 || R$2("invalid scalar, must be < L"), !t && this.is0() || e3 === 1n) return this;
    if (this.equals(re$4)) return kr$3(e3).p;
    let r3 = Me$7, a2 = re$4;
    for (let s = this; e3 > 0n; s = s.double(), e3 >>= 1n) e3 & 1n ? r3 = r3.add(s) : t && (a2 = a2.add(s));
    return r3;
  }
  multiply(e3) {
    return this.mul(e3);
  }
  clearCofactor() {
    return this.mul(BigInt(Se$7.h), false);
  }
  isSmallOrder() {
    return this.clearCofactor().is0();
  }
  isTorsionFree() {
    let e3 = this.mul(pe$5 / 2n, false).double();
    return pe$5 % 2n && (e3 = e3.add(this)), e3.is0();
  }
  toAffine() {
    let { ex: e3, ey: t, ez: r3 } = this;
    if (this.is0()) return { x: 0n, y: 0n };
    let a2 = tn$2(r3);
    return m$3(r3 * a2) !== 1n && R$2("invalid inverse"), { x: m$3(e3 * a2), y: m$3(t * a2) };
  }
  toRawBytes() {
    let { x: e3, y: t } = this.toAffine(), r3 = Qt$5(t);
    return r3[31] |= e3 & 1n ? 128 : 0, r3;
  }
  toHex() {
    return ut$3(this.toRawBytes());
  }
};
J$2.BASE = new J$2(st$3, it$3, 1n, m$3(st$3 * it$3));
J$2.ZERO = new J$2(0n, 1n, 1n, 0n);
var { BASE: re$4, ZERO: Me$7 } = J$2, $t$8 = (n4, e3) => n4.toString(16).padStart(e3, "0"), ut$3 = (n4) => Array.from(n4).map((e3) => $t$8(e3, 2)).join(""), pt$6 = (n4) => {
  let e3 = n4.length;
  (!Zt$4(n4) || e3 % 2) && R$2("hex invalid 1");
  let t = de$2(e3 / 2);
  for (let r3 = 0; r3 < t.length; r3++) {
    let a2 = r3 * 2, s = n4.slice(a2, a2 + 2), i = Number.parseInt(s, 16);
    (Number.isNaN(i) || i < 0) && R$2("hex invalid 2"), t[r3] = i;
  }
  return t;
}, Qt$5 = (n4) => pt$6($t$8(n4, 32 * 2)).reverse(), en$2 = (n4) => BigInt("0x" + ut$3(de$2(Ne$5(n4)).reverse())), ke$4 = (...n4) => {
  let e3 = de$2(n4.reduce((r3, a2) => r3 + Ne$5(a2).length, 0)), t = 0;
  return n4.forEach((r3) => {
    e3.set(r3, t), t += r3.length;
  }), e3;
}, tn$2 = (n4, e3 = S$5) => {
  (n4 === 0n || e3 <= 0n) && R$2("no inverse n=" + n4 + " mod=" + e3);
  let t = m$3(n4, e3), r3 = e3, a2 = 0n, i = 1n;
  for (; t !== 0n; ) {
    let p2 = r3 / t, y2 = r3 % t, d2 = a2 - i * p2;
    r3 = t, t = y2, a2 = i, i = d2;
  }
  return r3 === 1n ? m$3(a2, e3) : R$2("no inverse");
}, z$3 = (n4, e3) => {
  let t = n4;
  for (; e3-- > 0n; ) t *= t, t %= S$5;
  return t;
}, Er$1 = (n4) => {
  let t = n4 * n4 % S$5 * n4 % S$5, r3 = z$3(t, 2n) * t % S$5, a2 = z$3(r3, 1n) * n4 % S$5, s = z$3(a2, 5n) * a2 % S$5, i = z$3(s, 10n) * s % S$5, o = z$3(i, 20n) * i % S$5, p2 = z$3(o, 40n) * o % S$5, y2 = z$3(p2, 80n) * p2 % S$5, d2 = z$3(y2, 80n) * p2 % S$5, l2 = z$3(d2, 10n) * s % S$5;
  return { pow_p_5_8: z$3(l2, 2n) * n4 % S$5, b2: t };
}, Yt$3 = 19681161376707505956807079304988542015446066515923890162744021073123829784752n, Cr$2 = (n4, e3) => {
  let t = m$3(e3 * e3 * e3), r3 = m$3(t * t * e3), a2 = Er$1(n4 * r3).pow_p_5_8, s = m$3(n4 * t * a2), i = m$3(e3 * s * s), o = s, p2 = m$3(s * Yt$3), y2 = i === n4, d2 = i === m$3(-n4), l2 = i === m$3(-n4 * Yt$3);
  return y2 && (s = o), (d2 || l2) && (s = p2), (m$3(s) & 1n) === 1n && (s = m$3(-s)), { isValid: y2 || d2, value: s };
}, ot$5 = (n4) => m$3(en$2(n4), pe$5), he$7, dt$4 = (...n4) => lt$6.sha512Async(...n4), nn$3 = (...n4) => typeof he$7 == "function" ? he$7(...n4) : R$2("etc.sha512Sync not set"), rn$2 = (n4) => {
  let e3 = n4.slice(0, 32);
  e3[0] &= 248, e3[31] &= 127, e3[31] |= 64;
  let t = n4.slice(32, 64), r3 = ot$5(e3), a2 = re$4.mul(r3), s = a2.toRawBytes();
  return { head: e3, prefix: t, scalar: r3, point: a2, pointBytes: s };
}, yt$5 = (n4) => dt$4(Re$6(n4, 32)).then(rn$2), Ir$2 = (n4) => rn$2(nn$3(Re$6(n4, 32))), an$1 = (n4) => yt$5(n4).then((e3) => e3.pointBytes);
function _r$2(n4, e3) {
  return n4 ? dt$4(e3.hashable).then(e3.finish) : e3.finish(nn$3(e3.hashable));
}
var Sr$1 = (n4, e3, t) => {
  let { pointBytes: r3, scalar: a2 } = n4, s = ot$5(e3), i = re$4.mul(s).toRawBytes();
  return { hashable: ke$4(i, r3, t), finish: (y2) => {
    let d2 = m$3(s + ot$5(y2) * a2, pe$5);
    return Ne$5(ke$4(i, Qt$5(d2)), 64);
  } };
}, sn$1 = async (n4, e3) => {
  let t = Re$6(n4), r3 = await yt$5(e3), a2 = await dt$4(r3.prefix, t);
  return _r$2(true, Sr$1(r3, a2, t));
};
var Jt$3 = () => typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0, lt$6 = { bytesToHex: ut$3, hexToBytes: pt$6, concatBytes: ke$4, mod: m$3, invert: tn$2, randomBytes: (n4) => {
  let e3 = Jt$3();
  return e3 || R$2("crypto.getRandomValues must be defined"), e3.getRandomValues(de$2(n4));
}, sha512Async: async (...n4) => {
  let e3 = Jt$3();
  e3 || R$2("crypto.subtle or etc.sha512Async must be defined");
  let t = ke$4(...n4);
  return de$2(await e3.subtle.digest("SHA-512", t.buffer));
}, sha512Sync: void 0 };
Object.defineProperties(lt$6, { sha512Sync: { configurable: false, get() {
  return he$7;
}, set(n4) {
  he$7 || (he$7 = n4);
} } });
var Ue$7 = { getExtendedPublicKeyAsync: yt$5, getExtendedPublicKey: Ir$2, randomPrivateKey: () => lt$6.randomBytes(32), precompute(n4 = 8, e3 = re$4) {
  return e3.multiply(3n), e3;
} }, ne$5 = 8, Mr$1 = () => {
  let n4 = [], e3 = 256 / ne$5 + 1, t = re$4, r3 = t;
  for (let a2 = 0; a2 < e3; a2++) {
    r3 = t, n4.push(r3);
    for (let s = 1; s < 2 ** (ne$5 - 1); s++) r3 = r3.add(t), n4.push(r3);
    t = r3.double();
  }
  return n4;
}, kr$3 = (n4) => {
  let e3 = jt$5 || (jt$5 = Mr$1()), t = (d2, l2) => {
    let h2 = l2.negate();
    return d2 ? h2 : l2;
  }, r3 = Me$7, a2 = re$4, s = 1 + 256 / ne$5, i = 2 ** (ne$5 - 1), o = BigInt(2 ** ne$5 - 1), p2 = 2 ** ne$5, y2 = BigInt(ne$5);
  for (let d2 = 0; d2 < s; d2++) {
    let l2 = d2 * i, h2 = Number(n4 & o);
    n4 >>= y2, h2 > i && (h2 -= p2, n4 += 1n);
    let f2 = l2, g2 = l2 + Math.abs(h2) - 1, A2 = d2 % 2 !== 0, C2 = h2 < 0;
    h2 === 0 ? a2 = a2.add(t(A2, e3[f2])) : r3 = r3.add(t(C2, e3[g2]));
  }
  return { p: r3, f: a2 };
};
var K$5 = class n2 {
  static generateKey() {
    let e3, t;
    do
      e3 = Ue$7.randomPrivateKey(), t = (0, ge$5.encode)(e3);
    while (t.length !== 44);
    return new n2(t);
  }
  constructor(e3) {
    this.secretKey = e3;
    let t = (0, ge$5.decode)(e3);
    this.privateKey = w$5.Buffer.from(t).toString("hex");
  }
  async sign(e3) {
    return await sn$1(e3, this.privateKey);
  }
  async getPublicKey() {
    let e3 = await an$1(this.privateKey);
    return `ed25519:${(0, ge$5.encode)(e3)}`;
  }
  toString() {
    return this.privateKey;
  }
};
var Be$5 = class Be {
  constructor(e3 = "testnet") {
    this.networkId = e3;
  }
  get keyPrefix() {
    return `orderly_${this.networkId}_`;
  }
}, be$7 = class be extends Be$5 {
  getOrderlyKey(e3) {
    let t;
    if (e3) t = this.getItem(e3, "orderlyKey");
    else {
      let r3 = this.getAddress();
      if (!r3) return null;
      t = this.getItem(r3, "orderlyKey");
    }
    return t ? new K$5(t) : null;
  }
  getAccountId(e3) {
    return this.getItem(e3, "accountId");
  }
  setAccountId(e3, t) {
    this.setItem(e3, { accountId: t });
  }
  getAddress() {
    return localStorage.getItem(`${this.keyPrefix}address`);
  }
  setAddress(e3) {
    localStorage.setItem(`${this.keyPrefix}address`, e3);
  }
  removeAddress() {
    localStorage.removeItem(`${this.keyPrefix}address`);
  }
  generateKey() {
    return K$5.generateKey();
  }
  setKey(e3, t) {
    this.setItem(e3, { orderlyKey: t.secretKey });
  }
  cleanAllKey(e3) {
    localStorage.removeItem(`${this.keyPrefix}${e3}`), localStorage.removeItem(`${this.keyPrefix}address`);
  }
  cleanKey(e3, t) {
    let r3 = this.getItem(e3);
    delete r3[t], localStorage.setItem(`${this.keyPrefix}${e3}`, JSON.stringify(r3));
  }
  setItem(e3, t) {
    let r3 = `${this.keyPrefix}${e3}`, a2 = localStorage.getItem(r3);
    a2 ? a2 = JSON.parse(a2) : a2 = {}, localStorage.setItem(r3, JSON.stringify({ ...a2, ...t }));
  }
  getItem(e3, t) {
    let r3 = `${this.keyPrefix}${e3}`, a2 = localStorage.getItem(r3);
    return a2 ? a2 = JSON.parse(a2) : a2 = {}, typeof t > "u" ? a2 : a2[t];
  }
};
c();
var un$3 = {};
Vn$3(un$3, { base64url: () => ct$4, calculateStringHash: () => ft$4, formatByUnits: () => Oe$3, getGlobalObject: () => Ae$3, getTimestamp: () => x$1, isHex: () => Te$4, isHexString: () => Fr$2, parseAccountId: () => mt$4, parseBrokerHash: () => ae$8, parseTokenHash: () => Fe$6, parseUnits: () => parseUnits$1 });
c();
var ct$4 = function(n4) {
  return n4.replace(/\+/g, "-").replace(/\//g, "_");
};
function ae$8(n4) {
  return ft$4(n4);
}
function mt$4(n4, e3) {
  let t = AbiCoder.defaultAbiCoder();
  return keccak256(t.encode(["address", "bytes32"], [n4, ae$8(e3)]));
}
function Fe$6(n4) {
  return ft$4(n4);
}
function ft$4(n4) {
  return solidityPackedKeccak256(["string"], [n4]);
}
function Oe$3(n4, e3 = "ether") {
  return formatUnits(n4, e3);
}
function Te$4(n4) {
  return /^[a-f0-9]+$/iu.test(n4);
}
function Fr$2(n4) {
  return typeof n4 == "string" && n4.startsWith("0x") && Te$4(n4);
}
var Ae$3 = () => {
  if (typeof globalThis < "u") return globalThis;
  if (typeof self < "u") return self;
  if (typeof window < "u") return window;
  if (typeof b$4 < "u") return b$4;
  throw new Error("cannot find the global object");
}, x$1 = () => {
  var _a2;
  if (typeof window < "u") {
    let n4 = (_a2 = Ae$3()) == null ? void 0 : _a2.__ORDERLY_timestamp_offset;
    if (typeof n4 == "number") return Date.now() + (n4 || 0);
  }
  return Date.now();
};
var ht$3 = fe$5(tt$4()), Z$3 = class Z {
  constructor(e3) {
    this.keyStore = e3;
  }
  async sign(e3, t = x$1()) {
    let r3 = t.toString(), a2 = [r3, e3.method.toUpperCase(), e3.url].join("");
    e3.data && Object.keys(e3.data).length && (a2 += JSON.stringify(e3.data));
    let { signature: s, publicKey: i } = await this.signText(a2);
    return { "orderly-key": i, "orderly-timestamp": r3, "orderly-signature": s };
  }
  async signText(e3) {
    let t = this.keyStore.getOrderlyKey();
    if (!t) throw new Error("orderlyKeyPair is not defined");
    let r3 = ht$3.Buffer.from(e3), a2 = await t.sign(r3), s = ht$3.Buffer.from(a2).toString("base64");
    return { signature: ct$4(s), publicKey: await t.getPublicKey() };
  }
};
c();
c();
c();
var dn$1 = "0xfd064A18f3BF249cf1f87FC203E90D8f650f2d63";
var yn$3 = "0x0EaC556c0C2321BA25b9DC01e4e3c95aD5CDCd2f", ln$4 = "0x1826B75e2ef249173FC735149AE4B8e9ea10abff", cn$2 = "0xaf88d065e77c8cC2239327C5EDb3A432268e5831", mn$1 = "0x816f722424B49Cf1275cc86DA9840Fbd5a6167e9", fn$3 = "0x6F7a338F2aA472838dEFD3283eB360d4Dff5D203", hn$3 = "ErBmAD61mGFKvrFNaTJuxoPwqrS8GgtwtqJTJVjFWx9Q", gn$3 = "9shwxWDUNhtwkHocsUAmrNAQfBH2DHh4njdAEdHZZkF2";
var bn$3 = "5zBjLor7vEraAt4zp2H82sy9MSqFoDnNa1Lx6EYKTYRZ", wn$3 = "4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU", Tn$2 = "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v", E$4 = { statusChanged: "change:status", validateStart: "validate:start", validateEnd: "validate:end", switchAccount: "switch:account" }, An$2 = "0x65B99E978d1eeE9CfEdfD463EC7A81317e5A5073", vn$2 = "0x9442e24203e999db4aE87E35Dc0c8F3C610c29A0", xn$4 = "0x77F77926C6596c78f285D230Cd0dC8dC3540e3a6", En$3 = "0xdd6E018D747D70C705BA84B67B6eAD7748a57cDa";
var gt$3 = [{ anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "owner", type: "address" }, { indexed: true, internalType: "address", name: "spender", type: "address" }, { indexed: false, internalType: "uint256", name: "value", type: "uint256" }], name: "Approval", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "authorizer", type: "address" }, { indexed: true, internalType: "bytes32", name: "nonce", type: "bytes32" }], name: "AuthorizationCanceled", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "authorizer", type: "address" }, { indexed: true, internalType: "bytes32", name: "nonce", type: "bytes32" }], name: "AuthorizationUsed", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "_account", type: "address" }], name: "Blacklisted", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "newBlacklister", type: "address" }], name: "BlacklisterChanged", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "burner", type: "address" }, { indexed: false, internalType: "uint256", name: "amount", type: "uint256" }], name: "Burn", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "newMasterMinter", type: "address" }], name: "MasterMinterChanged", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "minter", type: "address" }, { indexed: true, internalType: "address", name: "to", type: "address" }, { indexed: false, internalType: "uint256", name: "amount", type: "uint256" }], name: "Mint", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "minter", type: "address" }, { indexed: false, internalType: "uint256", name: "minterAllowedAmount", type: "uint256" }], name: "MinterConfigured", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "oldMinter", type: "address" }], name: "MinterRemoved", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "address", name: "previousOwner", type: "address" }, { indexed: false, internalType: "address", name: "newOwner", type: "address" }], name: "OwnershipTransferred", type: "event" }, { anonymous: false, inputs: [], name: "Pause", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "newAddress", type: "address" }], name: "PauserChanged", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "newRescuer", type: "address" }], name: "RescuerChanged", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "from", type: "address" }, { indexed: true, internalType: "address", name: "to", type: "address" }, { indexed: false, internalType: "uint256", name: "value", type: "uint256" }], name: "Transfer", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "_account", type: "address" }], name: "UnBlacklisted", type: "event" }, { anonymous: false, inputs: [], name: "Unpause", type: "event" }, { inputs: [], name: "CANCEL_AUTHORIZATION_TYPEHASH", outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }], stateMutability: "view", type: "function" }, { inputs: [], name: "DOMAIN_SEPARATOR", outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }], stateMutability: "view", type: "function" }, { inputs: [], name: "PERMIT_TYPEHASH", outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }], stateMutability: "view", type: "function" }, { inputs: [], name: "RECEIVE_WITH_AUTHORIZATION_TYPEHASH", outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }], stateMutability: "view", type: "function" }, { inputs: [], name: "TRANSFER_WITH_AUTHORIZATION_TYPEHASH", outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "owner", type: "address" }, { internalType: "address", name: "spender", type: "address" }], name: "allowance", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "spender", type: "address" }, { internalType: "uint256", name: "value", type: "uint256" }], name: "approve", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "authorizer", type: "address" }, { internalType: "bytes32", name: "nonce", type: "bytes32" }], name: "authorizationState", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "account", type: "address" }], name: "balanceOf", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "_account", type: "address" }], name: "blacklist", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "blacklister", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint256", name: "_amount", type: "uint256" }], name: "burn", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "authorizer", type: "address" }, { internalType: "bytes32", name: "nonce", type: "bytes32" }, { internalType: "uint8", name: "v", type: "uint8" }, { internalType: "bytes32", name: "r", type: "bytes32" }, { internalType: "bytes32", name: "s", type: "bytes32" }], name: "cancelAuthorization", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "minter", type: "address" }, { internalType: "uint256", name: "minterAllowedAmount", type: "uint256" }], name: "configureMinter", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "currency", outputs: [{ internalType: "string", name: "", type: "string" }], stateMutability: "view", type: "function" }, { inputs: [], name: "decimals", outputs: [{ internalType: "uint8", name: "", type: "uint8" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "spender", type: "address" }, { internalType: "uint256", name: "decrement", type: "uint256" }], name: "decreaseAllowance", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "spender", type: "address" }, { internalType: "uint256", name: "increment", type: "uint256" }], name: "increaseAllowance", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "string", name: "tokenName", type: "string" }, { internalType: "string", name: "tokenSymbol", type: "string" }, { internalType: "string", name: "tokenCurrency", type: "string" }, { internalType: "uint8", name: "tokenDecimals", type: "uint8" }, { internalType: "address", name: "newMasterMinter", type: "address" }, { internalType: "address", name: "newPauser", type: "address" }, { internalType: "address", name: "newBlacklister", type: "address" }, { internalType: "address", name: "newOwner", type: "address" }], name: "initialize", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "string", name: "newName", type: "string" }], name: "initializeV2", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "lostAndFound", type: "address" }], name: "initializeV2_1", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_account", type: "address" }], name: "isBlacklisted", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "account", type: "address" }], name: "isMinter", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [], name: "masterMinter", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "_to", type: "address" }, { internalType: "uint256", name: "_amount", type: "uint256" }], name: "mint", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "minter", type: "address" }], name: "minterAllowance", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [], name: "name", outputs: [{ internalType: "string", name: "", type: "string" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "owner", type: "address" }], name: "nonces", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [], name: "owner", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [], name: "pause", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "paused", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [], name: "pauser", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "owner", type: "address" }, { internalType: "address", name: "spender", type: "address" }, { internalType: "uint256", name: "value", type: "uint256" }, { internalType: "uint256", name: "deadline", type: "uint256" }, { internalType: "uint8", name: "v", type: "uint8" }, { internalType: "bytes32", name: "r", type: "bytes32" }, { internalType: "bytes32", name: "s", type: "bytes32" }], name: "permit", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "from", type: "address" }, { internalType: "address", name: "to", type: "address" }, { internalType: "uint256", name: "value", type: "uint256" }, { internalType: "uint256", name: "validAfter", type: "uint256" }, { internalType: "uint256", name: "validBefore", type: "uint256" }, { internalType: "bytes32", name: "nonce", type: "bytes32" }, { internalType: "uint8", name: "v", type: "uint8" }, { internalType: "bytes32", name: "r", type: "bytes32" }, { internalType: "bytes32", name: "s", type: "bytes32" }], name: "receiveWithAuthorization", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "minter", type: "address" }], name: "removeMinter", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "contract IERC20", name: "tokenContract", type: "address" }, { internalType: "address", name: "to", type: "address" }, { internalType: "uint256", name: "amount", type: "uint256" }], name: "rescueERC20", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "rescuer", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [], name: "symbol", outputs: [{ internalType: "string", name: "", type: "string" }], stateMutability: "view", type: "function" }, { inputs: [], name: "totalSupply", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "to", type: "address" }, { internalType: "uint256", name: "value", type: "uint256" }], name: "transfer", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "from", type: "address" }, { internalType: "address", name: "to", type: "address" }, { internalType: "uint256", name: "value", type: "uint256" }], name: "transferFrom", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "newOwner", type: "address" }], name: "transferOwnership", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "from", type: "address" }, { internalType: "address", name: "to", type: "address" }, { internalType: "uint256", name: "value", type: "uint256" }, { internalType: "uint256", name: "validAfter", type: "uint256" }, { internalType: "uint256", name: "validBefore", type: "uint256" }, { internalType: "bytes32", name: "nonce", type: "bytes32" }, { internalType: "uint8", name: "v", type: "uint8" }, { internalType: "bytes32", name: "r", type: "bytes32" }, { internalType: "bytes32", name: "s", type: "bytes32" }], name: "transferWithAuthorization", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_account", type: "address" }], name: "unBlacklist", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "unpause", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_newBlacklister", type: "address" }], name: "updateBlacklister", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_newMasterMinter", type: "address" }], name: "updateMasterMinter", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_newPauser", type: "address" }], name: "updatePauser", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "newRescuer", type: "address" }], name: "updateRescuer", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "version", outputs: [{ internalType: "string", name: "", type: "string" }], stateMutability: "view", type: "function" }];
var Cn$4 = [{ inputs: [], stateMutability: "nonpayable", type: "constructor" }, { inputs: [], name: "AccountIdInvalid", type: "error" }, { inputs: [], name: "AddressZero", type: "error" }, { inputs: [{ internalType: "uint256", name: "balance", type: "uint256" }, { internalType: "uint128", name: "amount", type: "uint128" }], name: "BalanceNotEnough", type: "error" }, { inputs: [], name: "BrokerNotAllowed", type: "error" }, { inputs: [], name: "EnumerableSetError", type: "error" }, { inputs: [], name: "OnlyCrossChainManagerCanCall", type: "error" }, { inputs: [], name: "TokenNotAllowed", type: "error" }, { inputs: [], name: "ZeroDepositFee", type: "error" }, { anonymous: false, inputs: [{ indexed: true, internalType: "bytes32", name: "accountId", type: "bytes32" }, { indexed: true, internalType: "address", name: "userAddress", type: "address" }, { indexed: true, internalType: "uint64", name: "depositNonce", type: "uint64" }, { indexed: false, internalType: "bytes32", name: "tokenHash", type: "bytes32" }, { indexed: false, internalType: "uint128", name: "tokenAmount", type: "uint128" }], name: "AccountDeposit", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "bytes32", name: "accountId", type: "bytes32" }, { indexed: true, internalType: "address", name: "userAddress", type: "address" }, { indexed: true, internalType: "uint64", name: "depositNonce", type: "uint64" }, { indexed: false, internalType: "bytes32", name: "tokenHash", type: "bytes32" }, { indexed: false, internalType: "uint128", name: "tokenAmount", type: "uint128" }], name: "AccountDepositTo", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "bytes32", name: "accountId", type: "bytes32" }, { indexed: true, internalType: "uint64", name: "withdrawNonce", type: "uint64" }, { indexed: false, internalType: "bytes32", name: "brokerHash", type: "bytes32" }, { indexed: false, internalType: "address", name: "sender", type: "address" }, { indexed: false, internalType: "address", name: "receiver", type: "address" }, { indexed: false, internalType: "bytes32", name: "tokenHash", type: "bytes32" }, { indexed: false, internalType: "uint128", name: "tokenAmount", type: "uint128" }, { indexed: false, internalType: "uint128", name: "fee", type: "uint128" }], name: "AccountWithdraw", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "address", name: "oldAddress", type: "address" }, { indexed: false, internalType: "address", name: "newAddress", type: "address" }], name: "ChangeCrossChainManager", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "bytes32", name: "_tokenHash", type: "bytes32" }, { indexed: false, internalType: "address", name: "_tokenAddress", type: "address" }], name: "ChangeTokenAddressAndAllow", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "uint8", name: "version", type: "uint8" }], name: "Initialized", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "previousOwner", type: "address" }, { indexed: true, internalType: "address", name: "newOwner", type: "address" }], name: "OwnershipTransferred", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "address", name: "account", type: "address" }], name: "Paused", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "bytes32", name: "_brokerHash", type: "bytes32" }, { indexed: false, internalType: "bool", name: "_allowed", type: "bool" }], name: "SetAllowedBroker", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "bytes32", name: "_tokenHash", type: "bytes32" }, { indexed: false, internalType: "bool", name: "_allowed", type: "bool" }], name: "SetAllowedToken", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "address", name: "account", type: "address" }], name: "Unpaused", type: "event" }, { inputs: [{ internalType: "bytes32", name: "", type: "bytes32" }], name: "allowedToken", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "_tokenHash", type: "bytes32" }, { internalType: "address", name: "_tokenAddress", type: "address" }], name: "changeTokenAddressAndAllow", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "crossChainManagerAddress", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ components: [{ internalType: "bytes32", name: "accountId", type: "bytes32" }, { internalType: "bytes32", name: "brokerHash", type: "bytes32" }, { internalType: "bytes32", name: "tokenHash", type: "bytes32" }, { internalType: "uint128", name: "tokenAmount", type: "uint128" }], internalType: "struct VaultTypes.VaultDepositFE", name: "data", type: "tuple" }], name: "deposit", outputs: [], stateMutability: "payable", type: "function" }, { inputs: [{ components: [{ internalType: "bytes32", name: "accountId", type: "bytes32" }, { internalType: "bytes32", name: "brokerHash", type: "bytes32" }, { internalType: "bytes32", name: "tokenHash", type: "bytes32" }, { internalType: "uint128", name: "tokenAmount", type: "uint128" }], internalType: "struct VaultTypes.VaultDepositFE", name: "data", type: "tuple" }], name: "deposit", outputs: [], stateMutability: "payable", type: "function" }, { inputs: [], name: "depositFeeEnabled", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [], name: "depositId", outputs: [{ internalType: "uint64", name: "", type: "uint64" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "receiver", type: "address" }, { components: [{ internalType: "bytes32", name: "accountId", type: "bytes32" }, { internalType: "bytes32", name: "brokerHash", type: "bytes32" }, { internalType: "bytes32", name: "tokenHash", type: "bytes32" }, { internalType: "uint128", name: "tokenAmount", type: "uint128" }], internalType: "struct VaultTypes.VaultDepositFE", name: "data", type: "tuple" }], name: "depositTo", outputs: [], stateMutability: "payable", type: "function" }, { inputs: [], name: "emergencyPause", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "emergencyUnpause", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "bool", name: "_enabled", type: "bool" }], name: "enableDepositFee", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "getAllAllowedBroker", outputs: [{ internalType: "bytes32[]", name: "", type: "bytes32[]" }], stateMutability: "view", type: "function" }, { inputs: [], name: "getAllAllowedToken", outputs: [{ internalType: "bytes32[]", name: "", type: "bytes32[]" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "_brokerHash", type: "bytes32" }], name: "getAllowedBroker", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "_tokenHash", type: "bytes32" }], name: "getAllowedToken", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "receiver", type: "address" }, { components: [{ internalType: "bytes32", name: "accountId", type: "bytes32" }, { internalType: "bytes32", name: "brokerHash", type: "bytes32" }, { internalType: "bytes32", name: "tokenHash", type: "bytes32" }, { internalType: "uint128", name: "tokenAmount", type: "uint128" }], internalType: "struct VaultTypes.VaultDepositFE", name: "data", type: "tuple" }], name: "getDepositFee", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [], name: "initialize", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "messageTransmitterContract", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [], name: "owner", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [], name: "paused", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [{ components: [{ internalType: "uint32", name: "dstDomain", type: "uint32" }, { internalType: "uint64", name: "rebalanceId", type: "uint64" }, { internalType: "uint128", name: "amount", type: "uint128" }, { internalType: "bytes32", name: "tokenHash", type: "bytes32" }, { internalType: "uint256", name: "burnChainId", type: "uint256" }, { internalType: "uint256", name: "mintChainId", type: "uint256" }, { internalType: "address", name: "dstVaultAddress", type: "address" }], internalType: "struct RebalanceTypes.RebalanceBurnCCData", name: "data", type: "tuple" }], name: "rebalanceBurn", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ components: [{ internalType: "uint64", name: "rebalanceId", type: "uint64" }, { internalType: "uint128", name: "amount", type: "uint128" }, { internalType: "bytes32", name: "tokenHash", type: "bytes32" }, { internalType: "uint256", name: "burnChainId", type: "uint256" }, { internalType: "uint256", name: "mintChainId", type: "uint256" }, { internalType: "bytes", name: "messageBytes", type: "bytes" }, { internalType: "bytes", name: "messageSignature", type: "bytes" }], internalType: "struct RebalanceTypes.RebalanceMintCCData", name: "data", type: "tuple" }], name: "rebalanceMint", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "renounceOwnership", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "bytes32", name: "_brokerHash", type: "bytes32" }, { internalType: "bool", name: "_allowed", type: "bool" }], name: "setAllowedBroker", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "bytes32", name: "_tokenHash", type: "bytes32" }, { internalType: "bool", name: "_allowed", type: "bool" }], name: "setAllowedToken", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_crossChainManagerAddress", type: "address" }], name: "setCrossChainManager", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_rebalanceMessengerContract", type: "address" }], name: "setRebalanceMessengerContract", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_tokenMessengerContract", type: "address" }], name: "setTokenMessengerContract", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "tokenMessengerContract", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "newOwner", type: "address" }], name: "transferOwnership", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ components: [{ internalType: "bytes32", name: "accountId", type: "bytes32" }, { internalType: "bytes32", name: "brokerHash", type: "bytes32" }, { internalType: "bytes32", name: "tokenHash", type: "bytes32" }, { internalType: "uint128", name: "tokenAmount", type: "uint128" }, { internalType: "uint128", name: "fee", type: "uint128" }, { internalType: "address", name: "sender", type: "address" }, { internalType: "address", name: "receiver", type: "address" }, { internalType: "uint64", name: "withdrawNonce", type: "uint64" }], internalType: "struct VaultTypes.VaultWithdraw", name: "data", type: "tuple" }], name: "withdraw", outputs: [], stateMutability: "nonpayable", type: "function" }];
var bt$2 = [{ inputs: [{ internalType: "string", name: "name_", type: "string" }, { internalType: "string", name: "symbol_", type: "string" }, { internalType: "uint8", name: "decimals_", type: "uint8" }], stateMutability: "nonpayable", type: "constructor" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "owner", type: "address" }, { indexed: true, internalType: "address", name: "spender", type: "address" }, { indexed: false, internalType: "uint256", name: "value", type: "uint256" }], name: "Approval", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "from", type: "address" }, { indexed: true, internalType: "address", name: "to", type: "address" }, { indexed: false, internalType: "uint256", name: "value", type: "uint256" }], name: "Transfer", type: "event" }, { inputs: [{ internalType: "address", name: "owner", type: "address" }, { internalType: "address", name: "spender", type: "address" }], name: "allowance", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "spender", type: "address" }, { internalType: "uint256", name: "amount", type: "uint256" }], name: "approve", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "account", type: "address" }], name: "balanceOf", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [], name: "decimals", outputs: [{ internalType: "uint8", name: "", type: "uint8" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "spender", type: "address" }, { internalType: "uint256", name: "subtractedValue", type: "uint256" }], name: "decreaseAllowance", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "spender", type: "address" }, { internalType: "uint256", name: "addedValue", type: "uint256" }], name: "increaseAllowance", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "uint256", name: "amount", type: "uint256" }], name: "issue", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_to", type: "address" }, { internalType: "uint256", name: "_amount", type: "uint256" }], name: "mint", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "name", outputs: [{ internalType: "string", name: "", type: "string" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bool", name: "_paused", type: "bool" }], name: "pauseTransfers", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "symbol", outputs: [{ internalType: "string", name: "", type: "string" }], stateMutability: "view", type: "function" }, { inputs: [], name: "totalSupply", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "recipient", type: "address" }, { internalType: "uint256", name: "amount", type: "uint256" }], name: "transfer", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "sender", type: "address" }, { internalType: "address", name: "recipient", type: "address" }, { internalType: "uint256", name: "amount", type: "uint256" }], name: "transferFrom", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "nonpayable", type: "function" }];
var In$2 = [{ inputs: [], stateMutability: "nonpayable", type: "constructor" }, { inputs: [], name: "AccountIdInvalid", type: "error" }, { inputs: [], name: "AddressZero", type: "error" }, { inputs: [{ internalType: "uint256", name: "balance", type: "uint256" }, { internalType: "uint128", name: "amount", type: "uint128" }], name: "BalanceNotEnough", type: "error" }, { inputs: [], name: "BrokerNotAllowed", type: "error" }, { inputs: [], name: "EnumerableSetError", type: "error" }, { inputs: [], name: "OnlyCrossChainManagerCanCall", type: "error" }, { inputs: [], name: "TokenNotAllowed", type: "error" }, { inputs: [], name: "ZeroDepositFee", type: "error" }, { anonymous: false, inputs: [{ indexed: true, internalType: "bytes32", name: "accountId", type: "bytes32" }, { indexed: true, internalType: "address", name: "userAddress", type: "address" }, { indexed: true, internalType: "uint64", name: "depositNonce", type: "uint64" }, { indexed: false, internalType: "bytes32", name: "tokenHash", type: "bytes32" }, { indexed: false, internalType: "uint128", name: "tokenAmount", type: "uint128" }], name: "AccountDeposit", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "bytes32", name: "accountId", type: "bytes32" }, { indexed: true, internalType: "address", name: "userAddress", type: "address" }, { indexed: true, internalType: "uint64", name: "depositNonce", type: "uint64" }, { indexed: false, internalType: "bytes32", name: "tokenHash", type: "bytes32" }, { indexed: false, internalType: "uint128", name: "tokenAmount", type: "uint128" }], name: "AccountDepositTo", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "bytes32", name: "accountId", type: "bytes32" }, { indexed: true, internalType: "uint64", name: "withdrawNonce", type: "uint64" }, { indexed: false, internalType: "bytes32", name: "brokerHash", type: "bytes32" }, { indexed: false, internalType: "address", name: "sender", type: "address" }, { indexed: false, internalType: "address", name: "receiver", type: "address" }, { indexed: false, internalType: "bytes32", name: "tokenHash", type: "bytes32" }, { indexed: false, internalType: "uint128", name: "tokenAmount", type: "uint128" }, { indexed: false, internalType: "uint128", name: "fee", type: "uint128" }], name: "AccountWithdraw", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "address", name: "oldAddress", type: "address" }, { indexed: false, internalType: "address", name: "newAddress", type: "address" }], name: "ChangeCrossChainManager", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "bytes32", name: "_tokenHash", type: "bytes32" }, { indexed: false, internalType: "address", name: "_tokenAddress", type: "address" }], name: "ChangeTokenAddressAndAllow", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "uint8", name: "version", type: "uint8" }], name: "Initialized", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "previousOwner", type: "address" }, { indexed: true, internalType: "address", name: "newOwner", type: "address" }], name: "OwnershipTransferred", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "address", name: "account", type: "address" }], name: "Paused", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "bytes32", name: "_brokerHash", type: "bytes32" }, { indexed: false, internalType: "bool", name: "_allowed", type: "bool" }], name: "SetAllowedBroker", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "bytes32", name: "_tokenHash", type: "bytes32" }, { indexed: false, internalType: "bool", name: "_allowed", type: "bool" }], name: "SetAllowedToken", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "address", name: "account", type: "address" }], name: "Unpaused", type: "event" }, { inputs: [{ internalType: "bytes32", name: "", type: "bytes32" }], name: "allowedToken", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "_tokenHash", type: "bytes32" }, { internalType: "address", name: "_tokenAddress", type: "address" }], name: "changeTokenAddressAndAllow", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "crossChainManagerAddress", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ components: [{ internalType: "bytes32", name: "accountId", type: "bytes32" }, { internalType: "bytes32", name: "brokerHash", type: "bytes32" }, { internalType: "bytes32", name: "tokenHash", type: "bytes32" }, { internalType: "uint128", name: "tokenAmount", type: "uint128" }], internalType: "struct VaultTypes.VaultDepositFE", name: "data", type: "tuple" }], name: "deposit", outputs: [], stateMutability: "payable", type: "function" }, { inputs: [], name: "depositFeeEnabled", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [], name: "depositId", outputs: [{ internalType: "uint64", name: "", type: "uint64" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "receiver", type: "address" }, { components: [{ internalType: "bytes32", name: "accountId", type: "bytes32" }, { internalType: "bytes32", name: "brokerHash", type: "bytes32" }, { internalType: "bytes32", name: "tokenHash", type: "bytes32" }, { internalType: "uint128", name: "tokenAmount", type: "uint128" }], internalType: "struct VaultTypes.VaultDepositFE", name: "data", type: "tuple" }], name: "depositTo", outputs: [], stateMutability: "payable", type: "function" }, { inputs: [], name: "emergencyPause", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "emergencyUnpause", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "bool", name: "_enabled", type: "bool" }], name: "enableDepositFee", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "getAllAllowedBroker", outputs: [{ internalType: "bytes32[]", name: "", type: "bytes32[]" }], stateMutability: "view", type: "function" }, { inputs: [], name: "getAllAllowedToken", outputs: [{ internalType: "bytes32[]", name: "", type: "bytes32[]" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "_brokerHash", type: "bytes32" }], name: "getAllowedBroker", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "_tokenHash", type: "bytes32" }], name: "getAllowedToken", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "receiver", type: "address" }, { components: [{ internalType: "bytes32", name: "accountId", type: "bytes32" }, { internalType: "bytes32", name: "brokerHash", type: "bytes32" }, { internalType: "bytes32", name: "tokenHash", type: "bytes32" }, { internalType: "uint128", name: "tokenAmount", type: "uint128" }], internalType: "struct VaultTypes.VaultDepositFE", name: "data", type: "tuple" }], name: "getDepositFee", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [], name: "initialize", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "messageTransmitterContract", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [], name: "owner", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [], name: "paused", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [{ components: [{ internalType: "uint32", name: "dstDomain", type: "uint32" }, { internalType: "uint64", name: "rebalanceId", type: "uint64" }, { internalType: "uint128", name: "amount", type: "uint128" }, { internalType: "bytes32", name: "tokenHash", type: "bytes32" }, { internalType: "uint256", name: "burnChainId", type: "uint256" }, { internalType: "uint256", name: "mintChainId", type: "uint256" }, { internalType: "address", name: "dstVaultAddress", type: "address" }], internalType: "struct RebalanceTypes.RebalanceBurnCCData", name: "data", type: "tuple" }], name: "rebalanceBurn", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ components: [{ internalType: "uint64", name: "rebalanceId", type: "uint64" }, { internalType: "uint128", name: "amount", type: "uint128" }, { internalType: "bytes32", name: "tokenHash", type: "bytes32" }, { internalType: "uint256", name: "burnChainId", type: "uint256" }, { internalType: "uint256", name: "mintChainId", type: "uint256" }, { internalType: "bytes", name: "messageBytes", type: "bytes" }, { internalType: "bytes", name: "messageSignature", type: "bytes" }], internalType: "struct RebalanceTypes.RebalanceMintCCData", name: "data", type: "tuple" }], name: "rebalanceMint", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "renounceOwnership", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "bytes32", name: "_brokerHash", type: "bytes32" }, { internalType: "bool", name: "_allowed", type: "bool" }], name: "setAllowedBroker", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "bytes32", name: "_tokenHash", type: "bytes32" }, { internalType: "bool", name: "_allowed", type: "bool" }], name: "setAllowedToken", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_crossChainManagerAddress", type: "address" }], name: "setCrossChainManager", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_rebalanceMessengerContract", type: "address" }], name: "setRebalanceMessengerContract", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_tokenMessengerContract", type: "address" }], name: "setTokenMessengerContract", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "tokenMessengerContract", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "newOwner", type: "address" }], name: "transferOwnership", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ components: [{ internalType: "bytes32", name: "accountId", type: "bytes32" }, { internalType: "bytes32", name: "brokerHash", type: "bytes32" }, { internalType: "bytes32", name: "tokenHash", type: "bytes32" }, { internalType: "uint128", name: "tokenAmount", type: "uint128" }, { internalType: "uint128", name: "fee", type: "uint128" }, { internalType: "address", name: "sender", type: "address" }, { internalType: "address", name: "receiver", type: "address" }, { internalType: "uint64", name: "withdrawNonce", type: "uint64" }], internalType: "struct VaultTypes.VaultWithdraw", name: "data", type: "tuple" }], name: "withdraw", outputs: [], stateMutability: "nonpayable", type: "function" }];
var ve$6 = class ve {
  constructor(e3) {
    this.configStore = e3;
  }
  getContractInfoByEnv() {
    let e3 = this.configStore.get("networkId"), t = this.configStore.get("env"), r3 = ln$4;
    if (e3 === "mainnet") return { usdcAddress: cn$2, usdcAbi: gt$3, vaultAddress: mn$1, vaultAbi: Cn$4, verifyContractAddress: fn$3, erc20Abi: gt$3, solanaUSDCAddress: Tn$2, solanaVaultAddress: hn$3 };
    let a2 = gn$3, s = An$2, i = vn$2, o = xn$4;
    return t === "qa" && (a2 = bn$3, r3 = "0x50F59504D3623Ad99302835da367676d1f7E3D44", s = "0xFeA61647309cA4624EfF3c86EEEeb76a6F3eaFf7", i = En$3), { usdcAddress: dn$1, usdcAbi: bt$2, vaultAddress: yn$3, solanaVaultAddress: a2, solanaUSDCAddress: wn$3, vaultAbi: In$2, verifyContractAddress: r3, erc20Abi: bt$2, storyTestnetVaultAddress: s, monadTestnetVaultAddress: i, monadTestnetUSDCAddress: o };
  }
};
c();
c();
var wt$5 = class wt {
  constructor(e3 = [], t = {}) {
    this.providers = e3;
    this.services = t;
    this.injectProperties = {};
  }
  register(...e3) {
    this.providers.push(...e3), e3.forEach((t) => {
      let r3 = t;
      r3 instanceof Function && (r3 = new t()), this.add(r3);
    });
  }
  registerByName(e3, t) {
    let r3 = t;
    r3 instanceof Function && (r3 = new t()), this.addByName(e3, r3);
  }
  get(e3) {
    return this.services[e3];
  }
  getAll() {
    return Object.assign({}, this.services);
  }
  add(e3) {
    return this.addByName(e3.constructor.name, e3);
  }
  addByName(e3, t) {
    return this.services[e3] = t, this.services[e3.toLowerCase()] = t, this.injectIntoProperties(t, e3), this.get(e3);
  }
  inject(e3, t, r3) {
    e3 && r3 && (e3[t] = r3);
  }
  injectIntoProperties(e3, t = e3.constructor.name) {
    this.getInjectProperty(t.toLowerCase()).forEach((r3) => {
      this.inject(r3.target, r3.propertyKey, e3);
    });
  }
  getInjectProperty(e3) {
    return this.injectProperties[e3] || (this.injectProperties[e3] = []), this.injectProperties[e3];
  }
}, _n$2 = wt$5;
var U$6 = class U {
  static getContainer() {
    return U.container || (Ae$3()[U.KEY] = U.container = new _n$2()), U.container;
  }
  static register(...e3) {
    U.getContainer().register(...e3);
  }
  static registerByName(e3, t) {
    U.getContainer().registerByName(e3, t);
  }
  static get(e3) {
    return U.getContainer().get(e3);
  }
  static getOr(e3, t) {
    return U.getContainer().get(e3) || U.registerByName(e3, t), t;
  }
  static getAll() {
    return U.getContainer().getAll();
  }
  constructor() {
  }
};
U$6.KEY = "__ORDERLY_CONTAINER__", U$6.container = Ae$3()[U$6.KEY] || null;
var xe$4 = U$6, qr$2 = xe$4;
c();
c();
var Ke$6 = class Ke {
  constructor(e3, t, r3) {
    this.configStore = e3;
    this.contractManger = t;
    this.account = r3;
  }
  async withdraw(e3) {
    if (!this.account.walletAdapter) throw new Error("walletAdapter is undefined");
    if (!this.account.stateValue.address) throw new Error("account address is required");
    let { chainId: t, token: r3, allowCrossChainWithdraw: a2 } = e3, { amount: s } = e3;
    typeof s == "number" && (s = s.toString());
    let i = "/v1/withdraw_request", o = await this.getWithdrawalNonce(), p2 = x$1(), { message: y2, signatured: d2, domain: l2 } = await this.account.walletAdapter.generateWithdrawMessage({ receiver: this.account.stateValue.address, token: r3, brokerId: this.configStore.get("brokerId"), amount: this.account.walletAdapter.parseUnits(s), nonce: o, timestamp: p2, verifyContract: this.contractManger.getContractInfoByEnv().verifyContractAddress }), h2 = { signature: d2, message: y2, userAddress: this.account.stateValue.address, verifyingContract: l2.verifyingContract }, f2 = { method: "POST", url: i, data: h2 };
    a2 && (h2.message = { ...h2.message, allowCrossChainWithdraw: a2 });
    let g2 = await this.account.signer.sign(f2, x$1()), A2 = await this._simpleFetch(i, { method: "POST", body: JSON.stringify(h2), headers: { "Content-Type": "application/json", "orderly-account-id": this.account.stateValue.accountId, ...g2 } });
    if (!A2.success) throw new ApiError2(A2.message, A2.code);
    return A2;
  }
  async getWithdrawalNonce() {
    var _a2;
    let e3 = x$1().toString(), t = "/v1/withdraw_nonce", r3 = [e3, "GET", t].join(""), a2 = this.account.signer, { publicKey: s, signature: i } = await a2.signText(r3), o = await this._simpleFetch(t, { headers: { "orderly-account-id": this.account.stateValue.accountId, "orderly-key": s, "orderly-timestamp": e3, "orderly-signature": i } });
    if (o.success) return (_a2 = o.data) == null ? void 0 : _a2.withdraw_nonce;
    throw new Error(o.message);
  }
  async getNativeBalance(e3) {
    if (!this.account.walletAdapter) return "0";
    let t = await this.account.walletAdapter.getBalance();
    return Oe$3(t, e3 == null ? void 0 : e3.decimals);
  }
  async getBalance(e3, t) {
    var _a2, _b2;
    if (!this.account.walletAdapter) return "0";
    let r3 = this.contractManger.getContractInfoByEnv(), a2 = await ((_a2 = this.account.walletAdapter) == null ? void 0 : _a2.call(e3 ?? r3.usdcAddress, "balanceOf", [this.account.stateValue.address], { abi: r3.usdcAbi }));
    return (_b2 = this.account.walletAdapter) == null ? void 0 : _b2.formatUnits(a2, t == null ? void 0 : t.decimals);
  }
  async getBalanceByAddress(e3, t) {
    var _a2;
    if (!this.account.walletAdapter) return "0";
    let r3 = this.contractManger.getContractInfoByEnv(), a2 = await ((_a2 = this.account.walletAdapter) == null ? void 0 : _a2.call(e3, "balanceOf", [this.account.stateValue.address], { abi: r3.erc20Abi }));
    return Oe$3(a2, t == null ? void 0 : t.decimals);
  }
  async getAllowance(e3, t) {
    var _a2, _b2;
    let { address: r3, vaultAddress: a2, decimals: s } = typeof e3 == "object" ? e3 : { address: e3, vaultAddress: t, decimals: void 0 };
    if (!this.account.walletAdapter) return "0";
    let i = this.contractManger.getContractInfoByEnv(), o = a2 ?? i.vaultAddress, p2 = r3;
    this.account.walletAdapter.chainId === STORY_TESTNET_CHAINID && (o = i.storyTestnetVaultAddress ?? ""), this.account.walletAdapter.chainId === MONAD_TESTNET_CHAINID && (o = i.monadTestnetVaultAddress ?? "", p2 = i.monadTestnetUSDCAddress);
    let y2 = await ((_a2 = this.account.walletAdapter) == null ? void 0 : _a2.call(p2 ?? "", "allowance", [this.account.stateValue.address, o], { abi: i.usdcAbi }));
    return (_b2 = this.account.walletAdapter) == null ? void 0 : _b2.formatUnits(y2, s);
  }
  async approve(e3, t, r3) {
    var _a2;
    let { address: a2, amount: s, vaultAddress: i, decimals: o } = typeof e3 == "object" ? e3 : { address: e3, amount: t, vaultAddress: r3, decimals: void 0 };
    if (!a2) throw new Error("address is required");
    if (!this.account.walletAdapter) throw new Error("walletAdapter is undefined");
    let p2 = this.contractManger.getContractInfoByEnv(), y2 = typeof s < "u" && s !== "" ? this.account.walletAdapter.parseUnits(s, o) : MaxUint256.toString(), d2 = i || p2.vaultAddress, l2 = a2;
    return this.account.walletAdapter.chainId === STORY_TESTNET_CHAINID && (d2 = p2.storyTestnetVaultAddress ?? ""), this.account.walletAdapter.chainId === MONAD_TESTNET_CHAINID && (d2 = p2.monadTestnetVaultAddress ?? "", l2 = p2.monadTestnetUSDCAddress ?? ""), await ((_a2 = this.account.walletAdapter) == null ? void 0 : _a2.call(l2, "approve", [d2, y2], { abi: p2.usdcAbi }));
  }
  async approveByAddress(e3) {
    var _a2;
    let { address: t, amount: r3, decimals: a2 } = e3;
    if (!this.account.walletAdapter) throw new Error("walletAdapter is undefined");
    let s = typeof r3 < "u" && r3 !== "" ? this.account.walletAdapter.parseUnits(r3, a2) : MaxUint256.toString(), i = this.contractManger.getContractInfoByEnv();
    return await ((_a2 = this.account.walletAdapter) == null ? void 0 : _a2.call(t, "approve", [i.vaultAddress, s], { abi: i.erc20Abi }));
  }
  async getDepositFee(e3, t) {
    var _a2;
    if (!this.account.walletAdapter) throw new Error("walletAdapter is undefined");
    let r3 = this.configStore.get("brokerId");
    if (!r3) throw new Error("[Assets]:brokerId is required");
    let a2 = { accountId: this.account.accountIdHashStr, brokerHash: ae$8(r3), tokenHash: Fe$6("USDC"), tokenAmount: (_a2 = this.account.walletAdapter) == null ? void 0 : _a2.parseUnits(e3) }, s = this.contractManger.getContractInfoByEnv(), i = s.vaultAddress;
    return this.account.walletAdapter.chainNamespace === ChainNamespace.solana && (i = s.solanaVaultAddress, a2.USDCAddress = s.solanaUSDCAddress), t.chain_id === STORY_TESTNET_CHAINID && (i = s.storyTestnetVaultAddress ?? ""), t.chain_id === MONAD_TESTNET_CHAINID && (i = s.monadTestnetVaultAddress ?? ""), await this.account.walletAdapter.callOnChain(t, i, "getDepositFee", [this.account.stateValue.address, a2], { abi: s.vaultAbi });
  }
  async deposit(e3, t = 0n) {
    var _a2, _b2;
    if (!this.account.walletAdapter) throw new Error("walletAdapter is undefined");
    let r3 = this.configStore.get("brokerId");
    if (!r3) throw new Error("[Assets]:brokerId is required");
    let a2 = this.contractManger.getContractInfoByEnv(), s = { accountId: this.account.accountIdHashStr, brokerHash: ae$8(r3), tokenHash: Fe$6("USDC"), tokenAmount: (_a2 = this.account.walletAdapter) == null ? void 0 : _a2.parseUnits(e3) }, i = a2.vaultAddress;
    return this.account.walletAdapter.chainNamespace === ChainNamespace.solana && (i = a2.solanaVaultAddress, s.USDCAddress = a2.solanaUSDCAddress), this.account.walletAdapter.chainId === STORY_TESTNET_CHAINID && (i = a2.storyTestnetVaultAddress ?? ""), this.account.walletAdapter.chainId === MONAD_TESTNET_CHAINID && (i = a2.monadTestnetVaultAddress ?? ""), await ((_b2 = this.account.walletAdapter) == null ? void 0 : _b2.sendTransaction(i, "deposit", { from: this.account.stateValue.address, to: i, data: [s], value: t }, { abi: a2.vaultAbi }));
  }
  async _simpleFetch(e3, t = {}) {
    let r3 = `${this.configStore.get("apiBaseUrl")}${e3}`;
    return fetch(r3, t).then((a2) => a2.json());
  }
  get usdcAddress() {
    return this.contractManger.getContractInfoByEnv().usdcAddress;
  }
};
c();
var Ve$4 = class Ve {
  constructor(e3) {
    this.walletAdapters = e3;
    if (!this.walletAdapters.length) throw new Error("No wallet adapters provided");
  }
  get adapter() {
    return this._adapter;
  }
  get isEmpty() {
    return this.walletAdapters.length === 0;
  }
  get isAdapterExist() {
    return !!this._adapter;
  }
  switchWallet(e3, t, r3, a2) {
    console.log("-- this.walletAdapters", this.walletAdapters, e3);
    let s = this.walletAdapters.find((o) => o.chainNamespace === e3.toUpperCase());
    if (!s) throw new Error("Unsupported chain namespace");
    let i = { address: t, chain: { id: r3 }, provider: a2.provider, contractManager: a2.contractManager };
    if (console.log("------+++++---", i), this._adapter) if (this._adapter === s) {
      this._adapter.update(i);
      return;
    } else this._adapter.deactivate();
    this._adapter = s, this._adapter.active(i);
  }
  get chainId() {
    var _a2;
    return (_a2 = this.adapter) == null ? void 0 : _a2.chainId;
  }
};
var Le$7 = class Le {
  constructor(e3, t, r3, a2) {
    this.configStore = e3;
    this.keyStore = t;
    this._ee = new Jr$5();
    this._state = { status: AccountStatusEnum.NotConnected, validating: false, isNew: false };
    (a2 == null ? void 0 : a2.contracts) ? this.contractManger = a2.contracts : this.contractManger = new ve$6(e3), this.assetsManager = new Ke$6(e3, this.contractManger, this), this.walletAdapterManager = new Ve$4(r3), this._bindEvents();
  }
  logout() {
  }
  async setAddress(e3, t) {
    var _a2, _b2;
    if (!e3) throw new SDKError("Address is required");
    if (!t) throw new SDKError("Wallet is required");
    if (!((_a2 = t == null ? void 0 : t.chain) == null ? void 0 : _a2.id)) throw new SDKError("Chain id is required");
    if (this.stateValue.address === e3) return console.warn("address parameter is the same as the current address, if you want to change chain, please use `switchChain` method."), this.stateValue.status;
    this.stateValue.status > AccountStatusEnum.NotConnected && this._ee.emit(E$4.switchAccount, e3), t.chain.id = this.parseChainId((_b2 = t == null ? void 0 : t.chain) == null ? void 0 : _b2.id), this.keyStore.setAddress(e3);
    let r3 = { ...this.stateValue, status: AccountStatusEnum.Connected, address: e3, chainNamespace: t.chain.namespace, accountId: void 0, connectWallet: { name: t.wallet.name || "unknown", chainId: t.chain.id }, validating: true };
    this._ee.emit(E$4.statusChanged, r3), this.walletAdapterManager.switchWallet(t.chain.namespace, e3, t.chain.id, { provider: t.provider, contractManager: this.contractManger }), this.configStore.set("chainNamespace", t.chain.namespace), this._ee.emit(E$4.validateStart);
    let a2 = await this._checkAccount(e3);
    return this._ee.emit(E$4.validateEnd, a2), a2;
  }
  get stateValue() {
    return this._state;
  }
  get accountId() {
    return this.stateValue.accountId;
  }
  get accountIdHashStr() {
    var _a2;
    if (!this.address) throw new Error("address is error");
    let e3 = this.configStore.get("brokerId");
    if (((_a2 = this.walletAdapter) == null ? void 0 : _a2.chainNamespace) === ChainNamespace.solana) {
      let t = new PublicKey(this.address), r3 = w$5.Buffer.from(t.toBytes()), a2 = AbiCoder.defaultAbiCoder();
      return keccak256(a2.encode(["bytes32", "bytes32"], [r3, ae$8(e3)]));
    }
    return mt$4(this.address, e3);
  }
  get address() {
    return this.stateValue.address;
  }
  get chainId() {
    if (this.walletAdapterManager.isAdapterExist) return this.walletAdapterManager.chainId;
  }
  get apiBaseUrl() {
    return this.configStore.get("apiBaseUrl");
  }
  _bindEvents() {
    this._ee.addListener(E$4.statusChanged, (e3) => {
      this._state = e3;
    });
  }
  async _checkAccount(e3) {
    let t;
    try {
      let r3 = await this._checkAccountExist(e3);
      if (r3 && r3.account_id) this.keyStore.setAccountId(e3, r3.account_id), t = { ...this.stateValue, status: AccountStatusEnum.SignedIn, accountId: r3.account_id, userId: r3.user_id }, this._ee.emit(E$4.statusChanged, t);
      else return t = { ...this.stateValue, validating: false, status: AccountStatusEnum.NotSignedIn }, this._ee.emit(E$4.statusChanged, t), AccountStatusEnum.NotSignedIn;
      let a2 = this.keyStore.getOrderlyKey();
      if (!a2) return this._ee.emit(E$4.statusChanged, { ...this.stateValue, isNew: false, validating: false, status: AccountStatusEnum.DisabledTrading }), AccountStatusEnum.DisabledTrading;
      let s = await a2.getPublicKey(), i = await this._checkOrderlyKeyState(r3.account_id, s);
      if (i && i.orderly_key && i.key_status === "ACTIVE") {
        let o = x$1(), p2 = i.expiration;
        return o > p2 ? (this._ee.emit(E$4.statusChanged, { ...this.stateValue, validating: false }), this.keyStore.cleanKey(e3, "orderlyKey"), AccountStatusEnum.DisabledTrading) : (this._ee.emit(E$4.statusChanged, { ...this.stateValue, validating: false, status: AccountStatusEnum.EnableTrading }), AccountStatusEnum.EnableTrading);
      }
      return this._ee.emit(E$4.statusChanged, { ...this.stateValue, validating: false }), this.keyStore.cleanKey(e3, "orderlyKey"), AccountStatusEnum.NotConnected;
    } catch {
      this._ee.emit(E$4.statusChanged, { ...this.stateValue, validating: false });
    }
    return AccountStatusEnum.NotSignedIn;
  }
  async _checkAccountExist(e3, t) {
    let r3 = await this._getAccountInfo(e3, t);
    return r3.success ? r3.data : null;
  }
  async createAccount() {
    let { nonce: e3, timestamp: t } = await this._getRegisterationNonce(), r3 = this.stateValue.address;
    if (!r3) throw new Error("address is undefined");
    let { message: a2, signatured: s } = await this.walletAdapterManager.adapter.generateRegisterAccountMessage({ registrationNonce: e3, brokerId: this.configStore.get("brokerId"), timestamp: t }), i = await this._simpleFetch("/v1/register_account", { method: "POST", body: JSON.stringify({ signature: s, message: a2, userAddress: r3 }), headers: { "Content-Type": "application/json" } });
    if (i.success) {
      this.keyStore.setAccountId(r3, i.data.account_id);
      let o = { ...this.stateValue, status: AccountStatusEnum.DisabledTrading, accountId: i.data.account_id, userId: i.data.user_id, isNew: true };
      return this._ee.emit(E$4.statusChanged, o), i;
    } else throw new Error(i.message);
  }
  async createApiKey(e3, t) {
    var _a2;
    try {
      let { res: r3, keyPair: a2 } = await this.generateApiKey(e3, t);
      if (r3.success) return { key: (await a2.getPublicKey()).replace("ed25519:", ""), secretKey: (_a2 = a2.secretKey) == null ? void 0 : _a2.replace("ed25519:", "") };
    } catch (r3) {
      throw console.log("createApiKey error", r3), `${r3}`.includes("user rejected action") ? new Error("User rejected the request.") : r3;
    }
    throw new Error("create api key failed");
  }
  async createOrderlyKey(e3, t) {
    let { res: r3, address: a2, keyPair: s } = await this.generateApiKey(e3, t);
    if (r3.success) {
      this.keyStore.setKey(a2, s);
      let i = { ...this.stateValue, status: AccountStatusEnum.EnableTrading };
      return this._ee.emit(E$4.statusChanged, i), r3;
    } else throw new Error(r3.message);
  }
  async generateApiKey(e3, t) {
    if (this.stateValue.accountId === void 0) throw new Error("account id is undefined");
    if (!this.walletAdapter) throw new Error("walletAdapter is undefined");
    if (!this.walletAdapterManager.isAdapterExist) throw new Error("wallet adapter is not exist");
    if (typeof e3 != "number") throw new Error("the 'expiration' must be valid number");
    let r3 = this.walletAdapter.generateSecretKey(), a2 = new K$5(r3), s = await a2.getPublicKey(), i = this.stateValue.address;
    if (!i) throw new Error("address is undefined");
    let { message: o, signatured: p2 } = await this.walletAdapter.generateAddOrderlyKeyMessage({ brokerId: this.configStore.get("brokerId"), publicKey: s, expiration: e3, timestamp: x$1(), scope: t == null ? void 0 : t.scope, tag: t == null ? void 0 : t.tag });
    return console.log("generateAPiKey", s, i), { res: await this._simpleFetch("/v1/orderly_key", { method: "POST", body: JSON.stringify({ signature: p2, message: o, userAddress: i }), headers: { "X-Account-Id": this.stateValue.accountId, "Content-Type": "application/json" } }), address: i, keyPair: a2 };
  }
  async importOrderlyKey(e3) {
    var _a2;
    let { address: t, secretKey: r3, chainNamespace: a2 } = e3;
    if (!t || !r3 || !a2) return;
    let i = (_a2 = await this._checkAccountExist(t, a2)) == null ? void 0 : _a2.account_id;
    if (!i) return;
    let o = new K$5(r3), p2 = await this.checkOrderlyKey(t, o, i);
    return p2 && this.configStore.set("chainNamespace", a2), p2;
  }
  async checkOrderlyKey(e3, t, r3) {
    if (!e3 || !t || !r3) return;
    let a2 = await t.getPublicKey(), s = await this._checkOrderlyKeyState(r3, a2), { orderly_key: i, key_status: o, expiration: p2 } = s || {}, y2 = x$1();
    if (i && o === "ACTIVE" && p2 > y2) {
      this.keyStore.setAddress(e3), this.keyStore.setKey(e3, t), this.keyStore.setAccountId(e3, r3);
      let d2 = { ...this.stateValue, address: e3, accountId: r3, status: AccountStatusEnum.EnableTradingWithoutConnected };
      return this._ee.emit(E$4.statusChanged, d2), true;
    }
  }
  async settle() {
    if (!this.walletAdapter) return Promise.reject("walletAdapter is undefined");
    let e3 = await this._getSettleNonce(), t = this.stateValue.address, r3 = "/v1/settle_pnl", a2 = x$1(), { message: s, signatured: i, domain: o } = await this.walletAdapter.generateSettleMessage({ settlePnlNonce: e3, timestamp: a2, brokerId: this.configStore.get("brokerId"), verifyContract: this.contractManger.getContractInfoByEnv().verifyContractAddress }), p2 = { signature: i, message: s, userAddress: t, verifyingContract: o.verifyingContract }, y2 = { method: "POST", url: r3, data: p2 }, d2 = await this.signer.sign(y2, x$1()), l2 = await this._simpleFetch(r3, { method: "POST", body: JSON.stringify(p2), headers: { "Content-Type": "application/json", "orderly-account-id": this.stateValue.accountId, ...d2 } });
    return l2.success ? Promise.resolve(l2) : Promise.reject(l2);
  }
  async destroyOrderlyKey() {
    this.stateValue.address && this.keyStore.cleanKey(this.stateValue.address, "orderlyKey");
    let e3 = { ...this.stateValue, status: AccountStatusEnum.DisabledTrading };
    this._ee.emit(E$4.statusChanged, e3);
  }
  async disconnect() {
    this.stateValue.address && this.keyStore.removeAddress();
    let e3 = { ...this.stateValue, status: AccountStatusEnum.NotConnected, accountId: void 0, userId: void 0, address: void 0 };
    this._ee.emit(E$4.statusChanged, e3);
  }
  switchChainId(e3) {
    e3 = this.parseChainId(e3);
    let t = { ...this.stateValue, connectWallet: { ...this.stateValue.connectWallet, chainId: e3 } };
    this.walletAdapter && (this.walletAdapter.chainId = e3), this._ee.emit(E$4.statusChanged, t);
  }
  parseChainId(e3) {
    return typeof e3 == "string" && (Te$4(e3) || e3.startsWith("0x") && Te$4(e3.slice(2))) && (e3 = parseInt(e3, 16)), e3;
  }
  async _checkOrderlyKeyState(e3, t) {
    let r3 = await this._simpleFetch(`/v1/get_orderly_key?account_id=${e3}&orderly_key=${t}`);
    return r3.success ? r3.data : null;
  }
  get signer() {
    return this._singer || (this._singer = new Z$3(this.keyStore)), this._singer;
  }
  get walletAdapter() {
    return this.walletAdapterManager.adapter;
  }
  async _getRegisterationNonce() {
    var _a2;
    let e3 = await this._simpleFetch("/v1/registration_nonce", { headers: { "orderly-account-id": this.stateValue.accountId } });
    if (e3.success) return { nonce: (_a2 = e3.data) == null ? void 0 : _a2.registration_nonce, timestamp: e3.timestamp };
    throw new Error(e3.message);
  }
  async _getTimestampFromServer() {
    let e3 = await this._getAccountInfo();
    if (e3.success) return e3.timestamp;
    throw new SDKError("get timestamp error");
  }
  async _getAccountInfo(e3, t) {
    let r3 = this.configStore.get("brokerId"), a2 = e3 || this.address, s = t || this.stateValue.chainNamespace;
    return await this._simpleFetch(`/v1/get_account?address=${a2}&broker_id=${r3}&chain_type=${s}`);
  }
  async _getSettleNonce() {
    var _a2;
    let e3 = x$1().toString(), r3 = [e3, "GET", "/v1/settle_nonce"].join(""), a2 = this.signer, { publicKey: s, signature: i } = await a2.signText(r3), o = await this._simpleFetch("/v1/settle_nonce", { headers: { "orderly-account-id": this.stateValue.accountId, "orderly-key": s, "orderly-timestamp": e3, "orderly-signature": i } });
    if (o.success) return (_a2 = o.data) == null ? void 0 : _a2.settle_nonce;
    throw new Error(o.message);
  }
  async _simpleFetch(e3, t = {}) {
    let r3 = `${this.configStore.get("apiBaseUrl")}${e3}`;
    return fetch(r3, t).then((a2) => a2.json());
  }
  get on() {
    return this._ee.on.bind(this._ee);
  }
  get once() {
    return this._ee.once.bind(this._ee);
  }
  get off() {
    return this._ee.off.bind(this._ee);
  }
};
Le$7.instanceName = "account";
c();
c();
var kn = { mainnet: { apiBaseUrl: "https://api.orderly.org", publicWsUrl: "wss://ws-evm.orderly.org", privateWsUrl: "wss://ws-private-evm.orderly.org", operatorUrl: { EVM: "https://operator-evm.orderly.org", SOL: "https://operator-solana.orderly.org" } }, testnet: { apiBaseUrl: "https://testnet-api.orderly.org", publicWsUrl: "wss://testnet-ws-evm.orderly.org", privateWsUrl: "wss://testnet-ws-private-evm.orderly.org", operatorUrl: { EVM: "https://testnet-operator-evm.orderly.org", SOL: "https://testnet-operator-sol.orderly.org" } } }, Tt$5 = class Tt {
  constructor(e3) {
    let t = e3.env || "prod", r3 = e3.networkId || "mainnet", a2 = kn[r3], s = (e3 == null ? void 0 : e3.brokerId) || "orderly", i = (e3 == null ? void 0 : e3.brokerName) || "Orderly", o = (e3 == null ? void 0 : e3.chainNamespace) || ChainNamespace.evm;
    this.map = /* @__PURE__ */ new Map([["env", t], ["brokerId", s], ["brokerName", i], ["networkId", r3], ["chainNamespace", o], ["apiBaseUrl", a2.apiBaseUrl], ["publicWsUrl", a2.publicWsUrl], ["privateWsUrl", a2.privateWsUrl], ["operatorUrl", a2.operatorUrl]]);
  }
  get(e3) {
    let t = this.map.get(e3);
    return typeof t != "object" || t === null ? t : t[this.get("chainNamespace")];
  }
  getOr(e3, t) {
    return this.map.get(e3) ?? t;
  }
  set(e3, t) {
    this.map.set(e3, t);
  }
  clear() {
    throw new Error("Method not implemented.");
  }
};
c();
var Rn = fe$5(at$4());
var At$3 = class At {
  async signMessageByOrderlyKey(e3) {
    let t = xe$4.get("account"), a2 = await t.signer.sign(e3, x$1());
    return a2["orderly-account-id"] = t.accountId, a2;
  }
  get address() {
    throw new SDKError("Method not implemented.");
  }
  get chainId() {
    throw new SDKError("Method not implemented.");
  }
  active(e3) {
    throw new SDKError("Method not implemented.");
  }
  update(e3) {
    throw new SDKError("Method not implemented.");
  }
  generateSecretKey() {
    let e3, t;
    do
      e3 = Ue$7.randomPrivateKey(), t = (0, Rn.encode)(e3);
    while (t.length !== 44);
    return t;
  }
  parseUnits(e3, t = 6) {
    return parseUnits$1(e3, t).toString();
  }
  formatUnits(e3, t = 6) {
    return formatUnits(e3, t);
  }
  on(e3, t) {
    throw new SDKError("Method not implemented.");
  }
  off(e3, t) {
    throw new SDKError("Method not implemented.");
  }
};
c();
c();
c();
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

@noble/ed25519/index.js:
  (*! noble-ed25519 - MIT License (c) 2019 Paul Miller (paulmillr.com) *)
*/
a.set({ rounding: a.ROUND_DOWN });
var g$6 = a, y$3 = new a(0), $$5 = (t, e3) => {
  if (typeof t == "string" && isNaN(Number(t))) return (e3 == null ? void 0 : e3.fallback) || "--";
  let r3 = (e3 == null ? void 0 : e3.prefix) || "";
  if (typeof t == "undefined") return r3 + ((e3 == null ? void 0 : e3.fallback) || "--");
  let n4 = d$3(t, e3 == null ? void 0 : e3.fix);
  if (e3 && e3.padEnd && e3.fix) {
    let i = (e3 == null ? void 0 : e3.fillString) || "0", s = n4.includes("."), o = n4.split(".");
    return s ? r3 + o[0] + "." + o[1].padEnd(e3.fix, i) : r3 + o[0] + "." + "".padEnd(e3.fix, i);
  }
  return r3 + n4;
}, d$3 = (t, e3) => {
  let r3 = `${t}`;
  var n4 = r3.split(".");
  let i = n4[0], s = n4[1], o = /\B(?=(\d{3})+(?!\d))/g, c2 = r3.endsWith(".") && r3.length > 1, u2 = i.replace(o, ",") + (s ? "." + s.substring(0, e3 || s.length) : c2 ? "." : "");
  return e3 === 0 && u2.includes(".") ? u2.substring(0, u2.indexOf(".")) : u2;
}, E$3 = (t) => {
  t = m$2(Number(t));
  let e3 = t.toString().split(".");
  return e3[1] ? e3[1].length : 0;
};
function m$2(t) {
  let e3 = t.toExponential().match(/\d(?:\.(\d*))?e([+-]\d+)/);
  return Array.isArray(e3) ? t.toFixed(Math.max(0, (e3[1] || "").length - e3[2])) : t;
}
function _$3(t, e3 = 2, r3) {
  let i = ["", "K", "M", "B", "T"], s = 0;
  for (; t >= 1e3 && s < i.length - 1; ) t /= 1e3, s++;
  let o = new a(t).toFixed(e3, a.ROUND_DOWN).toString();
  return o = o.replace(/\.0+$/, ""), `${o}${i[s]}`;
}
function O$9(t, e3 = 16) {
  let r3 = `${t}`, i = /^[-+]?[0-9]+(\.[0-9]+)?[eE][-+]?[0-9]+$/.test(r3);
  return !t.toString().includes(".") && !i ? `${t}` : new a(t).toFixed(e3).replace(/(\.[0-9]*[1-9])0+$/, "$1");
}
var A$7 = (t, e3) => {
  if (t === void 0 || t === "" || (typeof t == "number" && (t = t.toString()), t.endsWith("."))) return t;
  let r3 = t.split(".");
  return r3.length === 1 || r3[1].length <= e3 || !r3[1] ? t : `${r3[0]}.${r3[1].substring(0, e3)}`;
};
var M$5 = (t) => {
  t /= 1e3;
  let e3 = Math.floor(t / 3600), r3 = Math.floor(t / 60 % 60), n4 = Math.floor(t % 60);
  return [e3, r3, n4];
};
function k$3(t, e3) {
  let r3 = e3 || /* @__PURE__ */ new Date(), n4 = new Date(r3);
  return n4.setDate(r3.getDate() - t), n4;
}
var f$5 = (t) => parseInt(t), F$3 = (t) => `0x${t.toString(16)}`, h$2 = (t) => typeof t == "string" && t.startsWith("0x") && /^[a-f0-9]+$/iu.test(t.slice(2)) ? f$5(t) : t, z$2 = h$2, B$7 = (t) => [ARBITRUM_TESTNET_CHAINID, SOLANA_TESTNET_CHAINID, STORY_TESTNET_CHAINID, MONAD_TESTNET_CHAINID].includes(t);
function U$5(t) {
  let e3 = t.toLowerCase();
  return e3.charAt(0).toUpperCase() + e3.slice(1);
}
function j$3(t) {
  let e3 = t.split("_");
  if (e3.length !== 3) throw new Error("Invalid string format");
  let [r3, n4, i] = e3;
  if (!r3.startsWith("PERP")) throw new Error("Invalid string format");
  return `${n4}-${r3}`;
}
function G$7(t) {
  return t.replace(/([a-z])([A-Z])/g, "$1_$2").toLowerCase();
}
var Y$4 = (t, e3) => {
  for (let r3 = 0; r3 < t.length; r3++) {
    let n4 = t.at(r3), i = e3.at(r3);
    if (n4 !== i) return r3;
  }
  return -1;
};
var w$4 = (t) => {
  typeof window != "undefined" && t();
}, l$1 = () => {
  if (typeof globalThis != "undefined") return globalThis;
  if (typeof self != "undefined") return self;
  if (typeof window != "undefined") return window;
  if (typeof dist.global != "undefined") return dist.global;
  throw new Error("cannot find the global object");
}, N$3 = () => {
  var t;
  if (typeof window != "undefined") {
    let e3 = (t = l$1()) == null ? void 0 : t.__ORDERLY_timestamp_offset;
    if (typeof e3 == "number") return Date.now() + (e3 || 0);
  }
  return Date.now();
};
var __defProp$1 = Object.defineProperty;
var __export$1 = (target, all) => {
  for (var name in all)
    __defProp$1(target, name, { get: all[name], enumerable: true });
};
if (typeof window !== "undefined") {
  window.__ORDERLY_VERSION__ = window.__ORDERLY_VERSION__ || {};
  window.__ORDERLY_VERSION__["@orderly.network/perp"] = "4.1.0";
}
var positions_exports = {};
__export$1(positions_exports, {
  MMR: () => MMR,
  estOffsetForTP: () => estOffsetForTP,
  estPnLForSL: () => estPnLForSL,
  estPnLForTP: () => estPnLForTP,
  estPriceForTP: () => estPriceForTP,
  estPriceFromOffsetForTP: () => estPriceFromOffsetForTP,
  liqPrice: () => liqPrice,
  maintenanceMargin: () => maintenanceMargin,
  notional: () => notional,
  totalNotional: () => totalNotional,
  totalUnrealizedPnL: () => totalUnrealizedPnL,
  totalUnsettlementPnL: () => totalUnsettlementPnL,
  unrealizedPnL: () => unrealizedPnL,
  unrealizedPnLROI: () => unrealizedPnLROI,
  unsettlementPnL: () => unsettlementPnL
});
var IMRFactorPower = 4 / 5;
function notional(qty, mark_price) {
  return new g$6(qty).mul(mark_price).abs().toNumber();
}
function totalNotional(positions) {
  return positions.reduce((acc, cur) => {
    return acc + notional(cur.position_qty, cur.mark_price);
  }, 0);
}
function unrealizedPnL(inputs) {
  return new g$6(inputs.qty).mul(inputs.markPrice - inputs.openPrice).toNumber();
}
function unrealizedPnLROI(inputs) {
  const { openPrice, IMR: IMR2 } = inputs;
  if (inputs.unrealizedPnL === 0 || inputs.positionQty === 0 || openPrice === 0 || IMR2 === 0)
    return 0;
  return new g$6(inputs.unrealizedPnL).div(new g$6(Math.abs(inputs.positionQty)).mul(openPrice).mul(IMR2)).toNumber();
}
function totalUnrealizedPnL(positions) {
  return positions.reduce((acc, cur) => {
    return acc + unrealizedPnL({
      qty: cur.position_qty,
      openPrice: cur.average_open_price,
      markPrice: cur.mark_price
    });
  }, 0);
}
function liqPrice(inputs) {
  const { markPrice, totalCollateral: totalCollateral2, positions, positionQty, MMR: MMR3 } = inputs;
  if (positionQty === 0 || totalCollateral2 === 0) {
    return null;
  }
  const totalNotional2 = positions.reduce((acc, cur) => {
    return acc.add(
      new g$6(notional(cur.position_qty, cur.mark_price)).mul(cur.mmr)
    );
  }, y$3);
  return Math.max(
    new g$6(markPrice).add(
      new g$6(totalCollateral2).sub(totalNotional2).div(new g$6(positionQty).abs().mul(MMR3).sub(positionQty))
    ).toNumber(),
    0
  );
}
function maintenanceMargin(inputs) {
  const { positionQty, markPrice, MMR: MMR3 } = inputs;
  return new g$6(positionQty).mul(markPrice).mul(MMR3).abs().toNumber();
}
function unsettlementPnL(inputs) {
  const {
    positionQty,
    markPrice,
    costPosition,
    sumUnitaryFunding,
    lastSumUnitaryFunding
  } = inputs;
  const qty = new g$6(positionQty);
  return qty.mul(markPrice).sub(costPosition).sub(qty.mul(new g$6(sumUnitaryFunding).sub(lastSumUnitaryFunding))).toNumber();
}
function totalUnsettlementPnL(positions) {
  if (!Array.isArray(positions) || positions.length === 0) {
    return 0;
  }
  return positions.reduce((acc, cur) => {
    return acc + unsettlementPnL({
      positionQty: cur.position_qty,
      markPrice: cur.mark_price,
      costPosition: cur.cost_position,
      sumUnitaryFunding: cur.sum_unitary_funding,
      lastSumUnitaryFunding: cur.last_sum_unitary_funding
    });
  }, 0);
}
function MMR(inputs) {
  const {
    baseMMR,
    baseIMR,
    IMRFactor,
    positionNotional,
    IMR_factor_power = IMRFactorPower
  } = inputs;
  return Math.max(
    baseMMR,
    new g$6(baseMMR).div(baseIMR).mul(IMRFactor).mul(Math.pow(Math.abs(positionNotional), IMR_factor_power)).toNumber()
  );
}
function estPnLForTP(inputs) {
  return new g$6(inputs.positionQty).mul(new g$6(inputs.price).sub(inputs.entryPrice)).toNumber();
}
function estPriceForTP(inputs) {
  return new g$6(inputs.pnl).add(inputs.entryPrice).div(inputs.positionQty).toNumber();
}
function estOffsetForTP(inputs) {
  return new g$6(inputs.price).div(inputs.entryPrice).toNumber();
}
function estPriceFromOffsetForTP(inputs) {
  return new g$6(inputs.offset).add(inputs.entryPrice).toNumber();
}
function estPnLForSL(inputs) {
  return 0;
}
var account_exports = {};
__export$1(account_exports, {
  IMR: () => IMR,
  MMR: () => MMR2,
  availableBalance: () => availableBalance,
  buyOrdersFilter_by_symbol: () => buyOrdersFilter_by_symbol,
  currentLeverage: () => currentLeverage,
  extractSymbols: () => extractSymbols,
  freeCollateral: () => freeCollateral,
  getPositonsAndOrdersNotionalBySymbol: () => getPositonsAndOrdersNotionalBySymbol,
  getQtyFromOrdersBySide: () => getQtyFromOrdersBySide,
  getQtyFromPositions: () => getQtyFromPositions,
  groupOrdersBySymbol: () => groupOrdersBySymbol,
  initialMarginWithOrder: () => initialMarginWithOrder,
  maxQty: () => maxQty,
  maxQtyByLong: () => maxQtyByLong,
  maxQtyByShort: () => maxQtyByShort,
  otherIMs: () => otherIMs,
  positionNotionalWithOrder_by_symbol: () => positionNotionalWithOrder_by_symbol,
  positionQtyWithOrders_by_symbol: () => positionQtyWithOrders_by_symbol,
  sellOrdersFilter_by_symbol: () => sellOrdersFilter_by_symbol,
  totalCollateral: () => totalCollateral,
  totalInitialMarginWithOrders: () => totalInitialMarginWithOrders,
  totalInitialMarginWithQty: () => totalInitialMarginWithQty,
  totalMarginRatio: () => totalMarginRatio,
  totalUnrealizedROI: () => totalUnrealizedROI,
  totalValue: () => totalValue
});
function totalValue(inputs) {
  const { totalUnsettlementPnL: totalUnsettlementPnL2, USDCHolding, nonUSDCHolding } = inputs;
  const nonUSDCHoldingValue = nonUSDCHolding.reduce((acc, cur) => {
    return new g$6(cur.holding).mul(cur.markPrice).add(acc);
  }, y$3);
  return nonUSDCHoldingValue.add(USDCHolding).add(totalUnsettlementPnL2);
}
function freeCollateral(inputs) {
  const value = inputs.totalCollateral.sub(inputs.totalInitialMarginWithOrders);
  return value.isNegative() ? y$3 : value;
}
function totalCollateral(inputs) {
  const { USDCHolding, nonUSDCHolding } = inputs;
  const nonUSDCHoldingValue = nonUSDCHolding.reduce((acc, cur) => {
    return acc + new g$6(cur.holding).mul(cur.markPrice).mul(cur.discount).toNumber();
  }, 0);
  return new g$6(USDCHolding).add(nonUSDCHoldingValue).add(inputs.unsettlementPnL);
}
function initialMarginWithOrder() {
}
function positionNotionalWithOrder_by_symbol(inputs) {
  return new g$6(inputs.markPrice).mul(inputs.positionQtyWithOrders);
}
function positionQtyWithOrders_by_symbol(inputs) {
  const { positionQty, buyOrdersQty, sellOrdersQty } = inputs;
  const positionQtyDecimal = new g$6(positionQty);
  const qty = Math.max(
    positionQtyDecimal.add(buyOrdersQty).abs().toNumber(),
    positionQtyDecimal.sub(sellOrdersQty).abs().toNumber()
  );
  return qty;
}
function IMR(inputs) {
  const {
    maxLeverage,
    baseIMR,
    IMR_Factor,
    positionNotional,
    ordersNotional: orderNotional,
    IMR_factor_power = IMRFactorPower
  } = inputs;
  return Math.max(
    1 / maxLeverage,
    baseIMR,
    new g$6(IMR_Factor).mul(
      new g$6(positionNotional).add(orderNotional).abs().toPower(IMR_factor_power)
    ).toNumber()
  );
}
function buyOrdersFilter_by_symbol(orders, symbol) {
  return orders.filter(
    (item) => item.symbol === symbol && item.side === OrderSide.BUY
  );
}
function sellOrdersFilter_by_symbol(orders, symbol) {
  return orders.filter(
    (item) => item.symbol === symbol && item.side === OrderSide.SELL
  );
}
function getQtyFromPositions(positions, symbol) {
  if (!positions) {
    return 0;
  }
  const position = positions.find((item) => item.symbol === symbol);
  return (position == null ? void 0 : position.position_qty) || 0;
}
function getQtyFromOrdersBySide(orders, symbol, side) {
  const ordersBySide = side === OrderSide.SELL ? sellOrdersFilter_by_symbol(orders, symbol) : buyOrdersFilter_by_symbol(orders, symbol);
  return ordersBySide.reduce((acc, cur) => {
    return acc + cur.quantity;
  }, 0);
}
function getPositonsAndOrdersNotionalBySymbol(inputs) {
  const { positions, orders, symbol, markPrice } = inputs;
  const positionQty = getQtyFromPositions(positions, symbol);
  const buyOrdersQty = getQtyFromOrdersBySide(orders, symbol, OrderSide.BUY);
  const sellOrdersQty = getQtyFromOrdersBySide(orders, symbol, OrderSide.SELL);
  const markPriceDecimal = new g$6(markPrice);
  return markPriceDecimal.mul(positionQty).add(markPriceDecimal.mul(new g$6(buyOrdersQty).add(sellOrdersQty))).abs().toNumber();
}
function totalInitialMarginWithOrders(inputs) {
  const {
    positions,
    orders,
    markPrices,
    IMR_Factors,
    maxLeverage,
    symbolInfo
  } = inputs;
  const symbols = extractSymbols(positions, orders);
  const total_initial_margin_with_orders = symbols.reduce((acc, cur) => {
    const symbol = cur;
    const positionQty = getQtyFromPositions(positions, symbol);
    const buyOrdersQty = getQtyFromOrdersBySide(orders, symbol, OrderSide.BUY);
    const sellOrdersQty = getQtyFromOrdersBySide(
      orders,
      symbol,
      OrderSide.SELL
    );
    const markPrice = markPrices[symbol] || 0;
    const positionQtyWithOrders = positionQtyWithOrders_by_symbol({
      positionQty,
      buyOrdersQty,
      sellOrdersQty
    });
    const position_notional_with_orders = positionNotionalWithOrder_by_symbol({
      markPrice,
      positionQtyWithOrders
    });
    const markPriceDecimal = new g$6(markPrice);
    const imr = IMR({
      positionNotional: markPriceDecimal.mul(positionQty).toNumber(),
      ordersNotional: markPriceDecimal.mul(new g$6(buyOrdersQty).add(sellOrdersQty)).toNumber(),
      maxLeverage,
      IMR_Factor: IMR_Factors[symbol],
      baseIMR: symbolInfo[symbol]("base_imr", 0)
    });
    return position_notional_with_orders.mul(imr).add(acc).toNumber();
  }, 0);
  return total_initial_margin_with_orders;
}
function totalInitialMarginWithQty(inputs) {
  const { positions, markPrices, IMR_Factors, symbolInfo, maxLeverage } = inputs;
  const symbols = positions.map((item) => item.symbol);
  const total_initial_margin_with_orders = symbols.reduce((acc, cur) => {
    const symbol = cur;
    const position = positions.find((item) => item.symbol === symbol);
    const positionQty = (position == null ? void 0 : position.position_qty) || 0;
    const buyOrdersQty = (position == null ? void 0 : position.pending_long_qty) || 0;
    const sellOrdersQty = (position == null ? void 0 : position.pending_short_qty) || 0;
    const markPrice = markPrices[symbol] || 0;
    const positionQtyWithOrders = positionQtyWithOrders_by_symbol({
      positionQty,
      buyOrdersQty,
      sellOrdersQty
    });
    const position_notional_with_orders = positionNotionalWithOrder_by_symbol({
      markPrice,
      positionQtyWithOrders
    });
    const markPriceDecimal = new g$6(markPrice);
    const imr = IMR({
      positionNotional: markPriceDecimal.mul(positionQty).toNumber(),
      ordersNotional: markPriceDecimal.mul(new g$6(buyOrdersQty).add(sellOrdersQty)).toNumber(),
      maxLeverage,
      IMR_Factor: IMR_Factors[symbol],
      baseIMR: symbolInfo[symbol]("base_imr", 0)
    });
    return position_notional_with_orders.mul(imr).add(acc).toNumber();
  }, 0);
  return total_initial_margin_with_orders;
}
function groupOrdersBySymbol(orders) {
  const symbols = {};
  orders.forEach((item) => {
    if (!symbols[item.symbol]) {
      symbols[item.symbol] = [];
    }
    symbols[item.symbol].push(item);
  });
  return symbols;
}
function extractSymbols(positions, orders) {
  const symbols = /* @__PURE__ */ new Set();
  positions.forEach((item) => {
    symbols.add(item.symbol);
  });
  orders.forEach((item) => {
    symbols.add(item.symbol);
  });
  return Array.from(symbols);
}
function otherIMs(inputs) {
  const {
    orders,
    positions,
    maxLeverage,
    IMR_Factors,
    symbolInfo,
    markPrices
  } = inputs;
  const symbols = extractSymbols(positions, orders);
  return symbols.reduce((acc, cur) => {
    const symbol = cur;
    if (typeof markPrices[symbol] === "undefined") {
      console.warn("markPrices[%s] is undefined", symbol);
      return acc;
    }
    const markPriceDecimal = new g$6(markPrices[symbol] || 0);
    const positionQty = getQtyFromPositions(positions, symbol);
    const positionNotional = markPriceDecimal.mul(positionQty).toNumber();
    const buyOrdersQty = getQtyFromOrdersBySide(
      orders,
      symbol,
      OrderSide.BUY
    );
    const sellOrdersQty = getQtyFromOrdersBySide(
      orders,
      symbol,
      OrderSide.SELL
    );
    const ordersNotional = markPriceDecimal.mul(new g$6(buyOrdersQty).add(sellOrdersQty)).toNumber();
    const IMR_Factor = IMR_Factors[symbol];
    if (!IMR_Factor) {
      console.warn("IMR_Factor is not found:", symbol);
      return acc;
    }
    const imr = IMR({
      maxLeverage,
      IMR_Factor,
      baseIMR: symbolInfo[symbol]("base_imr", 0),
      positionNotional,
      ordersNotional
    });
    const positionQtyWithOrders = positionQtyWithOrders_by_symbol({
      positionQty,
      buyOrdersQty,
      sellOrdersQty
    });
    const positionNotionalWithOrders = positionNotionalWithOrder_by_symbol({
      markPrice: markPrices[symbol] || 0,
      positionQtyWithOrders
    });
    return acc.add(positionNotionalWithOrders.mul(imr));
  }, y$3).toNumber();
}
function maxQty(side, inputs, options) {
  if (side === OrderSide.BUY) {
    return maxQtyByLong(inputs);
  }
  return maxQtyByShort(inputs);
}
function maxQtyByLong(inputs, options) {
  try {
    const {
      baseMaxQty,
      totalCollateral: totalCollateral2,
      otherIMs: otherIMs2,
      maxLeverage,
      baseIMR,
      markPrice,
      IMR_Factor,
      positionQty,
      buyOrdersQty,
      takerFeeRate
    } = inputs;
    if (totalCollateral2 === 0) {
      return 0;
    }
    const totalCollateralDecimal = new g$6(totalCollateral2);
    const factor_1 = totalCollateralDecimal.sub(otherIMs2).div(
      new g$6(takerFeeRate).mul(2).mul(1e-4).add(Math.max(1 / maxLeverage, baseIMR))
    ).div(markPrice).mul(0.995).sub(new g$6(positionQty).add(buyOrdersQty)).toNumber();
    if (positionQty === 0 && buyOrdersQty === 0) {
      return Math.min(baseMaxQty, factor_1);
    }
    const factor_2 = totalCollateralDecimal.sub(otherIMs2).div(IMR_Factor).toPower(1 / 1.8).div(markPrice).sub(
      new g$6(positionQty).add(buyOrdersQty)
      // .abs()
      // .div(new Decimal(takerFeeRate).mul(2).mul(0.0001).add(1))
    ).div(new g$6(takerFeeRate).mul(2).mul(1e-4).add(1)).mul(0.995).toNumber();
    return Math.min(baseMaxQty, factor_1, factor_2);
  } catch (error) {
    return 0;
  }
}
function maxQtyByShort(inputs, options) {
  try {
    const {
      baseMaxQty,
      totalCollateral: totalCollateral2,
      otherIMs: otherIMs2,
      maxLeverage,
      baseIMR,
      markPrice,
      IMR_Factor,
      positionQty,
      buyOrdersQty,
      sellOrdersQty,
      takerFeeRate
    } = inputs;
    const totalCollateralDecimal = new g$6(totalCollateral2);
    const factor_1 = totalCollateralDecimal.sub(otherIMs2).div(
      new g$6(takerFeeRate).mul(2).mul(1e-4).add(Math.max(1 / maxLeverage, baseIMR))
    ).div(markPrice).mul(0.995).add(positionQty).sub(sellOrdersQty).toNumber();
    if (positionQty === 0 && buyOrdersQty === 0) {
      return Math.min(baseMaxQty, factor_1);
    }
    const factor_2 = totalCollateralDecimal.sub(otherIMs2).div(IMR_Factor).toPower(1 / 1.8).div(markPrice).add(positionQty).sub(sellOrdersQty).div(new g$6(takerFeeRate).mul(2).mul(1e-4).add(1)).mul(0.995).toNumber();
    return Math.min(baseMaxQty, factor_1, factor_2);
  } catch (error) {
    return 0;
  }
}
function totalMarginRatio(inputs, dp) {
  const { totalCollateral: totalCollateral2, markPrices, positions } = inputs;
  if (totalCollateral2 === 0) {
    return 0;
  }
  const totalCollateralDecimal = new g$6(totalCollateral2);
  const totalPositionNotional = positions.reduce((acc, cur) => {
    const markPrice = markPrices[cur.symbol] || 0;
    return acc.add(new g$6(cur.position_qty).mul(markPrice).abs());
  }, y$3);
  if (totalPositionNotional.eq(y$3)) {
    return 0;
  }
  return totalCollateralDecimal.div(totalPositionNotional).toNumber();
}
function totalUnrealizedROI(inputs) {
  const { totalUnrealizedPnL: totalUnrealizedPnL2, totalValue: totalValue2 } = inputs;
  return new g$6(totalUnrealizedPnL2).div(totalValue2 - totalUnrealizedPnL2).toNumber();
}
function currentLeverage(totalMarginRatio2) {
  if (totalMarginRatio2 === 0) {
    return 0;
  }
  return 1 / totalMarginRatio2;
}
function availableBalance(inputs) {
  const { USDCHolding, unsettlementPnL: unsettlementPnL2 } = inputs;
  return new g$6(USDCHolding).add(unsettlementPnL2).toNumber();
}
function MMR2(inputs) {
  if (inputs.positionsNotional === 0) {
    return null;
  }
  if (inputs.positionsMMR === 0)
    return null;
  return new g$6(inputs.positionsMMR).div(inputs.positionsNotional).toNumber();
}
var order_exports = {};
__export$1(order_exports, {
  estLeverage: () => estLeverage,
  estLiqPrice: () => estLiqPrice,
  maxPrice: () => maxPrice$1,
  minPrice: () => minPrice$1,
  orderFee: () => orderFee,
  scopePrice: () => scopePrice$1
});
function maxPrice$1(markprice, range) {
  return markprice * (1 + range);
}
function minPrice$1(markprice, range) {
  return markprice * (1 - range);
}
function scopePrice$1(price, scope, side) {
  if (side === "BUY") {
    return price * (1 - scope);
  }
  return price * (1 + scope);
}
function orderFee(inputs) {
  return new g$6(inputs.qty).mul(inputs.price).mul(inputs.futuresTakeFeeRate).toNumber();
}
function estLiqPrice(inputs) {
  var _a2;
  const {
    positions,
    newOrder,
    totalCollateral: totalCollateral2,
    markPrice,
    baseIMR,
    baseMMR,
    orderFee: orderFee2,
    IMR_Factor
  } = inputs;
  let currentPosition = void 0;
  let newTotalMM = y$3;
  const hasPosition = positions.filter((item) => item.position_qty > 0).length > 0;
  const basePrice = hasPosition ? markPrice : newOrder.price;
  const newOrderNotional = new g$6(newOrder.qty).mul(newOrder.price);
  for (let index = 0; index < positions.length; index++) {
    const position = positions[index];
    let notional2 = new g$6(position.position_qty).mul(position.mark_price);
    if (newOrder.symbol === position.symbol) {
      currentPosition = position;
      notional2 = notional2.add(newOrderNotional);
    }
    newTotalMM = newTotalMM.add(notional2.abs().mul(position.mmr));
  }
  if (!currentPosition) {
    newTotalMM = newTotalMM.add(newOrderNotional.mul(baseMMR));
  }
  const newMMR = Math.max(
    baseMMR,
    new g$6(baseMMR).div(baseIMR).mul(IMR_Factor).mul(
      newOrderNotional.add(
        !!currentPosition ? new g$6(currentPosition.position_qty).mul(
          currentPosition.mark_price
        ) : y$3
      ).abs()
    ).toPower(4 / 5).toNumber()
  );
  const newQty = new g$6(newOrder.qty).add(
    (_a2 = currentPosition == null ? void 0 : currentPosition.position_qty) != null ? _a2 : 0
  );
  if (newQty.eq(0)) {
    return 0;
  }
  const price = new g$6(basePrice).add(
    new g$6(totalCollateral2).sub(newTotalMM).sub(orderFee2).div(newQty.abs().mul(newMMR).sub(newQty))
  ).toNumber();
  return Math.max(0, price);
}
function estLeverage(inputs) {
  const { totalCollateral: totalCollateral2, positions, newOrder } = inputs;
  if (totalCollateral2 <= 0) {
    return null;
  }
  let hasPosition = false;
  let sumPositionNotional = positions.reduce((acc, cur) => {
    let count = new g$6(cur.position_qty).mul(cur.mark_price);
    if (cur.symbol === newOrder.symbol) {
      hasPosition = true;
      count = count.add(new g$6(newOrder.qty).mul(newOrder.price));
    }
    return acc.add(count.abs());
  }, y$3);
  if (!hasPosition) {
    sumPositionNotional = sumPositionNotional.add(
      new g$6(newOrder.qty).mul(newOrder.price).abs()
    );
  }
  if (sumPositionNotional.eq(y$3)) {
    return null;
  }
  const totalMarginRatio2 = new g$6(totalCollateral2).div(
    sumPositionNotional
  );
  return new g$6(1).div(totalMarginRatio2).toDecimalPlaces(2, g$6.ROUND_HALF_EVEN).toNumber();
}
const { encode: N$2 } = ((_c = (_b = __cjsInterop1__) == null ? void 0 : _b.default) == null ? void 0 : _c.__esModule) ? __cjsInterop1__.default : __cjsInterop1__;
var S$4 = Object.defineProperty, E$2 = Object.defineProperties;
var _$2 = Object.getOwnPropertyDescriptors;
var M$4 = Object.getOwnPropertySymbols;
var O$8 = Object.prototype.hasOwnProperty, A$6 = Object.prototype.propertyIsEnumerable;
var I$7 = (s, a2, e3) => a2 in s ? S$4(s, a2, { enumerable: true, configurable: true, writable: true, value: e3 }) : s[a2] = e3, g$5 = (s, a2) => {
  for (var e3 in a2 || (a2 = {})) O$8.call(a2, e3) && I$7(s, e3, a2[e3]);
  if (M$4) for (var e3 of M$4(a2)) A$6.call(a2, e3) && I$7(s, e3, a2[e3]);
  return s;
}, p$2 = (s, a2) => E$2(s, _$2(a2));
var y$2 = (s, a2, e3) => (I$7(s, typeof a2 != "symbol" ? a2 + "" : a2, e3), e3);
var m$1 = (s, a2, e3) => new Promise((t, n4) => {
  var i = (o) => {
    try {
      d2(e3.next(o));
    } catch (c2) {
      n4(c2);
    }
  }, r3 = (o) => {
    try {
      d2(e3.throw(o));
    } catch (c2) {
      n4(c2);
    }
  }, d2 = (o) => o.done ? t(o.value) : Promise.resolve(o.value).then(i, r3);
  d2((e3 = e3.apply(s, a2)).next());
});
typeof window != "undefined" && (window.__ORDERLY_VERSION__ = window.__ORDERLY_VERSION__ || {}, window.__ORDERLY_VERSION__["@orderly.network/default-evm-adapter"] = "2.1.0");
function f$4(s) {
  return m$1(this, null, function* () {
    let { chainId: a2, receiver: e3, token: t, amount: n4, nonce: i, brokerId: r3, domain: d2 } = s, o = "Withdraw", c2 = Date.now(), h2 = { EIP712Domain: definedTypes.EIP712Domain, [o]: definedTypes[o] }, l2 = { brokerId: r3, chainId: a2, receiver: e3, token: t, amount: n4, timestamp: c2, withdrawNonce: i };
    return [l2, { domain: d2, message: l2, primaryType: o, types: h2 }];
  });
}
function v$3(s) {
  return m$1(this, null, function* () {
    let { publicKey: a2, chainId: e3, brokerId: t, expiration: n4 = 365, timestamp: i = Date.now(), scope: r3, tag: d2, domain: o } = s, c2 = "AddOrderlyKey", h2 = g$5({ brokerId: t, orderlyKey: a2, scope: r3 || "read,trading", chainId: e3, timestamp: i, expiration: i + 1e3 * 60 * 60 * 24 * n4 }, typeof d2 != "undefined" ? { tag: d2 } : {}), l2 = { EIP712Domain: definedTypes.EIP712Domain, [c2]: definedTypes[c2] };
    return [h2, { domain: o, message: h2, primaryType: c2, types: l2 }];
  });
}
function b$3(s) {
  return m$1(this, null, function* () {
    let { chainId: a2, domain: e3, registrationNonce: t, brokerId: n4, timestamp: i } = s, r3 = "Registration", d2 = { brokerId: n4, chainId: a2, timestamp: i, registrationNonce: t }, o = { EIP712Domain: definedTypes.EIP712Domain, [r3]: definedTypes[r3] };
    return [d2, { domain: e3, message: d2, primaryType: r3, types: o }];
  });
}
function D$2(s) {
  return m$1(this, null, function* () {
    let { settlePnlNonce: a2, brokerId: e3, chainId: t, timestamp: n4, domain: i } = s, r3 = "SettlePnl", d2 = { EIP712Domain: definedTypes.EIP712Domain, [r3]: definedTypes[r3] }, o = { brokerId: e3, chainId: t, timestamp: n4, settleNonce: a2 };
    return [o, { domain: i, message: o, primaryType: r3, types: d2 }];
  });
}
var w$3 = class w extends At$3 {
  constructor(e3) {
    super();
    this.web3Provider = e3;
    y$2(this, "chainNamespace", ChainNamespace.evm);
    y$2(this, "_address");
    y$2(this, "_chainId");
    y$2(this, "contractManager");
  }
  get address() {
    return this._address;
  }
  get chainId() {
    return this._chainId;
  }
  set chainId(e3) {
    this._chainId = e3;
  }
  setConfig(e3) {
    if (this._address = e3.address, this._chainId = e3.chain.id, e3.provider && (this.web3Provider.provider = e3.provider), e3.contractManager) this.contractManager = e3.contractManager;
    else throw new Error("Please provide contract manager class");
  }
  active(e3) {
    this.setConfig(e3), this.lifecycleName("active", e3);
  }
  deactivate() {
    this.lifecycleName("deactivate", {});
  }
  update(e3) {
    this.lifecycleName("update", e3), this.setConfig(e3);
  }
  generateSecretKey() {
    let e3, t;
    do
      e3 = P$3.utils.randomPrivateKey(), t = N$2(e3);
    while (t.length !== 44);
    return t;
  }
  lifecycleName(e3, t) {
    console.log("lifecycle", e3, t);
  }
  signTypedData(e3) {
    return m$1(this, null, function* () {
      return console.log("toSignatureMessage", this.address), yield this.web3Provider.signTypedData(this.address, JSON.stringify(e3));
    });
  }
  generateRegisterAccountMessage(e3) {
    return m$1(this, null, function* () {
      let [t, n4] = yield b$3(p$2(g$5({}, e3), { chainId: this.chainId, domain: this.getDomain() })), i = yield this.signTypedData(n4);
      return { message: p$2(g$5({}, t), { chainType: "EVM" }), signatured: i };
    });
  }
  generateAddOrderlyKeyMessage(e3) {
    return m$1(this, null, function* () {
      let [t, n4] = yield v$3(p$2(g$5({}, e3), { chainId: this.chainId, domain: this.getDomain() })), i = yield this.signTypedData(n4);
      return { message: p$2(g$5({}, t), { chainType: "EVM" }), signatured: i };
    });
  }
  generateWithdrawMessage(e3) {
    return m$1(this, null, function* () {
      let t = this.getDomain(true), [n4, i] = yield f$4(p$2(g$5({}, e3), { chainId: this.chainId, domain: t })), r3 = yield this.signTypedData(i);
      return { message: p$2(g$5({}, n4), { chainType: "EVM" }), signatured: r3, domain: t };
    });
  }
  generateSettleMessage(e3) {
    return m$1(this, null, function* () {
      let t = this.getDomain(true), [n4, i] = yield D$2(p$2(g$5({}, e3), { chainId: this.chainId, domain: t })), r3 = yield this.signTypedData(i);
      return { message: p$2(g$5({}, n4), { chainType: "EVM" }), signatured: r3, domain: t };
    });
  }
  getBalance() {
    return this.web3Provider.getBalance(this.address);
  }
  call(e3, t, n4, i) {
    return this.web3Provider.call(e3, t, n4, i);
  }
  sendTransaction(e3, t, n4, i) {
    return this.web3Provider.sendTransaction(e3, t, n4, i);
  }
  callOnChain(e3, t, n4, i, r3) {
    return this.web3Provider.callOnChain(e3, t, n4, i, r3);
  }
  getDomain(e3) {
    if (!this.web3Provider) throw new Error("web3Provider is undefined");
    return { name: "Orderly", version: "1", chainId: this.chainId, verifyingContract: e3 ? this.contractManager.getContractInfoByEnv().verifyContractAddress : "0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC" };
  }
  pollTransactionReceiptWithBackoff(e3, t, n4, i) {
    return this.web3Provider.pollTransactionReceiptWithBackoff(e3, t, n4, i);
  }
};
const { encode: Xn$3 } = ((_e3 = (_d = __cjsInterop1__) == null ? void 0 : _d.default) == null ? void 0 : _e3.__esModule) ? __cjsInterop1__.default : __cjsInterop1__;
const { decode: Gn$2 } = ((_g2 = (_f = __cjsInterop1__) == null ? void 0 : _f.default) == null ? void 0 : _g2.__esModule) ? __cjsInterop1__.default : __cjsInterop1__;
const { BN: _e$6, Program: ln$3 } = ((_i2 = (_h = __cjsInterop1__$1) == null ? void 0 : _h.default) == null ? void 0 : _i2.__esModule) ? __cjsInterop1__$1.default : __cjsInterop1__$1;
var In$1 = Object.defineProperty, wn$2 = Object.defineProperties;
var _n$1 = Object.getOwnPropertyDescriptors;
var Ke$5 = Object.getOwnPropertySymbols;
var Tn$1 = Object.prototype.hasOwnProperty, xn$3 = Object.prototype.propertyIsEnumerable;
var ie$3 = (n4, a2, e3) => a2 in n4 ? In$1(n4, a2, { enumerable: true, configurable: true, writable: true, value: e3 }) : n4[a2] = e3, g$4 = (n4, a2) => {
  for (var e3 in a2 || (a2 = {})) Tn$1.call(a2, e3) && ie$3(n4, e3, a2[e3]);
  if (Ke$5) for (var e3 of Ke$5(a2)) xn$3.call(a2, e3) && ie$3(n4, e3, a2[e3]);
  return n4;
}, S$3 = (n4, a2) => wn$2(n4, _n$1(a2));
var B$6 = (n4, a2, e3) => (ie$3(n4, typeof a2 != "symbol" ? a2 + "" : a2, e3), e3);
var l = (n4, a2, e3) => new Promise((s, i) => {
  var t = (r3) => {
    try {
      m2(e3.next(r3));
    } catch (u2) {
      i(u2);
    }
  }, o = (r3) => {
    try {
      m2(e3.throw(r3));
    } catch (u2) {
      i(u2);
    }
  }, m2 = (r3) => r3.done ? s(r3.value) : Promise.resolve(r3.value).then(t, o);
  m2((e3 = e3.apply(n4, a2)).next());
});
typeof window != "undefined" && (window.__ORDERLY_VERSION__ = window.__ORDERLY_VERSION__ || {}, window.__ORDERLY_VERSION__["@orderly.network/default-solana-adapter"] = "2.1.0");
var oe$5 = { version: "0.1.0", name: "solana_vault", instructions: [{ name: "initVault", accounts: [{ name: "signer", isMut: true, isSigner: true }, { name: "vaultAuthority", isMut: true, isSigner: false }, { name: "systemProgram", isMut: false, isSigner: false }], args: [{ name: "params", type: { defined: "InitVaultParams" } }] }, { name: "deposit", accounts: [{ name: "user", isMut: true, isSigner: true }, { name: "userTokenAccount", isMut: true, isSigner: false }, { name: "vaultAuthority", isMut: true, isSigner: false }, { name: "vaultTokenAccount", isMut: true, isSigner: false }, { name: "depositToken", isMut: false, isSigner: false }, { name: "peer", isMut: false, isSigner: false }, { name: "enforcedOptions", isMut: false, isSigner: false }, { name: "oappConfig", isMut: false, isSigner: false }, { name: "allowedBroker", isMut: false, isSigner: false }, { name: "allowedToken", isMut: false, isSigner: false }, { name: "tokenProgram", isMut: false, isSigner: false }, { name: "associatedTokenProgram", isMut: false, isSigner: false }, { name: "systemProgram", isMut: false, isSigner: false }], args: [{ name: "depositParams", type: { defined: "DepositParams" } }, { name: "oappParams", type: { defined: "OAppSendParams" } }], returns: { defined: "MessagingReceipt" } }, { name: "initOapp", accounts: [{ name: "payer", isMut: true, isSigner: true }, { name: "oappConfig", isMut: true, isSigner: false }, { name: "lzReceiveTypes", isMut: true, isSigner: false }, { name: "systemProgram", isMut: false, isSigner: false }], args: [{ name: "params", type: { defined: "InitOAppParams" } }] }, { name: "resetOapp", accounts: [{ name: "admin", isMut: true, isSigner: true }, { name: "oappConfig", isMut: true, isSigner: false }], args: [] }, { name: "reinitOapp", accounts: [{ name: "owner", isMut: true, isSigner: true }, { name: "oappConfig", isMut: true, isSigner: false }, { name: "vaultAuthority", isMut: false, isSigner: false }, { name: "systemProgram", isMut: false, isSigner: false }], args: [{ name: "params", type: { defined: "ReinitOAppParams" } }] }, { name: "resetVault", accounts: [{ name: "owner", isMut: true, isSigner: true }, { name: "vaultAuthority", isMut: true, isSigner: false }], args: [] }, { name: "reinitVault", accounts: [{ name: "admin", isMut: true, isSigner: true }, { name: "vaultAuthority", isMut: true, isSigner: false }, { name: "oappConfig", isMut: false, isSigner: false }, { name: "systemProgram", isMut: false, isSigner: false }], args: [{ name: "params", type: { defined: "ReinitVaultParams" } }] }, { name: "setBroker", accounts: [{ name: "admin", isMut: true, isSigner: true }, { name: "allowedBroker", isMut: true, isSigner: false }, { name: "oappConfig", isMut: false, isSigner: false }, { name: "systemProgram", isMut: false, isSigner: false }], args: [{ name: "params", type: { defined: "SetBrokerParams" } }] }, { name: "setToken", accounts: [{ name: "admin", isMut: true, isSigner: true }, { name: "allowedToken", isMut: true, isSigner: false }, { name: "oappConfig", isMut: false, isSigner: false }, { name: "mintAccount", isMut: false, isSigner: false }, { name: "systemProgram", isMut: false, isSigner: false }], args: [{ name: "params", type: { defined: "SetTokenParams" } }] }, { name: "setOrderDelivery", accounts: [{ name: "owner", isMut: true, isSigner: true }, { name: "vaultAuthority", isMut: true, isSigner: false }], args: [{ name: "params", type: { defined: "SetOrderDeliveryParams" } }] }, { name: "oappQuote", accounts: [{ name: "oappConfig", isMut: false, isSigner: false }, { name: "peer", isMut: false, isSigner: false }, { name: "enforcedOptions", isMut: false, isSigner: false }, { name: "vaultAuthority", isMut: false, isSigner: false }], args: [{ name: "params", type: { defined: "DepositParams" } }], returns: { defined: "MessagingFee" } }, { name: "lzReceive", accounts: [{ name: "payer", isMut: true, isSigner: true }, { name: "peer", isMut: false, isSigner: false }, { name: "oappConfig", isMut: false, isSigner: false }, { name: "user", isMut: false, isSigner: false, docs: ["CHECK"] }, { name: "userDepositWallet", isMut: true, isSigner: false }, { name: "vaultAuthority", isMut: true, isSigner: false }, { name: "vaultDepositWallet", isMut: true, isSigner: false }, { name: "depositToken", isMut: false, isSigner: false }, { name: "tokenProgram", isMut: false, isSigner: false }, { name: "systemProgram", isMut: false, isSigner: false }, { name: "eventAuthority", isMut: false, isSigner: false }, { name: "program", isMut: false, isSigner: false }], args: [{ name: "params", type: { defined: "OAppLzReceiveParams" } }] }, { name: "lzReceiveTypes", accounts: [{ name: "oappConfig", isMut: false, isSigner: false }], args: [{ name: "params", type: { defined: "OAppLzReceiveParams" } }], returns: { vec: { defined: "oapp::endpoint_cpi::LzAccount" } } }, { name: "setRateLimit", accounts: [{ name: "admin", isMut: false, isSigner: true }, { name: "peer", isMut: true, isSigner: false }, { name: "oappConfig", isMut: false, isSigner: false }], args: [{ name: "params", type: { defined: "SetRateLimitParams" } }] }, { name: "setDelegate", accounts: [{ name: "admin", isMut: false, isSigner: true }, { name: "oappConfig", isMut: false, isSigner: false }], args: [{ name: "params", type: { defined: "SetDelegateParams" } }] }, { name: "transferAdmin", accounts: [{ name: "admin", isMut: false, isSigner: true }, { name: "oappConfig", isMut: true, isSigner: false }], args: [{ name: "params", type: { defined: "TransferAdminParams" } }] }, { name: "setPeer", accounts: [{ name: "admin", isMut: true, isSigner: true }, { name: "peer", isMut: true, isSigner: false }, { name: "oappConfig", isMut: false, isSigner: false }, { name: "systemProgram", isMut: false, isSigner: false }], args: [{ name: "params", type: { defined: "SetPeerParams" } }] }, { name: "setEnforcedOptions", accounts: [{ name: "admin", isMut: true, isSigner: true }, { name: "enforcedOptions", isMut: true, isSigner: false }, { name: "oappConfig", isMut: false, isSigner: false }, { name: "systemProgram", isMut: false, isSigner: false }], args: [{ name: "params", type: { defined: "SetEnforcedOptionsParams" } }] }], accounts: [{ name: "enforcedOptions", type: { kind: "struct", fields: [{ name: "send", type: "bytes" }, { name: "sendAndCall", type: "bytes" }, { name: "bump", type: "u8" }] } }, { name: "oAppConfig", type: { kind: "struct", fields: [{ name: "endpointProgram", type: "publicKey" }, { name: "bump", type: "u8" }, { name: "admin", type: "publicKey" }, { name: "usdcHash", type: { array: ["u8", 32] } }, { name: "usdcMint", type: "publicKey" }] } }, { name: "oAppLzReceiveTypesAccounts", type: { kind: "struct", fields: [{ name: "oappConfig", type: "publicKey" }] } }, { name: "peer", type: { kind: "struct", fields: [{ name: "address", type: { array: ["u8", 32] } }, { name: "rateLimiter", type: { option: { defined: "RateLimiter" } } }, { name: "bump", type: "u8" }] } }, { name: "allowedBroker", type: { kind: "struct", fields: [{ name: "brokerHash", type: { array: ["u8", 32] } }, { name: "allowed", type: "bool" }, { name: "bump", type: "u8" }] } }, { name: "allowedToken", type: { kind: "struct", fields: [{ name: "mintAccount", type: "publicKey" }, { name: "tokenHash", type: { array: ["u8", 32] } }, { name: "tokenDecimals", type: "u8" }, { name: "allowed", type: "bool" }, { name: "bump", type: "u8" }] } }, { name: "vaultAuthority", type: { kind: "struct", fields: [{ name: "bump", docs: ["Bump seed for the vault authority PDA"], type: "u8" }, { name: "owner", type: "publicKey" }, { name: "depositNonce", type: "u64" }, { name: "orderDelivery", type: "bool" }, { name: "inboundNonce", type: "u64" }, { name: "dstEid", type: "u32" }, { name: "solChainId", type: "u128" }] } }], types: [{ name: "VaultDepositParams", type: { kind: "struct", fields: [{ name: "accountId", type: { array: ["u8", 32] } }, { name: "brokerHash", type: { array: ["u8", 32] } }, { name: "userAddress", type: { array: ["u8", 32] } }, { name: "tokenHash", type: { array: ["u8", 32] } }, { name: "srcChainId", type: "u128" }, { name: "tokenAmount", type: "u128" }, { name: "srcChainDepositNonce", type: "u64" }] } }, { name: "LzMessage", type: { kind: "struct", fields: [{ name: "msgType", type: "u8" }, { name: "payload", type: "bytes" }] } }, { name: "InitOAppParams", type: { kind: "struct", fields: [{ name: "admin", type: "publicKey" }, { name: "endpointProgram", type: { option: "publicKey" } }, { name: "usdcHash", type: { array: ["u8", 32] } }, { name: "usdcMint", type: "publicKey" }] } }, { name: "OAppLzReceiveParams", type: { kind: "struct", fields: [{ name: "srcEid", type: "u32" }, { name: "sender", type: { array: ["u8", 32] } }, { name: "nonce", type: "u64" }, { name: "guid", type: { array: ["u8", 32] } }, { name: "message", type: "bytes" }, { name: "extraData", type: "bytes" }] } }, { name: "AccountWithdrawSol", type: { kind: "struct", fields: [{ name: "accountId", type: { array: ["u8", 32] } }, { name: "sender", type: { array: ["u8", 32] } }, { name: "receiver", type: { array: ["u8", 32] } }, { name: "brokerHash", type: { array: ["u8", 32] } }, { name: "tokenHash", type: { array: ["u8", 32] } }, { name: "tokenAmount", type: "u64" }, { name: "fee", type: "u64" }, { name: "chainId", type: "u64" }, { name: "withdrawNonce", type: "u64" }] } }, { name: "VaultWithdrawParams", type: { kind: "struct", fields: [{ name: "accountId", type: { array: ["u8", 32] } }, { name: "sender", type: { array: ["u8", 32] } }, { name: "receiver", type: { array: ["u8", 32] } }, { name: "brokerHash", type: { array: ["u8", 32] } }, { name: "tokenHash", type: { array: ["u8", 32] } }, { name: "tokenAmount", type: "u64" }, { name: "fee", type: "u128" }, { name: "chainId", type: "u128" }, { name: "withdrawNonce", type: "u64" }] } }, { name: "MessagingFee", type: { kind: "struct", fields: [{ name: "nativeFee", type: "u64" }, { name: "lzTokenFee", type: "u64" }] } }, { name: "ReinitOAppParams", type: { kind: "struct", fields: [{ name: "admin", type: "publicKey" }, { name: "endpointProgram", type: { option: "publicKey" } }, { name: "usdcHash", type: { array: ["u8", 32] } }, { name: "usdcMint", type: "publicKey" }] } }, { name: "SetDelegateParams", type: { kind: "struct", fields: [{ name: "delegate", type: "publicKey" }] } }, { name: "SetEnforcedOptionsParams", type: { kind: "struct", fields: [{ name: "dstEid", type: "u32" }, { name: "send", type: "bytes" }, { name: "sendAndCall", type: "bytes" }] } }, { name: "SetPeerParams", type: { kind: "struct", fields: [{ name: "dstEid", type: "u32" }, { name: "peer", type: { array: ["u8", 32] } }] } }, { name: "SetRateLimitParams", type: { kind: "struct", fields: [{ name: "dstEid", type: "u32" }, { name: "refillPerSecond", type: { option: "u64" } }, { name: "capacity", type: { option: "u64" } }, { name: "enabled", type: "bool" }] } }, { name: "TransferAdminParams", type: { kind: "struct", fields: [{ name: "admin", type: "publicKey" }] } }, { name: "DepositParams", type: { kind: "struct", fields: [{ name: "accountId", type: { array: ["u8", 32] } }, { name: "brokerHash", type: { array: ["u8", 32] } }, { name: "tokenHash", type: { array: ["u8", 32] } }, { name: "userAddress", type: { array: ["u8", 32] } }, { name: "tokenAmount", type: "u64" }] } }, { name: "OAppSendParams", type: { kind: "struct", fields: [{ name: "nativeFee", type: "u64" }, { name: "lzTokenFee", type: "u64" }] } }, { name: "InitVaultParams", type: { kind: "struct", fields: [{ name: "owner", type: "publicKey" }, { name: "orderDelivery", type: "bool" }, { name: "dstEid", type: "u32" }, { name: "solChainId", type: "u128" }] } }, { name: "ReinitVaultParams", type: { kind: "struct", fields: [{ name: "owner", type: "publicKey" }, { name: "dstEid", type: "u32" }, { name: "depositNonce", type: "u64" }, { name: "orderDelivery", type: "bool" }, { name: "inboundNonce", type: "u64" }, { name: "solChainId", type: "u128" }] } }, { name: "SetBrokerParams", type: { kind: "struct", fields: [{ name: "brokerHash", type: { array: ["u8", 32] } }, { name: "allowed", type: "bool" }] } }, { name: "SetOrderDeliveryParams", type: { kind: "struct", fields: [{ name: "orderDelivery", type: "bool" }, { name: "nonce", type: "u64" }] } }, { name: "SetTokenParams", type: { kind: "struct", fields: [{ name: "mintAccount", type: "publicKey" }, { name: "tokenHash", type: { array: ["u8", 32] } }, { name: "allowed", type: "bool" }] } }, { name: "RateLimiter", type: { kind: "struct", fields: [{ name: "capacity", type: "u64" }, { name: "tokens", type: "u64" }, { name: "refillPerSecond", type: "u64" }, { name: "lastRefillTime", type: "u64" }] } }, { name: "OAppError", type: { kind: "enum", variants: [{ name: "Unauthorized" }, { name: "InvalidSender" }, { name: "InvalidOptions" }, { name: "InvalidEndpointProgram" }, { name: "RateLimitExceeded" }, { name: "WithdrawFailed" }, { name: "InvalidInboundNonce" }] } }, { name: "MsgType", type: { kind: "enum", variants: [{ name: "Deposit" }, { name: "Withdraw" }, { name: "RebalanceBurn" }, { name: "RebalanceMint" }] } }], events: [{ name: "SetAllowedBroker", fields: [{ name: "brokerHash", type: { array: ["u8", 32] }, index: false }] }, { name: "ResetAllowedBroker", fields: [{ name: "brokerHash", type: { array: ["u8", 32] }, index: false }] }, { name: "SetAllowedToken", fields: [{ name: "tokenHash", type: { array: ["u8", 32] }, index: false }, { name: "mintAccount", type: "publicKey", index: false }] }, { name: "ResetAllowedToken", fields: [{ name: "tokenHash", type: { array: ["u8", 32] }, index: false }, { name: "mintAccount", type: "publicKey", index: false }] }, { name: "Deposited", fields: [{ name: "user", type: "publicKey", index: false }, { name: "amount", type: "u64", index: false }] }, { name: "Withdrawn", fields: [{ name: "user", type: "publicKey", index: false }, { name: "amount", type: "u64", index: false }] }, { name: "VaultDeposited", fields: [{ name: "accountId", type: { array: ["u8", 32] }, index: false }, { name: "brokerHash", type: { array: ["u8", 32] }, index: false }, { name: "userAddress", type: { array: ["u8", 32] }, index: false }, { name: "tokenHash", type: { array: ["u8", 32] }, index: false }, { name: "srcChainId", type: "u128", index: false }, { name: "tokenAmount", type: "u64", index: false }, { name: "srcChainDepositNonce", type: "u64", index: false }] }, { name: "VaultWithdrawn", fields: [{ name: "accountId", type: { array: ["u8", 32] }, index: false }, { name: "sender", type: { array: ["u8", 32] }, index: false }, { name: "receiver", type: { array: ["u8", 32] }, index: false }, { name: "brokerHash", type: { array: ["u8", 32] }, index: false }, { name: "tokenHash", type: { array: ["u8", 32] }, index: false }, { name: "tokenAmount", type: "u64", index: false }, { name: "fee", type: "u128", index: false }, { name: "chainId", type: "u128", index: false }, { name: "withdrawNonce", type: "u64", index: false }] }, { name: "OAppSent", fields: [{ name: "guid", type: { array: ["u8", 32] }, index: false }, { name: "dstEid", type: "u32", index: false }] }, { name: "OAppReceived", fields: [{ name: "guid", type: { array: ["u8", 32] }, index: false }, { name: "srcEid", type: "u32", index: false }] }], errors: [{ code: 6e3, name: "InsufficientFunds", msg: "Deposited funds are insufficient for withdrawal" }, { code: 6001, name: "UserInfoBelongsToAnotherUser", msg: "User info pda belongs to another user" }, { code: 6002, name: "BrokerNotAllowed", msg: "Broker is not allowed" }, { code: 6003, name: "TokenNotAllowed", msg: "Token is not allowed" }, { code: 6004, name: "InvalidAccountId", msg: "AccountId is invalid" }, { code: 6005, name: "InvalidVaultOwner", msg: "Vault owner is not the same as the payer" }] };
var y$1 = new PublicKey("76y77prsiCMvXMjuoZ5VRrhG5qYBrUMYTE5WgHqgjEn6"), f$3 = new PublicKey("7a4WjyR8VZ7yZz5XJAKm39BUGn5iT9CKcv2pmG9tdXVH"), O$7 = new PublicKey("6doghB248px58JSSwG4qejQ46kFMW4AMj7vzJnWZHNZn"), I$6 = new PublicKey("8ahPGPjEbpgGaZx2NV1iG5Shj7TDwvsjkEDcGWjt94TP"), Le$6 = f$3, Ne$4 = f$3, C$2 = new PublicKey("HtEYV4xB4wvsj5fgTkcfuChYpvGYzgzwvNhgDZQNh7wW"), He$6 = "VaultAuthority", We$7 = "Broker", Ue$6 = "Token", ue$9 = addressToBytes32("0x9Dc724b24146BeDD2dA28b8C4B74126169B8f312"), Ve$3 = addressToBytes32("0x45b6C6266A7A2170617d8A27A50C642fd68b91c4"), Ge$3 = addressToBytes32("0x5Bf771A65d057e778C5f0Ed52A0003316f94322D"), Fe$5 = addressToBytes32("0xCecAe061aa078e13b5e70D5F9eCee90a3F2B6AeA"), ze$6 = 40200, Ye$6 = 30213, G$6 = new PublicKey("BWp8HaYYhiNHekt3zgQhqoCrRftneGxxfgKmCZ6svHN"), Qe$4 = new PublicKey("BswrQQoPKAFojTuJutZcBMtigAgTghEH4M8ofn3EG2X2"), je$6 = new PublicKey("BbGKfxuPwDmu58BjPpd7PMG69TqnZjSpKaLDMgf9E9Dr"), Ze$4 = new PublicKey("8iq7xCQt3bLdRRn4A46d5GuaXYinBoiAhbe2sUmZVzwg"), me$5 = new PublicKey("EYJq9eU4GMRUriUJBgGoZ8YLQBXcWaciXuSsEXE7ieQS"), de$1 = new PublicKey("5zBjLor7vEraAt4zp2H82sy9MSqFoDnNa1Lx6EYKTYRZ"), le$7 = new PublicKey("9shwxWDUNhtwkHocsUAmrNAQfBH2DHh4njdAEdHZZkF2"), F$2 = new PublicKey("ErBmAD61mGFKvrFNaTJuxoPwqrS8GgtwtqJTJVjFWx9Q");
var K$4 = (n4, a2) => getAssociatedTokenAddressSync(n4, a2, true);
function ce$9(n4) {
  return PublicKey.findProgramAddressSync([dist.Buffer.from(He$6, "utf8")], n4)[0];
}
function $e$6(n4, a2) {
  let e3 = Array.from(dist.Buffer.from(a2.slice(2), "hex"));
  return PublicKey.findProgramAddressSync([dist.Buffer.from(We$7, "utf8"), dist.Buffer.from(e3)], n4)[0];
}
function en$1(n4, a2) {
  let e3 = Array.from(dist.Buffer.from(a2.slice(2), "hex"));
  return PublicKey.findProgramAddressSync([dist.Buffer.from(Ue$6, "utf8"), dist.Buffer.from(e3)], n4)[0];
}
function pe$4(n4) {
  return PublicKey.findProgramAddressSync([dist.Buffer.from(OAPP_SEED, "utf8")], n4)[0];
}
function fe$4(n4, a2, e3) {
  let s = dist.Buffer.alloc(4);
  return s.writeUInt32BE(e3), PublicKey.findProgramAddressSync([dist.Buffer.from(PEER_SEED, "utf8"), a2.toBuffer(), s], n4)[0];
}
function ye$8(n4, a2, e3) {
  let s = dist.Buffer.alloc(4);
  return s.writeUInt32BE(e3), PublicKey.findProgramAddressSync([dist.Buffer.from(ENFORCED_OPTIONS_SEED, "utf8"), a2.toBuffer(), s], n4)[0];
}
function nn$2() {
  return PublicKey.findProgramAddressSync([dist.Buffer.from(MESSAGE_LIB_SEED, "utf8")], f$3)[0];
}
function ge$4(n4, a2) {
  let e3 = dist.Buffer.alloc(4);
  return e3.writeUInt32BE(a2), PublicKey.findProgramAddressSync([dist.Buffer.from(SEND_LIBRARY_CONFIG_SEED, "utf8"), n4.toBuffer(), e3], y$1)[0];
}
function Se$6(n4) {
  let a2 = dist.Buffer.alloc(4);
  return a2.writeUInt32BE(n4), PublicKey.findProgramAddressSync([dist.Buffer.from(SEND_LIBRARY_CONFIG_SEED, "utf8"), a2], y$1)[0];
}
function an(n4) {
  return PublicKey.findProgramAddressSync([dist.Buffer.from(MESSAGE_LIB_SEED, "utf8"), n4.toBuffer()], y$1)[0];
}
function be$6() {
  return PublicKey.findProgramAddressSync([dist.Buffer.from(ENDPOINT_SEED, "utf8")], y$1)[0];
}
function Vn$2(n4) {
  let a2 = ue$9;
  return n4.toBase58() === me$5.toBase58() && (a2 = ue$9), n4.toBase58() === de$1.toBase58() && (a2 = Ve$3), n4.toBase58() === le$7.toBase58() && (a2 = Ge$3), n4.toBase58() === F$2.toBase58() && (a2 = Fe$5), a2;
}
function Ae$2(n4, a2, e3) {
  let s = dist.Buffer.alloc(4), i = Vn$2(n4);
  return s.writeUInt32BE(e3), PublicKey.findProgramAddressSync([dist.Buffer.from(NONCE_SEED, "utf8"), a2.toBuffer(), s, i], y$1)[0];
}
function tn$1() {
  return PublicKey.findProgramAddressSync([dist.Buffer.from(EVENT_SEED, "utf8")], y$1)[0];
}
function sn() {
  return PublicKey.findProgramAddressSync([dist.Buffer.from(ULN_SEED, "utf8")], f$3)[0];
}
function Pe$6(n4, a2) {
  let e3 = dist.Buffer.alloc(4);
  return e3.writeUInt32BE(a2), PublicKey.findProgramAddressSync([dist.Buffer.from(SEND_CONFIG_SEED, "utf8"), e3, n4.toBuffer()], f$3)[0];
}
function ke$3(n4) {
  let a2 = dist.Buffer.alloc(4);
  return a2.writeUInt32BE(n4), PublicKey.findProgramAddressSync([dist.Buffer.from(SEND_CONFIG_SEED, "utf8"), a2], Le$6)[0];
}
function rn$1() {
  return PublicKey.findProgramAddressSync([dist.Buffer.from(EVENT_SEED, "utf8")], f$3)[0];
}
function he$6() {
  return PublicKey.findProgramAddressSync([dist.Buffer.from(EXECUTOR_CONFIG_SEED, "utf8")], O$7)[0];
}
function De$3() {
  return PublicKey.findProgramAddressSync([dist.Buffer.from(PRICE_FEED_SEED, "utf8")], I$6)[0];
}
function Ee$6() {
  return PublicKey.findProgramAddressSync([dist.Buffer.from(DVN_CONFIG_SEED, "utf8")], C$2)[0];
}
function Me$6(n4) {
  return n4.toBase58() === F$2.toBase58() ? Ye$6 : ze$6;
}
function Ie$3(n4) {
  return n4.toBase58() === me$5.toBase58() ? (console.log("DEV_LOOKUP_TABLE_ADDRESS: ", G$6.toBase58()), G$6) : n4.toBase58() === de$1.toBase58() ? Qe$4 : n4.toBase58() === le$7.toBase58() ? je$6 : n4.toBase58() === F$2.toBase58() ? Ze$4 : G$6;
}
function on$2(n4) {
  return PublicKey.findProgramAddressSync([dist.Buffer.from(MESSAGE_LIB_SEED, "utf8")], n4 || f$3)[0];
}
function un$2(n4, a2) {
  return PublicKey.findProgramAddressSync([dist.Buffer.from(MESSAGE_LIB_SEED, "utf8"), n4.toBytes()], y$1)[0];
}
function we$6(n4, a2) {
  return l(this, null, function* () {
    return (yield n4.getAddressLookupTable(a2)).value;
  });
}
function cn$1(n4) {
  let { publicKey: a2, brokerId: e3, expiration: s = 365, timestamp: i = Date.now(), scope: t, tag: o, chainId: m2 } = n4, r3 = S$3(g$4({ brokerId: e3, chainType: "SOL", orderlyKey: a2, scope: t || "read,trading", chainId: m2, timestamp: i }, typeof o != "undefined" ? { tag: o } : {}), { expiration: i + 1e3 * 60 * 60 * 24 * s }), u2 = solidityPackedKeccak256(["string"], [r3.brokerId]), c2 = solidityPackedKeccak256(["string"], [r3.orderlyKey]), b2 = solidityPackedKeccak256(["string"], [r3.scope]), D2 = AbiCoder.defaultAbiCoder(), k2 = keccak256$1(hexToBytes(D2.encode(["bytes32", "bytes32", "bytes32", "uint256", "uint256", "uint256"], [u2, c2, b2, r3.chainId, r3.timestamp, r3.expiration]))), E3 = bytesToHex(k2), M2 = new TextEncoder().encode(E3);
  return [r3, M2];
}
function pn$1(n4) {
  let { chainId: a2, registrationNonce: e3, brokerId: s, timestamp: i } = n4, t = { brokerId: s, chainId: a2, timestamp: i, registrationNonce: e3 }, o = solidityPackedKeccak256(["string"], [t.brokerId]), m2 = AbiCoder.defaultAbiCoder(), r3 = keccak256$1(hexToBytes(m2.encode(["bytes32", "uint256", "uint256", "uint256"], [o, t.chainId, t.timestamp, t.registrationNonce]))), u2 = bytesToHex(r3), c2 = new TextEncoder().encode(u2);
  return [t, c2];
}
function fn$2(n4) {
  let { chainId: a2, receiver: e3, token: s, amount: i, nonce: t, brokerId: o } = n4, m2 = Date.now(), r3 = { brokerId: o, chainId: a2, receiver: e3, token: s, amount: i, withdrawNonce: t, timestamp: m2, chainType: "SOL" }, u2 = solidityPackedKeccak256(["string"], [r3.brokerId]), c2 = solidityPackedKeccak256(["string"], [r3.token]), b2 = keccak256$1(dist.Buffer.from("Orderly Network")), D2 = AbiCoder.defaultAbiCoder(), k2 = keccak256$1(hexToBytes(D2.encode(["bytes32", "bytes32", "uint256", "bytes32", "uint256", "uint64", "uint64", "bytes32"], [u2, c2, a2, Gn$2(r3.receiver), r3.amount, r3.withdrawNonce, m2, b2]))), E3 = bytesToHex(k2), M2 = new TextEncoder().encode(E3);
  return [r3, M2];
}
function yn$2(n4) {
  let { settlePnlNonce: a2, brokerId: e3, chainId: s, timestamp: i } = n4, t = { brokerId: e3, chainId: s, timestamp: i, chainType: "SOL", settleNonce: a2 }, o = solidityPackedKeccak256(["string"], [e3]), m2 = AbiCoder.defaultAbiCoder(), r3 = keccak256$1(hexToBytes(m2.encode(["bytes32", "uint256", "uint64", "uint64"], [o, t.chainId, t.settleNonce, t.timestamp]))), u2 = bytesToHex(r3), c2 = new TextEncoder().encode(u2);
  return [t, c2];
}
function Te$3(i) {
  return l(this, arguments, function* ({ vaultAddress: n4, userAddress: a2, connection: e3, depositData: s }) {
    console.log("-- vaultAddress", n4);
    let t = new PublicKey(n4), o = Me$6(t), m2 = new ln$3(oe$5, t, { connection: e3 }), r3 = new PublicKey(a2), u2 = pe$4(t), c2 = fe$4(t, u2, o), b2 = ye$8(t, u2, o), D2 = ge$4(u2, o), k2 = Se$6(o), E3 = be$6(), M2 = Ae$2(t, u2, o), Z3 = Pe$6(u2, o), A2 = ke$3(o), P2 = he$6(), N2 = De$3(), q2 = Ee$6(), H2 = on$2(f$3), X2 = un$2(H2), J2 = ce$9(t), $2 = gn$2(a2, s), ee2 = yield m2.methods.oappQuote($2).accounts({ oappConfig: u2, peer: c2, enforcedOptions: b2, vaultAuthority: J2 }).remainingAccounts([{ pubkey: y$1, isWritable: false, isSigner: false }, { pubkey: f$3, isWritable: false, isSigner: false }, { pubkey: D2, isWritable: false, isSigner: false }, { pubkey: k2, isWritable: false, isSigner: false }, { pubkey: X2, isWritable: false, isSigner: false }, { pubkey: E3, isWritable: false, isSigner: false }, { pubkey: M2, isWritable: false, isSigner: false }, { pubkey: H2, isWritable: false, isSigner: false }, { pubkey: Z3, isWritable: false, isSigner: false }, { pubkey: A2, isWritable: false, isSigner: false }, { pubkey: O$7, isWritable: false, isSigner: false }, { pubkey: P2, isWritable: false, isSigner: false }, { pubkey: I$6, isWritable: false, isSigner: false }, { pubkey: N2, isWritable: false, isSigner: false }, { pubkey: C$2, isWritable: false, isSigner: false }, { pubkey: q2, isWritable: false, isSigner: false }, { pubkey: I$6, isWritable: false, isSigner: false }, { pubkey: N2, isWritable: false, isSigner: false }]).instruction(), ne2 = yield e3.getLatestBlockhash(), ae3 = Ie$3(t), W2 = yield we$6(e3, ae3);
    if (!W2) throw console.log("-- lookup table account error"), new Error("-- lookup table account error");
    let te2 = new TransactionMessage({ payerKey: r3, recentBlockhash: ne2.blockhash, instructions: [ee2] }).compileToV0Message([W2]), se2 = new VersionedTransaction(te2), h2 = yield e3.simulateTransaction(se2);
    if (console.log("-- feeRes", h2), h2.value.err) {
      let x2 = typeof h2.value.err == "object" ? JSON.stringify(h2.value.err) : h2.value.err;
      throw x2.toString().includes("AccountNotFound") ? new Error("Error: Account gas is insufficient.") : new Error(`Error: ${x2}`);
    }
    let U3 = `Program return: ${m2.programId} `, R2 = h2.value.logs.find((x2) => x2.startsWith(U3));
    if (!R2) throw new Error("Error: get deposit fee error");
    let re2 = R2.slice(U3.length), T2 = dist.Buffer.from(re2, "base64");
    return console.log(T2.readBigUInt64LE(0), T2.readBigUInt64LE(1)), T2.readBigUInt64LE(0);
  });
}
var gn$2 = (n4, a2) => {
  let e3 = a2.brokerHash, s = Array.from(dist.Buffer.from(e3.slice(2), "hex")), i = a2.tokenHash, t = Array.from(dist.Buffer.from(i.slice(2), "hex")), o = a2.accountId, m2 = Array.from(dist.Buffer.from(o.slice(2), "hex")), r3 = new PublicKey(n4);
  return { accountId: m2, brokerHash: s, tokenHash: t, userAddress: Array.from(r3.toBuffer()), tokenAmount: new _e$6(a2.tokenAmount) };
};
function Sn$2(t) {
  return l(this, arguments, function* ({ vaultAddress: n4, userAddress: a2, connection: e3, sendTransaction: s, depositData: i }) {
    let o = i.brokerHash, m2 = i.tokenHash;
    console.log("-- vault address", n4);
    let r3 = new PublicKey(n4), u2 = new ln$3(oe$5, r3, { connection: e3 }), c2 = new PublicKey(i.USDCAddress), b2 = new PublicKey(a2), D2 = K$4(c2, b2), k2 = ce$9(r3), E3 = K$4(c2, k2), M2 = $e$6(r3, o), Z3 = en$1(r3, m2), A2 = pe$4(r3);
    console.log("-- oappconfig pda", A2.toBase58());
    let P2 = Me$6(r3), N2 = fe$4(r3, A2, P2), q2 = ye$8(r3, A2, P2), H2 = nn$2(), X2 = ge$4(A2, P2), J2 = Se$6(P2), $2 = an(H2), ee2 = be$6(), ne2 = Ae$2(r3, A2, P2), ae3 = tn$1(), W2 = sn(), te2 = Pe$6(A2, P2), se2 = ke$3(P2), h2 = rn$1(), U3 = he$6(), R2 = De$3(), re2 = Ee$6(), T2 = gn$2(a2, i), x2 = yield Te$3({ vaultAddress: n4, userAddress: a2, connection: e3, depositData: i }), Re2 = { nativeFee: new _e$6(x2.toString()), lzTokenFee: new _e$6(0) };
    console.log("--- value params", { vaultDepositParams: T2, sendParam: Re2 });
    let Pn2 = yield u2.methods.deposit(T2, Re2).accounts({ userTokenAccount: D2, vaultAuthority: k2, vaultTokenAccount: E3, depositToken: c2, user: b2, peer: N2, enforcedOptions: q2, oappConfig: A2, allowedBroker: M2, allowedToken: Z3 }).remainingAccounts([{ isSigner: false, isWritable: false, pubkey: y$1 }, { isSigner: false, isWritable: false, pubkey: A2 }, { isSigner: false, isWritable: false, pubkey: f$3 }, { isSigner: false, isWritable: false, pubkey: X2 }, { isSigner: false, isWritable: false, pubkey: J2 }, { isSigner: false, isWritable: false, pubkey: $2 }, { isSigner: false, isWritable: false, pubkey: ee2 }, { isSigner: false, isWritable: true, pubkey: ne2 }, { isSigner: false, isWritable: false, pubkey: ae3 }, { isSigner: false, isWritable: false, pubkey: y$1 }, { isSigner: false, isWritable: false, pubkey: W2 }, { isSigner: false, isWritable: false, pubkey: te2 }, { isSigner: false, isWritable: false, pubkey: se2 }, { isSigner: true, isWritable: false, pubkey: b2 }, { isSigner: false, isWritable: false, pubkey: Ne$4 }, { isSigner: false, isWritable: false, pubkey: SystemProgram.programId }, { isSigner: false, isWritable: false, pubkey: h2 }, { isSigner: false, isWritable: false, pubkey: f$3 }, { isSigner: false, isWritable: false, pubkey: O$7 }, { isSigner: false, isWritable: true, pubkey: U3 }, { isSigner: false, isWritable: false, pubkey: I$6 }, { isSigner: false, isWritable: false, pubkey: R2 }, { isSigner: false, isWritable: false, pubkey: C$2 }, { isSigner: false, isWritable: true, pubkey: re2 }, { isSigner: false, isWritable: false, pubkey: I$6 }, { isSigner: false, isWritable: false, pubkey: R2 }]).instruction(), kn2 = Ie$3(r3), Oe2 = yield we$6(e3, kn2);
    if (!Oe2) {
      console.log("-- lookup table account error");
      return;
    }
    let hn2 = ComputeBudgetProgram.setComputeUnitLimit({ units: 4e5 }), Dn2 = yield e3.getLatestBlockhash(), En2 = new TransactionMessage({ payerKey: b2, recentBlockhash: Dn2.blockhash, instructions: [Pn2, hn2] }).compileToV0Message([Oe2]), Mn2 = new VersionedTransaction(En2), Ce2 = yield s(Mn2, e3);
    return console.log("res", Ce2), Ce2;
  });
}
function bn$2(n4) {
  let a2 = window.localStorage.getItem(LedgerWalletKey);
  if (!a2) return false;
  let e3 = JSON.parse(a2 != null ? a2 : "[]");
  return console.log("-- addressArr", e3), !!e3.includes(n4);
}
var ve$5 = class ve2 extends At$3 {
  constructor() {
    super();
    B$6(this, "chainNamespace", ChainNamespace.solana);
    B$6(this, "_address");
    B$6(this, "_chainId");
    B$6(this, "_provider");
    B$6(this, "_connection");
  }
  get address() {
    return this._address;
  }
  get chainId() {
    return this._chainId;
  }
  set chainId(e3) {
    this._chainId = e3;
  }
  get connection() {
    if (this._connection) return this._connection;
    if (this._provider.rpcUrl) return this._connection = new Connection(this._provider.rpcUrl, { commitment: "confirmed" }), this._connection;
    if (this._provider.network === WalletAdapterNetwork.Devnet) return this._connection = new Connection(clusterApiUrl(this._provider.network), { commitment: "confirmed" }), this._connection;
    let e3 = qr$2.get("account"), s = "/v1/solana-rpc-proxy";
    return this._connection = new Connection(`${e3.apiBaseUrl}${s}`, { commitment: "confirmed", fetchMiddleware: (i, t, o) => l(this, null, function* () {
      let m2 = { url: s, method: t == null ? void 0 : t.method, data: JSON.parse(t == null ? void 0 : t.body) }, r3 = yield this.signMessageByOrderlyKey(m2);
      for (let u2 of Object.keys(r3)) (t == null ? void 0 : t.headers)[u2] = r3[u2];
      return o(i, t);
    }) }), this._connection;
  }
  setConfig(e3) {
    this._address = e3.address, this._chainId = e3.chain.id, e3.provider && (this._provider = e3.provider);
  }
  lifecycleName(e3, s) {
    console.log("lifecycle", e3, s);
  }
  active(e3) {
    this.setConfig(e3), this.lifecycleName("active", e3);
  }
  deactivate() {
    this.lifecycleName("deactivate", {});
  }
  update(e3) {
    this.lifecycleName("update", e3), this.setConfig(e3);
  }
  generateSecretKey() {
    let e3, s;
    do
      e3 = P$3.utils.randomPrivateKey(), s = Xn$3(e3);
    while (s.length !== 44);
    return s;
  }
  uint8ArrayToHexString(e3) {
    return Array.from(e3).map((s) => s.toString(16).padStart(2, "0")).join("");
  }
  signMessage(e3) {
    return l(this, null, function* () {
      if (bn$2(this._address)) {
        let t = new Transaction$1();
        t.add(new TransactionInstruction({ keys: [], programId: new PublicKey("ComputeBudget111111111111111111111111111111"), data: new Uint8Array([3, 0, 0, 0, 0, 0, 0, 0, 0]) })), t.add(new TransactionInstruction({ keys: [], programId: new PublicKey("ComputeBudget111111111111111111111111111111"), data: new Uint8Array([2, 0, 0, 0, 0]) })), t.add(new TransactionInstruction({ keys: [], programId: new PublicKey("MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr"), data: e3 }));
        let o = new PublicKey(this.address);
        t.feePayer = o;
        let m2 = new Uint8Array(32).fill(0);
        t.recentBlockhash = new PublicKey(m2).toString();
        let u2 = (yield this._provider.signTransaction(t)).signatures[0].signature;
        if (u2) return this.uint8ArrayToHexString(u2);
        throw console.log("-- sign message error", u2), new Error("Unsupported signature");
      }
      let i = yield this._provider.signMessage(e3);
      return "0x" + bytesToHex(i);
    });
  }
  generateRegisterAccountMessage(e3) {
    return l(this, null, function* () {
      let [s, i] = pn$1(S$3(g$4({}, e3), { chainId: this.chainId })), t = yield this.signMessage(i);
      return { message: S$3(g$4({}, s), { chainType: "SOL" }), signatured: t };
    });
  }
  generateWithdrawMessage(e3) {
    return l(this, null, function* () {
      let [s, i] = fn$2(S$3(g$4({}, e3), { chainId: this.chainId })), t = yield this.signMessage(i);
      return { message: S$3(g$4({}, s), { chainType: "SOL" }), domain: { name: "", version: "", chainId: this.chainId, verifyingContract: e3.verifyContract }, signatured: t };
    });
  }
  generateAddOrderlyKeyMessage(e3) {
    return l(this, null, function* () {
      let [s, i] = cn$1(S$3(g$4({}, e3), { chainId: this.chainId })), t = yield this.signMessage(i);
      return { message: S$3(g$4({}, s), { chainType: "SOL" }), signatured: t };
    });
  }
  generateSettleMessage(e3) {
    return l(this, null, function* () {
      let [s, i] = yn$2(S$3(g$4({}, e3), { chainId: this.chainId })), t = yield this.signMessage(i);
      return { message: S$3(g$4({}, s), { chainType: "SOL" }), domain: { name: "", version: "", chainId: this.chainId, verifyingContract: e3.verifyContract }, signatured: t };
    });
  }
  getBalance() {
    return l(this, null, function* () {
      return BigInt(0);
    });
  }
  call(e3, s, i, t) {
    return l(this, null, function* () {
      if (s === "balanceOf") {
        let o = new PublicKey(e3), m2 = new PublicKey(this._address), r3 = K$4(o, m2), u2 = this.connection;
        return (yield getAccount(u2, r3, "confirmed")).amount;
      }
      return s === "allowance" ? MaxUint256 : BigInt(0);
    });
  }
  sendTransaction(e3, s, i, t) {
    return l(this, null, function* () {
      if (console.log("-- solanan sendTransaction", { contractAddress: e3, method: s, payload: i, options: t }), s === "deposit") return Sn$2({ vaultAddress: e3, userAddress: this._address, connection: this.connection, depositData: i.data[0], sendTransaction: this._provider.sendTransaction });
    });
  }
  callOnChain(e3, s, i, t, o) {
    return l(this, null, function* () {
      return console.log("-- params ", { chain: e3, address: s, method: i, params: t }), i === "getDepositFee" ? Te$3({ vaultAddress: s, userAddress: this._address, connection: this.connection, depositData: t[1] }) : 0;
    });
  }
  pollTransactionReceiptWithBackoff(e3, s, i, t) {
    return l(this, null, function* () {
      return Promise.resolve({ status: 1 });
    });
  }
};
var u$2 = Object.defineProperty;
var P$2 = (a2, r3, t) => r3 in a2 ? u$2(a2, r3, { enumerable: true, configurable: true, writable: true, value: t }) : a2[r3] = t;
var v$2 = (a2, r3, t) => (P$2(a2, r3 + "", t), t);
var p$1 = (a2, r3, t) => new Promise((e3, s) => {
  var i = (o) => {
    try {
      n4(t.next(o));
    } catch (d2) {
      s(d2);
    }
  }, c2 = (o) => {
    try {
      n4(t.throw(o));
    } catch (d2) {
      s(d2);
    }
  }, n4 = (o) => o.done ? e3(o.value) : Promise.resolve(o.value).then(i, c2);
  n4((t = t.apply(a2, r3)).next());
});
var w$2 = class w2 {
  constructor() {
    v$2(this, "_provider");
  }
  parseUnits(r3, t) {
    return parseUnits$1(r3, t).toString();
  }
  formatUnits(r3, t) {
    return formatUnits(r3, t);
  }
  set provider(r3) {
    this._provider = new BrowserProvider(r3, "any");
  }
  get browserProvider() {
    if (!this._provider) throw new Error("browserProvider is not initialized");
    return this._provider;
  }
  signTypedData(r3, t) {
    return p$1(this, null, function* () {
      var e3;
      return yield (e3 = this.browserProvider) == null ? void 0 : e3.send("eth_signTypedData_v4", [r3, t]);
    });
  }
  call(r3, t, e3, s) {
    return p$1(this, null, function* () {
      let i = yield this.browserProvider.getSigner();
      return new Contract(r3, s.abi, i)[t].apply(null, e3).catch((n4) => {
        throw getParsedEthersError(n4);
      });
    });
  }
  send(r3, t) {
    return this.browserProvider.send(r3, t);
  }
  sendTransaction(r3, t, e3, s) {
    return p$1(this, null, function* () {
      var d2;
      let i = yield (d2 = this.browserProvider) == null ? void 0 : d2.getSigner();
      if (!i) throw new Error("singer is not exist");
      let n4 = new Contract(r3, s.abi, this.browserProvider).interface.encodeFunctionData(t, e3.data), o = { from: e3.from, to: e3.to, data: n4, value: e3.value };
      try {
        return yield i.sendTransaction(o);
      } catch (m2) {
        throw getParsedEthersError(m2);
      }
    });
  }
  pollTransactionReceiptWithBackoff(r3, t = 1e3, e3 = 6e3, s = 30) {
    return p$1(this, null, function* () {
      let i = t, c2 = 0;
      for (; c2 < s; ) {
        try {
          let n4 = yield this.browserProvider.getTransactionReceipt(r3);
          if (n4) return n4;
        } catch (n4) {
        }
        yield new Promise((n4) => setTimeout(n4, i)), i = Math.min(i * 2, e3), c2++;
      }
      throw new Error("Transaction did not complete after maximum retries.");
    });
  }
  callOnChain(r3, t, e3, s, i) {
    let c2 = new JsonRpcProvider(r3.public_rpc_url);
    return new Contract(t, i.abi, c2)[e3].apply(null, s).catch((o) => {
      throw getParsedEthersError(o);
    });
  }
  getBalance(r3) {
    return this.browserProvider.getBalance(r3).then((t) => t);
  }
};
const { debounce } = ((_k = (_j = __cjsInterop1__$2) == null ? void 0 : _j.default) == null ? void 0 : _k.__esModule) ? __cjsInterop1__$2.default : __cjsInterop1__$2;
var __defProp2 = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp2(target, name, { get: all[name], enumerable: true });
};
if (typeof window !== "undefined") {
  window.__ORDERLY_VERSION__ = window.__ORDERLY_VERSION__ || {};
  window.__ORDERLY_VERSION__["@orderly.network/hooks"] = "2.1.0";
}
var version_default = "2.1.0";
var fetcher = (url, init2 = {}, queryOptions) => get(url, init2, queryOptions == null ? void 0 : queryOptions.formatter);
var OrderlyContext = createContext({
  // configStore: new MemoryConfigStore(),
});
var OrderlyProvider = OrderlyContext.Provider;
function useConfig(key, defaultValue) {
  const { configStore } = useContext(OrderlyContext);
  if (!configStore) {
    throw new SDKError(
      "useConfig must be used within OrderlyConfigProvider or OrderlyAppProvider"
    );
  }
  if (typeof key !== "undefined") {
    return configStore.get(key);
  }
  return configStore;
}
var useQuery = (query, options) => {
  const apiBaseUrl = useConfig("apiBaseUrl");
  const { formatter, ...swrOptions } = options || {};
  if (typeof apiBaseUrl === "undefined") {
    throw new SDKError("please add OrderlyConfigProvider to your app");
  }
  return useSWR(
    query,
    (url, init2) => fetcher(url.startsWith("http") ? url : `${apiBaseUrl}${url}`, init2, {
      formatter
    }),
    swrOptions
  );
};
var useLazyQuery = (query, options) => {
  const apiBaseUrl = useConfig("apiBaseUrl");
  const { formatter, init: init2, ...swrOptions } = {};
  if (typeof apiBaseUrl === "undefined") {
    throw new SDKError("please add OrderlyConfigProvider to your app");
  }
  return useSWRMutation(
    query,
    (url, options2) => {
      url = url.startsWith("http") ? url : `${apiBaseUrl}${url}`;
      if (options2 == null ? void 0 : options2.arg) {
        const queryString = Object.entries(options2.arg).map(
          ([key, value]) => `${key}=${encodeURIComponent(value)}`
        ).join("&");
        url = `${url}?${queryString}`;
      }
      return fetcher(url, init2, {
        formatter
      });
    },
    swrOptions
  );
};
var useAccountInstance = () => {
  const { configStore, keyStore, walletAdapters } = useContext(OrderlyContext);
  if (!configStore)
    throw new SDKError(
      "configStore is not defined, please use OrderlyProvider"
    );
  if (!keyStore) {
    throw new SDKError(
      "keyStore is not defined, please use OrderlyProvider and provide keyStore"
    );
  }
  const account5 = useConstant(() => {
    let account6 = qr$2.get("account");
    if (!account6) {
      account6 = new Le$7(
        configStore,
        keyStore,
        // getWalletAdapter,
        walletAdapters
      );
      qr$2.registerByName("account", account6);
    }
    return account6;
  });
  return account5;
};
var fetcher2 = (url, options) => {
  const init2 = {
    method: options.arg.method,
    headers: {
      ...options.arg.signature
    }
  };
  if (options.arg.data) {
    init2.body = JSON.stringify(options.arg.data);
  }
  if (typeof options.arg.params === "object" && Object.keys(options.arg.params).length) {
    let search = new URLSearchParams(options.arg.params);
    url = `${url}?${search.toString()}`;
  }
  return mutate(url, init2);
};
var useMutation = (url, method = "POST", options) => {
  const apiBaseUrl = useConfig("apiBaseUrl");
  let fullUrl = url;
  if (!url.startsWith("http")) {
    fullUrl = `${apiBaseUrl}${url}`;
  }
  const account5 = useAccountInstance();
  const { trigger, data, error, reset, isMutating } = useSWRMutation(
    fullUrl,
    // method === "POST" ? fetcher : deleteFetcher,
    fetcher2,
    options
  );
  const mutation = async (data2, params, options2) => {
    let newUrl = url;
    if (typeof params === "object" && Object.keys(params).length) {
      let search = new URLSearchParams(params);
      newUrl = `${url}?${search.toString()}`;
    }
    const payload = {
      method,
      url: newUrl,
      data: data2
    };
    const signer = account5.signer;
    const signature = await signer.sign(payload, N$3());
    return trigger(
      {
        data: data2,
        params,
        method,
        signature: {
          ...signature,
          "orderly-account-id": account5.accountId
        }
      },
      options2
    );
  };
  return [
    mutation,
    {
      data,
      error,
      reset,
      isMutating
    }
  ];
};
var signatureMiddleware = (useSWRNext) => {
  const apiBaseUrl = useConfig("apiBaseUrl");
  return (key, fetcher3, config2) => {
    try {
      const extendedFetcher = async (args) => {
        let url = Array.isArray(args) ? args[0] : args;
        let account5 = qr$2.get("account");
        let fullUrl = `${apiBaseUrl}${url}`;
        const signer = account5.signer;
        const payload = {
          method: "GET",
          url
        };
        const signature = await signer.sign(payload, N$3());
        return fetcher3(fullUrl, {
          headers: {
            ...signature,
            "orderly-account-id": account5.accountId
          }
        });
      };
      return useSWRNext(key, extendedFetcher, config2);
    } catch (e3) {
      throw e3;
    }
  };
};
var useEventEmitter = () => {
  return useConstant(() => {
    let ee2 = qr$2.get("EE");
    if (!ee2) {
      ee2 = new Jr$5();
      qr$2.registerByName("EE", ee2);
    }
    return ee2;
  });
};
var useTrack = () => {
  const ee2 = useEventEmitter();
  const debouncedTrackFn = useCallback(
    debounce((eventName, params) => {
      ee2.emit(eventName, params);
    }, 500),
    []
  );
  const track2 = useCallback((eventName, params) => {
    debouncedTrackFn(eventName, params);
  }, [debouncedTrackFn]);
  const setTrackUserId = useCallback((userId) => {
    ee2.emit(EnumTrackerKeys.trackIdentifyUserId, userId);
  }, []);
  return { track: track2, setTrackUserId };
};
var useAccount = () => {
  const {
    configStore,
    keyStore
    // onWalletConnect,
    // onWalletDisconnect,
    // onSetChain,
  } = useContext(OrderlyContext);
  if (!configStore)
    throw new SDKError(
      "configStore is not defined, please use OrderlyProvider"
    );
  if (!keyStore) {
    throw new SDKError(
      "keyStore is not defined, please use OrderlyProvider and provide keyStore"
    );
  }
  const account5 = useAccountInstance();
  const [state, setState] = useState(account5.stateValue);
  const { track: track2 } = useTrack();
  const statusChangeHandler = (nextState) => {
    setState(() => nextState);
  };
  useEffect(() => {
    account5.on("change:status", statusChangeHandler);
    return () => {
      account5.off("change:status", statusChangeHandler);
    };
  }, []);
  const createOrderlyKey = useCallback(
    async (remember) => {
      var _a2;
      track2(EnumTrackerKeys.signinSuccess, {
        network: account5.chainId,
        wallet: (_a2 = state.connectWallet) == null ? void 0 : _a2.name
      });
      return account5.createOrderlyKey(remember ? 365 : 30);
    },
    [account5, state]
  );
  const createAccount = useCallback(async () => {
    return account5.createAccount();
  }, [account5]);
  return {
    account: account5,
    state,
    // info: {},
    // login,
    createOrderlyKey,
    createAccount
    // disconnect,
    // connect,
    // setChain,
    // settlement,
  };
};
var usePrivateQuery = (query, options) => {
  const { formatter, ...swrOptions } = options || {};
  const { state } = useAccount();
  const middleware = Array.isArray(options == null ? void 0 : options.use) ? (options == null ? void 0 : options.use) ?? [] : [];
  return useSWR(
    () => state.status >= AccountStatusEnum.EnableTrading || state.status === AccountStatusEnum.EnableTradingWithoutConnected ? [query, state.accountId] : null,
    (url, init2) => {
      return fetcher(url, init2, { formatter });
    },
    {
      ...swrOptions,
      use: [signatureMiddleware, ...middleware],
      onError: (err) => {
      }
    }
  );
};
var usePrivateInfiniteQuery = (getKey, options) => {
  const { formatter, ...restOptions } = options || {};
  const { state } = useAccount();
  const middleware = Array.isArray(restOptions == null ? void 0 : restOptions.use) ? (restOptions == null ? void 0 : restOptions.use) ?? [] : [];
  const result = useSWRInfinite(
    (pageIndex, previousPageData) => {
      const queryKey = getKey(pageIndex, previousPageData);
      if (queryKey && (state.status >= AccountStatusEnum.EnableTrading || state.status === AccountStatusEnum.EnableTradingWithoutConnected)) {
        return [queryKey, state.accountId];
      }
      return null;
    },
    (url, init2) => {
      var _a2;
      return ((_a2 = restOptions.fetcher) == null ? void 0 : _a2.call(restOptions, url, init2)) || get(url, init2, formatter);
    },
    {
      ...restOptions,
      use: [signatureMiddleware, ...middleware]
    }
  );
  return result;
};
var usePreLoadData = () => {
  const [timestampOffsetInitialized, setTimestampOffsetInitialized] = useState(false);
  const { error: tokenError, data: tokenData } = useQuery(
    "https://api.orderly.org/v1/public/token",
    {
      revalidateOnFocus: false
    }
  );
  const apiBaseUrl = useConfig("apiBaseUrl");
  const { data: systemInfo } = useSWR(
    "/v1/public/system_info",
    async (url, init2) => {
      const data = await fetch(
        url.startsWith("http") ? url : `${apiBaseUrl}${url}`,
        init2
      );
      return await data.json();
    },
    {
      errorRetryCount: 3,
      errorRetryInterval: 500
    }
  );
  useEffect(() => {
    if (timestampOffsetInitialized)
      return;
    if (typeof systemInfo !== "undefined") {
      const sd = systemInfo.timestamp;
      const ld2 = Date.now();
      const diff = sd - ld2;
      if (isNaN(diff)) {
        return;
      }
      l$1().__ORDERLY_timestamp_offset = diff;
      setTimestampOffsetInitialized(true);
    }
  }, [systemInfo, timestampOffsetInitialized]);
  const isDone = useMemo(() => {
    return !!tokenData && timestampOffsetInitialized;
  }, [timestampOffsetInitialized, tokenData]);
  return {
    error: tokenError,
    done: isDone
  };
};
function parseJSON(value) {
  try {
    return value === "undefined" ? void 0 : JSON.parse(value ?? "");
  } catch {
    return void 0;
  }
}
function useSessionStorage(key, initialValue) {
  const readValue = useCallback(() => {
    if (typeof window === "undefined") {
      return initialValue;
    }
    try {
      const item = window.sessionStorage.getItem(key);
      return item ? parseJSON(item) : initialValue;
    } catch (error) {
      return initialValue;
    }
  }, [initialValue, key]);
  const [storedValue, setStoredValue] = useState(readValue);
  const setValue = (value) => {
    try {
      const newValue = value instanceof Function ? value(storedValue) : value;
      window.sessionStorage.setItem(key, JSON.stringify(newValue));
      setStoredValue(newValue);
    } catch (error) {
    }
  };
  useEffect(() => {
    setStoredValue(readValue());
  }, []);
  useEffect(() => {
    var _a2;
    if (typeof window == "undefined") {
      return;
    }
    (_a2 = window.addEventListener) == null ? void 0 : _a2.call(window, "storage", handleStorageChange);
    return () => {
      var _a3;
      (_a3 = window.removeEventListener) == null ? void 0 : _a3.call(window, "storage", handleStorageChange);
    };
  });
  const handleStorageChange = useCallback(
    (event) => {
      if ((event == null ? void 0 : event.key) && event.key !== key) {
        return;
      }
      setStoredValue(readValue());
    },
    [key, readValue]
  );
  return [storedValue, setValue];
}
function useLocalStorage(key, initialValue) {
  const readValue = useCallback(() => {
    if (typeof window === "undefined") {
      return initialValue;
    }
    try {
      const item = window.localStorage.getItem(key);
      return item ? parseJSON(item) : initialValue;
    } catch (error) {
      return initialValue;
    }
  }, [initialValue, key]);
  const [storedValue, setStoredValue] = useState(readValue);
  const setValue = useCallback(
    (value) => {
      try {
        const newValue = value instanceof Function ? value(storedValue) : value;
        window.localStorage.setItem(key, JSON.stringify(newValue));
        window.dispatchEvent(new Event("storage"));
        setStoredValue(() => newValue);
      } catch (error) {
      }
    },
    [storedValue]
  );
  useEffect(() => {
    setStoredValue(readValue());
  }, []);
  useEffect(() => {
    var _a2;
    const handleStorageChange = (event) => {
      if ((event == null ? void 0 : event.key) && event.key !== key) {
        return;
      }
      setStoredValue(readValue());
    };
    (_a2 = window == null ? void 0 : window.addEventListener) == null ? void 0 : _a2.call(window, "storage", handleStorageChange);
    return () => {
      var _a3;
      (_a3 = window == null ? void 0 : window.removeEventListener) == null ? void 0 : _a3.call(window, "storage", handleStorageChange);
    };
  }, [key]);
  return [storedValue, setValue];
}
var apiKeyMap = {
  dev: "4d6b7db0fdd6e9de2b6a270414fd51e0",
  qa: "96476b00bc2701360f9b480629ae5263",
  staging: "dffc00e003479b86d410c448e00f2304",
  prod: "3ab9ae56ed16cc57bc2ac97ffc1098c2"
};
var AmplitudeTracker = class {
  constructor(env, sdkInfo) {
    this._ee = qr$2.get("EE");
    amplitude.init(apiKeyMap[env], { serverZone: "EU" });
    this.setSdkInfo(sdkInfo);
    this._bindEvents();
  }
  setUserId(userId) {
    if (userId === this._userId) {
      return;
    }
    amplitude.setUserId(userId);
    this._userId = userId;
  }
  setSdkInfo(sdkInfo) {
    if (this._sdkInfoTag && sdkInfo.address === this._sdkInfoTag)
      return;
    const identify2 = new amplitude.Identify();
    Object.entries(sdkInfo).forEach(([key, value]) => {
      identify2.set(key, value);
    });
    amplitude.identify(identify2);
    this._sdkInfoTag = sdkInfo.address;
  }
  identify(identifyEvent) {
    amplitude.identify(identifyEvent);
  }
  track(eventName, properties) {
    amplitude.track(TrackerListenerKeyMap[eventName], properties);
  }
  _bindEvents() {
    const listenKeys = Object.keys(TrackerListenerKeyMap);
    listenKeys.forEach((key) => {
      this._ee.addListener(key, (params = {}) => {
        if (key === EnumTrackerKeys.trackIdentifyUserId) {
          this.setUserId(params);
        } else {
          this.track(key, params);
        }
      });
    });
  }
};
AmplitudeTracker.instanceName = "amplitudeTracker";
var useTrackingInstance = () => {
  const { configStore } = useContext(OrderlyContext);
  if (!configStore)
    throw new Error("configStore is not defined, please use OrderlyProvider");
  const env = configStore.get("env");
  const brokerId = configStore.get("brokerId");
  const trackInstace = useConstant(() => {
    var _a2;
    let instance = qr$2.get("amplitudeTracker");
    if (!instance) {
      instance = new AmplitudeTracker(env, {
        brokerId,
        sdk_version: ((_a2 = window == null ? void 0 : window.__ORDERLY_VERSION__) == null ? void 0 : _a2["@orderly.network/net"]) ?? ""
      });
      qr$2.registerByName("instance", instance);
    }
    return instance;
  });
  return trackInstace;
};
var WS_NAME = "nativeWebsocketClient";
var useWS = () => {
  const { configStore } = useContext(OrderlyContext);
  const ws2 = useConstant(() => {
    let websocketClient = qr$2.get(WS_NAME);
    const account5 = qr$2.get(Le$7.instanceName);
    if (!websocketClient) {
      websocketClient = new WS({
        networkId: configStore.get("networkId"),
        publicUrl: configStore.get("publicWsUrl"),
        privateUrl: configStore.get("privateWsUrl"),
        onSigntureRequest: async (accountId) => {
          const signer = account5.signer;
          const timestamp = N$3();
          const result = await signer.signText(timestamp.toString());
          return { ...result, timestamp };
        }
      });
      if ((account5.stateValue.status === AccountStatusEnum.EnableTrading || account5.stateValue.status === AccountStatusEnum.EnableTradingWithoutConnected) && account5.stateValue.accountId) {
        websocketClient.openPrivate(account5.stateValue.accountId);
      }
      account5.on("change:status", (nextState) => {
        if ((nextState.status === AccountStatusEnum.EnableTrading || nextState.status === AccountStatusEnum.EnableTradingWithoutConnected) && nextState.accountId) {
          websocketClient.openPrivate(nextState.accountId);
        } else {
          websocketClient.closePrivate(1e3, "switch account");
        }
      });
      if (typeof window !== "undefined") {
        l$1()["__Orderly_WS"] = websocketClient;
      }
      qr$2.registerByName(WS_NAME, websocketClient);
    }
    return websocketClient;
  });
  return ws2;
};
var useKeyStore = () => {
  const ctx = useContext(OrderlyContext);
  return ctx.keyStore;
};
var useSimpleDI = () => {
  return {
    get: qr$2.get,
    // getOr: SimpleDI.getOr<T>(name, SimpleDI.get<T>(name)),
    register: qr$2.register
  };
};
var WsNetworkStatus = /* @__PURE__ */ ((WsNetworkStatus2) => {
  WsNetworkStatus2["Connected"] = "connected";
  WsNetworkStatus2["Unstable"] = "unstable";
  WsNetworkStatus2["Disconnected"] = "disconnected";
  return WsNetworkStatus2;
})(WsNetworkStatus || {});
function useWsStatus() {
  const ws2 = useWS();
  const [wsStatus, setWsStatus] = useState(
    ws2.client.public.readyState ? "connected" : "disconnected"
    /* Disconnected */
  );
  const connectCount = useRef(0);
  useEffect(() => {
    ws2.on("status:change", (status) => {
      const { type, isPrivate } = status;
      if (!isPrivate) {
        switch (type) {
          case "open":
            connectCount.current = 0;
            setWsStatus(
              "connected"
              /* Connected */
            );
            break;
          case "close":
            connectCount.current = 0;
            setWsStatus(
              "disconnected"
              /* Disconnected */
            );
            break;
          case "reconnecting":
            connectCount.current++;
            if (connectCount.current >= 3) {
              setWsStatus(
                "unstable"
                /* Unstable */
              );
            }
            break;
        }
      }
    });
    return () => ws2.off("websocket:status", () => {
    });
  }, []);
  return wsStatus;
}
var StatusContext = createContext({});
var StatusProvider = (props) => {
  const wsStatus = useWsStatus();
  return /* @__PURE__ */ jsx(StatusContext.Provider, { value: { ws: wsStatus }, children: props.children });
};
var BaseMergeHandler = class {
  constructor(message) {
    this.message = message;
    this.data = this.formatOrder(message);
  }
  /**
   * format the order data;
   */
  formatOrder(message) {
    const data = this.pre(message);
    if (!data.created_time) {
      data.created_time = data.timestamp;
    }
    if (data.status === OrderStatus.FILLED && !data.updated_time) {
      data.updated_time = data.timestamp;
    }
    if (data.child_orders && data.child_orders.length) {
      data.child_orders.map((child) => {
        if (child.algo_status === OrderStatus.FILLED && child.is_activated && !child.updated_time) {
          child.updated_time = data.timestamp;
        }
      });
    }
    if (data.type && data.type.endsWith("_ORDER")) {
      data.type = data.type.replace("_ORDER", "");
    }
    return data;
  }
  merge(key, message, prevData) {
    switch (this.status) {
      case "NEW": {
        if (key.startsWith("orders:CANCELLED") || key.startsWith("orders:FILLED") || key.startsWith("orders:REJECTED")) {
          return prevData;
        }
        return this.insetOrUpdate(prevData);
      }
      case "CANCELLED": {
        if (key.startsWith("orders:FILLED") || key.startsWith("orders:REJECTED")) {
          return prevData;
        }
        if (key.startsWith("orders:NEW") || key.startsWith("orders:INCOMPLETE")) {
          return this.remove(prevData);
        }
        if (key.startsWith("orders:CANCELLED")) {
          return this.insert(prevData);
        }
        return this.update(prevData);
      }
      case "REPLACED":
        return this.update(prevData);
      case "FILLED": {
        if (this.orderIsExisting(prevData)) {
          if (key.startsWith("orders:INCOMPLETE") || key.startsWith("orders:NEW") || // all orders key
          key.startsWith("orders:")) {
            if (this.isFullFilled()) {
              return this.remove(prevData);
            }
            return this.update(prevData);
          }
        } else {
          if (key.startsWith("orders:CANCELLED") || key.startsWith("orders:INCOMPLETE") || key.startsWith("orders:NEW")) {
            return prevData;
          }
          return this.insert(prevData);
        }
      }
      default:
        return prevData || [];
    }
  }
  insert(orders) {
    const index = lensIndex(0);
    return over(
      //@ts-ignore
      index,
      (item) => ({
        meta: {
          ...item.meta,
          total: item.meta.total + 1
        },
        rows: [this.data, ...item.rows]
      }),
      orders
    );
  }
  insetOrUpdate(orders) {
    if (this.orderIsExisting(orders)) {
      return this.update(orders);
    }
    return this.insert(orders);
  }
  update(prevData) {
    const idx = this.findOrderIndex(prevData);
    if (!Array.isArray(idx)) {
      return prevData || [];
    }
    const [index, index2] = idx;
    return prevData.map((item, i) => {
      return {
        meta: { ...item.meta },
        rows: item.rows.map((order, j2) => {
          if (index === i && index2 === j2) {
            return { ...order, ...this.data };
          }
          return order;
        })
      };
    });
  }
  remove(prevData) {
    const idx = this.findOrderIndex(prevData);
    if (!Array.isArray(idx)) {
      return prevData;
    }
    const [index, index2] = idx;
    return prevData.map((item, i) => {
      return {
        meta: { ...item.meta, total: item.meta.total - 1 },
        rows: index === i ? item.rows.filter((_2, i2) => i2 !== index2) : item.rows
      };
    });
  }
  findOrderIndex(orders) {
    let index = 0;
    let index2;
    for (; index < orders.length; index++) {
      const item = orders[index];
      for (let idx2 = 0; idx2 < item.rows.length; idx2++) {
        const element = item.rows[idx2];
        if (element.algo_order_id === this.orderId || element.order_id === this.orderId) {
          index2 = idx2;
          break;
        }
      }
      if (typeof index2 !== "undefined") {
        break;
      }
    }
    if (typeof index2 === "undefined") {
      return;
    }
    return [index, index2];
  }
  orderIsExisting(orders) {
    const index = this.findOrderIndex(orders);
    return Array.isArray(index);
  }
};
function object2underscore(obj) {
  return Object.keys(obj).reduce((acc, key) => {
    acc[G$7(key)] = obj[key];
    return acc;
  }, {});
}
var AlgoOrderMergeHandler = class _AlgoOrderMergeHandler extends BaseMergeHandler {
  get orderId() {
    return this.data.algo_order_id;
  }
  get status() {
    return this.data.root_algo_status;
  }
  //   merge(
  //     key: string,
  //     message: WSMessage.AlgoOrder[],
  //     prevData: API.OrderResponse[]
  //   ): API.OrderResponse[] | undefined {
  //     switch (this.status) {
  //       case "TRIGGER": {
  //       }
  //       default:
  //         return super.merge(key, message, prevData);
  //     }
  //   }
  pre(message, prevData) {
    return _AlgoOrderMergeHandler.groupOrders(message);
  }
  isFullFilled() {
    if ("total_executed_quantity" in this.data && this.data.total_executed_quantity !== 0) {
      return this.data.total_executed_quantity === this.data.quantity;
    } else if ("total_executed_quantity" in this.data.child_orders[0]) {
      return this.data.child_orders[0].total_executed_quantity === this.data.child_orders[0].quantity;
    }
    return false;
  }
  static groupOrders(orders) {
    const rootOrderIndex = orders.findIndex(
      (order) => order.parentAlgoOrderId === 0 && order.algoOrderId === order.rootAlgoOrderId
    );
    if (rootOrderIndex === -1) {
      throw new SDKError("Root order not found");
    }
    const rootOrder_ = object2underscore(
      orders[rootOrderIndex]
    );
    rootOrder_.child_orders = orders.filter((_2, index) => index !== rootOrderIndex).map((order) => {
      return object2underscore(order);
    });
    if (rootOrder_.algo_type === "BRACKET" && rootOrder_.child_orders.length > 0) {
      const childOrders = this.groupBracketChildOrders([
        ...rootOrder_.child_orders
      ]);
      rootOrder_.child_orders = [childOrders];
    }
    return rootOrder_;
  }
  static groupBracketChildOrders(orders) {
    const innerOrders = [...orders];
    const rootOrderIndex = innerOrders.findIndex(
      (order) => order.algoType !== AlgoOrderType.STOP_LOSS && order.algoType !== AlgoOrderType.TAKE_PROFIT
    );
    if (rootOrderIndex === -1) {
      throw new SDKError("Root order not found");
    }
    const rootOrder = innerOrders.splice(
      rootOrderIndex,
      1
    )[0];
    rootOrder.child_orders = innerOrders;
    return rootOrder;
  }
};
var RegularOrderMergeHandler = class extends BaseMergeHandler {
  get orderId() {
    return this.data.order_id;
  }
  get status() {
    return this.data.status;
  }
  pre(message, prevData) {
    return object2underscore(message);
  }
  isFullFilled() {
    return "total_executed_quantity" in this.data && this.data.total_executed_quantity === this.data.quantity;
  }
};
var generateKeyFun = (args) => (pageIndex, previousPageData) => {
  var _a2;
  if (previousPageData && !((_a2 = previousPageData.rows) == null ? void 0 : _a2.length))
    return null;
  const { status, symbol, side, size = 100, page, dateRange } = args;
  const search = new URLSearchParams([
    ["size", size.toString()],
    ["page", `${pageIndex + 1}`],
    ["source_type", "ALL"]
  ]);
  if (dateRange) {
    if (dateRange.from) {
      search.set("start_t", `${dateRange.from.getTime()}`);
    }
    if (dateRange.to) {
      search.set("end_t", `${dateRange.to.getTime()}`);
    }
  }
  if (page) {
    search.set("page", `${page}`);
  }
  if (status) {
    search.set(`status`, status);
  }
  if (symbol) {
    search.set(`symbol`, symbol);
  }
  if (side) {
    search.set(`side`, side);
  }
  return `/v1/orders?${search.toString()}`;
};
var updateOrdersHandler = (key, updatedOrder, orders) => {
  if (!orders) {
    return;
  }
  const handler = new RegularOrderMergeHandler(updatedOrder);
  return handler.merge(key, updatedOrder, orders);
};
function updateAlgoOrdersHandler(key, message, orders) {
  if (!orders) {
    return;
  }
  const mergeHandler = new AlgoOrderMergeHandler(message);
  const result = mergeHandler.merge(key, message, orders);
  return result;
}
function getPositionBySymbol(symbol) {
}
var useAppStore = create()(
  immer((set2) => ({
    // accountInfo: null,
    portfolio: {
      totalCollateral: y$3,
      totalValue: null,
      freeCollateral: y$3,
      availableBalance: 0,
      unsettledPnL: 0,
      totalUnrealizedROI: 0
    },
    appState: {
      positionsLoading: false,
      ordersLoading: false,
      fundingRatesLoading: false,
      ready: false
    },
    actions: {
      cleanAll: () => {
        set2((state) => {
          state.accountInfo = void 0;
          state.portfolio = {
            totalCollateral: y$3,
            totalValue: null,
            freeCollateral: y$3,
            availableBalance: 0,
            unsettledPnL: 0,
            totalUnrealizedROI: 0
          };
        }, false);
      },
      setAccountInfo: (accountInfo) => {
        set2(
          (state) => {
            state.accountInfo = accountInfo;
          },
          false
          // "setAccountInfo"
        );
      },
      setSymbolsInfo: (symbolsInfo) => {
        set2(
          (state) => {
            state.symbolsInfo = symbolsInfo;
          },
          false
          // "setSymbolsInfo"
        );
      },
      setFundingRates: (fundingRates) => {
        set2(
          (state) => {
            state.fundingRates = fundingRates;
          },
          false
          // "setFundingRates"
        );
      },
      updateAppStatus: (key, value) => {
        set2(
          (state) => {
            state.appState[key] = value;
          },
          false
          // "updateAppStatus"
        );
      },
      updatePortfolio: (key, value) => {
        set2(
          (state) => {
            state.portfolio[key] = value;
          },
          false
          // "updatePortfolio"
        );
      },
      batchUpdateForPortfolio: (data) => {
        set2(
          (state) => {
            state.portfolio = { ...state.portfolio, ...data };
          },
          false
          // "batchUpdateForPortfolio"
        );
      },
      restoreHolding: (holding) => {
        set2(
          (state) => {
            state.portfolio.holding = holding;
          },
          false
          // "updateHolding"
        );
      },
      updateHolding(msg) {
        set2(
          (state) => {
            if (state.portfolio.holding && state.portfolio.holding.length) {
              for (const key in msg) {
                const holding = state.portfolio.holding.find(
                  (item) => item.token === key
                );
                if (holding) {
                  holding.holding = msg[key].holding;
                  holding.frozen = msg[key].frozen;
                }
              }
            }
          },
          false
          // "updateHolding"
        );
      }
    }
  }))
);
var useAccountInfo = () => useAppStore((state) => state.accountInfo);
var BaseCalculator = class {
  cache(data) {
    this._cache = data;
  }
};
var useMarkPriceStore = create((set2, get3) => ({
  markPrices: {},
  // orderBook: {},
  // ask_bid: [],
  actions: {
    updateMarkPrice: (markPrice) => {
      set2({
        markPrices: markPrice
      });
    },
    getMarkPriceBySymbol: (symbol) => {
      return get3().markPrices[symbol];
    }
  }
}));
var useMarkPriceActions = () => useMarkPriceStore((state) => state.actions);
var MarketCalculatorName = "markPriceCalculator";
var MarkPriceCalculator = class extends BaseCalculator {
  constructor() {
    super(...arguments);
    this.name = MarketCalculatorName;
  }
  calc(scope, data, ctx) {
    return data;
  }
  update(data, scope) {
    useMarkPriceStore.getState().actions.updateMarkPrice(data);
  }
};
var CalculatorContext = class _CalculatorContext {
  static get instance() {
    return this._instance;
  }
  static create(scope, data) {
    if (!this._instance) {
      this._instance = new _CalculatorContext(scope, data);
    }
    return this._instance.update(scope, data);
  }
  constructor(scope, data) {
    this.setCtxData();
    this.output = {
      // rows: positions,
    };
  }
  update(scope, data) {
    this.setCtxData();
    this.markPrices = scope === "markPrice" ? data : this.output[MarketCalculatorName];
    this.portfolio = this.output["portfolio"] || useAppStore.getState().portfolio;
    return this;
  }
  setCtxData() {
    this.accountInfo = useAppStore.getState().accountInfo;
    this.symbolsInfo = useAppStore.getState().symbolsInfo;
    this.fundingRates = useAppStore.getState().fundingRates;
  }
  get(fn2) {
    return fn2(this.output);
  }
  getCacheValue(name, fallback) {
    return this.output[name] || fallback();
  }
  clearCache() {
    this.output = {};
    this.accountInfo = void 0;
    this.portfolio = void 0;
  }
  deleteByName(name) {
    delete this.output[name];
  }
  // get positions(): API.PositionTPSLExt[] {
  //   if (this.output.positionCalculator) return this.output.positionCalculator;
  //   return usePositionStore.getState().positions;
  // }
  get isReady() {
    return !!this.accountInfo;
  }
  saveOutput(name, data) {
    this.output[name] = data;
  }
  outputToValue() {
    return this.output;
  }
};
var CalculatorService = class {
  constructor(scheduler, calculators) {
    this.scheduler = scheduler;
    this.pendingCalc = [];
    this.calcQueue = [];
    this.referenceCount = /* @__PURE__ */ new Map();
    this.isPaused = false;
    this.calculators = new Map(calculators);
  }
  register(scope, calculator) {
    const ref_count_name = `${scope}_${calculator.name}`;
    const count = this.referenceCount.get(ref_count_name);
    if (typeof count !== "undefined" && count > 0) {
      this.referenceCount.set(ref_count_name, count + 1);
      return;
    }
    const calculators = this.calculators.get(scope);
    if (Array.isArray(calculators)) {
      calculators.push(calculator);
    } else {
      this.calculators.set(scope, [calculator]);
    }
    this.referenceCount.set(ref_count_name, 1);
  }
  unregister(scope, calculator) {
    var _a2, _b2;
    const ref_count_name = `${scope}_${calculator.name}`;
    const count = this.referenceCount.get(ref_count_name);
    if (typeof count !== "undefined" && count > 1) {
      this.referenceCount.set(ref_count_name, count - 1);
      return;
    }
    const calculators = this.calculators.get(scope);
    if (Array.isArray(calculators)) {
      const index = calculators.findIndex((c2) => c2.name === calculator.name);
      if (index > -1) {
        (_b2 = (_a2 = calculators[index]).destroy) == null ? void 0 : _b2.call(_a2);
        calculators.splice(index, 1);
      }
    }
    this.referenceCount.delete(ref_count_name);
  }
  async calc(scope, data, options) {
    if (scope !== "position") {
      if (!(options == null ? void 0 : options.skipWhenOnPause)) ;
    }
    const ctx = CalculatorContext.create(scope, data);
    if (!ctx.isReady && (options == null ? void 0 : options.skipPending)) {
      return;
    }
    if ((options == null ? void 0 : options.skipWhenOnPause) && !this.windowIsVisible)
      return;
    this.calcQueue.push({ scope, data, options });
    await this.handleCalcQueue(ctx);
    this.ctx = ctx;
  }
  // private async handlePendingCalc() {
  //   // console.log("[handlePendingCalc]:", this.pendingCalc);
  //   if (this.pendingCalc.length === 0) return;
  //   this.calcQueue = [...this.pendingCalc, ...this.calcQueue];
  //   this.pendingCalc = [];
  // }
  async handleCalcQueue(context) {
    const first = this.calcQueue.shift();
    if (first) {
      const { scope, data, options } = first;
      const ctx = context || CalculatorContext.create(scope, data);
      const calculators = this.calculators.get(scope);
      if (Array.isArray(calculators) && calculators.length) {
        try {
          await this.scheduler.calc(scope, calculators, data, ctx);
        } catch (e3) {
        }
        if (!(options == null ? void 0 : options.skipUpdate)) {
          this.scheduler.update(scope, calculators, ctx.outputToValue());
        }
      }
      if (this.calcQueue.length) {
        this.handleCalcQueue(ctx);
      }
    }
  }
  stop() {
    var _a2;
    this.calcQueue = [];
    (_a2 = this.ctx) == null ? void 0 : _a2.clearCache();
  }
  get windowIsVisible() {
    if (typeof document === "undefined")
      return true;
    return document.visibilityState === "visible";
  }
};
var CalculatorServiceID = "CalculatorService";
var requestIdleCallbackPolyfill = (callback, options) => {
  const startTime = Date.now();
  return setTimeout(() => {
    callback({
      didTimeout: false,
      timeRemaining: () => Math.max(0, 50 - (Date.now() - startTime))
    });
  }, 1);
};
var cancelIdleCallbackPolyfill = (id2) => {
  clearTimeout(id2);
};
var safeRequestIdleCallback = typeof window !== "undefined" && window.requestIdleCallback ? window.requestIdleCallback.bind(window) : requestIdleCallbackPolyfill;
typeof window !== "undefined" && window.cancelIdleCallback ? window.cancelIdleCallback.bind(window) : cancelIdleCallbackPolyfill;
var ShardingScheduler = class {
  // run(calculators: Calculator[]) {}
  calc(scope, calculators, data, ctx) {
    return new Promise((resolve, reject) => {
      try {
        this.computation(
          calculators,
          (shard) => {
            const results = [];
            for (let index = 0; index < shard.length; index++) {
              const calculator = shard[index];
              const result = calculator.calc(scope, data, ctx);
              if (result) {
                ctx.saveOutput(calculator.name, result);
                results.push(result);
              }
            }
            return results;
          },
          (results) => {
            resolve(results);
          }
        );
      } catch (error) {
        reject(error);
      }
    });
  }
  update(scope, calculators, data) {
    for (let index = 0; index < calculators.length; index++) {
      const calculator = calculators[index];
      const item = data[calculator.name];
      if (!!item) {
        calculator.update(item, scope);
      }
    }
    return Promise.resolve();
  }
  computation(data, processor, onComplete) {
    let index = 0;
    const results = [];
    const estimatedShardSize = Math.min(data.length, 2);
    function processNextShard(deadline) {
      let shardSize = estimatedShardSize;
      while (index + shardSize <= data.length && deadline.timeRemaining() > 0) {
        const shard = data.slice(index, index + shardSize);
        const result = processor(shard);
        results.push(result);
        index += shardSize;
        if (deadline.timeRemaining() < 1) {
          shardSize = Math.max(1, Math.floor(shardSize / 2));
        } else {
          shardSize = Math.min(data.length - index, shardSize * 2);
        }
      }
      if (index < data.length) {
        safeRequestIdleCallback(processNextShard, {
          timeout: 1e3
        });
      } else {
        onComplete(results.flat());
      }
    }
    safeRequestIdleCallback(processNextShard, {
      timeout: 1e3
    });
  }
};
var POSITION_EMPTY = {
  rows: null,
  margin_ratio: 0,
  initial_margin_ratio: 0,
  maintenance_margin_ratio: 0,
  open_margin_ratio: 0,
  current_margin_ratio_with_orders: 0,
  initial_margin_ratio_with_orders: 0,
  maintenance_margin_ratio_with_orders: 0,
  total_collateral_value: 0,
  free_collateral: 0,
  total_pnl_24_h: 0,
  unrealPnL: 0,
  total_unreal_pnl: 0,
  unsettledPnL: 0,
  total_unsettled_pnl: 0,
  notional: 0,
  unrealPnlROI: 0
};
var usePositionStore = create()(
  immer((set2) => ({
    positions: {
      all: POSITION_EMPTY
    },
    actions: {
      setPositions: (key, positions2) => {
        set2((state) => {
          state.positions[key] = positions2;
        });
      },
      closePosition: (symbol) => {
        set2((state) => {
          delete state.positions[symbol];
        });
      },
      clearAll: () => {
        set2((state) => {
          state.positions = {
            all: POSITION_EMPTY
          };
        });
      }
    }
  }))
);
var usePositions = (symbol = "all") => usePositionStore((state) => (state.positions[symbol] ?? POSITION_EMPTY).rows);
var usePositionActions = () => usePositionStore((state) => state.actions);
var useApiStatusStore = create()(
  immer((set2) => ({
    apis: {
      positions: {
        loading: false
      }
    },
    actions: {
      updateStatus: (key, status) => {
        set2((state) => {
          state.apis[key] = status;
        });
      },
      updateApiLoading: (key, loading) => {
        set2((state) => {
          state.apis[key].loading = loading;
        });
      },
      updateApiError: (key, error) => {
        set2((state) => {
          state.apis[key] = {
            loading: false,
            error
          };
        });
      }
    }
  }))
);
var useApiStatusActions = () => useApiStatusStore((state) => state.actions);
var NAME_PREFIX = "positionCalculator";
var AllPositions = "all";
var PositionCalculator = class extends BaseCalculator {
  // private id: string;
  constructor(symbol = AllPositions) {
    super();
    this.name = `${NAME_PREFIX}_${symbol}`;
    this.symbol = symbol;
  }
  calc(scope, data, ctx) {
    if (scope === "markPrice") {
      return this.calcByMarkPrice(data, ctx);
    }
    if (scope === "indexPrice") {
      return this.calcByIndexPrice(data, ctx);
    }
    if (scope === "position") {
      return this.calcByPosition(
        this.preprocess(data),
        ctx
      );
    }
    return data;
  }
  update(data, scope) {
    if (!data || !Array.isArray(data.rows))
      return;
    usePositionStore.getState().actions.setPositions(this.symbol, data);
    if (Array.isArray(data.rows) && useApiStatusStore.getState().apis.positions.loading) {
      useApiStatusStore.getState().actions.updateApiLoading("positions", false);
    }
  }
  calcByMarkPrice(markPrice, ctx) {
    let positions2 = this.getPosition(markPrice, ctx);
    if (!positions2 || !Array.isArray(positions2.rows) || !positions2.rows.length)
      return positions2;
    positions2 = {
      ...positions2,
      rows: positions2.rows.map((item) => ({
        ...item,
        mark_price: markPrice[item.symbol] || item.mark_price
      }))
    };
    return this.format(positions2, ctx);
  }
  calcByIndexPrice(indexPrice, ctx) {
    let positions2 = this.getPosition(indexPrice, ctx);
    if (!positions2) {
      return positions2;
    }
    if (!Array.isArray(positions2.rows) || !positions2.rows.length)
      return positions2;
    positions2 = {
      ...positions2,
      rows: positions2.rows.map((item) => ({
        ...item,
        index_price: indexPrice[item.symbol] || item.index_price || item.mark_price
      }))
    };
    return this.format(positions2, ctx);
  }
  calcByPosition(positions2, ctx) {
    if (positions2.rows.length === 0)
      return positions2;
    return this.format(positions2, ctx);
  }
  format(data, ctx) {
    const { accountInfo, symbolsInfo, fundingRates, portfolio } = ctx;
    if (!accountInfo || !fundingRates || !symbolsInfo) {
      return data;
    }
    let unrealPnL_total = y$3, unrealPnL_total_index = y$3, notional_total = y$3, unsettlementPnL_total = y$3;
    let rows = data.rows.map((item) => {
      const info = symbolsInfo[item.symbol];
      const notional2 = positions_exports.notional(item.position_qty, item.mark_price);
      const unrealPnl = positions_exports.unrealizedPnL({
        qty: item.position_qty,
        openPrice: item == null ? void 0 : item.average_open_price,
        // markPrice: unRealizedPrice,
        markPrice: item.mark_price
      });
      let unrealPnl_index = 0, unrealPnlROI_index = 0;
      const imr = account_exports.IMR({
        maxLeverage: accountInfo.max_leverage,
        baseIMR: info == null ? void 0 : info["base_imr"],
        IMR_Factor: accountInfo.imr_factor[item.symbol],
        positionNotional: notional2,
        ordersNotional: 0,
        IMR_factor_power: 4 / 5
      });
      const unrealPnlROI = positions_exports.unrealizedPnLROI({
        positionQty: item.position_qty,
        openPrice: item.average_open_price,
        IMR: imr,
        unrealizedPnL: unrealPnl
      });
      if (item.index_price) {
        unrealPnl_index = positions_exports.unrealizedPnL({
          qty: item.position_qty,
          openPrice: item == null ? void 0 : item.average_open_price,
          // markPrice: unRealizedPrice,
          markPrice: item.index_price
        });
        unrealPnlROI_index = positions_exports.unrealizedPnLROI({
          positionQty: item.position_qty,
          openPrice: item.average_open_price,
          IMR: imr,
          unrealizedPnL: unrealPnl_index
        });
      }
      const unsettlementPnL22 = positions_exports.unsettlementPnL({
        positionQty: item.position_qty,
        markPrice: item.mark_price,
        costPosition: item.cost_position,
        sumUnitaryFunding: propOr(
          0,
          "sum_unitary_funding",
          fundingRates[item.symbol]
        ),
        lastSumUnitaryFunding: item.last_sum_unitary_funding
      });
      const MMR3 = positions_exports.MMR({
        baseMMR: info == null ? void 0 : info["base_mmr"],
        baseIMR: info == null ? void 0 : info["base_imr"],
        IMRFactor: accountInfo.imr_factor[item.symbol],
        positionNotional: notional2,
        IMR_factor_power: 4 / 5
      });
      unrealPnL_total = unrealPnL_total.add(unrealPnl);
      unrealPnL_total_index = unrealPnL_total_index.add(unrealPnl_index);
      notional_total = notional_total.add(notional2);
      unsettlementPnL_total = unsettlementPnL_total.add(unsettlementPnL22);
      return {
        ...item,
        mm: positions_exports.maintenanceMargin({
          positionQty: item.position_qty,
          markPrice: item.mark_price,
          MMR: MMR3
        }),
        mmr: MMR3,
        notional: notional2,
        unsettlement_pnl: unsettlementPnL22,
        unrealized_pnl: unrealPnl,
        unrealized_pnl_index: unrealPnl_index,
        unrealized_pnl_ROI: unrealPnlROI,
        unrealized_pnl_ROI_index: unrealPnlROI_index
      };
    });
    const totalUnrealPnl = unrealPnL_total.toNumber();
    const totalUnrealPnl_index = unrealPnL_total_index.toNumber();
    const unsettlementPnL2 = unsettlementPnL_total.toNumber();
    let totalUnrealizedROI2 = 0, totalUnrealizedROI_index = 0;
    if (portfolio) {
      const { totalValue: totalValue2, totalCollateral: totalCollateral2 } = portfolio;
      rows = rows.map((item) => {
        const est_liq_price = positions_exports.liqPrice({
          markPrice: item.mark_price,
          totalCollateral: totalCollateral2.toNumber(),
          positionQty: item.position_qty,
          positions: rows,
          MMR: item.mmr
        });
        return {
          ...item,
          est_liq_price
        };
      });
      if (totalValue2 !== null && !totalValue2.eq(y$3)) {
        totalUnrealizedROI2 = account_exports.totalUnrealizedROI({
          totalUnrealizedPnL: totalUnrealPnl,
          totalValue: totalValue2.toNumber()
        });
        totalUnrealizedROI_index = account_exports.totalUnrealizedROI({
          totalUnrealizedPnL: totalUnrealPnl_index,
          totalValue: totalValue2.toNumber()
        });
      }
    }
    return {
      ...data,
      unrealPnL: totalUnrealPnl,
      total_unreal_pnl: totalUnrealPnl,
      total_unreal_pnl_index: totalUnrealPnl_index,
      notional: notional_total.toNumber(),
      unsettledPnL: unsettlementPnL2,
      total_unsettled_pnl: unsettlementPnL2,
      unrealPnlROI: totalUnrealizedROI2,
      unrealPnlROI_index: totalUnrealizedROI_index,
      rows
    };
  }
  preprocess(data) {
    let rows = data.rows;
    if (this.symbol !== AllPositions && Array.isArray(rows)) {
      rows = rows.filter((item) => item.symbol === this.symbol);
    }
    return {
      ...data,
      rows
    };
  }
  getPosition(_2, ctx) {
    let positions2 = ctx.get((output) => output[this.name]) || usePositionStore.getState().positions[this.symbol];
    if (this.symbol === AllPositions) {
      return positions2;
    }
    if (positions2 && Array.isArray(positions2.rows)) {
      return positions2;
    }
    return this.preprocess(this.getAllPositions(ctx));
  }
  destroy() {
    var _a2;
    usePositionStore.getState().actions.closePosition(this.symbol);
    (_a2 = CalculatorContext.instance) == null ? void 0 : _a2.deleteByName(this.name);
  }
  getAllPositions(ctx) {
    return ctx.get((output) => output[AllPositions]) || usePositionStore.getState().positions[AllPositions];
  }
};
PositionCalculator.logPosition = (symbol = "all") => {
  return usePositionStore.getState().positions[symbol];
};
var parseHolding = (holding, markPrices) => {
  const nonUSDC = [];
  let USDC_holding = 0;
  holding.forEach((item) => {
    if (item.token === "USDC") {
      USDC_holding = item.holding;
    } else {
      nonUSDC.push({
        holding: item.holding,
        markPrice: markPrices[item.token] ?? 0,
        // markPrice: 0,
        discount: 0
      });
    }
  });
  return [USDC_holding, nonUSDC];
};
function createGetter(data, depth = 2) {
  const getValue2 = (value, defaultValue) => {
    if (defaultValue === void 0) {
      return value;
    }
    return value ?? defaultValue;
  };
  return new Proxy(data || {}, {
    get(target, property, receiver) {
      if (property === "isNil") {
        return isNil(data);
      }
      if (depth === 1) {
        return (defaultValue) => {
          if (!target)
            return defaultValue;
          return getValue2(target[property], defaultValue);
        };
      }
      return (key, defaultValue) => {
        var _a2;
        if (key) {
          return getValue2((_a2 = target[property]) == null ? void 0 : _a2[key], defaultValue);
        } else {
          return getValue2(target[property], defaultValue);
        }
      };
    }
  });
}
var PortfolioCalculatorName = "portfolio";
var PortfolioCalculator = class extends BaseCalculator {
  constructor() {
    super(...arguments);
    this.name = PortfolioCalculatorName;
  }
  calc(scope, data, ctx) {
    let markPrices, positions2;
    const portfolio = this.getPortfolio(ctx);
    if (scope === "markPrice") {
      markPrices = data;
    } else {
      markPrices = ctx.get(
        (cache) => cache[MarketCalculatorName]
      );
    }
    positions2 = ctx.get(
      (output) => output.positionCalculator_all
    );
    let holding = portfolio.holding;
    if (scope === "portfolio" && data.holding && Array.isArray(holding)) {
      holding = holding.map((item) => {
        if (data.holding[item.token]) {
          return {
            ...item,
            holding: data.holding[item.token].holding,
            frozen: data.holding[item.token].frozen
          };
        }
        return item;
      });
    }
    const accountInfo = ctx.accountInfo;
    const symbolsInfo = ctx.symbolsInfo;
    return this.format({
      holding,
      positions: positions2,
      markPrices,
      accountInfo,
      symbolsInfo
    });
  }
  getPortfolio(ctx) {
    return ctx.get((output) => output[this.name]) || useAppStore.getState().portfolio;
  }
  format(inputs) {
    const { holding, positions: positions2, markPrices, accountInfo, symbolsInfo } = inputs;
    if (!holding || !positions2 || !Array.isArray(positions2.rows) || !markPrices || !accountInfo) {
      return null;
    }
    const unsettledPnL = pathOr(0, ["total_unsettled_pnl"])(positions2);
    const unrealizedPnL2 = pathOr(0, ["total_unreal_pnl"])(positions2);
    const [USDC_holding, nonUSDC] = parseHolding(holding, markPrices);
    const usdc = holding.find((item) => item.token === "USDC");
    const totalCollateral2 = account_exports.totalCollateral({
      USDCHolding: USDC_holding,
      nonUSDCHolding: nonUSDC,
      unsettlementPnL: unsettledPnL
    });
    const totalValue2 = account_exports.totalValue({
      totalUnsettlementPnL: unsettledPnL,
      USDCHolding: USDC_holding,
      nonUSDCHolding: nonUSDC
    });
    const totalUnrealizedROI2 = account_exports.totalUnrealizedROI({
      totalUnrealizedPnL: unrealizedPnL2,
      totalValue: totalValue2.toNumber()
    });
    const totalInitialMarginWithOrders2 = account_exports.totalInitialMarginWithQty({
      positions: positions2.rows,
      markPrices,
      IMR_Factors: accountInfo.imr_factor,
      maxLeverage: accountInfo.max_leverage,
      symbolInfo: createGetter({ ...symbolsInfo })
    });
    const freeCollateral2 = account_exports.freeCollateral({
      totalCollateral: totalCollateral2,
      totalInitialMarginWithOrders: totalInitialMarginWithOrders2
    });
    const availableBalance2 = account_exports.availableBalance({
      USDCHolding: (usdc == null ? void 0 : usdc.holding) ?? 0,
      unsettlementPnL: positions2.total_unsettled_pnl ?? 0
    });
    return {
      totalCollateral: totalCollateral2,
      totalValue: totalValue2,
      totalUnrealizedROI: totalUnrealizedROI2,
      freeCollateral: freeCollateral2,
      availableBalance: availableBalance2,
      unsettledPnL,
      holding
    };
  }
  update(data, scope) {
    if (!!data) {
      useAppStore.getState().actions.batchUpdateForPortfolio({
        totalCollateral: data.totalCollateral,
        totalValue: data.totalValue,
        freeCollateral: data.freeCollateral,
        availableBalance: data.availableBalance,
        totalUnrealizedROI: data.totalUnrealizedROI,
        unsettledPnL: data.unsettledPnL,
        holding: Array.isArray(data.holding) ? data.holding : []
      });
    }
  }
};
var useIndexPriceStore = create((set2) => ({
  indexPrices: {},
  actions: {
    updateIndexPrice: (indexPrice) => {
      set2({
        indexPrices: indexPrice
      });
    }
  }
}));
var IndexPriceCalculatorName = "indexPriceCalculator";
var IndexPriceCalculator = class extends BaseCalculator {
  constructor() {
    super(...arguments);
    this.name = IndexPriceCalculatorName;
  }
  calc(scope, data, ctx) {
    return data;
  }
  update(data) {
    if (!data)
      return;
    useIndexPriceStore.getState().actions.updateIndexPrice(data);
  }
  static getValue() {
    return useIndexPriceStore.getState().indexPrices;
  }
};
var useCalculatorService = () => {
  const { get: get3 } = useSimpleDI();
  const calculatorService = useConstant(() => {
    let calculatorService2 = get3(CalculatorServiceID);
    if (!calculatorService2) {
      const positionCalculator = new PositionCalculator();
      const portfolioCalculator = new PortfolioCalculator();
      const markPriceCalculator = new MarkPriceCalculator();
      const indexPriceCalculator = new IndexPriceCalculator();
      calculatorService2 = new CalculatorService(new ShardingScheduler(), [
        [
          "markPrice",
          [
            markPriceCalculator,
            positionCalculator,
            portfolioCalculator,
            positionCalculator
          ]
        ],
        ["position", [positionCalculator, portfolioCalculator]],
        ["portfolio", [portfolioCalculator]],
        // indexPrice
        [
          "indexPrice",
          [indexPriceCalculator, positionCalculator]
        ]
      ]);
      qr$2.registerByName(CalculatorServiceID, calculatorService2);
    }
    return calculatorService2;
  });
  return calculatorService;
};
var useMarkPrice = (symbol) => {
  const ws2 = useWS();
  const [price, setPrice] = useState(0);
  useEffect(() => {
    const unsubscribe = ws2.subscribe(`${symbol}@markprice`, {
      onMessage: (message) => {
        setPrice(message.price);
      }
    });
    return () => {
      unsubscribe == null ? void 0 : unsubscribe();
    };
  }, [symbol]);
  return { data: price };
};
var useIndexPrice = (symbol) => {
  symbol = symbol.replace("PERP", "SPOT");
  const ws2 = useWS();
  return useSWRSubscription(`${symbol}@indexprice`, (key, { next }) => {
    const unsubscribe = ws2.subscribe(`${symbol}@indexprice`, {
      onMessage: (message) => {
        next(null, message.price);
      }
    });
    return () => {
      unsubscribe == null ? void 0 : unsubscribe();
    };
  });
};
var useOpenInterest = (symbol) => {
  const ws2 = useWS();
  return useSWRSubscription(`${symbol}@openinterest`, (key, { next }) => {
    const unsubscribe = ws2.subscribe(`${symbol}@openinterest`, {
      onMessage: (message) => {
        next(null, message.openInterest);
      }
    });
    return () => {
      unsubscribe == null ? void 0 : unsubscribe();
    };
  });
};
var useFutures = () => {
  const { data, isLoading, error } = useQuery(
    `/v1/public/futures`,
    {
      revalidateOnFocus: false
    }
  );
  const [sortedData, setSortedData] = useState(data);
  useWS();
  useEffect(() => {
  }, []);
  useEffect(() => {
    if (data) {
      const sortedData2 = data.sort((a2, b2) => {
        return 0;
      });
      setSortedData(sortedData2);
    }
  }, [data]);
  const sortBy = useCallback((key) => {
  }, [data]);
  const filterBy = useCallback((key) => {
  }, [data]);
  return {
    data: sortedData,
    sortBy,
    filterBy,
    isLoading,
    error
  };
};
var useTickerStream = (symbol) => {
  if (!symbol) {
    throw new SDKError("Symbol is required");
  }
  const { data: info } = useQuery(
    `/v1/public/futures/${symbol}`,
    {
      revalidateOnFocus: false
    }
  );
  const [ticker, setTicker] = useState();
  const ws2 = useWS();
  useEffect(() => {
    const unsubscribe = ws2.subscribe(
      // { event: "subscribe", topic: "markprices" },
      `${symbol}@ticker`,
      {
        onMessage: (message) => {
          if (message.symbol !== symbol)
            return;
          setTicker(message);
        }
        // onUnsubscribe: () => {
        //   return "markprices";
        // },
        // onError: (error: any) => {
        //
        // },
      }
    );
    return () => {
      setTicker(void 0);
      unsubscribe == null ? void 0 : unsubscribe();
    };
  }, [symbol]);
  const { data: markPrice } = useMarkPrice(symbol);
  const { data: indexPrice } = useIndexPrice(symbol);
  const { data: openInterest } = useOpenInterest(symbol);
  const { data: futures } = useFutures();
  const value = useMemo(() => {
    if (!info)
      return null;
    if (!ticker || ticker.symbol !== symbol)
      return info;
    const futureIndex = futures == null ? void 0 : futures.findIndex(
      (item) => item.symbol === symbol
    );
    let _oi = openInterest;
    if (!_oi && futureIndex !== -1 && futures) {
      _oi = futures[futureIndex].open_interest;
    }
    const config2 = {
      ...info,
      mark_price: markPrice,
      index_price: indexPrice,
      open_interest: _oi
    };
    if (ticker.open !== void 0) {
      config2["24h_open"] = ticker.open;
    }
    if (ticker.close !== void 0) {
      config2["24h_close"] = ticker.close;
    }
    if (ticker.high !== void 0) {
      config2["24h_high"] = ticker.high;
    }
    if (ticker.low !== void 0) {
      config2["24h_low"] = ticker.low;
    }
    if (ticker.volume !== void 0) {
      config2["24h_volumn"] = ticker.volume;
      config2["24h_volume"] = ticker.volume;
    }
    if (ticker.close !== void 0 && ticker.open !== void 0) {
      config2["change"] = new g$6(ticker.close).minus(ticker.open).div(ticker.open).toNumber();
      config2["24h_change"] = new g$6(ticker.close).minus(ticker.open).toNumber();
    }
    return config2;
  }, [info, symbol, ticker, futures, openInterest]);
  return value;
};
var useSymbolsInfo = () => {
  const symbolsInfo = useAppStore((state) => state.symbolsInfo);
  return useMemo(
    () => createGetter({ ...symbolsInfo }),
    [symbolsInfo]
  );
};
var defaultRawOrderBook = {
  asks: [],
  bids: [],
  ts: 0
};
var OrderbookService = class _OrderbookService {
  constructor() {
    this.bufferedOrderBookUpdates = {};
    this.rawOrderBook = {};
  }
  static getInstance() {
    if (!this.instance) {
      this.instance = new _OrderbookService();
    }
    return this.instance;
  }
  sortBufferedOrderBookUpdates(symbol) {
    var _a2;
    (_a2 = this.bufferedOrderBookUpdates[symbol]) == null ? void 0 : _a2.sort((a2, b2) => a2.ts - b2.ts);
  }
  applyUpdateToRawOrderBook(symbol, update) {
    const rawOrderBook = this.rawOrderBook[symbol];
    if (!rawOrderBook || rawOrderBook.ts > update.prevTs) {
      return;
    }
    const askMap = /* @__PURE__ */ new Map();
    const bidMap = /* @__PURE__ */ new Map();
    rawOrderBook.asks.forEach((ask) => askMap.set(ask[0], ask[1]));
    rawOrderBook.bids.forEach((bid) => bidMap.set(bid[0], bid[1]));
    update.asks.forEach((ask) => ask[1] === 0 ? askMap.delete(ask[0]) : askMap.set(ask[0], ask[1]));
    update.bids.forEach((bid) => bid[1] === 0 ? bidMap.delete(bid[0]) : bidMap.set(bid[0], bid[1]));
    rawOrderBook.asks = Array.from(askMap.entries()).sort((a2, b2) => a2[0] - b2[0]);
    rawOrderBook.bids = Array.from(bidMap.entries()).sort((a2, b2) => b2[0] - a2[0]);
    rawOrderBook.ts = update.ts;
  }
  applyBufferedUpdatesToRawOrderBooks(symbol) {
    var _a2;
    (_a2 = this.bufferedOrderBookUpdates[symbol]) == null ? void 0 : _a2.forEach((update) => this.applyUpdateToRawOrderBook(symbol, update));
  }
  deleteBufferedOrderBookUpdates(symbol) {
    delete this.bufferedOrderBookUpdates[symbol];
  }
  commitOrderBook(symbol) {
    const rawOrderBook = this.rawOrderBook[symbol];
    if (!rawOrderBook) {
      return;
    }
  }
  pushUpdateToBuffer(symbol, update) {
    if (this.bufferedOrderBookUpdates[symbol] === void 0) {
      this.bufferedOrderBookUpdates[symbol] = [];
    }
    const buffer = this.bufferedOrderBookUpdates[symbol];
    if (buffer.length > 0) {
      const lastUpdate = buffer[buffer.length - 1];
      if (lastUpdate.ts !== update.prevTs) {
        this.bufferedOrderBookUpdates[symbol] = [];
      }
    }
    this.bufferedOrderBookUpdates[symbol].push(update);
  }
  isValidFullOrderBook(symbol, currentTs) {
    var _a2;
    if ((((_a2 = this.bufferedOrderBookUpdates[symbol]) == null ? void 0 : _a2.length) ?? 0) !== 0) {
      const earliestUpdates = this.bufferedOrderBookUpdates[symbol][0];
      return earliestUpdates.prevTs <= currentTs;
    }
    return true;
  }
  setFullOrderbook(symbol, rawOrderbook) {
    const { ts: ts2 } = rawOrderbook;
    this.rawOrderBook[symbol] = rawOrderbook;
    this.sortBufferedOrderBookUpdates(symbol);
    if (this.isValidFullOrderBook(symbol, ts2)) {
      this.applyBufferedUpdatesToRawOrderBooks(symbol);
    }
  }
  updateOrderbook(symbol, update, callback) {
    const { asks, bids, prevTs, ts: ts2 } = update;
    const rawOrderBook = this.rawOrderBook[symbol];
    if (!rawOrderBook) {
      return;
    }
    const currentTs = rawOrderBook.ts;
    if (currentTs === 0) {
      this.pushUpdateToBuffer(symbol, { asks, bids, prevTs, ts: ts2 });
      return;
    }
    if (prevTs !== currentTs) {
      this.pushUpdateToBuffer(symbol, { asks, bids, prevTs, ts: ts2 });
      if (callback) {
        callback();
      }
      return;
    }
    this.applyUpdateToRawOrderBook(symbol, update);
    this.deleteBufferedOrderBookUpdates(symbol);
  }
  getRawOrderbook(symbol) {
    return this.rawOrderBook[symbol];
  }
  resetOrderBook(symbol) {
    this.rawOrderBook[symbol] = defaultRawOrderBook;
  }
};
var orderBookService = OrderbookService.getInstance();
var orderbook_service_default = orderBookService;
var paddingFn = (len) => Array(len).fill([
  Number.NaN,
  Number.NaN,
  Number.NaN,
  Number.NaN
]);
var reduceItems = (depth, level, data, asks = false) => {
  if (!Array.isArray(data) || data.length === 0) {
    return [];
  }
  let newData = [...data];
  const result = [];
  if (typeof depth !== "undefined") {
    const prices = /* @__PURE__ */ new Map();
    for (let i = 0; i < data.length; i++) {
      const [price, quantity] = data[i];
      if (isNaN(price) || isNaN(quantity))
        continue;
      let priceKey;
      if (asks) {
        priceKey = new g$6(Math.ceil(price / depth)).mul(depth).toNumber();
      } else {
        priceKey = new g$6(Math.floor(price / depth)).mul(depth).toNumber();
      }
      if (depth < 1 && depth > 0 && priceKey.toString().indexOf(".") !== -1) {
        const priceStr = price.toString();
        const index = priceStr.indexOf(".");
        const decimal = priceStr.slice(index + 1);
        const decimalDepth = O$9(depth).toString().slice(2).length;
        const decimalStr = decimal.slice(0, min(decimal.length, decimalDepth));
        priceKey = new g$6(
          priceStr.slice(0, index) + "." + decimalStr
        ).toNumber();
      }
      if (prices.has(priceKey)) {
        const item = prices.get(priceKey);
        const itemPrice = new g$6(item[1]).add(quantity).toNumber();
        prices.set(priceKey, [priceKey, itemPrice]);
      } else {
        prices.set(priceKey, [priceKey, quantity]);
      }
    }
    newData = Array.from(prices.values());
  }
  for (let i = 0; i < newData.length; i++) {
    const [price, quantity] = newData[i];
    if (isNaN(price) || isNaN(quantity))
      continue;
    const newQuantity = new g$6(quantity).add(result.length > 0 ? result[result.length - 1][2] : 0).toNumber();
    const newAmount = new g$6(quantity * price).add(result.length > 0 ? result[result.length - 1][3] : 0).toNumber();
    result.push([price, quantity, newQuantity, newAmount]);
  }
  return result;
};
var reduceOrderbook = (depth, level, padding2, data) => {
  let asks = reduceItems(depth, level, data.asks, true);
  let bids = reduceItems(depth, level, data.bids);
  if (asks.length !== 0 && bids.length !== 0 && asks[0][0] <= bids[0][0]) {
    if (asks.length === 1) {
      const [price, qty, newQuantity, newAmount] = asks[0];
      asks.shift();
      asks.push([
        price + (depth === void 0 ? 0 : depth),
        qty,
        newQuantity,
        newAmount
      ]);
    } else {
      const [bidPrice] = bids[0];
      while (asks.length > 0) {
        const [askPrice, askQty, newQuantity, newAmount] = asks[0];
        if (askPrice <= bidPrice) {
          asks.shift();
          let logStr = "";
          for (let index = 0; index < asks.length; index++) {
            if (index === 0) {
              const quantity = asks[index][1] + askQty;
              asks[index][1] = quantity;
              asks[index][2] = quantity;
              asks[index][3] = Math.ceil(quantity) * asks[index][0];
            } else {
              asks[index][3] = asks[index][0] * asks[index][1] + asks[index - 1][3];
            }
            logStr += `index: ${index} ${asks[index]}
`;
          }
        } else {
          break;
        }
      }
    }
  }
  asks = asks.reverse();
  if (padding2) {
    asks = asks.length < level ? paddingFn(level - asks.length).concat(asks) : asks;
    bids = bids.length < level ? bids.concat(paddingFn(level - bids.length)) : bids;
  }
  return {
    asks,
    bids
  };
};
var INIT_DATA = { asks: [], bids: [] };
var useOrderbookStream = (symbol, initial = INIT_DATA, options) => {
  var _a2, _b2, _c2, _d2, _e4, _f2, _g3, _h2, _i3, _j2, _k2, _l2, _m2, _n2, _o2, _p2, _q, _r3, _s2, _t2;
  if (!symbol) {
    throw new SDKError("Symbol is required");
  }
  const level = (options == null ? void 0 : options.level) ?? 10;
  const padding2 = (options == null ? void 0 : options.padding) ?? true;
  const symbolRef = useRef(symbol);
  symbolRef.current = symbol;
  const [requestData, setRequestData] = useState(null);
  const [data, setData] = useState(initial);
  const [isLoading, setIsLoading] = useState(true);
  const config2 = useSymbolsInfo()[symbol];
  const [depth, setDepth] = useState();
  const prevMiddlePrice = useRef(0);
  const depths = useMemo(() => {
    const tick = config2("quote_tick");
    if (typeof tick === "undefined")
      return [];
    try {
      const base = new g$6(tick);
      return [
        base.toNumber(),
        base.mul(10).toNumber(),
        base.mul(100).toNumber(),
        base.mul(1e3).toNumber()
      ];
    } catch (e3) {
    }
    return [tick];
  }, [config2("quote_tick")]);
  useEffect(() => {
    setDepth(config2("quote_tick"));
  }, [config2("quote_tick")]);
  const ws2 = useWS();
  const ticker = useTickerStream(symbol);
  const eventEmitter = useEventEmitter();
  useEffect(() => {
    let needRequestFullOrderbook = true;
    setIsLoading(true);
    let orderBookUpdateSub;
    let fullOrderBookUpdateSub;
    orderBookUpdateSub = ws2.subscribe(
      {
        event: "subscribe",
        topic: `${symbol}@orderbookupdate`
      },
      {
        formatter: (message) => message,
        onMessage: (message) => {
          const { data: wsData, ts: ts2 } = message;
          const { symbol: symbol2, asks, bids, prevTs } = wsData;
          if (symbolRef.current !== symbol2) {
            orderBookUpdateSub == null ? void 0 : orderBookUpdateSub();
            return;
          }
          orderbook_service_default.updateOrderbook(
            symbol2,
            { asks, bids, ts: ts2, prevTs },
            () => needRequestFullOrderbook = true
          );
          const data2 = orderbook_service_default.getRawOrderbook(symbol2);
          setData({ bids: data2.bids, asks: data2.asks });
        }
      }
    );
    if (needRequestFullOrderbook) {
      setIsLoading(true);
      fullOrderBookUpdateSub = ws2.onceSubscribe(
        {
          event: "request",
          id: `${symbol}@orderbook`,
          params: {
            type: "orderbook",
            symbol
          }
        },
        {
          formatter: (message) => message,
          onMessage: (message) => {
            const { symbol: symbol2, asks, bids, ts: ts2 } = message.data;
            if (symbolRef.current !== symbol2) {
              return;
            }
            orderbook_service_default.setFullOrderbook(symbol2, { asks, bids, ts: ts2 });
            const data2 = orderbook_service_default.getRawOrderbook(symbol2);
            setData({ bids: data2.bids, asks: data2.asks });
            setIsLoading(false);
          }
        }
      );
      needRequestFullOrderbook = false;
    }
    return () => {
      orderBookUpdateSub == null ? void 0 : orderBookUpdateSub();
      fullOrderBookUpdateSub == null ? void 0 : fullOrderBookUpdateSub();
      orderbook_service_default.resetOrderBook(symbol);
      setData(INIT_DATA);
    };
  }, [symbol]);
  const { data: markPrice } = useMarkPrice(symbol);
  const onItemClick = useCallback((item) => {
    eventEmitter.emit("orderbook:item:click", item);
  }, []);
  const onDepthChange = useCallback((depth2) => {
    setDepth(() => depth2);
  }, []);
  const reducedData = reduceOrderbook(depth, level, padding2, {
    asks: [...data.asks],
    bids: [...data.bids]
  });
  useEffect(() => {
    var _a3, _b3, _c3, _d3, _e5, _f3, _g4, _h3, _i4, _j3, _k3, _l3, _m3, _n3, _o3, _p3, _q2, _r4, _s3, _t3;
    const updateData = [
      [
        (_b3 = (_a3 = reducedData.asks) == null ? void 0 : _a3[reducedData.asks.length - 1]) == null ? void 0 : _b3[0],
        (_d3 = (_c3 = reducedData.bids) == null ? void 0 : _c3[0]) == null ? void 0 : _d3[0]
      ],
      [
        (_f3 = (_e5 = reducedData.asks) == null ? void 0 : _e5[reducedData.asks.length - 2]) == null ? void 0 : _f3[0],
        (_h3 = (_g4 = reducedData.bids) == null ? void 0 : _g4[1]) == null ? void 0 : _h3[0]
      ],
      [
        (_j3 = (_i4 = reducedData.asks) == null ? void 0 : _i4[reducedData.asks.length - 3]) == null ? void 0 : _j3[0],
        (_l3 = (_k3 = reducedData.bids) == null ? void 0 : _k3[2]) == null ? void 0 : _l3[0]
      ],
      [
        (_n3 = (_m3 = reducedData.asks) == null ? void 0 : _m3[reducedData.asks.length - 4]) == null ? void 0 : _n3[0],
        (_p3 = (_o3 = reducedData.bids) == null ? void 0 : _o3[3]) == null ? void 0 : _p3[0]
      ],
      [
        (_r4 = (_q2 = reducedData.asks) == null ? void 0 : _q2[reducedData.asks.length - 5]) == null ? void 0 : _r4[0],
        (_t3 = (_s3 = reducedData.bids) == null ? void 0 : _s3[4]) == null ? void 0 : _t3[0]
      ]
    ];
    eventEmitter.emit("orderbook:update", updateData);
  }, [
    (_b2 = (_a2 = reducedData.asks) == null ? void 0 : _a2[reducedData.asks.length - 1]) == null ? void 0 : _b2[0],
    (_d2 = (_c2 = reducedData.asks) == null ? void 0 : _c2[reducedData.asks.length - 2]) == null ? void 0 : _d2[0],
    (_f2 = (_e4 = reducedData.asks) == null ? void 0 : _e4[reducedData.asks.length - 3]) == null ? void 0 : _f2[0],
    (_h2 = (_g3 = reducedData.asks) == null ? void 0 : _g3[reducedData.asks.length - 4]) == null ? void 0 : _h2[0],
    (_j2 = (_i3 = reducedData.asks) == null ? void 0 : _i3[reducedData.asks.length - 5]) == null ? void 0 : _j2[0],
    (_l2 = (_k2 = reducedData.bids) == null ? void 0 : _k2[0]) == null ? void 0 : _l2[0],
    (_n2 = (_m2 = reducedData.bids) == null ? void 0 : _m2[1]) == null ? void 0 : _n2[0],
    (_p2 = (_o2 = reducedData.bids) == null ? void 0 : _o2[2]) == null ? void 0 : _p2[0],
    (_r3 = (_q = reducedData.bids) == null ? void 0 : _q[3]) == null ? void 0 : _r3[0],
    (_t2 = (_s2 = reducedData.bids) == null ? void 0 : _s2[4]) == null ? void 0 : _t2[0]
  ]);
  const middlePrice = useMemo(() => {
    var _a3, _b3;
    let asksFrist = 0, bidsFirst = 0;
    if (data.asks.length > 0) {
      asksFrist = (_b3 = (_a3 = reducedData.asks) == null ? void 0 : _a3[reducedData.asks.length - 1]) == null ? void 0 : _b3[0];
    }
    if (data.bids.length > 0) {
      bidsFirst = data.bids[0][0];
    }
    if (isNaN(asksFrist) || isNaN(bidsFirst) || !ticker)
      return 0;
    return [asksFrist, bidsFirst, ticker["24h_close"]].sort()[1];
  }, [ticker == null ? void 0 : ticker["24h_close"], data]);
  useEffect(() => {
    prevMiddlePrice.current = middlePrice;
  }, [middlePrice]);
  return [
    {
      asks: reducedData.asks.slice(-level),
      bids: reducedData.bids.slice(0, level),
      markPrice,
      middlePrice: [prevMiddlePrice.current, middlePrice]
    },
    { onDepthChange, depth, allDepths: depths, isLoading, onItemClick }
  ];
};
var useAccountInfo2 = () => {
  return usePrivateQuery("/v1/client/info");
};
var useMarketsStream = () => {
  const ws2 = useWS();
  const { data: futures } = useQuery(`/v1/public/futures`, {
    revalidateOnFocus: false
  });
  const topic = "tickers";
  const { data: tickers } = useSWRSubscription("tickers", (_2, { next }) => {
    const unsubscribe = ws2.subscribe(
      // { event: "subscribe", topic: "markprices" },
      topic,
      {
        onMessage: (message) => {
          next(null, message);
        }
        // onUnsubscribe: () => {
        //   return "markprices";
        // },
        // onError: (error: any) => {
        //
        // },
      }
    );
    return () => {
      unsubscribe == null ? void 0 : unsubscribe();
    };
  });
  const value = useMemo(() => {
    if (!futures)
      return null;
    if (!tickers)
      return futures;
    return futures.map((item) => {
      const ticker = tickers.find(
        (t) => t.symbol === item.symbol
      );
      if (ticker) {
        const data = {
          ...item,
          ["24h_close"]: ticker.close,
          ["24h_open"]: ticker.open,
          /**
           * @deprecated
           * spelling mistake, use 24h_volume to instead, will be remove next version
           */
          ["24h_volumn"]: ticker.volume,
          ["24h_volume"]: ticker.volume,
          ["24h_amount"]: ticker.amount,
          change: 0
        };
        if (ticker.close !== void 0 && ticker.open !== void 0) {
          data["change"] = new g$6(ticker.close).minus(ticker.open).div(ticker.open).toNumber();
        }
        return data;
      }
      return item;
    });
  }, [futures, tickers]);
  return { data: value };
};
var useFundingRates = () => {
  const data = useAppStore((state) => state.fundingRates);
  return createGetter({ ...data });
};
var MarketsType = /* @__PURE__ */ ((MarketsType2) => {
  MarketsType2[MarketsType2["FAVORITES"] = 0] = "FAVORITES";
  MarketsType2[MarketsType2["RECENT"] = 1] = "RECENT";
  MarketsType2[MarketsType2["ALL"] = 2] = "ALL";
  MarketsType2[MarketsType2["NEW_LISTING"] = 3] = "NEW_LISTING";
  return MarketsType2;
})(MarketsType || {});
var MarketsStorageKey = "orderly_markets";
var DefaultFavoriteTab = { name: "Popular", id: 1 };
var useMarketsStore = () => {
  const { configStore } = useContext(OrderlyContext);
  const ee2 = useEventEmitter();
  const id2 = useId();
  const getStore = () => {
    const store = configStore.get(MarketsStorageKey);
    return store || getDefaultStoreData();
  };
  const getStoreByKey = (key, defaultValue) => {
    const store = getStore();
    return store[key] || defaultValue;
  };
  const updateStore = (data) => {
    configStore.set(MarketsStorageKey, {
      ...getStore(),
      ...data
    });
  };
  const getFavoriteTabs = () => {
    return getStoreByKey("favoriteTabs", [{ ...DefaultFavoriteTab }]);
  };
  const getSelectedFavoriteTab = () => {
    return getStoreByKey("selectedFavoriteTab", { ...DefaultFavoriteTab });
  };
  const getFavorites = () => {
    const favs = getStoreByKey("favorites", []);
    const tabs = getFavoriteTabs();
    return filterInvalidTabs(favs, tabs);
  };
  const getRecent = () => {
    return getStoreByKey("recent", []);
  };
  const getNewListing = () => {
    return getStoreByKey("newListing", []);
  };
  const getTabSort = () => {
    return getStoreByKey("tabSort", {});
  };
  const [favoriteTabs, setFavoriteTabs] = useState(getFavoriteTabs);
  const [selectedFavoriteTab, setSelectedFavoriteTab] = useState(
    getSelectedFavoriteTab
  );
  const [favorites, setFavorites] = useState(getFavorites);
  const [recent, setRecent] = useState(getRecent);
  const [newListing, setNewListing] = useState(getNewListing);
  const [tabSort, setTabSort] = useState(getTabSort);
  const updateFavoriteTabs = (tab, operator) => {
    const tabs = updateTabs(favoriteTabs, tab, operator);
    setFavoriteTabs(tabs);
    ee2.emit("markets:changed", createEventData(id2, "favoriteTabs", tabs));
  };
  const updateSelectedFavoriteTab = (tab) => {
    setSelectedFavoriteTab(tab);
    ee2.emit(
      "markets:changed",
      createEventData(id2, "lastSelectedFavoriteTab", tab)
    );
  };
  const updateSymbolFavoriteState = (symbol, tab, remove = false) => {
    const list = updateSymbolFavorite({ favorites, symbol, tab, remove });
    setFavorites(list);
    ee2.emit("markets:changed", createEventData(id2, "favorites", list));
  };
  const addToHistory = (symbol) => {
    const list = addToTop(recent, symbol);
    setRecent(list);
    ee2.emit("markets:changed", id2);
    ee2.emit("markets:changed", createEventData(id2, "recent", list));
  };
  const pinToTop = (symbol) => {
    const newList = moveToTop(favorites, symbol);
    if (newList) {
      setFavorites(newList);
      ee2.emit("markets:changed", createEventData(id2, "favorites", newList));
    }
  };
  const updateTabsSortState = (tabId, sortKey, sortOrder) => {
    const map = getStoreByKey("tabSort", {});
    map[tabId] = {
      sortKey,
      sortOrder
    };
    setTabSort(map);
  };
  useEffect(() => {
    updateStore({
      favoriteTabs,
      favorites,
      recent,
      newListing,
      tabSort,
      selectedFavoriteTab
    });
  }, [
    favoriteTabs,
    favorites,
    recent,
    newListing,
    tabSort,
    selectedFavoriteTab
  ]);
  useEffect(() => {
    const event = ({ id: srcId, key, data }) => {
      if (srcId === id2) {
        return;
      }
      if (key === "favoriteTabs") {
        setFavoriteTabs(data);
      } else if (key === "lastSelectedFavoriteTab") {
        setSelectedFavoriteTab(data);
      } else if (key === "favorites") {
        setFavorites(data);
      } else if (key === "recent") {
        setRecent(data);
      } else if (key === "newListing") {
        setNewListing(data);
      }
    };
    ee2.on("markets:changed", event);
    return () => {
      ee2.off("markets:changed", event);
    };
  }, [id2]);
  return {
    favoriteTabs,
    favorites,
    recent,
    newListing,
    tabSort,
    selectedFavoriteTab,
    updateFavorites: setFavorites,
    updateFavoriteTabs,
    updateSymbolFavoriteState,
    pinToTop,
    addToHistory,
    updateSelectedFavoriteTab,
    updateTabsSortState
  };
};
var useMarkets = (type = 2) => {
  const { data: futures } = useMarketsStream();
  const symbolsInfo = useSymbolsInfo();
  const [markets, setMarkets] = useState([]);
  const store = useMarketsStore();
  const { favorites, recent, newListing } = store;
  useEffect(() => {
    const markets2 = addFieldToMarkets(futures, symbolsInfo);
    const filterList = filterMarkets({
      markets: markets2,
      favorites,
      recent,
      newListing,
      type
    });
    setMarkets(filterList);
  }, [futures, symbolsInfo, favorites, recent, newListing, type]);
  return [markets, store];
};
var addFieldToMarkets = (futures, symbolsInfo) => {
  var _a2;
  return (_a2 = futures || []) == null ? void 0 : _a2.map((item) => {
    const info = symbolsInfo[item.symbol];
    return {
      ...item,
      quote_dp: info("quote_dp"),
      created_time: info("created_time"),
      leverage: getLeverage(info("base_imr")),
      openInterest: getOpenInterest(item.open_interest, item.index_price),
      "8h_funding": get8hFunding2(item.est_funding_rate, info("funding_period")),
      change: get24hChange2({
        change: item.change,
        close: item["24h_close"],
        open: item["24h_open"]
      })
    };
  });
};
var filterMarkets = (params) => {
  const { markets, favorites, recent, newListing, type } = params;
  let curData = [];
  if (type === 2) {
    curData = markets;
  } else if (type === 3) {
    curData = markets.filter((item) => isNewListing(item.created_time)).sort((a2, b2) => b2.created_time - a2.created_time);
  } else {
    const storageData = type === 0 ? favorites : type === 1 ? recent : newListing;
    const keys = storageData.map((item) => item.name);
    curData = markets == null ? void 0 : markets.filter((item) => keys.includes(item.symbol));
  }
  const favoriteKeys = favorites.map((item) => item.name);
  return curData == null ? void 0 : curData.map((item) => ({
    ...item,
    isFavorite: type === 0 ? true : favoriteKeys.includes(item.symbol)
  }));
};
function isEmpty(value) {
  return value === void 0 || value === null;
}
var isNewListing = (createdTime) => {
  const thirtyDaysInMs = 30 * 24 * 60 * 60 * 1e3;
  const now = Date.now();
  return now - createdTime < thirtyDaysInMs;
};
function get8hFunding2(est_funding_rate, funding_period) {
  let funding8h = 0;
  if (isEmpty(est_funding_rate)) {
    return null;
  }
  if (funding_period) {
    funding8h = new g$6(est_funding_rate || 0).mul(funding_period).div(8).toNumber();
  }
  return funding8h;
}
function get24hChange2(params) {
  const { change, close, open: open2 } = params;
  if (change !== void 0) {
    return change;
  }
  if (!isEmpty(close) && !isEmpty(open2)) {
    if (open2 === 0) {
      return 0;
    }
    return new g$6(close).minus(open2).div(open2).toNumber();
  }
}
function getLeverage(base_imr) {
  return base_imr ? 1 / base_imr : void 0;
}
function getOpenInterest(open_interest, index_price) {
  return new g$6(open_interest || 0).mul(index_price || 0).toNumber();
}
function getDefaultStoreData() {
  return {
    recent: [],
    favorites: [
      { name: "PERP_ETH_USDC", tabs: [{ ...DefaultFavoriteTab }] },
      { name: "PERP_BTC_USDC", tabs: [{ ...DefaultFavoriteTab }] }
    ],
    favoriteTabs: [{ ...DefaultFavoriteTab }],
    selectedFavoriteTab: { ...DefaultFavoriteTab },
    tabSort: {}
  };
}
function filterInvalidTabs(favorites, tabs) {
  return favorites.map((favorite) => {
    return {
      ...favorite,
      tabs: favorite.tabs.filter(
        (tab) => !!tabs.find((item) => item.id === tab.id)
      )
    };
  }).filter((item) => !!item.tabs.length);
}
function updateTabs(favoriteTabs, tab, operator) {
  if (Array.isArray(tab)) {
    return tab;
  }
  const tabs = [...favoriteTabs];
  const index = tabs.findIndex((item) => item.id === tab.id);
  if (operator == null ? void 0 : operator.add) {
    tabs.push(tab);
  } else if ((operator == null ? void 0 : operator.update) && index !== -1) {
    tabs[index] = tab;
  } else if ((operator == null ? void 0 : operator.delete) && index !== -1) {
    tabs.splice(index, 1);
  }
  return tabs;
}
function addToTop(recent, symbol) {
  const list = [...recent];
  const index = list.findIndex((item) => item.name == symbol.symbol);
  if (index !== -1) {
    list.splice(index, 1);
  }
  list.unshift({ name: symbol.symbol });
  return list;
}
function moveToTop(favorites, symbol) {
  const index = favorites.findIndex((item) => item.name === symbol.symbol);
  if (index !== -1) {
    const item = favorites[index];
    const list = [...favorites];
    list.splice(index, 1);
    list.unshift(item);
    return list;
  }
}
function updateSymbolFavorite(params) {
  const { favorites, symbol, tab, remove = false } = params;
  const list = [...favorites];
  const index = list.findIndex((item) => item.name == symbol.symbol);
  const tabs = Array.isArray(tab) ? tab : [tab];
  if (index === -1) {
    if (tabs.length && !remove) {
      list.unshift({ name: symbol.symbol, tabs });
    }
  } else {
    const favorite = list[index];
    if (Array.isArray(tab)) {
      if (!tab.length) {
        list.splice(index, 1);
      } else {
        list[index] = { ...favorite, tabs: tab };
      }
    } else {
      if (remove) {
        const tabs2 = favorite.tabs.filter((item) => item.id != tab.id);
        if (!tabs2.length) {
          list.splice(index, 1);
        } else {
          list[index] = { ...favorite, tabs: tabs2 };
        }
      } else {
        list[index] = { ...favorite, tabs: [...favorite.tabs, tab] };
      }
    }
  }
  return list;
}
function createEventData(id2, key, data) {
  return {
    id: id2,
    key,
    data
  };
}
var useMarkPricesStream = () => {
  const data = useMarkPriceStore((state) => state.markPrices);
  return { data };
};
var useLeverage = () => {
  var _a2;
  const { data, mutate: mutate3 } = usePrivateQuery("/v1/client/info");
  const [update, { isMutating }] = useMutation("/v1/client/leverage");
  const { data: config2 } = useQuery("/v1/public/config", {
    revalidateOnFocus: false
  });
  const updateLeverage = useCallback((data2) => {
    return update(data2).then((res) => {
      if (res.success) {
        return mutate3();
      } else {
        throw new Error(res.message);
      }
    });
  }, []);
  return [
    prop("max_leverage", data),
    {
      update: updateLeverage,
      isMutating,
      // config: [1, 2, 3, 4, 5, 10, 15, 20],
      config: config2 ? (_a2 = config2 == null ? void 0 : config2.available_futures_leverage) == null ? void 0 : _a2.split(",").map((item) => parseInt(item)) : []
    }
  ];
};
var useFundingRate = (symbol) => {
  if (!symbol) {
    throw new SDKError("Symbol is required");
  }
  const [countDown, setCountDown] = useState("00:00:00");
  const { data } = useQuery(
    `/v1/public/funding_rate/${symbol}`,
    {
      fallbackData: {
        est_funding_rate: 0,
        next_funing_time: 0
      }
    }
  );
  useEffect(() => {
    if (!data)
      return;
    const { next_funding_time } = data;
    if (!next_funding_time || next_funding_time <= 0) {
      return;
    }
    const timer = setInterval(() => {
      const diff = new Date(next_funding_time).getTime() - N$3();
      const result = M$5(diff);
      if (result.length === 3) {
        setCountDown(
          `${result[0].toString().padStart(2, "0")}:${result[1].toString().padStart(2, "0")}:${result[2].toString().padStart(2, "0")}`
        );
      }
    }, 1e3);
    return () => {
      clearInterval(timer);
    };
  }, [data]);
  const est_funding_rate = useMemo(() => {
    if (!data)
      return;
    const { next_funding_time, est_funding_rate: est_funding_rate2 = 0 } = data;
    if (N$3() > next_funding_time) {
      return null;
    }
    return new g$6(Number(est_funding_rate2) * 100).toFixed(
      4,
      g$6.ROUND_DOWN
    );
  }, [data]);
  return {
    ...data,
    est_funding_rate,
    countDown
  };
};
var calculatePositiveRate = (periodData, period) => {
  if (!periodData || !period)
    return 0;
  const daysMap = {
    "1d": 1,
    "3d": 3,
    "7d": 7,
    "14d": 14,
    "30d": 30,
    "90d": 90
  };
  const totalTimes = daysMap[period] * 3;
  return periodData.positive / totalTimes;
};
var useFundingRateHistory = () => {
  const {
    data: historyData,
    isLoading,
    ...rest
  } = useQuery("/v1/public/market_info/funding_history");
  return {
    data: historyData ?? [],
    isLoading,
    getPositiveRates: (data, period) => {
      if (!(data == null ? void 0 : data.length))
        return {};
      return data.reduce((acc, item) => {
        acc[item.symbol] = calculatePositiveRate(item.funding[period], period);
        return acc;
      }, {});
    }
  };
};
var findTPSLFromOrders = (orders, symbol) => {
  const order = findPositionTPSLFromOrders(orders, symbol);
  if (!order)
    return;
  return findTPSLFromOrder(order);
};
var findTPSLFromOrder = (order) => {
  var _a2, _b2;
  let tp_trigger_price;
  let sl_trigger_price;
  const tpOrder = (_a2 = order == null ? void 0 : order.child_orders) == null ? void 0 : _a2.find(
    (order2) => order2.algo_type === AlgoOrderType.TAKE_PROFIT
  );
  const slOrder = (_b2 = order == null ? void 0 : order.child_orders) == null ? void 0 : _b2.find(
    (order2) => order2.algo_type === AlgoOrderType.STOP_LOSS
  );
  if (tpOrder) {
    tp_trigger_price = tpOrder.trigger_price;
  }
  if (slOrder) {
    sl_trigger_price = slOrder.trigger_price;
  }
  return {
    tp_trigger_price,
    sl_trigger_price
  };
};
var findPositionTPSLFromOrders = (orders, symbol) => {
  return orders == null ? void 0 : orders.find((order) => {
    return order.symbol === symbol && order.algo_type === AlgoOrderRootType.POSITIONAL_TP_SL && (order.root_algo_status === OrderStatus.NEW || order.root_algo_status === OrderStatus.REPLACED || order.root_algo_status === OrderStatus.PARTIAL_FILLED);
  });
};
var usePositionStream = (symbol = "all", options) => {
  const { calcMode } = options || {};
  const { includedPendingOrder = false } = options || {};
  const positionCalculator = useRef(null);
  const calculatorService = useCalculatorService();
  const [tpslOrders] = useOrderStream(
    {
      symbol: symbol === "all" ? void 0 : symbol,
      status: OrderStatus.INCOMPLETE,
      includes: [AlgoOrderRootType.POSITIONAL_TP_SL, AlgoOrderRootType.TP_SL],
      size: 500
    },
    {
      keeplive: true
    }
  );
  const { positions: positionStatus } = useApiStatusStore(
    (state) => state.apis
  );
  useEffect(() => {
    if (symbol === "all")
      return;
    positionCalculator.current = new PositionCalculator(symbol);
    calculatorService.register(
      "position",
      positionCalculator.current
    );
    calculatorService.register(
      "markPrice",
      positionCalculator.current
    );
    calculatorService.register(
      "indexPrice",
      positionCalculator.current
    );
    return () => {
      calculatorService.unregister(
        "position",
        positionCalculator.current
      );
      calculatorService.unregister(
        "markPrice",
        positionCalculator.current
      );
      calculatorService.unregister(
        "indexPrice",
        positionCalculator.current
      );
    };
  }, [symbol]);
  const formattedPositions = usePositionStore((state) => {
    const positions2 = state.positions[symbol] ?? POSITION_EMPTY;
    return [positions2.rows, omit(["rows"], positions2)];
  });
  const { totalCollateral: totalCollateral2, totalValue: totalValue2, totalUnrealizedROI: totalUnrealizedROI2 } = useAppStore(
    (state) => state.portfolio
  );
  const aggregated = useMemo(() => {
    let data = formattedPositions[1];
    if (!data)
      return {};
    if (calcMode === "markPrice")
      return data;
    const { total_unreal_pnl_index, unrealPnlROI_index, ...rest } = data;
    return {
      ...rest,
      unrealPnL: total_unreal_pnl_index,
      total_unreal_pnl: total_unreal_pnl_index,
      unrealPnlROI: unrealPnlROI_index
    };
  }, [calcMode]);
  let rows = formattedPositions[0];
  {
    if (!rows) {
      rows = [];
    }
    if (!includedPendingOrder) {
      rows = rows.filter((item) => item.position_qty !== 0);
    } else {
      rows = rows.filter(
        (item) => item.position_qty !== 0 || item.pending_long_qty !== 0 || item.pending_short_qty !== 0
      );
    }
    if (calcMode === "lastPrice") {
      rows = rows.map((item) => {
        const {
          unrealized_pnl_index,
          unrealized_pnl_ROI_index,
          ...rust
        } = item;
        return {
          ...rust,
          unrealized_pnl: unrealized_pnl_index ?? 0,
          unsettled_pnl_ROI: unrealized_pnl_ROI_index ?? 0
          // mark_price: item.last_price,
        };
      });
    }
    if (Array.isArray(tpslOrders) && tpslOrders.length) {
      rows = rows.map((item) => {
        const related_order = findPositionTPSLFromOrders(
          tpslOrders,
          item.symbol
        );
        const tp_sl_pricer = !!related_order ? findTPSLFromOrder(related_order) : void 0;
        return {
          ...item,
          tp_trigger_price: tp_sl_pricer == null ? void 0 : tp_sl_pricer.tp_trigger_price,
          sl_trigger_price: tp_sl_pricer == null ? void 0 : tp_sl_pricer.sl_trigger_price,
          algo_order: related_order
        };
      });
    }
  }
  const positionInfoGetter = createGetter(aggregated, 1);
  return [
    {
      rows,
      // rows: formattedPositions[0],
      aggregated: (formattedPositions == null ? void 0 : formattedPositions[1]) ?? {},
      totalCollateral: totalCollateral2,
      totalValue: totalValue2,
      totalUnrealizedROI: totalUnrealizedROI2
    },
    positionInfoGetter,
    {
      /**
       * @deprecated use `isLoading` instead
       */
      loading: positionStatus.loading,
      isLoading: positionStatus.loading
      // isValidating,
      // // showSymbol,
      // error,
      // // loadMore: () => {},
      // refresh: refreshPositions,
    }
  ];
};
pathOr(0, [
  0,
  "aggregated",
  "unsettledPnL"
]);
var useOrderStream = (params, options) => {
  var _a2;
  const {
    status,
    symbol,
    side,
    size = 50,
    page,
    dateRange
  } = params;
  const [includes2, setIncludes] = useState(params.includes ?? ["ALL"]);
  const [excludes, setExcludes] = useState(params.excludes ?? []);
  const { data: markPrices } = useMarkPricesStream();
  const { registerKeyHandler, unregisterKeyHandler } = useDataCenterContext();
  const [
    doCancelOrder,
    { error: cancelOrderError, isMutating: cancelMutating }
  ] = useMutation("/v1/order", "DELETE");
  const [doCancelAllOrders] = useMutation("/v1/orders", "DELETE");
  const [
    doUpdateOrder,
    { error: updateOrderError, isMutating: updateMutating }
  ] = useMutation("/v1/order", "PUT");
  const [
    doCancelAlgolOrder,
    { error: cancelAlgoOrderError, isMutating: cancelAlgoMutating }
  ] = useMutation("/v1/algo/order", "DELETE");
  const [doCancelAllAlgoOrders] = useMutation("/v1/algo/orders", "DELETE");
  const [
    doUpdateAlgoOrder,
    { error: updateAlgoOrderError, isMutating: updateAlgoMutating }
  ] = useMutation("/v1/algo/order", "PUT");
  useEffect(() => {
    const formatKey = (value) => value ? `:${value}` : "";
    const key = `orders${formatKey(status)}${formatKey(symbol)}${formatKey(
      side
    )}${formatKey(size.toString())}`;
    registerKeyHandler == null ? void 0 : registerKeyHandler(
      key,
      generateKeyFun({ status, symbol, side, size, page, dateRange })
    );
    return () => {
      if (!(options == null ? void 0 : options.stopOnUnmount))
        return;
      unregisterKeyHandler(key);
    };
  }, [status, symbol, side, size, page, dateRange, options == null ? void 0 : options.keeplive]);
  const ordersResponse = usePrivateInfiniteQuery(
    generateKeyFun({ status, symbol, side, size, page, dateRange }),
    {
      initialSize: 1,
      // revalidateFirstPage: false,
      // onError: (err) => {
      //   console.error("fetch failed::::", err);
      // },
      formatter: (data) => data,
      revalidateOnFocus: false
    }
  );
  const flattenOrders = useMemo(() => {
    var _a3, _b2;
    if (!ordersResponse.data) {
      return null;
    }
    let orders2 = (_b2 = (_a3 = ordersResponse.data) == null ? void 0 : _a3.map((item) => item.rows)) == null ? void 0 : _b2.flat();
    if (includes2.includes("ALL") && excludes.length === 0) {
      return orders2;
    }
    if (includes2.includes("ALL") && excludes.length > 0) {
      return orders2 == null ? void 0 : orders2.filter((item) => !excludes.includes(item.algo_type));
    }
    if (includes2.length > 0 && excludes.length === 0) {
      return orders2 == null ? void 0 : orders2.filter((item) => includes2.includes(item.algo_type));
    }
    if (includes2.length > 0 && excludes.length > 0) {
      return orders2 == null ? void 0 : orders2.filter(
        (item) => includes2.includes(item.algo_type) && !excludes.includes(item.algo_type)
      );
    }
    return orders2;
  }, [ordersResponse.data, includes2, excludes]);
  const orders = useMemo(() => {
    if (!flattenOrders) {
      return null;
    }
    if (status !== OrderStatus.NEW && status !== OrderStatus.INCOMPLETE) {
      return flattenOrders;
    }
    return flattenOrders.map((item) => {
      const order = {
        ...item,
        mark_price: (markPrices ?? {})[item.symbol] ?? 0
      };
      if (order.algo_type === AlgoOrderRootType.POSITIONAL_TP_SL || order.algo_type === AlgoOrderRootType.TP_SL) {
        order.quantity = order.child_orders[0].quantity;
      }
      return order;
    });
  }, [flattenOrders, markPrices, status]);
  const total = useMemo(() => {
    return (orders == null ? void 0 : orders.length) || 0;
  }, [orders == null ? void 0 : orders.length]);
  const cancelAlgoOrdersByTypes = (types) => {
    if (!types) {
      throw new SDKError("Types is required");
    }
    if (!Array.isArray(types)) {
      throw new SDKError("Types should be an array");
    }
    return Promise.all(
      types.map((type) => {
        return doCancelAllAlgoOrders(null, { algo_type: type });
      })
    );
  };
  const cancelAllOrders = useCallback(() => {
    return Promise.all([
      doCancelAllOrders(null),
      doCancelAllAlgoOrders(null, { algo_type: "STOP" })
    ]);
  }, [ordersResponse.data]);
  const cancelAllTPSLOrders = useCallback(() => {
    return cancelAlgoOrdersByTypes([
      AlgoOrderRootType.POSITIONAL_TP_SL,
      AlgoOrderRootType.TP_SL
    ]);
  }, [ordersResponse.data]);
  const _updateOrder = useCallback(
    (orderId, order, type) => {
      switch (type) {
        case "algoOrder":
          return doUpdateAlgoOrder({
            order_id: orderId,
            price: order["order_price"],
            quantity: order["order_quantity"],
            trigger_price: order["trigger_price"]
          });
        default:
          return doUpdateOrder({ ...order, order_id: orderId });
      }
    },
    []
  );
  const updateOrder = useCallback((orderId, order) => {
    return _updateOrder(orderId, order, "normalOrder");
  }, []);
  const updateAlgoOrder = useCallback((orderId, order) => {
    return _updateOrder(orderId, order, "algoOrder");
  }, []);
  const _cancelOrder = useCallback(
    (orderId, type, symbol2) => {
      switch (type) {
        case "algoOrder":
          return doCancelAlgolOrder(null, {
            // @ts-ignore
            order_id: orderId,
            symbol: symbol2,
            source: `SDK${version_default}`
          }).then((res) => {
            if (res.success) {
              ordersResponse.mutate();
              return res;
            } else {
              throw new Error(res.message);
            }
          });
        default:
          return doCancelOrder(null, {
            order_id: orderId,
            symbol: symbol2,
            source: `SDK_${version_default}`
          }).then((res) => {
            if (res.success) {
              return res;
            } else {
              throw new Error(res.message);
            }
          });
      }
    },
    []
  );
  const cancelOrder = useCallback((orderId, symbol2) => {
    return _cancelOrder(orderId, "normalOrder", symbol2);
  }, []);
  const cancelAlgoOrder = useCallback((orderId, symbol2) => {
    return _cancelOrder(orderId, "algoOrder", symbol2);
  }, []);
  const loadMore = () => {
    ordersResponse.setSize(ordersResponse.size + 1);
  };
  const cancelTPSLChildOrder = useCallback(
    (orderId, rootAlgoOrderId) => {
      return doUpdateAlgoOrder({
        order_id: rootAlgoOrderId,
        child_orders: [
          {
            order_id: orderId,
            is_activated: false
          }
        ]
      });
    },
    []
  );
  const updateTPSLOrder = useCallback(
    (orderId, childOrders) => {
      if (!Array.isArray(childOrders)) {
        throw new SDKError("Children orders is required");
      }
      return doUpdateAlgoOrder({
        order_id: orderId,
        child_orders: childOrders
      });
    },
    []
  );
  const meta2 = useMemo(() => {
    var _a3, _b2;
    return (_b2 = (_a3 = ordersResponse.data) == null ? void 0 : _a3[0]) == null ? void 0 : _b2.meta;
  }, [(_a2 = ordersResponse.data) == null ? void 0 : _a2[0]]);
  return [
    orders,
    {
      total,
      isLoading: ordersResponse.isLoading,
      refresh: ordersResponse.mutate,
      loadMore,
      cancelAllOrders,
      cancelAllTPSLOrders,
      cancelAlgoOrdersByTypes,
      updateOrder,
      cancelOrder,
      updateAlgoOrder,
      cancelAlgoOrder,
      cancelTPSLChildOrder,
      updateTPSLOrder,
      meta: meta2,
      errors: {
        cancelOrder: cancelOrderError,
        updateOrder: updateOrderError,
        cancelAlgoOrder: cancelAlgoOrderError,
        updateAlgoOrder: updateAlgoOrderError
      },
      submitting: {
        cancelOrder: cancelMutating,
        updateOrder: updateMutating,
        cancelAlgoOrder: cancelAlgoMutating,
        updateAlglOrder: updateAlgoMutating
      }
    }
  ];
};
var useMarketTradeStream = (symbol, options = {}) => {
  if (!symbol) {
    throw new SDKError("Symbol is required");
  }
  const [trades, setTrades] = useState([]);
  const [isLoading, setIsLoading] = useState(false);
  const { limit = 50 } = options;
  const ws2 = useWS();
  useEffect(() => {
    setIsLoading(true);
    setTrades(() => []);
    ws2.onceSubscribe(
      {
        id: `${symbol}@trade`,
        event: "request",
        params: {
          type: "trade",
          symbol,
          limit
        }
      },
      {
        onMessage: (data) => {
          setIsLoading(false);
          setTrades(() => data);
        }
      }
    );
  }, [symbol]);
  useEffect(() => {
    const unsubscript = ws2.subscribe(
      {
        id: `${symbol}@trade`,
        event: "subscribe",
        topic: `${symbol}@trade`,
        ts: N$3()
      },
      {
        onMessage: (data) => {
          setTrades((prev) => {
            const arr = [{ ...data, ts: N$3() }, ...prev];
            if (arr.length > limit) {
              arr.pop();
            }
            return arr;
          });
        }
      }
    );
    return () => {
      unsubscript == null ? void 0 : unsubscript();
    };
  }, [symbol]);
  return { data: trades, isLoading };
};
var useCollateral = (options = { dp: 6 }) => {
  const { dp } = options;
  const {
    totalCollateral: totalCollateral2,
    totalValue: totalValue2,
    freeCollateral: freeCollateral2,
    availableBalance: availableBalance2,
    unsettledPnL
  } = useAppStore((state) => state.portfolio);
  const accountInfo = useAppStore((state) => state.accountInfo);
  return {
    totalCollateral: totalCollateral2.toDecimalPlaces(dp).toNumber(),
    freeCollateral: freeCollateral2.toDecimalPlaces(dp).toNumber(),
    totalValue: (totalValue2 == null ? void 0 : totalValue2.toDecimalPlaces(dp).toNumber()) ?? null,
    availableBalance: availableBalance2,
    unsettledPnL,
    accountInfo
    // @hidden
    // positions: positionsPath(positions),
  };
};
var useMaxQty = (symbol, side, reduceOnly = false) => {
  const positions2 = usePositions();
  const [orders] = useOrderStream({ status: OrderStatus.NEW, size: 500 });
  const accountInfo = useAccountInfo();
  const symbolInfo = useSymbolsInfo();
  const { totalCollateral: totalCollateral2 } = useCollateral();
  const { data: markPrices } = useMarkPricesStream();
  const maxQty2 = useMemo(() => {
    if (!symbol)
      return 0;
    const positionQty = account_exports.getQtyFromPositions(
      positions2 === null ? [] : positions2,
      symbol
    );
    if (reduceOnly) {
      if (positionQty > 0) {
        if (side === OrderSide.BUY) {
          return 0;
        } else {
          return Math.abs(positionQty);
        }
      }
      if (positionQty < 0) {
        if (side === OrderSide.BUY) {
          return Math.abs(positionQty);
        } else {
          return 0;
        }
      }
      return 0;
    }
    if (!markPrices || !markPrices[symbol] || !orders || !accountInfo)
      return 0;
    const getSymbolInfo = symbolInfo[symbol];
    const filterAlgoOrders = orders.filter(
      (item) => item.algo_order_id === void 0 || item.algo_type === "BRACKET"
    );
    const buyOrdersQty = account_exports.getQtyFromOrdersBySide(
      filterAlgoOrders,
      symbol,
      OrderSide.BUY
    );
    const sellOrdersQty = account_exports.getQtyFromOrdersBySide(
      filterAlgoOrders,
      symbol,
      OrderSide.SELL
    );
    const otherPositions = !Array.isArray(positions2) ? [] : positions2.filter((item) => item.symbol !== symbol);
    const otherOrders = filterAlgoOrders.filter(
      (item) => item.symbol !== symbol
    );
    const otherIMs2 = account_exports.otherIMs({
      orders: otherOrders,
      positions: otherPositions,
      symbolInfo,
      markPrices,
      IMR_Factors: accountInfo.imr_factor,
      maxLeverage: accountInfo.max_leverage
    });
    return account_exports.maxQty(side, {
      markPrice: markPrices[symbol],
      symbol,
      baseMaxQty: getSymbolInfo("base_max"),
      totalCollateral: totalCollateral2,
      maxLeverage: accountInfo.max_leverage,
      takerFeeRate: accountInfo.futures_taker_fee_rate,
      baseIMR: getSymbolInfo("base_imr"),
      otherIMs: otherIMs2,
      positionQty,
      buyOrdersQty,
      sellOrdersQty,
      IMR_Factor: accountInfo.imr_factor[symbol]
    });
  }, [
    symbol,
    positions2,
    reduceOnly,
    markPrices,
    orders,
    accountInfo,
    symbolInfo,
    side,
    totalCollateral2
  ]);
  return Math.max(maxQty2, 0);
};
var useMarginRatio = () => {
  const positions2 = usePositionStore((state2) => state2.positions.all);
  const { rows } = positions2;
  const { notional: notional2 } = positions2;
  const { state } = useAccount();
  const { data: markPrices } = useMarkPricesStream();
  const { totalCollateral: totalCollateral2 } = useCollateral();
  const marginRatio = useMemo(() => {
    if (!rows || !markPrices || !totalCollateral2 || rows.length === 0) {
      return 0;
    }
    return account_exports.totalMarginRatio({
      totalCollateral: totalCollateral2,
      markPrices,
      positions: rows ?? []
    });
  }, [rows, markPrices, totalCollateral2]);
  const currentLeverage2 = useMemo(() => {
    if (state.status >= AccountStatusEnum.EnableTrading || state.status === AccountStatusEnum.EnableTradingWithoutConnected) {
      return account_exports.currentLeverage(marginRatio);
    }
    return null;
  }, [marginRatio, state.status]);
  const mmr = useMemo(() => {
    if (!rows || rows.length <= 0 || notional2 == null)
      return null;
    let positionsMM = y$3;
    for (let index = 0; index < rows.length; index++) {
      const item = rows[index];
      if (item.mm !== null) {
        positionsMM = positionsMM.add(item.mm);
      }
    }
    return account_exports.MMR({
      positionsMMR: positionsMM.toNumber(),
      positionsNotional: notional2
    });
  }, [rows, notional2]);
  return { marginRatio, currentLeverage: currentLeverage2, mmr };
};
var TestNetWhiteList = [421614, 901901901, MONAD_TESTNET_CHAINID];
function useChains(networkId, options = {}) {
  const { pick: pickField, ...swrOptions } = options;
  const {
    filteredChains: allowedChains,
    configStore,
    customChains
  } = useContext(OrderlyContext);
  const filterFun = useRef(options == null ? void 0 : options.filter);
  filterFun.current = options == null ? void 0 : options.filter;
  const chainsMap = useRef(/* @__PURE__ */ new Map());
  const commonSwrOpts = {
    revalidateIfStale: false,
    revalidateOnFocus: false,
    revalidateOnReconnect: false,
    // If false, undefined data gets cached against the key.
    revalidateOnMount: true,
    // dont duplicate a request w/ same key for 1hr
    dedupingInterval: 36e5,
    ...swrOptions
  };
  const { data: tokenChainsRes, error: tokenError } = useQuery(
    "https://api.orderly.org/v1/public/token",
    { ...commonSwrOpts }
  );
  const { data: testTokenChainsRes } = useQuery(
    "https://testnet-api.orderly.org/v1/public/token",
    {
      ...commonSwrOpts,
      fallbackData: TesntTokenFallback([
        ArbitrumSepoliaTokenInfo,
        SolanaDevnetTokenInfo
      ])
    }
  );
  const brokerId = configStore.get("brokerId");
  const needFetchFromAPI = options.forceAPI || !customChains;
  const { data: chainInfos, error: chainInfoErr } = useQuery(
    needFetchFromAPI ? `https://api.orderly.org/v1/public/chain_info${brokerId !== "orderly" ? `?broker_id=${brokerId}` : ""}` : null,
    { ...commonSwrOpts }
  );
  const { data: testChainInfos, error: testChainInfoError } = useQuery(
    needFetchFromAPI ? `https://testnet-api.orderly.org/v1/public/chain_info${brokerId !== "orderly" ? `?broker_id=${brokerId}` : ""}` : null,
    {
      ...commonSwrOpts,
      fallbackData: [ArbitrumSepoliaChainInfo, SolanaDevnetChainInfo],
      onError: (error) => {
      }
    }
  );
  const chains = useMemo(() => {
    const tokenChains = fillChainsInfo(
      tokenChainsRes,
      filterFun.current,
      chainInfos
    );
    const testTokenChains = fillChainsInfo(
      testTokenChainsRes,
      void 0,
      testChainInfos
    );
    let testnetArr = needFetchFromAPI ? filterAndUpdateChains(testTokenChains, testChainInfos, void 0, true) : customChains == null ? void 0 : customChains.testnet;
    tokenChains == null ? void 0 : tokenChains.forEach((item) => {
      var _a2;
      const chainId = (_a2 = item.network_infos) == null ? void 0 : _a2.chain_id;
      chainsMap.current.set(chainId, item);
    });
    testnetArr.forEach((chain) => {
      var _a2;
      chainsMap.current.set((_a2 = chain.network_infos) == null ? void 0 : _a2.chain_id, chain);
    });
    let mainnetArr = [];
    mainnetArr = filterAndUpdateChains(
      tokenChains,
      chainInfos,
      filterFun.current
    );
    mainnetArr = needFetchFromAPI ? mainnetArr : customChains == null ? void 0 : customChains.mainnet;
    mainnetArr.forEach((item) => {
      var _a2;
      const chainId = (_a2 = item.network_infos) == null ? void 0 : _a2.chain_id;
      chainsMap.current.set(chainId, item);
    });
    mainnetArr = filterByAllowedChains(mainnetArr, allowedChains == null ? void 0 : allowedChains.mainnet);
    testnetArr = filterByAllowedChains(
      testnetArr,
      (allowedChains == null ? void 0 : allowedChains.testnet) ?? TestNetWhiteList.map((id2) => ({ id: id2 }))
    );
    if (!!pickField) {
      testnetArr = testnetArr.map((item) => item[pickField]);
      mainnetArr = mainnetArr.map((item) => item[pickField]);
    }
    if (networkId === "mainnet") {
      return mainnetArr;
    }
    if (networkId === "testnet") {
      return testnetArr;
    }
    return {
      testnet: testnetArr,
      mainnet: mainnetArr
    };
  }, [
    networkId,
    tokenChainsRes,
    chainInfos,
    testChainInfos,
    testTokenChainsRes,
    customChains,
    pickField,
    allowedChains
  ]);
  const findByChainId = useCallback(
    (chainId, field) => {
      var _a2, _b2;
      const chain = chainsMap.current.get(chainId);
      if (chain) {
        chain.nativeToken = ((_a2 = chain.token_infos) == null ? void 0 : _a2.find(
          (item) => item.address === nativeTokenAddress
        )) || {
          symbol: (_b2 = chain.network_infos) == null ? void 0 : _b2.currency_symbol
        };
      }
      if (typeof field === "string") {
        return prop(field, chain);
      }
      return chain;
    },
    [chains, chainsMap]
  );
  const checkChainSupport = useCallback(
    (chainId, networkId2) => {
      const _chains = Array.isArray(chains) ? chains : chains[networkId2];
      return _checkChainSupport(chainId, _chains);
    },
    [chains]
  );
  return [
    chains,
    {
      findByChainId,
      checkChainSupport,
      error: tokenError
    }
  ];
}
function _checkChainSupport(chainId, chains) {
  if (typeof chainId === "string") {
    chainId = parseInt(chainId);
  }
  return chains.some((chain) => {
    return chain.network_infos.chain_id === chainId;
  });
}
function fillChainsInfo(chains, filter, chainInfos) {
  let _chains = [];
  chains == null ? void 0 : chains.forEach((item) => {
    item.chain_details.forEach((chain) => {
      const chainId = Number(chain.chain_id);
      const chainInfo = chainInfos == null ? void 0 : chainInfos.find(
        (item2) => item2.chain_id == chainId
      );
      const _chain = {
        network_infos: {
          name: chain.chain_name ?? (chainInfo == null ? void 0 : chainInfo.name) ?? "--",
          chain_id: chainId,
          withdrawal_fee: chain.withdrawal_fee,
          cross_chain_withdrawal_fee: chain.cross_chain_withdrawal_fee,
          bridgeless: true
        },
        token_infos: [
          {
            symbol: item.token,
            address: chain.contract_address,
            decimals: chain.decimals,
            display_name: chain.display_name
          }
        ]
      };
      if (typeof filter === "function") {
        if (!filter(_chain))
          return;
      }
      _chains.push(_chain);
    });
  });
  return _chains;
}
function filterAndUpdateChains(chains, chainInfos, filter, isTestNet) {
  const filterChains = [];
  chains.forEach((chain) => {
    let _chain = { ...chain };
    const networkInfo = chainInfos == null ? void 0 : chainInfos.find(
      (item) => item.chain_id == chain.network_infos.chain_id
    );
    if (networkInfo) {
      const { name, public_rpc_url, currency_symbol, explorer_base_url } = networkInfo;
      _chain.network_infos = {
        ..._chain.network_infos,
        name,
        shortName: name,
        public_rpc_url,
        currency_symbol,
        bridge_enable: true,
        mainnet: !isTestNet,
        explorer_base_url
        // est_txn_mins: null,
      };
    }
    if (typeof filter === "function") {
      if (!filter(_chain))
        return;
    }
    if (networkInfo) {
      filterChains.push(_chain);
    }
  });
  return filterChains;
}
function filterByAllowedChains(chains, allowedChains) {
  if (!allowedChains) {
    return chains;
  }
  return chains.filter(
    (chain) => allowedChains.some(
      (allowedChain) => {
        var _a2;
        return allowedChain.id === parseInt((_a2 = chain == null ? void 0 : chain.network_infos) == null ? void 0 : _a2.chain_id);
      }
    )
  );
}
function useStorageChain() {
  const [chain, setChain] = useLocalStorage(ChainKey, null);
  const setStorageChain = (chainId) => {
    let namespace = ChainNamespace.evm;
    if (SolanaChains$1.has(chainId)) {
      namespace = ChainNamespace.solana;
    }
    setChain({
      chainId,
      namespace
    });
  };
  return {
    storageChain: chain,
    setStorageChain
  };
}
var useHoldingStream = () => {
  const ws2 = useWS();
  const { data, isLoading, mutate: mutate3 } = usePrivateQuery(
    "/v1/client/holding",
    {
      formatter: (data2) => {
        return data2.holding;
      }
    }
  );
  const usdc = useMemo(() => {
    const usdc2 = data == null ? void 0 : data.find((item) => item.token === "USDC");
    return usdc2;
  }, [data]);
  useSWRSubscription("holding", (_2, { next }) => {
    const unsubscribe = ws2.privateSubscribe(
      {
        id: "balance",
        event: "subscribe",
        topic: "balance",
        ts: N$3()
      },
      {
        onMessage: (data2) => {
          const holding = (data2 == null ? void 0 : data2.balances) ?? {};
          if (holding) {
            mutate3((prevData) => {
              return prevData == null ? void 0 : prevData.map((item) => {
                const token = holding[item.token];
                return {
                  ...item,
                  frozen: token.frozen,
                  holding: token.holding
                };
              });
            });
            next(holding);
          }
        }
      }
    );
    return () => unsubscribe();
  });
  return {
    data,
    usdc,
    isLoading
  };
};
var useWithdraw = (options) => {
  const { account: account5, state } = useAccount();
  const [isLoading, setIsLoading] = useState(false);
  const { unsettledPnL, availableBalance: availableBalance2, freeCollateral: freeCollateral2 } = useCollateral();
  const networkId = useConfig("networkId");
  const [_2, { findByChainId }] = useChains(void 0);
  const ee2 = useEventEmitter();
  const { track: track2 } = useTrack();
  useHoldingStream();
  const maxAmount = useMemo(() => {
    return freeCollateral2;
  }, [freeCollateral2]);
  const availableWithdraw = useMemo(() => {
    if (unsettledPnL < 0) {
      return freeCollateral2;
    } else {
      return freeCollateral2 - unsettledPnL;
    }
  }, [freeCollateral2, unsettledPnL]);
  const targetChain = useMemo(() => {
    var _a2;
    let chain;
    if (networkId === "testnet") {
      chain = findByChainId(
        B$7(options == null ? void 0 : options.srcChainId) ? options == null ? void 0 : options.srcChainId : ARBITRUM_TESTNET_CHAINID
      );
    } else {
      chain = findByChainId(options == null ? void 0 : options.srcChainId);
      if (!((_a2 = chain == null ? void 0 : chain.network_infos) == null ? void 0 : _a2.bridgeless)) {
        chain = findByChainId(ARBITRUM_MAINNET_CHAINID);
      }
    }
    return chain;
  }, [networkId, findByChainId, options == null ? void 0 : options.srcChainId]);
  const dst = useMemo(() => {
    var _a2, _b2;
    const USDC = targetChain == null ? void 0 : targetChain.token_infos.find(
      (token) => token.symbol === "USDC"
    );
    return {
      symbol: (USDC == null ? void 0 : USDC.display_name) || "USDC",
      decimals: (USDC == null ? void 0 : USDC.decimals) || 6,
      address: USDC == null ? void 0 : USDC.address,
      chainId: (_a2 = targetChain == null ? void 0 : targetChain.network_infos) == null ? void 0 : _a2.chain_id,
      network: (_b2 = targetChain == null ? void 0 : targetChain.network_infos) == null ? void 0 : _b2.shortName
    };
  }, [targetChain]);
  const withdraw = useCallback(
    (inputs) => {
      return account5.assetsManager.withdraw(inputs).then((res) => {
        var _a2;
        if (res.success) {
          ee2.emit(EnumTrackerKeys.withdrawSuccess, {
            wallet: (_a2 = state == null ? void 0 : state.connectWallet) == null ? void 0 : _a2.name,
            network: targetChain == null ? void 0 : targetChain.network_infos.name,
            quantity: inputs.amount
          });
        }
        return res;
      }).catch((err) => {
        var _a2;
        track2(EnumTrackerKeys.withdrawFailed, {
          wallet: (_a2 = state == null ? void 0 : state.connectWallet) == null ? void 0 : _a2.name,
          network: targetChain == null ? void 0 : targetChain.network_infos.name,
          msg: JSON.stringify(err)
        });
        throw err;
      });
    },
    [state, targetChain, state]
  );
  return {
    dst,
    withdraw,
    isLoading,
    maxAmount,
    availableBalance: availableBalance2,
    availableWithdraw,
    unsettledPnL
  };
};
var useDeposit = (options) => {
  const networkId = useConfig("networkId");
  const [balanceRevalidating, setBalanceRevalidating] = useState(false);
  const [allowanceRevalidating, setAllowanceRevalidating] = useState(false);
  useEventEmitter();
  const [_2, { findByChainId }] = useChains(void 0);
  const [quantity, setQuantity] = useState("");
  const [depositFee, setDepositFee] = useState(0n);
  const [depositFeeRevalidating, setDepositFeeRevalidating] = useState(false);
  const [balance, setBalance] = useState("0");
  const [allowance, setAllowance] = useState("0");
  const { account: account5, state } = useAccount();
  const { track: track2 } = useTrack();
  const prevAddress = useRef();
  const getBalanceListener = useRef();
  const targetChain = useMemo(() => {
    var _a2;
    let chain;
    if (networkId === "testnet") {
      chain = findByChainId(
        B$7(options == null ? void 0 : options.srcChainId) ? options == null ? void 0 : options.srcChainId : ARBITRUM_TESTNET_CHAINID
      );
    } else {
      chain = findByChainId(options == null ? void 0 : options.srcChainId);
      if (!((_a2 = chain == null ? void 0 : chain.network_infos) == null ? void 0 : _a2.bridgeless)) {
        chain = findByChainId(ARBITRUM_MAINNET_CHAINID);
      }
    }
    return chain;
  }, [networkId, findByChainId, options == null ? void 0 : options.srcChainId]);
  const dst = useMemo(() => {
    var _a2, _b2;
    const USDC = targetChain == null ? void 0 : targetChain.token_infos.find(
      (token) => token.symbol === "USDC"
    );
    return {
      symbol: "USDC",
      address: USDC == null ? void 0 : USDC.address,
      decimals: USDC == null ? void 0 : USDC.decimals,
      chainId: (_a2 = targetChain == null ? void 0 : targetChain.network_infos) == null ? void 0 : _a2.chain_id,
      network: (_b2 = targetChain == null ? void 0 : targetChain.network_infos) == null ? void 0 : _b2.shortName
    };
  }, [targetChain]);
  const isNativeToken = useMemo(
    () => isNativeTokenChecker((options == null ? void 0 : options.address) || ""),
    [options == null ? void 0 : options.address]
  );
  const fetchBalanceHandler = useCallback(
    async (address, decimals) => {
      let balance2;
      if (!!address && isNativeTokenChecker(address)) {
        balance2 = await account5.assetsManager.getNativeBalance({
          decimals
        });
      } else {
        balance2 = await account5.assetsManager.getBalance(address, { decimals });
      }
      return balance2;
    },
    []
  );
  const fetchBalance = useCallback(
    async (address, decimals) => {
      if (!address)
        return;
      try {
        const balance2 = await fetchBalanceHandler(address, decimals);
        setBalance(() => balance2);
      } catch (e3) {
        setBalance(() => "0");
      }
    },
    [state]
  );
  const fetchBalances = useCallback(async (tokens) => {
    const tasks = [];
    for (const token of tokens) {
      if (isNativeTokenChecker(token.address)) {
        continue;
      }
      tasks.push(
        account5.assetsManager.getBalanceByAddress(token.address, {
          decimals: token == null ? void 0 : token.decimals
        })
      );
    }
    await Promise.all(tasks);
  }, []);
  const getAllowance = async (inputs) => {
    const { address, vaultAddress, decimals } = inputs;
    const key = `${address}-${vaultAddress}`;
    if (prevAddress.current === key)
      return;
    if (!address || !vaultAddress)
      return;
    if (address && isNativeTokenChecker(address))
      return;
    prevAddress.current = key;
    const allowance2 = await account5.assetsManager.getAllowance({
      address,
      vaultAddress,
      decimals
    });
    setAllowance(() => allowance2);
    return allowance2;
  };
  const getAllowanceByDefaultAddress = async (inputs) => {
    const { address, decimals } = inputs;
    if (prevAddress.current === address)
      return;
    if (!address || isNativeTokenChecker(address))
      return;
    prevAddress.current = address;
    const allowance2 = await account5.assetsManager.getAllowance({
      address,
      decimals
    });
    setAllowance(() => allowance2);
  };
  const queryBalance = useDebouncedCallback(
    (address, decimals) => {
      fetchBalance(address, decimals).finally(() => {
        setBalanceRevalidating(false);
      });
    },
    100
  );
  const queryAllowance = useDebouncedCallback(
    (inputs) => {
      getAllowance(inputs);
    },
    100
  );
  useEffect(() => {
    var _a2;
    if (state.status < AccountStatusEnum.Connected)
      return;
    setBalanceRevalidating(true);
    queryBalance(options == null ? void 0 : options.address, options == null ? void 0 : options.decimals);
    const params = {
      address: options == null ? void 0 : options.address,
      decimals: options == null ? void 0 : options.decimals
    };
    if (((_a2 = account5.walletAdapter) == null ? void 0 : _a2.chainNamespace) === ChainNamespace.solana) {
      setAllowance(account5.walletAdapter.formatUnits(MaxUint256));
      return;
    }
    if (dst.chainId !== (options == null ? void 0 : options.srcChainId)) {
      queryAllowance(params);
    } else {
      if (dst.symbol !== (options == null ? void 0 : options.srcToken)) {
        queryAllowance(params);
      } else {
        getAllowanceByDefaultAddress(params);
      }
    }
  }, [
    state.status,
    options == null ? void 0 : options.address,
    options == null ? void 0 : options.srcChainId,
    options == null ? void 0 : options.srcToken,
    options == null ? void 0 : options.decimals,
    account5.address,
    dst.chainId,
    dst.symbol
  ]);
  const updateAllowanceWhenTxSuccess = useCallback(
    (txHash) => {
      var _a2;
      return (_a2 = account5.walletAdapter) == null ? void 0 : _a2.pollTransactionReceiptWithBackoff(txHash).then((receipt) => {
        if (receipt.status === 1) {
          account5.assetsManager.getAllowance({ address: options == null ? void 0 : options.address }).then((allowance2) => {
            setAllowance(() => allowance2);
          });
        }
      });
    },
    [account5, options == null ? void 0 : options.address]
  );
  const approve = useCallback(
    async (amount) => {
      if (!(options == null ? void 0 : options.address)) {
        throw new SDKError("Address is required");
      }
      return account5.assetsManager.approve({
        address: options.address,
        amount
      }).then((res) => {
        return updateAllowanceWhenTxSuccess(res.hash);
      }).catch((e3) => {
      });
    },
    [account5, getAllowance, options == null ? void 0 : options.address, dst]
  );
  const deposit = useCallback(async () => {
    if (!(options == null ? void 0 : options.address)) {
      throw new SDKError("Address is required");
    }
    const _allowance = await account5.assetsManager.getAllowance({
      address: options == null ? void 0 : options.address
    });
    setAllowance(() => _allowance);
    if (new g$6(quantity).greaterThan(_allowance)) {
      throw new SDKError("Insufficient allowance");
    }
    return account5.assetsManager.deposit(quantity, depositFee).then((res) => {
      var _a2;
      track2(EnumTrackerKeys.depositSuccess, {
        wallet: (_a2 = state == null ? void 0 : state.connectWallet) == null ? void 0 : _a2.name,
        network: targetChain == null ? void 0 : targetChain.network_infos.name,
        quantity
      });
      updateAllowanceWhenTxSuccess(res.hash);
      setBalance((value) => new g$6(value).sub(quantity).toString());
      return res;
    }).catch((e3) => {
      var _a2, _b2;
      track2(EnumTrackerKeys.depositFailed, {
        wallet: (_a2 = state == null ? void 0 : state.connectWallet) == null ? void 0 : _a2.name,
        network: (_b2 = targetChain == null ? void 0 : targetChain.network_infos) == null ? void 0 : _b2.name,
        msg: JSON.stringify(e3)
      });
      throw e3;
    });
  }, [account5, fetchBalance, quantity, depositFee, options == null ? void 0 : options.address]);
  const loopGetBalance = async () => {
    var _a2;
    getBalanceListener.current && clearTimeout(getBalanceListener.current);
    const time = ((_a2 = account5.walletAdapter) == null ? void 0 : _a2.chainNamespace) === ChainNamespace.solana ? 1e4 : 3e3;
    getBalanceListener.current = setTimeout(async () => {
      try {
        const balance2 = await fetchBalanceHandler(
          options == null ? void 0 : options.address,
          options == null ? void 0 : options.decimals
        );
        setBalance(balance2);
        loopGetBalance();
      } catch (err) {
      }
    }, time);
  };
  const getDepositFee = useCallback(
    async (quantity2) => {
      return account5.assetsManager.getDepositFee(
        quantity2,
        targetChain == null ? void 0 : targetChain.network_infos
      );
    },
    [account5, targetChain]
  );
  const enquiryDepositFee = useCallback(() => {
    if (isNaN(Number(quantity)) || !quantity || Number(quantity) === 0) {
      setDepositFee(0n);
      setDepositFeeRevalidating(false);
      return;
    }
    setDepositFeeRevalidating(true);
    getDepositFee(quantity).then((res = 0n) => {
      const fee = BigInt(
        new g$6(res.toString()).mul(DEPOSIT_FEE_RATE).toFixed(0, g$6.ROUND_UP).toString()
      );
      setDepositFee(fee);
    }).catch((error) => {
    }).finally(() => {
      setDepositFeeRevalidating(false);
    });
  }, [quantity]);
  useEffect(() => {
    enquiryDepositFee();
  }, [quantity]);
  useEffect(() => {
    if (!(options == null ? void 0 : options.address)) {
      return;
    }
    loopGetBalance();
    return () => {
      getBalanceListener.current && clearTimeout(getBalanceListener.current);
    };
  }, [options == null ? void 0 : options.address, options == null ? void 0 : options.decimals]);
  return {
    /** orderly support chain dst */
    dst,
    balance,
    allowance,
    isNativeToken,
    balanceRevalidating,
    allowanceRevalidating,
    /** input quantiy */
    quantity,
    /** orderly deposit fee, unit: wei */
    depositFee,
    /** enquiring depositFee status on chain */
    depositFeeRevalidating,
    approve,
    deposit,
    fetchBalances,
    fetchBalance: fetchBalanceHandler,
    /** set input quantity */
    setQuantity
  };
};
var useWalletSubscription = (options) => {
  const ws2 = useWS();
  return useSWRSubscription("wallet", (_2, { next }) => {
    const unsubscribe = ws2.privateSubscribe(
      {
        id: "wallet",
        event: "subscribe",
        topic: "wallet",
        ts: Date.now()
      },
      {
        onMessage: (data) => {
          var _a2;
          (_a2 = options == null ? void 0 : options.onMessage) == null ? void 0 : _a2.call(options, data);
          next(null, data);
        }
      }
    );
    return () => unsubscribe();
  });
};
var useSettleSubscription = (options) => {
  const ws2 = useWS();
  return useSWRSubscription("settle", (_2, { next }) => {
    const unsubscribe = ws2.privateSubscribe(
      {
        id: "settle",
        event: "subscribe",
        topic: "settle",
        ts: N$3()
      },
      {
        onMessage: (data) => {
          var _a2;
          (_a2 = options == null ? void 0 : options.onMessage) == null ? void 0 : _a2.call(options, data);
          next(data);
        }
      }
    );
    return () => unsubscribe();
  });
};
var useSymbolPriceRange = (symbol, side, price) => {
  const config2 = useSymbolsInfo();
  const priceRange = config2 == null ? void 0 : config2[symbol]("price_range");
  const priceScrope = config2 == null ? void 0 : config2[symbol]("price_scope");
  const { data: prices } = useMarkPricesStream();
  const markPrice = price || (prices == null ? void 0 : prices[symbol]);
  const range = useMemo(() => {
    if (config2 === void 0 || markPrice === void 0) {
      return void 0;
    }
    if (priceRange === void 0 || Number.isNaN(markPrice)) {
      return void 0;
    }
    if (side === "BUY") {
      return {
        max: new g$6(markPrice).mul(1 + priceRange).toNumber(),
        min: new g$6(markPrice).mul(1 - priceScrope).toNumber()
      };
    }
    return {
      max: new g$6(markPrice).mul(1 + priceScrope).toNumber(),
      min: new g$6(markPrice).mul(1 - priceRange).toNumber()
    };
  }, [symbol, side, priceRange, markPrice]);
  return range;
};
function offsetToPrice(inputs) {
  const { offset, entryPrice, orderType, orderSide } = inputs;
  if (!offset)
    return;
  if (orderSide === OrderSide.BUY) {
    if (orderType === AlgoOrderType.TAKE_PROFIT) {
      return new g$6(entryPrice).add(new g$6(offset)).toNumber();
    }
    return new g$6(entryPrice).minus(new g$6(offset)).toNumber();
  }
  if (orderSide === OrderSide.SELL) {
    if (orderType === AlgoOrderType.TAKE_PROFIT) {
      return new g$6(entryPrice).minus(new g$6(offset)).toNumber();
    }
    return new g$6(entryPrice).add(new g$6(offset)).toNumber();
  }
}
function priceToOffset(inputs, options = {}) {
  const { price, entryPrice, orderType, orderSide } = inputs;
  const { symbol } = options;
  let decimal;
  if (orderSide === OrderSide.BUY) {
    if (orderType === AlgoOrderType.TAKE_PROFIT) {
      decimal = new g$6(price).minus(new g$6(entryPrice));
    }
    decimal = new g$6(price).minus(new g$6(entryPrice));
  }
  if (orderSide === OrderSide.SELL) {
    if (orderType === AlgoOrderType.TAKE_PROFIT) {
      decimal = new g$6(price).minus(new g$6(entryPrice));
    }
    decimal = new g$6(entryPrice).minus(new g$6(price));
  }
  if (symbol) {
    return decimal.abs().todp(symbol.quote_dp, g$6.ROUND_UP).toNumber();
  }
  return decimal.abs().toNumber();
}
function offsetPercentageToPrice(inputs) {
  const { percentage, entryPrice, orderType, orderSide } = inputs;
  if (!percentage)
    return;
  if (orderSide === OrderSide.BUY) {
    if (orderType === AlgoOrderType.TAKE_PROFIT) {
      return new g$6(1).add(new g$6(percentage)).mul(new g$6(entryPrice)).toNumber();
    }
    return new g$6(1).minus(new g$6(percentage)).mul(new g$6(entryPrice)).toNumber();
  }
  if (orderSide === OrderSide.SELL) {
    if (orderType === AlgoOrderType.TAKE_PROFIT) {
      return new g$6(1).minus(new g$6(percentage)).mul(new g$6(entryPrice)).toNumber();
    }
    return new g$6(1).add(new g$6(percentage)).mul(new g$6(entryPrice)).toNumber();
  }
}
function priceToOffsetPercentage(inputs) {
  const { price, entryPrice, orderType, orderSide } = inputs;
  if (orderSide === OrderSide.BUY) {
    if (entryPrice === 0)
      return 0;
    if (orderType === AlgoOrderType.TAKE_PROFIT) {
      return new g$6(price).div(new g$6(entryPrice)).minus(1).toDecimalPlaces(4, g$6.ROUND_DOWN).toNumber();
    }
    return new g$6(1).minus(new g$6(price).div(new g$6(entryPrice))).toDecimalPlaces(4, g$6.ROUND_DOWN).toNumber();
  }
  if (orderSide === OrderSide.SELL) {
    if (entryPrice === 0)
      return 0;
    if (orderType === AlgoOrderType.TAKE_PROFIT) {
      return new g$6(1).minus(new g$6(price).div(new g$6(entryPrice))).abs().toDecimalPlaces(4, g$6.ROUND_DOWN).toNumber();
    }
    return new g$6(price).div(new g$6(entryPrice)).minus(1).toDecimalPlaces(4, g$6.ROUND_DOWN).toNumber();
  }
}
function pnlToPrice(inputs) {
  const { qty, pnl, entryPrice, orderType, orderSide } = inputs;
  if (!pnl) {
    return;
  }
  if (qty === 0)
    return;
  if (orderSide === OrderSide.BUY) {
    if (orderType === AlgoOrderType.TAKE_PROFIT) {
      return new g$6(entryPrice).plus(new g$6(pnl).div(new g$6(qty))).toNumber();
    }
    return new g$6(entryPrice).add(new g$6(pnl).div(new g$6(qty))).toNumber();
  }
  if (orderSide === OrderSide.SELL) {
    if (orderType === AlgoOrderType.TAKE_PROFIT) {
      return new g$6(entryPrice).add(new g$6(pnl).div(new g$6(qty))).toNumber();
    }
    return new g$6(entryPrice).add(new g$6(pnl).div(new g$6(qty))).toNumber();
  }
}
function priceToPnl(inputs, options = {}) {
  const { qty, price, entryPrice, orderType, orderSide } = inputs;
  const { symbol } = options;
  let decimal = y$3;
  if (orderSide === OrderSide.BUY) {
    if (orderType === AlgoOrderType.TAKE_PROFIT) {
      decimal = new g$6(qty).mul(
        new g$6(price).minus(new g$6(entryPrice))
      );
    }
    decimal = new g$6(qty).mul(
      new g$6(price).minus(new g$6(entryPrice))
    );
  }
  if (orderSide === OrderSide.SELL) {
    if (orderType === AlgoOrderType.TAKE_PROFIT) {
      decimal = new g$6(qty).mul(
        new g$6(price).minus(new g$6(entryPrice))
      );
    }
    decimal = new g$6(qty).mul(
      new g$6(price).minus(new g$6(entryPrice))
    );
  }
  if (symbol) {
    return decimal.todp(2, g$6.ROUND_DOWN).toNumber();
  }
  return decimal.toNumber();
}
function calcTPSL_ROI(inputs) {
  const qtyNum = Number(inputs.qty);
  const priceNum = Number(inputs.price);
  if (qtyNum === 0 || priceNum === 0)
    return "0";
  return new g$6(inputs.pnl).div(new g$6(qtyNum).abs().mul(new g$6(priceNum))).toString();
}
function tpslCalculateHelper(key, inputs, options = {}) {
  var _a2;
  const { symbol } = options;
  if (key !== "quantity" && key !== "tp_trigger_price" && key !== "sl_trigger_price" && key !== "tp_pnl" && key !== "sl_pnl" && key !== "tp_offset" && key !== "sl_offset" && key !== "tp_offset_percentage" && key !== "sl_offset_percentage") {
    return {
      [key]: inputs.value
    };
  }
  const orderType = key.startsWith("tp_") ? AlgoOrderType.TAKE_PROFIT : AlgoOrderType.STOP_LOSS;
  const keyPrefix = key.slice(0, 3);
  let qty = Number(key === "quantity" ? inputs.value : inputs.qty);
  if (qty === 0 && (key === "tp_pnl" || key === "sl_pnl" || key === "tp_trigger_price" || key === "sl_trigger_price")) {
    return {
      [`${keyPrefix}trigger_price`]: "",
      // [`${keyPrefix}offset`]: "",
      // [`${keyPrefix}offset_percentage`]: "",
      [`${keyPrefix}pnl`]: "",
      [key]: inputs.value
    };
  }
  let trigger_price, offset, offset_percentage, pnl;
  const entryPrice = new g$6(inputs.entryPrice).todp(((_a2 = options.symbol) == null ? void 0 : _a2.quote_dp) ?? 2, g$6.ROUND_UP).toNumber();
  switch (key) {
    case "tp_trigger_price":
    case "sl_trigger_price": {
      trigger_price = inputs.value;
      if (inputs.value === "") {
        return {
          [`${keyPrefix}trigger_price`]: trigger_price,
          [`${keyPrefix}offset`]: "",
          [`${keyPrefix}offset_percentage`]: "",
          [`${keyPrefix}pnl`]: "",
          [`${keyPrefix}ROI`]: ""
        };
      }
      break;
    }
    case "tp_pnl":
    case "sl_pnl": {
      pnl = inputs.value;
      trigger_price = pnlToPrice({
        qty,
        pnl: Number(inputs.value),
        entryPrice,
        orderSide: inputs.orderSide,
        orderType
      });
      break;
    }
    case "tp_offset":
    case "sl_offset": {
      offset = inputs.value;
      trigger_price = offsetToPrice({
        offset: Number(inputs.value),
        entryPrice,
        orderSide: inputs.orderSide,
        orderType: key === "tp_offset" ? AlgoOrderType.TAKE_PROFIT : AlgoOrderType.STOP_LOSS
      });
      break;
    }
    case "tp_offset_percentage":
    case "sl_offset_percentage": {
      offset_percentage = inputs.value;
      trigger_price = offsetPercentageToPrice({
        percentage: Number(`${inputs.value}`.replace(/\.0{0,2}$/, "")),
        entryPrice,
        orderSide: inputs.orderSide,
        orderType
      });
      break;
    }
  }
  if (!trigger_price)
    return {
      [`${keyPrefix}trigger_price`]: "",
      [`${keyPrefix}offset`]: "",
      [`${keyPrefix}offset_percentage`]: "",
      [`${keyPrefix}pnl`]: "",
      [`${keyPrefix}ROI`]: "",
      [key]: inputs.value
    };
  return {
    [`${keyPrefix}trigger_price`]: A$7(
      trigger_price,
      (symbol == null ? void 0 : symbol.quote_dp) ?? 2
    ),
    [`${keyPrefix}offset`]: offset ?? priceToOffset(
      {
        price: Number(trigger_price),
        entryPrice,
        orderSide: inputs.orderSide,
        orderType
      },
      options
    ),
    [`${keyPrefix}offset_percentage`]: offset_percentage ?? priceToOffsetPercentage({
      price: Number(trigger_price),
      entryPrice,
      orderSide: inputs.orderSide,
      orderType
    }),
    [`${keyPrefix}pnl`]: pnl ?? priceToPnl(
      {
        qty,
        price: Number(trigger_price),
        entryPrice,
        orderSide: inputs.orderSide,
        orderType
      },
      options
    )
    // [`${keyPrefix}ROI`]: calcROI({
    //   pnl: Number(pnl ?? 0),
    //   qty,
    //   price: Number(trigger_price!),
    // }),
  };
}
function getMinNotional(props) {
  const { price, base_tick, qty, min_notional, base_dp, quote_dp, quote_tick } = props;
  if (price !== void 0 && qty !== void 0 && min_notional !== void 0) {
    try {
      const calcNotional = new g$6(price).mul(new g$6(qty)).toNumber();
      const notional2 = Number.parseFloat(`${min_notional}`);
      if (calcNotional < notional2) {
        let minQty = new g$6(notional2).div(price).toDecimalPlaces(base_dp, g$6.ROUND_DOWN).add(base_tick ?? 0);
        if (base_tick && base_tick > 0) {
          minQty = new g$6(
            getRoundedDownDivision(minQty.toNumber(), base_tick)
          );
        }
        const newMinNotional = minQty.mul(price).add(quote_tick ?? 0).toFixed(quote_dp);
        return newMinNotional;
      }
    } catch (e3) {
    }
  }
}
function getRoundedDownDivision(value, tick) {
  const decimalValue = new g$6(value);
  const decimalTick = new g$6(tick);
  const quotient = decimalValue.dividedToIntegerBy(decimalTick);
  return quotient.mul(decimalTick).toNumber();
}
var OrderValidation = class {
  static getLabel(key) {
    switch (key) {
      case "quantity":
      case "order_quantity":
        return "Quantity";
      case "order_price":
        return "Price";
      case "trigger_price":
        return "Trigger price";
      case "tp_trigger_price":
        return "TP price";
      case "sl_trigger_price":
        return "SL price";
      default:
        return key;
    }
  }
  static required(key) {
    return {
      type: "required",
      message: `${this.getLabel(key)} is required`
    };
  }
  static min(key, value) {
    return {
      type: "min",
      message: `${this.getLabel(key)} must be greater than ${value}`,
      value
    };
  }
  static max(key, value) {
    return {
      type: "max",
      message: `${this.getLabel(key)} must be less than ${value}`,
      value
    };
  }
};
var BaseOrderCreator = class {
  baseOrder(data) {
    const order = {
      symbol: data.symbol,
      order_type: data.order_type === OrderType.LIMIT ? !!data.order_type_ext ? data.order_type_ext : data.order_type : data.order_type,
      side: data.side,
      reduce_only: data.reduce_only,
      order_quantity: data.order_quantity,
      total: data.total
    };
    if (data.visible_quantity === 0) {
      order.visible_quantity = data.visible_quantity;
    }
    const bracketOrder = this.parseBracketOrder(data);
    if (!bracketOrder) {
      return order;
    }
    return {
      ...order,
      algo_type: AlgoOrderRootType.BRACKET,
      child_orders: [bracketOrder]
    };
  }
  baseValidate(values2, configs) {
    const errors = {};
    const { maxQty: maxQty2, symbol, markPrice } = configs;
    let { order_quantity, total, order_price, reduce_only, order_type } = values2;
    const { min_notional, base_tick, quote_dp, quote_tick, base_dp } = symbol || {};
    if (!order_quantity) {
      if (total && order_price) {
        const { quote_dp: quote_dp2 } = configs.symbol;
        const totalNumber = new g$6(total);
        const qty = totalNumber.dividedBy(order_price).toFixed(quote_dp2);
        order_quantity = qty;
      }
    }
    if (!order_quantity) {
      errors.order_quantity = OrderValidation.required("order_quantity");
    } else {
      const { base_min, quote_dp: quote_dp2, base_dp: base_dp2 } = configs.symbol;
      const qty = new g$6(order_quantity);
      if (qty.lt(base_min)) {
        errors.order_quantity = OrderValidation.min(
          "order_quantity",
          new g$6(base_min).todp(base_dp2).toString()
        );
      } else if (qty.gt(maxQty2)) {
        errors.order_quantity = OrderValidation.max(
          "order_quantity",
          new g$6(maxQty2).todp(base_dp2).toString()
        );
      }
    }
    const price = `${order_type}`.includes("MARKET") ? markPrice : order_price;
    const minNotional = getMinNotional({
      base_tick,
      quote_tick,
      price,
      qty: order_quantity,
      min_notional,
      quote_dp,
      base_dp
    });
    if (minNotional !== void 0 && !reduce_only) {
      errors.total = {
        type: "min",
        message: `The order value should be greater or equal to ${minNotional} USDC`,
        value: minNotional
      };
    }
    this.validateBracketOrder(values2, configs, errors);
    return Promise.resolve(errors);
  }
  totalToQuantity(order, config2) {
    if (!order.order_quantity && order.total && order.order_price) {
      const { base_dp } = config2.symbol;
      const totalNumber = new g$6(order.total);
      const qty = totalNumber.div(order.order_price).toDecimalPlaces(base_dp);
      order.order_quantity = qty.toNumber();
      delete order.total;
    }
    return order;
  }
  get type() {
    return this.orderType;
  }
  parseBracketOrder(data) {
    const orders = [];
    const side = data.side === OrderSide.BUY ? OrderSide.SELL : OrderSide.BUY;
    if (!!data.tp_trigger_price) {
      const tp_trigger_price = data.tp_trigger_price;
      orders.push({
        algo_type: AlgoOrderType.TAKE_PROFIT,
        side,
        type: OrderType.CLOSE_POSITION,
        trigger_price: tp_trigger_price,
        symbol: data.symbol,
        reduce_only: true
      });
    }
    if (!!data.sl_trigger_price) {
      const sl_trigger_price = data.sl_trigger_price;
      orders.push({
        algo_type: AlgoOrderType.STOP_LOSS,
        side,
        type: OrderType.CLOSE_POSITION,
        trigger_price: sl_trigger_price,
        symbol: data.symbol,
        reduce_only: true
      });
    }
    if (!orders.length)
      return null;
    return {
      symbol: data.symbol,
      algo_type: AlgoOrderRootType.POSITIONAL_TP_SL,
      child_orders: orders
    };
  }
  validateBracketOrder(values2, config2, errors) {
    const { tp_trigger_price, sl_trigger_price, side, order_price } = values2;
    const { markPrice } = config2;
    if (!tp_trigger_price && !sl_trigger_price)
      return errors;
    const hasTPPrice = !!tp_trigger_price;
    const hasSLPrice = !!sl_trigger_price;
    const { symbol } = config2;
    const { price_range, price_scope, quote_max, quote_min, quote_dp } = symbol;
    const _orderPrice = order_price || markPrice;
    if (hasTPPrice) {
      const tpPrice = new g$6(tp_trigger_price);
      if (tpPrice.gt(quote_max)) {
        errors.tp_trigger_price = OrderValidation.max(
          "tp_trigger_price",
          quote_max
        );
      }
      if (tpPrice.lt(quote_min)) {
        errors.tp_trigger_price = OrderValidation.min(
          "tp_trigger_price",
          quote_min
        );
      }
      if (side === OrderSide.BUY) {
        if (tpPrice.lte(_orderPrice)) {
          errors.tp_trigger_price = OrderValidation.min(
            "tp_trigger_price",
            _orderPrice
          );
        }
      }
      if (side === OrderSide.SELL) {
        if (tpPrice.gte(_orderPrice)) {
          errors.tp_trigger_price = OrderValidation.max(
            "tp_trigger_price",
            _orderPrice
          );
        }
      }
    }
    if (hasSLPrice) {
      const slPrice = new g$6(sl_trigger_price);
      if (slPrice.gt(quote_max)) {
        errors.sl_trigger_price = OrderValidation.max(
          "sl_trigger_price",
          quote_max
        );
      }
      if (slPrice.lt(quote_min)) {
        errors.sl_trigger_price = OrderValidation.min(
          "sl_trigger_price",
          quote_min
        );
      }
      if (side === OrderSide.BUY) {
        if (slPrice.gte(_orderPrice)) {
          errors.sl_trigger_price = OrderValidation.max(
            "sl_trigger_price",
            _orderPrice
          );
        }
      }
      if (side === OrderSide.SELL) {
        if (slPrice.lte(_orderPrice)) {
          errors.sl_trigger_price = OrderValidation.min(
            "sl_trigger_price",
            _orderPrice
          );
        }
      }
    }
    return errors;
  }
};
var MarketOrderCreator = class extends BaseOrderCreator {
  create(values2) {
    const data = this.baseOrder(values2);
    delete data["order_price"];
    delete data["total"];
    delete data["trigger_price"];
    delete data["isStopOrder"];
    return {
      ...data
    };
  }
  validate(values2, configs) {
    return this.baseValidate(values2, configs);
  }
};
var { maxPrice, minPrice, scopePrice } = order_exports;
var LimitOrderCreator = class extends BaseOrderCreator {
  constructor() {
    super(...arguments);
    this.orderType = OrderType.LIMIT;
  }
  create(values2, config2) {
    const order = {
      ...this.baseOrder(values2),
      order_price: values2.order_price
    };
    this.totalToQuantity(order, config2);
    return pick(
      [
        "symbol",
        "order_price",
        "order_quantity",
        "visible_quantity",
        "reduce_only",
        "side",
        "order_type",
        "algo_type",
        "child_orders"
      ],
      order
    );
  }
  validate(values2, config2) {
    return this.baseValidate(values2, config2).then((errors) => {
      const { order_price, side } = values2;
      if (!order_price) {
        errors.order_price = OrderValidation.required("order_price");
      } else {
        const price = new g$6(order_price);
        const { symbol } = config2;
        const { price_range, price_scope, quote_max, quote_min } = symbol;
        const maxPriceNumber = maxPrice(config2.markPrice, price_range);
        const minPriceNumber = minPrice(config2.markPrice, price_range);
        const scopePriceNumber = scopePrice(
          config2.markPrice,
          price_scope,
          side
        );
        const priceRange = side === "BUY" ? {
          min: scopePriceNumber,
          max: maxPriceNumber
        } : {
          min: minPriceNumber,
          max: scopePriceNumber
        };
        if (price.gt(quote_max)) {
          errors.order_price = OrderValidation.max("order_price", quote_max);
        } else {
          if (price.gt(priceRange == null ? void 0 : priceRange.max)) {
            errors.order_price = OrderValidation.max(
              "order_price",
              new g$6(priceRange.max).todp(symbol.quote_dp).toString()
            );
          }
        }
        if (price.lt(quote_min)) {
          errors.order_price = OrderValidation.min("order_price", quote_min);
        } else {
          if (price.lt(priceRange == null ? void 0 : priceRange.min)) {
            errors.order_price = OrderValidation.min(
              "order_price",
              new g$6(priceRange.min).todp(symbol.quote_dp).toString()
            );
          }
        }
      }
      return errors;
    });
  }
};
var { maxPrice: maxPrice2, minPrice: minPrice2, scopePrice: scopePrice2 } = order_exports;
var StopLimitOrderCreator = class extends BaseOrderCreator {
  constructor() {
    super(...arguments);
    this.orderType = OrderType.STOP_LIMIT;
  }
  create(values2, config2) {
    this.totalToQuantity(values2, config2);
    const order = {
      ...this.baseOrder(values2),
      trigger_price: values2.trigger_price,
      algo_type: AlgoOrderRootType.STOP,
      type: OrderType.LIMIT,
      quantity: values2["order_quantity"],
      price: values2["order_price"],
      trigger_price_type: TriggerPriceType.MARK_PRICE
    };
    return pick(
      [
        "symbol",
        "trigger_price",
        "algo_type",
        "type",
        "quantity",
        "price",
        "trigger_price_type",
        "side",
        "reduce_only",
        "visible_quantity"
      ],
      order
    );
  }
  validate(values2, config2) {
    return this.baseValidate(values2, config2).then((errors) => {
      const { order_price, trigger_price, side } = values2;
      const { symbol } = config2;
      const { price_range, price_scope, quote_max, quote_min } = symbol;
      if (!trigger_price) {
        errors.trigger_price = OrderValidation.required("trigger_price");
      }
      if (!order_price) {
        errors.order_price = OrderValidation.required("order_price");
      }
      if (trigger_price > quote_max) {
        errors.trigger_price = OrderValidation.max("trigger_price", quote_max);
      } else if (trigger_price < quote_min) {
        errors.trigger_price = OrderValidation.min("trigger_price", quote_min);
      } else {
        if (trigger_price && order_price) {
          const price = new g$6(order_price);
          const maxPriceNumber = maxPrice2(trigger_price, price_range);
          const minPriceNumber = minPrice2(trigger_price, price_range);
          const scropePriceNumbere = scopePrice2(
            trigger_price,
            price_scope,
            side
          );
          const priceRange = side === "BUY" ? {
            min: scropePriceNumbere,
            max: maxPriceNumber
          } : {
            min: minPriceNumber,
            max: scropePriceNumbere
          };
          if (price.gt(quote_max)) {
            errors.order_price = OrderValidation.max("order_price", quote_max);
          } else {
            if (price.gt(priceRange == null ? void 0 : priceRange.max)) {
              errors.order_price = OrderValidation.max(
                "order_price",
                new g$6(priceRange.max).todp(symbol.quote_dp).toString()
              );
            }
          }
          if (price.lt(quote_min)) {
            errors.order_price = OrderValidation.min("order_price", quote_min);
          } else {
            if (price.lt(priceRange == null ? void 0 : priceRange.min)) {
              errors.order_price = OrderValidation.min(
                "order_price",
                new g$6(priceRange.min).todp(symbol.quote_dp).toString()
              );
            }
          }
        }
      }
      return errors;
    });
  }
};
var GeneralOrderCreator = class extends BaseOrderCreator {
  create(data) {
    return {
      ...this.baseOrder(data),
      order_price: data.order_price,
      order_quantity: data.order_quantity
    };
  }
  validate(values2, configs) {
    return super.baseValidate(values2, configs);
  }
};
var StopMarketOrderCreator = class extends BaseOrderCreator {
  create(values2) {
    const order = {
      ...this.baseOrder(values2),
      // order_price: values.order_price,
      trigger_price: values2.trigger_price,
      algo_type: AlgoOrderRootType.STOP,
      type: OrderType.MARKET,
      quantity: values2["order_quantity"],
      // price: values["order_price"],
      trigger_price_type: TriggerPriceType.MARK_PRICE
    };
    return pick(
      [
        "symbol",
        "trigger_price",
        "algo_type",
        "type",
        "quantity",
        // "price",
        "trigger_price_type",
        "side",
        "reduce_only",
        "visible_quantity"
      ],
      order
    );
  }
  validate(values2, config2) {
    return this.baseValidate(values2, config2).then((errors) => {
      const { order_price, trigger_price, side } = values2;
      const { symbol } = config2;
      const { quote_max, quote_min } = symbol;
      if (!trigger_price) {
        errors.trigger_price = OrderValidation.required("trigger_price");
      }
      if (trigger_price > quote_max) {
        errors.trigger_price = OrderValidation.max("trigger_price", quote_max);
      } else if (trigger_price < quote_min) {
        errors.trigger_price = OrderValidation.min("trigger_price", quote_min);
      }
      return errors;
    });
  }
};
var PostOnlyOrderCreator = class extends LimitOrderCreator {
};
var FOKOrderCreator = class extends LimitOrderCreator {
};
var IOCOrderCreator = class extends LimitOrderCreator {
};
var BaseAlgoOrderCreator = class {
  /**
   * base validate
   */
  validate(values2, config2) {
    const result = /* @__PURE__ */ Object.create(null);
    return Promise.resolve().then(() => {
      const { tp_trigger_price, sl_trigger_price, side } = values2;
      const qty = Number(values2.quantity);
      const maxQty2 = config2.maxQty;
      const orderType = values2.order_type;
      const {
        quote_max,
        quote_min,
        price_scope,
        quote_dp,
        base_min,
        min_notional
      } = config2.symbol ?? {};
      if (!isNaN(qty) && qty > maxQty2) {
        result.quantity = OrderValidation.max("quantity", config2.maxQty);
      }
      if (!isNaN(qty) && qty < base_min) {
        result.quantity = OrderValidation.min("quantity", base_min);
      }
      if (Number(tp_trigger_price) < 0) {
        result.tp_trigger_price = OrderValidation.min("tp_trigger_price", 0);
      }
      if (Number(sl_trigger_price) < 0) {
        result.sl_trigger_price = OrderValidation.min("sl_trigger_price", 0);
      }
      const mark_price = orderType === OrderType.MARKET || orderType == null ? config2.markPrice : values2.order_price ? Number(values2.order_price) : void 0;
      if (side === OrderSide.BUY && mark_price) {
        const slTriggerPriceScope = new g$6(mark_price * (1 - price_scope)).toDecimalPlaces(quote_dp, g$6.ROUND_DOWN).toNumber();
        if (!!sl_trigger_price && Number(sl_trigger_price) < slTriggerPriceScope) {
          result.sl_trigger_price = OrderValidation.min(
            "sl_trigger_price",
            slTriggerPriceScope
          );
        }
        if (!!sl_trigger_price && Number(sl_trigger_price) > config2.markPrice) {
          result.sl_trigger_price = OrderValidation.max(
            "sl_trigger_price",
            config2.markPrice
          );
        }
        if (!!tp_trigger_price && Number(tp_trigger_price) <= config2.markPrice) {
          result.tp_trigger_price = OrderValidation.min(
            "tp_trigger_price",
            config2.markPrice
          );
        }
        if (!!tp_trigger_price && Number(tp_trigger_price) > quote_max) {
          result.tp_trigger_price = OrderValidation.max(
            "tp_trigger_price",
            quote_max
          );
        }
        if (!!sl_trigger_price && Number(sl_trigger_price) < quote_min) {
          result.sl_trigger_price = OrderValidation.min(
            "sl_trigger_price",
            quote_min
          );
        }
      }
      if (side === OrderSide.SELL && mark_price) {
        const slTriggerPriceScope = new g$6(mark_price * (1 + price_scope)).toDecimalPlaces(quote_dp, g$6.ROUND_DOWN).toNumber();
        if (!!sl_trigger_price && Number(sl_trigger_price) > slTriggerPriceScope) {
          result.sl_trigger_price = OrderValidation.max(
            "sl_trigger_price",
            slTriggerPriceScope
          );
        }
        if (!!sl_trigger_price && Number(sl_trigger_price) < config2.markPrice) {
          result.sl_trigger_price = OrderValidation.min(
            "sl_trigger_price",
            config2.markPrice
          );
        }
        if (!!tp_trigger_price && Number(tp_trigger_price) >= config2.markPrice) {
          result.tp_trigger_price = OrderValidation.max(
            "tp_trigger_price",
            config2.markPrice
          );
        }
        if (!!tp_trigger_price && Number(tp_trigger_price) > quote_max) {
          result.tp_trigger_price = OrderValidation.max(
            "tp_trigger_price",
            quote_max
          );
        }
        if (!!sl_trigger_price && Number(sl_trigger_price) < quote_min) {
          result.sl_trigger_price = OrderValidation.min(
            "sl_trigger_price",
            quote_min
          );
        }
      }
      return Object.keys(result).length > 0 ? result : null;
    });
  }
};
var TPSLOrderCreator = class extends BaseAlgoOrderCreator {
  constructor() {
    super(...arguments);
    this.type = OrderType.MARKET;
  }
  create(values2, config2) {
    const side = values2.side === OrderSide.BUY ? OrderSide.SELL : OrderSide.BUY;
    const child_orders = [];
    if (typeof values2.tp_trigger_price !== "undefined") {
      const tp_trigger_price = !!values2.tp_trigger_price ? new g$6(values2.tp_trigger_price).todp(config2.symbol.quote_dp).toNumber() : values2.tp_trigger_price;
      child_orders.push({
        algo_type: AlgoOrderType.TAKE_PROFIT,
        reduce_only: true,
        side,
        type: OrderType.MARKET,
        trigger_price: tp_trigger_price,
        symbol: values2.symbol,
        is_activated: !!values2.tp_trigger_price
      });
    }
    if (typeof values2.sl_trigger_price !== "undefined") {
      const sl_trigger_price = !!values2.sl_trigger_price ? new g$6(values2.sl_trigger_price).todp(config2.symbol.quote_dp).toNumber() : values2.sl_trigger_price;
      child_orders.push({
        algo_type: AlgoOrderType.STOP_LOSS,
        reduce_only: true,
        side,
        type: OrderType.MARKET,
        trigger_price: sl_trigger_price,
        symbol: values2.symbol,
        is_activated: !!values2.sl_trigger_price
      });
    }
    return {
      algo_type: AlgoOrderRootType.TP_SL,
      trigger_price_type: TriggerPriceType.MARK_PRICE,
      reduce_only: true,
      quantity: values2.quantity,
      symbol: values2.symbol,
      child_orders
    };
  }
  crateUpdateOrder(values2, oldValue, config2) {
    const data = this.create(values2, config2);
    const newData = [];
    const needUpdateQty = values2.quantity !== oldValue.quantity;
    data.child_orders.forEach((order) => {
      var _a2;
      let _order = /* @__PURE__ */ Object.create(null);
      if (needUpdateQty) {
        _order["quantity"] = data.quantity;
      }
      const oldOrder = (_a2 = oldValue.child_orders) == null ? void 0 : _a2.find(
        (oldOrder2) => oldOrder2.algo_type === order.algo_type
      );
      if (oldOrder) {
        if (!order.is_activated) {
          _order["is_activated"] = false;
        } else if (oldOrder.trigger_price !== order.trigger_price) {
          _order["trigger_price"] = order.trigger_price;
        }
        if (Object.keys(_order).length > 0) {
          _order["order_id"] = Number(oldOrder.algo_order_id);
          newData.push(_order);
        }
      }
    });
    if (needUpdateQty && newData.length < 2) {
      const missingOrders = oldValue.child_orders.filter(
        (order) => order.algo_order_id !== newData[0].order_id
      );
      if (missingOrders.length) {
        newData.push({
          quantity: Number(data.quantity),
          order_id: missingOrders[0].algo_order_id
        });
      }
    }
    return [
      {
        child_orders: newData
      },
      data
    ];
  }
};
var TPSLPositionOrderCreator = class extends BaseAlgoOrderCreator {
  constructor() {
    super(...arguments);
    this.type = AlgoOrderRootType.POSITIONAL_TP_SL;
  }
  create(values2, config2) {
    const side = values2.side === OrderSide.BUY ? OrderSide.SELL : OrderSide.BUY;
    const child_orders = [];
    if (typeof values2.tp_trigger_price !== "undefined") {
      const tp_trigger_price = !!values2.tp_trigger_price ? new g$6(values2.tp_trigger_price).todp(config2.symbol.quote_dp).toNumber() : values2.tp_trigger_price;
      child_orders.push({
        algo_type: AlgoOrderType.TAKE_PROFIT,
        reduce_only: true,
        side,
        type: OrderType.CLOSE_POSITION,
        trigger_price: tp_trigger_price,
        trigger_price_type: TriggerPriceType.MARK_PRICE,
        symbol: values2.symbol,
        is_activated: !!values2.tp_trigger_price
      });
    }
    if (typeof values2.sl_trigger_price !== "undefined") {
      const sl_trigger_price = !!values2.sl_trigger_price ? new g$6(values2.sl_trigger_price).todp(config2.symbol.quote_dp).toNumber() : values2.sl_trigger_price;
      child_orders.push({
        algo_type: AlgoOrderType.STOP_LOSS,
        reduce_only: true,
        side,
        type: OrderType.CLOSE_POSITION,
        trigger_price: sl_trigger_price,
        trigger_price_type: TriggerPriceType.MARK_PRICE,
        symbol: values2.symbol,
        is_activated: !!values2.sl_trigger_price
      });
    }
    return {
      algo_type: AlgoOrderRootType.POSITIONAL_TP_SL,
      trigger_price_type: TriggerPriceType.MARK_PRICE,
      // reduce_only: true,
      symbol: values2.symbol,
      child_orders
    };
  }
  crateUpdateOrder(values2, oldValue, config2) {
    const data = this.create(values2, config2);
    const newData = [];
    data.child_orders.forEach((order) => {
      var _a2;
      const oldOrder = (_a2 = oldValue.child_orders) == null ? void 0 : _a2.find(
        (oldOrder2) => oldOrder2.algo_type === order.algo_type
      );
      if (oldOrder) {
        if (!order.is_activated) {
          newData.push({
            is_activated: false,
            order_id: Number(oldOrder.algo_order_id)
          });
        } else if (oldOrder.trigger_price !== order.trigger_price) {
          newData.push({
            trigger_price: order.trigger_price,
            order_id: Number(oldOrder.algo_order_id)
          });
        }
      }
    });
    return [
      {
        child_orders: newData
      },
      data
    ];
  }
};
async function bracketOrderValidator(values2, config2) {
  const result = /* @__PURE__ */ Object.create(null);
  await Promise.resolve();
  const { tp_trigger_price, sl_trigger_price, side } = values2;
  const qty = Number(values2.quantity);
  const maxQty2 = config2.maxQty;
  const type = values2.order_type;
  const { quote_max, quote_min, price_scope, quote_dp } = config2.symbol ?? {};
  const mark_price = type === OrderType.MARKET ? config2.markPrice : values2.order_price ? Number(values2.order_price) : void 0;
  if (!isNaN(qty) && qty > maxQty2) {
    result.quantity = OrderValidation.max("quantity", config2.maxQty);
  }
  if (Number(tp_trigger_price) < 0) {
    result.tp_trigger_price = OrderValidation.min("tp_trigger_price", 0);
  }
  if (Number(sl_trigger_price) < 0) {
    result.sl_trigger_price = OrderValidation.min("sl_trigger_price", 0);
  }
  if (side === OrderSide.BUY && mark_price) {
    const slTriggerPriceScope = new g$6(mark_price * (1 - price_scope)).toDecimalPlaces(quote_dp, g$6.ROUND_DOWN).toNumber();
    if (!!sl_trigger_price && Number(sl_trigger_price) < slTriggerPriceScope) {
      result.sl_trigger_price = OrderValidation.min(
        "sl_trigger_price",
        slTriggerPriceScope
      );
    }
    if (!!tp_trigger_price && Number(tp_trigger_price) <= mark_price) {
      result.tp_trigger_price = OrderValidation.min(
        "tp_trigger_price",
        mark_price
      );
    }
    if (!!tp_trigger_price && Number(tp_trigger_price) > quote_max) {
      result.tp_trigger_price = OrderValidation.max(
        "tp_trigger_price",
        quote_max
      );
    }
    if (!!sl_trigger_price && Number(sl_trigger_price) < quote_min) {
      result.sl_trigger_price = OrderValidation.min(
        "sl_trigger_price",
        quote_min
      );
    }
  }
  if (side === OrderSide.SELL && mark_price) {
    const slTriggerPriceScope = new g$6(mark_price * (1 + price_scope)).toDecimalPlaces(quote_dp, g$6.ROUND_DOWN).toNumber();
    if (!!sl_trigger_price && Number(sl_trigger_price) > slTriggerPriceScope) {
      result.sl_trigger_price = OrderValidation.max(
        "sl_trigger_price",
        slTriggerPriceScope
      );
    }
    if (!!tp_trigger_price && Number(tp_trigger_price) >= mark_price) {
      result.tp_trigger_price = OrderValidation.max(
        "tp_trigger_price",
        mark_price
      );
    }
    if (!!tp_trigger_price && Number(tp_trigger_price) > quote_max) {
      result.tp_trigger_price = OrderValidation.max(
        "tp_trigger_price",
        quote_max
      );
    }
    if (!!sl_trigger_price && Number(sl_trigger_price) < quote_min) {
      result.sl_trigger_price = OrderValidation.min(
        "sl_trigger_price",
        quote_min
      );
    }
  }
  return Object.keys(result).length > 0 ? result : null;
}
var BracketLimitOrderCreator = class extends LimitOrderCreator {
  // orderType: OrderType;
  create(values2, config2) {
    const order = super.create(values2, config2);
    return {
      ...order,
      quantity: order.order_quantity,
      type: order.order_type,
      price: order.order_price
    };
  }
  async validate(values2, config2) {
    const value = await super.validate(values2, config2);
    const bracketData = await bracketOrderValidator(values2, config2);
    return { ...value, ...bracketData };
  }
};
var BracketMarketOrderCreator = class extends MarketOrderCreator {
  constructor() {
    super(...arguments);
    this.orderType = OrderType.MARKET;
  }
  create(values2) {
    const order = super.create(values2);
    return {
      ...order,
      quantity: order.order_quantity,
      type: order.order_type,
      price: order.order_price
    };
  }
  async validate(values2, config2) {
    const value = await super.validate(values2, config2);
    const bracketData = await bracketOrderValidator(values2, config2);
    return { ...value, ...bracketData };
  }
};
var BBOOrderCreator = class extends BaseOrderCreator {
  create(values2) {
    const order = {
      ...this.baseOrder(values2),
      level: values2.level
    };
    return pick(
      [
        "symbol",
        "order_quantity",
        "visible_quantity",
        "reduce_only",
        "side",
        "order_type",
        "level"
      ],
      order
    );
  }
  async validate(values2, configs) {
    return this.baseValidate(values2, configs).then((errors) => {
      delete errors["total"];
      let { order_quantity, order_price, reduce_only, level } = values2;
      const { symbol } = configs;
      const { min_notional, base_tick, quote_dp, quote_tick, base_dp } = symbol || {};
      const minNotional = getMinNotional({
        base_tick,
        quote_tick,
        price: order_price,
        qty: order_quantity,
        min_notional,
        quote_dp,
        base_dp
      });
      if (minNotional !== void 0 && !reduce_only) {
        errors.total = {
          type: "min",
          message: `The order value should be greater or equal to ${minNotional} USDC`,
          value: minNotional
        };
      }
      return errors;
    });
  }
};
var OrderFactory = class {
  static create(type) {
    switch (type) {
      case `${AlgoOrderRootType.BRACKET}:${OrderType.LIMIT}`:
        return new BracketLimitOrderCreator();
      case `${AlgoOrderRootType.BRACKET}:${OrderType.MARKET}`:
        return new BracketMarketOrderCreator();
      case OrderType.LIMIT:
        return new LimitOrderCreator();
      case OrderType.MARKET:
        return new MarketOrderCreator();
      case OrderType.ASK:
      case OrderType.BID:
        return new BBOOrderCreator();
      case OrderType.IOC:
        return new IOCOrderCreator();
      case OrderType.FOK:
        return new FOKOrderCreator();
      case OrderType.POST_ONLY:
        return new PostOnlyOrderCreator();
      case OrderType.STOP_LIMIT:
        return new StopLimitOrderCreator();
      case OrderType.STOP_MARKET:
        return new StopMarketOrderCreator();
      case AlgoOrderRootType.TP_SL:
        return new TPSLOrderCreator();
      case AlgoOrderRootType.POSITIONAL_TP_SL:
        return new TPSLPositionOrderCreator();
      default:
        return new GeneralOrderCreator();
    }
  }
};
var useTaskProfitAndStopLossInternal = (position, options) => {
  var _a2, _b2, _c2, _d2;
  const isEditing = typeof (options == null ? void 0 : options.isEditing) !== "undefined" ? options.isEditing : !!(options == null ? void 0 : options.defaultOrder);
  const [order, setOrder] = useState({
    algo_order_id: (_a2 = options == null ? void 0 : options.defaultOrder) == null ? void 0 : _a2.algo_order_id,
    symbol: position.symbol,
    side: Number(position.position_qty) > 0 ? OrderSide.BUY : OrderSide.SELL,
    quantity: isEditing ? ((_b2 = options == null ? void 0 : options.defaultOrder) == null ? void 0 : _b2.quantity) === 0 ? Math.abs(position.position_qty) : (_c2 = options == null ? void 0 : options.defaultOrder) == null ? void 0 : _c2.quantity : "",
    // quantity:
    //   options?.defaultOrder?.quantity || Math.abs(position.position_qty),
    algo_type: (_d2 = options == null ? void 0 : options.defaultOrder) == null ? void 0 : _d2.algo_type
  });
  const symbolInfo = useSymbolsInfo()[position.symbol]();
  const { data: markPrice } = useMarkPrice(order.symbol);
  const [doCreateOrder, { isMutating: isCreateMutating }] = useMutation("/v1/algo/order");
  const [doUpdateOrder, { isMutating: isUpdateMutating }] = useMutation(
    "/v1/algo/order",
    "PUT"
  );
  const [doDeleteOrder] = useMutation("/v1/algo/order", "DELETE");
  const [errors, setErrors] = useState(null);
  useEffect(() => {
    if (!isEditing || !(options == null ? void 0 : options.defaultOrder))
      return;
    const trigger_prices = findTPSLFromOrder(options.defaultOrder);
    if (trigger_prices.tp_trigger_price) {
      setOrderValue("tp_trigger_price", trigger_prices.tp_trigger_price, {
        ignoreValidate: true
      });
    }
    if (trigger_prices.sl_trigger_price) {
      setOrderValue("sl_trigger_price", trigger_prices.sl_trigger_price, {
        ignoreValidate: true
      });
    }
  }, []);
  const _setOrderValue = (key, value, options2) => {
    setOrder((prev) => {
      const side = position.position_qty > 0 ? OrderSide.BUY : OrderSide.SELL;
      const newValue = tpslCalculateHelper(
        key,
        {
          value,
          entryPrice: position.average_open_price,
          qty: side === OrderSide.BUY ? Number(prev.quantity) : -Number(prev.quantity),
          orderSide: side
        },
        {
          symbol: symbolInfo
        }
      );
      return {
        ...prev,
        ...newValue,
        ignoreValidate: options2 == null ? void 0 : options2.ignoreValidate
      };
    });
  };
  const setOrderValue = async (key, value, options2) => {
    if (key === "quantity") {
      setOrder((prev) => ({ ...prev, quantity: value }));
      if (typeof order.sl_trigger_price !== "undefined") {
        _setOrderValue("sl_trigger_price", order.sl_trigger_price, {
          ignoreValidate: true
        });
      }
      if (typeof order.tp_trigger_price !== "undefined") {
        _setOrderValue("tp_trigger_price", order.tp_trigger_price, {
          ignoreValidate: true
        });
      }
      _setOrderValue(key, value, options2);
      return;
    }
    _setOrderValue(key, value, options2);
  };
  const valueConfig = {
    symbol: symbolInfo,
    maxQty: Math.abs(position.position_qty),
    markPrice
  };
  useEffect(() => {
    requestAnimationFrame(() => {
      if (order.ignoreValidate)
        return;
      const orderCreator = getOrderCreator2();
      orderCreator.validate(order, valueConfig).then((errors2) => {
        setErrors(errors2);
      });
    });
  }, [order, valueConfig.markPrice, order.quantity]);
  const setValues = (values2) => {
    const keys = Object.keys(values2);
    keys.forEach((key) => {
      setOrderValue(
        key,
        values2[key]
      );
    });
  };
  const validate = () => {
    const orderCreator = getOrderCreator2();
    return new Promise((resolve, reject) => {
      return orderCreator.validate(
        order,
        valueConfig
      ).then((errors2) => {
        if (errors2) {
          setErrors(errors2);
          return reject(errors2);
        }
        resolve(
          orderCreator.create(
            order,
            valueConfig
          )
        );
      });
    });
  };
  const compare = () => {
    const quantityNum = Number(order.quantity);
    if (isNaN(quantityNum))
      return false;
    return quantityNum === Math.abs(Number(position.position_qty));
  };
  const getOrderCreator2 = () => {
    var _a3;
    if (((_a3 = options == null ? void 0 : options.defaultOrder) == null ? void 0 : _a3.algo_type) === AlgoOrderRootType.TP_SL) {
      return OrderFactory.create(AlgoOrderRootType.TP_SL);
    }
    return OrderFactory.create(
      compare() ? AlgoOrderRootType.POSITIONAL_TP_SL : AlgoOrderRootType.TP_SL
    );
  };
  const submit = async () => {
    const defaultOrder = options == null ? void 0 : options.defaultOrder;
    const orderId = defaultOrder == null ? void 0 : defaultOrder.algo_order_id;
    const algoType = defaultOrder == null ? void 0 : defaultOrder.algo_type;
    if (!orderId) {
      return createOrder();
    }
    if (algoType === AlgoOrderRootType.POSITIONAL_TP_SL) {
      if (compare()) {
        return updateOrder(orderId);
      }
      return createOrder();
    }
    return updateOrder(orderId);
  };
  const createOrder = () => {
    const orderCreator = getOrderCreator2();
    const orderBody = orderCreator.create(
      order,
      valueConfig
    );
    if (orderBody.child_orders.length === 0) {
      throw new SDKError("No child orders");
    }
    orderBody.child_orders = orderBody.child_orders.filter(
      (order2) => order2.is_activated
    );
    return doCreateOrder(orderBody);
  };
  const deleteOrder = (orderId, symbol) => {
    return doDeleteOrder(null, {
      order_id: orderId,
      symbol
    });
  };
  const updateOrder = (orderId) => {
    const orderCreator = getOrderCreator2();
    const [updatedOrderEntity, orderEntity] = orderCreator.crateUpdateOrder(
      // @ts-ignore
      order,
      options == null ? void 0 : options.defaultOrder,
      valueConfig
    );
    if (updatedOrderEntity.child_orders.length === 0) {
      return Promise.resolve("Not any order needs to update");
    }
    const needDelete = orderEntity.child_orders.filter(
      (order2) => typeof order2.is_activated === "boolean" && !order2.is_activated
    ).length === orderEntity.child_orders.length;
    if (needDelete) {
      return deleteOrder(orderId, order.symbol);
    }
    return doUpdateOrder({
      order_id: orderId,
      ...updatedOrderEntity
    });
  };
  return [
    omit(["ignoreValidate"], order),
    {
      submit,
      deleteOrder,
      // create: submit,
      // update: updateOrder,/
      setValue: setOrderValue,
      setValues,
      // createPositionTPSL: submit,
      // createTPSL: submit,
      validate,
      errors,
      isCreateMutating,
      isUpdateMutating
    }
  ];
};
var useTPSLOrder = (position, options) => {
  if (!position) {
    throw new SDKError("Position is required");
  }
  if (!position.symbol) {
    throw new SDKError("Symbol is required");
  }
  if (typeof position.average_open_price === "undefined") {
    throw new SDKError("Average open price is required");
  }
  if (typeof position.position_qty === "undefined") {
    throw new SDKError("Position quantity is required");
  }
  const result = useTaskProfitAndStopLossInternal(position, options);
  return result;
};
var useSymbolLeverage = (symbol) => {
  const { data: info } = useAccountInfo2();
  const maxAccountLeverage = info == null ? void 0 : info.max_leverage;
  const res = useQuery(`/v1/public/info/${symbol}`, {
    dedupingInterval: 1e3 * 60 * 60 * 24,
    revalidateOnFocus: false,
    errorRetryCount: 2,
    errorRetryInterval: 200
  });
  const maxSymbolLeverage = useMemo(() => {
    var _a2;
    const base = (_a2 = res == null ? void 0 : res.data) == null ? void 0 : _a2.base_imr;
    if (base)
      return 1 / base;
  }, [res]);
  const maxLeverage = useMemo(() => {
    if (!maxAccountLeverage || !maxSymbolLeverage) {
      return "-";
    }
    return Math.min(maxAccountLeverage, maxSymbolLeverage);
  }, [maxAccountLeverage, maxSymbolLeverage]);
  return maxLeverage;
};
var useAssetsHistory = (options) => {
  const { page = 1, pageSize = 10 } = options;
  const ee2 = useEventEmitter();
  const getKey = () => {
    const searchParams = new URLSearchParams();
    searchParams.set("page", page.toString());
    searchParams.set("size", pageSize.toString());
    if (options.side && options.side !== "All")
      searchParams.set("side", options.side);
    if (options.startTime)
      searchParams.set("start_t", options.startTime);
    if (options.endTime)
      searchParams.set("end_t", options.endTime);
    return `/v1/asset/history?${searchParams.toString()}`;
  };
  const { data, isLoading, mutate: mutate3 } = usePrivateQuery(
    getKey(),
    {
      formatter: (data2) => data2,
      revalidateOnFocus: false,
      errorRetryInterval: 60 * 1e3
    }
  );
  const updateList = useDebouncedCallback(
    (data2) => {
      mutate3();
    },
    // delay in ms
    300
  );
  useEffect(() => {
    ee2.on("wallet:changed", updateList);
    return () => {
      ee2.off("wallet:changed", updateList);
    };
  }, []);
  return [
    (data == null ? void 0 : data.rows) || [],
    {
      meta: data == null ? void 0 : data.meta,
      isLoading
    }
  ];
};
var useStatisticsDaily = (params, options) => {
  const { startDate, endDate, page = 1 } = params;
  const { ignoreAggregation = false } = options || {};
  if (!startDate || !endDate) {
    throw new SDKError("Start date and end date are required");
  }
  const getPeriod = (startDate2, endDate2) => {
    if (startDate2 === endDate2) {
      return 1;
    }
    const diff = new Date(endDate2).getTime() - new Date(startDate2).getTime();
    return diff / (1e3 * 60 * 60 * 24);
  };
  const key = useMemo(() => {
    const searchParams = new URLSearchParams();
    searchParams.set("page", page.toString());
    searchParams.set(
      "size",
      (getPeriod(startDate, endDate) + (ignoreAggregation ? 0 : 1)).toString()
    );
    const modifiedStartDate = new Date(startDate);
    modifiedStartDate.setDate(new Date(startDate).getDate() - 1);
    searchParams.set(
      "start_date",
      modifiedStartDate.toISOString().split("T")[0]
    );
    searchParams.set("end_date", params.endDate);
    return `/v1/client/statistics/daily?${searchParams.toString()}`;
  }, [page, startDate, endDate]);
  const { data } = usePrivateQuery(key, {
    formatter: (data2) => data2.rows.reverse(),
    revalidateOnFocus: false
  });
  const aggregateValue = useMemo(() => {
    if (ignoreAggregation) {
      return { vol: null, pnl: null, roi: null };
    }
    let vol = y$3;
    let pnl = y$3;
    let roi = y$3;
    if (Array.isArray(data) && data.length) {
      const prevDate = data.shift();
      data.forEach((d2) => {
        vol = vol.add(d2.perp_volume);
        pnl = pnl.add(d2.pnl);
      });
      roi = pnl.div(prevDate.account_value);
    }
    return { vol: vol.toNumber(), pnl: pnl.toNumber(), roi: roi.toNumber() };
  }, [data]);
  return [
    data || [],
    {
      aggregateValue
    }
  ];
};
var useFundingFeeHistory = (params, options) => {
  let { symbol, dataRange, page = 1, pageSize = 10 } = params;
  const infos = useSymbolsInfo();
  const getKey = () => {
    const search = new URLSearchParams();
    if (typeof symbol !== "undefined" && symbol !== "All") {
      search.set("symbol", symbol);
    }
    search.set("page", `${page}`);
    search.set("size", `${pageSize}`);
    if (dataRange) {
      search.set("start_t", dataRange[0].toString());
      search.set("end_t", dataRange[1].toString());
    }
    return `/v1/funding_fee/history?${search.toString()}`;
  };
  const { data, isLoading, isValidating } = usePrivateQuery(getKey(), {
    // initialSize: 1,
    formatter: (data2) => data2,
    revalidateOnFocus: false,
    errorRetryCount: 3,
    // keepPreviousData: true,
    ...options
  });
  const parsedData = useMemo(() => {
    if (!data || !Array.isArray(data == null ? void 0 : data.rows) || infos.isNil) {
      return null;
    }
    return data.rows.map((row) => {
      const config2 = infos[row.symbol];
      return {
        ...row,
        annual_rate: row.funding_rate * (24 / config2("funding_period")) * 365
      };
    });
  }, [data, infos]);
  return [
    parsedData,
    {
      meta: data == null ? void 0 : data.meta,
      isLoading,
      isValidating
    }
  ];
};
var useDistributionHistory = (parmas) => {
  let { type, dataRange, page, pageSize } = parmas;
  const infos = useSymbolsInfo();
  const getKey = () => {
    const search = new URLSearchParams();
    if (typeof type !== "undefined" && type !== "All") {
      search.set("type", type);
    }
    search.set("page", page.toString());
    search.set("size", pageSize.toString());
    if (dataRange) {
      search.set("start_t", dataRange[0].toString());
      search.set("end_t", dataRange[1].toString());
    }
    return `/v1/client/distribution_history?${search.toString()}`;
  };
  const { data, isLoading, isValidating } = usePrivateQuery(getKey(), {
    // initialSize: 1,
    formatter: (data2) => data2,
    revalidateOnFocus: false,
    errorRetryCount: 3
  });
  const parsedData = useMemo(() => {
    if (!Array.isArray(data == null ? void 0 : data.rows) || !(data == null ? void 0 : data.rows.length) || infos.isNil) {
      return [];
    }
    return data.rows.map((row) => {
      const config2 = infos[row.symbol];
      return {
        ...row,
        annual_rate: row.funding_rate * (24 / config2("funding_period"))
      };
    });
  }, [data, infos]);
  return [
    parsedData,
    {
      meta: data == null ? void 0 : data.meta,
      isLoading,
      isValidating
    }
  ];
};
function useMaintenanceStatus() {
  const [status, setStatus] = useState(0);
  const [startTime, setStartTime] = useState();
  const [endTime, setEndTime] = useState();
  const [brokerName, setBrokerName] = useState("Orderly network");
  const { data: systemInfo, mutate: mutate3 } = useQuery(
    `/v1/public/system_info?source=maintenance`,
    {
      revalidateOnFocus: false,
      errorRetryCount: 2,
      errorRetryInterval: 200
    }
  );
  const ws2 = useWS();
  const config2 = useConfig();
  useEffect(() => {
    if (!systemInfo) {
      return;
    }
    const brokerName2 = config2.get("brokerName");
    if (brokerName2) {
      setBrokerName(brokerName2);
    }
    if (systemInfo.scheduled_maintenance) {
      setStartTime(systemInfo.scheduled_maintenance.start_time);
      setEndTime(systemInfo.scheduled_maintenance.end_time);
    }
    if (systemInfo.status === 2) {
      setStatus(2);
    }
  }, [systemInfo, config2]);
  useEffect(() => {
    const unsubscribe = ws2.subscribe(`maintenance_status`, {
      onMessage: (message) => {
        setStatus(message.status);
        if (message.scheduled_maintenance) {
          setStartTime(message.scheduled_maintenance.start_time);
          setEndTime(message.scheduled_maintenance.end_time);
        }
      }
    });
    return () => {
      unsubscribe == null ? void 0 : unsubscribe();
    };
  }, []);
  return {
    status,
    brokerName,
    startTime,
    endTime
  };
}
var useStorageLedgerAddress = () => {
  const [ledgerWallet, setLedgerWallet] = useLocalStorage(LedgerWalletKey, []);
  const setLedgerAddress = (address) => {
    if (!ledgerWallet.includes(address)) {
      const arr = [...ledgerWallet, address];
      setLedgerWallet(arr);
    }
  };
  return {
    setLedgerAddress,
    ledgerWallet
  };
};
var usePrivateDataObserver = (options) => {
  const ws2 = useWS();
  const ee2 = useEventEmitter();
  const { state, account: account5 } = useAccount();
  const { setAccountInfo, restoreHolding, cleanAll } = useAppStore(
    (state2) => state2.actions
  );
  const statusActions = useApiStatusActions();
  const calculatorService = useCalculatorService();
  const positionsActions = usePositionActions();
  const { data: clientInfo } = usePrivateQuery("/v1/client/info");
  useEffect(() => {
    if (clientInfo) {
      setAccountInfo(clientInfo);
    }
  }, [clientInfo, setAccountInfo]);
  const { data: positions2, isLoading: isPositionLoading } = usePrivateQuery("/v1/positions", {
    formatter: (data) => data,
    onError: (error) => {
      statusActions.updateApiError("positions", error.message);
    }
    // revalidateOnFocus: false,
  });
  useEffect(() => {
    const handler = (state2) => {
      if (!state2.accountId) {
        calculatorService.stop();
        cleanAll();
        positionsActions.clearAll();
      }
    };
    account5.on(E$4.statusChanged, handler);
    return () => {
      account5.off(E$4.statusChanged, handler);
    };
  }, []);
  useEffect(() => {
    if (isPositionLoading) {
      statusActions.updateApiLoading("positions", isPositionLoading);
    }
  }, [isPositionLoading, statusActions]);
  useEffect(() => {
    if (positions2 && Array.isArray(positions2.rows)) {
      calculatorService.calc("position", positions2);
    }
  }, [calculatorService, positions2]);
  const { data: holding } = usePrivateQuery(
    "/v1/client/holding",
    {
      formatter: (data) => data.holding
      // revalidateOnFocus: false,
    }
  );
  useEffect(() => {
    const unsubscribe = ws2.privateSubscribe(
      {
        id: "balance",
        event: "subscribe",
        topic: "balance",
        ts: Date.now()
      },
      {
        onMessage: (data) => {
          const holding2 = (data == null ? void 0 : data.balances) ?? {};
          if (holding2) {
            calculatorService.calc("portfolio", { holding: holding2 });
          }
        }
      }
    );
    return () => unsubscribe();
  }, []);
  useEffect(() => {
    if (holding) {
      restoreHolding(holding);
    }
  }, [holding]);
  const [subOrder, setSubOrder] = useLocalStorage(
    "orderly_subscribe_order",
    true
  );
  const updateOrders = (data, isAlgoOrder) => {
    const keysMap = options.getKeysMap("orders");
    keysMap.forEach((getKey, key) => {
      mutate$1(
        unstable_serialize((index, prevData) => [
          getKey(index, prevData),
          state.accountId
        ]),
        (prevData) => {
          try {
            if (isAlgoOrder) {
              const result = updateAlgoOrdersHandler(
                key,
                data,
                prevData
              );
              return result;
            }
            return updateOrdersHandler(key, data, prevData);
          } catch (error) {
            return prevData;
          }
        },
        {
          revalidate: false
        }
      );
    });
    const formattedData = isAlgoOrder ? AlgoOrderMergeHandler.groupOrders(data) : object2underscore(data);
    ee2.emit("orders:changed", {
      ...formattedData,
      status: isAlgoOrder ? formattedData.algo_status : data.status
    });
  };
  useEffect(() => {
    if (!state.accountId)
      return;
    if (subOrder !== true)
      return;
    const unsubscribe = ws2.privateSubscribe("executionreport", {
      onMessage: (data) => {
        updateOrders(data, false);
      }
    });
    return () => unsubscribe == null ? void 0 : unsubscribe();
  }, [state.accountId, subOrder]);
  useEffect(() => {
    if (!state.accountId)
      return;
    if (subOrder !== true)
      return;
    const unsubscribe = ws2.privateSubscribe("algoexecutionreport", {
      onMessage: (data) => {
        updateOrders(data, true);
      }
    });
    return () => unsubscribe == null ? void 0 : unsubscribe();
  }, [state.accountId, subOrder]);
  useEffect(() => {
    if (!state.accountId)
      return;
    const key = ["/v1/positions", state.accountId];
    const unsubscribe = ws2.privateSubscribe("position", {
      onMessage: (data) => {
        const { positions: nextPositions } = data;
        mutate$1(
          key,
          (prevPositions) => {
            if (!!prevPositions) {
              const newPositions = {
                ...prevPositions,
                rows: prevPositions.rows.map((row) => {
                  const itemIndex = nextPositions.findIndex(
                    (item) => item.symbol === row.symbol
                  );
                  if (itemIndex >= 0) {
                    const itemArr = nextPositions.splice(itemIndex, 1);
                    const item = itemArr[0];
                    if (item.averageOpenPrice === 0 && item.positionQty !== 0) {
                      return row;
                    }
                    return object2underscore(item);
                  }
                  return row;
                })
              };
              if (nextPositions.length > 0) {
                newPositions.rows = [
                  ...newPositions.rows,
                  ...nextPositions.map((item) => {
                    return object2underscore(item);
                  })
                ];
              }
              return newPositions;
            }
          },
          {
            revalidate: false
          }
        );
      }
    });
    return () => {
      unsubscribe == null ? void 0 : unsubscribe();
    };
  }, [state.accountId]);
};
var useWSObserver = (calculatorService) => {
  const ws2 = useWS();
  useEffect(() => {
    const markPriceSubscription = ws2.subscribe("markprices", {
      onMessage: (message) => {
        const data = /* @__PURE__ */ Object.create(null);
        for (let index = 0; index < message.length; index++) {
          const element = message[index];
          data[element.symbol] = element.price;
        }
        calculatorService.calc("markPrice", data, {
          skipWhenOnPause: true
        });
      },
      onError: (error) => {
      }
    });
    const indexPriceSubscription = ws2.subscribe("indexprices", {
      onMessage: (message) => {
        if (!Array.isArray(message))
          return;
        const prices = /* @__PURE__ */ Object.create(null);
        for (let index = 0; index < message.length; index++) {
          const element = message[index];
          prices[element.symbol.replace("SPOT", "PERP")] = element.price;
        }
        calculatorService.calc("indexPrice", prices, {
          skipWhenOnPause: true
        });
      }
    });
    return () => {
      markPriceSubscription == null ? void 0 : markPriceSubscription();
      indexPriceSubscription == null ? void 0 : indexPriceSubscription();
    };
  }, []);
};
var useMarketStore = create(
  (set2, get3) => ({
    market: [],
    // marketSymbols: [],
    marketMap: null,
    actions: {
      updateMarket: (data) => {
        const marketMap = {};
        data.forEach((item) => {
          marketMap[item.symbol] = item;
        });
        set2({
          market: data,
          // marketSymbols: symbols,
          marketMap
        });
      },
      updateTicker: (data) => {
        set2(
          produce((state) => {
            state.market = data;
          })
        );
      }
    }
  })
);
var publicQueryOptions = {
  focusThrottleInterval: 1e3 * 60 * 60 * 24,
  revalidateOnFocus: false,
  dedupingInterval: 1e3 * 60 * 60 * 24
};
var usePublicDataObserver = () => {
  const { setSymbolsInfo, setFundingRates } = useAppStore(
    (state) => state.actions
  );
  const { updateMarket } = useMarketStore((state) => state.actions);
  useQuery(`/v1/public/info`, {
    ...publicQueryOptions,
    onSuccess(data) {
      if (!data || !(data == null ? void 0 : data.length)) {
        return {};
      }
      const obj = {};
      for (let index = 0; index < data.length; index++) {
        const item = data[index];
        const arr = item.symbol.split("_");
        const base_dp = E$3(item.base_tick);
        const quote_dp = E$3(item.quote_tick);
        obj[item.symbol] = {
          ...item,
          base_dp,
          quote_dp,
          base: arr[1],
          quote: arr[2],
          type: arr[0],
          name: `${arr[1]}-${arr[0]}`
        };
      }
      setSymbolsInfo(obj);
    }
  });
  useQuery(`/v1/public/funding_rates`, {
    ...publicQueryOptions,
    onSuccess(data) {
      if (!data || !(data == null ? void 0 : data.length)) {
        return {};
      }
      const obj = /* @__PURE__ */ Object.create(null);
      for (let index = 0; index < data.length; index++) {
        const item = data[index];
        obj[item.symbol] = {
          ...item,
          est_funding_rate: getEstFundingRate(item)
        };
      }
      setFundingRates(obj);
    }
  });
  useQuery(`/v1/public/futures`, {
    // revalidateOnFocus: false,
    ...publicQueryOptions,
    onSuccess(data) {
      if (!data || !(data == null ? void 0 : data.length)) {
        return [];
      }
      updateMarket(data);
    }
  });
};
function getEstFundingRate(data) {
  if (!data)
    return;
  const { next_funding_time, est_funding_rate } = data;
  if (Date.now() > next_funding_time) {
    return null;
  }
  return est_funding_rate;
}
var DataCenterContext = createContext(
  {}
);
var useDataCenterContext = () => useContext(DataCenterContext);
var DataCenterProvider = ({ children }) => {
  const { error, done } = usePreLoadData();
  const calculatorService = useCalculatorService();
  usePublicDataObserver();
  useWSObserver(calculatorService);
  const getKeyHandlerMapRef = useRef(/* @__PURE__ */ new Map());
  usePrivateDataObserver({
    getKeysMap(type) {
      return getKeyHandlerMapRef.current;
    }
  });
  if (error) {
    return /* @__PURE__ */ jsx("div", { children: "Data load failed" });
  }
  if (!done)
    return null;
  return /* @__PURE__ */ jsx(
    DataCenterContext.Provider,
    {
      value: {
        registerKeyHandler: (key, fun) => {
          getKeyHandlerMapRef.current.set(key, fun);
        },
        unregisterKeyHandler: (key) => {
          getKeyHandlerMapRef.current.delete(key);
        }
      },
      children
    }
  );
};
var ProxyConfigStore = class {
  constructor(_originConfigStore) {
    this._originConfigStore = _originConfigStore;
    w$4(() => {
      this._proxyConfigStore = window.__ORDERLY_CONFIG_STORE__ || _originConfigStore;
    });
  }
  get(key) {
    var _a2;
    const value = (_a2 = this._proxyConfigStore) == null ? void 0 : _a2.get(key);
    if (typeof value === "undefined") {
      return this._originConfigStore.get(key);
    }
    return value;
  }
  getOr(key, defaultValue) {
    return (this._proxyConfigStore ?? this._originConfigStore).getOr(
      key,
      defaultValue
    );
  }
  set(key, value) {
    (this._proxyConfigStore ?? this._originConfigStore).set(key, value);
  }
  clear() {
    throw new SDKError("Method not implemented.");
  }
  getFromOrigin(key) {
    return this._originConfigStore.get(key);
  }
  getOrFromOrigin(key, defaultValue) {
    return this._originConfigStore.getOr(key, defaultValue);
  }
  setToOrigin(key, value) {
    this._originConfigStore.set(key, value);
  }
  clearOrigin() {
    this._originConfigStore.clear();
  }
};
var ExtendedConfigStore = class extends Tt$5 {
  constructor(init2) {
    super(init2);
  }
  get(key) {
    if (key === MarketsStorageKey) {
      const jsonStr = localStorage.getItem(MarketsStorageKey);
      if (!jsonStr) {
        const oldJsonStr = localStorage.getItem(
          MarketsStorageKey.replace("orderly_", "")
        );
        return oldJsonStr ? JSON.parse(oldJsonStr) : "";
      }
      return JSON.parse(jsonStr);
    }
    return super.get(key);
  }
  set(key, value) {
    if (key === MarketsStorageKey) {
      const jsonStr = JSON.stringify(value);
      localStorage.setItem(MarketsStorageKey, jsonStr);
      return;
    }
    super.set(key, value);
  }
};
var OrderlyConfigProvider = (props) => {
  const [account5, setAccount] = Ce__default__default.useState(null);
  const {
    configStore,
    keyStore,
    // getWalletAdapter,
    walletAdapters,
    brokerId,
    brokerName,
    networkId,
    contracts,
    chainFilter,
    customChains
  } = props;
  if (typeof configStore !== "undefined" && !configStore.get("brokerId")) {
    throw new SDKError(
      "if configStore is provided, brokerId is required in configStore"
    );
  }
  if (typeof brokerId !== "undefined" && typeof configStore !== "undefined" && brokerId !== configStore.get("brokerId")) {
    throw new SDKError(
      "If you have provided a custom `configStore` and the `brokerId` is set in the `configStore`, please remove the `brokerId` prop."
    );
  }
  const innerConfigStore = useMemo(() => {
    return new ProxyConfigStore(
      configStore || new ExtendedConfigStore({ brokerId, brokerName, networkId })
    );
  }, [configStore, brokerId, brokerName, networkId]);
  const innerKeyStore = useMemo(() => {
    return keyStore || new be$7(networkId);
  }, [networkId, keyStore]);
  const innerWalletAdapters = useMemo(() => {
    return walletAdapters || [
      new w$3(new w$2()),
      new ve$5()
    ];
  }, [walletAdapters]);
  useLayoutEffect(() => {
    let account6 = qr$2.get(Le$7.instanceName);
    if (!account6) {
      account6 = new Le$7(
        innerConfigStore,
        innerKeyStore,
        // innerGetWalletAdapter,
        innerWalletAdapters,
        {
          contracts
        }
      );
      qr$2.registerByName(Le$7.instanceName, account6);
    }
    setAccount(account6);
  }, []);
  const filteredChains = useMemo(() => {
    if (typeof chainFilter === "function") {
      return chainFilter(innerConfigStore);
    }
    return chainFilter;
  }, [props.chainFilter, innerConfigStore]);
  if (!account5) {
    return null;
  }
  return /* @__PURE__ */ jsx(
    OrderlyProvider,
    {
      value: {
        configStore: innerConfigStore,
        keyStore: innerKeyStore,
        // getWalletAdapter: innerGetWalletAdapter,
        networkId: innerConfigStore.get("networkId") || networkId,
        filteredChains,
        walletAdapters: innerWalletAdapters,
        // apiBaseUrl,
        customChains
      },
      children: /* @__PURE__ */ jsx(StatusProvider, { children: /* @__PURE__ */ jsx(DataCenterProvider, { children: props.children }) })
    }
  );
};
var WalletConnectorContext = createContext({});
var useWalletConnector = () => {
  return useContext(WalletConnectorContext);
};
var needNumberOnlyFields = [
  "order_quantity",
  "order_price",
  "trigger_price",
  "total"
];
var cleanStringStyle = (str) => {
  if (typeof str !== "string") {
    str = `${str}`;
  }
  str = str.replace(/,/g, "");
  str = str.replace(/[^\d.]/g, "").replace(".", "$#$").replace(/\./g, "").replace("$#$", ".");
  return str;
};
function baseInputHandle(inputs) {
  let [values2, input, value, markPrice, config2] = inputs;
  needNumberOnlyFields.forEach((field) => {
    if (typeof values2[field] !== "undefined") {
      values2[field] = cleanStringStyle(values2[field]);
    }
  });
  if (needNumberOnlyFields.includes(input)) {
    value = cleanStringStyle(value);
  }
  return [
    {
      ...values2,
      [input]: value
    },
    input,
    value,
    markPrice,
    config2
  ];
}
function orderTypeHandle(inputs) {
  const [values2, input, value, markPrice, config2] = inputs;
  if (value === OrderType.LIMIT || value === OrderType.STOP_LIMIT) {
    if (values2.order_price === "") {
      values2.total = "";
    }
  }
  if (value === OrderType.MARKET || value === OrderType.LIMIT) {
    values2.trigger_price = void 0;
  }
  if (value === OrderType.MARKET || value === OrderType.STOP_MARKET) ;
  return [values2, input, value, markPrice, config2];
}
function orderEntityFormatHandle(baseTick, quoteTick) {
  return function(inputs) {
    const [values2, input, value, markPrice, config2] = inputs;
    return [values2, input, value, markPrice, config2];
  };
}
function priceInputHandle(inputs) {
  const [values2, input, value, markPrice, config2] = inputs;
  if (value === "") {
    return [{ ...values2, total: "" }, input, value, markPrice, config2];
  }
  const price = new g$6(value);
  const priceDP = price.dp();
  if (priceDP > config2.quote_dp) {
    values2.order_price = price.toDecimalPlaces(config2.quote_dp).toString();
  }
  price.toDecimalPlaces(Math.min(priceDP, config2.quote_dp));
  if (!values2.order_quantity && !values2.total) {
    return [values2, input, value, markPrice, config2];
  }
  const newValue = {
    ...values2
  };
  if (values2.order_quantity) {
    newValue.total = price.mul(values2.order_quantity).todp(2).toString();
  } else if (values2.total) {
    newValue.order_quantity = new g$6(values2.total).div(price).todp(config2.base_dp).toString();
  }
  return [
    // {
    //   ...values,
    //   total: total.todp(2).toString(),
    // },
    newValue,
    input,
    value,
    markPrice,
    config2
  ];
}
function quantityInputHandle(inputs) {
  const [values2, input, value, markPrice, config2] = inputs;
  if (value === "") {
    return [{ ...values2, total: "" }, input, value, markPrice, config2];
  }
  let quantity = new g$6(value);
  const quantityDP = quantity.dp();
  if (quantityDP > config2.base_dp) {
    quantity = quantity.toDecimalPlaces(config2.base_dp);
    values2.order_quantity = quantity.toString();
  }
  if (values2.order_type === OrderType.MARKET || values2.order_type === OrderType.STOP_MARKET) {
    if (!markPrice) {
      return [values2, input, value, markPrice, config2];
    }
    const price = markPrice;
    values2.order_price = "";
    values2.total = quantity.mul(price).todp(2).toString();
  }
  if (values2.order_type === OrderType.LIMIT || values2.order_type === OrderType.STOP_LIMIT) {
    if (values2.order_price) {
      const price = Number(values2.order_price);
      const total = quantity.mul(price);
      values2.total = total.todp(config2.quote_dp).toString();
    } else {
      values2.total = "";
    }
  }
  return [
    {
      ...values2
    },
    input,
    value,
    markPrice,
    config2
  ];
}
function totalInputHandle(inputs) {
  const [values2, input, value, markPrice, config2] = inputs;
  if (value === "") {
    return [{ ...values2, order_quantity: "" }, input, value, markPrice, config2];
  }
  let price = markPrice;
  if ((values2.order_type === OrderType.LIMIT || values2.order_type === OrderType.STOP_LIMIT) && !!values2.order_price) {
    price = Number(values2.order_price);
  }
  let total = new g$6(value);
  const totalDP = total.dp();
  if (totalDP > config2.quote_dp) {
    total = total.toDecimalPlaces(config2.quote_dp);
    values2.total = total.toString();
  }
  const quantity = total.div(price);
  let order_quantity = quantity.toDecimalPlaces(Math.min(config2.base_dp, quantity.dp())).toString();
  if (config2.base_tick >= 1) {
    order_quantity = formatNumber(
      order_quantity,
      new g$6((config2 == null ? void 0 : config2.base_tick) || "0").toNumber()
    );
  }
  return [
    {
      ...values2,
      order_quantity
    },
    input,
    value,
    markPrice,
    config2
  ];
}
function tpslInputHandle(inputs) {
  const [values2, input, value, markPrice, config2] = inputs;
  const price = values2.order_type === OrderType.MARKET || values2.order_type === OrderType.STOP_MARKET ? markPrice : values2.order_price;
  if (!price || !values2.order_quantity) {
    return [values2, input, value, markPrice, config2];
  }
  const _tpslValue = tpslCalculateHelper(
    input,
    {
      value,
      entryPrice: price,
      // order price or mark price
      qty: values2.side === OrderSide.BUY ? Number(values2.order_quantity) : Number(values2.order_quantity) * -1,
      orderSide: values2.side
      // values: newValues,
    },
    {
      symbol: config2
    }
  );
  return [{ ...values2, ..._tpslValue }, input, value, markPrice, config2];
}
function otherInputHandle(inputs) {
  return inputs;
}
var getCalculateHandler = (fieldName) => {
  switch (fieldName) {
    case "order_type":
      return orderTypeHandle;
    case "order_quantity": {
      return quantityInputHandle;
    }
    case "order_price": {
      return priceInputHandle;
    }
    case "total": {
      return totalInputHandle;
    }
    case "tp_pnl":
    case "sl_pnl":
    case "tp_trigger_price":
    case "sl_trigger_price":
    case "tp_offset":
    case "sl_offset":
    case "tp_offset_percentage":
    case "sl_offset_percentage":
      return tpslInputHandle;
    default:
      return otherInputHandle;
  }
};
function formatNumber(qty, dp) {
  if (typeof qty === "undefined")
    return qty;
  if (typeof dp === "undefined")
    return `${qty}`;
  const _qty = `${qty}`.replace(/,/g, "");
  try {
    const _dp = new g$6(dp);
    const _qtyDecimal = new g$6(_qty);
    if (_dp.lessThan(1)) {
      if (`${_qty}`.endsWith("."))
        return `${_qty}`;
      const numStr = dp.toString();
      const decimalIndex = numStr.indexOf(".");
      const digitsAfterDecimal = decimalIndex === -1 ? 0 : numStr.length - decimalIndex - 1;
      const result = _qtyDecimal.toDecimalPlaces(digitsAfterDecimal, g$6.ROUND_DOWN).toString();
      return result;
    }
    if (_qtyDecimal.lessThan(_dp)) {
      return _qty;
    }
    return _qtyDecimal.dividedBy(_dp).toDecimalPlaces(0, g$6.ROUND_DOWN).mul(dp).toString();
  } catch (e3) {
    return void 0;
  }
}
function useOrderEntry(symbolOrOrder, sideOrOptions, reduceOnly, options) {
  let isNewVersion = false;
  if (typeof symbolOrOrder === "object") {
    isNewVersion = true;
    if (!symbolOrOrder.symbol) {
      throw new SDKError("Symbol is required");
    }
    if (!symbolOrOrder.side) {
      throw new SDKError("Order side is required");
    }
    if (!symbolOrOrder.order_type) {
      throw new SDKError("Order type is required");
    }
  }
  const prevOrderData = useRef(null);
  const orderDataCache = useRef(null);
  const notSupportData = useRef({});
  const [errors, setErrors] = useState(null);
  const ee2 = useEventEmitter();
  const positions2 = usePositions();
  const fieldDirty = useRef({});
  const submitted = useRef(false);
  const askAndBid = useRef([]);
  const onOrderBookUpdate = useDebouncedCallback((data) => {
    askAndBid.current = data;
  }, 200);
  const { freeCollateral: freeCollateral2, totalCollateral: totalCollateral2, accountInfo } = useCollateral();
  const symbolInfo = useSymbolsInfo();
  const symbol = useMemo(() => {
    if (typeof symbolOrOrder === "string") {
      return symbolOrOrder;
    }
    return symbolOrOrder.symbol;
  }, [symbolOrOrder]);
  const optionsValue = useMemo(() => {
    if (typeof sideOrOptions === "object") {
      return sideOrOptions;
    }
    return options;
  }, [sideOrOptions]);
  const isReduceOnly = useMemo(() => {
    if (typeof reduceOnly === "boolean") {
      return reduceOnly;
    }
    if (typeof symbolOrOrder === "object") {
      return !!symbolOrOrder.reduce_only;
    }
    return false;
  }, [symbolOrOrder, reduceOnly]);
  const sideValue = useMemo(() => {
    if (typeof symbolOrOrder === "object") {
      return symbolOrOrder.side;
    }
    return sideOrOptions;
  }, [symbolOrOrder, sideOrOptions]);
  const baseDP = useMemo(
    () => E$3(symbolInfo[symbol]("base_tick", 0)),
    [symbolInfo]
  );
  const quoteDP = useMemo(() => {
    return E$3(symbolInfo[symbol]("quote_tick", 0));
  }, [symbolInfo]);
  const baseIMR = useMemo(
    () => symbolInfo[symbol]("base_imr", 0),
    [symbolInfo]
  );
  const baseMMR = useMemo(
    () => symbolInfo[symbol]("base_mmr", 0),
    [symbolInfo]
  );
  const { data: markPrice } = useMarkPrice(symbol);
  const diffOrderEntry = (prev, current) => {
    if (!prev)
      return null;
    let key, value, preValue;
    const keys = Object.keys(current);
    for (let i = 0; i < keys.length; i++) {
      const k2 = keys[i];
      let preveValue = prev[k2];
      let currentValue = current[k2];
      if (typeof preveValue === "undefined" && typeof currentValue === "undefined")
        continue;
      if (preveValue !== currentValue) {
        key = k2;
        value = currentValue;
        preValue = preveValue;
        break;
      }
    }
    if (!key)
      return null;
    return { key, value, preValue };
  };
  const maxQty2 = useMaxQty(symbol, sideValue, isReduceOnly);
  const parseString2Number = (order, key, dp) => {
    if (typeof order[key] !== "string")
      return;
    if (order[key] && order[key].startsWith(".")) {
      order[key] = `0${order[key]}`;
    }
    order[key] = order[key].replace(/,/g, "");
    if (dp && order[key].length > 0) {
      const hasPoint = `${order[key]}`.includes(".");
      const endOfPoint = `${order[key]}`.endsWith(".");
      const decimalPart = `${order[key]}`.split(".");
      if (hasPoint && !endOfPoint) {
        order[key] = `${decimalPart[0]}.${decimalPart[1].slice(
          0,
          quoteDP
        )}`;
      }
    }
  };
  const needParse = useMemo(() => {
    if (typeof symbolOrOrder === "string") {
      return null;
    }
    return pick([
      "order_price",
      "side",
      "order_quantity",
      "visible_quantity",
      "order_type",
      "order_type_ext",
      "symbol",
      "total",
      "reduce_only",
      "trigger_price"
    ])(
      //@ts-ignore
      symbolOrOrder
    );
  }, [symbolOrOrder]);
  const parsedData = useMemo(() => {
    if (typeof symbolOrOrder === "string") {
      return null;
    }
    if (typeof symbolOrOrder.order_quantity === "string") {
      parseString2Number(symbolOrOrder, "order_quantity");
    } else if (typeof symbolOrOrder.order_quantity === "number") {
      symbolOrOrder.order_quantity = new g$6(symbolOrOrder.order_quantity).toDecimalPlaces(baseDP).toString();
    }
    if (typeof symbolOrOrder.order_price === "string") {
      parseString2Number(symbolOrOrder, "order_price", quoteDP);
    }
    if (typeof symbolOrOrder.total === "string") {
      parseString2Number(symbolOrOrder, "total", quoteDP);
    }
    if (typeof symbolOrOrder.trigger_price === "string") {
      parseString2Number(symbolOrOrder, "trigger_price", quoteDP);
    }
    return symbolOrOrder;
  }, [
    needParse == null ? void 0 : needParse.order_price,
    needParse == null ? void 0 : needParse.order_quantity,
    needParse == null ? void 0 : needParse.total,
    needParse == null ? void 0 : needParse.trigger_price,
    needParse == null ? void 0 : needParse.order_type,
    needParse == null ? void 0 : needParse.order_type_ext,
    needParse == null ? void 0 : needParse.symbol,
    needParse == null ? void 0 : needParse.reduce_only,
    needParse == null ? void 0 : needParse.side,
    needParse == null ? void 0 : needParse.visible_quantity,
    quoteDP,
    baseDP
  ]);
  const isAlgoOrder = (parsedData == null ? void 0 : parsedData.order_type) === OrderType.STOP_LIMIT || (parsedData == null ? void 0 : parsedData.order_type) === OrderType.STOP_MARKET || (parsedData == null ? void 0 : parsedData.order_type) === OrderType.CLOSE_POSITION;
  const [doCreateOrder, { isMutating }] = useMutation(
    isAlgoOrder ? "/v1/algo/order" : "/v1/order"
  );
  const createOrder = (values2) => {
    if (!values2.symbol) {
      throw new SDKError("Symbol is error");
    }
    if (!values2.side) {
      throw new SDKError("Order side is error");
    }
    if (!values2 || typeof values2.order_type === "undefined") {
      throw new SDKError("Order type is error");
    }
    const orderCreator = OrderFactory.create(
      // @ts-ignore
      values2.order_type_ext ? values2.order_type_ext : values2.order_type
    );
    if (!orderCreator) {
      return Promise.reject(new SDKError("Order creator is null"));
    }
    return new Promise((resolve, reject) => {
      return orderCreator.validate(values2, {
        symbol: symbolInfo[symbol](),
        // token: tokenInfo[symbol](),
        maxQty: maxQty2,
        markPrice
      }).then((errors2) => {
        var _a2, _b2;
        submitted.current = true;
        if (errors2.order_price || errors2.order_quantity || errors2.trigger_price || errors2.total) {
          setErrors(errors2);
          reject(
            ((_a2 = errors2.order_price) == null ? void 0 : _a2.message) || ((_b2 = errors2.order_quantity) == null ? void 0 : _b2.message)
          );
        } else {
          const data = orderCreator.create(values2, {
            symbol: symbolInfo[symbol](),
            maxQty: maxQty2,
            markPrice
          });
          return doCreateOrder(
            omit(["order_type_ext"], {
              // ...values,
              // ...omit(["order_price"], values),
              ...data
            })
          ).then((res) => {
            if (res && res.success) {
              resolve(res.data);
            } else {
              reject(res);
            }
          }, reject);
        }
      });
    });
  };
  const onSubmit = (values2) => {
    if (typeof reduceOnly === "boolean" && reduceOnly && !values2.reduce_only) {
      return Promise.reject(
        new SDKError(
          "The reduceOny parameter of hook does not match your order data"
        )
      );
    }
    return createOrder({
      ...values2,
      symbol
    });
  };
  const submit = useCallback(() => {
    if (!parsedData) {
      throw new SDKError("Function is not supported, please use onSubmit()");
    }
    return createOrder(parsedData);
  }, [parsedData]);
  const calculate = useCallback(
    (values2, field, value) => {
      const fieldHandler = getCalculateHandler(field);
      const newValues = compose(
        head,
        orderEntityFormatHandle(),
        fieldHandler,
        baseInputHandle
      )([
        values2,
        field,
        value,
        markPrice,
        { base_dp: baseDP, quote_dp: quoteDP }
      ]);
      return newValues;
    },
    [markPrice]
  );
  const validator = (values2) => {
    const creator = OrderFactory.create(values2.order_type);
    return creator == null ? void 0 : creator.validate(values2, {
      symbol: symbolInfo[symbol](),
      // token: tokenInfo[symbol](),
      maxQty: maxQty2,
      markPrice
    });
  };
  const formattedOrder = useMemo(() => {
    var _a2;
    if (!parsedData) {
      return notSupportData.current;
    }
    if (!prevOrderData.current) {
      prevOrderData.current = parsedData;
      orderDataCache.current = {
        ...parsedData,
        total: ""
      };
      return orderDataCache.current;
    }
    const item = diffOrderEntry(prevOrderData.current, parsedData);
    if (!item) {
      return orderDataCache.current;
    }
    if (typeof parsedData.order_price !== "undefined") {
      fieldDirty.current.order_price = true;
    }
    if (typeof parsedData.order_quantity !== "undefined") {
      fieldDirty.current.order_quantity = true;
    }
    const values2 = calculate(parsedData, item.key, item.value);
    values2.isStopOrder = ((_a2 = values2.order_type) == null ? void 0 : _a2.startsWith("STOP")) || false;
    values2.total = values2.total || "";
    prevOrderData.current = parsedData;
    orderDataCache.current = values2;
    return values2;
  }, [parsedData, markPrice]);
  useEffect(() => {
    var _a2;
    if (!markPrice || symbolInfo.isNil)
      return;
    (_a2 = validator(formattedOrder)) == null ? void 0 : _a2.then((err) => {
      setErrors(err);
    }).catch((err) => {
    });
  }, [
    formattedOrder.broker_id,
    formattedOrder.order_quantity,
    formattedOrder.total,
    formattedOrder.trigger_price,
    formattedOrder.order_type,
    markPrice
  ]);
  useEffect(() => {
    if (isNewVersion) {
      if (!(optionsValue == null ? void 0 : optionsValue.watchOrderbook)) {
        throw new SDKError(
          "In order to calculate the estimated liquidation price, the `options.watchOrderbook` parameter must be set to true."
        );
      }
    } else {
      if (!(optionsValue == null ? void 0 : optionsValue.watchOrderbook)) {
        return;
      }
    }
    ee2.on("orderbook:update", onOrderBookUpdate);
    return () => {
      ee2.off("orderbook:update", onOrderBookUpdate);
    };
  }, [optionsValue == null ? void 0 : optionsValue.watchOrderbook]);
  useEffect(() => {
    askAndBid.current = [];
  }, [parsedData == null ? void 0 : parsedData.symbol]);
  const getPriceAndQty2 = (symbolOrOrder2) => {
    let quantity = Number(symbolOrOrder2.order_quantity);
    const orderPrice = Number(symbolOrOrder2.order_price);
    if (isNaN(quantity) || quantity <= 0) {
      return null;
    }
    if ((symbolOrOrder2.order_type === OrderType.LIMIT || symbolOrOrder2.order_type === OrderType.STOP_LIMIT) && isNaN(orderPrice))
      return null;
    let price;
    if (symbolOrOrder2.order_type === OrderType.MARKET || symbolOrOrder2.order_type === OrderType.STOP_MARKET) {
      if (symbolOrOrder2.side === OrderSide.BUY) {
        price = askAndBid.current[0];
      } else {
        price = askAndBid.current[1];
      }
    } else {
      if (symbolOrOrder2.side === OrderSide.BUY) {
        if (orderPrice >= askAndBid.current[0]) {
          price = askAndBid.current[0];
        } else {
          price = orderPrice;
        }
      } else {
        if (orderPrice <= askAndBid.current[1]) {
          price = askAndBid.current[1];
        } else {
          price = orderPrice;
        }
      }
    }
    if (symbolOrOrder2.side === OrderSide.SELL) {
      quantity = -quantity;
    }
    return { price, quantity };
  };
  const estLiqPrice2 = useMemo(() => {
    if (!accountInfo || !parsedData || !markPrice)
      return null;
    const result = getPriceAndQty2(formattedOrder);
    if (result === null)
      return null;
    const { price, quantity } = result;
    if (!price || !quantity)
      return null;
    const orderFee2 = order_exports.orderFee({
      qty: quantity,
      price,
      futuresTakeFeeRate: Number(accountInfo["futures_taker_fee_rate"]) / 1e4
    });
    const liqPrice2 = order_exports.estLiqPrice({
      markPrice,
      baseIMR,
      baseMMR,
      totalCollateral: totalCollateral2,
      positions: positions2 == null ? [] : positions2,
      IMR_Factor: accountInfo["imr_factor"][symbol],
      orderFee: orderFee2,
      newOrder: {
        qty: quantity,
        price,
        symbol: parsedData.symbol
      }
    });
    if (liqPrice2 <= 0)
      return null;
    return liqPrice2;
  }, [
    markPrice,
    baseIMR,
    baseMMR,
    totalCollateral2,
    formattedOrder == null ? void 0 : formattedOrder.order_price,
    formattedOrder == null ? void 0 : formattedOrder.order_quantity,
    formattedOrder == null ? void 0 : formattedOrder.total,
    formattedOrder == null ? void 0 : formattedOrder.trigger_price,
    accountInfo
  ]);
  const estLeverage2 = useMemo(() => {
    if (!accountInfo || !parsedData)
      return null;
    const result = getPriceAndQty2(formattedOrder);
    if (result === null || !result.price || !result.quantity)
      return null;
    const leverage = order_exports.estLeverage({
      totalCollateral: totalCollateral2,
      positions: positions2 === null ? [] : positions2,
      newOrder: {
        symbol: parsedData.symbol,
        qty: result.quantity,
        price: result.price
      }
    });
    return leverage;
  }, [
    baseIMR,
    baseMMR,
    totalCollateral2,
    positions2,
    formattedOrder == null ? void 0 : formattedOrder.order_price,
    formattedOrder == null ? void 0 : formattedOrder.order_quantity,
    formattedOrder == null ? void 0 : formattedOrder.total,
    formattedOrder == null ? void 0 : formattedOrder.trigger_price
  ]);
  return {
    maxQty: maxQty2,
    freeCollateral: freeCollateral2,
    markPrice,
    onSubmit,
    submit,
    submitting: isMutating,
    formattedOrder,
    // errors,
    estLiqPrice: estLiqPrice2,
    estLeverage: estLeverage2,
    helper: {
      //@ts-ignore
      calculate,
      validator
      // clearErrors,
    },
    metaState: {
      dirty: fieldDirty.current,
      submitted: submitted.current,
      errors
    },
    symbolConfig: symbolInfo[symbol]()
  };
}
function useMediaQuery(query) {
  const getMatches = (query2) => {
    if (typeof window !== "undefined") {
      return window.matchMedia(query2).matches;
    }
    return false;
  };
  const [matches, setMatches] = useState(getMatches(query));
  function handleChange() {
    setMatches(getMatches(query));
  }
  useEffect(() => {
    var _a2;
    const matchMedia = window == null ? void 0 : window.matchMedia(query);
    handleChange();
    if (matchMedia == null ? void 0 : matchMedia.addListener) {
      matchMedia == null ? void 0 : matchMedia.addListener(handleChange);
    } else {
      (_a2 = matchMedia == null ? void 0 : matchMedia.addEventListener) == null ? void 0 : _a2.call(matchMedia, "change", handleChange);
    }
    return () => {
      var _a3;
      if (matchMedia == null ? void 0 : matchMedia.removeListener) {
        matchMedia == null ? void 0 : matchMedia.removeListener(handleChange);
      } else {
        (_a3 = matchMedia == null ? void 0 : matchMedia.removeEventListener) == null ? void 0 : _a3.call(matchMedia, "change", handleChange);
      }
    };
  }, [query]);
  return matches;
}
var BasePaint = class {
  constructor(ctx, painter) {
    this.ctx = ctx;
    this.painter = painter;
  }
};
var BackgroundPaint = class extends BasePaint {
  constructor() {
    super(...arguments);
    this.img = null;
  }
  async draw(options) {
    if (typeof options.backgroundImg !== "undefined" && options.backgroundImg !== "") {
      return this._drawImage(options);
    } else if (typeof options.backgroundColor !== "undefined") {
      return this._drawColor(options);
    }
  }
  _drawColor(options) {
    this.ctx.fillStyle = options.backgroundColor || "black";
    this.ctx.fillRect(
      0,
      0,
      this.painter.width * this.painter.ratio,
      this.painter.height * this.painter.ratio
    );
  }
  async _drawImage(options) {
    return this.loadImg(options.backgroundImg).then((img) => {
      this.img = img;
      this.ctx.drawImage(
        this.img,
        0,
        0,
        this.painter.width * this.painter.ratio,
        this.painter.height * this.painter.ratio
      );
    });
  }
  loadImg(url) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.crossOrigin = "anonymous";
      img.onload = () => {
        resolve(img);
      };
      img.onerror = (e3) => {
        reject(e3);
      };
      img.src = url;
    });
  }
};
var qrPaint = (ctx, options) => {
  const { size, left, top, data, padding: padding2 } = options;
  const qr2 = qrcode(data);
  const canvas = document.createElement("canvas");
  canvas.width = size;
  canvas.height = size;
  const ctx2 = canvas.getContext("2d");
  const cells = qr2.modules;
  if (!cells) {
    return;
  }
  const tileW = size / cells.length;
  const tileH = size / cells.length;
  for (let r3 = 0; r3 < cells.length; ++r3) {
    const row = cells[r3];
    for (let c2 = 0; c2 < row.length; ++c2) {
      ctx2.fillStyle = row[c2] ? "#000" : "#fff";
      const w5 = Math.ceil((c2 + 1) * tileW) - Math.floor(c2 * tileW);
      const h2 = Math.ceil((r3 + 1) * tileH) - Math.floor(r3 * tileH);
      ctx2.fillRect(Math.round(c2 * tileW), Math.round(r3 * tileH), w5, h2);
    }
  }
  ctx.save();
  ctx.fillStyle = "#fff";
  ctx.fillRect(
    left - padding2,
    top - padding2,
    size + padding2 * 2,
    size + padding2 * 2
  );
  ctx.restore();
  ctx.drawImage(canvas, left, top, size, size);
};
var DataPaint = class extends BasePaint {
  constructor() {
    super(...arguments);
    this.positionInfoCellWidth = 90;
    this.DEFAULT_PROFIT_COLOR = "rgb(0,181,159)";
    this.DEFAULT_LOSS_COLOR = "rgb(255,103,194)";
    this.transformTop = 0;
    this.QRCODE_SIZE = 56;
  }
  async draw(options) {
    var _a2, _b2, _c2, _d2, _e4, _f2, _g3, _h2, _i3, _j2;
    const needDrawDetails = Array.isArray((_b2 = (_a2 = options.data) == null ? void 0 : _a2.position) == null ? void 0 : _b2.informations) && (((_e4 = (_d2 = (_c2 = options.data) == null ? void 0 : _c2.position) == null ? void 0 : _d2.informations) == null ? void 0 : _e4.length) ?? 0) > 0;
    const hasReferral = this.hasReferral(options);
    this.transformTop = 0;
    const offsetTop = 0;
    if (!!((_f2 = options.data) == null ? void 0 : _f2.message)) {
      this.drawMessage(options);
    }
    if (!!((_g3 = options.data) == null ? void 0 : _g3.position)) {
      this.drawPosition(
        options,
        needDrawDetails || hasReferral ? 0 : offsetTop
      );
    }
    if (needDrawDetails) {
      this.drawInformations(options);
    }
    this.drawUnrealizedPnL(
      options,
      needDrawDetails || hasReferral ? 0 : offsetTop
    );
    if (!hasReferral) {
      if (!!((_h2 = options.data) == null ? void 0 : _h2.domain)) {
        this.drawDomainUrl(options);
      }
      if (typeof ((_i3 = options.data) == null ? void 0 : _i3.updateTime) !== "undefined") {
        this.drawPositionTime(options);
      }
    }
    if (typeof ((_j2 = options.data) == null ? void 0 : _j2.referral) !== "undefined") {
      this.drawReferralCode(options);
    }
  }
  drawMessage(options) {
    var _a2;
    const layout = path(
      ["layout", "message"],
      options
    );
    const { position } = layout;
    this._drawText(`"${(_a2 = options.data) == null ? void 0 : _a2.message}"`, {
      color: layout.color,
      fontSize: this._ratio(layout.fontSize),
      top: this._ratio(position.top),
      left: this._ratio(position.left),
      textBaseline: "top",
      fontFamily: options.fontFamily
    });
  }
  drawPosition(options, offsetTop = 0) {
    var _a2, _b2, _c2, _d2, _e4, _f2;
    const layout = path(
      ["layout", "position"],
      options
    );
    const { position, fontSize = 14 } = layout;
    let left = this._ratio(position.left);
    let top = layout.position.top + offsetTop + this.transformTop;
    let prevElementBoundingBox = {};
    if (typeof ((_a2 = options.data) == null ? void 0 : _a2.position.side) !== "undefined") {
      prevElementBoundingBox = this._drawText(options.data.position.side, {
        color: ((_b2 = options.data) == null ? void 0 : _b2.position.side.toUpperCase()) === "LONG" ? options.profitColor || this.DEFAULT_PROFIT_COLOR : options.lossColor || this.DEFAULT_LOSS_COLOR,
        left,
        top: this._ratio(top),
        fontSize: this._ratio(fontSize),
        fontFamily: options.fontFamily
      });
    }
    if (typeof ((_c2 = options.data) == null ? void 0 : _c2.position.symbol) !== "undefined") {
      left += (prevElementBoundingBox.width ?? 0) + this._ratio(7);
      if (prevElementBoundingBox.width) {
        prevElementBoundingBox = this._drawText("|", {
          color: "rgba(255,255,255,0.2)",
          left,
          top: this._ratio(top),
          fontSize: this._ratio(fontSize),
          fontFamily: options.fontFamily
        });
      }
      left += (prevElementBoundingBox.width ?? 0) + this._ratio(7);
      prevElementBoundingBox = this._drawText((_d2 = options.data) == null ? void 0 : _d2.position.symbol, {
        color: layout.color,
        left,
        top: this._ratio(top),
        fontSize: this._ratio(fontSize),
        fontFamily: options.fontFamily
      });
    }
    if (typeof ((_e4 = options.data) == null ? void 0 : _e4.position.leverage) !== "undefined") {
      left += (prevElementBoundingBox.width ?? 0) + this._ratio(7);
      if (prevElementBoundingBox.width) {
        prevElementBoundingBox = this._drawText("|", {
          color: "rgba(255,255,255,0.2)",
          left,
          top: this._ratio(top),
          fontSize: this._ratio(fontSize),
          fontFamily: options.fontFamily
        });
      }
      left += (prevElementBoundingBox.width ?? 0) + this._ratio(7);
      prevElementBoundingBox = this._drawText(
        `${(_f2 = options.data) == null ? void 0 : _f2.position.leverage}X`,
        {
          color: layout.color,
          left,
          top: this._ratio(top),
          fontSize: this._ratio(fontSize),
          fontFamily: options.fontFamily
        }
      );
    }
  }
  drawUnrealizedPnL(options, offsetTop = 0) {
    var _a2, _b2, _c2, _d2, _e4, _f2, _g3;
    const layout = path(
      ["layout", "unrealizedPnl"],
      options
    );
    const { position } = layout;
    let left = this._ratio(position.left);
    let prevElementBoundingBox = {};
    const top = (position.top ?? 0) + offsetTop + this.transformTop;
    if (typeof ((_a2 = options.data) == null ? void 0 : _a2.position.ROI) !== "undefined") {
      const prefix = ((_b2 = options.data) == null ? void 0 : _b2.position.ROI) > 0 ? "+" : "";
      prevElementBoundingBox = this._drawText(
        `${prefix}${d$3((_c2 = options.data) == null ? void 0 : _c2.position.ROI)}%`,
        {
          color: prefix === "+" ? options.profitColor || this.DEFAULT_PROFIT_COLOR : options.lossColor || this.DEFAULT_LOSS_COLOR,
          left,
          top: this._ratio(top),
          fontSize: this._ratio(layout.fontSize),
          fontWeight: 700,
          fontFamily: options.fontFamily
        }
      );
    }
    if (typeof ((_d2 = options.data) == null ? void 0 : _d2.position.pnl) !== "undefined") {
      const prefix = ((_e4 = options.data) == null ? void 0 : _e4.position.pnl) >= 0 ? "+" : "";
      let text = `${prefix}${d$3((_f2 = options.data) == null ? void 0 : _f2.position.pnl)} ${(_g3 = options.data) == null ? void 0 : _g3.position.currency}`;
      let fontWeight = 600;
      if (prevElementBoundingBox.width) {
        left += (prevElementBoundingBox.width ?? 0) + this._ratio(8);
        text = `(${text})`;
      } else {
        left = this._ratio(position.left);
        fontWeight = 700;
      }
      const color = typeof options.data.position.ROI === "undefined" ? prefix === "+" ? options.profitColor || this.DEFAULT_PROFIT_COLOR : options.lossColor || this.DEFAULT_LOSS_COLOR : layout.secondaryColor;
      const fontSize = typeof options.data.position.ROI === "undefined" ? this._ratio(layout.fontSize) : this._ratio(layout.secondaryFontSize);
      prevElementBoundingBox = this._drawText(text, {
        color,
        left,
        top: this._ratio(top),
        fontSize,
        fontWeight,
        fontFamily: options.fontFamily
      });
    }
  }
  drawInformations(options) {
    var _a2, _b2, _c2;
    const layout = path(
      ["layout", "informations"],
      options
    );
    const { position } = layout;
    const informations = ((_b2 = (_a2 = options.data) == null ? void 0 : _a2.position) == null ? void 0 : _b2.informations) || [];
    (((_c2 = options.data) == null ? void 0 : _c2.position.informations.length) ?? 0) === 2;
    const col = informations.length > 4 ? 3 : 2;
    informations.forEach((info, index) => {
      let left = position.left + index % col * this.positionInfoCellWidth;
      let top = position.top + Math.floor(index / col) * 38 + this.transformTop;
      this._drawText(info.title, {
        left: this._ratio(left),
        top: this._ratio(top),
        fontSize: this._ratio(10),
        color: layout.labelColor,
        fontFamily: options.fontFamily
      });
      this._drawText(info.value, {
        left: this._ratio(left),
        top: this._ratio(top + 17),
        fontSize: this._ratio(layout.fontSize),
        fontWeight: 500,
        color: layout.color,
        fontFamily: options.fontFamily
      });
    });
  }
  drawDomainUrl(options, onlyMeasure = false) {
    var _a2;
    const layout = path(
      ["layout", "domain"],
      options
    );
    const hasReferral = this.hasReferral(options);
    const { position } = layout;
    const top = this.painter.height - position.bottom;
    return this._drawText(
      (_a2 = options.data) == null ? void 0 : _a2.domain,
      {
        left: !hasReferral ? this._ratio(position.left) : this._ratio(this.painter.width - 20),
        top: !hasReferral ? this._ratio(top) : this._ratio(this.painter.height - 16),
        fontSize: this._ratio(layout.fontSize),
        color: options.brandColor ?? this.DEFAULT_PROFIT_COLOR,
        fontFamily: options.fontFamily,
        textBaseline: layout.textBaseline,
        textAlign: !hasReferral ? layout.textAlign : "end",
        fontWeight: 600
      },
      onlyMeasure
    );
  }
  drawPositionTime(options) {
    var _a2, _b2;
    const layout = path(
      ["layout", "updateTime"],
      options
    );
    const { position } = layout;
    const hasReferral = this.hasReferral(options);
    let top = this.painter.height - position.bottom;
    let left = this._ratio(position.left);
    if (hasReferral) {
      const metrics = this.drawDomainUrl(options, true);
      left = this._ratio(this.painter.width) - metrics.width - this._ratio(8 + position.left);
      top = this.painter.height - position.bottom;
    }
    this._drawText(
      !hasReferral ? (_a2 = options.data) == null ? void 0 : _a2.updateTime : `Share on ${(_b2 = options.data) == null ? void 0 : _b2.updateTime}   |`,
      {
        left,
        top: this._ratio(top),
        // top: 536,
        fontSize: this._ratio(layout.fontSize),
        color: layout.color,
        // color: "red",
        textAlign: !hasReferral ? layout.textAlign : "end",
        fontFamily: options.fontFamily,
        textBaseline: layout.textBaseline
      }
    );
  }
  drawReferralCode(options) {
    var _a2;
    if (!((_a2 = options.data) == null ? void 0 : _a2.referral)) {
      return;
    }
    const layout = path(
      ["layout", "updateTime"],
      options
    );
    const { position } = layout;
    const top = this.painter.height - (position.bottom ?? 0);
    const messageLayout = path(
      ["layout", "message"],
      options
    );
    const url = new URL(options.data.referral.link);
    const searchParams = url.searchParams;
    searchParams.append("ref", options.data.referral.code);
    url.search = searchParams.toString();
    qrPaint(this.ctx, {
      size: this._ratio(this.QRCODE_SIZE),
      padding: this._ratio(2),
      left: this._ratio(position.left),
      top: this._ratio(top - this.QRCODE_SIZE),
      data: `${url.toString()}`
    });
    this._drawText(options.data.referral.slogan, {
      left: this._ratio(position.left + 66),
      top: this._ratio(top - this.QRCODE_SIZE),
      fontSize: this._ratio(14),
      color: options.brandColor ?? this.DEFAULT_PROFIT_COLOR,
      fontFamily: options.fontFamily,
      textBaseline: "top"
    });
    this._drawText("Referral Code", {
      left: this._ratio(position.left + 66),
      top: this._ratio(top - 29),
      fontSize: this._ratio(12),
      color: layout.color,
      fontFamily: options.fontFamily,
      textBaseline: "middle"
    });
    this._drawText(options.data.referral.code, {
      left: this._ratio(position.left + 66),
      top: this._ratio(top),
      fontSize: this._ratio(16),
      color: messageLayout.color,
      fontFamily: options.fontFamily,
      textBaseline: "bottom"
    });
  }
  _drawText(str, options, onlyMeasure = false) {
    let boundingBox;
    const {
      left = 30,
      top = 30,
      fontSize = 13,
      fontWeight = 500,
      color = "black",
      textBaseline = "middle",
      textAlign = "start"
    } = options ?? {};
    this.ctx.save();
    this.ctx.font = `${fontWeight} ${fontSize}px ${options == null ? void 0 : options.fontFamily}`;
    this.ctx.fillStyle = color;
    this.ctx.textBaseline = textBaseline;
    this.ctx.textAlign = textAlign;
    boundingBox = this.ctx.measureText(str);
    if (!onlyMeasure) {
      this.ctx.fillText(str, left, top);
    }
    this.ctx.restore();
    return boundingBox;
  }
  hasReferral(options) {
    var _a2;
    return typeof ((_a2 = options.data) == null ? void 0 : _a2.referral) !== "undefined";
  }
  _ratio(num) {
    return num * this.painter.ratio;
  }
};
var PosterPainter = class {
  // resourceManager: Resource;
  constructor(canvas, options) {
    this.canvas = canvas;
    this.width = 0;
    this.height = 0;
    this.ctx = this.canvas.getContext("2d");
    this.width = this.canvas.width;
    this.height = this.canvas.height;
    this.ratio = Math.max(
      (options == null ? void 0 : options.ratio) || 1,
      typeof window !== "undefined" ? Math.ceil(window.devicePixelRatio) : 1
    );
    this.canvas.width = this.width * this.ratio;
    this.canvas.height = this.height * this.ratio;
    this.canvas.style.width = this.width + "px";
    this.canvas.style.height = this.height + "px";
  }
  draw(options) {
    requestAnimationFrame(() => this._draw.bind(this)(options));
  }
  async _draw(options) {
    if (this.ctx === null)
      return;
    await new BackgroundPaint(this.ctx, this).draw(options);
    await new DataPaint(this.ctx, this).draw(options);
  }
};
var DefaultLayoutConfig = {
  domain: {
    fontSize: 13,
    // color: undefined,
    textBaseline: "bottom",
    position: {
      left: 20,
      bottom: 32
    }
  },
  message: {
    fontSize: 20,
    color: "rgba(255, 255, 255, 0.98)",
    textBaseline: "top",
    position: {
      left: 20,
      top: 16
    }
  },
  position: {
    fontSize: 14,
    color: "rgba(255,255,255,0.98)",
    position: {
      left: 20,
      top: 70
    }
  },
  unrealizedPnl: {
    fontSize: 36,
    color: "rgba(255,255,255,0.5)",
    secondaryColor: "rgba(255,255,255,0.54)",
    secondaryFontSize: 20,
    position: {
      left: 20,
      top: 110
    }
  },
  informations: {
    fontSize: 12,
    color: "rgba(255, 255, 255, 0.8)",
    labelColor: "rgba(255,255,255,0.36)",
    position: {
      left: 20,
      top: 150
    }
  },
  updateTime: {
    fontSize: 10,
    color: "rgba(255,255,255,0.3)",
    textAlign: "start",
    textBaseline: "bottom",
    position: {
      left: 20,
      bottom: 17
    }
  }
};
var usePoster = (data, options) => {
  const [error, setError] = useState(null);
  const [canCopy, setCanCopy] = useState(
    () => typeof navigator.clipboard !== "undefined"
  );
  const painterRef = useRef(null);
  const [target, setTarget] = useState(null);
  useEffect(() => {
    if (target) {
      if (!painterRef.current) {
        painterRef.current = new PosterPainter(target, {
          ratio: (options == null ? void 0 : options.ratio) || 1,
          ...options
        });
      }
      painterRef.current.draw(
        mergeDeepRight(
          { layout: DefaultLayoutConfig, fontFamily: "Manrope" },
          data
        )
      );
    }
  }, [target, data]);
  const toDataURL = (type, encoderOptions) => {
    if (!target) {
      throw new SDKError("The ref must be a canvas element");
    }
    return target.toDataURL(type, encoderOptions);
  };
  const toBlob = useCallback(
    (type, encoderOptions) => {
      return new Promise((resolve) => {
        if (!target) {
          resolve(null);
          return;
        }
        target.toBlob(resolve, type, encoderOptions);
      });
    },
    [target]
  );
  const ref = (ref2) => {
    if (!ref2)
      return;
    if (ref2.tagName.toUpperCase() !== "CANVAS") {
      setError(new SDKError("The ref must be a canvas element"));
      return;
    }
    setTarget(ref2);
  };
  const download = useCallback(
    (filename, type = "image/png", encoderOptions) => {
      if (!target) {
        throw new SDKError("The ref must be a canvas element");
      }
      const img = new Image();
      img.src = target.toDataURL(type, encoderOptions);
      const link = document.createElement("a");
      link.href = img.src;
      link.download = filename;
      link.click();
    },
    [target]
  );
  const copy2 = useCallback(() => {
    if (!target) {
      throw new SDKError("The ref must be a canvas element");
    }
    return new Promise((resolve, reject) => {
      if (!navigator.clipboard) {
        reject(new SDKError("Clipboard API is not supported"));
        return;
      }
      target.toBlob((blob) => {
        if (!blob) {
          reject(new SDKError("Failed to create blob"));
          return;
        }
        return navigator.clipboard.write([new ClipboardItem({ [blob.type]: blob })]).then(resolve, reject);
      });
    });
  }, [target]);
  return {
    error,
    /**
     * The ref to the canvas element, you should pass this ref to the canvas element
     */
    ref,
    /**
     * Converts the poster to a data URL
     */
    toDataURL,
    /**
     * Converts the poster to a blob
     */
    toBlob,
    /**
     * Downloads the poster as an image
     */
    download,
    /**
     * Browser if supports copy image to clipboard
     */
    canCopy,
    copy: copy2
  };
};
var utils_exports = {};
__export(utils_exports, {
  calcTPSL_ROI: () => calcTPSL_ROI,
  cleanStringStyle: () => cleanStringStyle,
  findPositionTPSLFromOrders: () => findPositionTPSLFromOrders,
  findTPSLFromOrder: () => findTPSLFromOrder,
  findTPSLFromOrders: () => findTPSLFromOrders,
  formatNumber: () => formatNumber,
  getPositionBySymbol: () => getPositionBySymbol,
  priceToPnl: () => priceToPnl
});
var useGetReferralCode = (accountId) => {
  const { data, error, isLoading } = useQuery(
    typeof accountId === "undefined" ? null : `/v1/public/referral/check_ref_code?account_id=${accountId}`
  );
  if (typeof accountId === "undefined") {
    return {
      referral_code: void 0,
      error: "The account id is empty or undefined",
      isLoading: false
    };
  }
  return {
    referral_code: data == null ? void 0 : data.referral_code,
    error,
    isLoading
  };
};
var useReferralInfo = () => {
  const {
    data,
    mutate: mutate3,
    isLoading,
    error
  } = usePrivateQuery("/v1/referral/info", {
    revalidateOnFocus: true
  });
  const isTrader = useMemo(() => {
    var _a2, _b2, _c2;
    if (typeof ((_a2 = data == null ? void 0 : data.referee_info) == null ? void 0 : _a2.referer_code) === "undefined")
      return void 0;
    return (((_c2 = (_b2 = data == null ? void 0 : data.referee_info) == null ? void 0 : _b2.referer_code) == null ? void 0 : _c2.length) || 0) > 0;
  }, [data == null ? void 0 : data.referee_info]);
  const isAffiliate = useMemo(() => {
    var _a2, _b2, _c2;
    if (typeof ((_a2 = data == null ? void 0 : data.referrer_info) == null ? void 0 : _a2.referral_codes) === "undefined")
      return void 0;
    return (((_c2 = (_b2 = data == null ? void 0 : data.referrer_info) == null ? void 0 : _b2.referral_codes) == null ? void 0 : _c2.length) || 0) > 0;
  }, [data == null ? void 0 : data.referrer_info]);
  const [pinCodes] = useLocalStorage("orderly_referral_codes", []);
  const getFirstRefCode = useCallback(() => {
    if (!(data == null ? void 0 : data.referrer_info.referral_codes))
      return void 0;
    const referralCodes = [...data == null ? void 0 : data.referrer_info.referral_codes];
    const pinedItems = [];
    for (let i = 0; i < pinCodes.length; i++) {
      const code = pinCodes[i];
      const index = referralCodes.findIndex((item) => item.code === code);
      if (index !== -1) {
        pinedItems.push({ ...referralCodes[index] });
        referralCodes.splice(index, 1);
      }
    }
    const newCodes = [...pinedItems, ...referralCodes];
    return newCodes == null ? void 0 : newCodes[0];
  }, [pinCodes, data]);
  return {
    data,
    isTrader,
    isAffiliate,
    error,
    isLoading,
    getFirstRefCode
  };
};
var TWType = /* @__PURE__ */ ((TWType2) => {
  TWType2["normal"] = "normal";
  TWType2["mm"] = "mm";
  return TWType2;
})(TWType || {});
var useEpochInfo = (type) => {
  const [curEpochInfo, setCurEpochInfo] = useState(
    void 0
  );
  const path2 = type === "normal" ? "/v1/public/trading_rewards/epoch_info" : "/v1/public/market_making_rewards/epoch_info";
  const {
    data: epochInfo,
    error,
    isLoading,
    mutate: refresh
  } = useQuery(path2, {
    formatter: (res) => {
      if (typeof res === "object" && "rows" in res && "current_epoch" in res) {
        const { rows, current_epoch } = res;
        if (Array.isArray(rows)) {
          const list = rows.map(
            (e3) => e3
          );
          list.sort((a2, b2) => b2.end_time - a2.end_time);
          const curEpochIndex = list == null ? void 0 : list.findIndex(
            (item) => item.epoch_id === current_epoch
          );
          const epochOne = list.find((item) => item.epoch_id === 1);
          if (epochOne && (epochOne == null ? void 0 : epochOne.start_time) > N$3()) {
            setCurEpochInfo(epochOne);
          } else {
            setCurEpochInfo(
              curEpochIndex !== -1 ? list == null ? void 0 : list[curEpochIndex] : void 0
            );
          }
          return list;
        }
      }
      return [];
    }
  });
  const isNotStared = useMemo(() => {
    const epochOne = epochInfo == null ? void 0 : epochInfo.find((item) => item.epoch_id === 1);
    if (epochOne) {
      return epochOne.start_time > N$3();
    }
    return true;
  }, [epochInfo]);
  return [epochInfo, { isLoading, curEpochInfo, isNotStared, refresh }];
};
var useAllBrokers = () => {
  const { data } = useQuery("/v1/public/broker/name", {
    formatter: (res) => {
      const { rows } = res;
      return rows == null ? void 0 : rows.map((item) => ({ [item.broker_id]: item.broker_name })).reduce((acc, curr) => ({ ...acc, ...curr }), {});
    }
  });
  return [data];
};
var useCurEpochEstimate = (type) => {
  const [data, setData] = useState(void 0);
  const { account: account5 } = useAccount();
  const brokers = useAllBrokers();
  const address = account5.address;
  const path2 = type === "normal" ? `/v1/public/trading_rewards/current_epoch_estimate?address=${address}` : `/v1/public/market_making_rewards/current_epoch_estimate?address=${address}`;
  const { data: estimateData } = useQuery(address !== void 0 ? path2 : "", {
    formatter: (res) => {
      var _a2;
      const data2 = {
        ...res,
        rows: ((_a2 = res.rows) == null ? void 0 : _a2.map((item) => ({
          ...item,
          broker_name: item.broker_id
        }))) || [],
        est_trading_volume: (res == null ? void 0 : res.est_maker_volume) || (res == null ? void 0 : res.est_trading_volume)
      };
      return data2;
    }
  });
  const reuslt = useMemo(() => {
    var _a2;
    if (estimateData) {
      const newData = { ...estimateData };
      newData.rows = (_a2 = newData.rows) == null ? void 0 : _a2.map((item) => ({
        ...item,
        broker_name: brokers[item.broker_id] || item.broker_id
      }));
      return newData;
    }
    return data;
  }, [estimateData, brokers]);
  return [reuslt];
};
var useApiKeyManager = (queryParams) => {
  const { account: account5 } = useAccount();
  const { keyInfo } = queryParams || {};
  const keyInfoPrams = getQueryParamsFromObject(keyInfo);
  const { data, mutate: mutate3, error, isLoading } = usePrivateQuery(
    `/v1/client/key_info${keyInfoPrams.length > 0 ? `?${keyInfoPrams}` : ""}`,
    {
      formatter: (data2) => data2 == null ? void 0 : data2.rows
    }
  );
  const [doIPRestriction] = useMutation(
    "/v1/client/set_orderly_key_ip_restriction",
    "POST"
  );
  const [doRemoveOrderKey] = useMutation(
    "/v1/client/remove_orderly_key",
    "POST"
  );
  const [doResetIPRestriction] = useMutation(
    "/v1/client/reset_orderly_key_ip_restriction",
    "POST"
  );
  const setIPRestriction = useCallback(
    (orderly_key, ip_restriction_list) => {
      return doIPRestriction({
        orderly_key,
        ip_restriction_list
      });
    },
    []
  );
  const removeOrderlyKey = useCallback((orderly_key) => {
    return doRemoveOrderKey({
      orderly_key
    });
  }, []);
  const generateOrderlyKey = (scope) => {
    return account5 == null ? void 0 : account5.createApiKey(365, {
      tag: "manualCreated",
      scope
    });
  };
  const resetOrderlyKeyIPRestriction = (orderlyKey, mode2) => {
    return doResetIPRestriction({
      orderly_key: orderlyKey,
      reset_mode: mode2
    });
  };
  return [
    data,
    {
      refresh: mutate3,
      error,
      isLoading,
      generateOrderlyKey,
      setIPRestriction,
      removeOrderlyKey,
      resetOrderlyKeyIPRestriction
    }
  ];
};
function getQueryParamsFromObject(obj) {
  if (typeof obj === "undefined")
    return "";
  const queryParams = new URLSearchParams();
  for (const [key, value] of Object.entries(obj)) {
    if (value !== void 0) {
      if (Array.isArray(value)) {
        value.forEach((item) => {
          queryParams.append(key, item.toString());
        });
      } else {
        queryParams.set(key, value.toString());
      }
    }
  }
  return queryParams.toString();
}
var getCreateOrderUrl = (order) => {
  const isAlgoOrder = (order == null ? void 0 : order.order_type) === OrderType.STOP_LIMIT || (order == null ? void 0 : order.order_type) === OrderType.STOP_MARKET || (order == null ? void 0 : order.order_type) === OrderType.CLOSE_POSITION || order.algo_type && order.algo_type === AlgoOrderRootType.BRACKET || isBracketOrder(order);
  return isAlgoOrder ? "/v1/algo/order" : "/v1/order";
};
var getOrderCreator = (order) => {
  let type;
  if (isBracketOrder(order)) {
    type = `${AlgoOrderRootType.BRACKET}:${order.order_type}`;
  } else if (order.order_type === OrderType.LIMIT) {
    type = order.order_type_ext || order.order_type;
  } else {
    type = order.order_type;
  }
  return OrderFactory.create(type);
};
var tpslFields = [
  "tp_trigger_price",
  "sl_trigger_price",
  "tp_pnl",
  "sl_pnl",
  "tp_offset",
  "sl_offset",
  "tp_offset_percentage",
  "sl_offset_percentage"
];
var isBracketOrder = (order) => {
  return !!order.tp_trigger_price || !!order.sl_trigger_price;
};
var hasTPSL = (order) => {
  return tpslFields.some((field) => !!order[field]);
};
var getPriceAndQty = (symbolOrOrder, askAndBid) => {
  let quantity = Number(symbolOrOrder.order_quantity);
  const orderPrice = Number(symbolOrOrder.order_price);
  if (isNaN(quantity) || quantity <= 0) {
    return null;
  }
  if (askAndBid.length === 0) {
    return null;
  }
  if ((symbolOrOrder.order_type === OrderType.LIMIT || symbolOrOrder.order_type === OrderType.STOP_LIMIT) && isNaN(orderPrice))
    return null;
  let price;
  if (symbolOrOrder.order_type === OrderType.MARKET || symbolOrOrder.order_type === OrderType.STOP_MARKET) {
    if (symbolOrOrder.side === OrderSide.BUY) {
      price = askAndBid[0];
    } else {
      price = askAndBid[1];
    }
  } else {
    if (symbolOrOrder.side === OrderSide.BUY) {
      if (orderPrice >= askAndBid[0]) {
        price = askAndBid[0];
      } else {
        price = orderPrice;
      }
    } else {
      if (orderPrice <= askAndBid[1]) {
        price = askAndBid[1];
      } else {
        price = orderPrice;
      }
    }
  }
  if (symbolOrOrder.side === OrderSide.SELL) {
    quantity = -quantity;
  }
  return { price, quantity };
};
var calcEstLiqPrice = (order$1, askAndBid, inputs) => {
  const result = getPriceAndQty(order$1, askAndBid);
  if (!result)
    return null;
  const { price, quantity } = result;
  if (!price || !quantity)
    return null;
  const {
    symbol,
    baseIMR,
    baseMMR,
    imr_factor,
    markPrice,
    totalCollateral: totalCollateral2,
    futures_taker_fee_rate,
    positions: positions2
  } = inputs;
  const orderFee2 = order_exports.orderFee({
    qty: quantity,
    price,
    futuresTakeFeeRate: Number(futures_taker_fee_rate) / 1e4
  });
  const liqPrice2 = order_exports.estLiqPrice({
    markPrice,
    baseIMR,
    baseMMR,
    totalCollateral: totalCollateral2,
    positions: positions2 == null ? [] : positions2,
    IMR_Factor: imr_factor,
    orderFee: orderFee2,
    newOrder: {
      qty: quantity,
      price,
      symbol
    }
  });
  if (liqPrice2 <= 0)
    return null;
  return liqPrice2;
};
var calcEstLeverage = (order$1, askAndBid, inputs) => {
  const result = getPriceAndQty(order$1, askAndBid);
  const { totalCollateral: totalCollateral2, positions: positions2, symbol } = inputs;
  if (!result)
    return null;
  const { price, quantity } = result;
  if (!price || !quantity)
    return null;
  return order_exports.estLeverage({
    totalCollateral: totalCollateral2,
    positions: positions2,
    newOrder: {
      symbol,
      qty: result.quantity,
      price: result.price
    }
  });
};
var initialOrderState = {
  order_price: "",
  order_quantity: "",
  trigger_price: "",
  tp_trigger_price: "",
  sl_trigger_price: "",
  tp_pnl: "",
  sl_pnl: "",
  tp_offset_percentage: "",
  sl_offset_percentage: "",
  tp_offset: "",
  sl_offset: "",
  total: ""
  // symbol: "",
};
var useOrderStore = (initialOrder) => {
  const [entry2, setEntry] = useState(initialOrder);
  const [estLeverage2, setEstLeverage] = useState(null);
  const [estLiquidationPrice, setEstLiquidationPrice] = useState(
    null
  );
  const [errors, setErrors] = useState({});
  const updateOrder = (order) => {
    setEntry(
      produce((draft) => {
        return { ...draft, ...order };
      })
      // (prev) => ({ ...prev, ...order })
    );
  };
  const updateOrderByKey = (key, value) => {
    setEntry(
      produce((draft) => {
        draft[key] = value;
      })
    );
  };
  const restoreOrder = (order) => {
    setEntry(produce((draft) => order));
  };
  const updateOrderComputed = (data) => {
    setEstLeverage(data.estLeverage);
    setEstLiquidationPrice(data.estLiquidationPrice);
  };
  const resetOrder = (order) => {
    setEntry(
      produce((draft) => ({
        ...draft,
        ...order ?? initialOrderState
      }))
    );
  };
  const hasTP_SL = () => {
    return typeof entry2.tp_trigger_price !== "undefined" || typeof entry2.sl_trigger_price !== "undefined";
  };
  return {
    entry: entry2,
    estLeverage: estLeverage2,
    estLiquidationPrice,
    errors,
    actions: {
      updateOrder,
      updateOrderByKey,
      restoreOrder,
      updateOrderComputed,
      resetOrder,
      hasTP_SL
    }
  };
};
var useOrderEntryNextInternal = (symbol, options = {}) => {
  const { symbolInfo } = options;
  const initialOrder = {
    side: OrderSide.BUY,
    order_type: OrderType.LIMIT,
    order_price: "",
    symbol,
    ...options.initialOrder
  };
  const { actions: orderEntryActions, entry: orderEntity } = useOrderStore(initialOrder);
  const calculate = useCallback(
    (values2, fieldName, value, markPrice, config2) => {
      const fieldHandler = getCalculateHandler(fieldName);
      let newValues = compose(
        head,
        // orderEntityFormatHandle(baseDP, quoteDP),
        fieldHandler,
        baseInputHandle
      )([values2, fieldName, value, markPrice, config2]);
      return newValues;
    },
    []
  );
  useEffect(() => {
    orderEntryActions.updateOrderByKey("symbol", symbol);
  }, [orderEntryActions, symbol]);
  const setValue = (key, value, additional) => {
    if (!symbolInfo) {
      orderEntryActions.updateOrderByKey(key, value);
      return;
    }
    const { markPrice } = additional ?? { markPrice: 0 };
    let newValues = calculate(
      { ...orderEntity },
      key,
      value,
      markPrice,
      symbolInfo
    );
    if (key === "order_type") {
      if (value === OrderType.MARKET || value === OrderType.STOP_MARKET) {
        newValues = calculate(
          newValues,
          "order_price",
          markPrice,
          markPrice,
          symbolInfo
        );
      }
    }
    if ((key === "order_quantity" || key === "order_price") && hasTPSL(newValues)) {
      newValues = calculateTPSL(key, newValues, markPrice, symbolInfo);
    }
    {
      if (newValues.tp_pnl && newValues.order_quantity) {
        newValues.tp_ROI = calcTPSL_ROI({
          qty: newValues.order_quantity,
          price: newValues.order_price || markPrice,
          pnl: newValues.tp_pnl
        });
      }
      if (newValues.sl_pnl && newValues.order_quantity) {
        newValues.sl_ROI = calcTPSL_ROI({
          qty: newValues.order_quantity,
          price: newValues.order_price || markPrice,
          pnl: newValues.sl_pnl
        });
      }
    }
    orderEntryActions.updateOrder(newValues);
    return newValues;
  };
  const calculateTPSL = (key, newValues, markPrice, symbolInfo2) => {
    if (key === "order_price") {
      if (typeof newValues.tp_pnl !== "undefined") {
        newValues = calculate(
          newValues,
          "tp_pnl",
          newValues.tp_pnl,
          markPrice,
          symbolInfo2
        );
      }
      if (typeof newValues.sl_pnl !== "undefined") {
        newValues = calculate(
          newValues,
          "sl_pnl",
          newValues.sl_pnl,
          markPrice,
          symbolInfo2
        );
      }
    } else {
      if (typeof newValues.tp_trigger_price !== "undefined") {
        newValues = calculate(
          newValues,
          "tp_trigger_price",
          newValues.tp_trigger_price,
          markPrice,
          symbolInfo2
        );
      }
      if (typeof newValues.sl_trigger_price !== "undefined") {
        newValues = calculate(
          newValues,
          "sl_trigger_price",
          newValues.sl_trigger_price,
          markPrice,
          symbolInfo2
        );
      }
    }
    return newValues;
  };
  const setValues = (values2, additional) => {
    if (!symbolInfo) {
      orderEntryActions.updateOrder(values2);
      return;
    }
    let newValues = { ...orderEntity };
    Object.keys(values2).forEach((key) => {
      newValues = calculate(
        newValues,
        key,
        values2[key],
        (additional == null ? void 0 : additional.markPrice) ?? 0,
        symbolInfo
      );
    });
    orderEntryActions.updateOrder(newValues);
    return newValues;
  };
  const onMarkPriceUpdated = useCallback(
    (markPrice, baseOn) => {
      if (!options.symbolInfo)
        return;
      let newValues;
      if (typeof baseOn === "undefined") {
        newValues = calculate(
          { ...orderEntity },
          "order_price",
          markPrice,
          markPrice,
          options.symbolInfo
        );
      } else {
        newValues = calculate(
          { ...orderEntity },
          baseOn,
          orderEntity[baseOn],
          markPrice,
          options.symbolInfo
        );
      }
      if (hasTPSL(newValues)) {
        if (newValues.tp_pnl && newValues.order_quantity) {
          newValues.tp_ROI = calcTPSL_ROI({
            qty: newValues.order_quantity,
            price: newValues.order_price || markPrice,
            pnl: newValues.tp_pnl
          });
        }
        if (newValues.sl_pnl && newValues.order_quantity) {
          newValues.sl_ROI = calcTPSL_ROI({
            qty: newValues.order_quantity,
            price: newValues.order_price || markPrice,
            pnl: newValues.sl_pnl
          });
        }
      }
      orderEntryActions.updateOrder(newValues);
    },
    [calculate, options.symbolInfo, orderEntity, orderEntryActions]
  );
  const validate = (order, creator, options2) => {
    const { markPrice, maxQty: maxQty2 } = options2;
    return creator == null ? void 0 : creator.validate(order, {
      symbol: symbolInfo,
      maxQty: maxQty2,
      markPrice
    });
  };
  const generateOrder = (creator, options2) => {
    const order = creator.create(orderEntity, {
      ...options2,
      symbol: symbolInfo
    });
    return order;
  };
  const submitOrder = useCallback(() => {
  }, [orderEntity]);
  const resetOrder = (order) => {
    orderEntryActions.resetOrder(order);
  };
  return {
    formattedOrder: orderEntity,
    setValue,
    setValues,
    submit: submitOrder,
    reset: resetOrder,
    generateOrder,
    validate,
    onMarkPriceChange: onMarkPriceUpdated
  };
};
var useOrderEntry2 = (symbol, options = {}) => {
  if (!symbol) {
    throw new SDKError("Symbol is required");
  }
  const ee2 = useEventEmitter();
  const { track: track2 } = useTrack();
  const [meta2, setMeta] = useState({
    dirty: {},
    submitted: false,
    validated: false,
    errors: null
  });
  const askAndBid = useRef([[]]);
  const lastChangedField = useRef();
  const lastOrderTypeExt = useRef();
  const lastLevel = useRef();
  const actions = useMarkPriceActions();
  const symbolConfig = useSymbolsInfo();
  const accountInfo = useAccountInfo();
  const positions2 = usePositions();
  const symbolInfo = symbolConfig[symbol]();
  const markPrice = actions.getMarkPriceBySymbol(symbol);
  const {
    formattedOrder,
    setValue: setValueInternal,
    setValues: setValuesInternal,
    validate,
    generateOrder,
    reset,
    // submit,
    ...orderEntryActions
  } = useOrderEntryNextInternal(symbol, {
    ...options,
    symbolInfo
  });
  const [doCreateOrder, { isMutating }] = useMutation(
    getCreateOrderUrl(formattedOrder)
  );
  const maxQty2 = useMaxQty(
    symbol,
    formattedOrder.side,
    formattedOrder.reduce_only
  );
  const updateOrderPrice = () => {
    var _a2, _b2;
    const order_type_ext = formattedOrder.order_type_ext ?? lastOrderTypeExt.current;
    const level = formattedOrder.level ?? lastLevel.current;
    if (![OrderType.ASK, OrderType.BID].includes(order_type_ext) || level === void 0) {
      return;
    }
    lastOrderTypeExt.current = order_type_ext;
    lastLevel.current = level;
    const index = order_type_ext === OrderType.ASK ? 0 : 1;
    const price = (_b2 = (_a2 = askAndBid.current) == null ? void 0 : _a2[level]) == null ? void 0 : _b2[index];
    if (price && !isNaN(price)) {
      setValue("order_price", price, {
        shouldUpdateLastChangedField: false
      });
    }
  };
  const updateOrderPriceByOrderBook = () => {
    const { order_type, order_type_ext, order_quantity } = formattedOrder;
    const isBBO = order_type === OrderType.LIMIT && [OrderType.ASK, OrderType.BID].includes(order_type_ext);
    if (lastChangedField.current !== "total" && isBBO) {
      updateOrderPrice();
    }
  };
  useEffect(() => {
    updateOrderPrice();
  }, [formattedOrder.order_type_ext, formattedOrder.level]);
  const onOrderBookUpdate = useDebouncedCallback((data) => {
    askAndBid.current = data;
    updateOrderPriceByOrderBook();
  }, 200);
  useEffect(() => {
    ee2.on("orderbook:update", onOrderBookUpdate);
    return () => {
      ee2.off("orderbook:update", onOrderBookUpdate);
    };
  }, []);
  useEffect(() => {
    if ((formattedOrder.order_type === OrderType.MARKET || formattedOrder.order_type === OrderType.STOP_MARKET) && markPrice) {
      orderEntryActions.onMarkPriceChange(
        markPrice,
        lastChangedField.current
      );
    }
  }, [markPrice, formattedOrder.order_type]);
  const prepareData = useCallback(() => {
    return {
      markPrice: actions.getMarkPriceBySymbol(symbol),
      maxQty: maxQty2
    };
  }, [maxQty2, symbol]);
  const interactiveValidate = (order) => {
    validateFunc(order).then((errors) => {
      const keys = Object.keys(errors);
      if (keys.length > 0) {
        setMeta(
          produce((draft) => {
            draft.errors = errors;
          })
        );
      } else {
        setMeta(
          produce((draft) => {
            draft.errors = null;
          })
        );
      }
    });
  };
  const canSetTPSLPrice = (key, value, orderType) => {
    if (tpslFields.includes(key) && value !== "" && value !== void 0 && value !== null && orderType !== OrderType.LIMIT && orderType !== OrderType.MARKET) {
      return false;
    }
    return true;
  };
  const setValue = (key, value, options2) => {
    const { shouldUpdateLastChangedField = true, shouldUpdateDirty = true } = options2 || {};
    if (!canSetTPSLPrice(key, value, formattedOrder.order_type)) {
      return;
    }
    if (shouldUpdateDirty) {
      setMeta(
        produce((draft) => {
          draft.dirty[key] = true;
        })
      );
    }
    const values2 = setValueInternal(key, value, prepareData());
    if (values2) {
      interactiveValidate(values2);
    }
    if (shouldUpdateLastChangedField) {
      lastChangedField.current = key;
    }
  };
  const setValues = (values2) => {
    if (!Object.keys(values2).every(
      (key) => canSetTPSLPrice(
        key,
        values2[key],
        formattedOrder.order_type
      )
    )) {
      return;
    }
    const newValues = setValuesInternal(values2, prepareData());
    if (newValues) {
      interactiveValidate(newValues);
    }
  };
  async function validateFunc(order) {
    const creator = getOrderCreator(order);
    return validate(order, creator, prepareData());
  }
  const validateOrder = () => {
    return new Promise(
      async (resolve, reject) => {
        const creator = getOrderCreator(formattedOrder);
        const errors = await validate(formattedOrder, creator, prepareData());
        const keys = Object.keys(errors);
        if (keys.length > 0) {
          setMeta(
            produce((draft) => {
              draft.errors = errors;
            })
          );
          if (!meta2.validated) {
            setMeta(
              produce((draft) => {
                draft.validated = true;
              })
            );
          }
          reject(errors);
        }
        const order = generateOrder(creator, prepareData());
        resolve(order);
      }
    );
  };
  const { freeCollateral: freeCollateral2, totalCollateral: totalCollateral2 } = useCollateral();
  const estLiqPrice2 = useMemo(() => {
    const markPrice2 = actions.getMarkPriceBySymbol(symbol);
    if (!markPrice2 || !accountInfo)
      return null;
    const orderQuantity = Number(formattedOrder.order_quantity);
    if (orderQuantity === 0 || orderQuantity > maxQty2) {
      return null;
    }
    const estLiqPrice22 = calcEstLiqPrice(formattedOrder, askAndBid.current[0], {
      baseIMR: symbolInfo == null ? void 0 : symbolInfo.base_imr,
      baseMMR: symbolInfo == null ? void 0 : symbolInfo.base_mmr,
      markPrice: markPrice2,
      totalCollateral: totalCollateral2,
      futures_taker_fee_rate: accountInfo.futures_taker_fee_rate,
      imr_factor: accountInfo.imr_factor[symbol],
      symbol,
      positions: positions2
    });
    return estLiqPrice22;
  }, [formattedOrder, accountInfo, positions2, totalCollateral2, symbol, maxQty2]);
  const estLeverage2 = useMemo(() => {
    const orderQuantity = Number(formattedOrder.order_quantity);
    if (orderQuantity === 0 || orderQuantity > maxQty2) {
      return null;
    }
    return calcEstLeverage(formattedOrder, askAndBid.current[0], {
      totalCollateral: totalCollateral2,
      positions: positions2,
      symbol
    });
  }, [formattedOrder, accountInfo, positions2, totalCollateral2, symbol, maxQty2]);
  const resetErrors = () => {
    setMeta(
      produce((draft) => {
        draft.errors = null;
      })
    );
  };
  const resetMetaState = () => {
    setMeta(
      produce((draft) => {
        draft.errors = null;
        draft.submitted = false;
        draft.validated = false;
        draft.dirty = {};
      })
    );
  };
  const submitOrder = async (options2) => {
    const creator = getOrderCreator(formattedOrder);
    const errors = await validate(formattedOrder, creator, prepareData());
    const { resetOnSuccess = true } = options2 || {};
    setMeta(
      produce((draft) => {
        draft.submitted = true;
        draft.validated = true;
      })
    );
    if (Object.keys(errors).length > 0) {
      setMeta(
        produce((draft) => {
          draft.errors = errors;
        })
      );
      throw new SDKError("Order validation failed");
    }
    const order = generateOrder(creator, prepareData());
    const result = await doCreateOrder(order);
    if (result.success) {
      track2(EnumTrackerKeys.placeorderSuccess, {
        side: order.side,
        order_type: order.order_type,
        tp_sl: hasTPSL(formattedOrder),
        reduce_only: !!order.reduce_only
      });
    }
    if (result.success && resetOnSuccess) {
      reset();
      resetMetaState();
    }
    return result;
  };
  return {
    ...orderEntryActions,
    submit: submitOrder,
    reset,
    resetErrors,
    resetMetaState,
    formattedOrder,
    maxQty: maxQty2,
    estLiqPrice: estLiqPrice2,
    estLeverage: estLeverage2,
    helper: {
      /**
       * @deprecated use validate instead
       */
      validator: validateOrder,
      validate: validateOrder
    },
    freeCollateral: freeCollateral2,
    setValue,
    setValues,
    symbolInfo: symbolInfo || {},
    metaState: meta2,
    isMutating,
    markPrice
  };
};
var initialOrderState2 = {
  order_price: "",
  order_quantity: "",
  trigger_price: "",
  tp_trigger_price: "",
  sl_trigger_price: "",
  total: "",
  symbol: ""
};
create()(
  immer((set2, get3) => ({
    entry: {
      side: OrderSide.BUY,
      order_type: OrderType.LIMIT,
      ...initialOrderState2
    },
    estLeverage: null,
    estLiquidationPrice: null,
    errors: {},
    actions: {
      hasTP_SL: () => {
        const order = get3().entry;
        return typeof order.tp_trigger_price !== "undefined" || typeof order.sl_trigger_price !== "undefined";
      },
      updateOrderComputed: (data) => {
        set2(
          (state) => {
            state.estLeverage = data.estLeverage;
            state.estLiquidationPrice = data.estLiquidationPrice;
          },
          false
          // "updateOrderComputed"
        );
      },
      updateOrder: (order) => {
        set2(
          (state) => {
            state.entry = {
              ...state.entry,
              ...order
            };
          },
          false
          // "updateOrder"
        );
      },
      updateOrderByKey: (key, value) => {
        set2(
          (state) => {
            state.entry[key] = value;
          },
          false
          // "updateOrderByKey"
        );
      },
      restoreOrder: (order) => {
        set2(
          (state) => {
            state.entry = order;
          },
          false
          // "restoreOrder"
        );
      },
      resetOrder: (order) => {
        set2(
          (state) => {
            state.entry.order_price = "";
            state.entry.order_quantity = "";
            state.entry.trigger_price = "";
            state.entry.total = "";
            state.entry.tp_trigger_price = "";
            state.entry.tp_pnl = "";
            state.entry.tp_offset = "";
            state.entry.tp_offset_percentage = "";
            state.entry.sl_trigger_price = "";
            state.entry.sl_pnl = "";
            state.entry.sl_offset = "";
            state.entry.sl_offset_percentage = "";
          },
          true
          // "resetOrder"
        );
      }
    }
  }))
);
var useOrderEntity = (order, options) => {
  if (!order.symbol) {
    throw new SDKError("Symbol is required");
  }
  const [errors, setErrors] = useState();
  const maxQty2 = useMaxQty(order.symbol, order.side, order.reduce_only);
  const finalMaxQty = (options == null ? void 0 : options.maxQty) ?? maxQty2;
  const actions = useMarkPriceActions();
  const markPrice = actions.getMarkPriceBySymbol(order.symbol);
  const prepareData = useCallback(() => {
    return {
      markPrice: actions.getMarkPriceBySymbol(order.symbol),
      maxQty: finalMaxQty
    };
  }, [finalMaxQty, order.symbol, order]);
  const symbolInfo = useSymbolsInfo();
  const validate = () => {
    return new Promise(
      async (resolve, reject) => {
        const creator = getOrderCreator(order);
        const _symbol = symbolInfo[order.symbol]();
        const errors2 = await (creator == null ? void 0 : creator.validate(order, {
          symbol: _symbol,
          maxQty: finalMaxQty,
          markPrice
        }));
        const keys = Object.keys(errors2);
        if (keys.length > 0) {
          setErrors(errors2);
          reject(errors2);
        } else {
          setErrors({});
        }
        const orderEntity = creator.create(order, {
          ...prepareData(),
          symbol: _symbol
        });
        resolve(orderEntity);
      }
    );
  };
  const autoCheck = useThrottledCallback(
    () => {
      validate().then(
        () => {
        },
        (reject) => {
        }
      );
    },
    50,
    {}
  );
  useEffect(() => {
    autoCheck();
  }, [order.order_price, order.order_quantity, order.trigger_price]);
  return {
    validate,
    errors,
    markPrice,
    symbolInfo
  };
};
var useRestrictedInfo = (options) => {
  const {
    enableDefault = false,
    customRestrictedIps = [],
    customRestrictedRegions = [],
    content
  } = options || {};
  const apiBaseUrl = useConfig("apiBaseUrl");
  const [invalidWebCity, setInvalidWebCity] = useState([]);
  const [invalidWebCountry, setInvalidWebCountry] = useState([]);
  const [invalidRegions, setInvalidRegions] = useState([]);
  const [allInvalidAreas, setAllInvalidAreas] = useState([]);
  const [city, setCity] = useState("");
  const [region, setRegion] = useState("");
  const [ip, setIp] = useState("");
  const [restrictedOpen, setRestrictedOpen] = useState(false);
  useEffect(() => {
    const fetchData = async () => {
      var _a2, _b2, _c2, _d2, _e4, _f2, _g3, _h2, _i3, _j2, _k2, _l2, _m2;
      try {
        const areaRes = await fetch(`${apiBaseUrl}/v1/restricted_areas`);
        const areaResdata = await areaRes.json();
        const ipRes = await fetch(`${apiBaseUrl}/v1/ip_info`);
        const ipData = await ipRes.json();
        if (areaResdata.success && ipData.success) {
          const invalidCountries = (_c2 = (_b2 = (_a2 = areaResdata == null ? void 0 : areaResdata.data) == null ? void 0 : _a2.invalid_web_country) == null ? void 0 : _b2.toLocaleLowerCase()) == null ? void 0 : _c2.replace(/\s+/g, "").split(",");
          const invalidCities = (_f2 = (_e4 = (_d2 = areaResdata == null ? void 0 : areaResdata.data) == null ? void 0 : _d2.invalid_web_city) == null ? void 0 : _e4.toLocaleLowerCase()) == null ? void 0 : _f2.replace(/\s+/g, "").split(",");
          const combinedInvalidRegions = (enableDefault ? invalidCities.concat(invalidCountries) : []).concat(
            customRestrictedRegions == null ? void 0 : customRestrictedRegions.map(
              (item) => {
                var _a3;
                return (_a3 = item == null ? void 0 : item.replace(/\s+/g, "")) == null ? void 0 : _a3.toLocaleLowerCase();
              }
            )
          );
          const allInvalidAreas2 = [
            enableDefault ? (_g3 = areaResdata == null ? void 0 : areaResdata.data) == null ? void 0 : _g3.invalid_web_country : "",
            enableDefault ? (_h2 = areaResdata == null ? void 0 : areaResdata.data) == null ? void 0 : _h2.invalid_web_city : "",
            customRestrictedRegions == null ? void 0 : customRestrictedRegions.join(", ")
          ].filter((item) => !!item);
          setInvalidWebCity(invalidCities);
          setInvalidWebCountry(invalidCountries);
          setInvalidRegions(combinedInvalidRegions);
          setAllInvalidAreas(allInvalidAreas2);
          const { city: city2, region: region2, ip: ip2 } = ipData.data;
          setCity(city2);
          setRegion(region2);
          setIp(ip2);
          if (combinedInvalidRegions.includes(
            (_j2 = (_i3 = ipData == null ? void 0 : ipData.data) == null ? void 0 : _i3.city) == null ? void 0 : _j2.replace(/\s+/g, "").toLocaleLowerCase()
          ) || combinedInvalidRegions.includes(
            (_l2 = (_k2 = ipData == null ? void 0 : ipData.data) == null ? void 0 : _k2.region) == null ? void 0 : _l2.replace(/\s+/g, "").toLocaleLowerCase()
          ) || customRestrictedIps.includes((_m2 = ipData == null ? void 0 : ipData.data) == null ? void 0 : _m2.ip)) {
            setRestrictedOpen(true);
          }
        }
      } catch (error) {
      }
    };
    fetchData();
  }, [apiBaseUrl]);
  return {
    ip,
    invalidRegions: allInvalidAreas,
    restrictedOpen,
    content
  };
};
var Zl = Object.defineProperty;
var lr$4 = (e3, o) => {
  for (var t in o) Zl(e3, t, { get: o[t], enumerable: true });
};
var Qo$3 = { variants: { gap: { 0: "oui-gap-0", 1: "oui-gap-1", 2: "oui-gap-2", 3: "oui-gap-3", 4: "oui-gap-4", 5: "oui-gap-5", 6: "oui-gap-6", 8: "oui-gap-8", 10: "oui-gap-10" }, gapX: { 0: "oui-gap-x-0", 1: "oui-gap-x-1", 2: "oui-gap-x-2", 3: "oui-gap-x-3", 4: "oui-gap-x-4", 5: "oui-gap-x-5", 6: "oui-gap-x-6", 8: "oui-gap-x-8", 10: "oui-gap-x-10" }, gapY: { 0: "oui-gap-y-0", 1: "oui-gap-y-1", 2: "oui-gap-y-2", 3: "oui-gap-y-3", 4: "oui-gap-y-4", 5: "oui-gap-y-5", 6: "oui-gap-y-6", 8: "oui-gap-y-8", 10: "oui-gap-y-10" } } };
var b$2 = createTV({ twMergeConfig: { prefix: "oui-" } });
var Ui$1 = { variants: { p: { 0: "oui-p-0", 1: "oui-p-1", 2: "oui-p-2", 3: "oui-p-3", 4: "oui-p-4", 5: "oui-p-5", 6: "oui-p-6", 7: "oui-p-7", 8: "oui-p-8", 9: "oui-p-9", 10: "oui-p-10" }, px: { 0: "oui-px-0", 1: "oui-px-1", 2: "oui-px-2", 3: "oui-px-3", 4: "oui-px-4", 5: "oui-px-5", 6: "oui-px-6", 7: "oui-px-7", 8: "oui-px-8", 9: "oui-px-9", 10: "oui-px-10" }, py: { 0: "oui-py-0", 1: "oui-py-1", 2: "oui-py-2", 3: "oui-py-3", 4: "oui-py-4", 5: "oui-py-5", 6: "oui-py-6", 7: "oui-py-7", 8: "oui-py-8", 9: "oui-py-9", 10: "oui-py-10" }, pt: { 0: "oui-pt-0", 1: "oui-pt-1", 2: "oui-pt-2", 3: "oui-pt-3", 4: "oui-pt-4", 5: "oui-pt-5", 6: "oui-pt-6", 7: "oui-pt-7", 8: "oui-pt-8", 9: "oui-pt-9", 10: "oui-pt-10" }, pb: { 0: "oui-pb-0", 1: "oui-pb-1", 2: "oui-pb-2", 3: "oui-pb-3", 4: "oui-pb-4", 5: "oui-pb-5", 6: "oui-pb-6", 7: "oui-pb-7", 8: "oui-pb-8", 9: "oui-pb-9", 10: "oui-pb-10" }, pl: { 0: "oui-pl-0", 1: "oui-pl-1", 2: "oui-pl-2", 3: "oui-pl-3", 4: "oui-pl-4", 5: "oui-pl-5", 6: "oui-pl-6", 7: "oui-pl-7", 8: "oui-pl-8", 9: "oui-pl-9", 10: "oui-pl-10" }, pr: { 0: "oui-pr-0", 1: "oui-pr-1", 2: "oui-pr-2", 3: "oui-pr-3", 4: "oui-pr-4", 5: "oui-pr-5", 6: "oui-pr-6", 7: "oui-pr-7", 8: "oui-pr-8", 9: "oui-pr-9", 10: "oui-pr-10" }, m: { 0: "oui-m-0", 1: "oui-m-1", 2: "oui-m-2", 3: "oui-m-3", 4: "oui-m-4", 5: "oui-m-5", 6: "oui-m-6", 7: "oui-m-7", 8: "oui-m-8", 9: "oui-m-9", 10: "oui-m-10" }, mx: { 0: "oui-mx-0", 1: "oui-mx-1", 2: "oui-mx-2", 3: "oui-mx-3", 4: "oui-mx-4", 5: "oui-mx-5", 6: "oui-mx-6", 7: "oui-mx-7", 8: "oui-mx-8", 9: "oui-mx-9", 10: "oui-mx-10" }, my: { 0: "oui-my-0", 1: "oui-my-1", 2: "oui-my-2", 3: "oui-my-3", 4: "oui-my-4", 5: "oui-my-5", 6: "oui-my-6", 7: "oui-my-7", 8: "oui-my-8", 9: "oui-my-9", 10: "oui-my-10" }, mt: { 0: "oui-mt-0", 1: "oui-mt-1", 2: "oui-mt-2", 3: "oui-mt-3", 4: "oui-mt-4", 5: "oui-mt-5", 6: "oui-mt-6", 7: "oui-mt-7", 8: "oui-mt-8", 9: "oui-mt-9", 10: "oui-mt-10" }, mb: { 0: "oui-mb-0", 1: "oui-mb-1", 2: "oui-mb-2", 3: "oui-mb-3", 4: "oui-mb-4", 5: "oui-mb-5", 6: "oui-mb-6", 7: "oui-mb-7", 8: "oui-mb-8", 9: "oui-mb-9", 10: "oui-mb-10" }, ml: { 0: "oui-ml-0", 1: "oui-ml-1", 2: "oui-ml-2", 3: "oui-ml-3", 4: "oui-ml-4", 5: "oui-ml-5", 6: "oui-ml-6", 7: "oui-ml-7", 8: "oui-ml-8", 9: "oui-ml-9", 10: "oui-ml-10" }, mr: { 0: "oui-mr-0", 1: "oui-mr-1", 2: "oui-mr-2", 3: "oui-mr-3", 4: "oui-mr-4", 5: "oui-mr-5", 6: "oui-mr-6", 7: "oui-mr-7", 8: "oui-mr-8", 9: "oui-mr-9", 10: "oui-mr-10" }, grow: { true: "oui-grow" } } };
var $i = (e3) => {
  let { width: o, height: t, angle: r3, left: i, top: n4, bottom: a2, right: s, ...l2 } = e3, u2 = /* @__PURE__ */ Object.create(null);
  return r3 && (u2["--oui-gradient-angle"] = `${r3}deg`), Oe$2("--oui-width", o, u2), Oe$2("--oui-height", t, u2), Oe$2("--oui-left", i, u2), Oe$2("--oui-right", s, u2), Oe$2("--oui-top", n4, u2), Oe$2("--oui-bottom", a2, u2), { ...l2, style: { ...l2.style, ...u2 } };
};
function Oe$2(e3, o, t) {
  typeof o < "u" && (t[e3] = Kl(o));
}
function Kl(e3) {
  return typeof e3 == "number" ? `${e3}px` : e3;
}
var Jo$1 = (e3) => {
  let { angle: o } = e3;
  return { "--oui-gradient-angle": o ? `${o}deg` : "180deg" };
};
var et$3 = { variants: { shadow: { sm: "oui-shadow-sm", base: "oui-shadow", md: "oui-shadow-md", lg: "oui-shadow-lg", xl: "oui-shadow-xl", "2xl": "oui-shadow-2xl", inner: "oui-shadow-inner", none: "oui-shadow-none" } } };
var ot$4 = { variants: { border: { true: "oui-border oui-border-line" }, r: { none: "oui-rounded-none", sm: "oui-rounded-sm", base: "oui-rounded", md: "oui-rounded-md", lg: "oui-rounded-lg", xl: "oui-rounded-xl", "2xl": "oui-rounded-2xl", full: "oui-rounded-full" }, gradient: { primary: "oui-gradient-primary", secondary: "oui-gradient-secondary", brand: "oui-gradient-brand", success: "oui-gradient-success", warning: "oui-gradient-warning", danger: "oui-gradient-danger", neutral: "oui-gradient-neutral" }, intensity: { 100: "oui-bg-base-1", 200: "oui-bg-base-2", 300: "oui-bg-base-3", 400: "oui-bg-base-4", 500: "oui-bg-base-5", 600: "oui-bg-base-6", 700: "oui-bg-base-7", 800: "oui-bg-base-8", 900: "oui-bg-base-9" }, borderColor: { 4: "oui-border-line-4", 6: "oui-border-line-6", 8: "oui-border-line", 12: "oui-border-line-12", 16: "oui-border-line-16" } } };
var Zi$2 = { variants: { position: { static: "oui-static", fixed: "oui-fixed", absolute: "oui-absolute", relative: "oui-relative", sticky: "oui-sticky" }, zIndex: { 0: "oui-z-0", 10: "oui-z-10", 20: "oui-z-20", 30: "oui-z-30", 40: "oui-z-40", 50: "oui-z-50", auto: "oui-z-auto" } } };
var qi$2 = { variants: { invisible: { true: "oui-invisible" } } };
var ur$3 = b$2({ base: ["oui-box"], variants: { ...Ui$1.variants, ...et$3.variants, ...ot$4.variants, ...Zi$2.variants, ...qi$2.variants, __position: { true: "oui-position" }, __size_width: { true: "oui-size-width" }, __size_height: { true: "oui-size-height" } }, defaultVariants: { __position: false, __size: false } }), _$1 = Ce__default__default.forwardRef((e3, o) => {
  let { asChild: t = false, as: r3 = "div", className: i, p: n4, px: a2, py: s, pt: l2, pb: u2, pl: p2, pr: d2, m: m2, mx: c2, my: x2, mr: y2, mt: S2, mb: f2, ml: R2, grow: k2, zIndex: w5, style: I2, shadow: v2, border: N2, gradient: W2, r: he2, invisible: q2, intensity: h2, position: D2, borderColor: L2, ...Ko2 } = $i(e3);
  return jsx(t ? Slot : r3, { style: I2, className: ur$3({ className: i, p: n4, r: he2, px: a2, py: s, pt: l2, pb: u2, pr: d2, pl: p2, m: m2, mx: c2, my: x2, mt: S2, mb: f2, ml: R2, mr: y2, zIndex: w5, shadow: v2, border: N2, gradient: W2, position: D2, intensity: h2, invisible: q2, grow: k2, borderColor: L2, __position: typeof D2 < "u", __size_width: typeof e3.width < "u", __size_height: typeof e3.height < "u" }), ...Ko2, ref: o });
});
_$1.displayName = "Box";
var tu = b$2({ variants: { ...Qo$3.variants } }), Ki$2 = b$2({ extend: tu, base: ["oui-flex"], variants: { display: { flex: "oui-flex", inlineFlex: "oui-inline-flex" }, direction: { row: "oui-flex-row", rowReverse: "oui-flex-row-reverse", column: "oui-flex-col", columnReverse: "oui-flex-col-reverse" }, itemAlign: { start: "oui-items-start", end: "oui-items-end", center: "oui-items-center", baseline: "oui-items-baseline", stretch: "oui-items-stretch" }, justify: { start: "oui-justify-start", end: "oui-justify-end", center: "oui-justify-center", between: "oui-justify-between", around: "oui-justify-around", evenly: "oui-justify-evenly", stretch: "oui-justify-stretch" }, wrap: { noWrap: "oui-flex-nowrap", wrap: "oui-flex-wrap", wrapReverse: "oui-flex-wrap-reverse" } }, defaultVariants: { display: "flex", direction: "row", itemAlign: "center", justify: "start", wrap: "noWrap" } }, { responsiveVariants: true }), z$1 = forwardRef((e3, o) => {
  let { className: t, display: r3, gap: i, gapX: n4, gapY: a2, wrap: s, justify: l2, itemAlign: u2, direction: p2, ...d2 } = e3;
  return jsx(_$1, { ref: o, className: Ki$2({ className: t, display: r3, gap: i, gapX: n4, gapY: a2, wrap: s, justify: l2, itemAlign: u2, direction: p2 }), ...d2 });
});
z$1.displayName = "Flex";
var Ji = tv({ base: "oui-text-gray-200 oui-animate-spin dark:oui-text-gray-600 oui-fill-primary-darken", variants: { size: { xs: "oui-w-3 oui-h-3", sm: "oui-w-4 oui-h-4", md: "oui-w-6 oui-h-6", lg: "oui-w-8 oui-h-8", xl: "oui-w-10 oui-h-10" }, color: { primary: "oui-fill-primary-darken", success: "oui-fill-success", danger: "oui-fill-danger", warning: "oui-fill-warning-darken", gray: "oui-fill-gray", darkGray: "oui-fill-darkGray", white: "oui-fill-white" } }, defaultVariants: { size: "lg", color: "primary" } }), we$5 = (e3) => {
  let { size: o, color: t, loading: r3 = true, children: i, className: n4 } = e3;
  return r3 ? jsxs("span", { role: "status", className: "oui-inline-block", children: [jsxs("svg", { "aria-hidden": "true", className: Ji({ size: o, className: n4, color: t }), viewBox: "0 0 100 101", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsx("path", { d: "M100 50.5908C100 78.2051 77.6142 100.591 50 100.591C22.3858 100.591 0 78.2051 0 50.5908C0 22.9766 22.3858 0.59082 50 0.59082C77.6142 0.59082 100 22.9766 100 50.5908ZM9.08144 50.5908C9.08144 73.1895 27.4013 91.5094 50 91.5094C72.5987 91.5094 90.9186 73.1895 90.9186 50.5908C90.9186 27.9921 72.5987 9.67226 50 9.67226C27.4013 9.67226 9.08144 27.9921 9.08144 50.5908Z", fill: "currentColor", fillOpacity: 0.2 }), jsx("path", { d: "M93.9676 39.0409C96.393 38.4038 97.8624 35.9116 97.0079 33.5539C95.2932 28.8227 92.871 24.3692 89.8167 20.348C85.8452 15.1192 80.8826 10.7238 75.2124 7.41289C69.5422 4.10194 63.2754 1.94025 56.7698 1.05124C51.7666 0.367541 46.6976 0.446843 41.7345 1.27873C39.2613 1.69328 37.813 4.19778 38.4501 6.62326C39.0873 9.04874 41.5694 10.4717 44.0505 10.1071C47.8511 9.54855 51.7191 9.52689 55.5402 10.0491C60.8642 10.7766 65.9928 12.5457 70.6331 15.2552C75.2735 17.9648 79.3347 21.5619 82.5849 25.841C84.9175 28.9121 86.7997 32.2913 88.1811 35.8758C89.083 38.2158 91.5421 39.6781 93.9676 39.0409Z", fill: "currentFill" })] }), jsx("span", { className: "oui-sr-only", children: "Loading..." })] }) : jsx(Fragment$1, { children: i });
};
var pr$4 = Ce__default__default.forwardRef((e3, o) => {
  let { asChild: t = false, children: r3, loading: i, leading: n4, trailing: a2, size: s, icon: l2, disabled: u2, ...p2 } = e3, d2 = t ? Slot : "button", m2 = typeof u2 < "u" ? u2 : i, c2 = useMemo(() => l2 ? Ce__default__default.cloneElement(l2, { size: s === "xs" || s === "sm" ? 12 : s === "md" ? 14 : s === "lg" ? 16 : s === "xl" ? 18 : 12, className: "oui-text-inherit", opacity: i ? 0 : 1 }) : null, [s, l2]), x2 = useMemo(() => !n4 && !a2 && !c2 ? r3 : jsxs(z$1, { as: "span", itemAlign: "center", className: "oui-space-x-1", children: [n4, c2, jsx("span", { children: r3 }), a2] }), [r3, n4, a2, c2]), y2 = useMemo(() => {
    switch (s) {
      case "xl":
        return "md";
      case "lg":
        return "md";
      case "md":
        return "sm";
      case "sm":
      case "xs":
        return "xs";
      default:
        return "md";
    }
  }, [s]);
  return jsx(d2, { ...p2, disabled: m2, ref: o, children: i ? jsxs(Fragment$1, { children: [jsx("span", { className: "oui-invisible", children: x2 }), jsx(z$1, { itemAlign: "center", justify: "center", position: "absolute", as: "span", children: jsx(we$5, { size: y2, color: "white" }) })] }) : x2 });
});
pr$4.displayName = "BaseButton";
var rt$4 = tv({ base: ["oui-button", "oui-inline-flex", "oui-items-center", "oui-justify-center", "oui-whitespace-nowrap", "oui-transition-colors", "disabled:oui-cursor-not-allowed", "disabled:oui-bg-base-3", "disabled:oui-text-base-contrast-36", "disabled:hover:oui-bg-base-3"], variants: { ...et$3.variants, variant: { text: "oui-bg-transparent", outlined: "oui-border", contained: "oui-text-white", gradient: "oui-gradient-brand oui-text-[rgba(0,0,0,0.88)]" }, size: { xs: ["oui-px-2", "oui-rounded", "oui-h-6", "oui-text-2xs"], sm: ["oui-px-3", "oui-rounded", "oui-h-7", "oui-text-2xs"], md: ["oui-px-3", "oui-rounded-md", "oui-h-8", "oui-text-sm"], lg: ["oui-px-3", "oui-rounded-md", "oui-h-10", "oui-text-base"], xl: ["oui-px-4", "oui-rounded-lg", "oui-h-13", "oui-text-lg"] }, color: { primary: ["hover:oui-bg-primary-darken/80 active:oui-bg-primary-darken/70"], secondary: "hover:oui-bg-base-4/80 active:oui-bg-base-4/70", success: "hover:oui-bg-success/80 active:oui-bg-success/70", buy: "hover:oui-bg-success/80 active:oui-bg-success/70", danger: "hover:oui-bg-danger/80 active:oui-bg-danger/70", sell: "hover:oui-bg-danger/80 active:oui-bg-danger/70", warning: "hover:oui-bg-warning-darken/80 active:oui-bg-warning-darken/70", gray: "hover:oui-bg-base-2/80 active:oui-bg-base-2/70", light: "hover:oui-bg-white/80 active:oui-bg-white/50 disable:oui-bg-white/20" }, fullWidth: { true: "oui-w-full" } }, compoundVariants: [{ variant: "contained", color: "primary", className: ["oui-bg-primary-darken", "oui-text-primary-contrast"] }, { variant: "contained", color: "secondary", className: ["oui-bg-base-4", "oui-text-primary-contrast"] }, { variant: "contained", color: "success", className: ["oui-bg-success", "oui-text-success-contrast"] }, { variant: "contained", color: "buy", className: ["oui-bg-trade-profit", "oui-text-success-contrast"] }, { variant: "contained", color: "warning", className: ["oui-bg-warning-darken", "oui-text-warning-contrast"] }, { variant: "contained", color: "danger", className: ["oui-bg-danger", "oui-text-danger-contrast"] }, { variant: "contained", color: "sell", className: ["oui-bg-trade-loss", "oui-text-danger-contrast"] }, { variant: "contained", color: "gray", className: ["oui-bg-base-2", "oui-text-base-contrast"] }, { variant: "contained", color: "light", className: ["oui-bg-white", "oui-text-black/[.88]", "disabled:oui-bg-white/30 hover:disabled:oui-bg-white/30 disabled:oui-text-black/[.36]"] }, { variant: "outlined", color: "primary", className: ["oui-border-primary-darken", "oui-text-primary-darken", "hover:oui-bg-primary-darken/20"] }, { variant: "outlined", color: "secondary", className: ["oui-border-base-4", "oui-text-base-contrast-54", "hover:oui-bg-base-4/20"] }, { variant: "outlined", color: "success", className: ["oui-border-success", "oui-text-success", "hover:oui-bg-success/20"] }, { variant: "outlined", color: "warning", className: ["oui-border-warning-darken", "oui-text-warning-contrast", "hover:oui-bg-warning-darken/20"] }, { variant: "outlined", color: "danger", className: ["oui-border-danger", "oui-text-danger", "hover:oui-bg-danger/20"] }, { variant: "outlined", color: "gray", className: ["oui-border-base-2", "oui-text-base"] }, { variant: "text", color: "primary", className: ["oui-text-primary-darken hover:oui-bg-primary-darken/10"] }, { variant: "text", color: "success", className: ["oui-text-success hover:oui-bg-success/10"] }, { variant: "text", color: "warning", className: ["oui-text-warning-contrast hover:oui-bg-warning-darken/10"] }, { variant: "text", color: "danger", className: ["oui-text-danger hover:oui-bg-danger/10"] }, { variant: "text", color: "gray", className: ["oui-text-base hover:oui-bg-base-2/10"] }, { variant: "text", color: "secondary", className: ["oui-text-base-contrast-36 hover:oui-bg-base-2/10"] }], defaultVariants: { size: "lg", variant: "contained", color: "primary" } }, { responsiveVariants: ["md", "lg"] }), _e$5 = Ce__default__default.forwardRef(({ className: e3, variant: o, size: t, color: r3, fullWidth: i, shadow: n4, angle: a2, style: s, ...l2 }, u2) => {
  let p2 = Jo$1({ angle: a2 });
  return jsx(pr$4, { className: rt$4({ variant: o, size: t, color: r3, className: e3, fullWidth: i, shadow: n4 }), size: t, ref: u2, style: { ...s, ...p2 }, ...l2 });
});
_e$5.displayName = "Button";
var dr$3 = Ce__default__default.forwardRef(({ onClick: e3, throttleDuration: o = 700, ...t }, r3) => {
  let i = useRef(0), a2 = useCallback((s, l2) => function(...u2) {
    let p2 = Date.now();
    p2 - i.current >= s && (i.current = p2, l2 == null ? void 0 : l2(...u2));
  }, [o])(o, e3);
  return jsx(_e$5, { onClick: a2, ref: r3, ...t });
});
var ta$2 = b$2({ extend: Qo$3, base: ["oui-grid"], variants: { cols: { 1: "oui-grid-cols-1", 2: "oui-grid-cols-2", 3: "oui-grid-cols-3", 4: "oui-grid-cols-4", 5: "oui-grid-cols-5", 6: "oui-grid-cols-6", 7: "oui-grid-cols-7", 8: "oui-grid-cols-8", 9: "oui-grid-cols-9", none: "oui-grid-cols-none" }, rows: { 1: "oui-grid-rows-1", 2: "oui-grid-rows-2", 3: "oui-grid-rows-3", 4: "oui-grid-rows-4", 5: "oui-grid-rows-5", 6: "oui-grid-rows-6", 7: "oui-grid-rows-7", 8: "oui-grid-rows-8", 9: "oui-grid-rows-9", none: "oui-grid-rows-none" }, autoFlow: { row: "oui-grid-flow-row", col: "oui-grid-flow-col", rowDense: "oui-grid-flow-row-dense", colDense: "oui-grid-flow-col-dense" }, gap: { 0: "oui-gap-0", 1: "oui-gap-1", 2: "oui-gap-2", 3: "oui-gap-3", 4: "oui-gap-4", 5: "oui-gap-5" }, gapX: { 0: "oui-gap-x-0", 1: "oui-gap-x-1", 2: "oui-gap-x-2", 3: "oui-gap-x-3", 4: "oui-gap-x-4", 5: "oui-gap-x-5" }, gapY: { 0: "oui-gap-y-0", 1: "oui-gap-y-1", 2: "oui-gap-y-2", 3: "oui-gap-y-3", 4: "oui-gap-y-4", 5: "oui-gap-y-5" } }, defaultVariants: {} }), mr$3 = Ce__default__default.forwardRef((e3, o) => {
  let { className: t, cols: r3, rows: i, gap: n4, gapX: a2, gapY: s, autoFlow: l2, ...u2 } = e3;
  return jsx(_$1, { ref: o, ...u2, className: ta$2({ className: t, cols: r3, rows: i, gap: n4, gapX: a2, gapY: s, autoFlow: l2 }) });
});
mr$3.displayName = "Grid";
var wu = b$2({ variants: { colSpan: { auto: "oui-col-auto", 1: "oui-col-span-1", 2: "oui-col-span-2", 3: "oui-col-span-3", 4: "oui-col-span-4", 5: "oui-col-span-5", 6: "oui-col-span-6", 7: "oui-col-span-7", 8: "oui-col-span-8", 9: "oui-col-span-9" }, rowSpan: { auto: "oui-row-auto", 1: "oui-row-span-1", 2: "oui-row-span-2", 3: "oui-row-span-3", 4: "oui-row-span-4", 5: "oui-row-span-5", 6: "oui-row-span-6", 7: "oui-row-span-7", 8: "oui-row-span-8", 9: "oui-row-span-9" } } }), ra$2 = (e3) => {
  let { colSpan: o, rowSpan: t, className: r3, ...i } = e3, n4 = useRef(null);
  return useEffect(() => {
    if (n4.current) {
      let a2 = n4.current.parentElement;
      !a2 || a2.classList.contains("oui-grid");
    }
  }, []), jsx(_$1, { ref: n4, ...i, className: wu({ colSpan: o, rowSpan: t, className: r3 }) });
};
var ia$1 = mr$3;
ia$1.span = ra$2;
var na$1 = b$2({ variants: { size: { "3xs": ["oui-text-3xs"], "2xs": ["oui-text-2xs"], xs: ["oui-text-xs"], sm: ["oui-text-sm"], base: ["oui-text-base"], lg: ["oui-text-lg"], xl: ["oui-text-xl"], "2xl": ["oui-text-2xl"], "3xl": ["oui-text-3xl"], "4xl": ["oui-text-4xl"], "5xl": ["oui-text-5xl"], "6xl": ["oui-text-6xl"] }, weight: { regular: ["oui-font-normal"], semibold: ["oui-font-semibold"], bold: ["oui-font-bold"] }, color: { inherit: "oui-text-inherit", neutral: "oui-text-base-contrast-54", primary: "oui-text-primary", primaryLight: "oui-text-primary-light", secondary: "oui-text-secondary", tertiary: "oui-text-tertiary", warning: "oui-text-warning-darken", danger: "oui-text-danger", success: "oui-text-success", buy: "oui-text-trade-profit", sell: "oui-text-trade-loss", lose: "oui-text-trade-loss", withdraw: "oui-text-trade-loss", profit: "oui-text-trade-profit", deposit: "oui-text-trade-profit" }, intensity: { 12: "oui-text-base-contrast-12", 20: "oui-text-base-contrast-20", 36: "oui-text-base-contrast-36", 54: "oui-text-base-contrast-54", 80: "oui-text-base-contrast-80", 98: "oui-text-base-contrast" }, dashBoard: { default: "oui-border-b oui-border-dashed oui-border-base-contrast-12" } } }), K$3 = Ce__default__default.forwardRef((e3, o) => {
  let { children: t, className: r3, asChild: i, as: n4 = "span", color: a2, size: s, weight: l2, intensity: u2, ...p2 } = e3;
  return jsx(Slot, { "data-accent-color": a2, ...p2, ref: o, className: na$1({ className: r3, color: a2, size: s, weight: l2, intensity: u2 }), children: i ? t : jsx(n4, { children: t }) });
});
K$3.displayName = "Text";
var fr$5 = (e3, o = {}) => {
  var _a2;
  let { rule: t, dp: r3, tick: i, rm: n4 = g$6.ROUND_DOWN, padding: a2 = true, abs: s } = o;
  if (Number.isNaN(e3)) return "--";
  if (r3 = typeof r3 < "u" ? r3 : i ? E$3(i) : 2, t === "human") return _$3(typeof e3 == "number" ? e3 : Number(e3), r3);
  let l2 = new g$6(e3);
  if (s && (l2 = l2.abs()), t === "percentages") return sa(l2.mul(100), { dp: r3, rm: n4, padding: a2 }) + "%";
  let u2 = sa(l2, { dp: r3, rm: n4, padding: a2 });
  return t === "price" ? d$3(u2) : (u2 == null ? void 0 : u2.includes("e")) ? (_a2 = new g$6(u2)) == null ? void 0 : _a2.toFixed() : u2;
};
function sa(e3, o) {
  let { dp: t, rm: r3, padding: i } = o;
  return r3 === "truncate" ? A$7(e3.toString(), t) : i ? e3.toFixed(t, r3) : e3.todp(t, r3).toString();
}
function Nu(e3, o) {
  if (e3 == null) return "";
  let [t, r3] = o ?? [6, 4], i = new RegExp(`^(.{${t}})(.*)(.{${r3}})$`);
  return `${e3.replace(i, "$1...$3")}`;
}
var ca = (e3) => ["percentages", "price", "human"].includes(e3), He$5 = (e3) => {
  let { rule: o = "price", coloring: t, dp: r3, tick: i, suffix: n4, prefix: a2, visible: s, unit: l2, currency: u2, rm: p2, padding: d2 = true, showIdentifier: m2 = false, identifiers: c2, className: x2, unitClassName: y2, placeholder: S2, masking: f2, ignoreDP: R2, ...k2 } = e3, w5 = Number(e3.children), I2 = useMemo(() => e3.children === "-" ? e3.children : isNaN(w5) ? S2 ?? "--" : typeof s < "u" && !s ? f2 ?? "*****" : R2 ? e3.showIdentifier ? Math.abs(w5).toString() : w5 : fr$5(w5, { rule: o, dp: r3, tick: i, rm: p2, padding: d2, abs: m2 }), [w5, s, i, r3]), v2 = k2.color || "inherit", N2 = useMemo(() => !t || typeof s < "u" && !s || Number.isNaN(w5) ? v2 : w5 === 0 ? "neutral" : w5 < 0 ? "lose" : "profit", [t, w5, k2.color, e3.visible]), W2 = useMemo(() => !m2 || Number.isNaN(w5) || w5 === 0 || typeof s < "u" && !s ? null : w5 < 0 ? (c2 == null ? void 0 : c2.loss) ? c2.loss : jsx("span", { children: "-" }) : (c2 == null ? void 0 : c2.profit) ? c2.profit : jsx("span", { children: "+" }), [w5, e3.visible, m2]), he2 = useMemo(() => {
    if (typeof n4 > "u" && typeof a2 > "u" && typeof l2 > "u" && typeof u2 > "u" && !m2) return I2;
    let q2 = n4 ? typeof n4 == "string" ? jsx("span", { children: n4 }) : n4 : void 0, h2 = l2 ? jsx("span", { className: cnBase("orderly-numeral-unit", y2), children: l2 }) : void 0, D2 = a2 || (u2 ? jsx("span", { children: u2 }) : void 0), L2 = jsxs(Fragment$1, { children: [I2, h2] });
    return jsxs(Fragment$1, { children: [D2, typeof W2 < "u" ? jsxs("span", { children: [W2, jsx("span", { children: L2 })] }) : jsx("span", { children: L2 }), q2] });
  }, [I2, n4, l2, a2, W2, y2]);
  return jsx(K$3, { ...k2, color: N2, children: he2, className: cnBase("oui-tabular-nums", x2) });
};
var wr = b$2({ slots: { root: "oui-text-base oui-flex oui-flex-col", label: "oui-text-xs oui-text-base-contrast-36", value: "" }, variants: { align: { start: { root: "oui-items-start" }, end: { root: "oui-items-end" } } }, defaultVariants: { align: "start" } }), vr$2 = Ce__default__default.forwardRef((e3, o) => {
  let { label: t } = wr({});
  return jsx("div", { ref: o, className: t({ className: cnBase("oui-statistic-label", e3.className) }), children: e3.children });
});
vr$2.displayName = "StatisticLabel";
var da$2 = Ce__default__default.forwardRef((e3, o) => {
  let { label: t, valueProps: r3, align: i, className: n4, classNames: a2, children: s, ...l2 } = e3, { root: u2, value: p2 } = wr({ align: i }), d2 = useMemo(() => {
    if (typeof s == "string" || typeof s == "number") {
      let { className: m2, ...c2 } = r3 ?? {};
      return jsx(He$5, { ...c2, className: cnBase(p2({ className: m2 }), "oui-font-semibold", !(r3 == null ? void 0 : r3.coloring) && "oui-text-base-contrast-80"), children: s });
    }
    return s;
  }, [s, r3]);
  return jsxs("div", { ...l2, className: u2({ className: cnBase(n4, a2 == null ? void 0 : a2.root) }), ref: o, children: [jsx(vr$2, { className: a2 == null ? void 0 : a2.label, children: t }), d2] });
});
da$2.displayName = "Statistic";
var Mu = tv({ variants: { color: { primary: "oui-text-primary-darken", success: "oui-text-success", danger: "oui-text-danger", warning: "oui-text-warning-darken", white: "oui-text-white", black: "oui-text-black", inherit: "oui-text-inherit" } }, defaultVariants: { color: "black" } }), g$3 = Ce__default__default.forwardRef((e3, o) => {
  let { size: t = 24, color: r3, className: i, ...n4 } = e3;
  return jsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: t, height: t, fill: "none", viewBox: "0 0 24 24", ref: o, className: Mu({ className: i, color: r3 }), ...n4 });
});
var C$1 = Ce__default__default.forwardRef((e3, o) => {
  let { opacity: t = 0.54, d: r3, ...i } = e3;
  return jsx(g$3, { ref: o, ...i, children: jsx("path", { fill: "currentcolor", fillOpacity: t, fillRule: "evenodd", clipRule: "evenodd", d: r3 }) });
});
var at$3 = Ce__default__default.forwardRef((e3, o) => jsx(C$1, { ref: o, ...e3, d: "M6.998 2.99a4 4 0 00-4 4v6a4 4 0 004 4 4 4 0 004 4h6a4 4 0 004-4v-6a4 4 0 00-4-4 4 4 0 00-4-4h-6zm10 6a2 2 0 012 2v6a2 2 0 01-2 2h-6a2 2 0 01-2-2h4a4 4 0 004-4v-4z" }));
at$3.displayName = "CopyIcon";
var ye$7 = Ce__default__default.forwardRef((e3, o) => {
  let { opacity: t = 0.54, ...r3 } = e3;
  return jsx(g$3, { ref: o, ...r3, children: jsx("path", { fill: "currentcolor", fillOpacity: t, d: "M4.994 3.906c-.256 0-.523.086-.718.281a1.029 1.029 0 0 0 0 1.438l6.28 6.281-6.28 6.281a1.029 1.029 0 0 0 0 1.438c.39.39 1.047.39 1.437 0l6.281-6.28 6.282 6.28c.39.39 1.047.39 1.437 0 .39-.39.39-1.047 0-1.438l-6.281-6.28 6.281-6.282c.39-.39.39-1.047 0-1.438a1.013 1.013 0 0 0-.719-.28c-.256 0-.523.085-.718.28l-6.282 6.281-6.28-6.28a1.013 1.013 0 0 0-.72-.282Z" }) });
});
ye$7.displayName = "CloseIcon";
var fa$1 = Ce__default__default.forwardRef((e3, o) => {
  let { opacity: t = 0.54, ...r3 } = e3;
  return jsx(C$1, { d: "M19.018 5.997c-.256 0-.523.084-.718.276l-8.707 8.594c-.257.253-.515.206-.717-.092l-2.996-4.42a1.034 1.034 0 0 0-1.405-.276.996.996 0 0 0-.28 1.38l2.995 4.42c.902 1.33 2.659 1.499 3.808.369l8.738-8.563a1 1 0 0 0 0-1.412 1.02 1.02 0 0 0-.718-.276Z", ref: o, ...e3 });
});
fa$1.displayName = "CheckIcon";
var nt$3 = Ce__default__default.forwardRef((e3, o) => {
  let { opacity: t = 0.54, ...r3 } = e3;
  return jsx(g$3, { ref: o, ...r3, children: jsx("path", { fill: "currentcolor", fillOpacity: t, d: "M5.827 9.03c-.25.05-.502.175-.655.404a1.019 1.019 0 0 0 .28 1.401l5.992 3.985c.334.223.787.223 1.122 0l5.992-3.985c.459-.305.587-.943.28-1.4a1.023 1.023 0 0 0-1.404-.28l-5.43 3.61-5.428-3.61c-.23-.154-.498-.176-.75-.126Z" }) });
});
nt$3.displayName = "ChevronDownIcon";
var st$2 = Ce__default__default.forwardRef((e3, o) => {
  let { opacity: t = 0.54, ...r3 } = e3;
  return jsx(g$3, { ref: o, ...r3, children: jsx("path", { fill: "currentcolor", fillOpacity: t, d: "m11.443 9.17-5.991 3.986a1.02 1.02 0 0 0-.28 1.4c.305.458.945.586 1.404.281l5.429-3.612 5.428 3.612a1.025 1.025 0 0 0 1.404-.28 1.02 1.02 0 0 0-.28-1.401l-5.99-3.986a1.028 1.028 0 0 0-1.124 0Z" }) });
});
st$2.displayName = "ChevronUpIcon";
var lt$5 = Ce__default__default.forwardRef((e3, o) => {
  let { opacity: t = 0.54, ...r3 } = e3;
  return jsx(g$3, { ref: o, ...r3, children: jsx("path", { fill: "currentcolor", fillOpacity: t, d: "M12.017 5.997c-.3 0-.612.14-.812.406l-6 8c-.495.66-.012 1.594.812 1.594h12c.824 0 1.307-.935.812-1.594l-6-8a1.022 1.022 0 0 0-.812-.406Z" }) });
});
lt$5.displayName = "CaretUpIcon";
var Q$4 = Ce__default__default.forwardRef((e3, o) => jsx(C$1, { ref: o, ...e3, d: "M6.007 7.996c-.824 0-1.276.935-.781 1.594l6 8a.994.994 0 0 0 1.593 0l6-8c.495-.66.012-1.594-.812-1.594h-12Z" }));
Q$4.displayName = "CaretDownIcon";
var va$1 = Ce__default__default.forwardRef((e3, o) => {
  let { opacity: t = 0.54, ...r3 } = e3;
  return jsx(g$3, { ref: o, ...r3, children: jsx("path", { fill: "currentcolor", fillOpacity: t, d: "M15.475 5.113a1.014 1.014 0 0 0-1.063.094l-8 6a1.025 1.025 0 0 0 0 1.624l8 6c.659.495 1.594.012 1.594-.812v-12c0-.412-.214-.747-.531-.906Z" }) });
});
va$1.displayName = "CaretLeftIcon";
var Pa = Ce__default__default.forwardRef((e3, o) => {
  let { opacity: t = 0.54, ...r3 } = e3;
  return jsx(g$3, { ref: o, ...r3, children: jsx("path", { fill: "currentcolor", fillOpacity: t, d: "M8.558 5.113a1.015 1.015 0 0 0-.562.906v12c0 .824.966 1.307 1.625.812l8-6c.533-.4.533-1.224 0-1.624l-8-6a1.014 1.014 0 0 0-1.063-.094Z" }) });
});
Pa.displayName = "CaretRightIcon";
var We$6 = Ce__default__default.forwardRef((e3, o) => jsx(C$1, { ref: o, ...e3, d: "M13.778 5.022c-.25.05-.5.176-.653.406l-3.986 6a1.03 1.03 0 0 0 0 1.125l3.986 6c.305.459.943.588 1.401.28.457-.305.585-.946.28-1.405l-3.612-5.438 3.612-5.437c.305-.46.177-1.1-.28-1.406-.229-.154-.498-.176-.748-.125Z" }));
We$6.displayName = "ChevronLeftIcon";
var Ge$2 = Ce__default__default.forwardRef((e3, o) => {
  let { opacity: t = 0.54, ...r3 } = e3;
  return jsx(g$3, { ref: o, ...r3, children: jsx("path", { fill: "currentcolor", fillOpacity: t, d: "M10.166 5.022c-.25-.051-.519-.03-.748.125a1.027 1.027 0 0 0-.28 1.406l3.612 5.437-3.612 5.438c-.305.459-.177 1.1.28 1.406a1.019 1.019 0 0 0 1.401-.281l3.986-6a1.03 1.03 0 0 0 0-1.125l-3.986-6c-.152-.23-.403-.356-.653-.406Z" }) });
});
Ge$2.displayName = "ChevronRightIcon";
var ka$2 = Ce__default__default.forwardRef((e3, o) => {
  let { opacity: t = 0.54, ...r3 } = e3;
  return jsx(g$3, { ref: o, ...r3, children: jsx("path", { fill: "currentcolor", fillOpacity: t, d: "M8.968 2.455a9.671 9.671 0 0 0-3.72 2.188c-.332.31-.434.818-.218 1.218.8 1.481-.037 3.066-1.844 3.157-.442.022-.833.35-.937.781a8.71 8.71 0 0 0-.25 2.188c0 .687.074 1.464.219 2.156.09.432.466.743.906.781 1.818.158 2.718 1.544 1.906 3.313-.18.393-.098.863.219 1.157 1.062.982 2.282 1.675 3.719 2.125.41.128.873-.027 1.125-.375 1.112-1.54 2.725-1.544 3.78 0 .25.363.706.538 1.126.405a10.1 10.1 0 0 0 3.75-2.155c.33-.301.417-.788.219-1.188-.832-1.68.125-3.22 1.843-3.25.456-.008.862-.307.969-.75.173-.717.219-1.341.219-2.22 0-.754-.09-1.497-.25-2.218a.994.994 0 0 0-.97-.782c-1.69-.003-2.638-1.665-1.811-3.125a.977.977 0 0 0-.188-1.218c-1.09-.99-2.42-1.764-3.812-2.188a.986.986 0 0 0-1.125.406c-.966 1.501-2.77 1.527-3.72.032a1.023 1.023 0 0 0-1.155-.438Zm6.078 2.124a7.904 7.904 0 0 1 1.84 1.054c-.725 2.297.506 4.683 3.056 5.265.063.412.057.662.057 1.088 0 .51.007.688-.051 1.056-2.54.527-3.795 2.845-3.088 5.296-.608.441-1.043.747-1.806 1.043-1.792-1.825-4.28-1.904-6.11.011-.714-.314-1.263-.593-1.818-1.061.688-2.49-.475-4.638-3.057-5.29-.115-.457-.07-1.745-.003-2.136 2.67-.64 3.722-3.003 3.059-5.279.586-.44 1.113-.762 1.798-1.04 1.725 1.755 4.315 1.93 6.123-.007Zm-3.047 3.407a4 4 0 1 0 0 8 4 4 0 0 0 0-8Zm0 2a2 2 0 1 1 0 4 2 2 0 0 1 0-4Z" }) });
});
ka$2.displayName = "SettingIcon";
var Na = Ce__default__default.forwardRef((e3, o) => {
  let { opacity: t = 0.54, ...r3 } = e3;
  return jsx(g$3, { ref: o, ...r3, children: jsx("path", { fill: "currentcolor", fillOpacity: t, d: "M8.968 2.456a9.669 9.669 0 0 0-3.72 2.187c-.332.31-.434.818-.218 1.219.8 1.48-.037 3.065-1.843 3.156-.443.023-.834.35-.938.78a8.712 8.712 0 0 0-.25 2.188c0 .688.074 1.464.219 2.156.09.433.466.744.906.783 1.818.156 2.718 1.543 1.906 3.311-.18.393-.098.863.219 1.156 1.062.983 2.282 1.675 3.719 2.125.41.13.873-.026 1.125-.375 1.112-1.537 2.725-1.543 3.78 0 .25.364.706.54 1.126.407a10.072 10.072 0 0 0 3.75-2.157c.33-.3.417-.787.219-1.186-.832-1.68.125-3.221 1.843-3.25.456-.008.862-.308.969-.75.173-.717.219-1.342.219-2.22 0-.754-.09-1.497-.25-2.218a.994.994 0 0 0-.97-.781c-1.69-.003-2.638-1.665-1.811-3.125a.979.979 0 0 0-.188-1.22 10.153 10.153 0 0 0-3.812-2.186.986.986 0 0 0-1.125.406c-.966 1.5-2.77 1.527-3.72.03-.242-.382-.723-.574-1.155-.436Zm3.03 5.53a4 4 0 1 1 0 8 4 4 0 0 1 0-8Z" }) });
});
Na.displayName = "SettingFillIcon";
var Ia = Ce__default__default.forwardRef((e3, o) => {
  let { opacity: t = 0.54, ...r3 } = e3;
  return jsx(g$3, { ref: o, ...r3, children: jsx("path", { fill: "currentcolor", fillOpacity: t, d: "M7.006 2.93a4 4 0 0 0-4 4v10a4 4 0 0 0 4 4h10a4 4 0 0 0 4-4v-10a4 4 0 0 0-4-4h-10Zm2 5c.256 0 .523.086.719.28l2.28 2.282 2.282-2.281c.195-.195.463-.281.719-.281.256 0 .523.086.719.28a1.03 1.03 0 0 1 0 1.439l-2.281 2.28 2.28 2.282a1.03 1.03 0 0 1 0 1.438 1.03 1.03 0 0 1-1.437 0l-2.281-2.281-2.281 2.28a1.03 1.03 0 0 1-1.438 0 1.03 1.03 0 0 1 0-1.437l2.28-2.281-2.28-2.281a1.03 1.03 0 0 1 0-1.438c.195-.195.463-.281.719-.281Z" }) });
});
Ia.displayName = "CloseSquareFillIcon";
var za = Ce__default__default.forwardRef((e3, o) => {
  let { opacity: t = 0.54, ...r3 } = e3;
  return jsx(g$3, { ref: o, ...r3, children: jsx("path", { fill: "currentcolor", fillOpacity: t, d: "M11.999 1.953c-5.523 0-10 4.477-10 10s4.477 10 10 10 10-4.477 10-10-4.477-10-10-10Zm-3 6c.256 0 .523.086.719.281l2.28 2.281 2.282-2.28c.196-.196.463-.282.719-.282.256 0 .523.086.719.281a1.03 1.03 0 0 1 0 1.438l-2.281 2.281 2.28 2.281a1.03 1.03 0 0 1 0 1.438 1.03 1.03 0 0 1-1.437 0l-2.281-2.28-2.281 2.28a1.03 1.03 0 0 1-1.438 0 1.029 1.029 0 0 1 0-1.438l2.28-2.28-2.28-2.282a1.029 1.029 0 0 1 0-1.438c.196-.195.463-.28.719-.28Z" }) });
});
za.displayName = "CloseCircleFillIcon";
var Ma = Ce__default__default.forwardRef((e3, o) => jsx(C$1, { ref: o, ...e3, d: "M2.014 11.999c0-5.523 4.477-10 10-10s10 4.477 10 10-4.477 10-10 10-10-4.477-10-10Zm14.971-4.687c.227-.217.539-.312.837-.312.298 0 .61.095.836.312a1.102 1.102 0 0 1 0 1.595l-8.15 7.768a1.24 1.24 0 0 1-1.673 0l-3.494-3.33a1.104 1.104 0 0 1 0-1.594 1.24 1.24 0 0 1 1.674 0l2.656 2.531 7.314-6.97Z" }));
Ma.displayName = "CheckedCircleFillIcon";
var Ea = Ce__default__default.forwardRef((e3, o) => {
  let { opacity: t = 0.54, ...r3 } = e3;
  return jsx(g$3, { ref: o, ...r3, children: jsx("path", { fill: "currentcolor", fillOpacity: t, fillRule: "evenodd", clipRule: "evenodd", d: "M6.99 2.93a4 4 0 0 0-4 4v10a4 4 0 0 0 4 4h10a4 4 0 0 0 4-4v-10a4 4 0 0 0-4-4h-10Zm9.995 4.382c.227-.217.539-.312.837-.312.298 0 .61.095.836.312a1.102 1.102 0 0 1 0 1.595l-8.15 7.768a1.24 1.24 0 0 1-1.673 0l-3.494-3.33a1.104 1.104 0 0 1 0-1.594 1.24 1.24 0 0 1 1.674 0l2.656 2.531 7.314-6.97Z" }) });
});
Ea.displayName = "CheckSquareFillIcon";
var Va$1 = Ce__default__default.forwardRef((e3, o) => {
  let { opacity: t = 0.54, ...r3 } = e3;
  return jsx(g$3, { ref: o, ...r3, children: jsx("path", { fill: "currentcolor", fillOpacity: t, fillRule: "evenodd", clipRule: "evenodd", d: "M6.99 2.93a4 4 0 0 0-4 4v10a4 4 0 0 0 4 4h10a4 4 0 0 0 4-4v-10a4 4 0 0 0-4-4h-10Zm0 2h10a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-10a2 2 0 0 1-2-2v-10a2 2 0 0 1 2-2Z" }) });
});
Va$1.displayName = "CheckSquareEmptyIcon";
var ac = Ce__default__default.forwardRef((e3, o) => {
  let { opacity: t = 0.54, ...r3 } = e3;
  return jsx(g$3, { ref: o, ...r3, children: jsx("path", { fill: "currentcolor", fillOpacity: t, d: "M11.99 2.93a1 1 0 0 0-1 1v7h-7a1 1 0 0 0 0 2h7v7a1 1 0 0 0 2 0v-7h7a1 1 0 0 0 0-2h-7v-7a1 1 0 0 0-1-1Z" }) });
});
var Oa$1 = Ce__default__default.forwardRef((e3, o) => {
  let { opacity: t = 0.54, ...r3 } = e3;
  return jsx(g$3, { ref: o, ...r3, children: jsx("path", { fill: "currentcolor", fillOpacity: t, d: "M12.014 1.999c-5.523 0-10 4.477-10 10s4.477 10 10 10 10-4.477 10-10-4.477-10-10-10Zm0 2a8 8 0 1 1 0 16 8 8 0 0 1 0-16Z" }) });
});
Oa$1.displayName = "CircleOutlinedIcon";
var Ha = Ce__default__default.forwardRef((e3, o) => {
  let { opacity: t = 0.54, ...r3 } = e3;
  return jsx(g$3, { ref: o, ...r3, children: jsx("path", { fill: "currentcolor", fillOpacity: t, d: "M6.99 2.93a4 4 0 0 0-4 4v10a4 4 0 0 0 4 4h10a4 4 0 0 0 4-4v-10a4 4 0 0 0-4-4h-10Zm0 2h10a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-10a2 2 0 0 1-2-2v-10a2 2 0 0 1 2-2Z" }) });
});
Ha.displayName = "SquareOutlinedIcon";
var Ga = Ce__default__default.forwardRef((e3, o) => {
  let { ...t } = e3;
  return jsx(g$3, { ref: o, ...t, children: jsx("path", { fill: "currentcolor", d: "M12.014 1.999c-5.523 0-10 4.477-10 10s4.477 10 10 10 10-4.477 10-10-4.477-10-10-10Zm0 5a1 1 0 0 1 1 1v5a1 1 0 0 1-2 0v-5a1 1 0 0 1 1-1Zm0 8a1 1 0 1 1 0 2 1 1 0 0 1 0-2Z" }) });
});
Ga.displayName = "ExclamationFillIcon";
var Xa = Ce__default__default.forwardRef((e3, o) => {
  let { opacity: t = 0.54, ...r3 } = e3;
  return jsx(g$3, { ref: o, ...r3, children: jsx("path", { fill: "currentcolor", fillOpacity: t, d: "M12.014 1.953c-5.523 0-10 4.477-10 10s4.477 10 10 10 10-4.477 10-10-4.477-10-10-10Zm0 5a3.006 3.006 0 0 1 3 3c.004 1.11-.516 2.044-1.375 2.906-.18.181-.353.355-.563.532-.099.084-.376.287-.406.312-.422.356-1.05.33-1.406-.094a1.035 1.035 0 0 1 .125-1.437l.375-.313c.168-.14.335-.272.47-.406.518-.522.782-1.022.78-1.5a1 1 0 0 0-1.969-.25c-.14.534-.685.86-1.219.72a1.034 1.034 0 0 1-.718-1.25 2.995 2.995 0 0 1 2.906-2.22Zm0 8a1 1 0 1 1 0 2 1 1 0 0 1 0-2Z" }) });
});
Xa.displayName = "ExclamationFillIcon";
var ja = Ce__default__default.forwardRef((e3, o) => jsx(C$1, { d: "M21.995 16.007c0-.256-.086-.523-.28-.719l-3.72-3.687-1.406 1.406 1.968 2H3.995a1 1 0 000 2h14.562l-1.968 2 1.406 1.406 3.72-3.687c.194-.196.28-.463.28-.719zm-1-8a1 1 0 00-1-1H5.432l1.97-2-1.407-1.406-3.719 3.687a1.03 1.03 0 000 1.438l3.72 3.687L7.4 11.007l-1.969-2h14.563a1 1 0 001-1z", ref: o, ...e3 }));
ja.displayName = "ArrowLeftRightIcon";
var Ua = Ce__default__default.forwardRef((e3, o) => jsx(C$1, { d: "M16.007 2.014c-.256 0-.523.086-.718.281L11.6 6.015l1.406 1.405 2-1.968v14.562a1 1 0 002 0V5.452l2 1.968 1.407-1.406-3.688-3.719a1.012 1.012 0 00-.719-.28zm-8 1a1 1 0 00-1 1v14.562l-2-1.968-1.406 1.406 3.688 3.72c.39.39 1.047.39 1.437 0l3.688-3.72-1.407-1.406-2 1.968V4.014a1 1 0 00-1-1z", ref: o, ...e3 }));
Ua.displayName = "ArrowDownUpIconIcon";
var $a = Ce__default__default.forwardRef((e3, o) => jsx(C$1, { ref: o, ...e3, d: "M6.99 20.99a4 4 0 01-4-4v-10a4 4 0 014-4h10a4 4 0 014 4v10a4 4 0 01-4 4h-10zm5-4a1 1 0 001-1v-5h3l-4-4-4 4h3v5a1 1 0 001 1z" }));
$a.displayName = "ArrowUpSquareFillIconIcon";
var qa$1 = Ce__default__default.forwardRef((e3, o) => {
  let { opacity: t = 0.54, ...r3 } = e3;
  return jsx(g$3, { ref: o, ...r3, children: jsx("path", { fill: "currentcolor", fillOpacity: t, d: "M6.99 2.99a4 4 0 00-4 4v10a4 4 0 004 4h10a4 4 0 004-4v-10a4 4 0 00-4-4h-10zm5 4a1 1 0 011 1v5h3l-4 4-4-4h3v-5a1 1 0 011-1z" }) });
});
qa$1.displayName = "ArrowDownSquareFillIconIcon";
var Ka = Ce__default__default.forwardRef((e3, o) => jsx(C$1, { d: "M7.998 2.014a4 4 0 00-4 4v12a4 4 0 004 4h8a4 4 0 004-4v-12a4 4 0 00-4-4h-8zm0 2h8a2 2 0 012 2v12a2 2 0 01-2 2h-8a2 2 0 01-2-2v-12a2 2 0 012-2zm1 2a1 1 0 00-1 1v1a1 1 0 001 1h6a1 1 0 001-1v-1a1 1 0 00-1-1h-6zm0 4a1 1 0 100 2 1 1 0 000-2zm3 0a1 1 0 100 2 1 1 0 000-2zm3 0a1 1 0 100 2 1 1 0 000-2zm-6 3a1 1 0 100 2 1 1 0 000-2zm3 0a1 1 0 100 2 1 1 0 000-2zm3 0a1 1 0 00-1 1v3a1 1 0 002 0v-3a1 1 0 00-1-1zm-6 3a1 1 0 100 2 1 1 0 000-2zm3 0a1 1 0 100 2 1 1 0 000-2z", ref: o, ...e3 }));
Ka.displayName = "FeeTierIconIcon";
var Ja = Ce__default__default.forwardRef((e3, o) => {
  let { opacity: t = 0.54, ...r3 } = e3;
  return jsx(g$3, { ref: o, ...r3, children: jsx("path", { fill: "currentcolor", fillOpacity: t, d: "M16.995 1.953a1.02 1.02 0 00-.719.281l-3 3.002-9.006 9.005-1 1c-.14.14-.212.338-.25.532l-1 5.003a.974.974 0 001.155 1.157l5.003-1c.194-.04.392-.112.532-.25l1-1.002 9.005-9.005c.445-.444 2.447-2.446 3.003-3a1.02 1.02 0 00.28-.72c0-1.637-.417-2.807-1.282-3.69-.873-.89-2.039-1.313-3.72-1.313zm.395 2.02c.902.052 1.488.26 1.889.67.41.417.669.997.724 1.882-.547.547-1.35 1.337-2.006 1.994l-2.565-2.564c.658-.657 1.41-1.436 1.958-1.983zm-3.396 3.42l2.564 2.564-7.567 7.567-2.564-2.564 7.568-7.567zM4.99 16.398l2.564 2.564-.094.094c-.66.132-1.993.411-3.22.657l.656-3.22.094-.095z" }) });
});
Ja.displayName = "EditIcon";
var on$1 = Ce__default__default.forwardRef((e3, o) => {
  let { opacity: t = 0.54, ...r3 } = e3;
  return jsx(g$3, { ref: o, ...r3, children: jsx("path", { fill: "currentcolor", fillOpacity: t, d: "M12.001 3.998c-2.959 0-5.452 1.454-7.5 3.844a16.652 16.652 0 00-1.812 2.562c-.302.528-.486.936-.594 1.188a1.058 1.058 0 000 .812c.108.252.292.66.594 1.188a16.652 16.652 0 001.812 2.562c2.048 2.39 4.541 3.844 7.5 3.844 2.96 0 5.452-1.454 7.5-3.844a16.652 16.652 0 001.812-2.562c.302-.528.486-.936.594-1.188a1.058 1.058 0 000-.812c-.108-.252-.292-.66-.594-1.188a16.652 16.652 0 00-1.812-2.562c-2.048-2.39-4.54-3.844-7.5-3.844zm0 4a4 4 0 110 8 4 4 0 010-8zm0 2a2 2 0 100 3.999 2 2 0 000-4z" }) });
});
on$1.displayName = "EyeIcon";
var rn = Ce__default__default.forwardRef((e3, o) => {
  let { opacity: t = 0.54, ...r3 } = e3;
  return jsx(g$3, { ref: o, ...r3, children: jsx("path", { fill: "currentcolor", fillOpacity: t, d: "M16.998 1.953a3 3 0 0 0-3 3c0 .257.04.577.102.815L8.747 9.504a3.25 3.25 0 0 0-1.75-.55 3 3 0 1 0 0 6c.633 0 1.257-.236 1.74-.569l5.365 3.766a3.2 3.2 0 0 0-.104.802 3 3 0 1 0 3-3c-.632 0-1.248.228-1.731.562l-5.378-3.763a3.2 3.2 0 0 0 .109-.799c0-.268-.038-.557-.104-.804l5.365-3.752c.479.323 1.118.556 1.739.556a3 3 0 1 0 0-6" }) });
});
rn.displayName = "ShareIcon";
var nn$1 = Ce__default__default.forwardRef((e3, o) => {
  let { opacity: t = 0.54, ...r3 } = e3;
  return jsx(g$3, { ref: o, ...r3, children: jsx("path", { fill: "currentcolor", fillOpacity: t, d: "M12.001 3.998c-2.959-.007-5.452 1.454-7.5 3.844a16.654 16.654 0 00-1.812 2.562c-.302.528-.486.936-.594 1.188a1.058 1.058 0 000 .812c.108.252.292.66.594 1.188.401.703.87 1.419 1.406 2.094.085.107.76.873 1.344 1.468l-1.157 1.125a1.03 1.03 0 000 1.438 1.03 1.03 0 001.438 0l14-14a1.03 1.03 0 000-1.438 1.014 1.014 0 00-.719-.281c-.256 0-.523.086-.719.28l-1.28 1.314c-1.654-1.106-3.298-1.59-5-1.594zm0 4c.518 0 1.31.137 2.031.562l-1.53 1.532c-.158-.082-.457-.094-.5-.094a2 2 0 00-2 2c0 .044-.015.347.03.53-.192.234-1.5 1.5-1.5 1.5a4.204 4.204 0 01-.53-2.03c-.012-2.21 1.79-4 4-4zm7.938.344s-9.755 9.718-11.063 11.03c1.44.572 2.918.626 3.125.626 2.96 0 5.452-1.454 7.5-3.844a16.652 16.652 0 001.812-2.562c.302-.528.486-.936.594-1.188a1.04 1.04 0 000-.812c-.227-.52-.654-1.347-1.312-2.313-.177-.26-.656-.937-.656-.937z" }) });
});
nn$1.displayName = "EyeCloseIcon";
var ln$2 = Ce__default__default.forwardRef((e3, o) => {
  let { opacity: t = 0.54, ...r3 } = e3;
  return jsx(g$3, { ref: o, ...r3, children: jsx("path", { fill: "currentcolor", fillOpacity: t, d: "M12.007 2.99a9 9 0 0 0-5.594 1.94 1 1 0 1 0 1.25 1.562 6.97 6.97 0 0 1 4.344-1.5 7 7 0 0 1 7 7h-2l3 4 3-4h-2a9 9 0 0 0-9-9m-8 5-3 4h2a9 9 0 0 0 9 9 9 9 0 0 0 5.594-1.937 1 1 0 1 0-1.25-1.562 6.96 6.96 0 0 1-4.344 1.5 7 7 0 0 1-7-7h2z" }) });
});
ln$2.displayName = "RefreshIcon";
var yr$2 = b$2({ slots: { root: "oui-relative oui-flex oui-shrink-0 oui-overflow-hidden oui-rounded-full", image: "oui-aspect-square oui-h-full oui-w-full", fallback: "oui-flex oui-h-full oui-w-full oui-items-center oui-justify-center oui-rounded-full oui-bg-base-2" }, variants: { size: { "2xs": { root: "oui-w-4 oui-h-4" }, xs: { root: "oui-w-5 oui-h-5" }, sm: { root: "oui-w-6 oui-h-6" }, md: { root: "oui-w-8 oui-h-8" }, lg: { root: "oui-w-10 oui-h-10" }, xl: { root: "oui-w-12 oui-h-12" } } }, defaultVariants: { size: "sm" } }), Pr$2 = Ce__default.forwardRef(({ className: e3, size: o, ...t }, r3) => {
  let { root: i } = yr$2({ size: o });
  return jsx(le$8.Root, { ref: r3, ...t, className: i({ className: e3 }) });
});
Pr$2.displayName = le$8.Root.displayName;
var Cr$1 = Ce__default.forwardRef(({ className: e3, ...o }, t) => {
  let { image: r3 } = yr$2();
  return jsx(le$8.Image, { ref: t, className: r3({ className: e3 }), ...o });
});
Cr$1.displayName = le$8.Image.displayName;
var Sr = Ce__default.forwardRef(({ className: e3, ...o }, t) => {
  let { fallback: r3 } = yr$2({ className: e3 });
  return jsx(le$8.Fallback, { ref: t, className: r3(), ...o });
});
Sr.displayName = le$8.Fallback.displayName;
var ue$8 = Ce__default.forwardRef((e3, o) => {
  let { size: t, src: r3, fallback: i, delayMs: n4, alt: a2, onLoadingStatusChange: s, ...l2 } = e3;
  return jsxs(Pr$2, { ...l2, ref: o, size: t, children: [jsx(Cr$1, { src: r3, onLoadingStatusChange: s, alt: a2 }), typeof i < "u" && jsx(Sr, { delayMs: n4, children: i })] });
}), un$1 = Ce__default.forwardRef((e3, o) => {
  let { address: t, ...r3 } = e3, i = useMemo(() => Sc(t), [e3.address]);
  return jsx(ue$8, { ...r3, src: i });
});
var Pe$5 = (e3) => {
  let o = useMemo(() => {
    var _a2;
    let t = e3.name;
    return typeof e3.symbol == "string" && (t = ((_a2 = e3.symbol) == null ? void 0 : _a2.split("_"))[1]), `https://oss.orderly.network/static/symbol_logo/${t}.png`;
  }, [e3.name, e3.symbol]);
  return jsx(ue$8, { size: e3.size, src: o, alt: e3.name, className: e3.className });
};
var kr$2 = (e3) => {
  let o = useMemo(() => `https://oss.orderly.network/static/network_logo/${e3.chainId}.png`, [e3.chainId]);
  return jsx(ue$8, { size: e3.size, src: o, alt: `${e3.chainId}`, className: e3.className });
};
var Mc = (e3) => {
  let o = useMemo(() => {
    var _a2, _b2, _c2;
    return `https://oss.orderly.network/static/wallet_icon/${(_c2 = (_b2 = (_a2 = e3.name) == null ? void 0 : _a2.split(" ")) == null ? void 0 : _b2[0]) == null ? void 0 : _c2.toLowerCase()}.png`;
  }, [e3.name]);
  return jsx(ue$8, { size: e3.size, src: o, alt: `${e3.name}` });
};
var je$5 = Ce__default__default.forwardRef((e3, o) => jsx(C$1, { d: "M8.006 2.014a1 1 0 0 0-1 1 4 4 0 0 0-4 4v10a4 4 0 0 0 4 4h10a4 4 0 0 0 4-4v-10c0-2.205-1.792-4-4-4a1 1 0 0 0-2 0h-6a1 1 0 0 0-1-1Zm-1 3a1 1 0 0 0 2 0h6a1 1 0 0 0 2 0 2 2 0 0 1 2 2v1h-14v-1a2 2 0 0 1 2-2Zm-2 5h14v7a2 2 0 0 1-2 2h-10a2 2 0 0 1-2-2v-7Zm3 2a1 1 0 1 0 0 2 1 1 0 0 0 0-2Zm4 0a1 1 0 1 0 0 2 1 1 0 0 0 0-2Zm4 0a1 1 0 1 0 0 2 1 1 0 0 0 0-2Zm-8 3a1 1 0 1 0 0 2 1 1 0 0 0 0-2Zm4 0a1 1 0 1 0 0 2 1 1 0 0 0 0-2Zm4 0a1 1 0 1 0 0 2 1 1 0 0 0 0-2Z", ref: o, ...e3 }));
je$5.displayName = "CaretLeftIcon";
var cn = Ce__default__default.forwardRef((e3, o) => jsx(C$1, { d: "M11.998 1.953c-4.362 0-8 1.56-8 4s3.638 4 8 4 8-1.559 8-4-3.638-4-8-4m-8 7.625v2.375c0 2.441 3.638 4 8 4s8-1.559 8-4V9.578c-1.814 1.49-4.642 2.375-8 2.375s-6.186-.885-8-2.375m0 6v2.375c0 2.441 3.638 4 8 4s8-1.559 8-4v-2.375c-1.814 1.49-4.642 2.375-8 2.375s-6.186-.885-8-2.375", ref: o, ...e3 }));
cn.displayName = "ServerFillIcon";
var dn = Ce__default__default.forwardRef((e3, o) => {
  let { opacity: t = 0.54, ...r3 } = e3;
  return jsxs(g$3, { ref: o, ...r3, children: [jsx("path", { d: "M12 2.5c-.3 0-.611.112-.81.325l-5.99 6.4c-.495.527-.013 1.275.81 1.275h11.98c.823 0 1.305-.748.81-1.275l-5.99-6.4c-.198-.213-.51-.325-.81-.325", fill: "currentcolor", fillOpacity: ".98" }), jsx("path", { d: "M12 21.5c-.3 0-.611-.112-.81-.325l-5.99-6.4c-.495-.527-.013-1.275.81-1.275h11.98c.823 0 1.305.748.81 1.275l-5.99 6.4c-.198.213-.51.325-.81.325", fill: "currentcolor", fillOpacity: ".36" })] });
});
dn.displayName = "SortingAscIcon";
var gn$1 = Ce__default__default.forwardRef((e3, o) => {
  let { opacity: t = 0.54, ...r3 } = e3;
  return jsxs(g$3, { ref: o, ...r3, children: [jsx("path", { d: "M12 2.5c-.3 0-.611.112-.81.325l-5.99 6.4c-.495.527-.013 1.275.81 1.275h11.98c.823 0 1.305-.748.81-1.275l-5.99-6.4c-.198-.213-.51-.325-.81-.325", fill: "currentcolor", fillOpacity: ".36" }), jsx("path", { d: "M12 21.5c-.3 0-.611-.112-.81-.325l-5.99-6.4c-.495-.527-.013-1.275.81-1.275h11.98c.823 0 1.305.748.81 1.275l-5.99 6.4c-.198.213-.51.325-.81.325", fill: "currentcolor", fillOpacity: ".98" })] });
});
gn$1.displayName = "SortingDescIcon";
var fn$1 = Ce__default__default.forwardRef((e3, o) => jsx(C$1, { d: "M11.993 18.012a1 1 0 0 1-.999-.999V9.458l-2.997 2.966-1.405-1.405 4.683-4.714a1 1 0 0 1 .72-.293c.26 0 .521.098.716.293l4.683 4.714-1.405 1.405-2.997-2.966v7.555a1 1 0 0 1-.999.999", ref: o, ...e3 })), xn$2 = Ce__default__default.forwardRef((e3, o) => jsx(C$1, { d: "M11.993 6.012a1 1 0 0 0-1 .999v7.555L7.998 11.6l-1.405 1.405 4.683 4.714c.195.196.457.293.719.293.26 0 .522-.098.717-.293l4.683-4.714L15.99 11.6l-2.997 2.966V7.011a1 1 0 0 0-1-.999", ref: o, ...e3 })), bn$1 = Ce__default__default.forwardRef((e3, o) => jsx(C$1, { d: "M18.012 11.993a1 1 0 0 0-.999-1H9.458l2.966-2.996-1.405-1.405-4.714 4.683a1 1 0 0 0-.293.719c0 .26.098.522.293.717l4.714 4.683 1.405-1.405-2.966-2.997h7.555a1 1 0 0 0 .999-1", ref: o, ...e3 })), hn$2 = Ce__default__default.forwardRef((e3, o) => jsx(C$1, { d: "M6.012 11.993a1 1 0 0 1 .999-1h7.555L11.6 7.998l1.405-1.405 4.714 4.683c.196.195.293.457.293.719 0 .26-.098.522-.293.717l-4.714 4.683L11.6 15.99l2.966-2.997H7.011a1 1 0 0 1-.999-1", ref: o, ...e3 }));
fn$1.displayName = "ArrowUpShortIcon";
xn$2.displayName = "ArrowDownShortIcon";
bn$1.displayName = "ArrowLeftShortIcon";
hn$2.displayName = "ArrowRightShortIcon";
var vn$1 = Ce__default__default.forwardRef((e3, o) => {
  let { opacity: t = 0.54, ...r3 } = e3;
  return jsx(g$3, { ref: o, ...r3, children: jsx("path", { fill: "currentcolor", fillOpacity: t, d: "M12 2.5c-.3 0-.611.112-.81.325l-5.99 6.4c-.495.527-.013 1.275.81 1.275h11.98c.823 0 1.305-.748.81-1.275l-5.99-6.4c-.198-.213-.51-.325-.81-.325m0 19c-.3 0-.611-.112-.81-.325l-5.99-6.4c-.495-.527-.013-1.275.81-1.275h11.98c.823 0 1.305.748.81 1.275l-5.99 6.4c-.198.213-.51.325-.81.325" }) });
});
vn$1.displayName = "SortingIconIcon";
var yn$1 = (e3) => {
  let { secondary: o } = e3, t = useMemo(() => {
    let r3 = "oui-bg-base-6 oui-absolute oui-bottom-0 oui-right-0 oui-outline oui-outline-2 oui-outline-base-1 oui-z-10";
    return o.component ? jsx("div", { className: cnBase(r3, o == null ? void 0 : o.className), children: o.component }) : "chainId" in o ? jsx(kr$2, { ...o, className: cnBase(r3, o == null ? void 0 : o.className) }) : jsx(Pe$5, { ...o, className: cnBase(r3, o == null ? void 0 : o.className) });
  }, [o]);
  return jsxs("div", { className: "oui-relative", children: [e3.children, t] });
};
var Xc = g$3;
Xc.combine = yn$1;
var Pn = (e3) => ["date", "address", "symbol", "status", "txId"].includes(e3), Zc = "base-quote", qc = "yyyy-MM-dd HH:mm:ss", wo$4 = Ce__default__default.forwardRef((e3, o) => {
  let { rule: t, children: r3, prefix: i, symbolElement: n4, formatString: a2, range: s, capitalize: l2, copyable: u2, copyIconSize: p2, onCopy: d2, showIcon: m2, iconSize: c2 = "xs", copyIconTestid: x2, isIcon: y2, ...S2 } = e3, f2 = useMemo(() => t === "symbol" && m2 ? jsx(Pe$5, { symbol: r3, size: c2 }) : i, [i, m2, t, c2, r3]), R2 = useMemo(() => {
    if (typeof e3.suffix < "u") return e3.suffix;
    if (u2) return jsx("button", { className: "oui-cursor-pointer oui-text-sm", "data-testid": x2, onClick: (I2) => {
      navigator.clipboard.writeText(r3), d2 == null ? void 0 : d2(I2);
    }, children: jsx(at$3, { size: p2 ?? 12, color: "white" }) });
  }, [e3.suffix, u2, r3]), k2 = useMemo(() => {
    if (typeof r3 > "u") return "--";
    if (typeof t > "u") return r3;
    if (t === "address" || t === "txId") {
      let I2 = r3, [v2, N2] = s ?? (t === "address" ? [6, 4] : [6, 6]), W2 = new RegExp(`^(.{${v2}})(.*)(.{${N2}})$`);
      return `${I2.replace(W2, "$1...$3")}`;
    }
    if (t === "date") {
      let I2 = new Date(r3);
      return isValid(I2) ? format(new Date(r3), a2 ?? qc) : "Error: Invalid Date";
    }
    if (t === "symbol") {
      let I2 = r3.split("_"), v2 = I2[0], N2 = I2[1], W2 = I2[2];
      return (a2 ?? Zc).replace("type", v2).replace("base", N2).replace("quote", W2);
    }
    return r3;
  }, [r3, t, a2, s, n4]), w5 = useMemo(() => typeof R2 > "u" && typeof f2 > "u" ? k2 : jsxs("span", { className: "oui-flex oui-gap-1 oui-items-center", children: [f2, k2, R2] }), [k2, R2, f2]);
  return jsx(K$3, { ...S2, ref: o, children: w5 });
});
wo$4.displayName = "FormattedText";
var Cn$3 = b$2({ base: "oui-text-transparent oui-bg-clip-text", variants: { color: { primary: "oui-gradient-primary", brand: "oui-gradient-brand", success: "oui-gradient-success", warning: "oui-gradient-warning", danger: "oui-gradient-danger", neutral: "oui-gradient-neutral", inherit: "oui-text-inherit" } } }), Tr$2 = Ce__default__default.forwardRef((e3, o) => {
  let { color: t, className: r3, angle: i, ...n4 } = e3, a2 = Jo$1({ angle: i });
  return jsx(K$3, { ...n4, ref: o, className: Cn$3({ color: t, className: r3 }), style: a2 });
});
Tr$2.displayName = "GradientText";
var $$4 = K$3;
$$4.formatted = wo$4;
$$4.numeral = He$5;
$$4.gradient = Tr$2;
var Dr$2 = forwardRef((e3, o) => {
  let { clearable: t, onClean: r3, fixClassName: i, helpText: n4, loading: a2, inputMode: s, containerClassName: l2, onValueChange: u2, onChange: p2, id: d2, formatters: m2, value: c2, ...x2 } = e3, [y2, S2] = useState(null), f2 = useRef(null), R2 = useRef(null), k2 = useRef(false), w5 = useMemo(() => m2 ?? [], [m2]);
  useEffect(() => {
    o && (typeof o == "function" ? o(f2.current) : o.current = f2.current);
  }, [f2, o]);
  let I2 = useCallback((h2) => {
    if (!Array.isArray(w5) || w5.length === 0) return h2;
    if (h2 == null) return "";
    let D2 = 0;
    for (; D2 < w5.length; ) h2 = w5[D2].onRenderBefore(h2, { isFocused: k2.current }), D2++;
    return h2;
  }, [w5]), v2 = useCallback((h2, D2) => {
    if (!Array.isArray(w5) || w5.length === 0) return h2;
    if (h2 == null) return "";
    let L2 = w5.length - 1;
    for (; L2 > -1; ) h2 = w5[L2].onSendBefore(h2, { isFocused: k2.current, originValue: D2 }), L2--;
    return h2;
  }, [w5]), N2 = useMemo(() => typeof c2 > "u" ? c2 : I2(c2), [c2]);
  return useEffect(() => {
    var _a2, _b2;
    if (document.activeElement !== f2.current) return;
    let h2 = `${N2}`.length, D2 = ((_a2 = R2.current) == null ? void 0 : _a2.length) || 0, L2 = y2 ? y2 + (h2 - D2) : 0;
    (_b2 = f2.current) == null ? void 0 : _b2.setSelectionRange(L2, L2);
  }, [N2]), jsx("input", { type: "text", ...x2, ref: f2, onBlur: (h2) => {
    var _a2;
    k2.current = false, (_a2 = x2.onBlur) == null ? void 0 : _a2.call(x2, h2);
  }, onFocus: (h2) => {
    var _a2;
    k2.current = true, (_a2 = x2.onFocus) == null ? void 0 : _a2.call(x2, h2);
  }, onChange: (h2) => {
    var _a2;
    if (h2.target.value.length < ((_a2 = e3.value) == null ? void 0 : _a2.length)) {
      let D2 = h2.target.selectionStart, L2 = Y$4(`${e3.value}`, h2.target.value);
      L2 > -1 && `${e3.value}`.at(L2) === "," && (h2.target.value = `${h2.target.value.substring(0, L2 - 1)}${h2.target.value.substring(L2)}`, h2.target.selectionStart = D2 ? D2 - 1 : 0);
    }
    if (typeof p2 == "function" && p2(h2), typeof u2 == "function") {
      let D2 = h2.target.value;
      D2 = v2(D2, String(e3.value)), u2(D2);
    }
    R2.current = h2.target.value, S2(h2.target.selectionStart);
  }, value: N2, id: d2 });
});
Dr$2.displayName = "BaseInput";
var Ue$5 = (e3) => {
  let { asChild: o, as: t = "label" } = e3;
  return jsx(o ? Slot : "label", { htmlFor: e3.name, className: e3.className, children: e3.children });
};
var Nn$1 = (e3) => {
  let { prefix: o, id: t } = e3;
  return typeof o > "u" ? null : typeof o == "string" ? jsx(Ue$5, { name: t, className: e3.className, children: o }) : o;
};
var Tn = (e3) => {
  let { suffix: o, id: t } = e3;
  return typeof o > "u" ? null : typeof o == "string" ? jsx(Ue$5, { name: t, className: e3.className, children: o }) : o;
};
var Dn = b$2({ slots: { input: ["oui-w-full oui-bg-transparent", "oui-bg-transparent", "oui-flex-1", "focus-visible:oui-outline-none", "oui-flex", "placeholder:oui-text-base-contrast-20", "placeholder:oui-text-xs", "oui-tabular-nums", "oui-text-white", "autofill:oui-bg-transparent", "oui-input-input", "disabled:oui-cursor-not-allowed", "oui-peer"], box: ["oui-rounded", "oui-bg-base-6", "oui-flex", "oui-items-center", "oui-outline", "oui-outline-offset-0", "oui-outline-1", "oui-outline-transparent", "focus-within:oui-outline-primary-light", "oui-input-root"], additional: ["oui-h-full oui-flex oui-flex-col oui-justify-center oui-px-2 oui-text-base-contrast"], closeButton: ["oui-cursor-pointer", "oui-invisible", "peer-focus:oui-visible"] }, variants: { size: { xs: { input: ["oui-h-6", "oui-text-2xs", "placeholder:oui-text-2xs"], box: ["oui-h-6"], additional: ["oui-text-2xs"] }, sm: { input: ["oui-h-7", "oui-text-2xs", "placeholder:oui-text-2xs"], box: ["oui-h-7"], additional: ["oui-text-2xs"] }, md: { input: ["oui-h-8", "oui-text-2xs", "placeholder:oui-text-2xs"], box: ["oui-h-8"], additional: ["oui-text-2xs"] }, lg: { input: ["oui-h-10", "oui-text-sm", "placeholder:oui-text-sm"], box: ["oui-h-10 oui-rounded-md"], additional: ["oui-text-sm"] }, xl: { input: ["oui-h-12", "oui-text-base", "placeholder:oui-text-base"], box: ["oui-h-12 oui-rounded-md"], additional: ["oui-text-sm"] } }, color: { success: { box: ["oui-outline-success", "focus-within:oui-outline-success"], input: ["oui-text-success"] }, danger: { box: ["oui-outline-danger", "focus-within:oui-outline-danger"], input: ["oui-text-danger"] }, warning: { box: ["oui-outline-warning-darken", "focus-within:oui-outline-warning-darken"], input: ["oui-text-warning-darken"] }, default: { box: ["oui-outline-transparent"] } }, disabled: { true: { input: ["oui-cursor-not-allowed", "oui-text-base-contrast-20"], box: ["oui-bg-base-5"] } }, pl: { true: { box: "oui-pl-3" }, false: { box: "oui-pl-0" } }, pr: { true: { box: "oui-pr-3" }, false: { box: "oui-pr-0" } }, fullWidth: { true: { box: "oui-w-full" } }, align: { center: { input: "oui-text-center" }, left: { input: "oui-text-left" }, right: { input: "oui-text-right" } } }, defaultVariants: { size: "lg" } }, { responsiveVariants: ["md", "lg"] }), ce$8 = Ce__default__default.forwardRef((e3, o) => {
  let { size: t, disabled: r3, color: i, suffix: n4, prefix: a2, id: s, pl: l2, pr: u2, fullWidth: p2, className: d2, classNames: m2, onClear: c2, align: x2, ...y2 } = e3, { input: S2, box: f2, additional: R2, closeButton: k2 } = Dn({ size: t, disabled: r3, color: i, fullWidth: p2, align: x2, pl: typeof a2 > "u" || l2, pr: typeof n4 > "u" || u2 }), w5 = useId(), I2 = typeof c2 < "u" ? jsx(zn$1, { className: k2({ className: m2 == null ? void 0 : m2.clearButton }), onClick: () => {
    c2 == null ? void 0 : c2();
  }, value: y2.value }) : n4;
  return jsxs("div", { className: f2({ className: cnBase(d2, m2 == null ? void 0 : m2.root) }), children: [jsx(Nn$1, { id: s || w5, prefix: a2, className: R2({ className: cnBase(m2 == null ? void 0 : m2.additional, m2 == null ? void 0 : m2.prefix) }) }), jsx(Dr$2, { ...y2, id: s || w5, disabled: r3, ref: o, className: S2({ align: x2, className: m2 == null ? void 0 : m2.input }) }), jsx(Tn, { id: s || w5, suffix: I2, className: R2({ className: cnBase(m2 == null ? void 0 : m2.additional, m2 == null ? void 0 : m2.suffix) }) })] });
}), zn$1 = Ce__default__default.forwardRef((e3, o) => jsx("button", { onMouseDown: (t) => {
  t.preventDefault(), e3.onClick();
}, ref: o, className: e3.className, children: jsx("svg", { width: "16", height: "16", viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: jsx("path", { d: "M8 1.302a6.667 6.667 0 1 0 0 13.333A6.667 6.667 0 0 0 8 1.302m-2 4c.17 0 .349.057.479.187l1.52 1.521L9.52 5.49a.68.68 0 0 1 .48-.188c.17 0 .348.057.479.187.26.261.26.698 0 .96l-1.52 1.52 1.52 1.52c.26.261.26.698 0 .96a.687.687 0 0 1-.959 0L8 8.926l-1.521 1.521a.686.686 0 0 1-.959 0 .686.686 0 0 1 0-.959l1.521-1.52-1.52-1.52a.686.686 0 0 1 0-.96A.68.68 0 0 1 6 5.302", fill: "#fff", fillOpacity: ".2" }) }) }));
zn$1.displayName = "ClearButton";
ce$8.displayName = "Input";
var cp = b$2({ base: ["oui-z-50", "oui-w-72", "oui-rounded-md", "oui-border", "oui-border-line-6", "oui-p-4", "oui-bg-base-8", "oui-shadow-md", "oui-outline-none", "data-[state=open]:oui-animate-in", "data-[state=closed]:oui-animate-out", "data-[state=closed]:oui-fade-out-0", "data-[state=open]:oui-fade-in-0", "data-[state=closed]:oui-zoom-out-95", "data-[state=open]:oui-zoom-in-95", "data-[side=bottom]:oui-slide-in-from-top-2", "data-[side=left]:oui-slide-in-from-right-2", "data-[side=right]:oui-slide-in-from-left-2", "data-[side=top]:oui-slide-in-from-bottom-2"] }), gt$2 = j$4.Root, En$2 = j$4.Trigger, Mr = j$4.Anchor, vo$6 = Ce__default.forwardRef(({ className: e3, align: o = "center", sideOffset: t = 4, ...r3 }, i) => jsx(j$4.Portal, { children: jsx(j$4.Content, { ref: i, align: o, sideOffset: t, className: cp({ className: e3 }), ...r3 }) }));
vo$6.displayName = j$4.Content.displayName;
var yo$3 = (e3) => {
  let { arrow: o, content: t, contentProps: r3, ...i } = e3;
  return jsxs(gt$2, { ...i, children: [jsx(En$2, { asChild: true, children: e3.children }), jsxs(vo$6, { ...r3, children: [t, o && jsx(j$4.Arrow, { className: "oui-fill-base-8", width: 10, height: 6 })] })] });
};
var H = b$2({ slots: { trigger: ["oui-flex", "oui-group", "oui-w-full", "oui-items-center", "oui-justify-between", "oui-whitespace-nowrap", "oui-rounded-md", "oui-px-2", "oui-space-x-2", "oui-shadow-sm", "oui-text-base-contrast-54", "placeholder:oui-text-base-contrast-54", "data-[state=open]:oui-text-base-contrast-80", "focus:oui-outline-none", "focus:oui-ring-1", "focus:oui-ring-ring", "disabled:oui-cursor-not-allowed", "disabled:oui-opacity-50", "[&>span]:oui-line-clamp-1"], scrollUpButton: "oui-flex oui-cursor-default oui-items-center oui-justify-center oui-py-1", scrollDownButton: "oui-flex oui-cursor-default oui-items-center oui-justify-center oui-py-1", content: ["oui-relative", "oui-z-50", "oui-max-h-96", "oui-overflow-hidden", "oui-rounded-md", "oui-bg-base-8", "oui-text-base-contrast", "oui-shadow-md", "data-[state=open]:oui-animate-in", "data-[state=closed]:aoui-nimate-out", "data-[state=closed]:oui-fade-out-0", "data-[state=open]:oui-fade-in-0", "data-[state=closed]:oui-zoom-out-95", "data-[state=open]:oui-zoom-in-95", "data-[side=bottom]:oui-slide-in-from-top-2", "data-[side=left]:oui-slide-in-from-right-2", "data-[side=right]:oui-slide-in-from-left-2", "data-[side=top]:oui-slide-in-from-bottom-2"], viewport: ["oui-p-1"], label: "oui-px-2 oui-py-1.5 oui-text-sm oui-font-semibold", item: ["oui-option-item", "oui-relative", "oui-flex", "oui-cursor-default", "oui-select-none", "oui-items-center", "oui-rounded-sm", "oui-py-1", "oui-pl-2", "oui-pr-8", "oui-text-sm", "oui-text-base-contrast-54", "oui-outline-none", "hover:oui-bg-base-6", "hover:oui-rounded", "focus:oui-bg-accent", "focus:oui-text-accent-foreground", "data-[state=checked]:oui-bg-base-5", "data-[state=checked]:oui-text-base-contrast-80", "data-[disabled]:oui-pointer-events-none", "data-[disabled]:oui-opacity-50"], separator: "-oui-mx-1 oui-my-1 oui-h-px oui-bg-muted", icon: "" }, variants: { variant: { outlined: { trigger: ["oui-border oui-border-line-6 oui-bg-line-4"] }, contained: { trigger: ["oui-bg-base-4"] }, text: { trigger: [] } }, position: { popper: { content: ["data-[side=bottom]:oui-translate-y-1", "data-[side=left]:-oui-translate-x-1", "data-[side=right]:oui-translate-x-1", "data-[side=top]:-oui-translate-y-1"], viewport: "oui-h-[var(--radix-select-trigger-height)] oui-w-full oui-min-w-[var(--radix-select-trigger-width)]" }, "item-aligned": { content: "", viewport: "" } }, size: { xs: { trigger: ["oui-h-6", "oui-text-2xs"], item: ["oui-h-6", "oui-text-2xs"], icon: ["oui-w-3", "oui-h-3"] }, sm: { trigger: ["oui-h-7", "oui-text-2xs"], item: ["oui-h-7", "oui-text-2xs"], icon: ["oui-w-4", "oui-h-4"] }, md: { trigger: ["oui-h-8", "oui-text-xs"], item: ["oui-h-7", "oui-text-xs"], icon: ["oui-w-4", "oui-h-4"] }, lg: { trigger: ["oui-h-10", "oui-text-sm", "oui-px-3"], item: ["oui-h-8", "oui-text-2xs"], icon: ["oui-w-5", "oui-h-5"] }, xl: { trigger: ["oui-h-12", "oui-text-2xs", "oui-px-3"], item: ["oui-h-12", "oui-text-2xs"], icon: ["oui-w-6", "oui-h-6"] } }, error: { true: { trigger: ["oui-border-danger", "focus:oui-ring-danger", "focus:oui-ring-ring-danger"] } } }, defaultVariants: { size: "lg", variant: "outlined" } }, { responsiveVariants: ["md", "lg"] }), Br = P$4.Root, Er = P$4.Group, Fr$1 = P$4.Value, ft$3 = Ce__default.forwardRef(({ className: e3, children: o, size: t, error: r3, variant: i, asChild: n4, showCaret: a2 = true, ...s }, l2) => {
  let { trigger: u2 } = H({ size: t, error: r3, variant: i });
  return n4 ? jsx(P$4.Trigger, { ref: l2, className: u2({ className: e3 }), asChild: n4, ...s, children: o }) : jsxs(P$4.Trigger, { ref: l2, className: u2({ className: e3 }), asChild: n4, ...s, children: [o, jsx(Fragment$1, { children: a2 && jsx(P$4.Icon, { asChild: true, className: "oui-transition-transform group-data-[state=open]:oui-rotate-180 group-data-[state=closed]:oui-rotate-0", children: jsx(Q$4, { size: 12, className: "oui-text-inherit", opacity: 1 }) }) })] });
});
ft$3.displayName = P$4.Trigger.displayName;
var Fn$1 = Ce__default.forwardRef(({ className: e3, ...o }, t) => {
  let { scrollUpButton: r3 } = H();
  return jsx(P$4.ScrollUpButton, { ref: t, className: r3({ className: e3 }), ...o, children: jsx(lt$5, { size: 16, color: "white" }) });
});
Fn$1.displayName = P$4.ScrollUpButton.displayName;
var Vn$1 = Ce__default.forwardRef(({ className: e3, ...o }, t) => {
  let { scrollDownButton: r3 } = H();
  return jsx(P$4.ScrollDownButton, { ref: t, className: r3({ className: e3 }), ...o, children: jsx(Q$4, { size: 16, color: "white" }) });
});
Vn$1.displayName = P$4.ScrollDownButton.displayName;
var xt$1 = Ce__default.forwardRef(({ className: e3, children: o, position: t = "popper", ...r3 }, i) => {
  let { content: n4, viewport: a2 } = H({ position: t, className: e3 });
  return jsx(P$4.Portal, { children: jsx(P$4.Content, { ref: i, className: n4({ className: e3 }), position: t, ...r3, children: jsx(P$4.Viewport, { className: a2(), children: o }) }) });
});
xt$1.displayName = P$4.Content.displayName;
var Ln = Ce__default.forwardRef(({ className: e3, ...o }, t) => {
  let { label: r3 } = H();
  return jsx(P$4.Label, { ref: t, className: r3({ className: e3 }), ...o });
});
Ln.displayName = P$4.Label.displayName;
var Po$3 = Ce__default.forwardRef(({ className: e3, children: o, size: t, ...r3 }, i) => {
  let { item: n4 } = H({ size: t });
  return jsx(P$4.Item, { ref: i, className: n4({ className: e3 }), ...r3, children: jsx(P$4.ItemText, { children: o }) });
});
Po$3.displayName = P$4.Item.displayName;
var An$1 = Ce__default.forwardRef(({ className: e3, ...o }, t) => {
  let { separator: r3 } = H();
  return jsx(P$4.Separator, { ref: t, className: r3({ className: e3 }), ...o });
});
An$1.displayName = P$4.Separator.displayName;
var Vr$2 = b$2({ slots: { root: "oui-relative oui-overflow-hidden oui-scroll-area-root", viewport: "oui-h-full oui-w-full oui-rounded-[inherit]", bar: ["oui-flex", "oui-touch-none", "oui-select-none", "oui-transition-colors"], tumb: "oui-relative oui-flex-1 oui-rounded-full oui-bg-base-10" }, variants: { orientation: { vertical: { bar: "oui-h-full oui-w-2 oui-border-l oui-border-l-transparent oui-p-[1px]" }, horizontal: { bar: "oui-h-2 oui-flex-col oui-border-t oui-border-t-transparent oui-p-[1px]" } } } }), $e$5 = Ce__default__default.forwardRef(({ className: e3, children: o, orientation: t = "vertical", ...r3 }, i) => {
  let { root: n4, viewport: a2, bar: s } = Vr$2({ orientation: t });
  return jsxs(Z$4.Root, { ref: i, className: n4({ className: e3 }), ...r3, children: [jsx(Z$4.Viewport, { className: a2(), children: o }), jsx(Lr$2, { orientation: t }), jsx(Z$4.Corner, {})] });
});
$e$5.displayName = Z$4.Root.displayName;
var Lr$2 = Ce__default__default.forwardRef(({ className: e3, orientation: o = "vertical", ...t }, r3) => {
  let { bar: i, tumb: n4 } = Vr$2({ className: e3, orientation: o });
  return jsx(Z$4.ScrollAreaScrollbar, { ref: r3, orientation: o, className: i({ className: e3 }), ...t, children: jsx(Z$4.ScrollAreaThumb, { className: n4() }) });
});
Lr$2.displayName = Z$4.ScrollAreaScrollbar.displayName;
var ht$2 = (e3) => {
  let { options: o, variant: t, valueFormatter: r3, ...i } = e3, [n4, a2] = useState(""), [s, l2] = useState(e3.value ?? ""), { trigger: u2 } = H({ size: e3.size, variant: t }), [p2, d2] = useState(() => typeof e3.value > "u" ? -1 : o.findIndex((f2) => f2.value === e3.value)), [m2, c2] = useState(false), x2 = useRef(null), y2 = () => {
    c2(true);
  }, S2 = n4 ? o.filter((f2) => {
    if (f2.value.toLowerCase().includes(n4.toLowerCase())) return true;
  }) : o;
  return jsxs(gt$2, { open: m2, children: [jsx(Mr, { children: jsx(So$4, { ref: x2, size: e3.size, autoComplete: "off", onFocus: y2, onBlur: () => {
    c2(false);
  }, placeholder: e3.placeholder ?? "All", value: m2 ? n4 : typeof r3 == "function" ? r3(s ?? "", { placeholder: e3.placeholder }) : s, onValueChange: (f2) => {
    a2(f2);
  }, classNames: { root: u2({ className: "oui-w-24 oui-peer" }), input: "oui-text-base-contrast-54 oui-font-semibold" }, "data-state": m2 ? "open" : "closed", suffix: jsx(P$4.Icon, { onMouseDown: (f2) => {
    var _a2, _b2;
    f2.preventDefault(), m2 ? (_a2 = x2.current) == null ? void 0 : _a2.blur() : (_b2 = x2.current) == null ? void 0 : _b2.focus();
  }, asChild: true, className: "oui-transition-transform peer-data-[state=open]:oui-rotate-180 peer-data-[state=closed]:oui-rotate-0 oui-mx-2", children: jsx(Q$4, { size: 12, className: "oui-text-inherit" }) }) }) }), jsx(vo$6, { onOpenAutoFocus: (f2) => {
    f2.preventDefault(), a2("");
  }, className: "oui-w-[var(_--radix-popover-trigger-width)] oui-p-1", children: jsx($e$5, { className: "oui-h-[200px]", children: S2.map((f2, R2) => jsx(fp, { option: f2, size: e3.size, activated: p2 === R2, onClick: (k2) => {
    var _a2, _b2;
    l2(k2.value), d2(R2), (_a2 = e3.onValueChange) == null ? void 0 : _a2.call(e3, k2.value), (_b2 = x2.current) == null ? void 0 : _b2.blur();
  } }, R2)) }) })] });
}, fp = (e3) => {
  let { item: o } = H({ size: e3.size });
  return jsx("button", { className: o({ className: `oui-text-base-contrast-54 oui-w-full ${e3.activated ? "oui-bg-base-7" : ""}` }), onMouseDown: (t) => {
    t.preventDefault(), e3.onClick(e3.option);
  }, children: e3.option.label });
};
var vt$3 = (e3) => {
  let { children: o, size: t, error: r3, placeholder: i, variant: n4, contentProps: a2, valueFormatter: s, showCaret: l2, maxHeight: u2, testid: p2, classNames: d2, ...m2 } = e3;
  return jsxs(Br, { ...m2, children: [jsx(ft$3, { size: t, error: r3, variant: n4, showCaret: l2, className: cnBase("oui-font-semibold focus:oui-ring-transparent oui-cursor-pointer", d2 == null ? void 0 : d2.trigger), "data-testid": p2, children: typeof s == "function" ? s(e3.value || e3.defaultValue, { placeholder: i }) : jsx(Fr$1, { placeholder: i }) }), jsx(xt$1, { ...a2, children: jsx($e$5, { children: jsxs("div", { style: { maxHeight: u2 }, children: [" ", o] }) }) })] });
};
var wp = (e3, o) => jsxs(Po$3, { value: e3.value, className: cnBase("oui-relative oui-cursor-pointer"), "data-testid": `oui-testid-selectItem-${e3.value.toLowerCase().replace(" ", "_")}`, children: [e3.label, o == e3.value && jsx(_$1, { width: 4, height: 4, gradient: "brand", r: "full", className: "oui-absolute oui-right-2 oui-top-1/2 -oui-translate-y-1/2" })] }, e3.value), Ze$3 = (e3) => {
  let { children: o, options: t, optionRenderer: r3 = wp, currentValue: i, ...n4 } = e3;
  return jsx(vt$3, { ...n4, children: jsx(Er, { children: t.map((a2, s) => Ce__default__default.cloneElement(r3(a2, i), { size: e3.size, key: s, index: s })) }) });
};
var Wn$1 = (e3) => {
  let { tokens: o, showIcon: t = true, ...r3 } = e3, { icon: i } = H(), n4 = useMemo(() => o.map((u2) => ({ ...u2, label: u2.name, value: u2.name })), [o]), a2 = n4.length > 1;
  return jsx(Ze$3, { ...r3, showCaret: a2, options: n4, valueFormatter: t ? (u2) => typeof e3.valueFormatter == "function" ? e3.valueFormatter(u2, {}) : jsxs(z$1, { gapX: 1, children: [jsx(Pe$5, { name: u2, className: i({ size: e3.size }) }), jsx($$4, { weight: "semibold", intensity: 54, children: u2 })] }) : void 0, optionRenderer: (u2) => typeof e3.optionRenderer == "function" ? e3.optionRenderer(u2) : jsx(kp, { ...u2 }), maxHeight: 254 });
}, kp = (e3) => {
  let { size: o, label: t, value: r3 } = e3, { item: i, icon: n4 } = H();
  return jsxs(SelectItem, { value: r3, className: i({ size: o, className: "oui-space-x-1 oui-flex oui-flex-row oui-items-center" }), children: [jsx(Pe$5, { name: r3, className: n4({ size: o }) }), jsx(SelectItemText, { children: t }), jsx(ItemIndicator, {})] });
};
var ke$2 = vt$3;
ke$2.options = Ze$3;
ke$2.combine = ht$2;
ke$2.tokens = Wn$1;
var _r$1 = forwardRef((e3, o) => {
  let { tokens: t, ...r3 } = e3, [i, n4] = useState(t[0]), a2 = useMemo(() => e3.tokens.map((l2) => ({ name: l2 })), [e3.tokens]), s = useRef(null);
  return jsx(ce$8, { ref: (l2) => {
    s.current = l2, o && (typeof o == "function" ? o(l2) : o.current = l2);
  }, autoComplete: "off", ...r3, suffix: jsx("div", { className: "oui-max-w-fit", children: jsx(ke$2.tokens, { disabled: r3.disabled, variant: "text", tokens: a2, value: i, size: r3.size, onValueChange: (l2) => n4(l2), showIcon: r3.align !== "right", contentProps: { align: "end", onCloseAutoFocus: (l2) => {
    var _a2;
    l2.preventDefault(), (_a2 = s.current) == null ? void 0 : _a2.focus();
  } } }) }) });
});
_r$1.displayName = "QuantityInput";
var zp = Y$5.Provider, Wr$2 = Y$5.Root, Gr$3 = Y$5.Trigger, yt$4 = Y$5.Portal, Mp = b$2({ base: ["oui-z-50", "oui-overflow-hidden", "oui-rounded-md", "oui-bg-base-8", "oui-px-2", "oui-py-1", "oui-text-xs", "oui-text-base-contrast", "oui-animate-in", "oui-fade-in-0", "oui-zoom-in-95", "data-[state=closed]:oui-animate-out", "data-[state=closed]:oui-fade-out-0", "data-[state=closed]:oui-zoom-out-95", "data-[side=bottom]:oui-slide-in-from-top-2", "data-[side=left]:oui-slide-in-from-right-2", "data-[side=right]:oui-slide-in-from-left-2", "data-[side=top]:oui-slide-in-from-bottom-2"] }), Ro$4 = Ce__default.forwardRef(({ className: e3, sideOffset: o = 4, ...t }, r3) => jsx(Y$5.Content, { ref: r3, sideOffset: o, className: Mp({ className: e3 }), ...t }));
Ro$4.displayName = Y$5.Content.displayName;
var Pt$3 = (e3) => {
  let { className: o, ...t } = e3;
  return jsx(Y$5.Arrow, { width: 12, height: 6, ...t, className: cn$3("oui-fill-base-8", o)({ twMerge: true }) });
}, Xn$2 = Ce__default.forwardRef(({ children: e3, content: o, defaultOpen: t, open: r3, onOpenChange: i, delayDuration: n4, disableHoverableContent: a2, arrow: s, ...l2 }, u2) => {
  let { className: p2, ...d2 } = s || {};
  return jsxs(Y$5.Root, { defaultOpen: t, open: r3, onOpenChange: i, delayDuration: n4, disableHoverableContent: a2, children: [jsx(Y$5.Trigger, { asChild: true, children: e3 }), jsx(yt$4, { children: jsxs(Ro$4, { ref: u2, ...l2, children: [o, jsx(Pt$3, { ...s })] }) })] });
});
Xn$2.displayName = "Tooltip";
var Yr$2 = forwardRef((e3, o) => {
  let { tooltip: t, tooltipProps: r3, triggerClassName: i, ...n4 } = e3, [a2, s] = useState(false);
  return useEffect(() => {
    s(typeof t < "u" && t !== "" && t !== null);
  }, [t]), jsxs(Wr$2, { open: a2, children: [jsx(Gr$3, { asChild: true, children: jsx("div", { className: i, children: jsx(ce$8, { ...n4, ref: o }) }) }), jsx(yt$4, { children: jsxs(Ro$4, { ...r3 == null ? void 0 : r3.content, children: [e3.tooltip, jsx(Pt$3, { ...r3 == null ? void 0 : r3.arrow })] }) })] });
});
Yr$2.displayName = "InputWithTooltip";
var Xr$1 = {};
lr$4(Xr$1, { createRegexInputFormatter: () => Zn, currencyFormatter: () => Un, decimalPointFormatter: () => Jn$3, dpFormatter: () => qn, identifierFormatter: () => Qn, numberFormatter: () => $n, rangeFormatter: () => Kn });
var Un = { onRenderBefore: function(e3, o) {
  return e3 == null ? "" : d$3(e3);
}, onSendBefore: function(e3, o) {
  return e3 == null ? "" : (e3 = e3.replace(/,/g, ""), e3);
} };
var $n = { onRenderBefore: function(e3, o) {
  return "" + e3;
}, onSendBefore: function(e3, o) {
  return e3.startsWith(".") ? `0${e3}` : e3 === "00" ? "0" : (e3 = e3.replace(/[^\d.]/g, "").replace(".", "$#$").replace(/\./g, "").replace("$#$", "."), e3);
} };
var Zn = (e3, o) => ({ onRenderBefore: (t, r3) => `${t}`.replace(e3, ""), onSendBefore: (t, r3) => (o == null ? void 0 : o(t, r3)) || t });
var qn = (e3, o) => {
  let t = (r3, i) => (typeof r3 == "number" && (r3 = r3.toString()), !r3 || r3.endsWith(".") ? r3 : Lp(r3, e3));
  return { onRenderBefore: t, onSendBefore: t };
};
function Lp(e3, o) {
  let t = e3.indexOf(".");
  if (t === -1 || o <= 0) return e3.split(".")[0];
  let r3 = t + o + 1;
  return e3.substring(0, r3);
}
var Kn = (e3) => {
  let o = (t, r3) => {
    if (typeof t == "number" && (t = t.toString()), !t || t.endsWith(".")) return t;
    let i = e3.max ?? Number(t), n4 = e3.min ?? Number(t), a2 = Number(t);
    return `${a2 < n4 ? n4 : a2 > i ? i : a2}`;
  };
  return { onRenderBefore: o, onSendBefore: o };
};
var Qn = () => {
  let e3 = "+", o = "-";
  return { onRenderBefore: (t, r3) => {
    if (typeof t == "number" && (t = t.toString()), !t || t.endsWith(".")) return t;
    let i = Number(t);
    if (i) {
      if (i > 0 && !t.startsWith(e3)) return e3 + t;
      if (i < 0 && !t.startsWith(o)) return o + t;
    }
    return t;
  }, onSendBefore: (t, r3) => {
    if (typeof t == "number" && (t = t.toString()), !t || t.endsWith(".")) return t;
    let i = Number(t);
    return i && i > 0 ? t.replace(e3, "") : t;
  } };
};
var Jn$3 = { onRenderBefore: function(e3, o) {
  return String(e3);
}, onSendBefore: function(e3, o) {
  return e3 == null ? "" : Op(e3, o == null ? void 0 : o.originValue);
} }, Op = (e3, o) => {
  if (e3 == null) return "";
  if (e3.endsWith(",")) return e3.slice(0, -1) + ".";
  if (e3.startsWith(",")) return e3.slice(0, 1) + ".";
  let t = d$3(o);
  return o && e3.length > t.length && e3.length - t.length === 1 ? _p(e3, t) : e3;
}, _p = (e3, o) => {
  if (e3.length <= o.length) return e3;
  for (let t = 0; t < o.length; t++) if (e3[t] !== o[t]) {
    let r3 = e3[t], i = r3 === "," ? "." : r3;
    return e3.slice(0, t) + i + e3.slice(t + 1);
  }
  return e3;
};
var Yp = tv({ base: ["oui-text-xs", "oui-text-base-contrast-36", "oui-mt-1", "oui-list-disc", "oui-list-inside", "oui-list-item"], variants: { color: { success: ["oui-text-success"], danger: ["oui-text-danger"], warning: ["oui-text-warning-darken"], default: ["oui-text-base-contrast-54"] } } }), Ct$4 = Ce__default__default.forwardRef((e3, o) => {
  let { className: t, asChild: r3, color: i, ...n4 } = e3;
  return jsx(r3 ? Slot : "div", { ref: o, className: Yp({ className: t, color: i }), ...n4 });
});
Ct$4.displayName = "InputHelpText";
var Up = b$2({ slots: { root: "oui-flex", label: "oui-text-sm oui-font-semibold", input: [] }, variants: { direction: { column: { root: "oui-flex-col oui-space-y-1" }, row: { root: "oui-flex-row oui-space-x-3 " } } }, defaultVariants: { direction: "column" } }), jr$2 = Ce__default__default.forwardRef((e3, o) => {
  var _a2;
  let { label: t, helpText: r3, direction: i, className: n4, ...a2 } = e3, { root: s, label: l2 } = Up({ direction: i });
  return jsxs("div", { className: s({ className: n4, direction: i }), children: [jsx(ts$1, { className: cnBase((_a2 = e3.classNames) == null ? void 0 : _a2.label) || l2(), children: t }), jsxs("div", { children: [jsx(ce$8, { ...a2 }), ((r3 == null ? void 0 : r3.length) || 0 > 0) && jsx(Ct$4, { color: a2.color, children: r3 })] })] });
});
jr$2.displayName = "TextField";
var ts$1 = Ce__default__default.forwardRef((e3, o) => {
  let { asChild: t = false, className: r3, ...i } = e3;
  return jsx(t ? Slot : "label", { className: r3, ref: o, ...i, children: e3.children });
});
ts$1.displayName = "InputLabel";
var So$4 = ce$8;
So$4.token = _r$1;
So$4.tooltip = Yr$2;
var Zp = tv({ base: ["peer", "oui-h-3", "oui-w-3", "oui-shrink-0", "oui-rounded-sm", "oui-border", "focus-visible:oui-outline-none", "disabled:oui-cursor-not-allowed", "disabled:oui-opacity-50"], variants: { color: { primary: "oui-border-primary data-[state=checked]:oui-text-base-contrast", white: "oui-border-base-contrast-54 " }, variant: { checkBox: "data-[state=checked]:oui-border-none", radio: "oui-rounded-full data-[state=checked]:oui-border-base-contrast-20 data-[state=checked]:oui-bg-transparent" } }, compoundVariants: [{ color: "primary", variant: "radio", className: "data-[state=checked]:oui-border-parimary data-[state=checked]:!oui-text-parimary" }], defaultVariants: { color: "white" } }), $r$1 = Ce__default.forwardRef(({ className: e3, color: o = "white", variant: t = "checkBox", ...r3 }, i) => jsx(To$2.Root, { ref: i, className: Zp({ color: o, className: e3, variant: t }), ...r3, children: jsx(To$2.Indicator, { className: cnBase("oui-flex oui-items-center oui-justify-center oui-text-current", r3.indicatorClassName), children: t === "checkBox" ? jsx(qp, { className: cnBase(o === "primary" ? "oui-text-primary" : "oui-text-white") }) : jsx("div", { className: cnBase("oui-w-[6px] oui-h-[6px] oui-rounded-full", o === "primary" ? "oui-bg-primary" : "oui-bg-base-contrast-80") }) }) }));
$r$1.displayName = To$2.Root.displayName;
var qp = (e3) => jsx("svg", { width: "12", height: "12", viewBox: "0 0 12 12", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...e3, children: jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M3.078.71A2.333 2.333 0 0 0 .745 3.041v5.834a2.333 2.333 0 0 0 2.333 2.333H8.91a2.333 2.333 0 0 0 2.334-2.333V3.042A2.333 2.333 0 0 0 8.91.71zm5.83 2.555a.7.7 0 0 1 .488-.182c.174 0 .355.056.488.182a.643.643 0 0 1 0 .93L5.129 8.728a.723.723 0 0 1-.975 0L2.115 6.785a.644.644 0 0 1 0-.93.724.724 0 0 1 .977 0l1.55 1.476z", fillOpacity: ".8" }) });
var Jp = tv({ slots: { root: ["peer", "oui-inline-flex", "oui-h-[16px]", "oui-w-[28px]", "oui-shrink-0", "oui-cursor-pointer", "oui-items-center", "oui-rounded-full", "oui-border-transparent", "oui-shadow-sm", "oui-transition-colors", "focus-visible:oui-outline-none", "focus-visible:oui-ring-2", "focus-visible:oui-ring-ring", "focus-visible:oui-ring-offset-2", "focus-visible:oui-ring-offset-background", "disabled:oui-cursor-not-allowed", "disabled:oui-opacity-50", "data-[state=checked]:oui-bg-primary-darken", "data-[state=unchecked]:oui-bg-input"], thumb: ["oui-pointer-events-none", "oui-block", "oui-h-[10px]", "oui-w-[10px]", "oui-rounded-full", "oui-bg-white/80", "oui-shadow-lg", "oui-ring-0", "oui-transition-transform", "data-[state=checked]:oui-translate-x-[15px]", "data-[state=unchecked]:oui-translate-x-[3px]"] }, variants: { color: { primary: { root: ["data-[state=checked]:oui-bg-primary-darken", "data-[state=unchecked]:oui-bg-base-1"] }, success: { root: ["data-[state=checked]:oui-bg-success", "data-[state=unchecked]:oui-bg-success"] }, danger: { root: ["data-[state=checked]:oui-bg-danger", "data-[state=unchecked]:oui-bg-danger"] }, warning: { root: ["data-[state=checked]:oui-bg-warning-darken", "data-[state=unchecked]:oui-bg-warning-darken"] } } }, defaultVariants: { color: "primary" } }), Zr$2 = Ce__default__default.forwardRef(({ className: e3, color: o, ...t }, r3) => {
  let { root: i, thumb: n4 } = Jp({ className: e3, color: o });
  return jsx(Io$4.Root, { className: i({ className: e3 }), ...t, ref: r3, children: jsx(Io$4.Thumb, { className: n4() }) });
});
Zr$2.displayName = Io$4.Root.displayName;
var ed = b$2({ base: "oui-inline-flex oui-items-center oui-rounded-md oui-font-semibold oui-transition-colors focus:oui-outline-none focus:oui-ring-2 focus:oui-ring-ring focus:oui-ring-offset-2", variants: { variant: { contained: "", text: "" }, color: { primary: "", primaryLight: "", secondary: "", danger: "", buy: "", success: "", warning: "", sell: "", neutral: "" }, size: { xs: "oui-px-2 oui-py-0.5 oui-text-2xs oui-rounded oui-h-[18px]", sm: "oui-px-2 oui-py-0.5 oui-text-2xs oui-rounded", md: "oui-px-2 oui-py-0.5 oui-text-sm", lg: "oui-px-2 oui-py-1 oui-text-base" } }, compoundVariants: [{ variant: "contained", color: "primary", className: ["oui-bg-primary/15", "oui-text-primary"] }, { variant: "contained", color: "primaryLight", className: ["oui-bg-primary-light/15", "oui-text-primary-light"] }, { variant: "contained", color: "danger", className: ["oui-bg-danger/15", "oui-text-danger"] }, { variant: "contained", color: "sell", className: ["oui-bg-danger/15", "oui-text-danger"] }, { variant: "contained", color: "success", className: ["oui-bg-success/15", "oui-text-success"] }, { variant: "contained", color: "buy", className: ["oui-bg-success/15", "oui-text-success"] }, { variant: "contained", color: "warning", className: ["oui-bg-warning-darken/15", "oui-text-warning-darken"] }, { variant: "contained", color: "neutral", className: ["oui-bg-line", "oui-text-base-contrast-36"] }, { variant: "text", color: "primary", className: ["oui-text-primary"] }, { variant: "text", color: "danger", className: ["oui-text-danger"] }, { variant: "text", color: "success", className: ["oui-text-success"] }, { variant: "text", color: "warning", className: ["oui-text-warning-darken"] }, { variant: "text", color: "neutral", className: ["oui-text-base-contrast-36"] }], defaultVariants: { variant: "contained", color: "primary", size: "md" } });
function od({ className: e3, variant: o, color: t, size: r3, ...i }) {
  return jsx("div", { className: ed({ variant: o, className: e3, color: t, size: r3 }), ...i });
}
var as$1 = Ce__default__default.forwardRef(({ src: e3, alt: o, href: t }, r3) => jsx("div", { className: "logo oui-px-3", ref: r3, children: jsx("a", { href: t ?? "/", children: jsx("img", { src: e3, alt: o, className: "oui-object-contain oui-h-8 oui-py-2" }) }) }));
as$1.displayName = "LogoElement";
var kt$3 = { columns: (e3) => {
  let o = createColumnHelper();
  return e3 == null ? void 0 : e3.map((t, r3) => {
    let i = { meta: t, size: t.width || 100 }, { dataIndex: n4, onSort: a2 } = t;
    return o.accessor(n4, { header: () => t.title, enableSorting: !!a2, sortingFn: typeof a2 == "function" ? (s, l2, u2) => a2 == null ? void 0 : a2(s.original, l2.original) : "alphanumeric", ...i });
  });
}, columnPinning: (e3) => {
  let o = [], t = [];
  return e3 == null ? void 0 : e3.map((r3) => {
    r3.fixed === "left" ? o.push(r3.dataIndex) : r3.fixed === "right" && t.push(r3.dataIndex);
  }), { left: o, right: t };
}, pagination: (e3) => {
  let o = {}, t = {};
  return e3 && (o = { pagination: { pageIndex: e3.page - 1, pageSize: e3.pageSize } }, t = { getPaginationRowModel: getPaginationRowModel() }), { state: o, config: t };
} };
function ns$2(e3) {
  let o = useRef(null);
  return useEffect(() => {
    if (!o.current) return;
    let t = window.getComputedStyle(o.current).backgroundColor;
    o.current.style.setProperty("--oui-table-background-color", t);
  }, e3), o;
}
var Do$3 = createContext(void 0);
var cd$1 = (e3) => {
  let o = useMemo(() => ({ ...e3.locale, exist: true }), [e3.locale]);
  return jsx(Do$3.Provider, { value: o, children: e3.children });
};
var Kr$2 = { locale: "en", dialog: { ok: "OK", cancel: "Cancel" }, modal: { confirm: "Confirm", cancel: "Cancel" }, pagination: { morePages: "More pages", rowsPerPage: "Rows per page" }, picker: { selectDate: "Select Date", dayPicker: enUS }, empty: { description: "No results found." } };
var A$5 = (e3, o) => {
  let t = useContext(Do$3), r3 = useMemo(() => {
    let n4 = Kr$2[e3], a2 = (t == null ? void 0 : t[e3]) || {};
    return { ...typeof n4 == "function" ? n4() : n4, ...a2 };
  }, [e3, o, t]), i = useMemo(() => {
    let n4 = t == null ? void 0 : t.locale, a2 = Kr$2.locale;
    return n4 || a2;
  }, [t]);
  return [r3, i];
};
var us$1 = ({ className: e3, ...o }) => jsx("nav", { role: "navigation", "aria-label": "pagination", className: cnBase("oui-flex oui-justify-between oui-items-center oui-w-full oui-text-xs", e3), ...o });
us$1.displayName = "Pagination";
var cs = Ce__default__default.forwardRef(({ className: e3, ...o }, t) => jsx("ul", { ref: t, className: cnBase("oui-flex oui-flex-row oui-items-center oui-gap-x-2", e3), ...o }));
cs.displayName = "PaginationContent";
var Rt$1 = Ce__default__default.forwardRef(({ className: e3, ...o }, t) => jsx("li", { ref: t, className: cnBase("oui-leading-[0px]", e3), ...o }));
Rt$1.displayName = "PaginationItem";
var Nt$4 = ({ className: e3, isActive: o, ...t }) => jsx("button", { "aria-current": o ? "page" : void 0, "data-active": o, className: rt$4({ size: "xs", variant: o ? "contained" : "text", className: "oui-min-w-6 oui-text-base-contrast-80 oui-font-semibold data-[active=false]:hover:oui-bg-base-6 disabled:oui-bg-transparent disabled:hover:oui-bg-transparent" }), ...t });
Nt$4.displayName = "PaginationLink";
var ps = ({ className: e3, ...o }) => jsx(Nt$4, { "aria-label": "Go to previous page", className: cnBase("oui-gap-1 oui-pl-2.5", e3), ...o, children: jsx(We$6, { className: "oui-h-4 oui-w-4", color: "white" }) });
ps.displayName = "PaginationPrevious";
var ds = ({ className: e3, ...o }) => jsx(Nt$4, { "aria-label": "Go to next page", className: cnBase("oui-gap-1 oui-pr-2.5", e3), ...o, children: jsx(Ge$2, { className: "oui-h-4 oui-w-4", color: "white" }) });
ds.displayName = "PaginationNext";
var ms = (e3) => {
  let { classNames: o, className: t, pageTotal: r3, page: i } = e3, [n4] = A$5("pagination");
  return jsxs(us$1, { className: cnBase(o == null ? void 0 : o.pagination, t), children: [jsxs(z$1, { mr: 4, children: [jsx(K$3, { as: "div", size: "2xs", intensity: 54, className: "oui-text-nowrap oui-mr-2", children: n4.rowsPerPage }), jsx("div", { className: "oui-w-14", children: jsx(ke$2.options, { options: [{ value: "10", label: "10" }, { value: "20", label: "20" }, { value: "50", label: "50" }, { value: "100", label: "100" }], value: `${e3.pageSize ?? 5}`, size: "xs", onValueChange: (a2) => {
    var _a2;
    return (_a2 = e3.onPageSizeChange) == null ? void 0 : _a2.call(e3, parseInt(a2));
  } }) })] }), jsx(gs, { ...e3 })] });
};
function xd(e3, o) {
  let t = [], r3 = "...";
  if (o <= 5) for (let n4 = 1; n4 <= o; n4++) t.push(n4);
  else e3 <= 3 ? t.push(1, 2, 3, 4, r3, o) : e3 >= o - 2 ? t.push(1, r3, o - 3, o - 2, o - 1, o) : t.push(1, r3, e3 - 1, e3, e3 + 1, r3, o);
  return t;
}
var gs = (e3) => {
  let { classNames: o, className: t, pageTotal: r3, page: i } = e3;
  if (r3 <= 1) return null;
  let n4 = useMemo(() => xd(i, r3), [i, r3]);
  return jsxs(cs, { children: [jsx(Rt$1, { children: jsx(ps, { disabled: e3.page === 1, onClick: (a2) => {
    var _a2;
    a2.preventDefault(), (_a2 = e3.onPageChange) == null ? void 0 : _a2.call(e3, e3.page - 1);
  } }) }), n4.map((a2, s) => jsx(Rt$1, { children: jsx(Nt$4, { isActive: a2 === e3.page, onClick: (l2) => {
    var _a2, _b2;
    l2.preventDefault(), a2 !== "..." ? (_a2 = e3.onPageChange) == null ? void 0 : _a2.call(e3, Number(a2)) : (_b2 = e3.onPageChange) == null ? void 0 : _b2.call(e3, Number(n4[s + 1] - 1));
  }, children: a2 }) }, s)), jsx(Rt$1, { children: jsx(ds, { disabled: e3.page === e3.pageTotal, onClick: (a2) => {
    var _a2;
    a2.preventDefault(), (_a2 = e3.onPageChange) == null ? void 0 : _a2.call(e3, e3.page + 1);
  } }) })] });
};
var xs$1 = (e3) => e3.pageTotal === 0 ? null : jsx(z$1, { justify: "end", py: 2, mx: 3, className: "oui-h-10 oui-w-full", children: jsx(ms, { ...e3, className: "oui-table-pagination oui-justify-between oui-w-full" }) });
function It$1(e3, o) {
  let t = e3.getIsPinned(), r3 = t === "left" && e3.getIsLastColumn("left"), i = t === "right" && e3.getIsFirstColumn("right"), n4 = { left: t === "left" ? `${e3.getStart("left")}px` : void 0, right: t === "right" ? `${e3.getAfter("right")}px` : void 0, width: e3.getSize() }, a2 = cnBase(t ? "oui-sticky" : "oui-relative", t ? "oui-z-[1]" : "oui-z-0", t && "oui-bg-[var(--oui-table-background-color)]"), s = cnBase("before:oui-block before:oui-absolute", "before:oui-w-[32px] before:oui-h-full", "before:oui-top-0 before:oui-z-[-1]", "before:oui-bg-[linear-gradient(90deg,rgba(var(--oui-color-base-10)_/_0.80)_0%,rgba(var(--oui-color-base-10)_/_0.36)_65%,rgba(var(--oui-color-base-10)_/_0.00)_100%)]"), l2 = r3 && cnBase(s, "before:oui-right-[-32px]"), u2 = i && cnBase(s, "before:oui-left-[-32px] before:oui-rotate-180");
  return { style: n4, classNames: { content: a2, leftShadow: l2, rightShadow: u2 } };
}
var Jr$4 = (e3) => jsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: "10", height: "10", viewBox: "0 0 10 10", fill: "none", children: e3.children }), bs$1 = () => jsx(Jr$4, { children: jsx("path", { d: "M5 1.042a.47.47 0 0 0-.338.135L2.166 3.844c-.206.22-.005.531.338.531h4.992c.342 0 .543-.311.337-.531L5.338 1.177A.47.47 0 0 0 5 1.042m0 7.916a.47.47 0 0 1-.338-.135L2.166 6.156c-.206-.22-.005-.531.338-.531h4.992c.342 0 .543.311.337.531L5.338 8.823A.47.47 0 0 1 5 8.958", fill: "#fff", fillOpacity: ".2" }) }), hs$1 = () => jsxs(Jr$4, { children: [jsx("path", { d: "M5 1.042a.47.47 0 0 0-.338.135L2.166 3.844c-.206.22-.005.531.338.531h4.992c.342 0 .543-.311.337-.531L5.338 1.177A.47.47 0 0 0 5 1.042", fill: "#fff", fillOpacity: ".8" }), jsx("path", { d: "M5 8.958a.47.47 0 0 1-.338-.135L2.166 6.156c-.206-.22-.005-.531.338-.531h4.992c.342 0 .543.311.337.531L5.338 8.823A.47.47 0 0 1 5 8.958", fill: "#fff", fillOpacity: ".2" })] }), ws$1 = () => jsxs(Jr$4, { children: [jsx("path", { d: "M5 1.042a.47.47 0 0 0-.338.135L2.166 3.844c-.206.22-.005.531.338.531h4.992c.342 0 .543-.311.337-.531L5.338 1.177A.47.47 0 0 0 5 1.042", fill: "#fff", fillOpacity: ".2" }), jsx("path", { d: "M5 8.958a.47.47 0 0 1-.338-.135L2.166 6.156c-.206-.22-.005-.531.338-.531h4.992c.342 0 .543.311.337.531L5.338 8.823A.47.47 0 0 1 5 8.958", fill: "#fff", fillOpacity: ".8" })] });
var Dt$4 = tv({ variants: { align: { left: "oui-text-left", center: "oui-text-center", right: "oui-text-right" } }, defaultVariants: { align: "left" } });
var ys$2 = (e3) => jsx("thead", { className: cnBase("oui-table-thead", "oui-sticky oui-top-0 oui-z-[2]", "oui-bg-[var(--oui-table-background-color)]", "oui-text-base-contrast-36"), children: e3.headerGroups.map((o) => jsx("tr", { className: cnBase("oui-table-thead-tr", "oui-h-10", e3.className), children: o.headers.map((t) => {
  let r3 = t.column, { align: i, className: n4, title: a2 } = r3.columnDef.meta || {}, { style: s, classNames: l2 } = It$1(r3), u2 = r3.getCanSort(), p2 = r3.getIsSorted();
  return jsx("th", { style: s, className: cnBase("oui-table-thead-th", "oui-whitespace-nowrap", "oui-px-3", e3.bordered && "after:oui-block after:oui-absolute after:oui-w-full after:oui-h-full after:oui-top-0 after:oui-left-0 after:oui-z-[-1] after:oui-border-b after:oui-border-line", Dt$4({ align: i }), n4, l2.content, e3.showLeftShadow && l2.leftShadow, e3.showRightShadow && l2.rightShadow), children: t.isPlaceholder ? null : jsxs("div", { className: cnBase("oui-inline-flex oui-items-center oui-gap-x-1", u2 && "oui-cursor-pointer oui-select-none hover:oui-text-base-contrast-80"), onClick: r3.getToggleSortingHandler(), children: [a2, u2 && jsx(hd, { isSorted: p2 })] }) }, t.id);
}) }, o.id)) }), hd = ({ isSorted: e3 }) => ({ asc: jsx(hs$1, {}), desc: jsx(ws$1, {}) })[e3] || jsx(bs$1, {});
var Cs$1 = (e3) => {
  let { cell: o } = e3, { original: t, index: r3 } = o.row, { formatter: i, render: n4, rule: a2, textProps: s, numeralProps: l2 } = o.column.columnDef.meta || {}, u2 = o.getValue();
  if (typeof i == "function" && (u2 = i(u2, t, r3)), typeof n4 == "function") return n4(u2, t, r3);
  if (typeof a2 < "u") {
    if (Pn(a2)) {
      let p2 = typeof s == "function" ? s(u2, t, r3) : s;
      return jsx(wo$4, { rule: a2, ...p2, children: u2 });
    }
    if (ca(a2)) {
      let p2 = typeof l2 == "function" ? l2(u2, t, r3) : l2;
      return jsx(He$5, { rule: a2, ...p2, children: u2 });
    }
  }
  return flexRender(o.column.columnDef.cell, o.getContext());
};
var Rs = (e3) => jsx("tbody", { className: cnBase("oui-table-tbody oui-relative", "oui-text-base-contrast-80", e3.className), "data-testid": e3.testId, children: e3.rows.map((o) => {
  var _a2;
  let { className: t, onClick: r3, ...i } = typeof e3.onRow == "function" ? e3.onRow(o.original, o.index) : {}, n4 = jsxs(Fragment$2, { children: [jsx("tr", { className: cnBase("oui-table-tbody-tr oui-group oui-h-10", typeof r3 == "function" && "oui-cursor-pointer", e3.bordered && "oui-border-b oui-border-b-line-4", t), onClick: (a2) => {
    o.getCanExpand() && o.getToggleExpandedHandler(), r3 == null ? void 0 : r3();
  }, ...i, children: o.getVisibleCells().map((a2) => {
    let s = a2.column, { style: l2, classNames: u2 } = It$1(s), { align: p2, className: d2 } = s.columnDef.meta || {};
    return jsxs("td", { style: l2, className: cnBase("oui-table-tbody-td oui-relative", "oui-px-3", Dt$4({ align: p2 }), d2, u2.content, e3.showLeftShadow && u2.leftShadow, e3.showRightShadow && u2.rightShadow), children: [jsx(Cs$1, { cell: a2 }), jsx(yd, { selected: o.getIsSelected(), isFirst: s.getIsFirstColumn(), isLast: s.getIsLastColumn() })] }, a2.id);
  }) }, o.id), o.getIsExpanded() && jsx("tr", { className: "oui-z-0", children: jsx("td", { colSpan: o.getVisibleCells().length, children: (_a2 = e3.expandRowRender) == null ? void 0 : _a2.call(e3, o, o.index) }) })] }, o.id);
  return typeof e3.renderRowContainer == "function" ? jsx(Fragment$2, { children: e3.renderRowContainer(o.original, o.index, n4) }, o.id) : n4;
}) }), yd = ({ selected: e3, isFirst: o, isLast: t }) => jsx("div", { className: cnBase("oui-absolute oui-top-0 oui-left-0 oui-z-[-1]", "oui-w-full oui-h-full", "group-hover:oui-bg-line-4", e3 && "oui-bg-line-6 group-hover:oui-bg-line-6", o && "oui-rounded-l", t && "oui-rounded-r") });
function Ns(e3) {
  let { dataSource: o, loading: t, ignoreLoadingCheck: r3 } = e3, [i, n4] = useState(false);
  return useEffect(() => {
    i || (r3 || t || Array.isArray(o)) && n4(true);
  }, [t, r3, o, i]), i;
}
var pe$3 = class e {
  constructor() {
    __publicField(this, "extensionMap", /* @__PURE__ */ new Map());
  }
  static getInstance() {
    let o = l$1();
    return o.__ORDERLY_EXTENSION_REGISTRY__ || (o.__ORDERLY_EXTENSION_REGISTRY__ = new e()), o.__ORDERLY_EXTENSION_REGISTRY__;
  }
  register(o) {
    var _a2;
    o.builder;
    for (let t = 0; t < o.positions.length; t++) {
      if (typeof o.builder != "function") {
        let i = (_a2 = this.extensionMap.get(o.positions[t])) == null ? void 0 : _a2.builder;
        o.builder = typeof i > "u" ? void 0 : i;
      }
      let r3 = o.positions[t];
      this.registerToPosition(r3, o);
    }
  }
  registerToPosition(o, t) {
    if (this.extensionMap.has(o)) {
      let r3 = this.extensionMap.get(o);
      if (!(r3 == null ? void 0 : r3.__isInternal)) {
        !(r3 == null ? void 0 : r3.builder) && t.__isInternal && this.setBuilder(o, t.builder);
        return;
      }
      t.builder || (t.builder = r3.builder);
    }
    this.extensionMap.set(o, t);
  }
  setBuilder(o, t) {
    let r3 = this.extensionMap.get(o);
    r3 && (r3.builder = t);
  }
  unregister(o) {
    for (let t = 0; t < o.positions.length; t++) {
      let r3 = o.positions[t];
      this.unregisterFromPosition(r3);
    }
  }
  unregisterFromPosition(o) {
    this.extensionMap.delete(o);
  }
  getPluginsByPosition(o) {
    return this.extensionMap.get(o);
  }
  getFormatterByPosition(o) {
    return this.extensionMap.get(o);
  }
};
var zo$2 = (e3) => (o) => {
  pe$3.getInstance().register({ name: e3.name, positions: e3.positions, __isInternal: !!e3.__isInternal, builder: e3.builder, render: o });
};
var Ts$1 = (e3, o) => {
  let r3 = pe$3.getInstance().getPluginsByPosition(e3);
  return () => {
    var _a2;
    return ((_a2 = r3 == null ? void 0 : r3.builder) == null ? void 0 : _a2.call(r3, o)) || o;
  };
};
var Is$1 = (e3, o) => Ts$1(e3, o)();
var zs = (e3) => {
  let { position: o } = e3;
  return jsxs("div", { className: "oui-text-danger", children: [jsx("strong", { children: `[${o}] ` }), jsx("span", { children: "Not found!" })] });
};
var ei$3 = (e3) => {
  let { position: o, scope: t, defaultWidget: r3, ...i } = e3, n4 = Is$1(o, i), a2 = useMemo(() => {
    var _a2;
    return ((_a2 = pe$3.getInstance().getPluginsByPosition(o)) == null ? void 0 : _a2.render) ?? r3 ?? zs;
  }, []);
  return jsx(ErrorBoundary, { fallback: jsx("div", { children: `Component: [${o}] went wrong` }), children: jsx(Slot, { ...n4, position: o, children: jsx(a2, {}) }) });
};
var Et$5 = ((a2) => (a2.DepositForm = "depositForm", a2.WithdrawForm = "withdrawForm", a2.AccountMenu = "accountMenu", a2.MobileAccountMenu = "mobileAccountMenu", a2.MainMenus = "mainMenus", a2.EmptyDataIdentifier = "emptyDataIdentifier", a2))(Et$5 || {});
var Ms$1 = (e3) => {
  let { visible: o, loading: t, emptyView: r3 } = e3;
  return o ? jsx(_$1, { position: "absolute", left: 0, top: 0, right: 0, bottom: 0, className: "oui-flex oui-justify-center oui-items-center", children: t ? jsx(we$5, {}) : r3 || jsx(ei$3, { position: "emptyDataIdentifier" }) }) : null;
};
function Bs(e3) {
  let { onSort: o, initialSort: t } = e3, [r3, i] = useState(t ? [{ id: t.sortKey, desc: t.sort === "desc" }] : []);
  return useEffect(() => {
    let { id: n4, desc: a2 } = r3[0] || {};
    o == null ? void 0 : o(n4 ? { sortKey: n4, sort: a2 ? "desc" : "asc" } : void 0);
  }, [r3, o]), [r3, i];
}
function Es(e3) {
  let { dataSource: o, loading: t } = e3, r3 = useRef(false), i = useMemo(() => t && !(o == null ? void 0 : o.length) ? r3.current : !!(o == null ? void 0 : o.length), [t, o]);
  return useEffect(() => {
    i && (r3.current = true);
  }, [i]), i;
}
function Fs$1(e3) {
  let { loading: o, dataSource: t, pagination: r3, rows: i } = e3, n4 = useRef(false), a2 = useMemo(() => o && !(t == null ? void 0 : t.length) ? n4.current : !!(r3 && (t == null ? void 0 : t.length) && (i == null ? void 0 : i.length)), [o, r3, t, i]);
  return useEffect(() => {
    a2 && (n4.current = true);
  }, [a2]), a2;
}
function Os(e3) {
  let o = useRef(null), [t, r3] = useState(false), [i, n4] = useState(false);
  return useEffect(() => {
    o.current && o.current.addEventListener("scroll", function(a2) {
      r3(o.current.scrollLeft > 0), n4(!As$2(o.current));
    });
  }, [o]), useEffect(() => {
    if (!o.current) return;
    let a2 = Od(o.current), s = As$2(o.current);
    n4(a2 && !s);
  }, [o, ...e3]), { scrollRef: o, showLeftShadow: t, showRightShadow: i };
}
function As$2(e3) {
  return e3.scrollLeft + e3.clientWidth >= e3.scrollWidth;
}
function Od(e3) {
  return e3.scrollWidth > e3.clientWidth;
}
function jd(e3) {
  var _a2;
  let { columns: o, className: t, classNames: r3, pagination: i, getRowCanExpand: n4, manualPagination: a2, loading: s, ignoreLoadingCheck: l2, emptyView: u2, initialSort: p2, manualSorting: d2, onSort: m2 } = e3, c2 = useMemo(() => e3.dataSource ? e3.dataSource : [], [e3.dataSource]), x2 = useMemo(() => kt$3.columns(o), [o]), y2 = useMemo(() => kt$3.columnPinning(o), [o]), S2 = useMemo(() => e3.rowSelection || {}, [e3.rowSelection]), { state: f2, config: R2 } = useMemo(() => kt$3.pagination(i), [i]), [k2, w5] = Bs({ onSort: m2, initialSort: p2 }), I2 = Ns({ dataSource: c2, loading: s, ignoreLoadingCheck: l2 }), v2 = useMemo(() => Array.isArray(e3.columnFilters) ? e3.columnFilters : e3.columnFilters ? [e3.columnFilters] : [], [e3.columnFilters]), N2 = useReactTable({ _features: e3.features, data: c2, columns: x2, state: { columnPinning: y2, columnFilters: v2, rowSelection: S2, sorting: k2, ...f2 }, onSortingChange: w5, getRowId: e3.generatedRowKey, getCoreRowModel: getCoreRowModel(), getExpandedRowModel: getExpandedRowModel(), getRowCanExpand: n4, getSortedRowModel: getSortedRowModel(), getFilteredRowModel: getFilteredRowModel(), manualSorting: d2, manualPagination: a2, enableMultiRowSelection: false, ...R2 });
  useEffect(() => {
    var _a3;
    (_a3 = e3.getTableInstance) == null ? void 0 : _a3.call(e3, N2);
  }, [N2]);
  let W2 = ns$2([t, r3 == null ? void 0 : r3.root]), { scrollRef: he2, showLeftShadow: q2, showRightShadow: h2 } = Os([c2 == null ? void 0 : c2.length]), D2 = N2.getRowModel().rows, L2 = I2 && (D2.length === 0 || s), Ko2 = Es({ loading: s, dataSource: c2 }), sr2 = Fs$1({ loading: s, dataSource: c2, rows: D2, pagination: i });
  return jsxs("div", { ref: W2, id: e3.id, className: cnBase("oui-table-root oui-w-full oui-h-full", "oui-bg-base-9", t, r3 == null ? void 0 : r3.root), children: [jsxs("div", { ref: he2, className: cnBase("oui-table-scroll oui-relative", "oui-w-full oui-min-h-[162px]", "oui-text-xs oui-font-semibold", "oui-overflow-auto oui-custom-scrollbar", sr2 ? "oui-h-[calc(100%_-_40px)]" : "oui-h-full", r3 == null ? void 0 : r3.scroll), children: [jsxs("table", { className: cnBase("oui-w-full", "oui-table-fixed oui-border-collapse"), children: [Ko2 && jsx(ys$2, { className: r3 == null ? void 0 : r3.header, headerGroups: N2.getHeaderGroups(), bordered: e3.bordered, showLeftShadow: q2, showRightShadow: h2 }), jsx(Rs, { className: r3 == null ? void 0 : r3.body, rows: D2, bordered: e3.bordered, renderRowContainer: e3.renderRowContainer, expandRowRender: e3.expandRowRender, onRow: e3.onRow, showLeftShadow: q2, showRightShadow: h2, testId: (_a2 = e3.testIds) == null ? void 0 : _a2.body })] }), jsx(Ms$1, { visible: L2, loading: s, emptyView: u2 })] }), sr2 && jsx(xs$1, { className: r3 == null ? void 0 : r3.pagination, count: (i == null ? void 0 : i.count) || (D2 == null ? void 0 : D2.length), pageTotal: (i == null ? void 0 : i.pageTotal) || N2.getPageCount(), page: i == null ? void 0 : i.page, pageSize: i == null ? void 0 : i.pageSize, onPageChange: i == null ? void 0 : i.onPageChange, onPageSizeChange: i == null ? void 0 : i.onPageSizeChange })] });
}
function Qe$3({ className: e3, classNames: o, showOutsideDays: t = true, ...r3 }) {
  let [i] = A$5("picker");
  return jsx(DayPicker, { locale: i.dayPicker, showOutsideDays: t, className: cnBase("oui-p-3 oui-bg-base-7 oui-rounded", e3), classNames: { months: "oui-flex oui-flex-col sm:oui-flex-row oui-space-y-4 sm:oui-space-x-4 sm:oui-space-y-0", month: "oui-space-y-4", caption: "oui-flex oui-justify-center oui-pt-1 oui-relative oui-items-center", caption_label: "oui-text-sm oui-font-medium ", nav: "oui-space-x-1 oui-flex oui-items-center", nav_button: cnBase("oui-h-7 oui-w-7 oui-bg-transparent oui-p-0 oui-opacity-50 hover:oui-opacity-100"), nav_button_previous: "oui-absolute oui-left-1", nav_button_next: "oui-absolute oui-right-1", table: "oui-w-full oui-border-collapse oui-space-y-1", head_row: "oui-flex", head_cell: "oui-text-base-contrast-80 oui-rounded-md oui-w-7 oui-font-normal oui-text-[0.8rem] oui-opacity-30", row: "oui-flex oui-w-full oui-mt-2", cell: cnBase("oui-relative oui-day-cell oui-p-0 oui-text-center oui-text-2xs focus-within:oui-relative focus-within:oui-z-20 [&:has([aria-selected])]:oui-bg-base-4 [&:has([aria-selected].day-outside)]:oui-bg-base-4/50 [&:has([aria-selected].day-range-end)]:oui-rounded-r-md", r3.mode === "range" ? "[&:has(>.oui-day-range-end)]:oui-rounded-r-md [&:has(>.oui-day-range-start)]:oui-rounded-l-md first:[&:has([aria-selected])]:oui-rounded-l-md last:[&:has([aria-selected])]:oui-rounded-r-md" : "[&:has([aria-selected])]:oui-rounded-md"), day: cnBase("oui-h-7 oui-w-7 oui-p-0 oui-rounded-md oui-font-normal aria-selected:oui-opacity-100 oui-text-base-contrast-80 hover:oui-bg-base-5"), day_range_start: "day-range-start  oui-bg-primary-darken oui-text-base-contrast-80 hover:oui-bg-primary-darken", day_range_end: "day-range-end oui-bg-primary-darken oui-text-base-contrast-80 hover:oui-bg-primary-darken", day_selected: "oui-bg-base-4 ", day_today: "oui-bg-accent ", day_outside: "oui-day-outside oui-text-muted-foreground oui-opacity-50 aria-selected:oui-bg-accent/50 aria-selected:oui-text-muted-foreground aria-selected:oui-opacity-30", day_disabled: "oui-text-muted-foreground oui-opacity-50", day_range_middle: "aria-selected:oui-bg-accent aria-selected:oui-text-accent-foreground", day_hidden: "oui-invisible", ...o }, components: { IconLeft: ({ ...n4 }) => jsx(We$6, { size: 16, className: "oui-text-inherit", opacity: 1 }), IconRight: ({ ...n4 }) => jsx(Ge$2, { size: 16, className: "oui-text-inherit", opacity: 1 }) }, ...r3 });
}
Qe$3.displayName = "Calendar";
var Kd = "yyyy/MM/dd", Mo$2 = (e3) => {
  let { placeholder: o, dateFormat: t, onChange: r3, value: i, initialValue: n4, size: a2, className: s, formatString: l2 = Kd, ...u2 } = e3, [p2] = A$5("picker"), [d2, m2] = useState(false), [c2, x2] = useState(i || n4 || null), [y2, S2] = useState(false), f2 = Qd$1((v2) => {
    S2(v2 <= 768);
  }, 100);
  useEffect(() => {
    let v2 = () => {
      f2(window.innerWidth);
    };
    return S2(window.innerWidth <= 768), window.addEventListener("resize", v2), () => {
      window.removeEventListener("resize", v2);
    };
  }, []), useEffect(() => {
    (i == null ? void 0 : i.from) && (i == null ? void 0 : i.to) && (c2 == null ? void 0 : c2.from) && (c2 == null ? void 0 : c2.to) && !Jd(i, c2) && x2(i);
  }, [i]);
  let { trigger: R2 } = H({ size: a2, className: s }), k2 = useMemo(() => {
    if (!c2 || !c2.from || !c2.to) return o ?? p2.selectDate;
    let v2 = [];
    return c2.from && v2.push(format(c2.from, l2)), c2.to && v2.push(format(c2.to, l2)), `${v2.join(" - ")}`;
  }, [c2, o, p2]);
  return jsx(yo$3, { open: d2, onOpenChange: (v2) => {
    typeof (c2 == null ? void 0 : c2.to) > "u" && typeof (c2 == null ? void 0 : c2.from) < "u" && x2({ ...c2, to: c2.from }), !v2 && c2 && (r3 == null ? void 0 : r3(c2)), m2(v2);
  }, contentProps: { className: "oui-w-auto oui-p-0", align: "start" }, content: jsx(Qe$3, { numberOfMonths: y2 ? 1 : 2, ...u2, mode: "range", selected: c2, onSelect: (v2, N2) => {
    (c2 == null ? void 0 : c2.from) && (c2 == null ? void 0 : c2.to) ? x2({ from: N2 }) : x2(v2);
  } }), children: jsxs("button", { className: R2({ className: "oui-datepicker-trigger oui-group" }), children: [jsx("span", { className: "oui-datepicker-trigger-icon", children: jsx(je$5, { size: 14, className: "oui-text-inherit", opacity: 1 }) }), jsx("span", { children: k2 }), jsx(Q$4, { size: 12, className: "oui-datepicker-trigger-arrow oui-text-inherit oui-transition-transform group-data-[state=open]:oui-rotate-180 group-data-[state=closed]:oui-rotate-0", opacity: 1 })] }) });
};
Mo$2.displayName = "DateRangePicker";
function Qd$1(e3, o) {
  let t = useRef(null);
  return useCallback((i) => {
    t.current && clearTimeout(t.current), t.current = setTimeout(() => {
      e3(i);
    }, o);
  }, [e3, o]);
}
function Jd(e3, o) {
  let t = (s) => ({ year: s.getFullYear(), month: s.getMonth(), day: s.getDate() }), r3 = t(e3.from), i = t(e3.to), n4 = t(o.from), a2 = t(o.to);
  return r3.year === n4.year && r3.month === n4.month && r3.day === n4.day && i.year === a2.year && i.month === a2.month && i.day === a2.day;
}
var Bo$3 = (e3) => {
  let { placeholder: o, dateFormat: t, onChange: r3, value: i, size: n4, className: a2, ...s } = e3, [l2] = A$5("picker"), { trigger: u2 } = H({ size: n4, className: a2 }), [p2, d2] = useState(false), m2 = useMemo(() => {
    if (typeof i > "u") return o ?? l2.selectDate;
  }, [i, o, l2]);
  return jsx(yo$3, { open: p2, onOpenChange: d2, contentProps: { className: "oui-w-auto oui-p-0" }, content: jsx(Qe$3, { onSelect: (x2, y2, S2, f2) => {
    var _a2;
    (_a2 = s.onSelect) == null ? void 0 : _a2.call(s, x2, y2, S2, f2), x2 && (r3 == null ? void 0 : r3(x2), d2(false));
  }, ...s }), children: jsxs("button", { className: u2({ className: "orderly-datepicker-trigger oui-group" }), children: [jsx("span", { className: "orderly-datepicker-trigger-icon", children: jsx(je$5, { size: 14, className: "oui-text-inherit", opacity: 1 }) }), jsx("span", { children: m2 }), jsx(Q$4, { size: 12, className: "orderly-datepicker-trigger-arrow oui-text-inherit oui-transition-transform group-data-[state=open]:oui-rotate-180 group-data-[state=closed]:oui-rotate-0", opacity: 1 })] }) });
};
Bo$3.displayName = "DatePicker";
var am = (e3) => jsx("div", { children: jsx(Bo$3, { size: "xs", ...e3, mode: "single", onChange: (o) => {
} }) }), nm = (e3) => {
  let { onChange: o, ...t } = e3;
  return jsx("div", { className: "oui-min-w-[180px]", children: jsx(Mo$2, { size: "xs", ...t, onChange: (i) => {
    typeof o == "function" && o(i);
  } }) });
}, sm = (e3) => {
  let { onChange: o, type: t, isCombine: r3, ...i } = e3;
  switch (t) {
    case "select":
      return jsx("div", { className: "oui-min-w-24", children: r3 ? jsx(ht$2, { size: "xs", ...i, onValueChange: o }) : jsx(Ze$3, { size: "xs", ...i, onValueChange: o }) });
    case "date":
      return jsx(am, { ...i });
    case "range":
      return jsx(nm, { ...i, onChange: o });
    case "symbol":
      return jsx("div", {});
    case "input":
    default:
      return jsx("div", { children: "No Component" });
  }
}, lm = (e3) => jsxs(z$1, { justify: "start", gapX: 3, py: 3, width: "100%", className: cnBase("oui-data-filter-bar oui-border-b oui-border-line", e3.className), children: [e3.items.map((o, t) => (o.type === "date" && (o.mode = "range"), jsx(sm, { ...o, onChange: (r3) => {
  e3.onFilter({ name: o.name ?? o.type, value: r3 });
} }, t))), e3.trailing && jsx("div", { className: "oui-flex-1 oui-flex oui-justify-end", children: e3.trailing })] });
var mm = (e3) => {
  let o = useRef(0), [t, r3] = useState((e3 == null ? void 0 : e3.page) ?? 1), [i, n4] = useState((e3 == null ? void 0 : e3.pageSize) ?? 10), a2 = useCallback((p2) => {
    if (n4(p2), o.current > 0) {
      let d2 = Math.ceil(o.current / p2);
      t > d2 && r3(d2);
    }
  }, [t]), s = (p2) => {
    let d2 = (p2 == null ? void 0 : p2.total) ?? o.current;
    o.current = d2;
    let m2 = (p2 == null ? void 0 : p2.records_per_page) ?? i, c2 = d2 ? Math.ceil(d2 / m2) : 0, x2 = Math.min((p2 == null ? void 0 : p2.current_page) ?? t, c2);
    return { count: d2, page: x2, pageSize: m2, pageTotal: c2 };
  }, l2 = useCallback((p2) => ({ ...s(p2), onPageChange: r3, onPageSizeChange: a2 }), [t, i]), u2 = useMemo(() => ({ page: t, pageSize: i, onPageChange: r3, onPageSizeChange: a2 }), [l2]);
  return useEffect(() => {
    (e3 == null ? void 0 : e3.resetPageWhenPageSizeChange) !== false && r3(1);
  }, [i, e3 == null ? void 0 : e3.resetPageWhenPageSizeChange]), { page: t, pageSize: i, setPage: r3, setPageSize: a2, parseMeta: s, pagination: u2, parsePagination: l2 };
};
function gm() {
  return jsxs("svg", { xmlns: "http://www.w3.org/2000/svg", width: "64", height: "64", fill: "none", viewBox: "0 0 64 64", children: [jsx("rect", { width: "36", height: "48", x: "18", y: "5", fill: "#07080A", rx: "4" }), jsx("rect", { width: "36", height: "48", x: "11", y: "12", fill: "url(#paint0_linear_309_13641)", rx: "4" }), jsx("rect", { width: "36", height: "48", x: "9", y: "10", fill: "url(#paint1_linear_309_13641)", rx: "4" }), jsx("path", { fill: "#303237", d: "M36.636 53.323V50H6v3.323C6 55.91 7.943 58 10.462 58H41c-2.392 0-4.364-2.168-4.364-4.663" }), jsx("rect", { width: "9", height: "2", x: "15", y: "16", fill: "#3F4146", rx: "1" }), jsx("rect", { width: "16", height: "2", x: "15", y: "24", fill: "#3F4146", rx: "1" }), jsx("rect", { width: "12", height: "3", x: "28", y: "29", fill: "#45484E", rx: "1.5" }), jsx("path", { fill: "#45484E", d: "M33 23a2 2 0 012-2h1.5a1.5 1.5 0 010 3H34a1 1 0 01-1-1z" }), jsx("rect", { width: "9", height: "3", x: "29", y: "37", fill: "#45484E", rx: "1.5" }), jsx("rect", { width: "13", height: "2", x: "15", y: "30", fill: "#3F4146", rx: "1" }), jsx("rect", { width: "15", height: "2", x: "15", y: "36", fill: "#3F4146", rx: "1" }), jsx("rect", { width: "24", height: "2", x: "15", y: "42", fill: "#3F4146", rx: "1" }), jsx("path", { fill: "#181A1D", fillRule: "evenodd", d: "M27.24 30.022a12.451 12.451 0 1122.195 9.87l5.328 5.328-1.58 1.58-5.241-5.24a12.452 12.452 0 01-20.703-11.537zm14.193 12.39A10.156 10.156 0 1037.47 22.49a10.156 10.156 0 003.963 19.92z", clipRule: "evenodd" }), jsx("path", { fill: "#54565B", fillRule: "evenodd", d: "M27.24 29.022a12.451 12.451 0 1122.195 9.87l5.328 5.328-1.58 1.58-5.241-5.24a12.452 12.452 0 01-20.703-11.537zm14.193 12.39A10.156 10.156 0 1037.47 21.49a10.156 10.156 0 003.963 19.92z", clipRule: "evenodd" }), jsx("path", { fill: "#16181B", d: "M51.755 43.867c-.99.99-.99 2.596 0 3.586l3.754 3.754a2.536 2.536 0 103.586-3.586l-3.754-3.754a2.536 2.536 0 00-3.586 0z" }), jsx("path", { fill: "#4E525C", d: "M51.755 42.867c-.99.99-.99 2.596 0 3.586l3.754 3.754a2.536 2.536 0 103.586-3.586l-3.754-3.754a2.536 2.536 0 00-3.586 0z" }), jsxs("defs", { children: [jsxs("linearGradient", { id: "paint0_linear_309_13641", x1: "27.286", x2: "48.844", y1: "55.742", y2: "25.703", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "#0C0D10" }), jsx("stop", { offset: "1", stopColor: "#121418" })] }), jsxs("linearGradient", { id: "paint1_linear_309_13641", x1: "25.286", x2: "46.844", y1: "53.742", y2: "23.703", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "#1B1D22" }), jsx("stop", { offset: "1", stopColor: "#26292E" })] })] })] });
}
var Ys$1 = gm;
var At$2 = (e3) => {
  let [o] = A$5("empty");
  return jsxs(z$1, { itemAlign: "center", direction: "column", gapY: 4, className: e3.className, children: [jsx(_$1, { children: jsx(Ys$1, {}) }), jsx($$4, { as: "div", intensity: 36, size: "2xs", children: e3.title ?? o.description })] });
};
zo$2({ name: "emptyDataIdentifier", positions: ["emptyDataIdentifier"] })(At$2);
var js$1 = {};
lr$4(js$1, { DownloadFeature: () => Xs });
var Xs = { createTable: (e3) => {
  e3.getPlainTextData = () => {
    let o = e3.getAllColumns().filter((i) => i.columnDef.meta.type !== "action").map((i) => {
      let { title: n4, plantTextTitle: a2 } = i.columnDef.meta;
      return a2 || n4;
    }), t = e3.getRowModel().rows.map((i) => i.getVisibleCells().filter((n4) => n4.column.columnDef.meta.type !== "action").map((n4) => {
      let { original: a2, index: s } = n4.row, { renderPlantText: l2 } = n4.column.columnDef.meta || {}, u2 = n4.getValue();
      return typeof l2 == "function" && (u2 = l2(u2, a2, s)), `"${u2}"`;
    }));
    return [o, ...t];
  }, e3.download = (o) => {
    let t = e3.getPlainTextData();
    bm$1(t, o);
  };
} };
function xm(e3) {
  return e3.map((o) => o.join(",")).join(`
`);
}
function bm$1(e3, o = `${Date.now()}.csv`) {
  let t = xm(e3), r3 = new Blob([t], { type: "text/csv;charset=utf-8;" }), i = URL.createObjectURL(r3), n4 = document.createElement("a");
  n4.href = i, n4.setAttribute("download", o), n4.click(), URL.revokeObjectURL(i);
}
var Me$5 = tv({ slots: { overlay: ["oui-dialog-overlay", "oui-fixed", "oui-inset-0", "oui-z-50", "oui-bg-black/80", "data-[state=open]:oui-animate-in", "data-[state=closed]:oui-animate-out", "data-[state=closed]:oui-fade-out-0", "data-[state=open]:oui-fade-in-0"], content: ["oui-dialog-content", "oui-fixed", "oui-left-[50%]", "oui-top-[50%]", "oui-z-50", "oui-w-full", "oui-max-w-lg", "oui-translate-x-[-50%]", "oui-translate-y-[-50%]", "oui-text-base-contrast-54", "oui-px-4 lg:oui-px-5", "oui-shadow-lg", "oui-duration-200", "data-[state=open]:oui-animate-in", "data-[state=closed]:oui-animate-out", "data-[state=closed]:oui-fade-out-0", "data-[state=open]:oui-fade-in-0", "data-[state=closed]:oui-zoom-out-95", "data-[state=open]:oui-zoom-in-95", "data-[state=closed]:oui-slide-out-to-left-1/2", "data-[state=closed]:oui-slide-out-to-top-[48%]", "data-[state=open]:oui-slide-in-from-left-1/2", "data-[state=open]:oui-slide-in-from-top-[48%]", "sm:oui-rounded-xl"], body: ["oui-dialog-body", "oui-py-4 lg:oui-py-5", "oui-text-xs"], close: ["oui-dialog-close-btn", "oui-absolute", "oui-right-4", "oui-top-4", "oui-ring-offset-background", "oui-transition-opacity", "hover:oui-opacity-100", "disabled:oui-pointer-events-none"], header: ["oui-dialog-header", "oui-flex", "oui-flex-col"], footer: ["oui-dialog-footer", "oui-flex", "oui-flex-row", "oui-justify-end", "oui-space-x-2", "oui-pb-5", "oui-pt-2 lg:oui-pt-3"], title: ["oui-dialog-title", "oui-text-base", "oui-min-h-11 lg:oui-min-h-[46px]", "oui-flex", "oui-items-center", "oui-text-base-contrast"], desc: ["oui-dialog-desc", "oui-text-xs", "oui-text-warning-darken", "oui-pt-2", "oui-text-center", "oui-pb-3"] }, variants: { size: { xs: { content: ["oui-max-w-xs"] }, sm: { content: ["oui-max-w-sm"] }, md: { content: ["oui-max-w-md"] }, lg: { content: ["oui-max-w-lg"] }, xl: { content: ["oui-max-w-xl"] } }, intensity: { 100: { content: ["oui-bg-base-1"] }, 200: { content: ["oui-bg-base-2"] }, 300: { content: ["oui-bg-base-3"] }, 400: { content: ["oui-bg-base-4"] }, 500: { content: ["oui-bg-base-5"] }, 600: { content: ["oui-bg-base-6"] }, 700: { content: ["oui-bg-base-7"] }, 800: { content: ["oui-bg-base-8"] }, 900: { content: ["oui-bg-base-9"] } } }, defaultVariants: { intensity: 800 } }), Fo$1 = B$8.Root, Us = B$8.Portal, ui$2 = Ce__default.forwardRef(({ className: e3, ...o }, t) => {
  let { overlay: r3 } = Me$5();
  return jsx(B$8.Overlay, { ref: t, className: r3({ className: e3 }), ...o });
});
ui$2.displayName = B$8.Overlay.displayName;
var oo$3 = Ce__default.forwardRef(({ className: e3, children: o, size: t, closable: r3 = true, intensity: i, ...n4 }, a2) => {
  let { content: s, close: l2 } = Me$5({ className: e3, size: t, intensity: i });
  return jsxs(Us, { children: [jsx(ui$2, {}), jsxs(B$8.Content, { ref: a2, className: s({ className: e3 }), ...n4, children: [o, r3 && jsxs(B$8.Close, { className: l2(), "data-testid": "oui-testid-dialog-content-close-btn", children: [jsx(ye$7, { size: 16, color: "white", opacity: 0.98 }), jsx("span", { className: "oui-sr-only", children: "Close" })] })] })] });
});
oo$3.displayName = B$8.Content.displayName;
var to$4 = ({ className: e3, ...o }) => {
  let { header: t } = Me$5();
  return jsx("div", { className: t({ className: e3 }), ...o });
};
to$4.displayName = "DialogHeader";
var Vo$5 = ({ className: e3, ...o }) => {
  let { body: t } = Me$5();
  return jsx("div", { className: t({ className: e3 }), ...o });
}, Ot$3 = ({ className: e3, ...o }) => {
  let { footer: t } = Me$5();
  return jsx("div", { className: t({ className: e3 }), ...o });
};
Ot$3.displayName = "DialogFooter";
var ro$5 = Ce__default.forwardRef(({ className: e3, ...o }, t) => {
  let { title: r3 } = Me$5();
  return jsx(B$8.Title, { ref: t, className: r3({ className: e3 }), ...o });
});
ro$5.displayName = B$8.Title.displayName;
var io$4 = Ce__default.forwardRef(({ className: e3, ...o }, t) => {
  let { desc: r3 } = Me$5();
  return jsx(B$8.Description, { ref: t, className: r3({ className: e3 }), ...o });
});
io$4.displayName = B$8.Description.displayName;
var ym = b$2({ base: ["oui-pointer-events-none oui-box-content"], variants: { intensity: { 4: "oui-border-line-4", 6: "oui-border-line-6", 8: "oui-border-line", 12: "oui-border-line-12", 16: "oui-border-line-16" }, direction: { horizontal: ["oui-border-b"], vertical: ["oui-border-l"] }, lineStyle: { dashed: "oui-border-dashed", dotted: "oui-border-dotted" }, mx: { 2: "oui-mx-2", 4: "oui-mx-4", 6: "oui-mx-6", 8: "oui-mx-8", 10: "oui-mx-10" }, my: { 2: "oui-my-2", 4: "oui-my-4", 6: "oui-my-6", 8: "oui-my-8", 10: "oui-my-10" } }, defaultVariants: { direction: "horizontal", intensity: 4 } }), te$6 = Ce__default__default.forwardRef((e3, o) => {
  let { className: t, intensity: r3, direction: i, lineStyle: n4, mx: a2, my: s, ...l2 } = e3;
  return jsx("div", { ref: o, ...l2, className: ym({ direction: i, intensity: r3, className: t, lineStyle: n4, mx: a2, my: s }) });
});
te$6.displayName = "Divider";
var Lo$4 = (e3) => {
  var _a2, _b2;
  let { actions: o } = e3, [t, r3] = useState(((_a2 = o == null ? void 0 : o.primary) == null ? void 0 : _a2.loading) ?? false);
  if (useEffect(() => {
    var _a3, _b3;
    return ((_a3 = o == null ? void 0 : o.primary) == null ? void 0 : _a3.loading) && r3((_b3 = o == null ? void 0 : o.primary) == null ? void 0 : _b3.loading), () => {
      r3(false);
    };
  }, [(_b2 = o == null ? void 0 : o.primary) == null ? void 0 : _b2.loading]), !o) return null;
  let i = useMemo(() => {
    var _a3, _b3;
    let n4 = [];
    if (o.secondary && typeof o.secondary.onClick == "function") {
      let { fullWidth: a2 = true, color: s = "gray", label: l2, ...u2 } = o.secondary;
      n4.push(jsx(_e$5, { ...u2, "data-testid": (_a3 = o.secondary) == null ? void 0 : _a3["data-testid"], color: s, fullWidth: a2, children: l2 }, "secondary"));
    }
    if (o.primary && typeof o.primary.onClick == "function") {
      let { fullWidth: a2 = true, color: s, disabled: l2, label: u2, onClick: p2, ...d2 } = o.primary;
      n4.push(jsx(dr$3, { ...d2, "data-testid": (_b3 = o.primary) == null ? void 0 : _b3["data-testid"], onClick: async (m2) => {
        if (!t) try {
          r3(true), await p2(m2);
        } catch {
        } finally {
          r3(false);
        }
      }, disabled: l2 || t, loading: t, fullWidth: a2, color: s, children: u2 }, "primary"));
    }
    return n4;
  }, [o, t]);
  return jsx(Ot$3, { className: e3.className, children: i });
};
var me$4 = (e3) => {
  var _a2, _b2, _c2;
  let o = typeof e3.title == "function" ? e3.title() : e3.title;
  return jsx(Fo$1, { open: e3.open, onOpenChange: e3.onOpenChange, children: jsxs(oo$3, { size: e3.size, closable: e3.closable, onOpenAutoFocus: (t) => t.preventDefault(), onCloseAutoFocus: (t) => t.preventDefault(), className: (_a2 = e3.classNames) == null ? void 0 : _a2.content, ...e3.contentProps, children: [o && jsxs(Fragment$1, { children: [jsx(to$4, { children: jsx(ro$5, { children: o }) }), jsx(te$6, {})] }), jsx(Vo$5, { className: (_b2 = e3.classNames) == null ? void 0 : _b2.body, children: e3.children }), typeof e3.description < "u" && jsx(io$4, { children: e3.description }), jsx(Lo$4, { actions: e3.actions, className: (_c2 = e3.classNames) == null ? void 0 : _c2.footer })] }) });
};
function pi$2(e3) {
  let o = (n4) => typeof window < "u" ? window.matchMedia(n4).matches : false, [t, r3] = useState(o(e3));
  function i() {
    r3(o(e3));
  }
  return useEffect(() => {
    var _a2;
    let n4 = window == null ? void 0 : window.matchMedia(e3);
    return i(), (n4 == null ? void 0 : n4.addListener) ? n4 == null ? void 0 : n4.addListener(i) : (_a2 = n4 == null ? void 0 : n4.addEventListener) == null ? void 0 : _a2.call(n4, "change", i), () => {
      var _a3;
      (n4 == null ? void 0 : n4.removeListener) ? n4 == null ? void 0 : n4.removeListener(i) : (_a3 = n4 == null ? void 0 : n4.removeEventListener) == null ? void 0 : _a3.call(n4, "change", i);
    };
  }, [e3]), t;
}
function Ao$6() {
  let e3 = pi$2("(max-width: 768px)");
  return { isMobile: e3, isDesktop: !e3 };
}
function Dm(e3, o) {
  useEffect(() => {
    if (!e3) return;
    let t = new ResizeObserver((r3) => {
      for (let i of r3) o(i);
    });
    return t.observe(e3), () => {
      t.unobserve(e3);
    };
  }, [e3]);
}
var mi$3 = (e3) => {
  let [o] = A$5("dialog"), { title: t, message: r3, open: i, onOpenChange: n4, onOk: a2, onCancel: s, okLabel: l2 = o.ok, cancelLabel: u2 = o.cancel, size: p2, classNames: d2 } = e3, { isMobile: m2 } = Ao$6(), c2 = useMemo(() => {
    var _a2, _b2;
    if (typeof a2 != "function" && typeof s != "function") return;
    let y2 = {};
    return typeof s == "function" && (y2.secondary = { label: u2, onClick: s, size: "md", fullWidth: true, ...(_a2 = e3.actions) == null ? void 0 : _a2.secondary }), typeof a2 == "function" && (y2.primary = { label: l2, size: "md", fullWidth: true, className: "oui-w-full lg:oui-w-[154px]", onClick: a2, ...(_b2 = e3.actions) == null ? void 0 : _b2.primary }), y2;
  }, [a2, s, l2, u2, e3.actions]);
  return jsx(me$4, { open: i, title: t, size: p2 || (m2 ? "xs" : "sm"), actions: c2, onOpenChange: n4, classNames: { content: cnBase("oui-bg-base-8 oui-font-semibold oui-border oui-border-line-6", "oui-p-4 oui-pt-0 lg:oui-p-5 lg:oui-pt-0", d2 == null ? void 0 : d2.content), body: cnBase("oui-py-4 lg:oui-py-5", d2 == null ? void 0 : d2.body), footer: cnBase("oui-justify-center oui-pb-0 oui-pt-2 lg:oui-pt-3", d2 == null ? void 0 : d2.footer) }, children: r3 });
};
var fi$3 = Symbol("modalId"), Fm = 0, Vm$1 = () => `__modal_${Fm++}`, Oo$3 = (e3) => typeof e3 == "string" ? e3 : (e3[fi$3] || (e3[fi$3] = Vm$1()), e3[fi$3]);
function X$5(e3, o) {
  let t = useContext(Ve$2), r3 = useContext(_o$2), i, n4 = e3 && typeof e3 != "string";
  if (e3 ? i = Oo$3(e3) : i = r3, !i) throw new Error("modalId is required");
  let a2 = i;
  useEffect(() => {
    n4 && ao$2(a2, e3, o);
  }, [n4, i, e3, o]);
  let s = t[a2], l2 = useCallback((f2) => O$6.show(a2, f2), [a2]), u2 = useCallback(() => O$6.hide(a2), [a2]), p2 = useCallback(() => O$6.remove(a2), [a2]), d2 = useCallback((f2) => {
    f2 || (y2("cancel"), u2());
  }, [a2]), m2 = useCallback((f2) => {
    O$6.setStates(a2, f2);
  }, [a2]), c2 = useCallback((f2) => {
    O$6.updateArgs(a2, f2);
  }, [a2]), x2 = useCallback((f2) => {
    var _a2;
    (_a2 = re$3[a2]) == null ? void 0 : _a2.resolve(f2), delete re$3[a2];
  }, [a2]), y2 = useCallback((f2) => {
    var _a2;
    (_a2 = re$3[a2]) == null ? void 0 : _a2.reject(f2), delete re$3[a2];
  }, [a2]), S2 = useCallback((f2) => {
    var _a2;
    (_a2 = Fe$4[a2]) == null ? void 0 : _a2.resolve(f2), delete Fe$4[a2];
  }, []);
  return { id: a2, args: s == null ? void 0 : s.args, states: s == null ? void 0 : s.states, visible: !!(s == null ? void 0 : s.visible), keepMounted: !!(s == null ? void 0 : s.keepMounted), show: l2, hide: u2, onOpenChange: d2, setStates: m2, updateArgs: c2, remove: p2, resolve: x2, reject: y2, resolveHide: S2 };
}
var ie$2 = /* @__PURE__ */ new Map(), ae$7 = (e3) => ({ id: o, defaultVisible: t, keepMounted: r3, ...i }) => {
  var _a2;
  let { args: n4, show: a2 } = X$5(o), s = useContext(Ve$2), l2 = !!s[o];
  useEffect(() => (t && a2(), no$3[o] = true, () => {
    r3 || delete no$3[o];
  }), [o, a2, t]), useEffect(() => {
    r3 && O$6.setStates(o, { keepMounted: true });
  }, [o, r3]);
  let u2 = (_a2 = s[o]) == null ? void 0 : _a2.delayVisible;
  return useEffect(() => {
    u2 && a2(n4);
  }, [u2, n4, a2]), l2 ? jsx(_o$2.Provider, { value: o, children: jsx(e3, { ...i, ...n4 }) }) : null;
};
function ao$2(e3, o, t) {
  ie$2.has(e3) ? ie$2.set(e3, { comp: ie$2.get(e3).comp, props: t }) : ie$2.set(e3, { comp: o, props: t });
}
var Ks = (e3) => {
  ie$2.delete(e3);
};
var Js$1 = {}, no$3 = {}, Ve$2 = createContext(Js$1), _o$2 = createContext(null), re$3 = {}, Fe$4 = {}, so$5 = () => {
  throw new Error("No dispatch method detected, did you embed your app with Modal.Provider?");
};
function Hm(e3, o) {
  return { type: "SHOW_MODAL", payload: { id: e3, args: o } };
}
function Wm$1(e3) {
  return { type: "HIDE_MODAL", payload: { id: e3 } };
}
function Gm(e3) {
  return { type: "DESTROY_MODAL", payload: { id: e3 } };
}
function Ym(e3, o) {
  return { type: "UPDATE_ARGS", payload: { id: e3, args: o } };
}
function Xm(e3, o) {
  return { type: "SET_MODAL_STATES", payload: { id: e3, states: o } };
}
var jm = (e3, o) => {
  let { id: t, args: r3 } = o.payload;
  switch (o.type) {
    case "SHOW_MODAL":
      return { ...e3, [t]: { ...e3[t], id: t, args: r3, visible: !!no$3[t], delayVisible: !no$3[t] } };
    case "HIDE_MODAL":
      return { ...e3, [t]: { ...e3[t], visible: false } };
    case "DESTROY_MODAL": {
      let i = { ...e3 };
      return delete i[t], i;
    }
    case "UPDATE_ARGS":
      return { ...e3, [t]: { ...e3[t], args: { ...e3[t].args, ...r3 } } };
    case "SET_MODAL_STATES":
      return { ...e3, [t]: { ...e3[t], states: { ...e3.states, ...o.payload.states } } };
    default:
      return e3;
  }
}, Um$1 = () => {
  let e3 = useContext(Ve$2), o = Object.keys(e3).filter((r3) => !!e3[r3]);
  o.forEach((r3) => {
    !ie$2.has(r3) && no$3[r3];
  });
  let t = o.filter((r3) => ie$2.has(r3)).map((r3) => ({ id: r3, ...ie$2.get(r3) }));
  return jsx(Fragment$1, { children: t.map((r3) => {
    let i = r3.comp;
    return jsx(i, { id: r3.id, ...r3.props }, r3.id);
  }) });
}, $m$1 = (e3) => {
  let [o, t] = useReducer(jm, Js$1);
  return so$5 = t, jsxs(Ve$2.Provider, { value: o, children: [e3.children, jsx(Um$1, {})] });
};
function Zm(e3, o) {
  let t = Oo$3(e3);
  if (typeof e3 != "string" && !ie$2.has(t) && ao$2(t, e3), so$5(Hm(t, o)), !re$3[t]) {
    let r3, i, n4 = new Promise((a2, s) => {
      r3 = a2, i = s;
    });
    re$3[t] = { resolve: r3, reject: i, promise: n4 };
  }
  return re$3[t].promise;
}
function qm(e3) {
  let o = Oo$3(e3);
  if (so$5(Wm$1(o)), delete re$3[o], !Fe$4[o]) {
    let t, r3, i = new Promise((n4, a2) => {
      t = n4, r3 = a2;
    });
    Fe$4[o] = { resolve: t, reject: r3, promise: i };
  }
  return Fe$4[o].promise;
}
function Km(e3) {
  so$5(Gm(e3)), delete re$3[e3], delete Fe$4[e3];
}
function Qm$1(e3, o) {
  so$5(Xm(e3, o));
}
function Jm(e3, o) {
  so$5(Ym(e3, o));
}
var O$6 = { show: Zm, hide: qm, remove: Km, setStates: Qm$1, updateArgs: Jm };
var Go$2 = B$8.Root, hi$2 = B$8.Trigger, el = B$8.Portal, wi$2 = Ce__default.forwardRef(({ className: e3, ...o }, t) => jsx(B$8.Overlay, { className: cnBase("oui-fixed oui-inset-0 oui-z-50 oui-bg-black/80  data-[state=open]:oui-animate-in data-[state=closed]:oui-animate-out data-[state=closed]:oui-fade-out-0 data-[state=open]:oui-fade-in-0", e3), ...o, ref: t }));
wi$2.displayName = B$8.Overlay.displayName;
var ig = tv({ base: "oui-fixed oui-z-50 oui-gap-4 oui-bg-base-8 oui-px-4 oui-shadow-lg oui-transition oui-ease-in-out data-[state=closed]:oui-duration-260 data-[state=open]:oui-duration-300 data-[state=open]:oui-animate-in data-[state=closed]:oui-animate-out", variants: { side: { top: "oui-inset-x-0 oui-top-0 oui-border-b data-[state=closed]:oui-slide-out-to-top data-[state=open]:oui-slide-in-from-top", bottom: "oui-inset-x-0 oui-bottom-0 oui-rounded-t-2xl data-[state=closed]:oui-slide-out-to-bottom data-[state=open]:oui-slide-in-from-bottom", left: "oui-inset-y-0 oui-left-0 oui-h-full oui-w-3/4 data-[state=closed]:oui-slide-out-to-left data-[state=open]:oui-slide-in-from-left sm:oui-max-w-sm", right: "oui-inset-y-0 oui-right-0 oui-h-full oui-w-3/4 oui-border-l data-[state=closed]:oui-slide-out-to-right data-[state=open]:oui-slide-in-from-right sm:oui-max-w-sm" } }, defaultVariants: { side: "bottom" } }), lo$4 = Ce__default.forwardRef(({ side: e3 = "bottom", closeable: o = true, className: t, children: r3, ...i }, n4) => jsxs(el, { children: [jsx(wi$2, {}), jsxs(B$8.Content, { ref: n4, className: cnBase(ig({ side: e3 }), t), onOpenAutoFocus: (a2) => a2.preventDefault(), onCloseAutoFocus: (a2) => a2.preventDefault(), ...i, children: [o && jsxs(B$8.Close, { className: cnBase("oui-absolute oui-right-4 oui-top-4 oui-rounded-sm oui-ring-offset-base-700 oui-transition-opacity  focus:oui-outline-none focus:oui-ring-2 focus:oui-ring-ring focus:oui-ring-offset-2 disabled:oui-pointer-events-none data-[state=open]:oui-bg-secondary"), children: [jsx(ye$7, { size: 16, color: "white", opacity: 0.98 }), jsx("span", { className: "oui-sr-only", children: "Close" })] }), r3] })] }));
lo$4.displayName = B$8.Content.displayName;
var _t$3 = ({ className: e3, leading: o, ...t }) => jsxs("div", { className: cnBase("oui-sheet-header oui-grid oui-grid-cols-[40px_1fr_40px] oui-items-center oui-min-h-12"), children: [jsx("div", { children: o }), jsx("div", { ...t, className: cnBase("oui-flex oui-flex-col oui-space-y-2 oui-text-center oui-text-lg oui-text-base-contrast", e3) })] });
_t$3.displayName = "SheetHeader";
var vi$2 = ({ className: e3, ...o }) => jsx("div", { className: cnBase("oui-py-4", e3), ...o });
vi$2.displayName = "DialogBody";
var Ht$4 = Ce__default.forwardRef(({ className: e3, leading: o, ...t }, r3) => jsxs("div", { className: "oui-sheet-header oui-grid oui-grid-cols-[40px_1fr_40px] oui-items-center", ref: r3, children: [jsx("div", { children: o }), jsx("div", { className: cnBase("oui-flex oui-flex-col oui-space-y-2 oui-text-center oui-text-lg oui-text-base-contrast", e3), ...t })] }));
Ht$4.displayName = B$8.Title.displayName;
var tl = Ce__default.forwardRef(({ className: e3, ...o }, t) => jsx(B$8.Description, { ref: t, className: cnBase("oui-sheet-description oui-text-2xs oui-text-base-contrast-54", e3), ...o }));
tl.displayName = B$8.Description.displayName;
function ag(e3) {
  return uo$3.create((o) => {
    let { title: t, leading: r3, classNames: i, contentProps: n4, closable: a2, ...s } = o, { visible: l2, hide: u2, resolve: p2, reject: d2, onOpenChange: m2 } = X$5();
    return jsx(Yo$1, { open: l2, onOpenChange: m2, title: t, leading: r3, classNames: i, closable: a2, contentProps: n4, children: jsx(e3, { ...s, close: u2, resolve: p2, reject: d2 }) });
  });
}
function ng(e3, o, t) {
  uo$3.register(e3, ag(o), t);
}
var ug = (e3) => {
  let { action: o } = e3, t = useCallback(() => {
    var _a2;
    typeof o.onClick == "function" ? o.onClick(o) : (_a2 = e3.onClick) == null ? void 0 : _a2.call(e3, { ...o, index: e3.index });
  }, [o]), r3 = useMemo(() => o.label, [o.label]);
  return jsx("div", { className: cnBase("oui-flex oui-justify-center oui-items-center oui-text-lg oui-h-[52px] oui-cursor-pointer", e3.active && "oui-text-primary-darken"), onClick: t, children: r3 });
}, cg = (e3) => jsx("div", { className: "oui-relative oui-h-[1px] oui-bg-base-300 oui-mt-[-1px]" }), pg = (e3) => jsx(Fragment$1, { children: e3.actionSheets.map((o, t) => o.type === "division" ? jsx(cg, {}, t) : jsxs(Fragment$2, { children: [o.value === "cancel" && jsx("div", { className: "oui-h-2 oui-bg-base-10" }), jsx(ug, { onClick: (r3) => {
  var _a2, _b2;
  r3.value !== "cancel" && (typeof o.onClick == "function" ? o.onClick(o) : ((_a2 = e3.onValueChange) == null ? void 0 : _a2.call(e3, r3.value), (_b2 = e3.onClose) == null ? void 0 : _b2.call(e3)));
}, index: t, action: o, active: typeof e3.value < "u" && e3.value.value === o.value }), t < e3.actionSheets.length - 1 && jsx(te$6, { className: "oui-border-base-contrast/10" })] }, o.value || t)) }), yi$5 = (e3) => {
  let [o] = A$5("modal"), t = useMemo(() => {
    let r3 = [];
    if (Array.isArray(e3.actionSheets)) for (let i of e3.actionSheets) typeof i == "string" ? i === "Cancel" ? r3.push({ label: o.cancel, value: "cancel", onClick: () => {
      var _a2;
      (_a2 = e3.onClose) == null ? void 0 : _a2.call(e3);
    } }) : i === "Confirm" ? r3.push({ label: o.confirm, value: "confirm" }) : i.startsWith("---") && r3.push({ label: "---", value: "---", type: "division" }) : r3.push(i);
    return r3;
  }, [e3.actionSheets]);
  return jsxs(Go$2, { open: e3.open, onOpenChange: e3.onOpenChange, children: [typeof e3.children < "u" && jsx(hi$2, { asChild: true, children: e3.children }), jsx(lo$4, { closeable: false, className: "oui-action-sheet-content !oui-p-0 oui-pb-[env(safe-area-inset-bottom)]", onOpenAutoFocus: (r3) => r3.preventDefault(), children: jsx(pg, { actionSheets: t, onClose: e3.onClose, onValueChange: e3.onValueChange, value: e3.value }) })] });
};
var Yo$1 = (e3) => {
  let { open: o, onOpenChange: t, classNames: r3, contentProps: i, closable: n4 = true } = e3, a2 = typeof e3.title == "function" ? e3.title() : e3.title;
  return jsx(Go$2, { open: o, onOpenChange: t, children: jsxs(lo$4, { onOpenAutoFocus: (s) => s.preventDefault(), className: r3 == null ? void 0 : r3.content, closeable: n4, ...i, children: [a2 && jsxs(Fragment$1, { children: [jsx(_t$3, { leading: e3.leading, children: jsx(Ht$4, { children: a2 }) }), jsx(te$6, {})] }), jsx(vi$2, { className: r3 == null ? void 0 : r3.body, children: e3.children })] }) });
};
var gg = ae$7((e3) => {
  let { visible: o, onOpenChange: i } = X$5();
  return jsx(Yo$1, { open: o, onOpenChange: i, ...e3, children: e3.content });
}), sl = (e3) => O$6.show(gg, e3);
var bg$1 = ae$7((e3) => {
  let { onOk: o } = e3, { visible: t, hide: r3, onOpenChange: a2 } = X$5(), s = useCallback(() => Promise.resolve().then(o).then(r3), [o]);
  return jsx(mi$3, { open: t, onOpenChange: a2, ...e3, onOk: s });
}), ll = (e3) => O$6.show(bg$1, e3);
var wg = ae$7((e3) => {
  let { visible: o, onOpenChange: n4 } = X$5();
  return jsx(me$4, { title: e3.title, open: o, onOpenChange: n4, size: e3.size, closable: e3.closable, children: e3.content });
}), ul = (e3) => O$6.show(wg, e3);
var cl = ae$7((e3) => {
  let { size: o } = e3, { visible: t, hide: r3, resolve: i, reject: n4, onOpenChange: a2 } = X$5(), [s] = A$5("modal"), { isMobile: l2 } = Ao$6(), u2 = l2 ? "xs" : "sm", p2 = typeof e3.title == "function" ? e3.title() : e3.title;
  return jsx(me$4, { open: t, title: jsx($$4, { size: "base", weight: "semibold", children: p2 }), size: o || u2, classNames: { content: e3.contentClassName, body: e3.bodyClassName, ...e3.classNames }, closable: true, onOpenChange: (d2) => {
    d2 || n4(), a2(d2);
  }, actions: { primary: { label: e3.okLabel ?? s.confirm, className: "oui-text-sm oui-font-semibold oui-w-[100%] oui-h-8", "data-testid": "oui-testid-confirm-dialog-confirm-btn", onClick: () => Promise.resolve().then(() => typeof e3.onOk == "function" ? e3.onOk() : true).then((d2) => {
    i(d2), r3();
  }, (d2) => {
    n4(d2), r3();
  }) }, secondary: { label: e3.cancelLabel ?? s.cancel, className: "oui-text-sm oui-font-semibold oui-w-[100%] oui-h-8", "data-testid": "oui-testid-confirm-dialog-cancel-btn", onClick: () => Promise.resolve().then(() => typeof e3.onCancel == "function" ? e3.onCancel() : Promise.reject("cancel")).then((d2) => {
    i(d2), r3();
  }, (d2) => {
    n4(d2), r3();
  }) } }, children: jsx("div", { className: "oui-text-2xs lg:oui-text-sm", children: e3.content }) });
}), pl = (e3) => O$6.show(cl, e3);
var uo$3 = { create: ae$7, register: ao$2, unregister: Ks, ...O$6, confirm: pl, alert: ll, sheet: sl, dialog: ul };
function yg$1(e3) {
  return uo$3.create((o) => {
    let { visible: t, hide: r3, resolve: i, reject: n4, onOpenChange: a2 } = X$5(), { title: s, size: l2, contentClassName: u2, bodyClassName: p2, closable: d2, classNames: m2, ...c2 } = o;
    return jsx(me$4, { open: t, onOpenChange: a2, size: l2, title: s, closable: d2, classNames: { content: u2, body: p2, ...m2 }, contentProps: { onInteractOutside: (x2) => {
      document.querySelector("#privy-dialog") && x2.preventDefault();
    } }, children: jsx(e3, { ...c2, close: r3, resolve: i, reject: n4 }) });
  });
}
function Pg(e3, o, t) {
  uo$3.register(e3, yg$1(o), t);
}
var Ci$3 = b$2({ slots: { list: ["oui-header-list", "oui-flex", "oui-items-center"], content: ["oui-ring-offset-background", "focus-visible:oui-outline-none", "focus-visible:oui-ring-2", "focus-visible:oui-ring-ring", "focus-visible:oui-ring-offset-2"], trigger: ["oui-tab-trigger", "oui-inline-flex", "oui-items-center", "oui-justify-center", "oui-whitespace-nowrap", "oui-box-content", "oui-font-medium", "oui-text-base-contrast-36 hover:oui-text-base-contrast-54", "oui-ring-offset-background", "oui-transition-all", "oui-space-x-1", "focus-visible:oui-outline-none", "focus-visible:oui-ring-2", "focus-visible:oui-ring-ring", "focus-visible:oui-ring-offset-2", "disabled:oui-pointer-events-none", "disabled:oui-opacity-50"], icon: ["oui-text-inherit"] }, variants: { variant: { text: { list: ["oui-space-x-6", "oui-border-b", "oui-border-line-6", "oui-px-1"], trigger: ["oui-pb-2", "oui-relative", "data-[state=active]:oui-text-base-contrast", "data-[state=active]:after:oui-content-['']", "data-[state=active]:after:oui-block", "data-[state=active]:after:oui-h-[3px]", "data-[state=active]:after:oui-bg-white", "data-[state=active]:after:oui-absolute", "data-[state=active]:after:oui-rounded-full", "data-[state=active]:after:-oui-bottom-0", "data-[state=active]:after:oui-left-0", "data-[state=active]:after:oui-right-0"] }, contained: { list: ["oui-space-x-[6px]"], trigger: ["oui-rounded", "oui-px-3", "oui-bg-base-7 hover:oui-bg-base-5", "oui-text-base-contrast-36", "data-[state=active]:oui-bg-base-5", "data-[state=active]:oui-text-base-contrast"], icon: ["oui-text-inherit"] } }, size: { sm: {}, md: {}, lg: {}, xl: {} } }, compoundVariants: [{ size: "sm", variant: "text", className: { trigger: ["oui-text-sm", "oui-h-5"], icon: ["oui-w-[10px]", "oui-h-[10px]"] } }, { size: "md", variant: "text", className: { trigger: ["oui-text-base", "oui-h-6"], icon: ["oui-w-3", "oui-h-3"] } }, { size: "lg", variant: "text", className: { trigger: ["oui-text-lg", "oui-h-7"], icon: ["oui-w-[14px]", "oui-h-[14px]"] } }, { size: "xl", variant: "text", className: { trigger: ["oui-text-lg", "oui-h-7"], icon: ["oui-w-4", "oui-h-4"] } }, { size: "sm", variant: "contained", className: { list: ["oui-space-x-1"], trigger: ["oui-text-2xs", "oui-h-6"], icon: ["oui-w-[10px]", "oui-h-[10px]"] } }, { size: "md", variant: "contained", className: { trigger: ["oui-text-2xs", "oui-h-7"], icon: ["oui-w-3", "oui-h-3"] } }, { size: "lg", variant: "contained", className: { trigger: ["oui-text-sm", "oui-h-8", "oui-rounded-md"], icon: ["oui-w-[14px]", "oui-h-[14px]"] } }, { size: "xl", variant: "contained", className: { trigger: ["oui-text-base", "oui-h-9", "oui-rounded-md"], icon: ["oui-w-4", "oui-h-4"] } }], defaultVariants: { size: "md", variant: "text" } }), Si$3 = ee$2.Root, Wt$5 = Ce__default.forwardRef(({ className: e3, size: o, variant: t, ...r3 }, i) => {
  let { list: n4 } = Ci$3({ size: o, variant: t });
  return jsx(ee$2.List, { ref: i, className: n4({ className: e3 }), ...r3 });
});
Wt$5.displayName = ee$2.List.displayName;
var Gt$4 = Ce__default.forwardRef(({ className: e3, size: o, children: t, icon: r3, variant: i, ...n4 }, a2) => {
  let { trigger: s, icon: l2 } = Ci$3({ size: o, variant: i });
  return jsxs(ee$2.Trigger, { ref: a2, className: s({ className: e3 }), ...n4, children: [typeof r3 < "u" ? Ce__default.cloneElement(r3, { className: l2(), opacity: 1 }) : null, jsx("span", { children: t })] });
});
Gt$4.displayName = ee$2.Trigger.displayName;
var Yt$2 = Ce__default.forwardRef(({ className: e3, size: o, ...t }, r3) => {
  let { content: i } = Ci$3({ size: o });
  return jsx(ee$2.Content, { ref: r3, className: i({ className: e3 }), ...t });
});
Yt$2.displayName = ee$2.Content.displayName;
var ml = (e3) => (useEffect(() => {
  if (e3.components && Object.keys(e3.components).length) for (let o in e3.components) {
    let t = e3.components[o];
    zo$2({ name: t.displayName ?? `custom-component-${o}`, positions: [o], __isInternal: false })((r3) => jsx(t, { ...r3 }));
  }
}, [e3.components]), e3.children);
var fl$1 = createContext({}), Ri = () => useContext(fl$1), Tg = (e3) => {
  let o = (t, r3) => {
    var _a2;
    return ((_a2 = e3.overrides) == null ? void 0 : _a2[t]) || r3;
  };
  return jsx(fl$1.Provider, { value: { getComponentTheme: o }, children: jsx(ml, { components: e3.components, children: e3.children }) });
};
function xl(e3) {
  let [o, t] = useState(false), [r3, i] = useState(0), [n4, a2] = useState(0);
  return { handleMouseDown: (p2) => {
    e3.current && (t(true), i(p2.pageX - e3.current.offsetLeft), a2(e3.current.scrollLeft));
  }, handleMouseMove: (p2) => {
    if (!o || !e3.current) return;
    p2.preventDefault();
    let m2 = p2.pageX - e3.current.offsetLeft - r3;
    e3.current.scrollLeft = n4 - m2;
  }, handleMouseUp: () => {
    t(false);
  }, isDragging: o };
}
function wl() {
  let [e3, o] = useState(false), [t, r3] = useState(false), i = useRef(null);
  return useEffect(() => {
    if (!i.current) return;
    let a2 = () => {
      let u2 = i.current;
      u2 && (o(u2.scrollLeft > 0), r3(u2.scrollLeft + u2.clientWidth < u2.scrollWidth));
    }, s = new IntersectionObserver((u2) => {
      u2.forEach((p2) => {
        p2.isIntersecting && a2();
      });
    }), l2 = i.current;
    return l2.addEventListener("scroll", a2), s.observe(l2), () => {
      l2.removeEventListener("scroll", a2), s.disconnect();
    };
  }, []), useEffect(() => {
    if (!i.current) return;
    let a2 = new IntersectionObserver((s) => {
      s.forEach((l2) => {
        l2.isIntersecting;
      });
    });
    return a2.observe(i.current), () => {
      a2.disconnect();
    };
  }, []), { containerRef: i, leadingVisible: e3, tailingVisible: t, onScoll: (a2) => {
    var _a2, _b2;
    a2 === "left" ? (_a2 = i.current) == null ? void 0 : _a2.scrollBy({ left: -100, behavior: "smooth" }) : (_b2 = i.current) == null ? void 0 : _b2.scrollBy({ left: 100, behavior: "smooth" });
  } };
}
var Ti = (e3) => {
  let { visible: o, leading: t, tailing: r3, onClick: i } = e3;
  return o ? jsxs("button", { onClick: () => {
    i == null ? void 0 : i(t ? "left" : "right");
  }, className: cnBase(t ? "oui-scroll-indicator-leading" : "oui-scroll-indicator-tailing", "oui-group oui-flex", "oui-absolute oui-top-0 oui-bottom-0", t && "oui-left-0 oui-flex-row-reverse", r3 && "oui-right-0"), children: [jsx("div", { className: cnBase("oui-w-6 oui-h-full", "oui-bg-[linear-gradient(90deg,rgba(var(--oui-color-base-9)_/_0)_0%,rgba(var(--oui-color-base-9)_/_1)_100%)]", t && "oui-rotate-180") }), jsx("div", { className: cnBase("oui-flex oui-justify-center oui-items-center", "oui-w-3 oui-bg-base-9 oui-h-full"), children: jsx(Dg, { className: cnBase("oui-text-base-contrast-54 group-hover:oui-text-base-contrast", t && "oui-rotate-180") }) })] }) : null;
}, Dg = (e3) => jsx("svg", { width: "6", height: "14", viewBox: "0 0 6 14", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...e3, children: jsx("path", { d: "M1.194.025C.944-.026.675-.005.446.15a1.027 1.027 0 0 0-.28 1.406l3.612 5.437L.166 12.43c-.305.459-.177 1.1.28 1.406a1.02 1.02 0 0 0 1.401-.281l3.986-6a1.03 1.03 0 0 0 0-1.125l-3.986-6C1.695.2 1.444.075 1.194.025" }) });
var Di$1 = (e3) => {
  let { containerRef: o, leadingVisible: t, tailingVisible: r3, onScoll: i } = wl(), { handleMouseDown: n4, handleMouseMove: a2, handleMouseUp: s, isDragging: l2 } = xl(o);
  return jsxs("div", { className: cnBase("oui-scroll-indicator", "oui-relative oui-overflow-hidden oui-select-none", e3.className), children: [jsx("div", { ref: o, className: cnBase("oui-overflow-x-scroll oui-hide-scrollbar", l2 ? "oui-cursor-grabbing" : "oui-cursor-grab"), onMouseDown: n4, onMouseMove: a2, onMouseUp: s, onMouseLeave: s, children: e3.children }), jsx(Ti, { leading: true, onClick: i, visible: t }), jsx(Ti, { tailing: true, onClick: i, visible: r3 })] });
};
var Pl = createContext({}), Cl = (e3) => {
  let { getComponentTheme: o } = Ri(), { classNames: t, contentVisible: r3 = true, variant: i, showScrollIndicator: n4, ...a2 } = e3, s = o("tabs", { variant: "contained" }), [l2, u2] = useState({}), p2 = (m2) => {
    u2((c2) => ({ ...c2, [m2.value]: m2 }));
  }, d2 = () => {
    var _a2, _b2;
    let m2 = jsx(Wt$5, { variant: s.variant, size: a2.size, className: cnBase("oui-flex-1 oui-border-0", (_a2 = e3.classNames) == null ? void 0 : _a2.tabsList), children: Object.keys(l2).map((c2) => {
      let x2 = l2[c2];
      return jsx(Gt$4, { value: x2.value, icon: x2.icon, variant: s.variant, size: a2.size, "data-testid": x2.testid, children: x2.title }, c2);
    }) });
    return n4 ? jsx(Di$1, { className: (_b2 = e3.classNames) == null ? void 0 : _b2.scrollIndicator, children: m2 }) : m2;
  };
  return jsxs(Pl.Provider, { value: { registerTab: p2 }, children: [e3.children, jsxs(Si$3, { ...a2, children: [jsxs(z$1, { justify: "between", itemAlign: "center", width: "100%", className: cnBase(s.variant !== "contained" && "oui-border-b oui-border-b-line-6"), children: [e3.leading, d2(), e3.trailing] }), r3 && Object.keys(l2).map((m2) => {
    var _a2;
    let c2 = l2[m2];
    return jsx(Yt$2, { value: c2.value, className: (_a2 = e3.classNames) == null ? void 0 : _a2.tabsContent, children: c2.content }, m2);
  })] })] });
};
Cl.displayName = "Tabs";
var Sl = (e3) => {
  let { title: o, value: t, icon: r3, testid: i } = e3, { registerTab: n4 } = useContext(Pl);
  return useEffect(() => {
    let a2 = { title: o, value: t, icon: r3, testid: i, content: e3.children };
    n4(a2);
  }, [e3.children, o, t]), null;
};
Sl.displayName = "TabPanel";
var Lg = b$2({ base: ["oui-card-root", "oui-card", "oui-rounded-xl", "oui-shadow", "oui-text-base-contrast", "oui-p-6"], variants: { ...ot$4.variants }, defaultVariants: { intensity: 900 } }), $t$7 = Ce__default__default.forwardRef(({ className: e3, intensity: o, ...t }, r3) => jsx("div", { ref: r3, className: Lg({ intensity: o, className: e3 }), ...t }));
$t$7.displayName = "CardBase";
var Zt$3 = Ce__default__default.forwardRef(({ className: e3, ...o }, t) => jsx("div", { ref: t, className: cnBase("oui-card-header oui-flex oui-flex-col oui-space-y-1.5", e3), ...o }));
Zt$3.displayName = "CardHeader";
var qt$3 = Ce__default__default.forwardRef(({ className: e3, ...o }, t) => jsx("h3", { ref: t, className: cnBase("oui-card-header-title oui-font-semibold oui-leading-none oui-tracking-tight oui-text-lg", e3), ...o }));
qt$3.displayName = "CardTitle";
var kl = Ce__default__default.forwardRef(({ className: e3, ...o }, t) => jsx("p", { ref: t, className: cnBase("oui-text-sm oui-text-muted-foreground", e3), ...o }));
kl.displayName = "CardDescription";
var Kt$4 = Ce__default__default.forwardRef(({ className: e3, ...o }, t) => jsx("div", { ref: t, className: cnBase("oui-card-content oui-pt-4", e3), ...o }));
Kt$4.displayName = "CardContent";
var Qt$4 = Ce__default__default.forwardRef(({ className: e3, ...o }, t) => jsx("div", { ref: t, className: e3, ...o }));
Qt$4.displayName = "CardFooter";
var Rl = forwardRef((e3, o) => {
  let { title: t, children: r3, footer: i, classNames: n4, ...a2 } = e3;
  return jsxs($t$7, { ...a2, className: n4 == null ? void 0 : n4.root, ref: o, children: [jsx(Zt$3, { className: n4 == null ? void 0 : n4.header, children: typeof e3.title == "string" ? jsx(qt$3, { children: t }) : t }), jsx(Kt$4, { className: n4 == null ? void 0 : n4.content, children: r3 }), i && jsx(Qt$4, { className: n4 == null ? void 0 : n4.footer, children: i })] });
});
Rl.displayName = "Card";
var _g = oe$6.Root, Hg = oe$6.Trigger, Il = Ce__default.forwardRef(({ className: e3, align: o = "center", sideOffset: t = 4, ...r3 }, i) => jsx(oe$6.Content, { ref: i, align: o, sideOffset: t, className: cnBase("oui-z-[100] oui-w-64 oui-rounded-md oui-bg-base-8 oui-p-3 oui-text-base-contrast oui-shadow-md oui-outline-none data-[state=open]:oui-animate-in data-[state=closed]:oui-animate-out data-[state=closed]:oui-fade-out-0 data-[state=open]:oui-fade-in-0 data-[state=closed]:oui-zoom-out-95 data-[state=open]:oui-zoom-in-95 data-[side=bottom]:oui-slide-in-from-top-2 data-[side=left]:oui-slide-in-from-right-2 data-[side=right]:oui-slide-in-from-left-2 data-[side=top]:oui-slide-in-from-bottom-2", e3), ...r3 }));
Il.displayName = oe$6.Content.displayName;
var Wg = (e3) => {
  let { content: o, open: t, defaultOpen: r3, onOpenChange: i, children: n4, ...a2 } = e3;
  return jsxs(_g, { open: t, defaultOpen: r3, onOpenChange: i, children: [jsx(Hg, { asChild: true, children: n4 }), jsx(oe$6.Portal, { children: jsxs(Il, { ...a2, children: [o, jsx(oe$6.Arrow, { width: 11, height: 5, className: "oui-fill-base-4" })] }) })] });
};
Wg.displayName = "HoverCard";
var Xg = b$2({ base: "oui-flex oui-flex-row oui-items-stretch oui-rounded-md oui-cursor-pointer oui-border oui-border-line-6 oui-bg-line-4 oui-text-base-contrast-54", variants: { size: { sm: "oui-px-2 oui-h-[22px] oui-text-2xs", base: "oui-px-3 oui-h-[40px]", lg: "oui-px-6 oui-py-3" }, fullWidth: { true: "oui-w-full" }, disabled: { true: "oui-opacity-50 oui-cursor-not-allowed" }, color: { base: "oui-text-base-contract", buy: "oui-text-trade-profit", sell: "oui-text-trade-loss" } }, defaultVariants: { size: "base", color: "base" } }), jg$1 = forwardRef(({ size: e3, color: o, value: t, label: r3, placeholder: i, className: n4, options: a2, fullWidth: s, disabled: l2, ...u2 }, p2) => {
  let [d2, m2] = useState(false), c2 = useMemo(() => {
    if (t && t.value) return t;
    if (typeof t == "number" || typeof t == "string") {
      let S2 = a2.find((f2) => f2.value === t);
      if (S2) return S2;
    }
  }, [t, a2]), x2 = useMemo(() => c2 ? c2.label : i || r3 || "", [c2, r3, i]), y2 = useMemo(() => [...a2, "---", "Cancel"], [a2]);
  return jsx(yi$5, { actionSheets: y2, onOpenChange: m2, open: d2, onClose: () => m2(false), value: c2, onValueChange: u2.onValueChange, children: jsxs("div", { className: cnBase("oui-space-x-1 oui-text-base-contrast-54 ", "oui-rounded-md", "oui-bg-base-8", Xg({ size: e3, color: o, fullWidth: s, disabled: l2 || a2.length === 0, className: n4 })), children: [jsx("div", { className: "oui-flex-1 oui-flex oui-justify-start oui-items-center oui-text-inherit oui-text-2xs", children: x2 }), jsx("div", { className: "oui-flex oui-items-center", children: d2 ? jsx(st$2, { size: 14, color: "white" }) : jsx(nt$3, { size: 14, color: "white" }) })] }) });
});
var $g$1 = Bo$3;
$g$1.range = Mo$2;
function Dl(e3, [o, t]) {
  return Math.min(t, Math.max(o, e3));
}
function or$2(e3, o, t) {
  let r3 = t - o;
  if (r3 === 0) return Dl(0, [0, 100]);
  let n4 = 100 / r3 * (e3 - o);
  return Dl(n4, [0, 100]);
}
function Zg(e3, o) {
  return (t) => {
    let r3 = (o[1] - o[0]) / (e3[1] - e3[0]);
    return o[0] + r3 * (t - e3[0]);
  };
}
function zl(e3, o, t) {
  let r3 = e3 / 2, n4 = Zg([0, 50], [0, r3]);
  return (r3 - n4(o) * t) * t;
}
var Qg = b$2({ slots: { root: "oui-relative oui-flex oui-w-full oui-touch-none oui-select-none oui-items-center", thumb: ["oui-block", "oui-h-[10px]", "oui-w-[10px]", "oui-rounded-full", "oui-border-[2px]", "oui-border-primary", "oui-bg-base-6", "oui-shadow", "oui-group", "oui-transition-colors", "focus-visible:oui-outline-none", "focus:oui-shadow-[0_0_0_8px]", "focus:oui-shadow-base-contrast/20", "focus:oui-h-[14px]", "focus:oui-w-[14px]", "data-[disabled]:oui-pointer-events-none", "data-[disabled]:oui-border-base-2", "data-[disabled]:oui-hidden"], track: "oui-relative oui-h-[8px] oui-w-full oui-grow oui-overflow-hidden oui-rounded-full", trackInner: "oui-absolute oui-left-0 oui-right-0 oui-h-[2px] oui-top-[3px]  oui-pointer-events-none oui-bg-base-2", range: "oui-absolute oui-h-[2px] oui-top-[3px] oui-bg-primary data-[disabled]:oui-bg-base-2", mark: "oui-absolute oui-top-[1px] oui-w-[6px] oui-h-[6px] oui-rounded oui-border oui-border-base-2 oui-bg-base-6 oui-pointer-events-none oui-translate-x-[-50%]", tips: ["oui-absolute", "oui-hidden", "oui-rounded", "oui-drop-shadow", "oui-w-[36px]", "oui-h-[19px]", "oui-translate-x-[-12px]", "oui-top-[-28px]", "oui-font-semibold", "oui-text-center", "group-focus:oui-inline-block", "after:oui-block", "after:oui-absolute", "after:oui-bottom-[-8px]", "after:oui-w-0", "after:oui-h-0", "after:oui-border-4", "after:oui-left-1/2", "after:oui-translate-x-[-50%]", "after:oui-border-solid", "after:oui-border-transparent", "after:oui-border-t-inherit", "oui-text-base-5", "oui-text-2xs"] }, variants: { color: { primary: { thumb: ["oui-border-primary", "oui-bg-base-5"], range: "oui-bg-primary", tips: "oui-bg-primary after:oui-border-t-primary" }, primaryLight: { thumb: ["oui-border-primary-light", "oui-bg-base-5"], range: "oui-bg-primary-light", tips: "oui-bg-primary-light after:oui-border-t-primary-light" }, buy: { thumb: ["oui-border-success", "oui-bg-base-5"], range: "oui-bg-success", tips: ["oui-bg-success after:oui-border-t-success"] }, sell: { thumb: ["oui-border-danger", "oui-bg-base-5"], range: "oui-bg-danger", tips: ["oui-bg-danger after:oui-border-t-danger"] } } } }), Ei$1 = Ce__default.forwardRef(({ className: e3, color: o, marks: t, markCount: r3, classNames: i, markLabelVisible: n4, showTip: a2, onValueChange: s, value: l2, ...u2 }, p2) => {
  let { track: d2, range: m2, thumb: c2, root: x2, trackInner: y2, mark: S2, tips: f2 } = Qg({ color: o }), [R2, k2] = Ce__default.useState(l2);
  Ce__default.useEffect(() => {
    k2((v2) => !v2 || (l2 == null ? void 0 : l2.some((N2, W2) => N2 !== v2[W2])) ? l2 : v2);
  }, [l2]);
  let w5 = useMemo(() => {
    if (Array.isArray(t) && t.length > 0) return t;
    let v2 = u2.max;
    if (v2 || (v2 = 100), typeof r3 < "u") {
      let N2 = [], W2 = v2 / r3, he2 = r3 - 1;
      for (let q2 = 0; q2 <= he2; q2++) {
        let h2 = q2 * W2;
        N2.push({ value: h2, label: `${h2}` });
      }
      return N2.push({ value: v2, label: "100" }), N2;
    }
    return [];
  }, [t, r3, u2.max]), I2 = (v2) => {
    k2(v2), s == null ? void 0 : s(v2);
  };
  return jsxs(xe$5.Root, { ref: p2, className: x2({ className: e3 }), value: s ? l2 : R2, onValueChange: s || I2, ...u2, children: [jsxs(xe$5.Track, { className: d2({ className: i == null ? void 0 : i.track }), children: [jsx("div", { className: y2() }), jsx(xe$5.Range, { className: m2({ className: i == null ? void 0 : i.range }) })] }), Array.isArray(w5) && w5.length > 0 && jsx(Jg$1, { value: R2, color: o, marks: w5, isInnerMask: !Array.isArray(t) || t.length === 0, markLabelVisible: n4, disabled: u2.disabled, className: S2(), step: u2.step }), jsx(xe$5.Thumb, { className: c2({ className: cnBase(i == null ? void 0 : i.thumb, "oui-slider-thumb") }), children: a2 && jsx(ef$1, { value: R2, className: f2({ color: o }), max: u2.max ?? 100, min: 0, tipFormatter: u2.tipFormatter }) })] });
});
Ei$1.displayName = xe$5.Root.displayName;
var Jg$1 = (e3) => {
  let { marks: o, value: t, isInnerMask: r3, markLabelVisible: i, className: n4, color: a2 = "primary" } = e3, s = useMemo(() => (t == null ? void 0 : t[0]) ?? 0, [t]), l2 = useMemo(() => {
    if (!(typeof e3.step > "u")) return Math.floor(s / e3.step);
  }, [s, e3.step]), u2 = useMemo(() => {
    switch (a2) {
      case "primary":
        return "oui-border-primary oui-bg-primary";
      case "buy":
        return "oui-border-trade-profit oui-bg-trade-profit";
      case "sell":
        return "oui-border-trade-loss oui-bg-trade-loss";
      case "primaryLight":
        return "oui-border-primary-light oui-bg-primary-light";
    }
  }, [a2]), p2 = useMemo(() => {
    switch (a2) {
      case "primary":
        return "oui-text-primary";
      case "buy":
        return "oui-texttrade-profit";
      case "sell":
        return "oui-text-trade-loss";
      case "primaryLight":
        return "oui-text-primary-light";
    }
  }, [a2]);
  return jsx(Fragment$1, { children: o == null ? void 0 : o.map((d2, m2) => {
    let c2 = or$2(m2, 0, o.length - 1), x2 = zl(6, c2, 1), y2 = r3 ? d2.value : m2, f2 = (r3 ? s >= y2 : (l2 ?? 0) >= y2) && s >= 0 && !e3.disabled ? u2 : "";
    return jsxs(Fragment$2, { children: [jsx("span", { className: cnBase(n4, f2), style: { left: `calc(${c2}% + ${x2}px)` } }), !e3.disabled && i && jsx("span", { "data-testid": `oui-testid-slider-mark-label-${d2.label}`, className: cnBase("oui-absolute oui-top-[16px] oui-text-2xs xl:oui-text-xs oui-text-base-contrast-54 oui-cursor-pointer oui-translate-x-[-50%]", l2 === m2 && p2), style: { left: `calc(${c2}% + ${x2}px)` }, children: d2.label }, m2)] }, m2);
  }) });
}, ef$1 = (e3) => {
  var _a2, _b2;
  let { className: o, min: t, max: r3 } = e3, i = ((_a2 = e3.value) == null ? void 0 : _a2[0]) ?? 0, n4 = or$2(i, t, r3);
  return jsx("span", { className: o, style: { lineHeight: "19px" }, children: ((_b2 = e3.tipFormatter) == null ? void 0 : _b2.call(e3, i, t, r3, n4)) ?? `${n4.toFixed()}%` });
}, Ml = Ce__default.forwardRef((e3, o) => {
  let t = useMemo(() => [e3.value], [e3.value]);
  return jsx(Ei$1, { ...e3, value: t, ref: o, onValueChange: typeof e3.onValueChange == "function" ? (r3) => {
    e3.onValueChange(r3[0]);
  } : void 0, onValueCommit: typeof e3.onValueCommit == "function" ? (r3) => {
    e3.onValueCommit(r3[0]);
  } : void 0 });
});
Ml.displayName = "SingleSlider";
var Bl = Ei$1;
Bl.single = Ml;
var Vi$1 = Ce__default__default.forwardRef((e3, o) => {
  let { opacity: t = 1, viewBox: r3 = "0 0 20 20", ...i } = e3;
  return jsx(g$3, { ref: o, viewBox: r3, ...i, children: jsx("path", { d: "M10 1.628a8.333 8.333 0 1 0-.001 16.666 8.333 8.333 0 0 0 0-16.666m-2.5 5c.212 0 .435.071.598.234L10 8.762l1.9-1.9a.85.85 0 0 1 .6-.234c.213 0 .436.071.6.234a.86.86 0 0 1 0 1.198l-1.902 1.901 1.901 1.9a.86.86 0 0 1 0 1.2.86.86 0 0 1-1.198 0L10 11.158 8.097 13.06a.86.86 0 0 1-1.198 0 .857.857 0 0 1 0-1.198L8.8 9.96l-1.9-1.9a.857.857 0 0 1 0-1.2.84.84 0 0 1 .6-.233", fill: "#FF447C", fillOpacity: t }) });
}), Li = Ce__default__default.forwardRef((e3, o) => {
  let { opacity: t = 1, viewBox: r3 = "0 0 20 20", ...i } = e3;
  return jsx(g$3, { ref: o, viewBox: r3, ...i, children: jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M1.678 10a8.333 8.333 0 1 1 16.667-.001 8.333 8.333 0 0 1-16.667 0m12.477-3.907c.189-.18.448-.26.697-.26s.507.08.697.26c.38.362.38.969 0 1.33l-6.793 6.473a1.033 1.033 0 0 1-1.394 0l-2.911-2.774a.92.92 0 0 1 0-1.33 1.034 1.034 0 0 1 1.395 0l2.213 2.11z", fill: "#00B49E" }) });
}), Ai$1 = Ce__default__default.forwardRef((e3, o) => {
  let { opacity: t = 1, viewBox: r3 = "0 0 20 20", ...i } = e3;
  return jsx(g$3, { ref: o, viewBox: r3, ...i, children: jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M9.167 3.333c0-.46.373-.833.833-.833A7.5 7.5 0 1 1 2.5 10a.833.833 0 0 1 1.667 0A5.834 5.834 0 1 0 10 4.167a.833.833 0 0 1-.833-.834", fill: "#4774F6", fillOpacity: t }) });
});
Vi$1.displayName = "ToasterErrorIcon";
Li.displayName = "ToastSuccessIcon";
Ai$1.displayName = "ToastLoadingIcon";
var nf = (e3) => jsx(Toaster, { toastOptions: { duration: 3e3, success: { iconTheme: { primary: "rgba(123, 220, 138, 1)", secondary: "rgba(25, 14, 44, 1)" }, style: { background: "rgba(40, 46, 58, 1)" } }, loading: { duration: 5e3, style: { background: "rgba(40, 46, 58, 1)" } }, error: { iconTheme: { primary: "rgba(217, 91, 129, 1)", secondary: "rgba(25, 14, 44, 1)" }, style: { background: "rgba(40, 46, 58, 1)" } } }, ...e3, containerClassName: cnBase("!top-[62px] md:!top-[80px] oui-font-semibold", e3.className), children: (o) => jsx(ToastBar, { toast: o, style: { ...o.style, color: "rgba(255, 255, 255, 0.8)", borderRadius: "6px", wordBreak: "break-all", maxWidth: 800, boxShadow: "0px 4px 8px 0px rgba(0, 0, 0, 0.36)" }, children: ({ icon: t, message: r3 }) => {
  let i = t;
  return o.type === "error" ? i = jsx(Vi$1, { className: "w-[16px] h-[16px] md:w-[24px] md:h-[24px]" }) : o.type === "success" ? i = jsx(Li, { size: 20 }) : o.type === "loading" && (i = jsx("div", { className: "oui-animate-rotate-360 oui-rounded-full", children: jsx(Ai$1, { className: "w-[16px] h-[16px] md:w-[24px] md:h-[24px]" }) })), jsxs("div", { className: "oui-flex oui-items-center oui-padding-[12px] md:oui-padding-[16px]", children: [i, jsx("div", { className: "oui-text-base oui-px-[2px]", children: r3 }), jsx("button", { onClick: () => toast$1.dismiss(o.id), className: "oui-hidden md:oui-block", children: jsx(ye$7, { size: 16, className: " oui-text-base-contrast-54" }) })] });
} }) });
function Ll(e3, o) {
  let t = useRef(), r3 = useRef(o);
  r3.current = o, useEffect(() => {
    let i = { root: null, rootMargin: "0px", threshold: 0 }, n4 = (a2) => {
      a2.forEach((s) => {
        var _a2;
        s.isIntersecting && ((_a2 = r3.current) == null ? void 0 : _a2.call(r3));
      });
    };
    return t.current = new IntersectionObserver(n4, i), () => {
      var _a2;
      (_a2 = t.current) == null ? void 0 : _a2.disconnect();
    };
  }, []), useEffect(() => {
    var _a2;
    (_a2 = t.current) == null ? void 0 : _a2.observe(e3.current);
  }, []);
}
var mf = (e3, o) => {
  let t = useRef(null), r3 = useRef(null);
  Ll(t, () => {
    var _a2;
    e3.isLoading || ((_a2 = e3.loadMore) == null ? void 0 : _a2.call(e3));
  });
  let i = useMemo(() => Array.isArray(e3.dataSource) && e3.dataSource.length <= 0, [e3.dataSource]), n4 = useMemo(() => e3.dataSource ? i ? e3.emptyView || jsx(z$1, { direction: "column", height: "100%", itemAlign: "center", justify: "center", mt: 3, children: jsx(At$2, {}) }) : e3.dataSource.map((s, l2) => jsx(Ce__default__default.Fragment, { children: e3.renderItem(s, l2, e3.extraData) }, l2)) : null, [i, e3.dataSource, e3.extraData, e3.emptyView]), a2 = useMemo(() => {
    var _a2;
    return (((_a2 = e3.dataSource) == null ? void 0 : _a2.length) || 0) === 0 || !e3.isLoading ? null : jsx("div", { className: "oui-flex oui-py-2 oui-justify-center oui-items-center", children: jsx(we$5, {}) });
  }, [e3.isLoading, e3.dataSource]);
  return useImperativeHandle(o, () => ({ scroll: (s) => {
    var _a2;
    (_a2 = r3.current) == null ? void 0 : _a2.scroll({ left: s.x, top: s.y, behavior: "smooth" });
  } })), jsxs("div", { style: e3.style, ref: r3, className: cnBase("oui-relative oui-min-h-[180px] oui-custom-scrollbar oui-overflow-auto", e3.className), children: [jsx("div", { className: cnBase("oui-space-y-3 oui-h-full oui-w-full", i && "oui-absolute oui-left-0 oui-right-0 oui-top-0 oui-bottom-0", e3.contentClassName), children: n4 }), jsx("div", { ref: t, className: "oui-relative oui-invisible oui-h-[1px] oui-top-[-300px]" }), a2] });
}, gf = forwardRef(mf);
createContext({});
var Yi = T$1.Root, Xi$1 = T$1.Trigger, kf = T$1.Group, ji = T$1.Portal, Zo$1 = tv({ slots: { content: ["oui-z-50", "oui-min-w-[8rem]", "oui-overflow-hidden", "oui-rounded-xl", "oui-p-1", "oui-bg-base-8", "oui-text-base-contrast", "oui-shadow-md", "oui-border", "oui-border-line-6", "data-[state=open]:oui-animate-in", "data-[state=closed]:oui-animate-out", "data-[state=closed]:oui-fade-out-0", "data-[state=open]:oui-fade-in-0", "data-[state=closed]:oui-zoom-out-95", "data-[state=open]:oui-zoom-in-95", "data-[side=bottom]:oui-slide-in-from-top-2", "data-[side=left]:oui-slide-in-from-right-2", "data-[side=right]:oui-slide-in-from-left-2", "data-[side=top]:oui-slide-in-from-bottom-2"], item: ["oui-relative", "oui-flex", "oui-cursor-default", "oui-select-none", "oui-items-center", "oui-px-2", "oui-py-1.5", "oui-text-sm", "oui-outline-none", "oui-transition-colors", "hover:oui-bg-base-5", "focus:oui-bg-accent", "focus:oui-text-accent-foreground", "data-[disabled]:oui-pointer-events-none", "data-[disabled]:oui-opacity-50"], label: "oui-px-2 oui-py-1.5 oui-text-sm oui-font-semibold", separator: "-oui-mx-1 oui-my-1 oui-h-px oui-bg-muted", shortcut: "oui-ml-auto oui-text-xs oui-tracking-widest oui-opacity-60" }, variants: { size: { xs: { content: "oui-rounded", item: ["oui-px-2", "oui-py-1.5", "oui-h-6", "oui-rounded", "oui-text-2xs"] }, sm: { content: "oui-rounded", item: ["oui-px-2", "oui-py-1.5", "oui-h-6", "oui-rounded", "oui-text-2xs"] }, md: { content: "oui-rounded-md", item: ["oui-px-4", "oui-py-3", "oui-h-6", "oui-rounded"] }, lg: { content: "oui-rounded-lg", item: ["oui-px-4", "oui-py-3", "oui-h-6", "oui-rounded-md"] }, xl: { content: "oui-rounded-xl", item: ["oui-px-4", "oui-py-3", "oui-h-10", "oui-rounded-lg", "oui-text-base"] } }, inset: { true: { item: ["oui-pl-8"], label: ["oui-pl-8"] } } }, defaultVariants: { inset: false, size: "lg" } }), rr$2 = Ce__default.forwardRef(({ className: e3, sideOffset: o = 4, size: t, ...r3 }, i) => {
  let { content: n4 } = Zo$1({ size: t });
  return jsx(T$1.Portal, { children: jsx(T$1.Content, { ref: i, sideOffset: o, className: n4({ className: e3 }), ...r3 }) });
});
rr$2.displayName = T$1.Content.displayName;
var ir$3 = Ce__default.forwardRef(({ className: e3, inset: o, size: t, ...r3 }, i) => {
  let { item: n4 } = Zo$1({ size: t });
  return jsx(T$1.Item, { ref: i, className: n4({ className: e3, inset: o }), ...r3 });
});
ir$3.displayName = T$1.Item.displayName;
var Yl = Ce__default.forwardRef(({ className: e3, inset: o, ...t }, r3) => {
  let { label: i } = Zo$1({ inset: o });
  return jsx(T$1.Label, { ref: r3, className: i({ className: e3 }), ...t });
});
Yl.displayName = T$1.Label.displayName;
var Xl$1 = Ce__default.forwardRef(({ className: e3, ...o }, t) => {
  let { separator: r3 } = Zo$1();
  return jsx(T$1.Separator, { ref: t, className: r3({ className: e3 }), ...o });
});
Xl$1.displayName = T$1.Separator.displayName;
var If = (e3) => {
  let { currentValue: o, menu: t, render: r3, size: i, children: n4, ...a2 } = e3, s = useMemo(() => typeof e3.render == "function" ? e3.menu.map((l2, u2) => {
    var _a2;
    return (_a2 = e3.render) == null ? void 0 : _a2.call(e3, l2, u2);
  }) : e3.menu.map((l2) => jsx(ir$3, { textValue: l2.value, onSelect: (u2) => {
    var _a2;
    (_a2 = e3.onSelect) == null ? void 0 : _a2.call(e3, l2);
  }, size: i, "data-testid": l2.testId, children: jsxs(z$1, { justify: "between", width: "100%", children: [l2.label, o == l2.value && jsx(_$1, { width: 4, height: 4, gradient: "primary", r: "full" })] }) }, l2.value)), [e3.menu, e3.render, o]);
  return jsxs(Yi, { children: [jsx(Xi$1, { asChild: true, children: n4 }), jsx(ji, { children: jsx(rr$2, { onCloseAutoFocus: (l2) => {
    l2.preventDefault();
  }, size: i, ...a2, children: s }) })] });
};
var Mf = memo((e3) => {
  let { value: o, children: t, left: r3 } = e3;
  return useMemo(() => !!(typeof o == "function" ? o() : o), [o]) ? t : r3;
});
var Bf = (e3) => {
  let { value: o, case: t, default: r3, ...i } = e3, n4 = typeof o == "function" ? o() : o;
  if (typeof t == "function") {
    let s = t(n4);
    return s ? jsx(Slot, { children: s, ...i }) : typeof r3 > "u" ? void 0 : jsx(Slot, { children: r3, ...i });
  }
  let a2 = Object.keys(t);
  for (; a2.length; ) {
    let s = a2.pop();
    if (s === n4.toString()) return jsx(Slot, { children: t[s], ...i });
  }
  return jsx(Slot, { children: r3, ...i });
};
var Ef = (e3, o) => typeof e3 > "u" || e3 === null ? o ?? void 0 : e3.charAt(0).toUpperCase() + e3.slice(1);
var $l = {};
lr$4($l, { default: () => Vf });
var Vf = {};
const { merge } = ((_m = (_l = __cjsInterop1__$2) == null ? void 0 : _l.default) == null ? void 0 : _m.__esModule) ? __cjsInterop1__$2.default : __cjsInterop1__$2;
var binance = binanceModule({ options: { lng: "en" } });
var initConfig = (apiKey, options) => {
  const defaultOptions2 = {
    apiKey,
    connect: {
      // autoConnectAllPreviousWallet: true,
      autoConnectLastWallet: true
    },
    wallets: [injectedModule(), binance],
    chains: [],
    appMetadata: {
      name: "Orderly",
      // icon: blocknativeIcon,
      description: "Orderly",
      recommendedInjectedWallets: [
        { name: "Coinbase", url: "https://wallet.coinbase.com/" },
        { name: "MetaMask", url: "https://metamask.io" },
        { name: "Trezor", url: "https://trezor.io/" },
        { name: "Walletconnect", url: "https://walletconnect.com/" },
        { name: "Ledger", url: "https://www.ledger.com/" }
      ],
      agreement: {
        version: "1.0.0",
        termsUrl: "https://www.blocknative.com/terms-conditions",
        privacyUrl: "https://www.blocknative.com/privacy-policy"
      },
      gettingStartedGuide: "https://blocknative.com",
      explore: "https://blocknative.com"
    },
    accountCenter: {
      desktop: {
        enabled: false
      },
      mobile: {
        enabled: false
      }
    },
    theme: "dark"
  };
  const mergedOptions = merge(defaultOptions2, options);
  return init(mergedOptions);
};
var SolanaChains = /* @__PURE__ */ new Map([[WalletAdapterNetwork.Devnet, 901901901], [WalletAdapterNetwork.Mainnet, 900900900]]);
var SolanaContext = createContext({
  network: WalletAdapterNetwork.Devnet,
  endpoint: ""
});
var useSolanaContext = () => {
  const context = useContext(SolanaContext);
  if (context === void 0) {
    throw new Error("useSolanaContext must be used within a SolanaProvider");
  }
  return context;
};
function SolanaProvider({ children, ...props }) {
  const { isMobile } = Ao$6();
  const network = useMemo(() => props.network ?? WalletAdapterNetwork.Devnet, [props.network]);
  const endpoint = useMemo(() => {
    if (network === WalletAdapterNetwork.Mainnet) {
      return props.mainnetRpc ?? "";
    }
    if (network === WalletAdapterNetwork.Devnet) {
      return props.devnetRpc ?? "";
    }
    return "";
  }, [network, props.mainnetRpc, props.devnetRpc]);
  const mobileWalletNotFoundHanlder = (adapter) => {
    console.log("-- mobile wallet adapter", adapter);
    return Promise.reject(new WalletNotReadyError("wallet not ready"));
  };
  const handleSolanaError = (error, adapter) => {
    console.log("-- solanan error", error);
    console.log("-- solana adapter", adapter);
    if (!isMobile && error instanceof WalletNotReadyError) {
      window.open(adapter == null ? void 0 : adapter.url, "_blank");
    }
  };
  const wallets = useMemo(() => {
    let uri = "";
    if (typeof window !== "undefined") {
      const location = l$1().location;
      uri = `${location.protocol}//${location.host}`;
    }
    return props.wallets ?? [
      new PhantomWalletAdapter(),
      new SolanaMobileWalletAdapter({
        addressSelector: createDefaultAddressSelector(),
        appIdentity: {
          uri
        },
        authorizationResultCache: createDefaultAuthorizationResultCache(),
        chain: network,
        onWalletNotFound: mobileWalletNotFoundHanlder
      })
    ];
  }, [props.wallets, network]);
  const contextValue = useMemo(() => ({
    network,
    endpoint
  }), [network, endpoint]);
  return /* @__PURE__ */ Ce__default__default.createElement(SolanaContext.Provider, { value: contextValue }, /* @__PURE__ */ Ce__default__default.createElement(WalletProvider, { wallets, onError: props.onError ?? handleSolanaError }, /* @__PURE__ */ Ce__default__default.createElement(WalletModalProvider, { className: "oui-pointer-events-auto" }, children)));
}
function useSOL() {
  const [wallet, setWallet] = useState(null);
  const { isMobile } = Ao$6();
  const { endpoint, network } = useSolanaContext();
  const { setVisible: setModalVisible, visible } = useWalletModal();
  const { setLedgerAddress } = useStorageLedgerAddress();
  const {
    signMessage,
    signTransaction,
    sendTransaction,
    publicKey,
    wallet: solanaWallet,
    connect: solanaConnect,
    disconnect: solanaDisconnect,
    connecting
  } = useWallet();
  const selectModalVisibleRef = useRef(false);
  const [connected, setConnected] = useState(false);
  const isManual = useRef(false);
  const solanaPromiseRef = useRef({
    walletSelect: null,
    connect: null,
    walletSelectResolve: () => {
    },
    walletSelectReject: () => {
    },
    connectReject: () => {
    },
    connectResolve: () => {
    }
  });
  const ee2 = useEventEmitter();
  const initPromiseRef = () => {
    console.log("-- init solana promise");
    solanaPromiseRef.current.walletSelectResolve = () => {
    };
    solanaPromiseRef.current.walletSelectReject = () => {
    };
    solanaPromiseRef.current.connectReject = () => {
    };
    solanaPromiseRef.current.connectReject = () => {
    };
    solanaPromiseRef.current.connect = null;
    solanaPromiseRef.current.walletSelect = null;
    solanaPromiseRef.current.walletSelect = new Promise((resolve, reject) => {
      solanaPromiseRef.current.walletSelectResolve = resolve;
      solanaPromiseRef.current.walletSelectReject = reject;
    });
    solanaPromiseRef.current.connect = new Promise((resolve, reject) => {
      solanaPromiseRef.current.connectResolve = resolve;
      solanaPromiseRef.current.connectReject = reject;
    });
  };
  const handleSolanaError = (e3) => {
    console.log("solan connect error", e3);
    if (e3 instanceof WalletNotReadyError) {
      if (isMobile) {
        console.log("-- need toast wallet not ready", e3);
        ee2.emit("wallet:connect-error", {
          message: "Please open the wallet app and use the in-app browser."
        });
      }
    }
    solanaDisconnect().then();
  };
  const connect = async () => {
    initPromiseRef();
    isManual.current = true;
    if (!solanaPromiseRef.current) {
      return;
    }
    if (!solanaWallet) {
      setModalVisible(true);
      selectModalVisibleRef.current = true;
    } else {
      solanaPromiseRef.current.walletSelectResolve(solanaWallet);
      if (!publicKey) {
        try {
          await solanaConnect();
        } catch (e3) {
          solanaPromiseRef.current.connectReject(e3);
        }
      } else {
        solanaPromiseRef.current.connectResolve({
          userAddress: publicKey.toBase58(),
          signMessage,
          signTransaction,
          sendTransaction
        });
      }
    }
    console.log("-- connect fn", solanaWallet, publicKey);
    return Promise.all([
      solanaPromiseRef.current.walletSelect,
      solanaPromiseRef.current.connect
    ]).then(([wallet2, { userAddress, signMessage: signMessage2, signTransaction: signTransaction2, sendTransaction: sendTransaction2 }]) => {
      const tempWallet = {
        label: wallet2.adapter.name,
        icon: "",
        provider: {
          rpcUrl: endpoint,
          network,
          signMessage: signMessage2,
          signTransaction: signTransaction2,
          sendTransaction: sendTransaction2
        },
        accounts: [
          {
            address: userAddress
          }
        ],
        chains: [
          {
            id: SolanaChains.get(network),
            namespace: ChainNamespace.solana
          }
        ]
      };
      if (wallet2.adapter.name === "Ledger") {
        setLedgerAddress(userAddress);
      }
      setWallet(tempWallet);
      setConnected(true);
      return [tempWallet];
    }).catch((e3) => {
      console.log("connect solana error", e3);
      handleSolanaError(e3);
      return Promise.reject(e3);
    }).finally(() => {
      isManual.current = false;
    });
  };
  const disconnect = async () => {
    console.log("--- discconnect sol");
    await solanaDisconnect();
    setWallet(null);
    setConnected(false);
    return [];
  };
  const connectedChain = useMemo(() => {
    if (!publicKey) {
      return null;
    }
    return {
      id: network === WalletAdapterNetwork.Mainnet ? 900900900 : 901901901,
      namespace: ChainNamespace.solana
    };
  }, [publicKey]);
  useEffect(() => {
    if (selectModalVisibleRef.current) {
      if (!visible && !solanaWallet && solanaPromiseRef.current) {
        console.log(
          "-- select modal visible ref",
          selectModalVisibleRef.current
        );
        console.log("-- use reject solana select modal");
        solanaPromiseRef.current.walletSelectReject("user reject");
        selectModalVisibleRef.current = false;
      } else if (solanaWallet) {
        selectModalVisibleRef.current = false;
      }
    }
  }, [
    visible,
    solanaWallet,
    solanaPromiseRef.current,
    selectModalVisibleRef.current
  ]);
  useEffect(() => {
    if (!solanaWallet || !publicKey) {
      console.log("--- not connect sol", solanaWallet, publicKey);
      setConnected(false);
      return;
    }
    console.log("-- publick", {
      publicKey: publicKey.toBase58(),
      isManual: isManual.current
    });
    if (isManual.current) {
      if (solanaPromiseRef.current) {
        solanaPromiseRef.current.connectResolve({
          userAddress: publicKey == null ? void 0 : publicKey.toBase58(),
          signMessage,
          signTransaction,
          sendTransaction
        });
      }
      return;
    }
    const userAddress = publicKey.toBase58();
    setWallet({
      label: solanaWallet.adapter.name,
      icon: "",
      provider: {
        signMessage,
        signTransaction,
        sendTransaction,
        rpcUrl: endpoint,
        network
      },
      accounts: [
        {
          address: userAddress
        }
      ],
      chains: [
        {
          id: SolanaChains.get(network),
          namespace: ChainNamespace.solana
        }
      ]
    });
    if (solanaWallet.adapter.name === "Ledger") {
      setLedgerAddress(userAddress);
    }
    setConnected(true);
  }, [
    publicKey,
    solanaWallet,
    signMessage,
    signTransaction,
    isManual,
    sendTransaction,
    endpoint,
    network
  ]);
  useEffect(() => {
    if (!solanaWallet) {
      return;
    }
    console.log("-- public key", publicKey, { isMobile });
    if (isMobile && solanaWallet.readyState === WalletReadyState.Loadable && !isManual.current) {
      solanaDisconnect().then();
      return;
    }
    console.log("-- solana refresh auto connect", solanaWallet);
    if (solanaPromiseRef.current) {
      solanaPromiseRef.current.walletSelectResolve(solanaWallet);
    }
    solanaConnect().then((res) => {
      console.log("-- connect res", res);
    }).catch((e3) => {
      solanaPromiseRef.current.connectReject(e3);
      handleSolanaError(e3);
    });
  }, [
    solanaWallet,
    solanaConnect,
    publicKey,
    solanaDisconnect,
    handleSolanaError,
    isMobile
  ]);
  return {
    connected,
    connect,
    disconnect,
    connecting,
    wallet,
    connectedChain
  };
}
function useEvm() {
  const [
    {
      wallet,
      // the wallet that has been connected or null if not yet connected
      connecting
      // boolean indicating if connection is in progress
    },
    connect,
    // function to call to initiate user to connect wallet
    evmDisconnect,
    // function to call with wallet<DisconnectOptions> to disconnect wallet
    updateBalances,
    // function to be called with an optional array of wallet addresses connected through Onboard to update balance or empty/no params to update all connected wallets
    setWalletModules,
    // function to be called with an array of wallet modules to conditionally allow connection of wallet types i.e. setWalletModules([ledger, trezor, injected])
    setPrimaryWallet
    // function that can set the primary wallet and/or primary account within that wallet. The wallet that is set needs to be passed in for the first parameter and if you would like to set the primary account, the address of that account also needs to be passed in
  ] = useConnectWallet();
  const [
    {
      chains,
      // the list of chains that web3-onboard was initialized with
      connectedChain: evmConnectChain,
      // the current chain the user's wallet is connected to
      settingChain
      // boolean indicating if the chain is in the process of being set
    },
    setChain
    // function to call to initiate user to switch chains in their wallet
  ] = useSetChain();
  const connected = useMemo(() => {
    return !!(wallet && wallet.accounts && wallet.accounts[0] && wallet.accounts[0].address);
  }, [wallet]);
  const disconnect = async () => {
    console.log("-- disconnect evm xxxxxxxxxxxx");
    if (!wallet) {
      return;
    }
    return evmDisconnect({
      label: wallet.label
    });
  };
  const connectedChain = useMemo(() => {
    return evmConnectChain ? { ...evmConnectChain, id: parseInt(evmConnectChain.id) } : null;
  }, [evmConnectChain]);
  const changeChain = (chain) => {
    return setChain(chain);
  };
  return {
    connect,
    connected,
    disconnect,
    connecting,
    wallet,
    connectedChain,
    changeChain
  };
}
function Main(props) {
  const sol = useSOL();
  const evm = useEvm();
  const [namespace, setNamespace] = useState(null);
  const newNamespace = useRef();
  const connect = async (options) => {
    if (Array.from(SolanaChains.values()).includes(options.chainId)) {
      newNamespace.current = ChainNamespace.solana;
      return sol.connect().then((res) => {
        console.log("-- connect sol", res);
        if (res) {
          return res;
        }
      });
    }
    newNamespace.current = ChainNamespace.evm;
    const evmOption = options.autoSelect ? {
      autoSelect: options.autoSelect
    } : void 0;
    return evm.connect(evmOption).then((res) => {
      console.log("-- connect evm", res);
      if (!res.length) {
        return Promise.reject({ message: "user reject" });
      }
      return res;
    }).catch((e3) => {
      console.log("-- connect evm error", e3);
      return Promise.reject(e3);
    });
  };
  const disconnect = async () => {
    if (namespace === ChainNamespace.evm) {
      return evm.disconnect();
    }
    if (namespace === ChainNamespace.solana) {
      return sol.disconnect();
    }
  };
  const connecting = newNamespace.current == ChainNamespace.solana ? sol.connecting : evm.connecting;
  const wallet = namespace === ChainNamespace.solana && sol.connected ? sol.wallet : namespace === ChainNamespace.evm && evm.connected ? evm.wallet : null;
  const connectedChain = namespace === ChainNamespace.solana ? sol.connectedChain : evm.connectedChain;
  const setChain = (chain) => {
    const chainId = typeof chain.chainId === "number" ? chain.chainId : f$5(chain.chainId);
    let tempNamespace = ChainNamespace.evm;
    if (Array.from(SolanaChains.values()).includes(chainId)) {
      tempNamespace = ChainNamespace.solana;
    }
    console.log("--- namespace", {
      namespace,
      tempNamespace
    });
    if (namespace === tempNamespace && namespace === ChainNamespace.evm) {
      return evm.changeChain(chain);
    }
    if (namespace !== tempNamespace) {
      return connect({ chainId }).then();
    }
  };
  useEffect(() => {
    if (sol.connected && evm.connected) {
      if (newNamespace.current === ChainNamespace.solana) {
        evm.disconnect().then();
        setNamespace(ChainNamespace.solana);
        return;
      } else {
        setNamespace(ChainNamespace.evm);
        sol.disconnect().then();
        return;
      }
    }
    if (sol.connected) {
      setNamespace(ChainNamespace.solana);
      return;
    }
    if (evm.connected) {
      setNamespace(ChainNamespace.evm);
      return;
    }
  }, [newNamespace.current, sol.connected, evm.connected]);
  return /* @__PURE__ */ Ce__default__default.createElement(
    WalletConnectorContext.Provider,
    {
      value: {
        connect,
        disconnect,
        connecting,
        wallet,
        setChain,
        connectedChain,
        namespace
      }
    },
    props.children
  );
}
function InitEvm(props) {
  const [initialized, setInitialized] = useState(!!props.skipInit);
  const { get: get2, register } = useSimpleDI();
  useEffect(() => {
    document.body.style.setProperty("--onboard-modal-z-index", "88");
  }, []);
  useEffect(() => {
    if (props.skipInit) {
      return;
    }
    let onboardAPI = get2("onboardAPI");
    if (onboardAPI) {
      console.log("[Orderly SDK]:onboardAPI already initialized");
      setInitialized(true);
      return;
    }
    Promise.all([
      fetchChainInfo("https://testnet-api.orderly.org/v1/public/chain_info"),
      fetchChainInfo("https://api.orderly.org/v1/public/chain_info")
    ]).then(([testChainInfo, mainnetChainInfo]) => {
      const testChains = processChainInfo(testChainInfo);
      const mainnetChains = processChainInfo(mainnetChainInfo);
      let options = props.options || {};
      options = merge({ chains: [...testChains, ...mainnetChains] }, options);
      onboardAPI = initConfig(props.apiKey, options);
      register("onboardAPI", onboardAPI);
      setInitialized(true);
    }).catch((error) => {
      console.error("Error fetching data:", error);
    });
  }, []);
  if (!initialized)
    return null;
  return props.children;
}
var fetchChainInfo = async (url) => {
  const response = await fetch(url);
  if (!response.ok) {
    throw new Error(`Failed to fetch data from ${url}`);
  }
  return response.json();
};
var processChainInfo = (chainInfo) => {
  var _a2, _b2;
  return ((_b2 = (_a2 = chainInfo == null ? void 0 : chainInfo.data) == null ? void 0 : _a2.rows) == null ? void 0 : _b2.map((row) => ({
    id: Number(row.chain_id),
    token: row.currency_symbol,
    label: row.name,
    rpcUrl: row.public_rpc_url,
    blockExplorerUrl: row.explorer_base_url
  }))) || [];
};
function WalletConnectorProvider(props) {
  var _a2;
  return /* @__PURE__ */ Ce__default__default.createElement(SolanaProvider, { ...props.solanaInitial ?? {} }, /* @__PURE__ */ Ce__default__default.createElement(InitEvm, { ...props.evmInitial ?? {} }, /* @__PURE__ */ Ce__default__default.createElement(Main, { solanaNetwork: ((_a2 = props.solanaInitial) == null ? void 0 : _a2.network) ?? WalletAdapterNetwork.Devnet }, props.children)));
}
var h$1 = ((i) => (i.en = "en", i.zh = "zh", i.ja = "ja", i.es = "es", i.ko = "ko", i.vi = "vi", i.de = "de", i.fr = "fr", i.nl = "nl", i.id = "id", i))(h$1 || {}), p = "en", n3 = "translation", w$1 = "orderly_i18nLng";
var v$1 = { "markets.favorites": "Favorites", "markets.recent": "Recent", "markets.newListings": "New listings", "markets.allMarkets": "All markets", "markets.openInterest": "Open interest", "markets.openInterest.tooltip": "Total size of positions per side.", "markets.topGainers": "Top gainers", "markets.topLosers": "Top losers", "markets.search.placeholder": "Search market", "markets.dataList.favorites.empty": "Click on the <0/> icon next to a market to add it to your list.", "markets.dataList.column.8hFunding": "8h funding", "markets.dataList.column.moveTop": "Move to top", "markets.favorites.dropdown.title": "Select lists for", "markets.favorites.dropdown.addPlaceholder": "Add a new watchlist", "markets.favorites.tabs.maxList": "Maximum 10 groups in the favorite list", "markets.favorites.tabs.maxName": "List name cannot exceed 15 characters", "markets.favorites.tabs.delete.dialog.title": "Delete list", "markets.favorites.tabs.delete.dialog.description": "Are you sure you want to delete {{name}}?", "markets.column.market": "Market", "markets.column.24hChange": "24h change", "markets.column.24hVolume": "24h volume", "markets.column.market&Volume": "Market / Volume", "markets.column.price&Change": "Price / change", "markets.column.last": "Last", "markets.column.24hPercentage": "24h%", "markets.funding.comparison": "Comparison", "markets.funding.column.estFunding": "Est. funding", "markets.funding.column.lastFunding": "Last funding", "markets.funding.column.1dAvg": "1D avg.", "markets.funding.column.3dAvg": "3D avg.", "markets.funding.column.7dAvg": "7D avg.", "markets.funding.column.14dAvg": "14D avg.", "markets.funding.column.30dAvg": "30D avg.", "markets.funding.column.90dAvg": "90D avg.", "markets.funding.column.positiveRate": "Positive rate", "markets.symbolInfoBar.Mark": "Mark", "markets.symbolInfoBar.Mark.tooltip": "Price for the computation of unrealized PnL and liquidation.", "markets.symbolInfoBar.Index": "Index", "markets.symbolInfoBar.Index.tooltip": "Average of the last prices across other exchanges.", "markets.symbolInfoBar.24hVolume": "24h volume", "markets.symbolInfoBar.24hVolume.tooltip": "24 hour total trading volume on the Orderly Network.", "markets.symbolInfoBar.predFundingRate": "Pred. funding rate", "markets.symbolInfoBar.predFundingRate.tooltip": "Funding rates are payments between traders who are long and short. When positive, long positions pay short positions funding. When negative, short positions pay long positions." };
var k$2 = { "portfolio.feeTier": "Fee tier", "portfolio.apiKeys": "API Keys", "portfolio.setting": "Setting", "portfolio.overview.availableWithdraw": "Available to withdraw", "portfolio.overview.performance": "Performance", "portfolio.overview.performance.roi": "{{period}} ROI", "portfolio.overview.performance.pnl": "{{period}} PnL", "portfolio.overview.performance.volume": "{{period}} Volume (USDC)", "portfolio.overview.performance.dailyPnl": "Daily PnL", "portfolio.overview.performance.cumulativePnl": "Cumulative PnL", "portfolio.overview.deposits&Withdrawals": "Deposits & Withdrawals", "portfolio.overview.distribution": "Distribution", "portfolio.overview.column.txId": "TxID", "portfolio.overview.column.funding&AnnualRate": "Funding rate / Annual rate", "portfolio.overview.column.paymentType": "Payment type", "portfolio.overview.column.paymentType.paid": "Paid", "portfolio.overview.column.paymentType.received": "Received", "portfolio.overview.column.fundingFee": "Funding fee", "portfolio.overview.distribution.type.referralCommission": "Referral commission", "portfolio.overview.distribution.type.refereeRebate": "Referee rebate", "portfolio.overview.distribution.type.brokerFee": "Broker fee", "portfolio.feeTier.updatedDailyBy": "Updated daily by", "portfolio.feeTier.header.yourTier": "Your tier", "portfolio.feeTier.header.30dVolume": "30D trading volume", "portfolio.feeTier.header.takerFeeRate": "Taker fee rate", "portfolio.feeTier.header.makerFeeRate": "Maker fee rate", "portfolio.feeTier.column.tier": "Tier", "portfolio.feeTier.column.30dVolume": "30 day volume", "portfolio.feeTier.column.30dVolume.above": "Above {{volume}}", "portfolio.feeTier.column.maker": "Maker", "portfolio.feeTier.column.taker": "Taker", "portfolio.apiKey.accountId": "Account ID", "portfolio.apiKey.accountId.copied": "Account id copied", "portfolio.apiKey.uid": "UID", "portfolio.apiKey.secretKey": "Secret key", "portfolio.apiKey.secretKey.copied": "Secret key copied", "portfolio.apiKey.ip": "IP", "portfolio.apiKey.permissions": "Permissions", "portfolio.apiKey.permissions.read": "Read", "portfolio.apiKey.permissions.trading": "Trading", "portfolio.apiKey.description": "Create API keys to suit your trading needs. For your security, don't share your API keys with anyone.", "portfolio.apiKey.readApiGuide": "Read API guide", "portfolio.apiKey.column.apiKey": "API key", "portfolio.apiKey.column.apiKey.copy": "API key copied", "portfolio.apiKey.column.permissionType": "Permission type", "portfolio.apiKey.column.restrictedIP": "Restricted IP", "portfolio.apiKey.column.restrictedIP.copy": "Restricted IP copied", "portfolio.apiKey.column.expirationDate": "Expiration date", "portfolio.apiKey.create.dialog.title": "Create API key", "portfolio.apiKey.create.connectWallet.tooltip": "Please connect wallet before create API key", "portfolio.apiKey.create.signIn.tooltip": "Please sign in before create API key", "portfolio.apiKey.create.enableTrading.tooltip": "Please enable trading before create API key", "portfolio.apiKey.create.wrongNetwork.tooltip": "Please switch to a supported network to create API key", "portfolio.apiKey.create.ipRestriction": "IP restriction (optional)", "portfolio.apiKey.create.ipRestriction.placeholder": "Add IP addresses, separated by commas.", "portfolio.apiKey.created.warning": "Please copy the API secret. Once you close this pop-up, the API secret will be encrypted.", "portfolio.apiKey.created.button.copyApiInfo": "Copy API info", "portfolio.apiKey.apiInfo.copied": "API info copied", "portfolio.apiKey.created": "API key created", "portfolio.apiKey.deleted": "API key deleted", "portfolio.apiKey.updated": "API key updated", "portfolio.apiKey.edit.dialog.title": "Edit API key", "portfolio.apiKey.delete.dialog.title": "Delete API key", "portfolio.apiKey.delete.dialog.description": "Delete your API key <0>{{apiKey}}</0>?", "portfolio.setting.systemUpgrade": "System upgrade", "portfolio.setting.cancelOpenOrders": "Cancel open orders during system upgrade", "portfolio.setting.cancelOpenOrders.description": "During the upgrade period, all open orders will be cancelled to manage your risk in case of high market volatility." };
var P$1 = { "trading.layout": "Layout", "trading.layout.right": "Advanced (right)", "trading.layout.left": "Advanced (left)", "trading.orders.closeAll": "Close All", "trading.hideOtherSymbols": "Hide other symbols", "trading.history": "History", "trading.portfolioSettings": "Portfolio Settings", "trading.portfolioSettings.decimalPrecision": "Decimal Precision for PnL & Notional", "trading.portfolioSettings.unrealPnlPriceBasis": "Unrealized PnL Price Basis", "trading.orderBook": "Order book", "trading.lastTrades": "Last trades", "trading.orderBook.column.value": "Value", "trading.tabs.chart": "Chart", "trading.tabs.trades": "Trades", "trading.tabs.data": "Data", "trading.column.24High": "24h high", "trading.column.24Low": "24h low", "trading.orderBook.sum": "Sum", "trading.orderBook.markPrice.tooltip": "Obtained from a third-party oracle, the mark price is calculated as the median of three prices: the last price, the fair price based on the funding rate basis, and the fair price based on the order books.", "trading.orderBook.spreadRatio.tooltip": "Spread Ratio of the ask1 and bid1.", "trading.faucet.getTestUSDC": "Get test USDC", "trading.faucet.getTestUSDC.success": "{{quantity}} USDC will be added to your balance. Please note this may take up to 3 minutes. Please check back later.", "trading.asset.startTrading": "Start trading", "trading.asset.startTrading.description": "You can deposit assets from various networks", "trading.asset.myAssets": "My Assets", "trading.asset.freeCollateral": "Free collateral", "trading.asset.freeCollateral.tooltip": "Free collateral for placing new orders.", "trading.asset.freeCollateral.formula": "Free collateral = Total balance + Total unsettlement PnL - Total position initial margin", "trading.asset.marginRatio": "Margin ratio", "trading.asset.marginRatio.tooltip": "The margin ratio represents the proportion of collateral relative to the total position value.", "trading.asset.marginRatio.formula": "Account margin ratio = (Total collateral value / Total position notional) * 100%", "trading.asset.unsettledPnl": "Unsettled PnL", "trading.asset.free&TotalCollateral": "Free / Total Collateral", "trading.asset.availableBalance": "Available Balance", "trading.asset.maintenanceMarginRatio": "Maintenance margin ratio", "trading.asset.maintenanceMarginRatio.tooltip": "The minimum margin ratio required to protect your positions from being liquidated. If the Margin ratio falls below the Maintenance margin ratio, the account will be liquidated.", "trading.asset.maintenanceMarginRatio.formula": "Account maintenance margin ratio = Sum(Position notional * Symbol maintenance Margin Ratio)  / Total position notional * 100%", "trading.riskRate": "Risk rate", "trading.riskRate.tooltip": "The Risk rate is used to assess the risk level of an account. When the Risk rate reaches 100%, the account will be liquidated", "trading.riskRate.formula": "Risk rate = Maintenance margin ratio / Margin ratio * 100%", "trading.asset&Margin": "Asset & Margin", "trading.fundingRate.predFundingRate": "Pred. funding rate" };
var b$1 = { "chart.now": "Now" };
var C = { "positions.positionHistory": "Position history", "positions.liquidation": "Liquidation", "positions.closePosition": "Close Position", "positions.column.liqPrice": "Liq. price", "positions.column.liqPrice.tooltip": "Estimated price at which your position will be liquidated. Prices are estimated and depend on multiple factors across all positions.", "positions.column.unrealPnl.tooltip": "Current unrealized profit or loss on your open positions across all widgets calculated using Mark Price.", "positions.column.unrealPnl.priceBasis": "Unrealized PnL Price Basis", "positions.column.margin": "Margin", "positions.column.margin.tooltip": "The minimum equity to keep your position.", "positions.column.margin.formula": "Margin = Position size * Mark price * MMR", "positions.column.close": "Close", "positions.limitClose": "Limit close", "positions.limitClose.description": "You agree closing {{quantity}} {{base}} position at limit price.", "positions.marketClose": "Market close", "positions.marketClose.description": "You agree closing {{quantity}} {{base}} position at market price.", "positions.history.status.closed": "Closed", "positions.history.status.partialClosed": "Partially closed", "positions.history.type.adl": "Adl", "positions.history.type.liquidated": "Liquidated", "positions.history.liquidated.liquidationId": "Liquidation id", "positions.history.liquidated.liquidatorFee": "Liquidator fee", "positions.history.liquidated.insFundFee": "Ins. Fund fee", "positions.history.column.closed": "Closed", "positions.history.column.maxClosed": "Max closed", "positions.history.column.closed&maxClosed": "Closed / Max closed", "positions.history.column.netPnl": "Net PnL", "positions.history.column.timeOpened": "Time opened", "positions.history.column.timeClosed": "Time closed", "positions.history.column.updatedTime": "Updated time", "positions.history.netPnl.fundingFee": "Funding fee", "positions.history.netPnl.tradingFee": "Trading fee", "positions.Liquidation.column.liquidationId": "Liquidation id", "positions.Liquidation.column.insFundTransfer": "Ins. fund transfer", "positions.Liquidation.column.liquidationFee": "Liquidation fee" };
var T = { "orders.orderHistory": "Order history", "orders.status.pending": "Pending", "orders.status.filled": "Filled", "orders.status.partialFilled": "Partial filled", "orders.status.canceled": "Canceled", "orders.status.rejected": "Rejected", "orders.status.incomplete": "Incomplete", "orders.status.completed": "Completed", "orders.status.opened.toast.title": "Order opened", "orders.status.filled.toast.title": "Order filled", "orders.status.canceled.toast.title": "Order canceled", "orders.status.rejected.toast.title": "Order rejected", "orders.status.replaced.toast.title": "Order edited", "orders.column.orderPrice": "Order price", "orders.column.fill&Quantity": "Filled / Quantity", "orders.column.triggerPrice": "Trigger price", "orders.column.orderTime": "Order time", "orders.column.hidden": "Hidden", "orders.editOrder": "Edit order", "order.edit.confirm.quantity": "You agree changing the quantity of {{base}}-PERP order to <0>{{value}}</0>.", "order.edit.confirm.price": "You agree changing the price of {{base}}-PERP order to <0>{{value}}</0>.", "order.edit.confirm.triggerPrice": "You agree changing the trigger price of {{base}}-PERP order to <0>{{value}}</0>.", "orders.cancelOrder": "Cancel order", "orders.cancelOrder.description": "Are you sure you want to cancel your pending order.", "orders.cancelAll": "Cancel all", "orders.pending.cancelAll": "Cancel all pending orders", "orders.pending.cancelAll.description": "Are you sure you want to cancel all of your pending orders?", "orders.tpsl.cancelAll": "Cancel all TP/SL orders", "orders.tpsl.cancelAll.description": "Are you sure you want to cancel all of your TP/SL orders?", "orders.price.greaterThan": "Price can not be greater than {{max}} USDC.", "orders.price.lessThan": "Price can not be less than {{min}} USDC.", "orders.quantity.lessThan": "Quantity should be less than {{quantity}}", "orders.quantity.lessThanPosition": "Quantity should be less than position quantity : {{quantity}}", "orders.history.renew": "Renew", "orders.download.tooltip": "The downloaded data will reflect only the applied filters (e.g., status, time, side, and pagination) and may not include all records." };
var L$5 = { "tpsl.tp": "TP", "tpsl.sl": "SL", "tpsl.tpPrice": "TP Price", "tpsl.slPrice": "SL Price", "tpsl.tpPnl": "TP PnL", "tpsl.slPnl": "SL PnL", "tpsl.tpTrigger": "TP trigger", "tpsl.slTrigger": "SL trigger", "tpsl.pnl": "PnL", "tpsl.offset": "Offset", "tpsl.positionTpsl": "Position TP/SL", "tpsl.entirePosition": "Entire position", "tpsl.estPnl": "Est. PNL", "tpsl.takeProfit": "Take profit", "tpsl.stopLoss": "Stop loss", "tpsl.cancelOrder.description": "Are you sure you want to cancel this TP/SL order?", "tpsl.confirmOrder": "Confirm Order" };
var R$1 = { "share.pnl.sharePnl": "Share PnL", "share.pnl.share.long": "LONG", "share.pnl.share.short": "SHORT", "share.pnl.displayFormat": "PnL display format", "share.pnl.displayFormat.roi&Pnl": "ROI & PnL", "share.pnl.displayFormat.roi": "ROI", "share.pnl.displayFormat.pnl": "PnL", "share.pnl.optionalInfo": "Optional information to share", "share.pnl.optionalInfo.openPrice": "Open price", "share.pnl.optionalInfo.closePrice": "Close price", "share.pnl.optionalInfo.openTime": "Opened at", "share.pnl.optionalInfo.closeTime": "Closed at", "share.pnl.optionalInfo.message": "Your message", "share.pnl.optionalInfo.message.placeholder": "Max 25 characters", "share.pnl.optionalInfo.message.maxLength": "Maximum support of 25 characters", "share.pnl.image.copied": "Image copied", "share.pnl.copy.failed.description": "Browser version outdated, please update in order to copy image to clipboard." };
var I$5 = { "orderEntry.buyLong": "Buy / Long", "orderEntry.sellShort": "Sell / Short", "orderEntry.reduceOnly": "Reduce only", "orderEntry.orderType.limit": "Limit", "orderEntry.orderType.market": "Market", "orderEntry.orderType.limitOrder": "Limit order", "orderEntry.orderType.marketOrder": "Market order", "orderEntry.orderType.stopLimit": "Stop limit", "orderEntry.orderType.stopMarket": "Stop market", "orderEntry.orderType.postOnly": "Post only", "orderEntry.orderType.ioc": "IOC", "orderEntry.orderType.fok": "FOK", "orderEntry.bbo": "BBO", "orderEntry.bbo.counterparty1": "Counterparty 1", "orderEntry.bbo.counterparty5": "Counterparty 5", "orderEntry.bbo.queue1": "Queue 1", "orderEntry.bbo.queue5": "Queue 5", "orderEntry.bbo.disabled.tips": "BBO is not supported when TP/SL, Post-Only, IOC, or FOK is selected.", "orderEntry.estLiqPrice": "Est. liq. price", "orderEntry.disableOrderConfirm": "Disable order confirmation", "orderEntry.orderConfirm": "Order confirm", "orderEntry.hidden": "Hidden", "orderEntry.keepVisible": "Keep visible", "orderEntry.maxBuy": "Max buy", "orderEntry.maxSell": "Max sell", "orderEntry.tpMarkPrice": "TP price (Mark)", "orderEntry.slMarkPrice": "SL price (Mark)", "orderEntry.tpsl.trigger.description": "TP/SL triggers at the specified mark price and executes as a market order.", "orderEntry.estRoi": "Est.ROI", "orderEntry.estPnL": "Est.PnL", "orderEntry.tpsl.tips": "TP/SL triggers at the specified mark price and executes as a market order. By default, it applies to the entire position. Adjust settings in open positions for partial TP/SL.", "orderEntry.orderQuantity.error.required": "Quantity is required", "orderEntry.orderQuantity.error.min": "Quantity must be greater than {{value}}", "orderEntry.orderQuantity.error.max": "Quantity must be less than {{value}}", "orderEntry.orderPrice.error.required": "Price is required", "orderEntry.orderPrice.error.min": "Price must be greater than {{value}}", "orderEntry.orderPrice.error.max": "Price must be less than {{value}}", "orderEntry.triggerPrice.error.required": "Trigger price is required", "orderEntry.triggerPrice.error.min": "Trigger price must be greater than {{value}}", "orderEntry.triggerPrice.error.max": "Trigger price must be less than {{value}}", "orderEntry.tpTriggerPrice.error.min": "TP Price must be greater than {{value}}", "orderEntry.tpTriggerPrice.error.max": "TP Price must be less than {{value}}", "orderEntry.slTriggerPrice.error.min": "SL Price must be greater than {{value}}", "orderEntry.slTriggerPrice.error.max": "SL Price must be less than {{value}}", "orderEntry.total.error.min": "The order value should be greater or equal to {{value}} USDC" };
var x = { "leverage.maxAccountLeverage": "Max account leverage", "leverage.accountLeverage": "Account leverage", "leverage.currentLeverage": "Current leverage", "leverage.maxLeverage": "Max leverage", "leverage.updated": "Leverage updated" };
var A$4 = { "scaffold.footer.operational": "Operational", "scaffold.footer.joinCommunity": "Join our community", "scaffold.footer.poweredBy": "Powered by", "scaffold.maintenance.dialog.title": "System upgrade in progress", "scaffold.maintenance.dialog.description": "Sorry, {{brokerName}} is temporarily unavailable due to a scheduled upgrade. The service is expected to be back by {{endDate}}.", "scaffold.maintenance.tips.description": "{{brokerName}} will be temporarily unavailable for a scheduled upgrade from {{startDate}} to {{endDate}}.", "scaffold.restrictedInfo.description.default": " You are accessing {{brokerName}} from an IP address ({{ip}}) associated with a restricted country." };
var E$1 = { "tradingRewards.rewards": "Rewards", "tradingRewards.subtitle": "Trade with {{brokerName}} to earn esORDER.", "tradingRewards.learnMore": "Learn more here", "tradingRewards.myEstRewards": "My est. rewards", "tradingRewards.epoch": "Epoch", "tradingRewards.epochRewards": "Epoch rewards", "tradingRewards.otherOrderlyDex": "Other Orderly DEX", "tradingRewards.claim": "Claim", "tradingRewards.availableClaim": "Available to claim", "tradingRewards.stake": "Stake", "tradingRewards.booster": "Booster", "tradingRewards.stakeBooster": "Stake booster", "tradingRewards.avgStakedAmount": "Avg. staked amount", "tradingRewards.rewardHistory": "Reward history", "tradingRewards.rewardsEarned": "Rewards earned", "tradingRewards.rewardHistory.column.start&EndDate": "Start / End date", "tradingRewards.rewardHistory.column.startDate": "Start", "tradingRewards.rewardHistory.column.endDate": "End date" };
var S$2 = { "tradingView.timeInterval.1m": "1m", "tradingView.timeInterval.3m": "3m", "tradingView.timeInterval.5m": "5m", "tradingView.timeInterval.15m": "15m", "tradingView.timeInterval.30m": "30m", "tradingView.timeInterval.1h": "1h", "tradingView.timeInterval.2h": "2h", "tradingView.timeInterval.4h": "4h", "tradingView.timeInterval.6h": "6h", "tradingView.timeInterval.12h": "12h", "tradingView.timeInterval.1d": "1D", "tradingView.timeInterval.3d": "3D", "tradingView.timeInterval.1w": "1W", "tradingView.timeInterval.1M": "1M", "tradingView.timeInterval.more": "More", "tradingView.lineType.bars": "Bars", "tradingView.lineType.candles": "Candles", "tradingView.lineType.hollowCandles": "Hollow candles", "tradingView.lineType.line": "Line", "tradingView.lineType.area": "Area", "tradingView.lineType.baseline": "Baseline", "tradingView.displayControl.buySell": "Buy/Sell", "tradingView.displayControl.limitOrders": "Limit orders", "tradingView.displayControl.stopOrders": "Stop orders", "tradingView.noScriptSrc": "Due to TradingView's policy, you will need to apply for your own license.", "tradingView.noScriptSrc.1": "1. Please apply for your TradingView Advanced Chart license <0>here</0>", "tradingView.noScriptSrc.2": "2. Follow the instructions on <0>orderly.network</0> to set up." };
var D$1 = { "connector.testnet": "Testnet", "connector.mainnet": "Mainnet", "connector.disconnect": "Disconnect", "connector.connectWallet": "Connect wallet", "connector.signIn": "Sign in", "connector.signIn.description": "Confirm you are the owner of this wallet", "connector.enableTrading": "Enable trading", "connector.enableTrading.description": "Enable secure access to our API for lightning fast trading", "connector.switchNetwork": "Switch Network", "connector.wrongNetwork": "Wrong network", "connector.wrongNetwork.tooltip": "Please switch to a supported network to continue.", "connector.expired": "Your previous access has expired, you will receive a signature request to enable trading. Signing is free and will not send a transaction.", "connector.rememberMe": "Remember me", "connector.rememberMe.description": "Toggle this option to skip these steps next time you want to trade.", "connector.referralCode.placeholder": "Referral code (Optional)", "connector.referralCode.invalid": "The referral_code must be 4 to 10 characters long, only accept upper case roman characters and numbers", "connector.referralCode.notExist": "This referral code does not exist.", "connector.somethingWentWrong": "Something went wrong", "connector.userRejected": "User rejected the request.", "connector.walletConnected": "Wallet connected", "connector.networkSwitched": "Network switched", "connector.switchChain.failed": "Switch chain failed", "connector.trade.connectWallet.tooltip": "Please connect wallet before starting to trade", "connector.trade.signIn.tooltip": "Please sign in before starting to trade", "connector.trade.enableTrading.tooltip": "Please enable trading before starting to trade", "connector.setUp.connectWallet.tooltip": "Please connect wallet before set up", "connector.setUp.signIn.tooltip": "Please sign in before set up", "connector.setUp.enableTrading.tooltip": "Please enable trading before set up", "connector.ledger.signMessageFailed": "Sign Message Failed", "connector.ledger.signMessageFailed.description": "Are you using Ledger Wallet?", "connector.loginIn": "Login in", "connector.logout": "Log out", "connector.email": "Email", "connector.google": "Google", "connector.twitter": "X / Twitter", "connector.myWallet": "My wallet", "connector.addEvmWallet": "Add Evm wallet", "connector.addSolanaWallet": "Add Solana wallet", "connector.createEvmWallet": "Create Evm wallet", "connector.createSolanaWallet": "Create Solana wallet", "connector.termsOfUse": "By connecting your wallet, you acknowledge and agree to the <0>terms of use</0>.", "connector.supportedEvmChain": "Supported Evm chain", "connector.supportedSolanaChain": "Supported Solana chain", "connector.noWallet": "No wallet", "connector.noWallet.description": "Please create a wallet to proceed. Only you can access the private key. You can export the private key and import your wallet into another wallet client, such as MetaMask or Phantom, at any time." };
var M$3 = { "transfer.network": "Network", "transfer.lowestFee": "lowest fee", "transfer.web3Wallet": "Your Web3 Wallet", "transfer.brokerAccount": "Your {{brokerName}} account", "transfer.quantity.invalid": "Please input a valid number", "transfer.insufficientBalance": "Insufficient balance", "transfer.rejectTransaction": "Rejected transaction", "transfer.deposit.approve.symbol": "Approve {{symbol}}", "transfer.deposit.approve.success": "Approve success", "transfer.deposit.approve.failed": "Approve failed", "transfer.deposit.increase.symbol": "Increase {{symbol}} authorized amount", "transfer.deposit.requested": "Deposit requested", "transfer.deposit.completed": "Deposit completed", "transfer.deposit.failed": "Deposit failed", "transfer.deposit.destinationGasFee": "Destination gas fee", "transfer.deposit.destinationGasFee.description": "Additional gas tokens are required to cover operations on the destination chain.", "transfer.withdraw.unsupported.chain": "Withdrawals are not supported on this chain. Please switch to any of the bridgeless networks.", "transfer.withdraw.unsupported.networkName": "Withdrawals are not supported on {{networkName}}. Please switch to any of the bridgeless networks.", "transfer.withdraw.crossChain.confirmWithdraw": "Confirm to withdraw", "transfer.withdraw.crossChain.recipientAddress": "Recipient address", "transfer.withdraw.crossChain.recipientNetwork": "Recipient network", "transfer.withdraw.crossChain.withdrawAmount": "Withdraw amount", "transfer.withdraw.crossChain.process": "Your cross-chain withdrawal is being processed...", "transfer.withdraw.crossChain.warning": "Withdrawals that require cross-chain rebalancing can't be cancelled or followed up with more withdrawals until they've been processed.", "transfer.withdraw.crossChain.vaultWarning": "Withdrawal exceeds the balance of the {{networkName}} vault ( {{chainVaultBalance}} USDC ). Cross-chain rebalancing fee will be charged for withdrawal to {{networkName}}.", "transfer.withdraw.minAmount.error": "quantity must large than {{minAmount}}", "transfer.withdraw.requested": "Withdraw requested", "transfer.withdraw.completed": "Withdraw completed", "transfer.withdraw.failed": "Withdraw failed" };
var O$5 = { "affiliate.referral": "Referral", "affiliate.trader": "Trader", "affiliate.enter": "Enter", "affiliate.statistics": "Statistics", "affiliate.connectWallet.tooltip": "Please connect your wallet to use this function", "affiliate.page.title": "Earn more as a <0>{{shortBrokerName}}</0> affiliate", "affiliate.page.subTitle": "Grow your brand | Get 40% commission | Unlock exclusive perks", "affiliate.page.learnMore": "Learn how it works", "affiliate.asAffiliate.title": "As an affiliate", "affiliate.asAffiliate.description": "Onboard traders to earn passive income", "affiliate.asAffiliate.button": "Become an affiliate", "affiliate.asTrader.title": "As a trader", "affiliate.asTrader.description": "Onboard traders to earn passive income", "affiliate.asTrader.button": "Enter code", "affiliate.referralCode": "Referral code", "affiliate.referralCode.dialog.title": "Bind a referral code", "affiliate.referralCode.dialog.description": "Bind a referral code to earn trading fee rebates.", "affiliate.referralCode.label": "Enter referral code", "affiliate.referralCode.bound": "Referral code bound", "affiliate.referralCode.notExist": "This referral code does not exist.", "affiliate.process.title": "Becoming an affiliate is easy", "affiliate.process.step1.title.title": "Apply", "affiliate.process.step1.description": "Fill out the application form", "affiliate.process.step2.title": "Share", "affiliate.process.step2.description": "Unlock your affiliate link and share it with your community", "affiliate.process.step3.title": "Earn", "affiliate.process.step3.description": "Get paid and receive special treatment 24/7, 365", "affiliate.summary": "Summary", "affiliate.summary.refereesTraded": "Referees that traded", "affiliate.referralLink": "Referral link", "affiliate.referralLink.earn": "Earn", "affiliate.referralLink.earn.tooltip": "{{brokerName}} net fee that deduct Orderly fee.", "affiliate.referralLink.share": "Share", "affiliate.referralLink.share.tooltip": "Your referees get <0>{{value}}</0> of their {{brokerName}} net fee", "affiliate.referralVol": "Referral vol.", "affiliate.referralCodes": "Referral codes", "affiliate.referralCodes.remaining": "Remaining referral codes", "affiliate.referralCodes.column.you&Referee": "You / Referee", "affiliate.referralCodes.column.traders": "Traders", "affiliate.referralCodes.column.referees&Traders": "Referees / Traders", "affiliate.referralCodes.copyLink": "Copy link", "affiliate.commission": "Commission", "affiliate.commission.30d": "30d commission", "affiliate.commission.column.activeUsers": "Referral active users", "affiliate.myReferees": "My referees", "affiliate.referees": "Referees", "affiliate.referees.column.refereeAddress": "Referee address", "affiliate.referees.column.totalCommission": "Total commission", "affiliate.referees.column.totalVol": "Total vol.", "affiliate.referees.column.invitationTime": "Invitation time", "affiliate.trader.yourReferrer": "Your referrer", "affiliate.trader.rebate": "Rebate", "affiliate.trader.rebates": "Rebates", "affiliate.trader.myRebates": "My rebates", "affiliate.trader.tradingVol": "Trading vol." };
var q$1 = { "ui.pagination.morePages": "More pages", "ui.pagination.rowsPerPage": "Rows per page", "ui.picker.selectDate": "Select Date", "ui.empty.description": "No results found." };
var V$4 = { "tradingLeaderboard.leaderboard": "Leaderboard", "tradingLeaderboard.campaigns": "Campaigns", "tradingLeaderboard.ongoing": "Ongoing", "tradingLeaderboard.past": "Past", "tradingLeaderboard.future": "Future", "tradingLeaderboard.learnMore": "Learn more", "tradingLeaderboard.tradeNow": "Trade now", "tradingLeaderboard.tradingVolume": "Trading volume", "tradingLeaderboard.rank": "Rank" };
var d$2 = { "common.cancel": "Cancel", "common.confirm": "Confirm", "common.ok": "OK", "common.yes": "Yes", "common.no": "No", "common.all": "All", "common.buy": "Buy", "common.sell": "Sell", "common.edit": "Edit", "common.save": "Save", "common.add": "Add", "common.delete": "Delete", "common.tips": "Tips", "common.max": "Max", "common.download": "Download", "common.copy": "Copy", "common.copy.failed": "Copy failed", "common.copy.copied": "Copied", "common.share": "Share", "common.export": "Export", "common.select.1d": "1D", "common.select.3d": "3D", "common.select.7d": "7D", "common.select.14d": "14D", "common.select.30d": "30D", "common.select.90d": "90D", "common.price": "Price", "common.quantity": "Quantity", "common.qty": "Qty", "common.status": "Status", "common.status.all": "All status", "common.date": "Date", "common.time": "Time", "common.volume": "Volume", "common.total": "Total", "common.symbol": "Symbol", "common.token": "Token", "common.amount": "Amount", "common.side": "Side", "common.side.all": "All sides", "common.type": "Type", "common.notional": "Notional", "common.fee": "Fee", "common.avgPrice": "Avg. price", "common.avgOpen": "Avg. open", "common.avgClose": "Avg. close", "common.trigger": "Trigger", "common.lastPrice": "Last price", "common.indexPrice": "Index price", "common.markPrice": "Mark price", "common.limitPrice": "Limit price", "common.marketPrice": "Market", "common.unrealizedPnl": "Unrealized PnL", "common.realizedPnl": "Realized PnL", "common.totalValue": "Total value", "common.address": "Address", "common.address.search.placeholder": "Search address", "common.available": "Available", "common.overview": "Overview", "common.funding": "Funding", "common.assets": "Assets", "common.countdown": "Countdown", "common.current": "Current", "common.account": "Account", "common.deposit": "Deposit", "common.withdraw": "Withdraw", "common.settle": "Settle", "common.markets": "Markets", "common.portfolio": "Portfolio", "common.positions": "Positions", "common.position": "Position", "common.orders": "Orders", "common.tpsl": "TP/SL", "common.leverage": "Leverage", "common.affiliate": "Affiliate", "common.tradingRewards": "Trading rewards", "common.trading": "Trading", "common.language": "Language", "assetHistory.status.pending": "Pending", "assetHistory.status.confirm": "Confirm", "assetHistory.status.processing": "Processing", "assetHistory.status.completed": "Completed", "assetHistory.status.failed": "Failed", "assetHistory.status.pendingRebalance": "Pending rebalance", "linkDevice.createQRCode.loading.description": "Approve QR code with wallet...", "linkDevice.createQRCode.linkMobileDevice": "Link Mobile Device", "linkDevice.createQRCode.linkMobileDevice.description": "Open {{hostname}} on your mobile device and scan the QR code to link this wallet. For security, the QR code will expire in 60 seconds. <br/> The QR code allows mobile trading but does not enable withdrawals. Ensure you are not sharing your screen or any screenshots of the QR code.", "linkDevice.createQRCode.success.description": "Scan the QR code or paste the URL into another browser/<br/>device to continue.", "linkDevice.createQRCode.success.copyUrl": "Copy URL", "linkDevice.scanQRCode": "Scan QR Code", "linkDevice.scanQRCode.description": "Click the <0/> icon in the top right corner on desktop to generate a QR code to scan.", "linkDevice.scanQRCode.tooltip": "Link to Desktop via QR Code", "linkDevice.scanQRCode.connected.description": "You are connected via another device. This mode is for trading only. To switch networks, deposit or withdraw assets, please disconnect and reconnect your wallet on this device.", "settle.settlePnl": "Settle PnL", "settle.settlePnl.warning": "Please settle your balance", "settle.settlePnl.description": "Are you sure you want to settle your PnL? <br/> Settlement will take up to 1 minute before you can withdraw your available balance.", "settle.unsettled": "Unsettled", "settle.unsettled.tooltip": "Unsettled balance can not be withdrawn. In order to withdraw, please settle your balance first.", "settle.settlement.requested": "Settlement requested", "settle.settlement.completed": "Settlement completed", "settle.settlement.failed": "Settlement failed", "settle.settlement.error": "Settlement is only allowed once every 10 minutes. Please try again later.", ...v$1, ...k$2, ...P$1, ...b$1, ...C, ...T, ...L$5, ...R$1, ...I$5, ...x, ...A$4, ...E$1, ...S$2, ...D$1, ...M$3, ...O$5, ...q$1, ...V$4 };
var U$4 = { [p]: { [n3]: d$2 } }, Q$3 = new W$3(null, { lookupLocalStorage: w$1 }), K$2 = createInstance({ fallbackLng: p, interpolation: { escapeValue: false }, resources: U$4 }).use(Q$3);
K$2.init();
var e2 = K$2;
var f$2 = createContext({ languages: [] }), Y$3 = () => useContext(f$2);
function Z$2(r3, o) {
  let t = useContext(I18nContext);
  return useTranslation(r3, { i18n: (t == null ? void 0 : t.i18n) || e2, ...o });
}
function oe$4() {
  let [r3, o] = useState(e2.language);
  return useEffect(() => {
    let t = (s) => {
      o(s);
    };
    return e2.on("languageChanged", t), () => {
      e2.off("languageChanged", t);
    };
  }, [e2]), r3;
}
var O$4 = () => {
  useEffect(() => {
    let r3 = new URLSearchParams(window.location.search).get("ref");
    r3 && localStorage.setItem("referral_code", r3);
  }, []);
};
var N$1 = "orderly:wallet-info";
function _() {
  let { connectedChain: e3, disconnect: r3 } = useWalletConnector(), [s, o] = useLocalStorage("orderly_link_device", {}), { account: n4 } = useAccount(), { isMobile: t } = Ao$6(), d2 = useConfig(), i = async (a2) => {
    localStorage.removeItem(N$1), await n4.disconnect(), await r3({ label: a2 });
  };
  useEffect(() => {
    let a2 = b(), u2 = JSON.parse(localStorage.getItem(N$1) ?? "{}");
    a2 && u2 && i(u2.label);
  }, []);
  let l2 = async () => {
    let a2 = b();
    if (!a2) return;
    let { address: u2, secretKey: p2, chainId: g2, chainNamespace: h2 } = a2;
    if (!await n4.importOrderlyKey({ address: u2, secretKey: p2, chainNamespace: h2 })) return;
    o({ chainId: g2, chainNamespace: h2 });
    let S2 = new URL(window.location.href);
    S2.searchParams.delete("link");
    let w5 = decodeURIComponent(S2.toString());
    history.replaceState(null, "", w5);
  };
  useEffect(() => {
    t && !e3 && l2();
  }, [n4, e3, t]);
  let c2 = async () => {
    let { chainId: a2, chainNamespace: u2 } = he$5() || {};
    if (t && !e3 && a2 && u2) {
      let p2 = n4.keyStore.getAddress(), g2 = n4.keyStore.getOrderlyKey(), h2 = n4.keyStore.getAccountId(p2);
      await n4.checkOrderlyKey(p2, g2, h2) && d2.set("chainNamespace", u2);
    }
  };
  return useEffect(() => {
    c2();
  }, [n4, t, e3]), { linkDevice: l2 };
}
function he$5() {
  try {
    let e3 = localStorage.getItem("orderly_link_device");
    return e3 ? parseJSON(e3) : null;
  } catch {
  }
}
function b() {
  let r3 = new URL(window.location.href).searchParams.get("link");
  if (!r3) return;
  let { a: s, k: o, i: n4, n: t } = ye$6(r3) || {};
  if (s && o && n4 && t) return { address: s, secretKey: o, chainId: n4, chainNamespace: t };
}
function ye$6(e3) {
  try {
    let r3 = JSON.parse(window.atob(e3)), s = Math.floor(Date.now() / 1e3), o = r3.t;
    return !o || s > o ? void 0 : r3;
  } catch {
  }
}
var U$3 = "orderly:wallet-info";
var q = (e3) => {
  let { wallet: r3, connect: s, connectedChain: o, disconnect: n4, namespace: t } = useWalletConnector();
  if (typeof s != "function") throw new SDKError("Please provide a wallet connector provider");
  useEventEmitter();
  let i = useRef(false);
  useConfig("brokerId");
  let { account: c2, state: a2 } = useAccount(), u2 = useKeyStore(), p2 = useConfig("networkId"), [g2, { checkChainSupport: h2 }] = useChains(), [k2, S2] = useState(false), { track: w5, setTrackUserId: ie2 } = useTrack(), E3 = useMemo(() => {
    var _a2, _b2;
    return (_b2 = (_a2 = r3 == null ? void 0 : r3.accounts) == null ? void 0 : _a2[0]) == null ? void 0 : _b2.address;
  }, [r3]), P2 = useMemo(() => {
    var _a2, _b2, _c2, _d2;
    let m2 = (_b2 = (_a2 = r3 == null ? void 0 : r3.chains) == null ? void 0 : _a2[0]) == null ? void 0 : _b2.id, f2 = (_d2 = (_c2 = r3 == null ? void 0 : r3.chains) == null ? void 0 : _c2[0]) == null ? void 0 : _d2.namespace;
    if (!(typeof m2 > "u")) return { id: z$2(m2), namespace: f2 };
  }, [r3]);
  return useEffect(() => {
    a2.status >= AccountStatusEnum.EnableTrading && c2.accountId && ie2(c2.accountId);
  }, [c2, a2]), useEffect(() => {
    if (!o) {
      S2(false);
      return;
    }
    let m2 = h2(o.id, p2);
    S2(!m2);
  }, [o, g2, h2, p2]), useEffect(() => {
    w$4(() => {
      let m2 = u2.getAddress(), f2 = JSON.parse(localStorage.getItem(U$3) ?? "{}");
      (o == null ? void 0 : o.namespace) !== ChainNamespace.solana && m2 && c2.address !== m2 && f2.label && s({ autoSelect: { label: f2.label, disableModals: true } }).then((x2) => {
      }, (x2) => {
      });
    });
  }, [r3, c2.address]), useEffect(() => {
    if (r3 === null && a2.status > AccountStatusEnum.NotConnected && !a2.validating) {
      c2.disconnect();
      return;
    }
    if (k2 || !o || i.current) return;
    let m2 = b();
    E3 && E3 !== c2.address && !m2 && (c2.setAddress(E3, { provider: r3 == null ? void 0 : r3.provider, chain: { id: h$2(P2.id), namespace: P2.namespace.toUpperCase() }, wallet: { name: (r3 == null ? void 0 : r3.label) ?? "" } }), w5(EnumTrackerKeys.walletConnect, { wallet: (r3 == null ? void 0 : r3.label) ?? "", network: P2.namespace.toUpperCase() }), w$4(() => {
      localStorage.setItem(U$3, JSON.stringify({ label: (r3 == null ? void 0 : r3.label) ?? "" }));
    })), (P2 == null ? void 0 : P2.id) !== c2.chainId && c2.switchChainId(P2 == null ? void 0 : P2.id);
  }, [r3, o, E3, P2, c2.address, a2, c2.chainId, k2]), { connectWallet: async () => (i.current = true, s({ chainId: e3.currentChainId }).then(async (m2) => {
    if (Array.isArray(m2) && m2.length > 0 && m2[0] && m2[0].accounts.length > 0) {
      let f2 = m2[0], x2 = h$2(f2.chains[0].id);
      if (!h2(x2, p2)) return { wrongNetwork: true };
      if (!c2) throw new Error("account is not initialized");
      a2.status === AccountStatusEnum.EnableTradingWithoutConnected && (localStorage.removeItem("orderly_link_device"), await c2.disconnect());
      let ce2 = await c2.setAddress(f2.accounts[0].address, { provider: f2.provider, chain: { id: h$2(f2.chains[0].id), namespace: f2.chains[0].namespace.toUpperCase() }, wallet: { name: f2.label } });
      return w5(EnumTrackerKeys.walletConnect, { wallet: f2.label, network: f2.chains[0].namespace.toUpperCase() }), { wallet: f2, status: ce2, wrongNetwork: false };
    }
    return null;
  }).finally(() => {
    i.current = false;
  })), wrongNetwork: k2 };
};
function Q$2() {
  let { t: e3 } = Z$2(), r3 = useEventEmitter(), s = useRef({}), [o, n4] = useSessionStorage("orderly_wallet_change_id", {});
  s.current = o, useWalletSubscription({ onMessage: (t) => {
    let { id: d2, side: i, transStatus: l2 } = t, c2 = true;
    if (["DEPOSIT", "WITHDRAW"].includes(i) && ["COMPLETED", "FAILED"].includes(l2)) {
      let a2 = s.current[d2];
      n4({ ...o, [d2]: a2 ? void 0 : true }), c2 = !a2;
    }
    if (l2 === "COMPLETED" && c2) {
      let a2 = `${U$5(i)} completed`;
      i === "DEPOSIT" ? a2 = e3("transfer.deposit.completed") : i === "WITHDRAW" && (a2 = e3("transfer.withdraw.completed")), toast$2.success(a2);
    } else if (l2 === "FAILED" && c2) {
      let a2 = `${U$5(i)} failed`;
      i === "DEPOSIT" ? a2 = e3("transfer.deposit.failed") : i === "WITHDRAW" && (a2 = e3("transfer.withdraw.failed")), toast$2.error(a2);
    }
    r3.emit("wallet:changed", t);
  } });
}
function z() {
  let { t: e3 } = Z$2();
  useSettleSubscription({ onMessage: (r3) => {
    let { status: s } = r3;
    switch (s) {
      case "COMPLETED":
        toast$2.success(e3("settle.settlement.completed"));
        break;
      case "FAILED":
        toast$2.error(e3("settle.settlement.failed"));
        break;
    }
  } });
}
function B$5() {
  let { t: e3 } = Z$2(), r3 = useEventEmitter(), { setLedgerAddress: s } = useStorageLedgerAddress();
  return useEffect(() => {
    r3.on("wallet:connect-error", (o) => {
      toast$2.error(o.message);
    }), r3.on("wallet:sign-message-with-ledger-error", (o) => {
      window.setTimeout(() => {
        uo$3.confirm({ title: e3("connector.ledger.signMessageFailed"), content: e3("connector.ledger.signMessageFailed.description"), size: "sm", onOk: async () => (s(o.userAddress), Promise.resolve()), okLabel: e3("common.ok"), onCancel: async () => (toast$2.error(o.message), Promise.resolve()), cancelLabel: e3("common.no") }).then((n4) => {
        });
      });
    });
  }, [r3, e3]), {};
}
function V$3(e3) {
  let { storageChain: r3, setStorageChain: s } = useStorageChain(), [o, n4] = useState(), [t] = useChains(), d2 = useConfig("networkId"), { connectedChain: i } = useWalletConnector();
  return useEffect(() => {
    var _a2, _b2, _c2;
    if (i) n4 == null ? void 0 : n4(typeof i.id == "number" ? i.id : parseInt(i.id));
    else {
      if (o) return;
      let l2, c2 = d2 === "mainnet" ? (_a2 = t.mainnet) == null ? void 0 : _a2[0] : (_b2 = t.testnet) == null ? void 0 : _b2[0];
      typeof e3 == "function" ? l2 = e3(d2, t) : typeof e3 == "object" && (l2 = d2 === "mainnet" ? e3 == null ? void 0 : e3.mainnet : e3 == null ? void 0 : e3.testnet);
      let a2 = (l2 == null ? void 0 : l2.id) || ((_c2 = c2 == null ? void 0 : c2.network_infos) == null ? void 0 : _c2.chain_id);
      if (!a2) return;
      r3 ? n4 == null ? void 0 : n4(r3.chainId) : (s(a2), n4 == null ? void 0 : n4(a2));
    }
  }, [i, t, o, d2, n4, e3]), [o, n4];
}
var Y$2 = createContext({}), L$4 = () => useContext(Y$2), j$2 = (e3) => {
  let [r3, s] = useState(false), [o, n4] = V$3(e3.defaultChain);
  _(), useTrackingInstance();
  let { connectWallet: t, wrongNetwork: d2 } = q({ currentChainId: o });
  Q$2(), z(), B$5();
  let i = useRestrictedInfo(e3.restrictedInfo), l2 = i.restrictedOpen;
  return jsx(Y$2.Provider, { value: { connectWallet: t, wrongNetwork: d2, currentChainId: o, setCurrentChainId: n4, onChainChanged: e3.onChainChanged, disabledConnect: l2, restrictedInfo: i, showAnnouncement: r3, setShowAnnouncement: s }, children: e3.children });
};
var G$5 = createContext({}), rr$1 = () => useContext(G$5), X$4 = (e3) => jsx(G$5.Provider, { value: e3, children: e3.children });
function sr(e$1) {
  return e$1 === "BUY" ? e2.t("common.buy") : e$1 === "SELL" ? e2.t("common.sell") : U$5(e$1);
}
function ee$1(e$1, r3) {
  let { symbol: s, side: o, quantity: n4 } = e$1, t = "total_executed_quantity" in e$1 ? e$1.total_executed_quantity : 0, d2 = "status" in e$1 ? e$1.status : e$1.algo_status, i = r3[s], l2 = i("base_dp"), c2 = sr(o), a2 = j$3(s), u2 = "algo_type" in e$1 && e$1.algo_type === AlgoOrderRootType.POSITIONAL_TP_SL ? e2.t("tpsl.entirePosition") : l2 === void 0 ? n4 : fr$5(n4, { dp: l2 }), p2 = "", g2 = "";
  switch (d2) {
    case OrderStatus.NEW:
      p2 = e2.t("orders.status.opened.toast.title"), g2 = `${c2} ${a2} ${u2}`;
      break;
    case OrderStatus.FILLED:
    case OrderStatus.PARTIAL_FILLED:
      let h2 = l2 === void 0 ? t : fr$5(t, { dp: l2 });
      p2 = e2.t("orders.status.filled.toast.title"), g2 = `${c2} ${a2} ${h2} / ${u2}`;
      break;
    case OrderStatus.CANCELLED:
      p2 = e2.t("orders.status.canceled.toast.title"), g2 = `${c2} ${a2} ${u2}`;
      break;
    case OrderStatus.REJECTED:
      p2 = e2.t("orders.status.rejected.toast.title"), g2 = `${c2} ${a2} ${u2}`;
      break;
    case OrderStatus.REPLACED:
      p2 = e2.t("orders.status.replaced.toast.title"), g2 = `${o} ${a2} ${t} / ${u2}`;
      break;
  }
  return { title: p2, msg: g2 };
}
function oe$3() {
  let e3 = useEventEmitter(), r3 = useSymbolsInfo(), s = useRef({});
  useEffect(() => {
    s.current = r3;
  }, [r3]);
  let o = useDebouncedCallback((n4) => {
    ((d2) => {
      let { title: i, msg: l2 } = ee$1(d2, s.current);
      i && l2 && toast$2.success(jsxs("div", { children: [i, jsx("br", {}), jsx("div", { className: "orderly-text-white/[0.54] orderly-text-xs", children: l2 })] }));
    })(n4);
  }, 100);
  useEffect(() => (e3.on("orders:changed", o), () => {
    e3.off("orders:changed", o);
  }), []);
}
function ae$6() {
  let { t: e3 } = Z$2(), r3 = oe$4();
  return useMemo(() => {
    let s = { [h$1.en]: enUS, [h$1.zh]: zhCN };
    return { locale: r3, dialog: { ok: e3("common.ok"), cancel: e3("common.cancel") }, modal: { confirm: e3("common.confirm"), cancel: e3("common.cancel") }, pagination: { morePages: e3("ui.pagination.morePages"), rowsPerPage: e3("ui.pagination.rowsPerPage") }, picker: { selectDate: e3("ui.picker.selectDate"), dayPicker: s[r3] }, empty: { description: e3("ui.empty.description") } };
  }, [e3, r3]);
}
var se$3 = (e3) => {
  let { components: r3, appIcons: s, onChainChanged: o, defaultChain: n4, ...t } = e3;
  useTrack(), O$4(), oe$3();
  let d2 = ae$6();
  return jsx(X$4, { appIcons: s, brokerName: e3.brokerName, children: jsx(Tg, { components: r3, overrides: e3.overrides, children: jsxs(OrderlyConfigProvider, { ...t, children: [jsx(j$2, { onChainChanged: o, defaultChain: n4, restrictedInfo: e3.restrictedInfo, children: jsx(cd$1, { locale: d2, children: jsx(zp, { delayDuration: 300, children: jsx($m$1, { children: e3.children }) }) }) }), jsx(nf, {})] }) }) });
};
se$3.displayName = "OrderlyAppProvider";
var xr$2 = (e3, r3) => {
  let { wrongNetwork: s, disabledConnect: o } = L$4(), { state: n4 } = useAccount();
  return (r3 == null ? void 0 : r3.skip) ? e3 : s || o || typeof (r3 == null ? void 0 : r3.accountStatus) < "u" && n4.status < r3.accountStatus ? typeof (r3 == null ? void 0 : r3.fallbackData) < "u" ? r3.fallbackData : null : e3;
};
function Tr$1(e3) {
  let { t: r3 } = Z$2(), s = (n4, t, d2) => {
    var _a2;
    return (_a2 = { quantity: { required: r3("orderEntry.orderQuantity.error.required"), min: r3("orderEntry.orderQuantity.error.min", { value: t }), max: r3("orderEntry.orderQuantity.error.max", { value: t }) }, order_quantity: { required: r3("orderEntry.orderQuantity.error.required"), min: r3("orderEntry.orderQuantity.error.min", { value: t }), max: r3("orderEntry.orderQuantity.error.max", { value: t }) }, order_price: { required: r3("orderEntry.orderPrice.error.required"), min: r3("orderEntry.orderPrice.error.min", { value: t }), max: r3("orderEntry.orderPrice.error.max", { value: t }) }, trigger_price: { required: r3("orderEntry.triggerPrice.error.required"), min: r3("orderEntry.triggerPrice.error.min", { value: t }), max: r3("orderEntry.triggerPrice.error.max", { value: t }) }, tp_trigger_price: { min: r3("orderEntry.tpTriggerPrice.error.min", { value: t }), max: r3("orderEntry.tpTriggerPrice.error.max", { value: t }) }, sl_trigger_price: { min: r3("orderEntry.slTriggerPrice.error.min", { value: t }), max: r3("orderEntry.slTriggerPrice.error.max", { value: t }) }, total: { min: r3("orderEntry.total.error.min", { value: t }) } }[n4]) == null ? void 0 : _a2[d2];
  };
  return { parseErrorMsg: (n4) => {
    let { type: t, value: d2 } = (e3 == null ? void 0 : e3[n4]) || {};
    return t ? s(n4, d2, t) : "";
  } };
}
const OrderlyIcon = (props) => {
  const { size = 14, ...rest } = props;
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      width: `${size}px`,
      height: `${size}px`,
      viewBox: "0 0 14 14",
      xmlns: "http://www.w3.org/2000/svg",
      ...rest,
      children: [
        /* @__PURE__ */ jsx(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M6.98336 0.00840759L7.01663 0.0084076C8.7717 0.0124856 10.375 0.661681 11.6015 1.73116C11.6884 1.80694 11.6334 1.94602 11.518 1.94602L2.48196 1.94602C2.36659 1.94602 2.31155 1.80694 2.39846 1.73116C3.62496 0.661681 5.22829 0.0124854 6.98336 0.00840759Z",
            fill: "white",
            fillOpacity: "0.54"
          }
        ),
        /* @__PURE__ */ jsx(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M4.27699 8.90344C4.22691 8.83211 4.14627 8.78729 4.05904 8.78729L0.43836 8.78729C0.333471 8.78729 0.256996 8.88663 0.28676 8.98708C1.144 11.8804 3.82515 13.9914 6.99995 13.9914C10.1747 13.9914 12.8559 11.8804 13.7131 8.98708C13.7429 8.88663 13.6664 8.78729 13.5615 8.78729L9.94092 8.78729C9.85369 8.78729 9.77305 8.83211 9.72296 8.90344C9.12187 9.75954 8.12636 10.3192 6.99998 10.3192C5.87359 10.3192 4.87808 9.75954 4.27699 8.90344Z",
            fill: "white",
            fillOpacity: "0.54"
          }
        ),
        /* @__PURE__ */ jsx(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M9.63607 4.97781C9.70006 5.06094 9.79754 5.11306 9.90253 5.11306L13.5313 5.11306C13.6371 5.11306 13.7138 5.01213 13.6822 4.9112C13.408 4.035 12.9658 3.2329 12.3933 2.54255C12.3456 2.48508 12.2744 2.45264 12.1997 2.45264L1.79998 2.45264C1.72527 2.45264 1.65409 2.48508 1.60644 2.54255C1.03391 3.2329 0.591703 4.035 0.317483 4.9112C0.285896 5.01213 0.362554 5.11306 0.468425 5.11306L4.09718 5.11306C4.20217 5.11306 4.29964 5.06094 4.36364 4.97781C4.97123 4.18863 5.92608 3.68002 6.99985 3.68002C8.07363 3.68002 9.02847 4.18863 9.63607 4.97781Z",
            fill: "white",
            fillOpacity: "0.54"
          }
        ),
        /* @__PURE__ */ jsx(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M10.2113 8.28152C10.1428 8.28152 10.0962 8.21175 10.1199 8.14751C10.2516 7.79013 10.3235 7.40386 10.3235 7.00082C10.3235 6.56144 10.2381 6.14199 10.0828 5.75817C10.0566 5.69344 10.1033 5.6211 10.1732 5.6211L13.7326 5.6211C13.8088 5.6211 13.8747 5.67479 13.8882 5.74971C13.9617 6.15568 14 6.57383 14 7.00093C14 7.39252 13.9678 7.77659 13.9058 8.15064C13.8932 8.22662 13.8269 8.28152 13.7498 8.28152L10.2113 8.28152ZM3.8801 8.14751C3.90378 8.21175 3.8572 8.28152 3.78867 8.28152L0.250192 8.28152C0.173095 8.28152 0.106775 8.22662 0.0941906 8.15064C0.0322319 7.77659 0 7.39252 0 7.00093C0 6.57383 0.0383425 6.15567 0.111777 5.74971C0.125329 5.67479 0.191156 5.6211 0.267378 5.6211L3.82684 5.6211C3.89673 5.6211 3.94336 5.69344 3.91718 5.75817C3.76195 6.14199 3.67648 6.56144 3.67648 7.00082C3.67648 7.40386 3.74839 7.79013 3.8801 8.14751Z",
            fill: "white",
            fillOpacity: "0.54"
          }
        )
      ]
    }
  );
};
const OrderlyActiveIcon = (props) => {
  const { size = 14, ...rest } = props;
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      width: `${size}px`,
      height: `${size}px`,
      viewBox: "0 0 14 14",
      xmlns: "http://www.w3.org/2000/svg",
      ...rest,
      children: [
        /* @__PURE__ */ jsx(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M6.98336 0.00839233L7.01663 0.00839234C8.7717 0.0124704 10.375 0.661666 11.6015 1.73115C11.6884 1.80693 11.6334 1.946 11.518 1.946L2.48196 1.946C2.36659 1.946 2.31155 1.80693 2.39846 1.73114C3.62496 0.661666 5.22829 0.0124701 6.98336 0.00839233Z",
            fill: "white",
            fillOpacity: "0.98"
          }
        ),
        /* @__PURE__ */ jsx(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M4.27699 8.90341C4.22691 8.83208 4.14627 8.78726 4.05904 8.78726L0.43836 8.78726C0.333471 8.78726 0.256996 8.8866 0.28676 8.98706C1.144 11.8804 3.82515 13.9914 6.99995 13.9914C10.1747 13.9914 12.8559 11.8804 13.7131 8.98706C13.7429 8.8866 13.6664 8.78726 13.5615 8.78726L9.94092 8.78726C9.85369 8.78726 9.77305 8.83208 9.72296 8.90341C9.12187 9.75952 8.12636 10.3192 6.99998 10.3192C5.87359 10.3192 4.87808 9.75952 4.27699 8.90341Z",
            fill: "white",
            fillOpacity: "0.98"
          }
        ),
        /* @__PURE__ */ jsx(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M9.63607 4.97781C9.70006 5.06093 9.79754 5.11306 9.90253 5.11306L13.5313 5.11306C13.6371 5.11306 13.7138 5.01213 13.6822 4.9112C13.408 4.03499 12.9658 3.2329 12.3933 2.54254C12.3456 2.48508 12.2744 2.45264 12.1997 2.45264L1.79998 2.45264C1.72527 2.45264 1.65409 2.48508 1.60644 2.54254C1.03391 3.2329 0.591703 4.03499 0.317483 4.9112C0.285896 5.01213 0.362554 5.11306 0.468425 5.11306L4.09718 5.11306C4.20217 5.11306 4.29964 5.06093 4.36364 4.97781C4.97123 4.18863 5.92608 3.68002 6.99985 3.68002C8.07363 3.68002 9.02847 4.18863 9.63607 4.97781Z",
            fill: "white",
            fillOpacity: "0.98"
          }
        ),
        /* @__PURE__ */ jsx(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M10.2113 8.28152C10.1428 8.28152 10.0962 8.21175 10.1199 8.14751C10.2516 7.79012 10.3235 7.40386 10.3235 7.00082C10.3235 6.56143 10.2381 6.14199 10.0828 5.75816C10.0566 5.69344 10.1033 5.62109 10.1732 5.62109L13.7326 5.62109C13.8088 5.62109 13.8747 5.67479 13.8882 5.74971C13.9617 6.15567 14 6.57383 14 7.00093C14 7.39252 13.9678 7.77659 13.9058 8.15064C13.8932 8.22661 13.8269 8.28152 13.7498 8.28152L10.2113 8.28152ZM3.8801 8.14751C3.90378 8.21175 3.8572 8.28152 3.78867 8.28152L0.250192 8.28152C0.173095 8.28152 0.106775 8.22661 0.0941906 8.15064C0.0322319 7.77659 0 7.39252 0 7.00093C0 6.57383 0.0383425 6.15567 0.111777 5.74971C0.125329 5.67479 0.191156 5.62109 0.267378 5.62109L3.82684 5.62109C3.89673 5.62109 3.94336 5.69344 3.91718 5.75816C3.76195 6.14199 3.67648 6.56143 3.67648 7.00082C3.67648 7.40386 3.74839 7.79012 3.8801 8.14751Z",
            fill: "white",
            fillOpacity: "0.98"
          }
        )
      ]
    }
  );
};
const config = {
  scaffold: {
    mainNavProps: {
      initialMenu: "/",
      mainMenus: [
        { name: "Trading", href: "/" },
        { name: "Portfolio", href: "/portfolio" },
        { name: "Markets", href: "/markets" }
      ],
      campaigns: {
        name: "Reward",
        href: "/rewards",
        children: [
          {
            name: "Trading rewards",
            href: "https://app.orderly.network/tradingRewards",
            description: "Trade with Orderly to earn ORDER",
            icon: /* @__PURE__ */ jsx(OrderlyIcon, { size: 14 }),
            activeIcon: /* @__PURE__ */ jsx(OrderlyActiveIcon, { size: 14 }),
            target: "_blank"
          },
          {
            name: "Staking",
            href: "https://app.orderly.network/staking",
            description: "Stake ORDER/esORDER to acquire VALOR",
            icon: /* @__PURE__ */ jsx(OrderlyIcon, { size: 14 }),
            activeIcon: /* @__PURE__ */ jsx(OrderlyActiveIcon, { size: 14 }),
            target: "_blank"
          }
        ]
      }
    },
    footerProps: {
      // telegramUrl: "https://orderly.network",
      discordUrl: "https://discord.gg/MA98WqRjbd",
      twitterUrl: "https://x.com/winmore_xyz",
      trailing: /* @__PURE__ */ jsxs("span", { className: "oui-text-2xs oui-text-base-contrast-54", children: [
        "Charts powered by",
        " ",
        /* @__PURE__ */ jsx(
          "a",
          {
            href: "https://tradingview.com",
            target: "_blank",
            rel: "noopener noreferrer",
            children: "TradingView"
          }
        )
      ] })
    }
  },
  orderlyAppProvider: {
    appIcons: {
      main: {
        img: "/logo.svg"
      },
      secondary: {
        img: "/logo-secondary.svg"
      }
    }
  },
  tradingPage: {
    tradingViewConfig: {
      scriptSRC: "/tradingview/charting_library/charting_library.js",
      library_path: "/tradingview/charting_library/",
      customCssUrl: "/tradingview/chart.css"
    },
    sharePnLConfig: {
      backgroundImages: [
        "/pnl/poster_bg_1.png",
        "/pnl/poster_bg_2.png",
        "/pnl/poster_bg_3.png",
        "/pnl/poster_bg_4.png"
      ],
      color: "rgba(255, 255, 255, 0.98)",
      profitColor: "rgba(41, 223, 169, 1)",
      lossColor: "rgba(245, 97, 139, 1)",
      brandColor: "rgba(255, 255, 255, 0.98)"
    }
  }
};
const NimcoProvider = (props) => {
  const networkId = "mainnet";
  const onChainChanged = useCallback(
    (_chainId3, { isTestnet }) => {
      if (isTestnet && networkId === "mainnet" || !isTestnet && networkId === "testnet") {
        setTimeout(() => {
          const href = isTestnet ? void 0 : void 0;
          if (href) {
            window.location.href = href;
          }
        }, 100);
      }
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    []
  );
  return /* @__PURE__ */ jsx(
    WalletConnectorProvider,
    {
      solanaInitial: {
        network: WalletAdapterNetwork.Mainnet
      },
      evmInitial: void 0,
      children: /* @__PURE__ */ jsx(
        se$3,
        {
          brokerId: "ninco_fi",
          brokerName: "NincoFi",
          networkId,
          onChainChanged,
          appIcons: config.orderlyAppProvider.appIcons,
          children: props.children
        }
      )
    }
  );
};
function Layout({ children }) {
  return /* @__PURE__ */ jsxs("html", { lang: "en", children: [
    /* @__PURE__ */ jsxs("head", { children: [
      /* @__PURE__ */ jsx("meta", { charSet: "utf-8" }),
      /* @__PURE__ */ jsx("meta", { name: "viewport", content: "width=device-width, initial-scale=1" }),
      /* @__PURE__ */ jsx("link", { rel: "icon", type: "image/png", href: "/favicon.png" }),
      /* @__PURE__ */ jsx(Meta, {}),
      /* @__PURE__ */ jsx(Links, {})
    ] }),
    /* @__PURE__ */ jsxs("body", { children: [
      /* @__PURE__ */ jsx(NimcoProvider, { children }),
      /* @__PURE__ */ jsx(ScrollRestoration, {}),
      /* @__PURE__ */ jsx(Scripts, {})
    ] })
  ] });
}
function App() {
  return /* @__PURE__ */ jsx(Outlet, {});
}
const route0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Layout,
  default: App
}, Symbol.toStringTag, { value: "Module" }));
var te$5 = "orderly_selected_chains", ne$4 = 6, L$3 = (e3) => {
  let { networkId: o, bridgeLessOnly: r3 } = e3 || {}, { setStorageChain: l2 } = useStorageChain(), m2 = useConfig(), [n4, { checkChainSupport: c2 }] = useChains(), { setChain: d2, connectedChain: f2 } = useWalletConnector(), { onChainChanged: u2, currentChainId: T2, setCurrentChainId: s, wrongNetwork: C2 } = L$4(), [B2, N2] = useState(T2), { getComponentTheme: U3 } = Ri(), h2 = useMemo(() => ({ mainnet: (r3 ? n4.mainnet.filter((i) => i.network_infos.bridgeless) : n4.mainnet).map((i) => ({ name: i.network_infos.name, id: i.network_infos.chain_id, lowestFee: i.network_infos.bridgeless, isTestnet: false })), testnet: n4.testnet.map((i) => ({ name: i.network_infos.name, id: i.network_infos.chain_id, lowestFee: i.network_infos.bridgeless, isTestnet: true })) }), [n4, r3]), x2 = useMemo(() => !(U3("chainSelector", { showTestnet: true }).showTestnet === false || !h2.testnet.length), [h2.testnet]), { recentChains: z2, saveRecentChain: D2 } = oe$2(h2), E3 = async (t) => {
    if (f2) {
      let i = await d2({ chainId: t.id });
      return i && { result: i, wrongNetwork: !c2(t.id, m2.get("networkId")), chainId: t.id };
    }
    return l2(t.id), s(t.id), { result: true, wrongNetwork: false, chainId: t.id };
  }, S2 = (t, i) => {
    var _a2;
    let v2 = { isTestnet: t.isTestnet, isWalletConnected: i };
    (_a2 = e3.onChainChangeAfter) == null ? void 0 : _a2.call(e3, t.id, v2), u2 == null ? void 0 : u2(t.id, v2);
  }, V2 = async (t) => {
    var _a2, _b2, _c2;
    N2(t.id), (_a2 = e3.onChainChangeBefore) == null ? void 0 : _a2.call(e3, t.id, { isTestnet: t.isTestnet });
    try {
      let i = await (E3 == null ? void 0 : E3(t));
      i ? ((_b2 = e3.resolve) == null ? void 0 : _b2.call(e3, i), (_c2 = e3.close) == null ? void 0 : _c2.call(e3), D2(t), S2(t, true)) : (N2(void 0), S2(t, false));
    } catch {
      S2(t, false);
    }
  }, { selectedTab: H2, onTabChange: K2 } = ie$1(h2, T2, C2, x2);
  return { recentChains: z2, chains: h2, selectChainId: B2, onChainClick: V2, selectedTab: H2, onTabChange: K2, showTestnet: x2 };
};
function ie$1(e3, o, r3, l2) {
  let [m2, n4] = useState("Mainnet"), c2 = (d2) => {
    n4(d2);
  };
  return useEffect(() => {
    var _a2, _b2;
    if (!l2) {
      n4("Mainnet");
      return;
    }
    if (o) {
      if ((_a2 = e3.mainnet) == null ? void 0 : _a2.some((u2) => u2.id === o)) {
        n4(r3 ? "Testnet" : "Mainnet");
        return;
      }
      if ((_b2 = e3.testnet) == null ? void 0 : _b2.some((u2) => u2.id === o)) {
        n4(r3 ? "Mainnet" : "Testnet");
        return;
      }
    }
  }, [o, e3, r3, l2]), { selectedTab: m2, onTabChange: c2 };
}
function oe$2(e3) {
  let [o, r3] = useLocalStorage(te$5, []), l2 = useMemo(() => o == null ? void 0 : o.map((n4) => {
    var _a2;
    return (_a2 = e3.mainnet) == null ? void 0 : _a2.find((c2) => c2.id === parseInt(n4));
  }).filter((n4) => !!n4), [e3, o]), m2 = useCallback((n4) => {
    if (n4.isTestnet) return;
    let c2 = o == null ? void 0 : o.filter((d2) => d2 !== n4.id);
    c2 = [n4.id, ...c2].slice(0, ne$4), r3(c2);
  }, [o]);
  return { recentChains: l2, saveRecentChain: m2 };
}
var ce$7 = b$2({ slots: { icon: "", list: "oui-grid oui-grid-cols-1 oui-gap-1", mainnetList: '"', testnetList: '"', recentList: "", item: "oui-w-full oui-rounded-md", tip: "oui-text-center" }, variants: { variant: { compact: { icon: "oui-w-6 oui-h-6", list: "oui-bg-base-9 oui-rounded-lg oui-p-1", mainnetList: "oui-grid-cols-2 oui-mt-4", testnetList: "oui-grid-cols-1 oui-mt-4", recentList: "oui-mt-4", item: "oui-bg-base-6 hover:oui-bg-base-7", tip: "oui-pt-6" }, wide: { icon: "oui-w-[18px] oui-h-[18px]", mainnetList: "oui-grid-cols-3 oui-mt-3", testnetList: "oui-grid-cols-2 oui-mt-3", recentList: "oui-mt-3", item: "oui-bg-base-5 hover:oui-bg-base-6", tip: "oui-pt-8" } }, selected: { true: { item: "" }, false: { item: "oui-bg-transparent" } } }, compoundVariants: [{ variant: "compact", selected: true, className: { item: "hover:oui-bg-base-6" } }, { variant: "wide", selected: true, className: { item: "hover:oui-bg-base-5" } }], defaultVariants: { variant: "wide", selected: false } }), P = (e3) => {
  var _a2, _b2, _c2, _d2;
  let { isWrongNetwork: o, variant: r3 = "wide" } = e3, { t: l2 } = Z$2(), { list: m2, recentList: n4, mainnetList: c2, testnetList: d2, icon: f2, item: u2, tip: T2 } = ce$7({ variant: r3 });
  return jsxs(_$1, { className: cnBase("oui-font-semibold", e3.className), children: [jsxs(Cl, { value: e3.selectedTab, variant: "contained", size: r3 === "wide" ? "md" : "lg", onValueChange: (s) => e3.onTabChange(s), children: [jsxs(Sl, { value: "Mainnet", title: l2("connector.mainnet"), children: [!!((_a2 = e3.recentChains) == null ? void 0 : _a2.length) && jsx(z$1, { gap: 2, className: n4(), children: (_b2 = e3.recentChains) == null ? void 0 : _b2.map((s) => jsx(le$6, { item: s, onClick: () => e3.onChainClick(s), iconClassName: f2() }, s.id)) }), jsx(_$1, { r: "2xl", className: cnBase(m2(), c2()), children: (_c2 = e3.chains.mainnet) == null ? void 0 : _c2.map((s) => {
    let C2 = e3.selectChainId === s.id;
    return jsx(W$2, { selected: C2, item: s, onClick: () => e3.onChainClick(s), className: u2({ selected: C2 }) }, s.id);
  }) })] }), e3.showTestnet && jsx(Sl, { value: "Testnet", title: l2("connector.testnet"), children: jsx(_$1, { r: "2xl", className: cnBase(m2(), d2()), children: (_d2 = e3.chains.testnet) == null ? void 0 : _d2.map((s) => {
    let C2 = e3.selectChainId === s.id;
    return jsx(W$2, { selected: C2, item: s, onClick: () => e3.onChainClick(s), className: u2({ selected: C2 }) }, s.id);
  }) }) })] }), o && jsx(_$1, { className: T2(), children: jsx($$4, { color: "warning", size: "xs", children: l2("connector.wrongNetwork.tooltip") }) })] });
}, W$2 = (e3) => {
  let { item: o } = e3;
  return jsx("button", { className: e3.className, onClick: e3.onClick, children: jsxs(z$1, { justify: "between", className: "oui-py-2.5", px: 3, children: [jsxs(z$1, { itemAlign: "center", width: "100%", className: "oui-gap-x-[6px]", children: [jsx(kr$2, { chainId: o.id, size: "xs" }), jsx($$4, { size: "2xs", children: o.name })] }), e3.selected && jsx(_$1, { gradient: "brand", r: "full", width: 4, height: 4 })] }) });
}, le$6 = (e3) => jsx("button", { className: "oui-border oui-border-line-12 oui-rounded-lg hover:oui-border-primary-light", onClick: e3.onClick, children: jsx(z$1, { itemAlign: "center", p: 2, children: jsx(kr$2, { chainId: e3.item.id, className: e3.iconClassName }) }) });
var I$4 = (e3) => {
  let o = L$3(e3);
  return jsx(P, { ...o, variant: e3.variant, isWrongNetwork: e3.isWrongNetwork });
}, F$1 = "ChainSelectorDialogId", A$3 = "ChainSelectorSheetId";
Pg(F$1, I$4, { size: "lg", title: () => e2.t("connector.switchNetwork"), variant: "wide", isWrongNetwork: true });
ng(A$3, I$4, { title: () => e2.t("connector.switchNetwork"), classNames: { content: "!oui-bg-base-8", body: "!oui-bg-base-8" }, variant: "compact", isWrongNetwork: true });
var Q$1 = (e3) => {
  let { title: t, description: n4 } = e3;
  return jsxs(_$1, { position: "relative", className: "oui-pl-8", children: [jsxs(_$1, { children: [jsx($$4, { as: "div", intensity: 98, size: "sm", children: t }), jsx($$4, { as: "div", intensity: 54, size: "2xs", children: n4 })] }), jsx(he$4, { ...e3 })] });
}, he$4 = (e3) => {
  let { active: t, isLoading: n4, isCompleted: o } = e3;
  return jsx(Bf, { className: "oui-absolute oui-left-0 oui-top-1 oui-z-10", value: () => o ? "completed" : n4 ? "loading" : t ? "active" : "normal", case: { loading: jsx("div", { children: jsx(we$5, { size: "sm", className: "oui-ml-1" }) }), completed: jsx("div", { children: jsx(Ma, { opacity: 1, className: "oui-text-primary" }) }) }, default: jsx(be$5, { active: !!t }) });
}, be$5 = ({ active: e3, className: t }) => jsx("div", { className: cnBase("oui-w-[8.3px] oui-h-[8.3px] oui-rounded-full oui-ml-2 oui-mt-1", t, e3 ? "oui-bg-primary-light" : "oui-bg-base-2") });
var O$3 = (e3) => {
  let { initAccountState: t = AccountStatusEnum.NotConnected } = e3, [n4, o] = useState(true), r3 = useEventEmitter(), { t: c2 } = Z$2(), { state: g2, account: d2 } = useAccount(), [m2, a2] = useState(t), [l2, f2] = useState(0), [s, h2] = useState(false), [I2] = useLocalStorage("orderly-first-show-wallet-connector-dialog", void 0);
  useEffect(() => () => {
    localStorage.setItem("orderly-first-show-wallet-connector-dialog", "1");
  }, []), useEffect(() => {
    a2(g2.status);
  }, [g2]);
  let T2 = useMemo(() => {
    let i = [];
    return t < AccountStatusEnum.SignedIn && i.push({ key: "signIn", title: c2("connector.signIn"), description: c2("connector.signIn.description") }), t < AccountStatusEnum.EnableTrading && i.push({ key: "enableTrading", title: c2("connector.enableTrading"), description: c2("connector.enableTrading.description") }), i;
  }, [t, c2]), k2 = () => (h2(true), e3.enableTrading(n4).then(async (i) => {
    var _a2;
    h2(false), f2((w5) => w5 + 1);
    try {
      await ((_a2 = e3.enableTradingComplted) == null ? void 0 : _a2.call(e3));
    } catch {
    }
    typeof e3.onCompleted == "function" ? e3.onCompleted() : typeof e3.close == "function" && e3.close();
  }, (i) => {
    if (h2(false), i !== -1) {
      if (i.message.indexOf("Signing off chain messages with Ledger is not yet supported") !== -1) {
        r3.emit("wallet:sign-message-with-ledger-error", { message: i.message, userAddress: d2.address });
        return;
      }
      toast$2.error(X$3(i));
    }
  }).catch((i) => {
    h2(false);
  })), W2 = () => (h2(true), e3.signIn().then((i) => {
    f2((w5) => w5 + 1), k2();
  }, (i) => {
    if (h2(false), i !== -1) {
      if (i.message.indexOf("Signing off chain messages with Ledger is not yet supported") !== -1) {
        r3.emit("wallet:sign-message-with-ledger-error", { message: i.message, userAddress: d2.address });
        return;
      }
      toast$2.error(X$3(i));
    }
  }).catch((i) => {
    h2(false);
  }));
  return jsxs(_$1, { id: "oui-wallet-connect-dialog-content", className: "oui-font-semibold", children: [jsx($$4, { intensity: 54, size: "xs", children: c2("connector.expired") }), jsxs(_$1, { p: 4, my: 6, intensity: 600, r: "lg", className: "oui-space-y-5", position: "relative", children: [T2.map((i, w5) => jsx(Q$1, { title: i.title, description: i.description, isCompleted: l2 > w5, active: l2 === w5, isLoading: s && l2 === w5 }, i.key)), T2.length > 1 && jsx(_$1, { position: "absolute", height: "38px", left: 28, top: 18, zIndex: 0, children: jsx(te$6, { lineStyle: "dashed", direction: "vertical", intensity: 16, className: "oui-h-full" }) })] }), e3.showRefCodeInput && T2.length == 2 && jsx(ve$4, { ...e3 }), I2 && jsxs(z$1, { justify: "between", itemAlign: "center", children: [jsx(Me$4, {}), jsx(Zr$2, { color: "primary", checked: n4, onCheckedChange: o, disabled: s, className: "data-[state=checked]:oui-bg-primary-darken" })] }), jsx(z$1, { justify: "center", mt: 8, children: jsx(_$1, { width: "45%", children: jsx(Ee$5, { state: m2, signIn: W2, enableTrading: k2, loading: s, disabled: m2 >= AccountStatusEnum.EnableTrading }) }) })] });
}, Ee$5 = ({ state: e3, signIn: t, enableTrading: n4, loading: o, disabled: r3 }) => {
  let { t: c2 } = Z$2();
  return jsx(Bf, { value: () => e3 <= AccountStatusEnum.NotSignedIn ? "signIn" : "enableTrading", case: { signIn: jsx(_e$5, { fullWidth: true, onClick: () => t(), loading: o, disabled: r3, children: c2("connector.signIn") }), enableTrading: jsx(_e$5, { fullWidth: true, onClick: () => n4(), loading: o, disabled: r3, children: c2("connector.enableTrading") }) } });
}, ve$4 = (e3) => {
  let { t } = Z$2();
  return jsx(jr$2, { placeholder: t("connector.referralCode.placeholder"), fullWidth: true, label: "", value: e3.refCode, onChange: (n4) => {
    e3.setRefCode(n4.target.value);
  }, classNames: { label: "oui-text-base-contrast-54 oui-text-xs", input: "placeholder:oui-text-base-contrast-20 placeholder:oui-text-sm" }, formatters: [Xr$1.createRegexInputFormatter(/[^A-Z0-9]/g)], onClear: () => {
    e3.setRefCode("");
  }, autoComplete: "off", helpText: e3.helpText, className: "oui-mb-4", color: e3.helpText ? "danger" : void 0 });
}, Me$4 = () => {
  let { t: e3 } = Z$2(), t = () => {
    window.innerWidth > 768 || uo$3.alert({ title: e3("connector.rememberMe"), message: jsx("span", { className: "oui-text-2xs oui-text-base-contrast/60", children: e3("connector.rememberMe.description") }) });
  };
  return jsx(Xn$2, { content: e3("connector.rememberMe.description"), className: "oui-max-w-[300px]", children: jsx("button", { onClick: t, children: jsx($$4, { intensity: 54, size: "xs", className: "oui-underline oui-underline-offset-4 oui-decoration-dashed oui-decoration-base-contrast-36", children: e3("connector.rememberMe") }) }) });
};
function X$3(e$1) {
  Object.keys(e$1).forEach((n4) => {
  });
  let t = e2.t("connector.somethingWentWrong");
  return e$1.toString().includes("rejected") && (t = e2.t("connector.userRejected")), Ef(t) ?? t;
}
var L$2 = () => {
  let { account: e3, state: t, createOrderlyKey: n4, createAccount: o } = useAccount(), [r3, c2] = useState(""), [g2, d2] = useState(""), { t: m2 } = Z$2(), { trigger: a2 } = useLazyQuery(`/v1/public/referral/verify_ref_code?referral_code=${r3}`);
  useEffect(() => {
    let y2 = localStorage.getItem("referral_code");
    y2 != null && c2(y2);
  }, []);
  let { referral_code: l2, isLoading: f2 } = useGetReferralCode(e3.accountId), [s, { error: h2, isMutating: I2 }] = useMutation("/v1/referral/bind", "POST");
  useEffect(() => {
    r3.length === 0 && d2("");
  }, [r3]);
  let T2 = () => {
    toast$2.success(m2("connector.walletConnected")), r3.length >= 4 && r3.length <= 10 && s({ referral_code: r3 }).finally(() => {
      localStorage.removeItem("referral_code");
    });
  }, k2 = async () => {
    if (r3.length === 0) return Promise.resolve(void 0);
    if (r3.length > 0 && (r3.length < 4 || r3.length > 10)) return Promise.resolve(m2("connector.referralCode.invalid"));
    let { exist: y2 } = await a2();
    return y2 === false ? Promise.resolve(m2("connector.referralCode.notExist")) : Promise.resolve(void 0);
  }, W2 = ((l2 == null ? void 0 : l2.length) || 0) === 0 && !f2, i = async () => {
    if (W2) {
      let y2 = await k2();
      if (typeof y2 < "u") return d2(y2), Promise.reject(-1);
    }
    return d2(""), o();
  };
  return { enableTrading: async (y2) => {
    if (W2) {
      let _2 = await k2();
      if (typeof _2 < "u") return d2(_2), Promise.reject(-1);
    }
    return d2(""), n4(y2);
  }, initAccountState: t.status, signIn: i, enableTradingComplted: T2, refCode: r3, setRefCode: c2, helpText: g2, showRefCodeInput: W2 };
};
var B$4 = "walletConnector", G$4 = "walletConnectorSheet", D = (e3) => {
  let t = L$2();
  return jsx(O$3, { ...t, ...e3 });
};
Pg(B$4, D, { size: "sm", title: () => e2.t("connector.connectWallet") });
ng(G$4, D, { title: () => e2.t("connector.connectWallet") });
var S$1 = (e3) => {
  let { status: t, buttonProps: n4, fallback: o, descriptions: r3, classNames: c2, networkId: g2, id: d2, bridgeLessOnly: m2 } = e3, { t: a2 } = Z$2(), { state: l2 } = useAccount(), { wrongNetwork: f2, disabledConnect: s } = L$4(), h2 = useMemo(() => t === void 0 ? l2.status === AccountStatusEnum.EnableTradingWithoutConnected ? AccountStatusEnum.EnableTradingWithoutConnected : AccountStatusEnum.EnableTrading : t, [t, l2.status]), I2 = { connectWallet: a2("connector.connectWallet"), switchChain: a2("connector.wrongNetwork"), enableTrading: a2("connector.enableTrading"), signin: a2("connector.signIn"), ...e3.labels }, T2 = useMemo(() => typeof o < "u" ? o({ validating: l2.validating, status: l2.status, wrongNetwork: f2 }) : l2.validating && !s ? jsx(A$2, { angle: 45, disabled: true, loading: true, description: r3 == null ? void 0 : r3.connectWallet, id: d2, type: "button", ...n4, children: I2.connectWallet }) : jsx(je$4, { bridgeLessOnly: m2, status: l2.status, buttonProps: { ...n4, id: d2, type: "button" }, wrongNetwork: f2, networkId: e3.networkId, labels: I2, descriptions: r3, disabledConnect: s }), [l2.status, l2.validating, n4, f2]);
  return jsx(Mf, { value: l2.status >= h2 && !f2 && !s, left: T2, children: e3.children });
}, je$4 = (e3) => {
  let { buttonProps: t, labels: n4, descriptions: o } = e3, { t: r3 } = Z$2(), { connectWallet: c2 } = L$4(), { account: g2 } = useAccount(), { isMobile: d2 } = Ao$6(), m2 = useMediaQuery(MEDIA_TABLET), a2 = () => {
    uo$3.show(m2 ? G$4 : B$4).then((s) => {
    }, (s) => {
    });
  }, l2 = async () => {
    let s = await c2();
    s && (s.wrongNetwork ? f2() : ((s == null ? void 0 : s.status) ?? AccountStatusEnum.NotConnected) < AccountStatusEnum.EnableTrading && a2());
  }, f2 = () => {
    g2.once("validate:end", (s) => {
      s < AccountStatusEnum.EnableTrading ? a2() : toast$2.success(r3("connector.walletConnected"));
    }), uo$3.show(d2 ? A$3 : F$1, { networkId: e3.networkId, bridgeLessOnly: e3.bridgeLessOnly }).then((s) => {
      s.wrongNetwork || e3.status >= AccountStatusEnum.Connected && (e3.status < AccountStatusEnum.EnableTrading ? a2() : toast$2.success(r3("connector.walletConnected")));
    }, (s) => {
    });
  };
  return e3.wrongNetwork && !e3.disabledConnect ? jsx(A$2, { color: "warning", onClick: () => {
    f2();
  }, description: o == null ? void 0 : o.switchChain, ...t, children: n4.switchChain }) : jsx(Bf, { value: e3.status, case: (s) => {
    if (s <= AccountStatusEnum.NotConnected || e3.disabledConnect) return jsx(A$2, { size: "lg", onClick: () => {
      l2();
    }, variant: e3.disabledConnect ? void 0 : "gradient", angle: 45, description: o == null ? void 0 : o.connectWallet, disabled: e3.disabledConnect, ...t, children: n4.connectWallet });
    if (s <= AccountStatusEnum.NotSignedIn) return jsx(A$2, { size: "lg", onClick: () => {
      a2();
    }, angle: 45, description: o == null ? void 0 : o.signin, ...t, children: n4.signin });
  }, default: jsx(A$2, { size: "lg", description: o == null ? void 0 : o.enableTrading, ...t, onClick: () => a2(), children: n4.enableTrading }) });
};
S$1.displayName = "AuthGuard";
var A$2 = (e3) => {
  let { description: t, ...n4 } = e3;
  return jsxs(z$1, { direction: "column", children: [jsx(_e$5, { ...n4 }), !!t && jsx(_$1, { mt: 4, className: "oui-leading-none", style: { lineHeight: 0 }, children: jsx($$4, { size: "2xs", intensity: 36, children: t }) })] });
};
var dt$3 = (e3) => {
  var _a2;
  let { status: t, labels: n4, description: o, dataSource: r3, ...c2 } = e3, { state: g2 } = useAccount(), { wrongNetwork: d2, disabledConnect: m2 } = L$4(), a2 = useMemo(() => t === void 0 ? g2.status === AccountStatusEnum.EnableTradingWithoutConnected ? AccountStatusEnum.EnableTradingWithoutConnected : AccountStatusEnum.EnableTrading : t, [t, g2.status]), l2 = xr$2(r3, { accountStatus: a2 }), f2 = d2 || m2 || g2.status < a2 || e3.ignoreLoadingCheck;
  return jsx(jd, { dataSource: l2, ignoreLoadingCheck: f2, emptyView: jsx(ut$2, { status: a2, description: o, labels: n4, className: (_a2 = e3.classNames) == null ? void 0 : _a2.authGuardDescription, visible: !g2.validating }), manualPagination: true, ...c2 });
}, ut$2 = (e3) => {
  let { t } = Z$2(), o = { ...{ connectWallet: t("connector.connectWallet"), switchChain: t("connector.wrongNetwork"), enableTrading: t("connector.enableTrading"), signin: t("connector.signIn") }, ...e3.description };
  return e3.visible ? jsx(z$1, { py: 8, children: jsx(S$1, { status: e3.status, labels: e3.labels, descriptions: o, buttonProps: { size: "md" }, children: jsx(ei$3, { position: Et$5.EmptyDataIdentifier }) }) }) : null;
};
var le$5 = (e3) => {
  let { t } = Z$2(), { hint: n4 = { connectWallet: t("connector.trade.connectWallet.tooltip"), signIn: t("connector.trade.signIn.tooltip"), enableTrading: t("connector.trade.enableTrading.tooltip"), wrongNetwork: t("connector.wrongNetwork.tooltip") }, status: o } = e3;
  return jsx(_$1, { my: 8, children: jsx(S$1, { status: o, descriptions: { ...n4, switchChain: n4.wrongNetwork }, children: e3.children || jsx(At$2, {}) }) });
};
le$5.displayName = "AuthGuardEmpty";
var ue$7 = (e3) => {
  let { t } = Z$2(), { opactiy: n4 = 90, tooltip: o = { connectWallet: t("connector.setUp.connectWallet.tooltip"), signIn: t("connector.setUp.signIn.tooltip"), enableTrading: t("connector.setUp.enableTrading.tooltip"), wrongNetwork: t("connector.wrongNetwork.tooltip") } } = e3, [r3, c2] = useState(false), { state: g2 } = useAccount(), d2 = true, { wrongNetwork: m2 } = L$4(), a2 = useMemo(() => {
    if (m2) return o == null ? void 0 : o.wrongNetwork;
    switch (g2.status) {
      case AccountStatusEnum.NotConnected:
        return o == null ? void 0 : o.connectWallet;
      case AccountStatusEnum.NotSignedIn:
        return o == null ? void 0 : o.signIn;
      case AccountStatusEnum.DisabledTrading:
        return o == null ? void 0 : o.enableTrading;
      case AccountStatusEnum.EnableTrading:
        return "";
      default:
        return e3.content;
    }
  }, [e3.content, g2, d2, o]), l2 = useMemo(() => {
    switch (g2.status) {
      case AccountStatusEnum.NotConnected:
      case AccountStatusEnum.NotSignedIn:
        return n4;
      case AccountStatusEnum.EnableTrading:
        return;
      default:
        return;
    }
  }, [e3.opactiy, g2, d2]);
  return jsx(Xn$2, { open: a2 ? r3 : false, onOpenChange: c2, content: a2, className: "oui-text-2xs", align: e3.align, alignOffset: e3.alignOffset, side: e3.side, sideOffset: e3.sideOffset, children: jsx("div", { style: { opacity: l2 }, children: e3.children }) });
};
ue$7.displayName = "AuthGuardTooltip";
var xe$3 = (e3) => {
  let { t } = Z$2(), { accountState: o, onDisconnect: n4, onOpenExplorer: i } = e3, r3 = o.validating || e3.disabledConnect;
  if (!r3 && (o.status === AccountStatusEnum.EnableTrading || o.status === AccountStatusEnum.EnableTradingWithoutConnected)) return jsx(Qo$2, { address: o.address, onDisconnect: n4, onOpenExplorer: i });
  if (o.status <= AccountStatusEnum.NotConnected || r3) return jsx(_e$5, { "data-testid": "oui-testid-nav-bar-connectWallet-btn", size: "md", variant: r3 ? void 0 : "gradient", angle: 45, className: "wallet-connect-button", loading: o.validating, disabled: r3, onClick: () => {
    e3.connect().then((a2) => {
    }).catch((a2) => {
    });
  }, children: t("connector.connectWallet") });
  if (o.status <= AccountStatusEnum.NotSignedIn) return jsx(_e$5, { size: "md", onClick: () => e3.onCrateAccount(), children: t("connector.signIn") });
  if (o.status <= AccountStatusEnum.DisabledTrading) return jsx(_e$5, { size: "md", onClick: () => {
    e3.onCreateOrderlyKey().then((a2) => {
    }).catch((a2) => {
    });
  }, children: t("connector.enableTrading") });
}, Qo$2 = (e3) => {
  let { address: t, onDisconnect: o } = e3, { t: n4 } = Z$2();
  return jsxs(Yi, { children: [jsx(Xi$1, { asChild: true, children: jsx(_e$5, { size: "md", variant: "gradient", angle: 45, "data-testid": "oui-testid-nav-bar-address-btn", children: jsx($$4.formatted, { rule: "address", className: "oui-text-[rgba(0,0,0,.88)]", children: t }) }) }), jsx(ji, { children: jsxs(rr$2, { size: "xl", align: "end", onCloseAutoFocus: (i) => i.preventDefault(), style: { width: "280px" }, className: "oui-py-5 oui-font-semibold", sideOffset: 12, children: [jsx(kf, { children: jsxs(z$1, { px: 4, children: [jsxs(z$1, { gap: 2, className: "oui-flex-1", children: [jsx(un$1, { address: t, size: "md" }), jsx($$4.formatted, { rule: "address", size: "base", children: t })] }), jsxs(z$1, { gap: 2, children: [jsx("button", { "data-testid": "oui-testid-nav-bar-dropDownMenuItem-copyAddress", onClick: async () => {
    await navigator.clipboard.writeText(t);
  }, children: jsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: "18", height: "18", viewBox: "0 0 18 18", className: "oui-fill-[rgba(255,255,255,0.36)] hover:oui-fill-primary-darken", children: jsx("path", { d: "M5.249 2.243a3 3 0 0 0-3 3v4.5a3 3 0 0 0 3 3 3 3 0 0 0 3 3h4.5a3 3 0 0 0 3-3v-4.5a3 3 0 0 0-3-3 3 3 0 0 0-3-3zm7.5 4.5a1.5 1.5 0 0 1 1.5 1.5v4.5a1.5 1.5 0 0 1-1.5 1.5h-4.5a1.5 1.5 0 0 1-1.5-1.5h3a3 3 0 0 0 3-3z" }) }) }), jsx("button", { onClick: () => e3.onOpenExplorer(), children: jsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: "18", height: "18", viewBox: "0 0 18 18", className: "oui-fill-[rgba(255,255,255,0.36)] hover:oui-fill-primary-darken", children: jsx("path", { d: "M12.7432 15.7432C14.3999 15.7432 15.7432 14.3999 15.7432 12.7432V5.24316C15.7432 3.58641 14.3999 2.24316 12.7432 2.24316H5.24316C3.58641 2.24316 2.24316 3.58641 2.24316 5.24316V12.7432C2.24316 14.3999 3.58641 15.7432 5.24316 15.7432H12.7432ZM6.74316 11.9932C6.55116 11.9932 6.35092 11.9287 6.20392 11.7824C5.91142 11.4892 5.91142 10.9972 6.20392 10.7039L9.20392 7.70392L7.49316 5.99316H11.9932V10.4932L10.2824 8.78241L7.28241 11.7824C7.13616 11.9287 6.93516 11.9932 6.74316 11.9932Z" }) }) })] })] }) }), jsx(te$6, { className: "oui-mx-4 oui-my-3", intensity: 8 }), jsx(kf, { children: jsx(ir$3, { size: "xl", onSelect: (i) => {
    i.preventDefault(), o();
  }, "data-testid": "oui-testid-nav-bar-dropDownMenuItem-disconnect", children: jsxs(z$1, { gap: 2, className: "oui-text-danger-light", children: [jsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: "18", height: "18", viewBox: "0 0 18 18", fill: "none", children: jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M3.97 14.03a.75.75 0 0 1 0-1.06l.262-.263C2.594 12.354 1.5 11.108 1.5 9.06c0-2.447 1.563-3.75 3.75-3.75H6a.75.75 0 0 1 0 1.5h-.75C3.837 6.81 3 7.508 3 9.06s.837 2.25 2.25 2.25h.38l1.188-1.188a.75.75 0 0 1-.068-.312v-.75c0-1.162.381-2.19 1.172-2.883.645-.565 1.512-.867 2.578-.867h1.13l1.34-1.34a.75.75 0 0 1 1.061 1.06l-9 9a.75.75 0 0 1-1.06 0m6.14-7.2L8.27 8.668c.065-.583.281-1.056.635-1.367.289-.253.684-.419 1.205-.473M7.825 12.8l3.414-3.415c-.126 2.12-1.496 3.297-3.414 3.415m7.705-6.58a.75.75 0 0 0-1.06 1.06c.508.509.53 1.202.53 1.72 0 .739-.014 1.203-.53 1.72-.165.164-.455.307-.825.405a3.8 3.8 0 0 1-.895.125H12a.75.75 0 0 0 0 1.5h.75c.31 0 .787-.045 1.28-.175.48-.127 1.065-.36 1.5-.795.97-.97.97-1.991.97-2.75v-.06c0-.51.002-1.778-.97-2.75", fill: "currentcolor" }) }), jsx("span", { children: n4("connector.disconnect") })] }) }) })] }) })] });
};
var Oe$1 = () => {
  let { t: e3 } = Z$2(), { disconnect: t, connectedChain: o } = useWalletConnector(), { account: n4, state: i } = useAccount(), { connectWallet: r3, disabledConnect: a2 } = L$4(), [l2, { findByChainId: c2 }] = useChains(), m2 = async () => {
    uo$3.show(B$4).then((u2) => {
    }, (u2) => {
    });
  }, g2 = async () => {
    uo$3.show(B$4).then((u2) => {
    }, (u2) => {
    });
  }, h2 = () => {
    n4.once("validate:end", (u2) => {
      u2 < AccountStatusEnum.EnableTrading ? v2({ status: u2 }) : toast$2.success(e3("connector.walletConnected"));
    }), uo$3.show(F$1).then((u2) => {
      u2.wrongNetwork || (i.status < AccountStatusEnum.EnableTrading ? v2(i) : toast$2.success(e3("connector.walletConnected")));
    }, (u2) => {
    });
  }, S2 = async () => {
    let u2 = await r3();
    u2 && (u2.wrongNetwork ? h2() : v2(u2));
  }, v2 = (u2) => {
    u2.validating || u2.status <= AccountStatusEnum.Connected || (u2.status < AccountStatusEnum.SignedIn && m2(), u2.status < AccountStatusEnum.EnableTrading && g2());
  }, k2 = useCallback(() => {
    if (!o) return;
    let u2 = c2(o.id, "network_infos");
    if (u2) {
      let { explorer_base_url: y2 } = u2;
      y2 && (y2.endsWith("/") ? window.open(`${y2}address/${n4.address}`) : window.open(`${y2}/address/${n4.address}`));
    }
  }, [i, o]), d2 = async () => {
    var _a2;
    localStorage.removeItem("orderly_link_device"), await t({ label: (_a2 = i.connectWallet) == null ? void 0 : _a2.name }), await n4.disconnect();
  };
  return { address: i.address, accountState: i, connect: S2, onCrateAccount: m2, onCreateOrderlyKey: g2, onOpenExplorer: k2, onDisconnect: d2, disabledConnect: a2 };
};
zo$2({ name: "account-menu", positions: [Et$5.AccountMenu], builder: Oe$1, __isInternal: true })((e3) => jsx(xe$3, { ...e3 }));
var Lt$2 = () => jsx(ei$3, { position: Et$5.AccountMenu });
var kt$2 = (e3) => {
  let { active: t, item: o, onClick: n4 } = e3;
  return jsx(_e$5, { variant: t ? "gradient" : "text", color: "secondary", size: "sm", angle: 45, className: cnBase(t ? "oui-text-[rgba(0_,_0_,_0_,_0.88)]" : "hover:oui-bg-base-7"), onClick: () => {
    n4 == null ? void 0 : n4(o);
  }, children: o.name });
};
var _e$4 = (e3) => {
  let { items: t, onItemClick: o, current: n4, className: i } = e3, r3 = useMemo(() => {
    var _a2;
    return typeof n4 < "u" ? n4 : (_a2 = t == null ? void 0 : t[0]) == null ? void 0 : _a2.href;
  }, [n4, t]);
  return !Array.isArray(t) || t.length === 0 ? null : jsx(z$1, { gap: 0, border: true, r: "md", className: cnBase("oui-p-[1px]", i), borderColor: 12, children: t == null ? void 0 : t.map((a2, l2) => jsx(kt$2, { item: a2, onClick: o, active: r3 == a2.href }, l2)) });
};
var fn = (e3) => {
  let { totalValue: t = 0, visible: o = true, onToggleVisibility: n4, visibleAvailable: i = true } = e3, { t: r3 } = Z$2();
  return jsxs(z$1, { direction: "column", gap: 0, className: "oui-text-2xs", itemAlign: "start", children: [jsxs(z$1, { gap: 1, itemAlign: "center", children: [jsx($$4, { intensity: 54, className: "oui-whitespace-nowrap", children: r3("common.totalValue") }), i && jsx("button", { onClick: () => n4 == null ? void 0 : n4(), children: o ? jsx(on$1, { size: 12, className: "oui-text-primary-light", opacity: 1 }) : jsx(nn$1, { size: 12, className: "oui-text-primary-light", opacity: 1 }) }), jsx($$4, { intensity: 54, children: "" })] }), jsx($$4.numeral, { visible: e3.visible, unit: "USDC", unitClassName: "oui-text-base-contrast-20 oui-ml-1", as: "div", children: t ?? "-" })] });
}, hn$1 = (e3) => {
  let { freeCollateral: t, visible: o, onToggleVisibility: n4, visibleAvailable: i = true } = e3, { t: r3 } = Z$2();
  return jsxs(z$1, { direction: "column", gap: 0, className: "oui-text-2xs", itemAlign: "start", children: [jsxs(z$1, { gap: 1, itemAlign: "center", children: [jsx($$4, { intensity: 54, className: "oui-whitespace-nowrap", children: r3("trading.asset.freeCollateral") }), i && jsx("button", { onClick: () => n4 == null ? void 0 : n4(), children: o ? jsx(on$1, { size: 12, className: "oui-text-primary-light", opacity: 1 }) : jsx(nn$1, { size: 12, className: "oui-text-primary-light", opacity: 1 }) })] }), jsx($$4.numeral, { unit: "USDC", unitClassName: "oui-text-base-contrast-20 oui-ml-1", visible: o, as: "div", children: t ?? "-" })] });
}, vn = (e3) => {
  let { currentLeverage: t } = e3, { t: o } = Z$2();
  return jsxs(z$1, { direction: "column", gap: 0, className: "oui-text-2xs", itemAlign: "start", children: [jsx(_$1, { children: jsx($$4, { intensity: 54, className: "oui-whitespace-nowrap", children: o("leverage.currentLeverage") }) }), jsx($$4.numeral, { as: "div", unit: "x", children: t ?? 0 })] });
}, xn$1 = (e3) => {
  let { t } = Z$2();
  return jsxs(z$1, { direction: "column", gap: 0, className: "oui-text-2xs", itemAlign: "start", children: [jsx(_$1, { children: jsx($$4, { intensity: 54, className: "oui-whitespace-nowrap", children: t("leverage.maxLeverage") }) }), jsx($$4, { color: "primary", as: "div", children: `${e3.maxLeverage ?? "--"}x` })] });
}, Cn$2 = (e3) => {
  let { visible: t, onToggleVisibility: o, visibleAvailable: n4 = true } = e3, { t: i } = Z$2();
  return jsxs(z$1, { direction: "column", gap: 0, className: "oui-text-2xs", itemAlign: "start", children: [jsxs(z$1, { gap: 1, itemAlign: "center", children: [jsx($$4, { intensity: 54, className: "oui-whitespace-nowrap", children: i("common.unrealizedPnl") }), n4 && jsx("button", { onClick: () => o == null ? void 0 : o(), children: t ? jsx(on$1, { size: 12, className: "oui-text-primary-light", opacity: 1 }) : jsx(nn$1, { size: 12, className: "oui-text-primary-light", opacity: 1 }) })] }), jsx($$4.numeral, { as: "div", coloring: true, showIdentifier: true, weight: "semibold", visible: t, suffix: jsx($$4.numeral, { coloring: true, prefix: "(", suffix: ")", rule: "percentages", children: e3.unrealized_pnl_ROI ?? "-" }), children: e3.unrealPnL ?? "-" })] });
}, bn = (e3) => {
  let { totalValue: t, keys: o, elementKeys: n4 } = e3, { t: i } = Z$2(), r3 = (l2) => (c2) => {
    c2.preventDefault(), c2.stopPropagation(), e3.onKeyToTop(l2);
  }, a2 = n4.map((l2) => {
    switch (l2) {
      case "totalValue":
        return jsxs(ae$5, { onSetTop: r3("totalValue"), children: [jsxs(z$1, { className: "oui-text-base-contrast-54", gapX: 2, children: [jsx(se$2, { active: o.includes("totalValue"), onClick: () => e3.onToggleItemByKey("totalValue") }), jsx("span", { children: i("common.totalValue") })] }), jsx($$4.numeral, { visible: e3.visible, unit: "USDC", className: "group-hover:-oui-translate-x-5 oui-transition-transform", unitClassName: "oui-text-base-contrast-36 oui-ml-1", children: t ?? "-" })] }, l2);
      case "freeCollateral":
        return jsxs(ae$5, { onSetTop: r3("freeCollateral"), children: [jsxs(z$1, { className: "oui-text-base-contrast-54", gapX: 2, children: [jsx(se$2, { active: o.includes("freeCollateral"), onClick: () => e3.onToggleItemByKey("freeCollateral") }), jsx("span", { children: i("trading.asset.freeCollateral") })] }), jsx($$4.numeral, { unit: "USDC", visible: e3.visible, className: "group-hover:-oui-translate-x-5 oui-transition-transform", unitClassName: "oui-text-base-contrast-36 oui-ml-1", children: e3.freeCollateral ?? "-" })] }, l2);
      case "unrealPnL":
        return jsxs(ae$5, { onSetTop: r3("unrealPnL"), children: [jsxs(z$1, { className: "oui-text-base-contrast-54", gapX: 2, children: [jsx(se$2, { active: o.includes("unrealPnL"), onClick: () => e3.onToggleItemByKey("unrealPnL") }), jsx("span", { children: i("common.unrealizedPnl") })] }), jsx($$4.numeral, { coloring: true, showIdentifier: true, visible: e3.visible, className: "group-hover:-oui-translate-x-5 oui-transition-transform", suffix: jsx($$4.numeral, { coloring: true, prefix: "(", visible: e3.visible, suffix: ")", rule: "percentages", children: e3.unrealized_pnl_ROI ?? "-" }), children: e3.unrealPnL ?? "-" })] }, l2);
      case "currentLeverage":
        return jsxs(ae$5, { onSetTop: r3("currentLeverage"), children: [jsxs(z$1, { className: "oui-text-base-contrast-54", gapX: 2, children: [jsx(se$2, { active: o.includes("currentLeverage"), onClick: () => e3.onToggleItemByKey("currentLeverage") }), jsx("span", { children: i("leverage.currentLeverage") })] }), jsx($$4.numeral, { className: "group-hover:-oui-translate-x-5 oui-transition-transform", unit: "x", children: e3.currentLeverage ?? "-" })] }, l2);
      case "maxLeverage":
        return jsxs(ae$5, { onSetTop: r3("maxLeverage"), children: [jsxs(z$1, { className: "oui-text-base-contrast-54", gapX: 2, children: [jsx(se$2, { active: o.includes("maxLeverage"), onClick: () => e3.onToggleItemByKey("maxLeverage") }), jsx("span", { children: i("leverage.maxLeverage") })] }), jsx($$4, { className: "group-hover:-oui-translate-x-5 oui-transition-transform", color: "primary", children: `${e3.maxLeverage ?? "-"}x` })] }, l2);
      default:
        return null;
    }
  });
  return jsx(z$1, { className: "oui-text-2xs oui-font-semibold", direction: "column", gapY: 1, children: a2 });
}, ae$5 = (e3) => jsxs("div", { className: "oui-w-full oui-relative oui-group hover:oui-bg-base-6 oui-px-[6px] oui-py-1 oui-rounded", children: [jsx(z$1, { justify: "between", width: "100%", children: e3.children }), jsx("button", { className: "oui-absolute oui-right-1 oui-top-1", onClick: e3.onSetTop, children: jsxs("svg", { className: "group-hover:oui-opacity-100 group-hover:oui-translate-x-0 oui-opacity-0 oui-translate-x-3 oui-transition-all oui-cursor-pointer oui-fill-base-contrast-54 hover:oui-fill-base-contrast", width: "16", height: "16", viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsx("rect", { width: "16", height: "16", rx: "2", fill: "rgb(var(--oui-color-primary-darken))" }), jsx("path", { d: "M3.507 3.999a.5.5 0 1 0 0 1h9a.5.5 0 0 0 0-1zm4 8.006a.5.5 0 0 0 1 0V7.724l1.5 1.484.703-.703-2.343-2.36a.515.515 0 0 0-.72 0l-2.343 2.36.703.703 1.5-1.484z" })] }) })] }), se$2 = (e3) => jsx("button", { onClick: e3.onClick, children: e3.active ? jsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: "12", height: "12", viewBox: "0 0 12 12", fill: "none", children: jsx("path", { d: "M7.506.977a.56.56 0 0 0-.365.16C6.367 1.88 6.13 2.5 6.413 3.348c-.661.506-1.078.63-1.903.63-1.127 0-1.863.137-2.364.637v.016a1.187 1.187 0 0 0 0 1.686l1.4 1.411-2.385 2.385a.513.513 0 0 0-.015.717.514.514 0 0 0 .719 0l2.394-2.395 1.403 1.396a1.19 1.19 0 0 0 1.687 0h.016c.501-.5.64-1.142.64-2.358 0-.773.16-1.319.64-1.893.924.271 1.462.012 2.22-.746a.5.5 0 0 0 .14-.36c0-.175-.044-.445-.156-.78a4 4 0 0 0-.984-1.577 4 4 0 0 0-1.578-.984C7.95 1.02 7.682.977 7.506.977", fill: "currentcolor", className: "oui-text-primary-light" }) }) : jsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: "12", height: "12", viewBox: "0 0 12 12", fill: "none", children: jsx("path", { d: "M7.506.977a.56.56 0 0 0-.365.16C6.367 1.88 6.13 2.5 6.413 3.348c-.661.506-1.078.63-1.903.63-1.127 0-1.863.137-2.364.637v.016a1.187 1.187 0 0 0 0 1.686l1.4 1.411-2.385 2.385a.513.513 0 0 0-.015.717.514.514 0 0 0 .719 0l2.394-2.395 1.403 1.396a1.19 1.19 0 0 0 1.687 0h.016c.501-.5.64-1.142.64-2.358 0-.773.16-1.319.64-1.893.924.271 1.462.012 2.22-.746a.5.5 0 0 0 .14-.36c0-.175-.044-.445-.156-.78a4 4 0 0 0-.984-1.577 4 4 0 0 0-1.578-.984C7.95 1.02 7.682.977 7.506.977m.193 1.027c.531.098 1.066.45 1.447.83.381.382.706.848.84 1.459-.477.458-.77.494-1.247.243a.5.5 0 0 0-.583.087c-.91.91-1.15 1.736-1.15 2.85 0 .97-.057 1.33-.36 1.655-.085.092-.203.078-.281 0L2.849 5.615a.18.18 0 0 1-.012-.255c.178-.217.576-.386 1.669-.386 1.306.001 2-.335 2.859-1.14a.5.5 0 0 0 .094-.578c-.257-.513-.217-.784.24-1.252", fill: "currentcolor" }) }) });
var Ke$4 = (e3) => {
  let { keys: t, ...o } = e3, n4 = 0, i = Ce__default__default.useRef(0);
  useEffect(() => {
    let a2 = new ResizeObserver((l2) => {
      if (Array.isArray(l2) && l2.length > 0) {
        let c2 = l2[0].contentRect.width;
        c2 > 1440 ? i.current = 5 : c2 > 1366 ? i.current = 4 : c2 > 1280 ? i.current = 3 : c2 > 1140 ? i.current = 2 : i.current = 1;
      }
    });
    return a2.observe(document.body), () => {
      a2.disconnect();
    };
  }, []);
  let r3 = t.slice(0, i.current).map((a2, l2) => {
    switch (a2) {
      case "freeCollateral":
        return jsx(hn$1, { freeCollateral: e3.freeCollateral, visible: e3.visible, onToggleVisibility: e3.onToggleVisibility, visibleAvailable: l2 === n4 });
      case "unrealPnL":
        return jsx(Cn$2, { unrealPnL: e3.unrealPnL, unrealized_pnl_ROI: e3.unrealized_pnl_ROI, visible: e3.visible, onToggleVisibility: e3.onToggleVisibility, visibleAvailable: l2 === n4 });
      case "currentLeverage":
        return n4++, jsx(vn, { currentLeverage: e3.currentLeverage });
      case "maxLeverage":
        return n4++, jsx(xn$1, { maxLeverage: e3.maxLeverage });
      case "totalValue":
      default:
        return jsx(fn, { totalValue: e3.totalValue, onToggleVisibility: e3.onToggleVisibility, visible: e3.visible, visibleAvailable: l2 === n4 });
    }
  });
  return jsxs("div", { className: "oui-flex oui-items-center oui-gap-6", children: [jsx(wn$1, { elements: r3 }), jsx(yo$3, { content: jsx(bn, { totalValue: o.totalValue, freeCollateral: e3.freeCollateral, maxLeverage: e3.maxLeverage, currentLeverage: e3.currentLeverage, unrealized_pnl_ROI: e3.unrealized_pnl_ROI, unrealPnL: e3.unrealPnL, keys: t, elementKeys: e3.elementKeys, onToggleItemByKey: e3.onToggleItemByKey, onKeyToTop: e3.onKeyToTop, visible: e3.visible }), contentProps: { onOpenAutoFocus: (a2) => a2.preventDefault(), sideOffset: 12, className: "oui-p-1" }, arrow: true, children: jsx("div", { className: "oui-cursor-pointer oui-group", children: jsx(yn, {}) }) })] });
}, wn$1 = (e3) => jsx("div", { className: "oui-flex oui-gap-6", children: e3.elements.map((t, o) => jsx("div", { children: t }, o)) }), yn = () => jsx("svg", { width: "20", height: "20", viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg", className: "oui-fill-base-contrast-36 hover:oui-fill-primary-light group-data-[state=open]:oui-fill-primary-light", children: jsx("path", { d: "M10.007 8.335a1.666 1.666 0 1 1 0 3.333 1.666 1.666 0 0 1 0-3.333m-5.84 0a1.666 1.666 0 1 1 0 3.333 1.666 1.666 0 0 1 0-3.333m11.666 0a1.666 1.666 0 1 1 0 3.333 1.666 1.666 0 0 1 0-3.333" }) });
var Vt$3 = () => {
  let [e3, t] = useLocalStorage("accountSummaryTypes", ["totalValue"]), [o, n4] = useState(["totalValue", "freeCollateral", "unrealPnL", "currentLeverage", "maxLeverage"]), { freeCollateral: i, totalValue: r3 } = useCollateral({ dp: 2 }), { state: a2 } = useAccount(), [l2, c2] = useLocalStorage("orderly_assets_visible", true), [{ aggregated: m2, totalUnrealizedROI: g2 }] = usePositionStream(), { wrongNetwork: h2, disabledConnect: S2 } = L$4(), { currentLeverage: v2 } = useMarginRatio(), [k2] = useLeverage(), d2 = (C2) => {
    e3.includes(C2) ? t(e3.filter((A2) => A2 !== C2)) : t([...e3, C2]);
  }, u2 = (C2) => {
    if (!e3.includes(C2)) {
      t([C2, ...e3]), n4([C2, ...o.filter((A2) => A2 !== C2)]);
      return;
    }
    t([C2, ...e3.filter((A2) => A2 !== C2)]), n4([C2, ...o.filter((A2) => A2 !== C2)]);
  }, y2 = h2 || S2 || a2.status < AccountStatusEnum.EnableTrading && a2.status !== AccountStatusEnum.EnableTradingWithoutConnected;
  return { totalValue: y2 ? null : r3, freeCollateral: y2 ? null : i, maxLeverage: y2 ? null : k2, currentLeverage: y2 ? null : v2, unrealPnL: y2 ? null : m2 == null ? void 0 : m2.total_unreal_pnl, unrealized_pnl_ROI: y2 ? null : g2, keys: e3, elementKeys: o, visible: l2, wrongNetwork: h2, onToggleItemByKey: d2, onKeyToTop: u2, onToggleVisibility: () => c2(!l2) };
};
var Ce$3 = () => {
  let e3 = Vt$3();
  return jsx(Ke$4, { ...e3, elementKeys: e3.elementKeys });
};
var we$4 = (e3) => {
  let { t } = Z$2();
  if (e3.wrongNetwork && e3.isConnected && !e3.disabledConnect) return jsx(Xn$2, { open: true, hideWhenDetached: true, content: t("connector.wrongNetwork.tooltip"), className: "oui-bg-base-5", arrow: { className: "oui-fill-base-5" }, children: jsx(_e$5, { color: "warning", size: "md", onClick: () => {
    uo$3.show(F$1, { networkId: e3.networkId }).then((i) => {
      !i.wrongNetwork && e3.accountStatus < AccountStatusEnum.EnableTrading && uo$3.show(B$4).then((r3) => {
      }, (r3) => {
      });
    }, (i) => {
    });
  }, children: t("connector.wrongNetwork") }) });
  let o = () => {
    if (e3.loading) return jsx(we$5, { className: "oui-w-[18px] oui-h-[18px]" });
    if (e3.currentChainId) return jsx(kr$2, { chainId: e3.currentChainId, size: "xs" });
  }, n4 = jsxs(z$1, { intensity: 500, justify: "center", className: cnBase("oui-relative oui-cursor-pointer", "oui-w-11 oui-h-8", "oui-rounded-t-[6px] oui-rounded-bl-[6px] oui-rounded-br-[3px]"), children: [o(), jsxs("svg", { width: "10", height: "10", viewBox: "0 0 10 10", xmlns: "http://www.w3.org/2000/svg", className: "oui-absolute oui-right-0 oui-bottom-0", children: [jsx("defs", { children: jsxs("linearGradient", { id: "paint0_linear_490_5080", x1: "10", y1: "5", x2: "-5.79673e-08", y2: "5", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "rgb(var(--oui-gradient-brand-end))" }), jsx("stop", { offset: "1", stopColor: "rgb(var(--oui-gradient-brand-start))" })] }) }), jsx("path", { d: "M10 7V0L0 10H7C8.65685 10 10 8.65685 10 7Z", fill: "url(#paint0_linear_490_5080)" })] })] });
  return jsxs(Yi, { open: e3.open, onOpenChange: e3.onOpenChange, children: [jsx(Xi$1, { asChild: true, children: n4 }), jsx(ji, { children: jsx(rr$2, { onCloseAutoFocus: (i) => i.preventDefault(), onClick: (i) => i.stopPropagation(), sideOffset: 4, collisionPadding: { right: 16 }, className: cnBase("oui-bg-base-8 oui-w-[456px] oui-p-4 oui-rounded-xl", "oui-border oui-border-line-6", "oui-font-semibold"), children: jsx(I$4, { close: e3.hide, onChainChangeBefore: e3.onChainChangeBefore, onChainChangeAfter: e3.onChainChangeAfter }) }) })] });
};
var zt$4 = () => {
  let [e3, t] = useState(false), [o, n4] = useState(false), { state: i } = useAccount(), { connectedChain: r3 } = useWalletConnector(), { currentChainId: a2, wrongNetwork: l2, disabledConnect: c2 } = L$4(), m2 = useConfig("networkId"), g2 = () => {
    t(false);
  }, h2 = () => {
    n4(true), g2();
  }, S2 = () => {
    n4(false);
  };
  return { isConnected: !!r3, currentChainId: a2, wrongNetwork: l2, disabledConnect: c2, accountStatus: i.status, networkId: m2, open: e3, onOpenChange: t, hide: g2, onChainChangeBefore: h2, onChainChangeAfter: S2, loading: o };
};
var ye$5 = () => {
  let e3 = zt$4();
  return jsx(we$4, { ...e3 });
};
var Ne$3 = createContext({}), le$4 = () => useContext(Ne$3);
var Ze$2 = ((n4) => (n4.menuLeading = "menuLeading", n4.menuTailing = "menuTailing", n4.navTailing = "navTailing", n4))(Ze$2 || {}), Wt$4 = (e3) => {
  var _a2;
  let { onItemClick: t, campaignPosition: o = "navTailing" } = e3, { state: n4 } = useAccount(), { routerAdapter: i } = le$4(), { connectedChain: r3 } = useWalletConnector(), { wrongNetwork: a2, disabledConnect: l2 } = L$4(), [c2, m2] = useState(() => typeof e3.initialMenu > "u" ? [] : Array.isArray(e3.initialMenu) ? e3.initialMenu : [e3.initialMenu]), [g2, h2] = useState(() => {
    var _a3;
    return (e3 == null ? void 0 : e3.initialProduct) ?? ((_a3 = e3 == null ? void 0 : e3.products) == null ? void 0 : _a3[0].href) ?? "";
  }), S2 = (d2) => (u2) => {
    let y2 = u2[u2.length - 1];
    if (!y2) return;
    y2.target !== "_blank" && m2(u2.map((Z3) => Z3.href));
    let C2 = u2[u2.length - 1], A2 = { href: C2.href, name: C2.name, scope: d2, target: C2.target };
    if (typeof t == "function") {
      t(A2);
      return;
    }
    i == null ? void 0 : i.onRouteChange(A2);
  }, v2 = useMemo(() => {
    let d2 = { logo: {}, mainMenus: [], products: [], ...e3, campaignPosition: o };
    return e3.campaigns && (o === "menuTailing" ? d2.mainMenus = [...d2.mainMenus, e3.campaigns] : o === "menuLeading" ? d2.mainMenus = [e3.campaigns, ...d2.mainMenus] : d2.campaigns = e3.campaigns), d2;
  }, [e3]), k2 = {};
  return v2.products && v2.products.length && (k2.products = { items: v2.products, current: g2, onItemClick: (d2) => {
    let u2 = { href: d2.href, name: d2.name, scope: "product" };
    if (typeof t == "function") {
      t(u2);
      return;
    }
    i == null ? void 0 : i.onRouteChange(u2);
  } }), v2.mainMenus && v2.mainMenus.length && (k2.mainMenus = { items: v2.mainMenus, current: c2, onItemClick: S2("mainMenu") }), v2.campaigns && ((_a2 = v2.campaigns.children) == null ? void 0 : _a2.length) && (k2.campaigns = { item: v2.campaigns, current: c2, onItemClick: S2("campaign") }), { ...v2, isConnected: !!r3, wrongNetwork: a2, ...k2, status: n4.status, disabledConnect: l2 };
};
var Se$5 = (e3) => {
  var _a2;
  let { classNames: t, currentPath: o, item: n4, onClick: i, ...r3 } = e3, a2 = useMemo(() => {
    var _a3;
    return ((_a3 = e3.currentPath) == null ? void 0 : _a3[0]) === e3.item.href;
  }, [o]), l2 = useCallback(() => {
    var _a3;
    Array.isArray(e3.item.children) || ((_a3 = e3.onClick) == null ? void 0 : _a3.call(e3, [e3.item]));
  }, [e3.item]), c2 = jsxs("button", { id: n4.id, "data-testid": n4.testid, ...r3, disabled: e3.item.disabled, "data-actived": a2, className: cnBase("oui-text-base-contrast-36 oui-text-sm oui-relative oui-group oui-rounded oui-px-3 oui-py-1 oui-h-[32px] hover:oui-bg-base-7", t == null ? void 0 : t.navItem), onClick: l2, children: [jsxs("span", { className: "oui-flex oui-items-center", children: [jsx(Kt$3, { isActive: a2, item: e3.item }), jsx($$4.gradient, { color: a2 ? "brand" : "inherit", angle: 45, className: "oui-break-normal oui-whitespace-nowrap", children: e3.item.name }), Array.isArray(e3.item.children) && jsx("span", { className: "oui-ml-1 group-data-[open=true]:oui-rotate-180", children: a2 ? jsxs("svg", { width: "12", height: "12", viewBox: "0 0 12 12", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsx("path", { d: "M2.913 4.515a.5.5 0 0 0-.328.202.51.51 0 0 0 .14.701L5.722 7.41a.51.51 0 0 0 .562 0l2.995-1.992a.51.51 0 0 0 .14-.7.51.51 0 0 0-.701-.14L6.002 6.382 3.287 4.577a.5.5 0 0 0-.374-.062", fill: "url(#mainNavDropDownIcon)" }), jsx("defs", { children: jsxs("linearGradient", { id: "mainNavDropDownIcon", x1: "9.502", y1: "5.994", x2: "2.502", y2: "5.994", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "rgb(var(--oui-gradient-brand-end))" }), jsx("stop", { offset: "1", stopColor: "rgb(var(--oui-gradient-brand-start))" })] }) })] }) : jsx(nt$3, { size: 12, color: "white" }) })] }), jsx(_$1, { invisible: !a2, position: "absolute", bottom: 0, left: "50%", height: "3px", r: "full", width: "60%", gradient: "brand", angle: 45, className: "-oui-translate-x-1/2 " })] });
  return Array.isArray(e3.item.children) ? jsx(mi$2, { items: e3.item.children, className: t == null ? void 0 : t.subMenu, current: (_a2 = e3.currentPath) == null ? void 0 : _a2[1], onItemClick: (m2) => {
    var _a3;
    (_a3 = e3.onClick) == null ? void 0 : _a3.call(e3, [e3.item, m2]);
  }, children: c2 }) : c2;
}, mi$2 = (e3) => {
  let [t, o] = useState(false), n4 = useRef(null), i = useCallback(() => {
    n4.current && (clearTimeout(n4.current), n4.current = null);
  }, []), r3 = e3.children.props.className;
  return jsxs(gt$2, { open: t, children: [jsx(Mr, { children: jsx("div", { className: "oui-group", "data-open": t, onMouseEnter: () => {
    o(true);
  }, onMouseLeave: () => {
    n4.current = setTimeout(() => {
      o(false);
    }, 150);
  }, children: cloneElement(e3.children, { className: cnBase(r3, t && "oui-bg-base-7") }) }) }), jsx(vo$6, { align: "start", onMouseEnter: i, onMouseLeave: () => {
    o(false), n4.current && clearTimeout(n4.current);
  }, className: cnBase("oui-p-1 oui-w-[260px] oui-border oui-border-line-6 oui-space-y-[2px]", e3.className), children: e3.items.map((a2, l2) => jsx(di$1, { item: a2, onClick: e3.onItemClick, active: a2.href === e3.current }, l2)) })] });
}, di$1 = (e3) => {
  let { item: t } = e3;
  return jsxs(z$1, { px: 2, py: 3, gapX: 2, "data-active": e3.active ?? false, className: cnBase("hover:oui-bg-base-6 oui-cursor-pointer oui-text-base-contrast-80 oui-items-start oui-w-full oui-group data-[active=true]:oui-bg-base-5"), r: "md", onClick: () => {
    e3.onClick(t);
  }, "data-testid": t.testid, children: [!!e3.item.icon && jsx("div", { className: "oui-translate-y-1 oui-relative oui-w-6 oui-h-6", children: jsx(Kt$3, { isActive: e3.active ?? false, item: e3.item }) }), jsxs("div", { className: "oui-flex-1", children: [jsx(pi$1, { item: t, isActive: e3.active }), typeof t.description < "u" && jsx($$4, { size: "2xs", as: "div", intensity: 36, children: t.description })] })] });
}, pi$1 = (e3) => {
  let { item: { name: t }, isActive: o } = e3;
  return jsxs(z$1, { itemAlign: "center", width: "100%", position: "relative", children: [jsxs("div", { className: "oui-flex-1 oui-flex", children: [jsx($$4.gradient, { color: o ? "brand" : "inherit", size: "xs", as: "div", intensity: 80, weight: "semibold", children: t }), typeof e3.item.tag < "u" && jsx(gi$2, { item: e3.item })] }), e3.item.target === "_blank" && jsx(fi$2, {})] });
}, gi$2 = (e3) => jsx("div", { className: "oui-px-2 oui-py-1 oui-ml-1 oui-rounded oui-inline-flex oui-bg-gradient-to-r oui-from-[rgb(var(--oui-gradient-brand-start)_/_0.12)] oui-to-[rgb(var(--oui-gradient-brand-end)_/_0.12)]", children: jsx($$4.gradient, { color: "brand", size: "3xs", children: e3.item.tag }) }), _t$2 = "oui-flex oui-border oui-border-line oui-w-6 oui-h-6 oui-rounded-md oui-justify-center oui-items-center oui-absolute oui-left-0 oui-top-0", Kt$3 = (e3) => {
  let { item: t, isActive: o } = e3;
  return e3.item.icon ? typeof e3.item.icon == "string" ? jsx("span", { className: "oui-w-[20px] oui-h-[20px] oui-mr-1", children: jsx("img", { src: o && e3.item.activeIcon || e3.item.icon, className: "oui-max-w-full oui-max-h-full" }) }) : jsxs(Fragment$1, { children: [jsx("div", { className: cnBase(_t$2, "group-data-[active=true]:oui-invisible group-hover:oui-invisible"), children: e3.item.icon }), jsx("div", { className: cnBase(_t$2, "oui-invisible group-data-[active=true]:oui-visible group-hover:oui-visible"), children: e3.item.activeIcon || e3.item.icon })] }) : null;
}, fi$2 = () => jsxs(Fragment$1, { children: [jsx("svg", { width: "20", height: "20", viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg", className: "oui-absolute oui-right-0 oui-top-0 group-hover:oui-invisible", children: jsx("path", { d: "M14.159 17.492a3.333 3.333 0 0 0 3.333-3.333V5.826a3.333 3.333 0 0 0-3.333-3.334H5.826a3.333 3.333 0 0 0-3.334 3.334v8.333a3.333 3.333 0 0 0 3.334 3.333zm-6.667-4.166a.85.85 0 0 1-.599-.235.86.86 0 0 1 0-1.198l3.333-3.333-1.9-1.901h5v5l-1.901-1.9L8.09 13.09a.84.84 0 0 1-.599.235", fill: "#fff", fillOpacity: ".2" }) }), jsxs("svg", { width: "20", height: "20", viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg", className: "oui-absolute oui-right-0 oui-top-0 oui-invisible group-hover:oui-visible", children: [jsx("path", { d: "M14.159 17.492a3.333 3.333 0 0 0 3.333-3.333V5.826a3.333 3.333 0 0 0-3.333-3.334H5.826a3.333 3.333 0 0 0-3.334 3.334v8.333a3.333 3.333 0 0 0 3.334 3.333zm-6.667-4.166a.85.85 0 0 1-.599-.235.86.86 0 0 1 0-1.198l3.333-3.333-1.9-1.901h5v5l-1.901-1.9L8.09 13.09a.84.84 0 0 1-.599.235", fill: "url(#outlineIcon)" }), jsx("defs", { children: jsxs("linearGradient", { id: "outlineIcon", x1: "17.492", y1: "9.992", x2: "2.492", y2: "9.992", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "rgb(var(--oui-gradient-brand-end))" }), jsx("stop", { offset: "1", stopColor: "rgb(var(--oui-gradient-brand-start))" })] }) })] })] });
var $t$6 = (e3) => jsxs(Fragment$1, { children: [jsx(Se$5, { item: e3.item, onClick: e3.onItemClick, classNames: { navItem: cnBase("oui-gradient-primary oui-text-white", e3.className) } }), jsx(te$6, { direction: "vertical", className: "oui-h-8", intensity: 8 })] });
var Te$2 = Ce__default__default.forwardRef((e3, t) => {
  let { size: o = 20, ...n4 } = e3;
  return jsx("svg", { width: o, height: o, viewBox: "0 0 20 20", ref: t, fill: "#fff", fillOpacity: ".54", xmlns: "http://www.w3.org/2000/svg", ...n4, children: jsx("path", { d: "M4.108 9.464S9.645 7.13 11.565 6.31c.736-.328 3.233-1.38 3.233-1.38s1.152-.46 1.056.658c-.032.46-.288 2.069-.544 3.81-.384 2.463-.8 5.157-.8 5.157s-.064.755-.608.887c-.544.13-1.44-.46-1.6-.592-.129-.098-2.401-1.576-3.233-2.299-.224-.197-.48-.591.032-1.051a124 124 0 0 0 3.36-3.285c.384-.394.768-1.313-.832-.197-2.272 1.61-4.513 3.12-4.513 3.12s-.512.33-1.472.034-2.08-.69-2.08-.69-.768-.493.544-1.018" }) });
}), Ie$2 = Ce__default__default.forwardRef((e3, t) => {
  let { size: o = 20, ...n4 } = e3;
  return jsx("svg", { width: o, height: o, viewBox: "0 0 20 20", ref: t, fill: "#fff", fillOpacity: ".54", ...n4, xmlns: "http://www.w3.org/2000/svg", children: jsx("path", { d: "M14.956 5.522c1.604 2.374 2.396 5.053 2.1 8.136a.05.05 0 0 1-.02.033 11.7 11.7 0 0 1-3.55 1.805.045.045 0 0 1-.05-.017 9.6 9.6 0 0 1-.725-1.188.046.046 0 0 1 .024-.063 7 7 0 0 0 1.108-.531.046.046 0 0 0 .004-.076 6 6 0 0 1-.22-.174.04.04 0 0 0-.047-.006c-2.296 1.068-4.812 1.068-7.136 0a.04.04 0 0 0-.046.006 6 6 0 0 1-.22.174.046.046 0 0 0 .005.076c.353.204.721.384 1.107.531.025.01.037.039.025.063a8.5 8.5 0 0 1-.725 1.188.05.05 0 0 1-.05.017 11.7 11.7 0 0 1-3.546-1.805.05.05 0 0 1-.018-.033c-.248-2.667.257-5.368 2.097-8.137a.04.04 0 0 1 .02-.016 11.6 11.6 0 0 1 2.89-.903.05.05 0 0 1 .046.022c.125.224.269.51.366.744a10.7 10.7 0 0 1 3.246 0 8 8 0 0 1 .36-.744.044.044 0 0 1 .046-.022 11.7 11.7 0 0 1 2.89.903q.012.005.019.017m-6.018 5.07c.011-.788-.56-1.44-1.276-1.44-.71 0-1.276.647-1.276 1.44 0 .795.576 1.442 1.276 1.442.71 0 1.276-.647 1.276-1.441m4.718 0c.011-.788-.56-1.44-1.276-1.44-.71 0-1.276.647-1.276 1.44 0 .795.577 1.442 1.276 1.442.717 0 1.276-.647 1.276-1.441" }) });
}), Pe$4 = Ce__default__default.forwardRef((e3, t) => {
  let { size: o = 20, ...n4 } = e3;
  return jsx("svg", { width: o, height: o, viewBox: "0 0 20 20", ref: t, fill: "#fff", fillOpacity: ".54", xmlns: "http://www.w3.org/2000/svg", ...n4, children: jsx("path", { d: "m4.42 4.73 4.633 6.194-4.662 5.037H5.44l4.082-4.41 3.298 4.41h3.57l-4.893-6.543 4.34-4.689h-1.05l-3.759 4.062-3.037-4.062zm1.543.772h1.64l7.244 9.686h-1.64z" }) });
});
Pe$4.displayName = "CommuntiyXIcon";
Te$2.displayName = "CommuntiyTelegramIcon";
Ie$2.displayName = "CommuntiyDiscordIcon";
var $e$4 = Ce__default__default.forwardRef((e3, t) => {
  let { opacity: o = 1, ...n4 } = e3;
  return jsxs("svg", { ref: t, width: "45", height: "14", viewBox: "0 0 45 14", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...n4, children: [jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M8.352 2.558a.063.063 0 0 1-.04.112H2.419a.063.063 0 0 1-.04-.112A4.73 4.73 0 0 1 5.365 1.5c1.132 0 2.171.396 2.987 1.058M3.518 7.546a.18.18 0 0 0-.148-.08H.886a.085.085 0 0 0-.083.11 4.75 4.75 0 0 0 4.562 3.429 4.75 4.75 0 0 0 4.562-3.43.085.085 0 0 0-.082-.108H7.36a.18.18 0 0 0-.148.079 2.252 2.252 0 0 1-3.694 0m3.518-2.812a.18.18 0 0 0 .134.061h2.598c.06 0 .101-.057.082-.113a4.8 4.8 0 0 0-.801-1.432.17.17 0 0 0-.132-.062H1.814a.17.17 0 0 0-.132.062A4.8 4.8 0 0 0 .88 4.682a.085.085 0 0 0 .081.113h2.6c.05 0 .099-.023.133-.06a2.25 2.25 0 0 1 1.67-.742c.663 0 1.258.286 1.67.741M7.6 6.95a.067.067 0 0 1-.063-.086 2.26 2.26 0 0 0-.079-1.45.067.067 0 0 1 .061-.093h2.45c.03 0 .058.022.063.052a4.8 4.8 0 0 1 .04 1.52.064.064 0 0 1-.065.057zm-4.407-.086a.067.067 0 0 1-.063.086H.723a.064.064 0 0 1-.064-.056 4.8 4.8 0 0 1 .039-1.52.065.065 0 0 1 .063-.053h2.45c.047 0 .079.049.061.093a2.25 2.25 0 0 0-.079 1.45", fill: "#fff", fillOpacity: o }), jsx("path", { d: "M11.272 4.438h1.685v1.61l-.275-.312q.237-.511.662-.874.425-.361.949-.487.524-.124 1.073.038v1.585q-.661-.224-1.223-.125-.55.1-.874.475-.312.375-.312.923v3.608h-1.685zm4.148 3.22q0-.923.4-1.697.41-.774 1.123-1.211a2.95 2.95 0 0 1 1.573-.437 2.7 2.7 0 0 1 1.523.437 2.8 2.8 0 0 1 1.01 1.198q.363.762.363 1.71 0 .95-.362 1.71-.35.762-1.011 1.199a2.7 2.7 0 0 1-1.523.437 2.95 2.95 0 0 1-1.573-.437 3.1 3.1 0 0 1-1.124-1.198 3.7 3.7 0 0 1-.4-1.71m1.748 0q0 .5.224.924.225.412.612.65.387.236.861.236.475 0 .862-.237.386-.237.611-.649.225-.424.225-.924 0-.498-.225-.91-.225-.425-.611-.65a1.6 1.6 0 0 0-.862-.237q-.474 0-.861.237a1.6 1.6 0 0 0-.612.65q-.224.412-.224.91m3.395-6.016h1.685v9.237h-1.685zm4.192 5.329h3.97l-.387.537a2 2 0 0 0-.25-.9 1.63 1.63 0 0 0-.612-.623 1.64 1.64 0 0 0-.861-.225q-.487 0-.886.25a1.6 1.6 0 0 0-.625.686 2.1 2.1 0 0 0-.224.961q0 .537.224.974.239.436.662.687.425.25.961.25.525 0 .937-.238.423-.25.661-.674l1.386.624q-.45.787-1.236 1.26-.786.463-1.798.463-.96 0-1.747-.437a3.3 3.3 0 0 1-1.248-1.198 3.34 3.34 0 0 1-.45-1.71q0-.924.437-1.686.45-.775 1.223-1.21.774-.45 1.723-.45 1.061 0 1.885.537.825.536 1.21 1.448.4.898.226 1.96h-5.181zm6.221-2.534h1.685v1.61l-.274-.312q.237-.511.661-.874.425-.361.949-.487.525-.124 1.073.038v1.585q-.661-.224-1.223-.125-.549.1-.874.475-.312.375-.312.923v3.608h-1.685zm4.885-2.796h1.686v9.237H35.86zm4.359 9.324q.224.487.587.737.362.262.836.262.711 0 1.186-.5.487-.486.487-1.26V9.08l.262.35a2.43 2.43 0 0 1-.911 1.011q-.6.362-1.373.362-.8 0-1.386-.337a2.3 2.3 0 0 1-.886-.936q-.312-.6-.312-1.386V4.438h1.685v3.408q0 .436.162.761.162.312.462.5.312.174.761.174.45 0 .8-.175a1.3 1.3 0 0 0 .549-.511q.187-.338.187-.75V4.439H45v5.767q0 .936-.45 1.685a3.07 3.07 0 0 1-1.21 1.186 3.4 3.4 0 0 1-1.698.424q-.973 0-1.735-.474a3.3 3.3 0 0 1-1.186-1.26z", fill: "#fff", fillOpacity: o })] });
});
var Le$5 = Ce__default__default.forwardRef((e3, t) => {
  let { size: o = 18, ...n4 } = e3;
  return jsx("svg", { width: o, height: o, viewBox: "0 0 18 18", ref: t, className: "oui-fill-success-light", xmlns: "http://www.w3.org/2000/svg", ...n4, children: jsx("path", { d: "M9.02092 2.92969C6.18562 2.92969 3.51037 4.13854 1.68502 6.18754C1.40947 6.49676 1.446 6.96671 1.75537 7.24218C2.0646 7.51743 2.53447 7.48143 2.81002 7.17183C4.35112 5.44196 6.6141 4.42969 9.02092 4.42969C11.4205 4.42969 13.6369 5.43123 15.185 7.17183C15.4603 7.48143 15.9301 7.51743 16.2397 7.24218C16.5492 6.96694 16.5853 6.49699 16.31 6.18754C14.4787 4.12856 11.8512 2.92969 9.02092 2.92969ZM9.02092 5.92969C7.04092 5.92969 5.20867 6.78461 3.93502 8.25019C3.6633 8.56294 3.6927 9.03318 4.00537 9.30468C4.31797 9.57618 4.7883 9.54693 5.06002 9.23418C6.05175 8.09343 7.47982 7.42968 9.02092 7.42968C10.5348 7.42968 11.9446 8.08144 12.935 9.18769C13.2113 9.49593 13.681 9.51093 13.9897 9.23418C14.2983 8.95818 14.3364 8.48793 14.06 8.17968C12.7879 6.75896 10.9659 5.92969 9.02092 5.92969ZM9.02092 8.92968C7.91917 8.92968 6.89242 9.40218 6.18502 10.2189C5.91375 10.5317 5.94225 11.0019 6.25537 11.2734C6.56835 11.5449 7.03875 11.5164 7.31002 11.2029C7.73542 10.7124 8.3589 10.4297 9.02092 10.4297C9.6684 10.4297 10.2604 10.7072 10.685 11.1797C10.962 11.4879 11.4552 11.5037 11.7631 11.2262C12.0712 10.9494 12.087 10.4799 11.81 10.1717C11.1037 9.38643 10.0983 8.92968 9.02092 8.92968ZM8.99752 11.9297C8.81609 11.9297 8.64374 12.0047 8.50537 12.1404C8.50537 12.1404 7.3935 13.2362 6.95842 13.6637C6.52342 14.0919 6.7968 14.9319 7.49752 14.9297H9.63037H10.4975C11.1864 14.9319 11.477 14.0739 11.0366 13.6404C10.5961 13.2069 9.51322 12.1404 9.51314 12.1404C9.37469 12.0047 9.17894 11.9297 8.99752 11.9297Z" }) });
});
Le$5.displayName = "SignalIcon";
var ce$6 = (e3) => {
  let { size: t = 20, viewBox: o, ...n4 } = e3;
  return jsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: `${t}px`, height: `${t}px`, fill: "none", viewBox: "0 0 20 20", ...n4, children: jsx("path", { d: "M10.012 1.66602C5.40954 1.66602 1.67871 5.39685 1.67871 9.99935C1.67871 14.6018 5.40954 18.3327 10.012 18.3327C14.6145 18.3327 18.3454 14.6018 18.3454 9.99935C18.3454 5.39685 14.6145 1.66602 10.012 1.66602ZM10.012 5.83268C10.472 5.83268 10.8454 6.20602 10.8454 6.66602V10.8327C10.8454 11.2927 10.472 11.666 10.012 11.666C9.55204 11.666 9.17871 11.2927 9.17871 10.8327V6.66602C9.17871 6.20602 9.55204 5.83268 10.012 5.83268ZM10.012 12.4993C10.472 12.4993 10.8454 12.8727 10.8454 13.3327C10.8454 13.7927 10.472 14.166 10.012 14.166C9.55204 14.166 9.17871 13.7927 9.17871 13.3327C9.17871 12.8727 9.55204 12.4993 10.012 12.4993Z", fill: "#FF7D00" }) });
};
var Xe$6 = (e3) => jsxs("svg", { width: "200", height: "24", viewBox: "0 0 200 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...e3, children: [jsx("path", { d: "M22.2637 18.5152H26.1444V13.3629C26.1444 10.2669 27.9664 9.39239 29.6701 9.39239C29.9777 9.39239 30.2617 9.41602 30.6639 9.46329V6.20176C30.2853 6.10722 29.9777 6.08359 29.7174 6.08359C27.8481 6.08359 26.6886 7.3362 26.2153 9.27421H26.1444V6.22539H22.2637V18.5152Z", fill: "white" }), jsx("path", { d: "M37.3191 18.7516C39.1411 18.7516 40.3952 17.7826 40.7265 16.8608V18.5152H44.6072V1.97122H40.7265V7.87979C40.3952 6.95806 39.1411 5.98905 37.3191 5.98905C34.8108 5.98905 31.9713 7.83252 31.9713 12.3703C31.9713 16.9317 34.8108 18.7516 37.3191 18.7516ZM35.6153 12.3703C35.6153 10.196 36.9168 9.20331 38.2892 9.20331C39.638 9.20331 40.8921 10.196 40.8921 12.3703C40.8921 14.5447 39.638 15.5373 38.2892 15.5373C36.9168 15.5373 35.6153 14.5447 35.6153 12.3703Z", fill: "white" }), jsx("path", { d: "M53.418 18.7516C56.4468 18.7516 58.6475 17.1917 59.2154 14.3556H55.8079C55.595 15.1592 55.0744 15.8209 53.489 15.8209C51.9746 15.8209 51.0281 15.1355 50.8151 13.3393H59.31C59.3573 13.0557 59.381 12.8194 59.381 12.3703C59.381 7.57255 56.5888 5.98905 53.418 5.98905C50.1289 5.98905 47.1474 7.73799 47.1474 12.323C47.1474 17.0972 50.3655 18.7516 53.418 18.7516ZM50.8388 11.0941C51.0754 9.676 51.8799 8.9197 53.3234 8.9197C55.0981 8.9197 55.6423 10.0305 55.7133 11.0941H50.8388Z", fill: "white" }), jsx("path", { d: "M61.8978 18.5152H65.7784V13.3629C65.7784 10.2669 67.6005 9.39239 69.3042 9.39239C69.6118 9.39239 69.8957 9.41602 70.298 9.46329V6.20176C69.9194 6.10722 69.6118 6.08359 69.3515 6.08359C67.4821 6.08359 66.3227 7.3362 65.8494 9.27421H65.7784V6.22539H61.8978V18.5152Z", fill: "white" }), jsx("path", { d: "M72.5672 18.5152H76.4479V1.97122H72.5672V18.5152Z", fill: "white" }), jsx("path", { d: "M79.8261 20.0278V23.2893C83.6358 23.6911 85.2212 22.4149 86.8776 18.3734L91.8468 6.22539H87.8714L85.1739 13.5757L82.5473 6.22539H78.5957L83.0679 17.2626C83.3755 17.9953 83.3992 18.3734 83.1389 18.9643C82.9259 19.437 82.3817 20.3587 79.8261 20.0278Z", fill: "white" }), jsx("path", { d: "M100.278 18.5152H104.229V8.63609H104.324L110.287 18.5152H114.546V1.97122H110.571V12.1103H110.476L104.371 1.97122H100.278V18.5152Z", fill: "white" }), jsx("path", { d: "M123.327 18.7516C126.356 18.7516 128.557 17.1917 129.125 14.3556H125.717C125.504 15.1592 124.984 15.8209 123.398 15.8209C121.884 15.8209 120.937 15.1355 120.724 13.3393H129.219C129.267 13.0557 129.29 12.8194 129.29 12.3703C129.29 7.57255 126.498 5.98905 123.327 5.98905C120.038 5.98905 117.057 7.73799 117.057 12.323C117.057 17.0972 120.275 18.7516 123.327 18.7516ZM120.748 11.0941C120.985 9.676 121.789 8.9197 123.233 8.9197C125.007 8.9197 125.552 10.0305 125.623 11.0941H120.748Z", fill: "white" }), jsx("path", { d: "M137.439 18.6807C138.172 18.6807 138.882 18.5861 139.474 18.4207V15.5609C138.93 15.6082 138.717 15.6082 138.456 15.6082C137.202 15.6082 136.966 14.9228 136.966 14.072V9.22695H139.379V6.22539H136.966V3.01113H133.085V6.22539H130.979V9.22695H133.085V14.6156C133.085 17.4753 134.789 18.6807 137.439 18.6807Z", fill: "white" }), jsx("path", { d: "M144.456 18.5152H148.833L150.797 11.3777L152.761 18.5152H157.115L160.333 6.22539H156.666L154.749 14.781H154.654L152.454 6.22539H149.117L146.917 14.781H146.822L144.905 6.22539H141.261L144.456 18.5152Z", fill: "white" }), jsx("path", { d: "M167.796 18.7516C170.896 18.7516 174.043 16.8845 174.043 12.3703C174.043 7.85616 170.896 5.98905 167.796 5.98905C164.673 5.98905 161.549 7.85616 161.549 12.3703C161.549 16.8845 164.673 18.7516 167.796 18.7516ZM165.169 12.3703C165.169 10.196 166.282 9.20331 167.796 9.20331C169.287 9.20331 170.399 10.196 170.399 12.3703C170.399 14.5447 169.287 15.5373 167.796 15.5373C166.282 15.5373 165.169 14.5447 165.169 12.3703Z", fill: "white" }), jsx("path", { d: "M176.554 18.5152H180.434V13.3629C180.434 10.2669 182.256 9.39239 183.96 9.39239C184.268 9.39239 184.552 9.41602 184.954 9.46329V6.20176C184.575 6.10722 184.268 6.08359 184.007 6.08359C182.138 6.08359 180.979 7.3362 180.505 9.27421H180.434V6.22539H176.554V18.5152Z", fill: "white" }), jsx("path", { d: "M187.223 18.5152H191.104V14.9701L192.074 13.9302L195.742 18.5152H200.001L194.44 11.4249L199.362 6.22539H195.126L191.104 10.8104V1.97122H187.223V18.5152Z", fill: "white" }), jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M9.66235 0.640167L9.70838 0.640167C12.1367 0.64581 14.355 1.54403 16.052 3.02375C16.1722 3.1286 16.0961 3.32102 15.9365 3.32102L3.43427 3.32102C3.27465 3.32102 3.1985 3.1286 3.31874 3.02375C5.01571 1.54403 7.23406 0.645809 9.66235 0.640167Z", fill: "white" }), jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M5.9175 12.9472C5.84821 12.8485 5.73663 12.7865 5.61594 12.7865L0.606422 12.7865C0.461299 12.7865 0.355489 12.924 0.39667 13.063C1.58273 17.0661 5.29234 19.9869 9.68495 19.9869C14.0776 19.9869 17.7872 17.0661 18.9732 13.063C19.0144 12.924 18.9086 12.7865 18.7635 12.7865L13.754 12.7865C13.6333 12.7865 13.5218 12.8485 13.4525 12.9472C12.6208 14.1317 11.2434 14.9061 9.68499 14.9061C8.12654 14.9061 6.74917 14.1317 5.9175 12.9472Z", fill: "white" }), jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M13.3322 7.51577C13.4208 7.63078 13.5556 7.7029 13.7009 7.7029L18.7216 7.7029C18.868 7.7029 18.9741 7.56325 18.9304 7.42361C18.551 6.2113 17.9392 5.10154 17.147 4.14637C17.0811 4.06686 16.9826 4.02197 16.8792 4.02197L2.4903 4.02197C2.38694 4.02197 2.28845 4.06686 2.22251 4.14637C1.43037 5.10153 0.818541 6.2113 0.439134 7.42361C0.395431 7.56325 0.501494 7.7029 0.647976 7.7029L5.66868 7.7029C5.81394 7.7029 5.9488 7.63078 6.03735 7.51577C6.87801 6.42387 8.19911 5.72017 9.68478 5.72017C11.1704 5.72017 12.4916 6.42387 13.3322 7.51577Z", fill: "white" }), jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M14.1283 12.0868C14.0334 12.0868 13.969 11.9902 14.0018 11.9013C14.184 11.4069 14.2835 10.8724 14.2835 10.3148C14.2835 9.70687 14.1652 9.12653 13.9505 8.59547C13.9142 8.50592 13.9788 8.40582 14.0755 8.40582L19.0003 8.40582C19.1057 8.40582 19.1968 8.48012 19.2156 8.58377C19.3172 9.14546 19.3702 9.72401 19.3702 10.3149C19.3702 10.8567 19.3256 11.3881 19.2399 11.9057C19.2225 12.0108 19.1307 12.0868 19.0241 12.0868L14.1283 12.0868ZM5.36846 11.9013C5.40122 11.9902 5.33678 12.0868 5.24195 12.0868L0.346163 12.0868C0.239492 12.0868 0.147732 12.0108 0.130321 11.9057C0.0445957 11.3881 0 10.8567 0 10.3149C0 9.72401 0.0530502 9.14546 0.154653 8.58377C0.173403 8.48011 0.264481 8.40582 0.369941 8.40582L5.29476 8.40582C5.39146 8.40582 5.45599 8.50592 5.41977 8.59547C5.20498 9.12653 5.08673 9.70687 5.08673 10.3148C5.08673 10.8724 5.18623 11.4069 5.36846 11.9013Z", fill: "white" })] });
var ue$6 = (e3) => {
  let { appIcons: t } = rr$1();
  if (e3.src) return jsx(as$1, { src: e3.src, alt: e3.alt });
  let { main: o } = t || {};
  return (o == null ? void 0 : o.img) ? jsx("img", { src: o == null ? void 0 : o.img }) : (o == null ? void 0 : o.component) ? o.component : jsx(Xe$6, {});
};
var eo$4 = (e3) => {
  let { items: t, classNames: o } = e3;
  return !Array.isArray(t) || t.length === 0 ? null : jsx(z$1, { className: cnBase("oui-gap-[6px] 2xl:oui-gap-2", o == null ? void 0 : o.root), children: t == null ? void 0 : t.map((n4, i) => jsx(Se$5, { item: n4, currentPath: e3.current, onClick: e3.onItemClick }, i)) });
};
zo$2({ name: "default-main-nav-menus", positions: [Et$5.MainMenus], __isInternal: true })((e3) => jsx(eo$4, { ...e3 }));
var oo$2 = (e3) => jsx(ei$3, { position: Et$5.MainMenus, ...e3 });
var et$2 = 60;
function tt$3() {
  let [e3, t] = useState(false), [o, n4] = useState(true), [i, r3] = useState(false), [a2, l2] = useState(et$2), [c2, m2] = useState(""), [g2, h2] = useState(""), S2 = useEventEmitter(), { track: v2 } = useTrack(), { state: k2, account: d2 } = useAccount(), [u2, { findByChainId: y2 }] = useChains(void 0, { pick: "network_infos", filter: (M2) => {
    var _a2, _b2;
    return ((_a2 = M2.network_infos) == null ? void 0 : _a2.bridge_enable) || ((_b2 = M2.network_infos) == null ? void 0 : _b2.bridgeless);
  } }), C2 = () => {
    var _a2;
    let M2 = y2(d2.chainId);
    return { wallet: (_a2 = k2 == null ? void 0 : k2.connectWallet) == null ? void 0 : _a2.name, network: M2 == null ? void 0 : M2.network_infos.name };
  }, A2 = useCallback(async () => {
    try {
      let M2 = await d2.createApiKey(30);
      m2(M2.secretKey), n4(false), v2(EnumTrackerKeys.signLinkDeviceMessageSuccess, C2());
    } catch (M2) {
      M2 instanceof Error && M2.message.indexOf("Signing off chain messages with Ledger is not yet supported") !== -1 && S2.emit("wallet:sign-message-with-ledger-error", { message: M2.message, userAddress: d2.address }), q2();
    }
  }, [d2]), Z3 = useCallback(() => {
    t(true), A2(), v2(EnumTrackerKeys.clickLinkDeviceButton, C2());
  }, [d2]), q2 = useCallback(() => {
    t(false);
  }, []), V2 = useCallback(() => {
    r3(true), v2(EnumTrackerKeys.linkDeviceModalClickConfirm, {});
  }, []), P2 = useCallback(() => {
    navigator.clipboard.writeText(g2);
  }, [g2]);
  return useEffect(() => {
    e3 || (r3(false), n4(true), l2(et$2), m2(""), h2(""));
  }, [e3]), useEffect(() => {
    if (a2 === 0) {
      q2();
      return;
    }
    if (!i) return;
    let M2 = setTimeout(() => {
      l2(a2 - 1);
    }, 1e3);
    return () => clearTimeout(M2);
  }, [a2, i]), useEffect(() => {
    var _a2;
    if (i && c2) {
      let M2 = Math.floor(Date.now() / 1e3) + et$2, $2 = { k: c2, t: M2, a: d2.address, i: d2.chainId, n: (_a2 = d2.walletAdapter) == null ? void 0 : _a2.chainNamespace }, E3 = Fi$1($2);
      h2(E3);
    }
  }, [i, c2]), { open: e3, onOpenChange: t, showDialog: Z3, hideDialog: q2, loading: o, seconds: a2, confirm: i, onConfirm: V2, url: g2, copyUrl: P2 };
}
function Fi$1(e3) {
  let t = JSON.stringify(e3), o = window.btoa(t);
  return `${window.location.origin}?link=${o}`;
}
var ot$3 = (e3) => {
  let { t } = Z$2();
  return jsxs(Fragment$1, { children: [jsx(Ki$1, { className: "oui-text-base-contrast-80 oui-cursor-pointer", onClick: e3.showDialog }), jsx(me$4, { title: jsx($$4, { weight: "semibold", children: t("common.confirm") }), open: e3.open, onOpenChange: e3.onOpenChange, size: "sm", contentProps: { onInteractOutside: (o) => {
    document.querySelector("#privy-dialog") && o.preventDefault();
  } }, children: jsx(so$4, { ...e3 }) })] });
}, so$4 = (e3) => e3.loading ? jsx(Ui, {}) : e3.confirm ? jsx(Oi, { hideDialog: e3.hideDialog, seconds: e3.seconds, url: e3.url, copyUrl: e3.copyUrl }) : jsx(_i$3, { hideDialog: e3.hideDialog, onConfirm: e3.onConfirm }), Oi = (e3) => {
  let { t } = Z$2(), o = { primary: { label: t("common.ok"), onClick: e3.hideDialog, size: "md" } };
  return jsxs(z$1, { direction: "column", gapY: 3, children: [jsx($$4, { size: "base", intensity: 98, children: t("linkDevice.scanQRCode") }), jsx($$4, { size: "2xs", intensity: 54, weight: "regular", className: "oui-text-center", children: jsx(Trans, { i18nKey: "linkDevice.createQRCode.success.description" }) }), jsxs($$4, { size: "sm", intensity: 54, children: [`${t("common.countdown")}: `, jsxs($$4.gradient, { color: "brand", className: "oui-tabular-nums", children: [e3.seconds, "s"] })] }), jsx(z$1, { className: cnBase("oui-w-[240px] oui-h-[240px] ", "oui-border oui-border-base-contrast-20 oui-rounded-2xl"), justify: "center", itemAlign: "center", children: jsx(z$1, { className: "oui-w-[220px] oui-h-[220px] oui-rounded-lg oui-bg-white", justify: "center", itemAlign: "center", children: jsx(Wi, { width: 196, height: 196, content: e3.url }) }) }), jsxs(z$1, { direction: "row", gap: 1, className: cnBase("oui-cursor-pointer", "oui-group oui-text-base-contrast-54 hover:oui-text-base-contrast"), onClick: e3.copyUrl, children: [jsx(at$3, { size: 16, opacity: 1, className: "oui-text-base-contrast-54 group-hover:oui-text-base-contrast" }), jsx($$4, { size: "2xs", weight: "regular", children: t("linkDevice.createQRCode.success.copyUrl") })] }), jsx(Lo$4, { actions: o, className: "oui-w-full oui-p-0 !oui-pt-8" })] });
}, Wi = (e3) => {
  let t = useRef(null);
  return useEffect(() => {
    if (!t.current || !e3.content) return;
    let o = qrcode(e3.content), n4 = e3.width, i = e3.height, r3 = t.current.getContext("2d"), a2 = o.modules, l2 = n4 / a2.length, c2 = i / a2.length;
    for (let m2 = 0; m2 < a2.length; ++m2) {
      let g2 = a2[m2];
      for (let h2 = 0; h2 < g2.length; ++h2) {
        r3.fillStyle = g2[h2] ? "#000" : "#fff";
        let S2 = Math.ceil((h2 + 1) * l2) - Math.floor(h2 * l2), v2 = Math.ceil((m2 + 1) * c2) - Math.floor(m2 * c2);
        r3.fillRect(Math.round(h2 * l2), Math.round(m2 * c2), S2, v2);
      }
    }
  }, [t, e3.content]), jsx("canvas", { width: e3.width, height: e3.height, ref: t });
}, _i$3 = (e3) => {
  let { t } = Z$2(), o = { secondary: { label: t("common.cancel"), onClick: e3.hideDialog, className: "oui-flex-1", size: "md" }, primary: { label: t("common.confirm"), onClick: e3.onConfirm, className: "oui-flex-1", size: "md" } };
  return jsxs(z$1, { direction: "column", children: [jsx(ue$6, {}), jsx($$4, { size: "base", intensity: 98, className: "oui-mt-5", children: t("linkDevice.createQRCode.linkMobileDevice") }), jsx($$4, { size: "2xs", intensity: 54, weight: "regular", className: "oui-text-center oui-mt-3", children: jsx(Trans, { i18nKey: "linkDevice.createQRCode.linkMobileDevice.description", values: { hostname: window.location.hostname } }) }), jsx(Lo$4, { actions: o, className: "oui-w-full oui-p-0 !oui-pt-8" })] });
}, Ui = () => {
  let { t: e3 } = Z$2();
  return jsxs(z$1, { direction: "column", gap: 5, children: [jsx(Gi, {}), jsx($$4, { size: "sm", intensity: 98, children: e3("linkDevice.createQRCode.loading.description") })] });
}, Gi = () => jsxs("svg", { width: "80", height: "80", viewBox: "0 0 80 80", fill: "none", xmlns: "http://www.w3.org/2000/svg", className: "oui-animate-spin", children: [jsx("path", { d: "M11.4858 52.1631C10.4698 52.5965 9.28872 52.1259 8.91766 51.0855C7.68926 47.6412 7.04029 44.0121 7.00182 40.3463C6.95634 36.0129 7.76483 31.713 9.38113 27.6921C10.9974 23.6712 13.3899 20.0079 16.4219 16.9116C18.9868 14.2923 21.967 12.122 25.2375 10.4861C26.2253 9.99202 27.4035 10.4698 27.8369 11.4858L28.8571 13.8773C29.2904 14.8933 28.8139 16.0615 27.8336 16.5706C25.3569 17.8567 23.0959 19.5294 21.1375 21.5293C18.7119 24.0064 16.7979 26.9369 15.5049 30.1537C14.2119 33.3704 13.5651 36.8103 13.6015 40.277C13.6308 43.076 14.1051 45.8482 15.0026 48.4906C15.3579 49.5365 14.8933 50.7096 13.8773 51.143L11.4858 52.1631Z", fill: "url(#paint0_linear_177_6754)" }), jsx("path", { d: "M73 40C73 58.2254 58.2254 73 40 73C21.7746 73 7 58.2254 7 40C7 21.7746 21.7746 7 40 7C58.2254 7 73 21.7746 73 40ZM13.6 40C13.6 54.5803 25.4197 66.4 40 66.4C54.5803 66.4 66.4 54.5803 66.4 40C66.4 25.4197 54.5803 13.6 40 13.6C25.4197 13.6 13.6 25.4197 13.6 40Z", fill: "white", fillOpacity: "0.06" }), jsx("defs", { children: jsxs("linearGradient", { id: "paint0_linear_177_6754", x1: "73", y1: "40", x2: "7", y2: "40", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "rgb(var(--oui-gradient-brand-end))" }), jsx("stop", { offset: "1", stopColor: "rgb(var(--oui-gradient-brand-start))" })] }) })] }), Ki$1 = (e3) => {
  let { size: t = 20, viewBox: o, ...n4 } = e3;
  return jsxs("svg", { width: t, height: t, viewBox: "0 0 20 20", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...n4, children: [jsx("path", { d: "M19.167 7.583a1.74 1.74 0 0 0-1.731-1.75h-4.038a1.74 1.74 0 0 0-1.731 1.75v8.167c0 .967.775 1.75 1.73 1.75h4.039a1.74 1.74 0 0 0 1.73-1.75zm-1.154 0v7.584H12.82V7.583A.58.58 0 0 1 13.398 7h4.038a.58.58 0 0 1 .577.583m-2.02 8.75a.58.58 0 0 1-.576.584.58.58 0 0 1-.577-.584.58.58 0 0 1 .577-.583.58.58 0 0 1 .577.583" }), jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M1.666 5a2.5 2.5 0 0 1 2.5-2.5h10a2.5 2.5 0 0 1 2.5 2.5.08.08 0 0 1-.078.078h-1.51a.08.08 0 0 1-.08-.078.834.834 0 0 0-.833-.833h-10A.834.834 0 0 0 3.333 5v5.633c0 .11.09.2.2.2h7.1c.11 0 .2.09.2.2V12.3a.2.2 0 0 1-.2.2H2.7a.2.2 0 0 0-.2.2v.633c0 .511.308.834.834.834h7.3c.11 0 .2.09.2.2v1.266a.2.2 0 0 1-.2.2h-7.3c-1.465 0-2.5-1.086-2.5-2.5v-1.666c0-.392.27-.72.635-.81.107-.026.198-.113.198-.224z" })] });
};
var nt$2 = () => {
  let e3 = tt$3();
  return jsx(ot$3, { ...e3 });
};
var it$2 = () => {
  let [e$1, t] = useState(false), [o, n4] = useState(e2.language), { languages: i } = Y$3();
  return { open: e$1, onOpenChange: t, languages: i, selectedLang: o, onLangChange: (a2) => {
    n4(a2), e2.changeLanguage(a2), t(false);
  } };
};
var st$1 = (e3) => {
  let { languages: t } = e3, { t: o } = Z$2();
  if (t.length <= 1) return null;
  let n4 = jsx("div", { children: jsx(tr$1, { className: cnBase("oui-w-6 oui-h-6 lg:oui-w-5 lg:oui-h-5", "oui-text-base-contrast-80 oui-cursor-pointer") }) }), i = jsx(_$1, { height: 24, children: jsx($$4, { children: o("common.language") }) }), r3 = jsx(_$1, { mt: 4, className: cnBase("oui-max-h-[348px] oui-overflow-y-auto oui-custom-scrollbar", "oui-grid oui-gap-1 oui-pr-[6px]"), children: t.map((a2) => {
    let l2 = e3.selectedLang === a2.localCode;
    return jsx(er, { selected: l2, item: a2, onClick: () => e3.onLangChange(a2.localCode) }, a2.localCode);
  }) });
  return jsxs(Yi, { open: e3.open, onOpenChange: e3.onOpenChange, children: [jsx(Xi$1, { asChild: true, children: n4 }), jsx(ji, { children: jsxs(rr$2, { onCloseAutoFocus: (a2) => a2.preventDefault(), onClick: (a2) => a2.stopPropagation(), sideOffset: 10, align: "start", collisionPadding: { right: 16 }, className: cnBase("oui-w-[320px] lg:oui-w-[360px]", "oui-bg-base-8 oui-p-5 oui-rounded-xl", "oui-border oui-border-line-6", "oui-font-semibold"), children: [i, r3] }) })] });
}, er = (e3) => {
  let { item: t } = e3;
  return jsx("button", { className: cnBase("oui-group oui-rounded-md hover:oui-bg-base-5", e3.selected && "oui-bg-base-5"), onClick: e3.onClick, children: jsxs(z$1, { justify: "between", className: "oui-h-10", px: 3, children: [jsx(z$1, { itemAlign: "center", width: "100%", className: "oui-gap-x-[6px]", children: jsx($$4, { size: "2xs", className: cnBase("oui-text-base-contrast-36 group-hover:oui-text-base-contrast-80", e3.selected && "oui-text-base-contrast-80"), children: t.displayName }) }), e3.selected && jsx(_$1, { gradient: "brand", r: "full", width: 4, height: 4 })] }) });
}, tr$1 = (e3) => {
  let { size: t = 20, ...o } = e3;
  return jsx("svg", { width: t, height: t, viewBox: "0 0 20 20", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...o, children: jsx("path", { d: "M10 1.678a8.333 8.333 0 1 0 0 16.667 8.333 8.333 0 1 0 0-16.667m0 1.667c1.1 0 2.308 2.527 2.492 5.831l-4.975.01c.183-3.304 1.382-5.84 2.482-5.84m-2.943.67c-.717 1.393-1.1 3.242-1.193 5.165L3.38 9.174c.248-2.271 1.778-4.176 3.676-5.159m5.889.003c1.898.983 3.388 2.835 3.676 5.168l-2.483-.008c-.078-2-.52-3.758-1.193-5.16m-9.56 6.83 2.483-.02c.092 1.923.478 3.803 1.191 5.182a6.79 6.79 0 0 1-3.674-5.162m4.118.007 4.975-.01c-.184 3.303-1.38 5.833-2.48 5.833s-2.312-2.519-2.495-5.823m6.64-.008 2.471-.008c-.287 2.208-1.68 4.18-3.672 5.162.74-1.53 1.108-3.23 1.2-5.154" }) });
};
var lt$4 = () => {
  let e3 = it$2();
  return jsx(st$1, { ...e3 });
};
var ct$3 = (e3) => {
  let { className: t, logo: o, products: n4, classNames: i, campaigns: r3, campaignPosition: a2 } = e3, l2 = a2 === "navTailing" && r3, c2 = !e3.wrongNetwork && !e3.disabledConnect && e3.status >= AccountStatusEnum.SignedIn, m2 = !e3.disabledConnect && e3.wrongNetwork && e3.isConnected, { isDesktop: g2 } = Ao$6(), h2 = useMemo(() => typeof e3.children > "u" ? null : jsx(z$1, { grow: true, children: e3.children }), [e3.children]);
  return jsxs(z$1, { width: "100%", as: "header", itemAlign: "center", height: "48px", justify: "between", px: 3, gapX: 3, className: cnBase("oui-main-nav oui-font-semibold", t, i == null ? void 0 : i.root), children: [jsxs(z$1, { itemAlign: "center", className: cnBase("oui-gap-3 2xl:oui-gap-4", "oui-overflow-hidden"), children: [jsx(ue$6, { ...o }), jsx(_e$4, { ...n4, className: i == null ? void 0 : i.products }), jsx(oo$2, { ...e3.mainMenus, classNames: i == null ? void 0 : i.mainNav })] }), h2, jsxs(z$1, { itemAlign: "center", className: "oui-gap-3 2xl:oui-gap-4", children: [!!l2 && jsx($t$6, { ...r3, className: i == null ? void 0 : i.campaignButton }), jsx(Ce$3, {}), c2 && jsxs(Fragment$1, { children: [jsx(te$6, { direction: "vertical", className: "oui-h-8", intensity: 8 }), jsx(nt$2, {})] }), jsx(lt$4, {}), g2 && jsx(ye$5, {}), !m2 && jsx(Lt$2, {})] })] });
};
ct$3.displayName = "MainNav";
var ut$1 = (e3) => {
  let { children: t, classNames: o, ...n4 } = e3, i = Wt$4(n4);
  return jsx(ct$3, { classNames: o, ...i, children: t });
};
var pr$3 = b$2({ slots: { button: ["oui-h-10", "oui-px-3", "oui-rounded-md", "oui-w-full", "oui-text-left", "oui-text-base", "oui-text-base-contrast-36", "oui-group", "hover:oui-bg-base-8", "oui-transition-colors", "group-data-[state=closed]/bar:oui-w-[42px]", "oui-overflow-hidden"], icon: [] }, variants: { mode: { "icon-only": { button: "oui-w-10", icon: "w-6 h-6" }, full: { button: "oui-full", icon: "w-6 h-6" } }, active: { true: { button: "oui-bg-base-5 hover:oui-bg-base-5" } }, open: { true: { button: "" } } } }), vo$5 = memo((e3) => {
  let { item: t, mode: o, open: n4, onClick: i, active: r3, ...a2 } = e3, { button: l2 } = pr$3({ mode: o, active: e3.active, open: e3.open }), c2 = jsx("button", { "data-actived": e3.active, disabled: t.disabled, className: l2(), onClick: () => {
    var _a2;
    (_a2 = e3.onClick) == null ? void 0 : _a2.call(e3, t);
  }, children: jsxs(z$1, { itemAlign: "center", gap: 2, as: "span", children: [t.icon, e3.open && jsx($$4.gradient, { color: e3.active ? "brand" : "inherit", angle: 45, size: "base", className: "oui-animate-in oui-fade-in", children: t.name })] }) });
  return e3.open ? jsx("li", { className: "oui-min-w-[120px]", children: c2 }) : jsx("li", { children: jsx(Xn$2, { content: t.name, side: "right", align: "center", sideOffset: 20, children: c2 }) });
});
vo$5.displayName = "LeftMenuItem";
var gr$3 = (e3) => {
  var _a2;
  return jsxs(_$1, { py: 6, children: [jsx("svg", { width: "18", height: "18", viewBox: "0 0 18 18", fill: "none", xmlns: "http://www.w3.org/2000/svg", className: "oui-absolute oui-invisible oui-pointer-events-none", children: jsx("defs", { children: jsxs("linearGradient", { id: "side-menu-gradient", x1: "15.7432", y1: "8.94726", x2: "2.24316", y2: "8.94726", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "rgb(var(--oui-gradient-brand-end))" }), jsx("stop", { offset: "1", stopColor: "rgb(var(--oui-gradient-brand-start))" })] }) }) }), jsx("ul", { className: "oui-space-y-4", children: (_a2 = e3.menus) == null ? void 0 : _a2.map((t, o) => jsx(vo$5, { item: t, open: e3.open, active: t.href === e3.current, onClick: e3.onItemSelect }, o)) })] });
}, fr$4 = (e3) => {
  let { title: t } = e3, o = typeof t == "string" ? jsx($$4, { intensity: 54, size: "xs", children: t }) : t, n4 = { className: "oui-text-base-contrast-36 hover:oui-text-base-contrast-80 oui-cursor-pointer", onClick: e3.onToggle };
  return jsxs(z$1, { justify: e3.open ? "between" : "center", itemAlign: "center", className: "oui-h-6", children: [e3.open ? o : null, e3.open ? jsx(vr$1, { ...n4 }) : jsx(hr, { ...n4 })] });
}, ge$3 = (e3) => {
  let { open: t = true, items: o, current: n4, onItemSelect: i } = e3;
  return jsxs(_$1, { "data-state": t ? "opened" : "closed", className: cnBase("oui-group/bar", e3.className), style: e3.style, children: [jsx(fr$4, { open: t, title: e3.title, onToggle: () => {
    var _a2;
    (_a2 = e3.onOpenChange) == null ? void 0 : _a2.call(e3, !t);
  } }), jsx(gr$3, { menus: o, current: n4, onItemSelect: i, open: t })] });
};
ge$3.displayName = "SideBar";
var hr = (e3) => jsx("svg", { width: "16", height: "16", viewBox: "0 0 16 16", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...e3, children: jsx("path", { d: "M6.326 8.826a.84.84 0 0 0-.6.234L2.16 12.627v-2.135H.492v4.167c0 .46.373.833.834.833h4.166v-1.667H3.357l3.567-3.567a.857.857 0 0 0 0-1.198.84.84 0 0 0-.598-.234M10.502.492V2.16h2.135L9.07 5.726a.857.857 0 0 0 0 1.199.86.86 0 0 0 1.197 0l3.568-3.568v2.135h1.667V1.326a.834.834 0 0 0-.834-.834z" }) }), vr$1 = (e3) => jsx("svg", { width: "16", height: "16", viewBox: "0 0 16 16", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...e3, children: jsx("path", { d: "M14.668.492a.85.85 0 0 0-.599.234l-3.567 3.568V2.159H8.835v4.167c0 .46.373.833.833.833h4.167V5.492H11.7l3.569-3.567a.86.86 0 0 0 0-1.199.85.85 0 0 0-.6-.234m-12.5 8.334v1.666h2.135L.736 14.06a.86.86 0 0 0 0 1.198.86.86 0 0 0 1.198 0l3.568-3.567v2.134h1.666V9.66a.834.834 0 0 0-.833-.833z" }) });
var xo$3 = (e3) => {
  var _a2;
  let [t, o] = useState(((_a2 = e3 == null ? void 0 : e3.items) == null ? void 0 : _a2[0].href) || "/"), { expanded: n4, setExpand: i } = le$4();
  return { items: [], current: t, open: n4, onOpenChange: (r3) => {
    i == null ? void 0 : i(r3);
  }, onItemSelect: (r3) => {
    r3.href && o(r3.href);
  }, ...e3 };
};
var Re$5 = (e3) => {
  let t = xo$3(e3);
  return jsx(ge$3, { ...t });
};
var pt$5 = (e3) => {
  let { t } = Z$2(), o = useMemo(() => {
    switch (e3.wsStatus) {
      case WsNetworkStatus.Connected:
        return "oui-fill-success-light oui-text-success-light";
      case WsNetworkStatus.Disconnected:
        return "oui-fill-danger-light oui-text-danger-light";
      case WsNetworkStatus.Unstable:
        return "oui-fill-warning-light oui-text-warning-light";
    }
  }, [e3.wsStatus]), n4 = (i) => {
    window.open(i, "_blank");
  };
  return jsxs(z$1, { direction: "row", justify: "between", height: 28, px: 3, width: "100%", children: [jsxs(z$1, { children: [jsxs(z$1, { direction: "row", itemAlign: "center", gap: 1, className: o, children: [jsx(Le$5, { fillOpacity: 1, fill: "currentColor" }), jsx($$4, { size: "2xs", children: t("scaffold.footer.operational") })] }), jsx(te$6, { direction: "vertical", className: "oui-h-[18px] oui-px-1 oui-ml-2 oui-border-line-12" }), jsxs(z$1, { gap: 2, children: [jsx($$4, { intensity: 54, size: "2xs", children: t("scaffold.footer.joinCommunity") }), jsxs(z$1, { direction: "row", gap: 1, children: [typeof e3.telegramUrl < "u" && jsx(Te$2, { className: "oui-fill-white/[.54] hover:oui-fill-white/[.98] oui-cursor-pointer", fill: "currentColor", fillOpacity: 1, onClick: (i) => n4(e3.telegramUrl) }), typeof e3.discordUrl < "u" && jsx(Ie$2, { className: "oui-fill-white/[.54] hover:oui-fill-white/[.98] oui-cursor-pointer", fill: "currentColor", fillOpacity: 1, onClick: (i) => n4(e3.discordUrl) }), typeof e3.twitterUrl < "u" && jsx(Pe$4, { className: "oui-fill-white/[.54] hover:oui-fill-white/[.98] oui-cursor-pointer", fill: "currentColor", fillOpacity: 1, onClick: (i) => n4(e3.twitterUrl) })] }), typeof (e3 == null ? void 0 : e3.trailing) < "u" && jsxs(Fragment$1, { children: [jsx(te$6, { direction: "vertical", className: "oui-h-[18px] oui-border-line-12" }), e3 == null ? void 0 : e3.trailing] })] })] }), jsxs(z$1, { direction: "row", gap: 1, children: [jsx($$4, { intensity: 54, size: "2xs", children: t("scaffold.footer.poweredBy") }), jsx($e$4, {})] })] });
};
var bo$4 = () => ({ wsStatus: useWsStatus() });
var gt$1 = (e3) => {
  let t = bo$4();
  return jsx(pt$5, { ...t, ...e3 });
};
function Lo$3(e3) {
  let t = format(new UTCDateMini(e3), "MMM dd");
  return `${format(new UTCDateMini(e3), "h:mm aa")} (UTC) on ${t}`;
}
var Xr = 1e3 * 60 * 60 * 24, Jr$3 = (e$1, t, o) => e2.t("scaffold.maintenance.tips.description", { brokerName: e$1, startDate: t, endDate: o }), Yr$1 = (e$1, t) => e2.t("scaffold.maintenance.dialog.description", { brokerName: e$1, endDate: t });
var Ao$5 = (e3) => {
  let [t, o] = useState(0), { setShowAnnouncement: n4 } = L$4(), { data: i } = useQuery("/v1/public/announcement", { revalidateOnFocus: false, refreshInterval: 60 * 60 * 1e3 }), [r3, a2] = useState([]), [l2, c2] = useState(void 0), [m2, g2] = useState(() => window.sessionStorage.getItem("announcementTips") !== "hidden"), h2 = useWS(), S2 = useCallback(() => {
    w$4(() => {
      window.sessionStorage.setItem("announcementTips", "hidden"), g2(false);
    });
  }, []), v2 = () => {
    o((t + 1) % r3.length);
  }, k2 = () => {
    o((t - 1 + r3.length) % r3.length);
  }, { startTime: d2, endTime: u2, status: y2, brokerName: C2 } = useMaintenanceStatus(), A2 = useMemo(() => d2 ? Lo$3(d2) : "-", [d2]), Z3 = useMemo(() => u2 ? Lo$3(u2) : "-", [u2]);
  useEffect(() => {
    let V2 = h2.subscribe("announcement", { onMessage: (P2) => {
      P2 && a2((M2) => [...M2.filter(($2) => $2.announcementId !== P2.announcement_id), { announcementId: P2.announcement_id, content: P2.message, url: P2.url }]);
    } });
    return () => {
      V2 == null ? void 0 : V2();
    };
  }, []), useEffect(() => {
    if (i) {
      if (!i.length) {
        a2((V2) => V2.filter((P2) => P2.announcementId !== "-1"));
        return;
      }
      a2((V2) => {
        let P2 = new Set(V2.map((E3) => E3.announcementId)), M2 = V2.find((E3) => E3.announcementId === "-1"), $2 = [];
        return i.forEach((E3) => {
          P2.has(E3.announcement_id) || $2.push({ announcementId: E3.announcement_id, content: E3.message, url: E3.url });
        }), M2 && $2.unshift(M2), $2;
      });
    }
  }, [i]), useEffect(() => {
    if (y2 === 2) {
      c2(Yr$1(C2, Z3));
      return;
    }
    c2(void 0), d2 ? d2 < N$3() + Xr && a2((V2) => [{ announcementId: "-1", type: "maintenance", content: Jr$3(C2, A2, Z3) }, ...V2.filter((P2) => P2.type !== "maintenance")]) : a2((V2) => V2.filter((P2) => P2.announcementId !== "-1"));
  }, [d2, y2, Z3, C2]);
  let q2 = useMemo(() => !!r3.length && m2 && !(e3 == null ? void 0 : e3.hideTips), [r3, m2, e3 == null ? void 0 : e3.hideTips]);
  return useEffect(() => {
    n4(q2);
  }, [q2]), { maintenanceDialogInfo: l2, tips: r3, currentIndex: t, showTips: m2, closeTips: S2, nextTips: v2, prevTips: k2, showAnnouncement: q2 };
};
var xt = (e3) => {
  let { closeTips: t, tips: o, currentIndex: n4, nextTips: i, prevTips: r3, maintenanceDialogInfo: a2, showAnnouncement: l2 } = e3, { isMobile: c2 } = Ao$6(), { t: m2 } = Z$2();
  if (a2) return jsx(Fo$1, { open: true, children: jsxs(oo$3, { closable: false, onOpenAutoFocus: (h2) => h2.preventDefault(), className: "oui-w-[320px] md:oui-w-auto", children: [jsx(to$4, { children: jsx(ro$5, { children: m2("scaffold.maintenance.dialog.title") }) }), jsx(te$6, {}), jsx(Vo$5, { className: "oui-text-2xs md:oui-text-xs", children: a2 })] }) });
  if (!l2) return null;
  let g2 = o[n4];
  return jsx(z$1, { style: e3.style, className: cnBase("oui-text-2xs md:oui-text-sm oui-leading-4", "oui-relative oui-gap-1 oui-rounded-xl", "md:oui-w-full oui-pl-4 oui-py-3 oui-pr-0 md:oui-pr-[60px]", "oui-min-h-[48px] md:oui-h-[34px] md:oui-min-h-[34px]", "oui-justify-start oui-items-start", "xl:oui-justify-center xl:oui-items-center xl:oui-px-4", e3.className), children: c2 ? jsx(da$1, { currentTip: g2, currentIndex: n4, tips: o, prevTips: r3, nextTips: i, closeTips: t }) : jsx(ma, { currentTip: g2, currentIndex: n4, tips: o, prevTips: r3, nextTips: i, closeTips: t }) });
}, ma = (e3) => {
  let { currentTip: t, currentIndex: o, tips: n4, prevTips: i, nextTips: r3, closeTips: a2 } = e3;
  return jsxs(Fragment$1, { children: [jsxs("div", { className: cnBase("oui-flex oui-items-start oui-justify-start oui-gap-1 oui-mx-[120px]", t.url ? "oui-cursor-pointer" : ""), children: [jsx(Vo$4, { type: t.type }), jsx(_$1, { className: "oui-font-semibold oui-leading-4 oui-ml-2 oui-text-base-contrast-80 oui-line-clamp-1 oui-overflow-hidden oui-text-ellipsis", children: t.content })] }), jsxs("div", { className: cnBase("oui-flex oui-items-center oui-justify-center oui-gap-1", "oui-absolute oui-right-2 md:oui-right-4 oui-top-2/4 -oui-translate-y-2/4"), children: [jsx(Ro$3, { currentIndex: o, tipsCount: n4.length, prevTips: i, nextTips: r3 }), jsx(Fo, { closeTips: a2 })] })] });
}, da$1 = (e3) => {
  let { currentTip: t, currentIndex: o, tips: n4, prevTips: i, nextTips: r3, closeTips: a2 } = e3;
  return jsxs(Fragment$1, { children: [jsxs("div", { className: cnBase("oui-flex oui-flex-col oui-items-start oui-justify-start oui-gap-5 oui-w-full oui-mr-[60px] ", t.url ? "oui-cursor-pointer" : ""), children: [jsx(_$1, { className: "oui-font-semibold oui-leading-4 oui-ml-2 oui-text-base-contrast-80 oui-text-sm oui-line-clamp-2 oui-h-[36px] oui-overflow-hidden oui-text-ellipsis", children: t.content }), jsxs("div", { className: "oui-flex oui-items-center oui-justify-between oui-gap-1 oui-w-full", children: [jsx(Vo$4, { type: t.type }), jsx(Ro$3, { currentIndex: o, tipsCount: n4.length, prevTips: i, nextTips: r3 })] })] }), jsx("div", { className: cnBase("oui-absolute oui-right-4 oui-top-3"), children: jsx(Fo, { closeTips: a2 }) })] });
}, Ro$3 = ({ currentIndex: e3, tipsCount: t, prevTips: o, nextTips: n4 }) => jsxs("div", { className: "oui-flex oui-items-center oui-justify-center oui-gap-1 oui-text-base-contrast-54", children: [jsx(We$6, { size: 20, opacity: 1, className: " oui-text-base-contrast-54 hover:oui-text-base-contrast-80 oui-flex-shrink-0 oui-w-4 md:oui-w-5 oui-h-4 md:oui-h-5 oui-cursor-pointer ", onClick: o }), jsxs("div", { className: "oui-text-base-contrast-54 oui-text-xs", children: [e3 + 1, "/", t] }), jsx(Ge$2, { size: 20, opacity: 1, className: "oui-text-base-contrast-54 hover:oui-text-base-contrast-80 oui-flex-shrink-0 oui-w-4 md:oui-w-5 oui-h-4 md:oui-h-5 oui-cursor-pointer ", onClick: n4 })] }), Fo = ({ closeTips: e3 }) => jsx(ye$7, { size: 16, opacity: 1, className: " oui-ml-4 md:oui-ml-5 oui-w-5 oui-h-5 oui-text-base-contrast-80 md:oui-text-base-contrast-54 hover:oui-text-base-contrast-80 oui-cursor-pointer", onClick: e3 }), Vo$4 = ({ type: e3 }) => e3 === "listing" ? jsx("div", { className: cnBase("oui-flex oui-items-center oui-justify-center oui-px-2 oui-h-[18px] oui-rounded-sm ", "oui-bg-primary/15 oui-text-primary oui-text-2xs oui-font-medium"), children: "Listing" }) : e3 === "maintenance" ? jsx("div", { className: cnBase("oui-flex oui-items-center oui-justify-center oui-px-2 oui-h-[18px] oui-rounded-sm ", "oui-bg-[rgba(232,136,0,0.15)] oui-text-warning-darken oui-text-2xs oui-font-medium"), children: "Maintenance" }) : e3 === "delisting" ? jsx("div", { className: cnBase("oui-flex oui-items-center oui-justify-center oui-px-2 oui-h-[18px] oui-rounded-sm ", "oui-bg-[rgba(232,136,0,0.15)] oui-text-warning-darken oui-text-2xs oui-font-medium"), children: "Delisting" }) : jsx("div", {});
var Be$4 = (e3) => {
  let { hideTips: t, ...o } = e3, n4 = Ao$5({ hideTips: t });
  return jsx(xt, { ...n4, ...o });
};
var Ct$3 = (e3) => {
  let { brokerName: t } = e3, { ip: o, content: n4, restrictedOpen: i } = e3.restrictedInfo || {}, { t: r3 } = Z$2();
  if (!i) return;
  let a2 = () => typeof n4 == "function" ? jsx("span", { children: n4({ ip: o, brokerName: t }) }) : n4 || jsx("span", { children: r3("scaffold.restrictedInfo.description.default", { brokerName: t, ip: o }) });
  return jsx(z$1, { ref: e3.container, justify: "center", className: cnBase("oui-rounded-xl oui-p-[7px]", "oui-text-warning-darken", e3.className), children: jsxs(z$1, { className: cnBase("oui-min-h-[20px] oui-gap-1", "oui-text-2xs md:oui-text-sm oui-leading-4", "oui-items-start lg:oui-justify-center", e3.mutiLine ? "lg:oui-items-start" : "lg:oui-items-center"), children: [jsx(ce$6, { size: 20, className: "oui-flex-shrink-0 oui-w-4 oui-h-4 lg:oui-w-5 lg:oui-h-5" }), a2()] }) });
};
var bt$1 = () => {
  let { restrictedInfo: e3 } = L$4(), t = useConfig("brokerName"), o = useRef(null), [n4, i] = useState(false);
  return Dm(o.current, (r3) => {
    i(r3.contentRect.height > 28);
  }), { restrictedInfo: e3, brokerName: t, container: o, mutiLine: n4 };
};
var Ee$4 = (e3) => {
  let t = bt$1();
  return jsx(Ct$3, { ...e3, ...t });
};
function zo$1(e3, t) {
  return typeof e3 == "string" && (e3 = parseInt(e3)), t.some((o) => o.network_infos.chain_id === e3);
}
var Oo$2 = (e3) => {
  let [t] = useChains(), { networkId: o } = useContext(OrderlyContext), n4 = (r3) => zo$1(r3, o === "testnet" ? t.testnet : t.mainnet), i = (r3) => {
    e3.setExpand(r3);
  };
  return jsx(Ne$3.Provider, { value: { routerAdapter: e3.routerAdapter, expanded: e3.expanded, setExpand: i, checkChainSupport: n4, topNavbarHeight: e3.topNavbarHeight, footerHeight: e3.footerHeight, announcementHeight: e3.announcementHeight }, children: e3.children });
};
var Wo$2 = () => {
  let { restrictedInfo: e3, showAnnouncement: t } = L$4(), [o, n4] = wt$4(48), [i, r3] = wt$4(29), [a2, l2] = wt$4(0, [t]), [c2, m2] = useLocalStorage("orderly_scaffold_expanded", true), { isMobile: g2 } = Ao$6();
  return { topNavbarRef: o, footerRef: i, topNavbarHeight: n4, footerHeight: r3, announcementRef: a2, announcementHeight: l2, restrictedInfo: e3, expand: c2, setExpand: m2, isMobile: g2 };
}, wt$4 = (e3, t = []) => {
  let o = useRef(null), [n4, i] = useState(e3);
  return Dm(o.current, (r3) => {
    i(r3.contentRect.height);
  }), useEffect(() => {
    var _a2;
    if (!o.current) return;
    let r3 = (_a2 = o.current) == null ? void 0 : _a2.getBoundingClientRect().height;
    i(r3);
  }, [o, ...t]), [o, n4];
};
var Va = (e3) => {
  var _a2, _b2, _c2;
  let { classNames: t, footerProps: o, routerAdapter: n4 } = e3, { topNavbarHeight: i, footerHeight: r3, topNavbarRef: a2, footerRef: l2, announcementRef: c2, announcementHeight: m2, restrictedInfo: g2, expand: h2, setExpand: S2, isMobile: v2 } = Wo$2(), k2 = ((_a2 = e3.leftSideProps) == null ? void 0 : _a2.maxWidth) || 185, d2 = ((_b2 = e3.leftSideProps) == null ? void 0 : _b2.minWidth) || 98, u2 = !!e3.leftSidebar;
  return jsx(Oo$2, { routerAdapter: n4, expanded: h2, setExpand: S2, topNavbarHeight: i, footerHeight: r3, announcementHeight: m2, children: v2 ? jsxs(Fragment$1, { children: [jsxs("div", { className: "oui-fixed oui-left-0 oui-right-0 oui-top-0 oui-z-50", children: [jsx(Ee$4, { className: "oui-bg-base-6 oui-mx-1" }), jsx(Be$4, { className: "oui-bg-base-6 oui-mx-1", hideTips: g2 == null ? void 0 : g2.restrictedOpen })] }), e3.children] }) : jsxs("div", { style: { height: `calc(100vh - ${r3}px)` }, className: cnBase("oui-scaffold-root oui-font-semibold", "oui-text-base-contrast oui-bg-base-10", "oui-flex oui-flex-col", "oui-overflow-auto oui-custom-scrollbar", t == null ? void 0 : t.root), children: [jsx(_$1, { ref: a2, className: cnBase("oui-scaffold-topNavbar oui-bg-base-9", t == null ? void 0 : t.topNavbar), children: e3.topBar ?? jsx(ut$1, { ...e3.mainNavProps }) }), jsxs("div", { className: cnBase("oui-scaffold-container", "oui-relative oui-h-full", "oui-min-w-[1018px]", (_c2 = e3.classNames) == null ? void 0 : _c2.container), children: [jsxs(_$1, { px: 3, ref: c2, children: [jsx(Ee$4, { className: cnBase("oui-scaffold-restricted-info", "oui-relative oui-z-[1]", "oui-mt-3", "oui-bg-base-9", "oui-min-w-[994px]") }), jsx(Be$4, { className: cnBase("oui-scaffold-maintenance-tips", "oui-mt-3", "oui-relative oui-z-[1]", "oui-bg-base-9", "oui-min-w-[994px]"), hideTips: g2.restrictedOpen })] }), u2 ? jsxs(ia$1, { className: cnBase("oui-box-content oui-transition-all oui-flex xl:oui-grid", "oui-flex-1 oui-min-h-full", t == null ? void 0 : t.body), style: { gridTemplateColumns: `${h2 ? `${k2}px` : `${d2}px`} 1fr` }, children: [jsx("div", { className: cnBase(t == null ? void 0 : t.leftSidebar), children: isValidElement(e3.leftSidebar) ? e3.leftSidebar : jsx(Re$5, { ...e3.leftSideProps }) }), jsx(_$1, { width: "100%", className: cnBase("oui-overflow-hidden", t == null ? void 0 : t.content), children: e3.children })] }) : jsx(_$1, { height: "100%", className: cnBase(t == null ? void 0 : t.content), children: e3.children })] }), jsx(_$1, { ref: l2, className: cnBase("oui-scaffold-footer oui-w-full oui-bg-base-10", "oui-fixed oui-bottom-0 oui-z-50", "oui-border-t-[1px] oui-border-line-12", t == null ? void 0 : t.footer), children: e3.footer || jsx(gt$1, { ...o }) })] }) });
};
var m = (e3) => {
  let { currentLeverage: r3 = 0 } = e3, { t: a2 } = Z$2();
  return jsxs(z$1, { itemAlign: "start", direction: "column", mb: 0, children: [jsx(S, { currentLeverage: r3 }), jsx(f$1, { ...e3 }), jsxs(z$1, { direction: "row", gap: 2, width: "100%", mt: 0, pt: 5, children: [jsx(_e$5, { variant: "contained", color: "gray", fullWidth: true, onClick: e3.onCancel, "data-testid": "oui-testid-leverage-cancel-btn", children: a2("common.cancel") }), jsx(_e$5, { fullWidth: true, loading: e3.isLoading, onClick: e3.onSave, "data-testid": "oui-testid-leverage-save-btn", children: a2("common.save") })] })] });
}, S = (e3) => {
  let { t: r3 } = Z$2();
  return jsxs(z$1, { justify: "between", width: "100%", children: [jsx($$4, { as: "div", size: "sm", intensity: 54, className: "oui-mt-2", children: r3("leverage.maxAccountLeverage") }), jsxs(z$1, { gap: 1, children: [`${r3("common.current")}:`, jsx($$4.numeral, { unit: "x", size: "sm", intensity: 80, children: e3.currentLeverage ?? "--" })] })] });
}, f$1 = (e3) => jsxs(_$1, { pt: 3, width: "100%", className: e3.className, children: [jsx(Bl, { max: e3.maxLeverage, min: 1, markCount: 5, value: [e3.value], onValueChange: (r3) => {
  e3.onLeverageChange(r3[0]), e3.setShowSliderTip(true);
}, color: "primary", onValueCommit: (r3) => {
  var _a2;
  (_a2 = e3.onValueCommit) == null ? void 0 : _a2.call(e3, r3), e3.setShowSliderTip(false);
}, showTip: e3.showSliderTip, tipFormatter: (r3, a2, s, v2) => `${r3}x` }), jsx(z$1, { justify: "between", width: "100%", pt: 3, children: [1, 10, 20, 30, 40, 50].map((r3, a2) => jsx("button", { onClick: (s) => {
  var _a2;
  e3.onLeverageChange(r3), (_a2 = e3.onValueCommit) == null ? void 0 : _a2.call(e3, [r3]);
}, className: cnBase(" oui-text-2xs oui-pb-3", a2 === 0 ? "oui-pr-2" : a2 === 5 ? "oui-pl-0" : "oui-px-0 oui-ml-2", e3.value >= r3 && "oui-text-primary-light"), "data-testid": `oui-testid-leverage-${r3}-btn`, children: `${r3}x` })) })] });
var u$1 = (e3) => {
  let { currentLeverage: r3 } = useMarginRatio(), [a2, s] = useState(false), { t: v2 } = Z$2(), [b2, { update: y2, config: l2, isMutating: w5 }] = useLeverage(), c2 = useMemo(() => (l2 == null ? void 0 : l2.map((t) => ({ label: `${t}x`, value: t }))) || [], [l2]), [p2, P2] = useState(b2 ?? 0), T2 = l2 == null ? void 0 : l2.reduce((t, V2) => Math.max(t, Number(V2), 0), 0), F2 = 100 / (((c2 == null ? void 0 : c2.length) || 0) - 1), k2 = (t) => {
    P2(t);
  }, E3 = async () => {
    try {
      y2({ leverage: p2 }).then((t) => {
        var _a2;
        (_a2 = e3 == null ? void 0 : e3.close) == null ? void 0 : _a2.call(e3), toast$2.success(v2("leverage.updated"));
      }, (t) => {
        toast$2.error(t.message);
      });
    } catch {
    }
  };
  return { currentLeverage: r3, value: p2, marks: c2, onLeverageChange: k2, step: F2, onCancel: e3 == null ? void 0 : e3.close, onSave: E3, isLoading: w5, showSliderTip: a2, setShowSliderTip: s, maxLeverage: T2 };
};
var g$2 = (e3) => {
  let r3 = u$1({ close: e3.close });
  return jsx(m, { ...r3 });
};
var U$2 = "leverageEditor";
Pg(U$2, g$2, { title: () => e2.t("leverage.maxAccountLeverage"), size: "md" });
function wt$3(t, o) {
  let [n4, e3] = useState(""), [r3, u2] = useState(false);
  return useEffect(() => {
    r3 || typeof o != "function" || (u2(true), o(t.address, t.decimals).then((i) => {
      e3(i);
    }).catch((i) => {
    }).finally(() => {
      u2(false);
    }));
  }, [t]), { balance: n4, loading: r3 };
}
var yt$3 = (t) => {
  let { token: o, isActive: n4, onTokenChange: e3, fetchBalance: r3 } = t, { symbol: u2, precision: i, decimals: s } = o, { balance: a2, loading: m2 } = wt$3(o, r3), c2 = typeof r3 == "function", p2 = i ?? 2, f2 = () => c2 ? m2 ? jsx(we$5, { size: "sm" }) : jsx($$4.numeral, { rule: "price", dp: p2, rm: g$6.ROUND_DOWN, className: cnBase("oui-text-base-contrast-80 group-hover:oui-text-base-contrast-54", n4 && "oui-text-base-contrast-54"), children: a2 }) : null;
  return jsxs(z$1, { justify: "between", px: 2, r: "base", className: cnBase("group", "oui-h-[30px] hover:oui-bg-base-5", "oui-text-2xs oui-font-semibold", "oui-cursor-pointer", n4 && "oui-bg-base-5", t.index !== 0 && "oui-mt-[2px]"), onClick: () => {
    e3 == null ? void 0 : e3(o);
  }, children: [jsxs(z$1, { gapX: 1, children: [jsx(Pe$5, { name: u2, className: "oui-w-[16px] oui-h-[16px]" }), jsx($$4, { className: cnBase("oui-text-base-contrast-54 group-hover:oui-text-base-contrast-80", n4 && "oui-text-base-contrast-80"), children: u2 })] }), f2()] }, u2);
};
var $$3 = forwardRef((t, o) => {
  let { token: n4, tokens: e3 = [], classNames: r3, label: u2, status: i, hintMessage: s, value: a2, onValueChange: m2, onTokenChange: c2, fetchBalance: p2, loading: f2, placeholder: b2, ...h2 } = t, { t: d2 } = Z$2(), w5 = useRef(null), [k2, v2] = useState(false), [S2, D2] = useState(0), N2 = useMemo(() => e3.map((g2) => ({ ...g2, name: g2.display_name || g2.symbol })), [e3]);
  useEffect(() => {
    var _a2;
    let g2 = (_a2 = w5 == null ? void 0 : w5.current) == null ? void 0 : _a2.getBoundingClientRect();
    D2((g2 == null ? void 0 : g2.width) || 0);
  }, [w5]);
  let I2 = (g2) => {
    let V2 = e3.find((G2) => G2.symbol === g2);
    V2 && (c2 == null ? void 0 : c2(V2));
  }, F2 = (g2) => {
    let V2 = g2.symbol === (n4 == null ? void 0 : n4.symbol);
    return jsx(yt$3, { token: g2, fetchBalance: p2, onTokenChange: (G2) => {
      c2 == null ? void 0 : c2(G2), v2(false);
    }, isActive: V2 });
  }, W2 = jsxs(_$1, { children: [jsx(_$1, { className: "oui-absolute oui-top-0", children: jsx($$4, { size: "2xs", intensity: 36, children: u2 || d2("common.quantity") }) }), f2 && jsx(_$1, { className: "oui-absolute oui-bottom-1", children: jsx(we$5, { size: "sm" }) })] }), U3 = e3.length > 1, Q2 = jsx("div", { className: "oui-absolute oui-right-0", children: jsx(ke$2.tokens, { open: U3 ? k2 : false, onOpenChange: v2, disabled: h2.disabled, variant: "text", tokens: N2, value: (n4 == null ? void 0 : n4.display_name) || (n4 == null ? void 0 : n4.symbol), size: h2.size, onValueChange: I2, showIcon: true, optionRenderer: F2, contentProps: { onCloseAutoFocus: (g2) => {
    var _a2;
    g2.preventDefault(), (_a2 = w5.current) == null ? void 0 : _a2.focus();
  }, onClick: (g2) => {
    var _a2;
    g2.preventDefault(), (_a2 = w5.current) == null ? void 0 : _a2.focus();
  }, style: { width: S2 }, align: "end", sideOffset: 5, className: "oui-border oui-border-line-6" } }) }), q2 = jsxs(z$1, { mt: 1, gapX: 1, px: 1, children: [jsx(_$1, { width: 4, height: 4, r: "full", className: cnBase(i === "error" && "oui-bg-danger-light", i === "warning" && "oui-bg-warning-light") }), jsx($$4, { size: "2xs", className: cnBase(i === "error" && "oui-text-danger-light", i === "warning" && "oui-text-warning-light"), children: s })] }), ne2 = b2 ?? (f2 ? "" : "0");
  return jsxs(Fragment$1, { children: [jsx(So$4, { "data-testid": t.testId, ref: w5, autoComplete: "off", placeholder: ne2, prefix: W2, suffix: Q2, value: a2, onValueChange: (g2) => {
    var _a2;
    (_a2 = t.onValueChange) == null ? void 0 : _a2.call(t, g2);
  }, formatters: [Xr$1.numberFormatter, Xr$1.dpFormatter((n4 == null ? void 0 : n4.precision) ?? 2), Xr$1.currencyFormatter], ...h2, classNames: { ...r3, root: cnBase("oui-h-[54px] oui-relative oui-px-3", "oui-border oui-border-line oui-rounded-lg", i === "error" && "focus-within:oui-outline-danger-light oui-outline-danger-light", i === "warning" && "focus-within:oui-outline-warning-light oui-outline-warning-light", t.readOnly ? "oui-bg-base-6 focus-within:oui-outline-0 oui-border-none" : "oui-bg-base-5", r3 == null ? void 0 : r3.root), input: cnBase("oui-absolute oui-bottom-0", r3 == null ? void 0 : r3.input) } }), s && q2] });
});
var Tt$4 = (t) => jsx("svg", { width: "12", height: "12", viewBox: "0 0 12 12", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...t, children: jsx("path", { d: "M10.997 8.004a.5.5 0 0 0-.14-.36l-1.86-1.843-.703.703.984 1h-7.28a.5.5 0 0 0 0 1h7.28l-.984 1 .703.703 1.86-1.844a.5.5 0 0 0 .14-.36m-.5-4a.5.5 0 0 0-.5-.5H2.716l.984-1-.703-.703-1.859 1.843a.515.515 0 0 0 0 .719l1.86 1.844.702-.703-.984-1h7.281a.5.5 0 0 0 .5-.5" }) }), vt$2 = (t) => jsx("svg", { width: "20", height: "21", viewBox: "0 0 20 21", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...t, children: jsx("path", { d: "M9.994 5.51a.83.83 0 0 0-.832.833v6.295l-2.498-2.471-1.17 1.17 3.902 3.929a.84.84 0 0 0 .599.244.84.84 0 0 0 .597-.244l3.903-3.928-1.171-1.171-2.498 2.471V6.343a.83.83 0 0 0-.832-.833" }) });
var Ft$5 = (t) => jsx("svg", { width: "14", height: "14", viewBox: "0 0 14 14", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...t, children: jsx("path", { d: "M4.078 1.744a2.333 2.333 0 0 0-2.333 2.333v5.834a2.333 2.333 0 0 0 2.333 2.333h5.833a2.333 2.333 0 0 0 2.334-2.333V4.077A2.333 2.333 0 0 0 9.91 1.744zm2.917 2.333c.322 0 .583.262.583.584v2.916h1.75L6.995 9.911 4.66 7.577h1.75V4.661c0-.322.262-.584.584-.584" }) }), St$3 = (t) => jsx("svg", { width: "14", height: "14", viewBox: "0 0 14 14", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...t, children: jsx("path", { d: "M4.078 12.244a2.333 2.333 0 0 1-2.333-2.333V4.077a2.333 2.333 0 0 1 2.333-2.333h5.833a2.333 2.333 0 0 1 2.334 2.333v5.834a2.333 2.333 0 0 1-2.334 2.333zm2.917-2.333a.584.584 0 0 0 .583-.584V6.411h1.75L6.995 4.077 4.66 6.411h1.75v2.916c0 .322.262.584.584.584" }) }), Nt$3 = (t) => jsx("svg", { width: "12", height: "12", viewBox: "0 0 12 12", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...t, children: jsx("path", { d: "M6.00342 1.49561C4.97642 1.49561 3.99542 1.84011 3.20642 2.46461C2.98992 2.63561 2.95692 2.9511 3.12842 3.1676C3.29992 3.3841 3.61492 3.4171 3.83142 3.2456C4.44492 2.7601 5.20392 2.4956 6.00342 2.4956C7.93642 2.4956 9.50342 4.0626 9.50342 5.9956H8.50342L10.0034 7.9956L11.5034 5.9956H10.5034C10.5034 3.5101 8.48892 1.49561 6.00342 1.49561ZM2.00342 3.9956L0.503418 5.9956H1.50342C1.50342 8.4811 3.51792 10.4956 6.00342 10.4956C7.03092 10.4956 8.01142 10.1516 8.80042 9.52659C9.01692 9.35559 9.04992 9.0401 8.87842 8.8236C8.70692 8.6071 8.39191 8.5741 8.17542 8.7456C7.56142 9.2316 6.80342 9.4956 6.00342 9.4956C4.07042 9.4956 2.50342 7.9286 2.50342 5.9956H3.50342L2.00342 3.9956Z" }) });
var ae$4 = (t) => {
  var _a2, _b2;
  let { chains: o, value: n4, wrongNetwork: e3, loading: r3 } = t, [u2, i] = useState(false), { t: s } = Z$2(), a2 = e3 || (o == null ? void 0 : o.length) > 1, m2 = e3 ? jsx(z$1, { width: 18, height: 18, intensity: 100, r: "full", justify: "center", itemAlign: "center", children: jsx($$4, { size: "2xs", intensity: 80, children: "U" }) }) : jsx(kr$2, { className: "oui-w-[18px] oui-h-[18px]", chainId: n4 == null ? void 0 : n4.id }), c2 = e3 ? "Unknown" : (_b2 = (_a2 = n4 == null ? void 0 : n4.info) == null ? void 0 : _a2.network_infos) == null ? void 0 : _b2.name, p2 = () => {
    if (r3) return jsx(we$5, { size: "sm" });
    if (a2) return jsx(Tt$4, { className: "oui-text-base-contrast-54" });
  }, f2 = jsxs(z$1, { intensity: 500, className: cnBase("oui-rounded-t-xl oui-rounded-b-sm oui-border oui-border-line", a2 ? "oui-cursor-pointer" : "oui-cursor-auto"), height: 54, px: 3, justify: "between", itemAlign: "center", children: [jsxs("div", { children: [jsx(z$1, { children: jsx($$4, { size: "2xs", intensity: 54, children: s("transfer.network") }) }), jsxs(z$1, { gapX: 1, children: [m2, jsx($$4, { size: "sm", intensity: 80, children: c2 })] })] }), p2()] }), b2 = o.map((h2, d2) => {
    let w5 = h2.chain_id === (n4 == null ? void 0 : n4.id);
    return jsxs(z$1, { px: 2, r: "base", justify: "between", className: cnBase("oui-deposit-network-select-item", "hover:oui-bg-base-5 oui-h-[30px] oui-cursor-pointer", w5 && "oui-bg-base-5", d2 !== 0 && "oui-mt-[2px]"), onClick: async () => {
      i(false), await t.onValueChange(h2);
    }, children: [jsxs(z$1, { gapX: 1, itemAlign: "center", children: [jsx(kr$2, { className: "oui-w-[18px] oui-h-[18px]", chainId: h2.chain_id }), jsx($$4, { size: "2xs", intensity: 54, children: h2.name }), h2.bridgeless && jsx(z$1, { className: "oui-bg-success-light/15", height: 18, px: 2, r: "base", justify: "center", itemAlign: "center", children: jsx($$4, { size: "2xs", className: "oui-text-success-light", children: s("transfer.lowestFee") }) })] }), w5 && jsx(_$1, { width: 4, height: 4, r: "full", className: "oui-deposit-network-select-active-dot oui-bg-[linear-gradient(270deg,#59B0FE_0%,#26FEFE_100%)]" })] }, h2.chain_id);
  });
  return jsxs(Yi, { open: a2 ? u2 : false, onOpenChange: i, children: [jsx(Xi$1, { asChild: true, children: f2 }), jsx(ji, { children: jsx(rr$2, { onCloseAutoFocus: (h2) => h2.preventDefault(), align: "start", sideOffset: 2, className: cnBase("oui-deposit-token-select-dropdown-menu-content", "oui-bg-base-8 oui-p-1", "oui-w-[var(--radix-dropdown-menu-trigger-width)]", "oui-rounded-md oui-select-none"), children: jsx($e$5, { children: jsxs("div", { className: "oui-max-h-[254px]", children: [b2, " "] }) }) }) })] });
};
var le$3 = () => jsxs(z$1, { height: 40, gapX: 3, children: [jsx(z$1, { height: 1, className: "oui-bg-base-contrast-12 oui-flex-1" }), jsx(vt$2, { className: "oui-text-primary-light" }), jsx(z$1, { height: 1, className: "oui-bg-base-contrast-12 oui-flex-1" })] });
function At$1(t) {
  return t ? t.replace(/^(.{6})(.*)(.{4})$/, "$1......$3") : "--";
}
var Dt$3 = (t = []) => {
  let o = t.reduce((n4, e3) => (n4[e3.symbol] = e3, n4), {});
  return o.USDC || o.USDbC || t[0];
}, Wt$3 = (t) => t + 3;
var ue$5 = () => {
  let { t } = Z$2(), { wallet: o } = useWalletConnector(), { walletName: n4, address: e3 } = useMemo(() => {
    var _a2;
    return { walletName: o == null ? void 0 : o.label, address: At$1((_a2 = o == null ? void 0 : o.accounts) == null ? void 0 : _a2[0].address) };
  }, [o]);
  return jsxs(z$1, { justify: "between", children: [jsx($$4, { size: "sm", intensity: 98, children: t("transfer.web3Wallet") }), jsxs(z$1, { gapX: 1, children: [jsx(Mc, { size: "xs", name: n4 ?? "" }), jsx($$4, { size: "sm", intensity: 54, children: e3 })] })] });
};
var ce$5 = () => {
  let { t } = Z$2(), { appIcons: o } = rr$1(), n4 = useConfig("brokerName"), e3 = useMemo(() => {
    let { secondary: r3 } = o || {};
    if (!(r3 == null ? void 0 : r3.img) && (r3 == null ? void 0 : r3.component)) return null;
    if (r3 == null ? void 0 : r3.img) return jsx("img", { src: r3 == null ? void 0 : r3.img, className: "oui-w-5 oui-h-5" });
    if (r3 == null ? void 0 : r3.component) return jsx(Fragment$1, { children: r3.component });
  }, [o]);
  return jsxs(z$1, { justify: "between", children: [jsx($$4, { size: "sm", intensity: 98, children: t("transfer.brokerAccount", { brokerName: n4 }) }), e3] });
};
var pe$2 = (t) => {
  let { amount: o, maxQuantity: n4, token: e3, loading: r3 } = t, { t: u2 } = Z$2(), i = (e3 == null ? void 0 : e3.display_name) || (e3 == null ? void 0 : e3.symbol) || "", s = (e3 == null ? void 0 : e3.precision) ?? 2;
  return jsxs(z$1, { justify: "between", px: 2, children: [jsxs($$4, { size: "2xs", intensity: 36, children: ["$", jsx($$4.numeral, { dp: 2, padding: false, rm: g$6.ROUND_DOWN, children: o })] }), jsxs(z$1, { gapX: 2, children: [jsxs($$4, { size: "2xs", intensity: 36, children: [`${u2("common.available")}: `, jsx($$4.numeral, { rm: g$6.ROUND_DOWN, dp: s, padding: false, "data-testid": "oui-testid-withdraw_deposit-dialog-available-value", children: n4 }), ` ${i}`] }), r3 && jsx(we$5, { size: "sm" }), jsx($$4, { size: "2xs", color: "primary", className: "oui-cursor-pointer oui-select-none", onClick: t.onClick, children: u2("common.max") })] })] });
};
var Le$4 = (t) => {
  let { token: o, dst: n4, price: e3 } = t, r3 = (o == null ? void 0 : o.display_name) || (o == null ? void 0 : o.symbol) || "USDC";
  return jsx(z$1, { children: jsxs($$4, { size: "xs", intensity: 36, className: t.className, children: [jsx($$4, { size: "xs", intensity: 80, children: "1" }), ` ${r3} = `, e3 ? jsx($$4.numeral, { size: "xs", intensity: 80, dp: 3, padding: false, children: e3 }) : "-", ` ${n4 == null ? void 0 : n4.symbol}`] }) });
};
var He$4 = (t) => {
  let { dstGasFee: o, feeQty: n4, feeAmount: e3, dp: r3, nativeSymbol: u2 } = t, { t: i } = Z$2(), s = () => {
    let m2 = jsxs("div", { className: "oui-text-2xs", children: [jsxs(z$1, { gapX: 1, children: [jsx($$4, { intensity: 54, children: `${i("transfer.deposit.destinationGasFee")}: ` }), jsx($$4.numeral, { intensity: 80, dp: r3, rm: g$6.ROUND_UP, padding: false, children: n4 }), jsx($$4, { intensity: 54, children: u2 })] }), jsx(_$1, { mt: 2, children: jsx($$4, { intensity: 36, children: i("transfer.deposit.destinationGasFee.description") }) })] });
    uo$3.alert({ title: i("common.fee"), message: m2 });
  }, a2 = !!o && o !== "0";
  return jsxs($$4, { size: "xs", intensity: 36, className: "oui-border-dashed oui-border-b oui-border-line-12 oui-cursor-pointer", onClick: s, children: [`${i("common.fee")}  `, jsxs($$4, { size: "xs", intensity: 80, children: ["$", jsx($$4.numeral, { dp: 2, padding: false, rm: g$6.ROUND_UP, children: e3 }), " "] }), a2 && jsxs("span", { children: ["(", jsxs($$4, { intensity: 54, children: [jsx($$4.numeral, { dp: r3, padding: false, rm: g$6.ROUND_UP, children: n4 }), u2] }), ")"] })] });
};
var Xe$5 = ((e3) => (e3[e3.Deposit = 0] = "Deposit", e3[e3.Approve = 1] = "Approve", e3[e3.Increase = 2] = "Increase", e3))(Xe$5 || {});
var Ye$5 = (t) => {
  let { disabled: o, loading: n4, actionType: e3, symbol: r3 = "USDC", onDeposit: u2, onApprove: i, networkId: s } = t, { t: a2 } = Z$2(), m2 = useMemo(() => ({ 1: { children: a2("transfer.deposit.approve.symbol", { symbol: r3 }), onClick: i, disabled: false, "data-testid": "oui-testid-deposit-dialog-approve-btn" }, 2: { children: a2("transfer.deposit.increase.symbol", { symbol: r3 }), onClick: i, "data-testid": "oui-testid-deposit-dialog-increase-btn" }, 0: { children: a2("common.deposit"), onClick: u2, "data-testid": "oui-testid-deposit-dialog-deposit-btn" } })[e3], [i, u2, e3, r3, a2]), c2 = { initial: "md", lg: "lg" };
  return jsx(_$1, { className: "oui-w-full lg:oui-w-auto lg:oui-min-w-[184px]", children: jsx(S$1, { status: AccountStatusEnum.EnableTrading, networkId: s, buttonProps: { fullWidth: true, size: c2 }, children: jsx(_e$5, { fullWidth: true, disabled: o, loading: n4, size: c2, ...m2 }) }) });
};
var Ke$3 = (t) => {
  let { token: o, tokens: n4, onTokenChange: e3, amount: r3, quantity: u2, maxQuantity: i, onQuantityChange: s, hintMessage: a2, inputStatus: m2, chains: c2, currentChain: p2, settingChain: f2, onChainChange: b2, actionType: h2, onDeposit: d2, onApprove: w5, fetchBalance: k2, dst: v2, wrongNetwork: S2, balanceRevalidating: D2, loading: N2, disabled: I2, networkId: F2, fee: W2 } = t;
  return jsxs(_$1, { id: "oui-deposit-form", className: na$1({ weight: "semibold" }), children: [jsxs(_$1, { className: "oui-mb-6 lg:oui-mb-8", children: [jsx(ue$5, {}), jsxs(_$1, { mt: 3, mb: 1, children: [jsx(ae$4, { chains: c2, value: p2, onValueChange: b2, wrongNetwork: S2, loading: f2 }), jsx($$3, { classNames: { root: "oui-mt-[2px] oui-rounded-t-sm oui-rounded-b-xl" }, value: u2, onValueChange: s, tokens: n4, token: o, onTokenChange: e3, status: m2, hintMessage: a2, fetchBalance: k2, "data-testId": "oui-testid-deposit-dialog-quantity-input" })] }), jsx(pe$2, { token: o, amount: r3, maxQuantity: i, loading: D2, onClick: () => {
    s(i);
  } }), jsx(le$3, {}), jsx(ce$5, {}), jsx($$3, { readOnly: true, token: v2, value: u2, classNames: { root: "oui-mt-3 oui-border-transparent focus-within:oui-outline-transparent" } }), jsxs(z$1, { direction: "column", mt: 1, gapY: 1, itemAlign: "start", children: [jsx(Le$4, { token: o, dst: v2, price: 1 }), jsx(He$4, { ...W2 })] })] }), jsx(z$1, { justify: "center", children: jsx(Ye$5, { actionType: h2, symbol: o == null ? void 0 : o.symbol, disabled: I2, loading: N2, onDeposit: d2, onApprove: w5, networkId: F2 }) })] });
};
function Je$3(t) {
  let { isNativeToken: o, allowance: n4, quantity: e3, maxQuantity: r3 } = t;
  return useMemo(() => {
    let i = o ? Number.MAX_VALUE : Number(n4);
    if (i <= 0) return 1;
    let s = Number(e3), a2 = Number(r3);
    return i < s && s <= a2 ? 2 : 0;
  }, [o, n4, e3, r3]);
}
function tt$2() {
  let { t } = Z$2(), o = useConfig("networkId"), [n4] = useLocalStorage("orderly_link_device", {}), { connectedChain: e3, settingChain: r3, setChain: u2 } = useWalletConnector(), [i, { findByChainId: s }] = useChains(o, { pick: "network_infos", filter: (c2) => {
    var _a2, _b2;
    return ((_a2 = c2.network_infos) == null ? void 0 : _a2.bridge_enable) || ((_b2 = c2.network_infos) == null ? void 0 : _b2.bridgeless);
  } }), a2 = useMemo(() => {
    let c2 = e3 ? h$2(e3.id) : parseInt(n4 == null ? void 0 : n4.chainId);
    if (!c2) return null;
    let p2 = s(c2);
    return { ...e3, id: c2, info: p2 };
  }, [s, e3, n4]), m2 = useCallback(async (c2) => {
    var _a2, _b2;
    let p2 = s(c2.chain_id);
    if (e3) return !p2 || ((_a2 = p2.network_infos) == null ? void 0 : _a2.chain_id) === (a2 == null ? void 0 : a2.id) ? Promise.resolve() : u2({ chainId: F$3(Number((_b2 = p2.network_infos) == null ? void 0 : _b2.chain_id)) }).then((f2) => {
      f2 ? toast$2.success(t("connector.networkSwitched")) : toast$2.error(t("connector.switchChain.failed"));
    }).catch((f2) => {
      f2 && f2.message && toast$2.error(`${t("connector.switchChain.failed")}: ${f2.message}`);
    });
  }, [a2, u2, s]);
  return { chains: i, currentChain: a2, settingChain: r3, onChainChange: m2 };
}
function nt$1(t) {
  let { quantity: o, allowance: n4, approve: e3, deposit: r3, enableCustomDeposit: u2, customDeposit: i, onSuccess: s } = t, [a2, m2] = useState(false), c2 = useEventEmitter(), { t: p2 } = Z$2(), f2 = useCallback(async () => {
    if (!a2) return m2(true), e3(o).then((d2) => {
      toast$2.success(p2("transfer.deposit.approve.success"));
    }).catch((d2) => {
      toast$2.error(d2.message || d2.errorCode || p2("transfer.deposit.approve.failed"));
    }).finally(() => {
      m2(false);
    });
  }, [e3, a2, o, n4, p2]), b2 = useCallback(async () => r3().then((d2) => {
    toast$2.success(p2("transfer.deposit.requested")), c2.emit("deposit:requested"), s == null ? void 0 : s();
  }).catch((d2) => {
    toast$2.error(d2.message || d2.errorCode || p2("transfer.deposit.failed"));
  }), [r3, s, p2]), h2 = useCallback(() => {
    var _a2, _b2;
    let d2 = Number(o);
    if (isNaN(d2) || d2 <= 0) {
      toast$2.error(p2("transfer.quantity.invalid"));
      return;
    }
    if (a2) return;
    m2(true), (_b2 = (_a2 = u2 ? i : b2) == null ? void 0 : _a2()) == null ? void 0 : _b2.finally(() => {
      m2(false);
    });
  }, [o, a2, b2, u2, i, p2]);
  return { submitting: a2, onApprove: f2, onDeposit: h2 };
}
function rt$3(t) {
  let { quantity: o, maxQuantity: n4 } = t, { t: e3 } = Z$2(), [r3, u2] = useState("default"), [i, s] = useState();
  return useEffect(() => {
    if (!o) {
      u2("default"), s("");
      return;
    }
    new g$6(o).gt(n4) ? (u2("error"), s(e3("transfer.insufficientBalance"))) : (u2("default"), s(""));
  }, [o, n4]), { inputStatus: r3, hintMessage: i };
}
function it$1(t) {
  let { currentChain: o, tokensFilter: n4 } = t, [e3, r3] = useState(), [u2, i] = useState([]), s = useCallback((a2) => {
    var _a2;
    if (a2 && ((_a2 = a2 == null ? void 0 : a2.token_infos) == null ? void 0 : _a2.length) > 0) {
      let m2 = typeof n4 == "function" ? n4(a2) : a2.token_infos;
      i(m2);
      let c2 = Dt$3(m2);
      if (!c2) return;
      r3(c2);
    }
  }, [n4]);
  return useEffect(() => {
    s(o == null ? void 0 : o.info);
  }, [o == null ? void 0 : o.id, s]), { token: e3, tokens: u2, onTokenChange: r3 };
}
var at$2 = (t) => {
  var _a2;
  let { wrongNetwork: o } = L$4(), n4 = useConfig("networkId"), { chains: e3, currentChain: r3, settingChain: u2, onChainChange: i } = tt$2(), { token: s, tokens: a2, onTokenChange: m2 } = it$1({ currentChain: r3 }), { dst: c2, balance: p2, allowance: f2, depositFeeRevalidating: b2, depositFee: h2, quantity: d2, setQuantity: w5, approve: k2, deposit: v2, isNativeToken: S2, balanceRevalidating: D2, fetchBalance: N2 } = useDeposit({ address: s == null ? void 0 : s.address, decimals: s == null ? void 0 : s.decimals, srcChainId: r3 == null ? void 0 : r3.id, srcToken: s == null ? void 0 : s.symbol }), I2 = useMemo(() => new g$6(p2 || 0).todp((s == null ? void 0 : s.precision) ?? 2, g$6.ROUND_DOWN).toString(), [p2, s]), { inputStatus: F2, hintMessage: W2 } = rt$3({ quantity: d2, maxQuantity: I2 }), U3 = () => {
    w5("");
  }, Q2 = useCallback(() => {
    var _a3;
    U3(), (_a3 = t.onClose) == null ? void 0 : _a3.call(t);
  }, [t.onClose]), { submitting: q2, onApprove: ne2, onDeposit: g2 } = nt$1({ quantity: d2, allowance: f2, approve: k2, deposit: v2, onSuccess: Q2 }), V2 = q2 || b2, G2 = !d2 || Number(d2) === 0 || !s || F2 === "error" || b2, We2 = useMemo(() => new g$6(d2 || 0).mul(1).toNumber(), [d2]), dt2 = Je$3({ isNativeToken: S2, allowance: f2, quantity: d2, maxQuantity: I2 }), B2 = En$1({ nativeToken: (_a2 = r3 == null ? void 0 : r3.info) == null ? void 0 : _a2.nativeToken, depositFee: h2 });
  return useEffect(() => {
    U3();
  }, [s, r3 == null ? void 0 : r3.id]), { token: s, tokens: a2, onTokenChange: m2, amount: We2, quantity: d2, maxQuantity: I2, onQuantityChange: w5, hintMessage: W2, inputStatus: F2, chains: e3, currentChain: r3, settingChain: u2, onChainChange: i, actionType: dt2, onDeposit: g2, onApprove: ne2, fetchBalance: N2, dst: c2, wrongNetwork: o, balanceRevalidating: D2, loading: V2, disabled: G2, networkId: n4, fee: B2 };
};
function En$1(t) {
  let { nativeToken: o, depositFee: n4 = 0 } = t, { account: e3 } = useAccount(), r3 = o == null ? void 0 : o.symbol, { data: u2 } = useIndexPrice(`SPOT_${r3}_USDC`);
  return { ...useMemo(() => {
    var _a2;
    let s = new g$6(n4.toString()).div(new g$6(10).pow(((_a2 = e3.walletAdapter) == null ? void 0 : _a2.chainNamespace) === ChainNamespace.solana ? 9 : 18)).toString(), a2 = new g$6(s).mul(u2 || 0).toString();
    return { dstGasFee: s, feeQty: s, feeAmount: a2, dp: Wt$3(4) };
  }, [n4, u2]), nativeSymbol: r3 };
}
var Fe$3 = (t) => {
  let o = at$2(t);
  return jsx(Ke$3, { ...o });
};
var Gt$3 = ({ checkIsBridgeless: t, quantity: o, chainVaultBalance: n4, currentChain: e3, maxAmount: r3, crossChainTrans: u2 }) => {
  let { t: i } = Z$2(), { wrongNetwork: s } = L$4(), { state: a2 } = useAccount(), m2 = useMemo(() => {
    if (e3 && e3.info && e3.info.network_infos) return e3.info.network_infos.name;
  }, [e3]), c2 = useMemo(() => !n4 || !r3 || !o || new g$6(o).gt(r3) ? false : !!new g$6(o).gt(n4), [o, n4]), f2 = (() => {
    if (a2.status !== AccountStatusEnum.NotConnected) {
      if (s || !t) return jsx(_$1, { children: m2 ? i("transfer.withdraw.unsupported.networkName", { networkName: m2 }) : i("transfer.withdraw.unsupported.chain") });
      if (u2) return i("transfer.withdraw.crossChain.process");
      if (c2) return i("transfer.withdraw.crossChain.vaultWarning", { networkName: m2, chainVaultBalance: n4 });
    }
  })();
  return f2 ? jsx(z$1, { className: "oui-text-warning-darken oui-text-xs oui-justify-center oui-text-center", mb: 3, children: f2 }) : null;
};
var Lt$1 = ({ hasPositions: t, unsettledPnl: o, onSettlle: n4 }) => {
  let { t: e3 } = Z$2();
  if (o === 0 && !t) return jsx(Fragment$1, {});
  let r3 = () => {
    uo$3.confirm({ title: e3("settle.settlePnl"), content: jsx(Trans, { i18nKey: "settle.settlePnl.description" }), onOk: () => n4() });
  };
  return jsxs(z$1, { justify: "between", className: "oui-text-2xs oui-text-base-contrast-36 oui-mt-1 oui-mx-2", children: [jsxs(z$1, { itemAlign: "center", justify: "start", gap: 1, children: [jsx(Xn$2, { className: "oui-max-w-[274px]", content: e3("settle.unsettled.tooltip"), children: jsxs(z$1, { itemAlign: "center", justify: "start", gap: 1, children: [jsx(Ga, { size: 14, className: "oui-text-warning-darken" }), jsx($$4, { className: "oui-border-dashed oui-border-b oui-border-line-12 oui-cursor-pointer", children: `${e3("settle.unsettled")}:` })] }) }), jsx($$4.numeral, { showIdentifier: true, coloring: true, weight: "semibold", dp: 6, "data-testid": "oui-testid-withdraw-dialog-unsettledPnl-value", children: o }), jsx($$4, { children: "USDC" })] }), jsxs(z$1, { itemAlign: "center", gap: 1, className: "oui-cursor-pointer", children: [jsx(Nt$3, { className: "oui-text-primary" }), jsx($$4, { "data-testid": "oui-testid-withdraw-dialog-settle-text", size: "2xs", color: "primary", className: " oui-select-none", onClick: r3, children: e3("common.settle") })] })] });
};
var $t$5 = ({ address: t, amount: o, currentChain: n4 }) => {
  let { t: e3 } = Z$2(), r3 = useMemo(() => {
    if (n4 && n4.info && n4.info.network_infos) return n4.info.network_infos.name;
  }, [n4]);
  return jsxs(z$1, { direction: "column", itemAlign: "start", justify: "start", className: "oui-gap-1 lg:oui-gap-3", children: [jsxs(z$1, { direction: "column", itemAlign: "start", mb: 5, className: "oui-gap-3 lg:oui-gap-4", children: [jsxs(z$1, { direction: "column", justify: "start", itemAlign: "start", children: [jsx($$4, { size: "2xs", intensity: 36, children: e3("transfer.withdraw.crossChain.recipientAddress") }), jsx($$4, { size: "sm", intensity: 98, className: "oui-break-all", children: t })] }), jsxs(z$1, { direction: "column", justify: "start", itemAlign: "start", children: [jsx($$4, { size: "2xs", intensity: 36, children: e3("transfer.withdraw.crossChain.recipientNetwork") }), jsxs(z$1, { gap: 1, children: [jsx(kr$2, { className: "oui-h-[18px] oui-w-[18px]", size: "sm", chainId: n4.id }), jsx($$4, { size: "sm", intensity: 98, children: r3 })] })] }), jsxs(z$1, { direction: "column", justify: "start", itemAlign: "start", children: [jsx($$4, { size: "2xs", intensity: 36, children: `${e3("transfer.withdraw.crossChain.withdrawAmount")} (USDC)` }), jsx($$4.numeral, { size: "sm", intensity: 98, dp: 2, children: o })] })] }), jsx(z$1, { justify: "center", className: "oui-text-warning-darken oui-text-2xs lg:oui-text-xs oui-text-center", mb: 3, children: e3("transfer.withdraw.crossChain.warning") })] });
};
function lt$3(t) {
  let { t: o } = Z$2(), n4 = () => {
    uo$3.show(F$1, { networkId: t.networkId, bridgeLessOnly: true }).then((e3) => {
      toast$2.success(o("connector.networkSwitched"));
    }, (e3) => {
    });
  };
  return jsx(z$1, { direction: "column", children: jsx(_e$5, { color: "warning", size: t.size, fullWidth: true, onClick: () => {
    n4();
  }, children: o("connector.switchNetwork") }) });
}
var Xt$1 = (t) => {
  let { disabled: o, loading: n4, onWithdraw: e3, networkId: r3, crossChainWithdraw: u2, address: i, currentChain: s, quantity: a2, fee: m2, checkIsBridgeless: c2 } = t, { t: p2 } = Z$2(), f2 = useMemo(() => a2 ? new g$6(a2).minus(m2 ?? 0).toNumber() : 0, [a2, m2]), b2 = () => {
    if (u2) {
      uo$3.confirm({ title: p2("transfer.withdraw.crossChain.confirmWithdraw"), content: jsx($t$5, { address: i, amount: f2, currentChain: s }), classNames: { content: "oui-font-semibold", body: "!oui-pb-0", footer: "!oui-pt-0" }, onOk: async () => {
        e3();
      } });
      return;
    }
    e3();
  }, h2 = { initial: "md", lg: "lg" };
  return jsx(_$1, { className: "oui-w-full lg:oui-w-auto lg:oui-min-w-[184px]", children: jsx(S$1, { status: AccountStatusEnum.EnableTrading, networkId: r3, bridgeLessOnly: true, buttonProps: { fullWidth: true, size: h2 }, children: c2 ? jsx(_e$5, { "data-testid": "oui-testid-withdraw-dialog-withdraw-btn", fullWidth: true, disabled: o, loading: n4, onClick: b2, size: h2, children: p2("common.withdraw") }) : jsx(lt$3, { networkId: r3, size: h2 }) }) });
};
var ct$2 = ({ address: t, loading: o, disabled: n4, quantity: e3, onQuantityChange: r3, token: u2, inputStatus: i, hintMessage: s, amount: a2, maxQuantity: m2, balanceRevalidating: c2, chains: p2, currentChain: f2, onChainChange: b2, fee: h2, settingChain: d2, wrongNetwork: w5, hasPositions: k2, unsettledPnL: v2, onSettlePnl: S2, onWithdraw: D2, chainVaultBalance: N2, crossChainWithdraw: I2, crossChainTrans: F2, showQty: W2, networkId: U3, checkIsBridgeless: Q2 }) => {
  let { t: q2 } = Z$2();
  return jsxs(_$1, { id: "oui-withdraw-form", className: na$1({ weight: "semibold" }), children: [jsxs(_$1, { className: "oui-mb-6 lg:oui-mb-8", children: [jsx(ce$5, {}), jsx(_$1, { mt: 3, mb: 1, children: jsx($$3, { value: e3, onValueChange: r3, token: u2, onTokenChange: () => {
  }, status: i, hintMessage: s, testId: "oui-testid-withdraw-dialog-quantity-input" }) }), jsx(pe$2, { token: u2, amount: a2, maxQuantity: m2.toString(), loading: c2, onClick: () => {
    r3(m2.toString());
  } }), jsx(Lt$1, { unsettledPnl: v2, hasPositions: k2, onSettlle: S2 }), jsx(le$3, {}), jsx(ue$5, {}), jsxs(_$1, { mt: 3, children: [jsx(ae$4, { chains: p2, value: f2, onValueChange: b2, wrongNetwork: w5, loading: d2 }), jsx($$3, { classNames: { root: "oui-mt-[2px] oui-rounded-t-sm oui-rounded-b-xl" }, token: u2, value: W2, readOnly: true })] }), jsx(z$1, { direction: "column", mt: 1, gapY: 1, itemAlign: "start", children: jsxs($$4, { size: "xs", intensity: 36, children: [`${q2("common.fee")}  `, jsx($$4, { size: "xs", intensity: 80, children: `${h2} ` }), jsx($$4, { children: "USDC" })] }) })] }), jsx(Gt$3, { checkIsBridgeless: Q2, chainVaultBalance: N2, currentChain: f2, quantity: e3, maxAmount: m2, crossChainTrans: F2 }), jsx(z$1, { justify: "center", children: jsx(Xt$1, { checkIsBridgeless: Q2, networkId: U3, disabled: n4, loading: o, onWithdraw: D2, crossChainWithdraw: I2, currentChain: f2, address: t, quantity: e3, fee: h2 }) })] });
};
var Jt$2 = 1, mt$3 = ({ onClose: t }) => {
  let { t: o } = Z$2(), [n4] = usePositionStream(), [e3, r3] = useState(false), [u2, i] = useState(false), { data: s } = usePrivateQuery("/v1/asset/history", { revalidateOnMount: true }), a2 = useConfig("networkId"), m2 = useEventEmitter(), [c2, p2] = useState(""), [f2, b2] = useState({ symbol: "USDC", decimals: 6, address: "", display_name: "", precision: 6 }), [h2, d2] = useState("default"), [w5, k2] = useState(), { wrongNetwork: v2 } = L$4(), { account: S2 } = useAccount(), [D2] = useLocalStorage("orderly_link_device", {}), { data: N2 } = useQuery("/v1/public/vault_balance", { revalidateOnMount: true }), { connectedChain: I2, wallet: F2, setChain: W2, settingChain: U3 } = useWalletConnector();
  useConfig();
  let { walletName: q2, address: ne2 } = useMemo(() => {
    var _a2;
    return { walletName: F2 == null ? void 0 : F2.label, address: (_a2 = F2 == null ? void 0 : F2.accounts) == null ? void 0 : _a2[0].address };
  }, [F2]), g2 = (l2) => {
    p2(l2);
  }, V2 = useMemo(() => new g$6(c2 || 0).mul(Jt$2).toNumber(), [c2, Jt$2]), { dst: G2, withdraw: We2, maxAmount: B2, unsettledPnL: ge3 } = useWithdraw(), [so2, L2] = useState(true), [Be3, { findByChainId: we2 }] = useChains(a2, { pick: "network_infos", filter: (l2) => {
    var _a2, _b2;
    return ((_a2 = l2.network_infos) == null ? void 0 : _a2.bridge_enable) || ((_b2 = l2.network_infos) == null ? void 0 : _b2.bridgeless);
  } }), re2 = useMemo(() => a2 === "mainnet" ? Be3.filter((l2) => l2.bridgeless) : Be3, [Be3, a2]), { configStore: ao2 } = useContext(OrderlyContext), lo2 = ao2.get("apiBaseUrl"), { data: ft2 } = useQuery(`${lo2}/v1/public/token?t=withdraw`, { revalidateIfStale: false, revalidateOnFocus: false, revalidateOnReconnect: false, revalidateOnMount: true, dedupingInterval: 36e5, formatter: (l2) => {
    if (l2.rows.length === 1) return l2.rows[0].chain_details;
  } }), C2 = useMemo(() => {
    let l2 = I2 ? h$2(I2.id) : parseInt(D2 == null ? void 0 : D2.chainId);
    if (!l2) return null;
    let T2 = we2(l2);
    return { ...I2, id: l2, info: T2 };
  }, [we2, I2, D2]), uo2 = useMemo(() => v2 || !C2 ? false : a2 === "testnet" ? true : !(!C2.info || !C2.info.network_infos || !C2.info.network_infos.bridgeless), [C2, v2]), co2 = () => {
    p2("");
  }, mo2 = useCallback(async (l2) => {
    var _a2, _b2;
    let T2 = we2(l2.chain_id);
    return !T2 || ((_a2 = T2.network_infos) == null ? void 0 : _a2.chain_id) === (C2 == null ? void 0 : C2.id) ? Promise.resolve() : W2 == null ? void 0 : W2({ chainId: F$3(Number((_b2 = T2.network_infos) == null ? void 0 : _b2.chain_id)) }).then((ie2) => {
      ie2 ? (toast$2.success(o("connector.networkSwitched")), co2()) : toast$2.error(o("connector.switchChain.failed"));
    }).catch((ie2) => {
      toast$2.error(`${o("connector.switchChain.failed")}: ${ie2.message}`);
    });
  }, [C2, W2, we2, o]), po2 = useMemo(() => {
    var _a2;
    return ((_a2 = n4 == null ? void 0 : n4.rows) == null ? void 0 : _a2.length) > 0;
  }, [n4]), fo2 = async () => S2.settle().catch((l2) => (l2.code == -1104 && toast$2.error(o("settle.settlement.error")), l2.message.indexOf("Signing off chain messages with Ledger is not yet supported") !== -1 && m2.emit("wallet:sign-message-with-ledger-error", { message: l2.message, userAddress: S2.address }), l2.message.indexOf("user rejected") !== -1 && toast$2.error(o("transfer.rejectTransaction")), Promise.reject(l2))).then((l2) => (toast$2.success(o("settle.settlement.requested")), Promise.resolve(l2))), xe2 = useMemo(() => {
    if (!N2 || !C2) return null;
    let l2 = N2.find((T2) => parseInt(T2.chain_id) === (C2 == null ? void 0 : C2.id));
    return l2 ? l2.balance : null;
  }, [re2, C2, N2]), be4 = useMemo(() => {
    if (xe2 !== null) {
      let l2 = parseFloat(c2);
      return l2 > xe2 && l2 <= B2;
    }
    return false;
  }, [c2, B2, xe2]), ht2 = useMemo(() => re2.minimum_withdraw_amount ?? 1, [re2]), ho2 = async () => {
    if (!u2 && h2 === "default") {
      if (new g$6(c2).lt(ht2)) {
        toast$2.error(o("transfer.withdraw.minAmount.error", { minAmount: ht2 }));
        return;
      }
      return i(true), We2({ amount: c2, token: "USDC", chainId: C2 == null ? void 0 : C2.id, allowCrossChainWithdraw: be4 }).then((l2) => {
        toast$2.success(o("transfer.withdraw.requested")), m2.emit("withdraw:requested"), t && t(), p2("");
      }).catch((l2) => {
        if (l2.message.indexOf("user rejected") !== -1) {
          toast$2.error(o("transfer.rejectTransaction"));
          return;
        }
        if (l2.message.indexOf("Signing off chain messages with Ledger is not yet supported") !== -1) {
          m2.emit("wallet:sign-message-with-ledger-error", { message: l2.message, userAddress: S2.address });
          return;
        }
        toast$2.error(l2.message);
      }).finally(() => {
        i(false);
      });
    }
  }, _e4 = useMemo(() => {
    if (!C2) return 0;
    let l2 = ft2 == null ? void 0 : ft2.find((T2) => parseInt(T2.chain_id) === C2.id);
    return l2 ? be4 ? (l2.withdrawal_fee || 0) + (l2.cross_chain_withdrawal_fee || 0) : l2.withdrawal_fee || 0 : 0;
  }, [C2, ft2, re2, be4]), go2 = useMemo(() => {
    if (!c2) return "";
    let l2 = new g$6(c2).sub(_e4 ?? 0);
    return l2.isNegative() ? "" : l2.toNumber();
  }, [_e4, c2]);
  return useEffect(() => {
    if (e3 && L2(true), !c2) {
      d2("default"), k2(""), L2(true);
      return;
    }
    let l2 = new g$6(c2 ?? 0);
    ge3 < 0 ? l2.gt(B2) ? (d2("error"), k2(o("transfer.insufficientBalance")), L2(true)) : (d2("default"), k2(""), L2(false)) : l2.gt(B2) ? (d2("error"), k2(o("transfer.insufficientBalance")), L2(true)) : l2.gt(new g$6(B2).minus(ge3)) && l2.lessThanOrEqualTo(B2) ? (d2("warning"), k2(o("settle.settlePnl.warning")), L2(true)) : (d2("default"), k2(""), L2(false));
  }, [c2, B2, ge3, e3]), useEffect(() => {
    let l2 = s == null ? void 0 : s.find((T2) => T2.trans_status === "pending_rebalance".toUpperCase());
    r3(!!l2);
  }, [s]), useWalletSubscription({ onMessage(l2) {
    if (!e3) return;
    let { trxId: T2, transStatus: ie2 } = l2;
    T2 === e3 && ie2 === "COMPLETED" && r3(false);
  } }), { walletName: q2, address: ne2, quantity: c2, onQuantityChange: g2, token: f2, inputStatus: h2, hintMessage: w5, dst: G2, amount: V2, balanceRevalidating: false, maxQuantity: B2, disabled: so2, loading: u2, hasPositions: po2, unsettledPnL: ge3, wrongNetwork: v2, settingChain: U3, chains: re2, currentChain: C2, onChainChange: mo2, onSettlePnl: fo2, onWithdraw: ho2, chainVaultBalance: xe2, fee: _e4, crossChainWithdraw: be4, crossChainTrans: e3, showQty: go2, networkId: a2, checkIsBridgeless: uo2 };
};
var pt$4 = (t) => {
  let o = mt$3({ onClose: t.close });
  return jsx(ct$2, { ...o });
};
var to$3 = (t) => jsx(ei$3, { position: Et$5.DepositForm, defaultWidget: Fe$3, ...t });
var Lr$1 = "DepositAndWithdrawWithDialogId", $r = "DepositAndWithdrawWithSheetId", ro$4 = (t) => {
  let [o, n4] = useState(t.activeTab || "deposit"), { t: e3 } = Z$2();
  return jsxs(Cl, { value: o, onValueChange: n4, variant: "contained", size: "lg", classNames: { tabsList: "oui-px-0", tabsContent: "oui-pt-5" }, children: [jsx(Sl, { title: e3("common.deposit"), icon: jsx(Ft$5, {}), value: "deposit", children: jsx(to$3, { onClose: t.close }) }), jsx(Sl, { title: e3("common.withdraw"), icon: jsx(St$3, {}), value: "withdraw", children: jsx(pt$4, { ...t }) })] });
};
Pg(Lr$1, ro$4, { size: "md", classNames: { content: "oui-border oui-border-line-6" } });
ng($r, ro$4);
var N = Object.create;
var k$1 = Object.defineProperty;
var I$3 = Object.getOwnPropertyDescriptor;
var K$1 = Object.getOwnPropertyNames;
var $$2 = Object.getPrototypeOf, M$2 = Object.prototype.hasOwnProperty;
var g$1 = (t, e3) => () => (e3 || t((e3 = { exports: {} }).exports, e3), e3.exports);
var X$2 = (t, e3, r3, o) => {
  if (e3 && typeof e3 == "object" || typeof e3 == "function") for (let i of K$1(e3)) !M$2.call(t, i) && i !== r3 && k$1(t, i, { get: () => e3[i], enumerable: !(o = I$3(e3, i)) || o.enumerable });
  return t;
};
var G$3 = (t, e3, r3) => (r3 = t != null ? N($$2(t)) : {}, X$2(!t || !t.__esModule ? k$1(r3, "default", { value: t, enumerable: true }) : r3, t));
var O$2 = g$1((x2) => {
  Object.defineProperty(x2, "__esModule", { value: true });
  Object.defineProperty(x2, "default", { enumerable: true, get: function() {
    return re2;
  } });
  function S2(t, e3) {
    return { handler: t, config: e3 };
  }
  S2.withOptions = function(t, e3 = () => ({})) {
    let r3 = function(o) {
      return { __options: o, handler: t(o), config: e3(o) };
    };
    return r3.__isOptionsFunction = true, r3.__pluginFunction = t, r3.__configFunction = e3, r3;
  };
  var re2 = S2;
});
var A$1 = g$1((C2) => {
  Object.defineProperty(C2, "__esModule", { value: true });
  Object.defineProperty(C2, "default", { enumerable: true, get: function() {
    return ae3;
  } });
  var oe2 = ie2(O$2());
  function ie2(t) {
    return t && t.__esModule ? t : { default: t };
  }
  var ae3 = oe2.default;
});
var V$2 = g$1((rr2, R2) => {
  var b2 = A$1();
  R2.exports = (b2.__esModule ? b2 : { default: b2 }).default;
});
var v = () => {
  let t = document.documentElement, e3 = getComputedStyle(t);
  return { primary: u(e3.getPropertyValue("--oui-color-primary")), primaryLight: u(e3.getPropertyValue("--oui-color-primary-light")), secondary: u(e3.getPropertyValue("--oui-color-secondary")), success: u(e3.getPropertyValue("--oui-color-success")), warning: u(e3.getPropertyValue("--oui-color-warning")), danger: u(e3.getPropertyValue("--oui-color-danger")), info: u(e3.getPropertyValue("--oui-color-info")), loss: u(e3.getPropertyValue("--oui-color-trading-loss")), profit: u(e3.getPropertyValue("--oui-color-trading-profit")) };
}, u = (t) => `rgb(${t.split(" ").join(",")})`;
var f = (t) => useMemo(() => {
  let r3 = v();
  return { profit: (t == null ? void 0 : t.profit) || r3.profit, loss: (t == null ? void 0 : t.loss) || r3.loss, primary: r3.primary, primaryLight: r3.primaryLight };
}, [t]);
var d$1 = (t) => {
  let { label: e3, value: r3, prefix: o, unit: i = "USDC", coloring: a2 = false, dp: n4, rm: c2 } = t;
  return jsxs(_$1, { intensity: 600, p: 3, r: "md", children: [jsxs(z$1, { direction: "row", className: t.titleClassName, children: [o, jsx($$4.numeral, { unit: i, as: "div", size: "sm", coloring: a2, showIdentifier: a2, unitClassName: "oui-text-base-contrast-54 oui-ml-1", weight: "semibold", rm: c2, dp: n4, children: r3 })] }), jsx($$4, { size: "2xs", intensity: 54, weight: "semibold", children: e3 })] });
};
var h = (t) => {
  let e3 = Math.abs(t), r3 = e3 === 0 ? 0 : e3 <= 10 ? 2 : e3 <= 100 ? 1 : 0, o = _$3(e3, r3);
  return t < 0 ? `-${o}` : o;
};
var at$1 = (t) => {
  let { fill: e3, x: r3, y: o, width: i, height: a2 } = t, n4 = Math.abs(a2);
  return jsx("rect", { rx: 2, x: r3, y: a2 > 0 ? o : o + a2, width: i, height: n4, stroke: "none", fill: e3 });
}, nt = (t) => {
  let { x: e3, y: r3, stroke: o, payload: i, index: a2, width: n4, containerWidth: c2 } = t, { t: z2 } = Z$2(), D2 = a2 === 0 ? 48 : c2 > 0 ? c2 - 10 : n4 + i.offset;
  return jsx("g", { transform: `translate(${D2},${r3 - 6})`, children: jsx("text", { x: 0, y: 0, dy: 16, textAnchor: a2 === 0 ? "start" : "end", fontSize: 10, fill: "rgba(255,255,255,0.54)", children: a2 === 0 ? i.value : z2("chart.now") }) });
}, lt$2 = (t) => {
  let { width: e3, height: r3, stroke: o, fill: i } = t;
  return jsx(Cross, { x: t.x + t.width / 2, top: t.top, height: r3, width: 1, stroke: "rgba(255,255,255,0.16)", strokeDasharray: "3 2", fill: "none" });
}, st = (t) => {
  let { active: e3, payload: r3, label: o } = t, i = useRef((/* @__PURE__ */ new Date()).toISOString().split("T")[0]), { t: a2 } = Z$2();
  return e3 && r3 && r3.length ? jsx(d$1, { label: o === i.current ? a2("chart.now") : o, value: r3[0].value, coloring: true }) : null;
}, ct$1 = (t) => {
  let { invisible: e3 } = t, r3 = f(t.colors), o = useRef(0);
  return jsx(ResponsiveContainer, { className: cnBase(e3 && "chart-invisible"), onResize: (i, a2) => {
    o.current = i;
  }, children: jsxs(BarChart, { data: t.data, margin: { left: -10, top: 10, right: 10, bottom: 30 }, children: [!e3 && jsx(Tooltip, { cursor: jsx(lt$2, {}), content: jsx(st, {}) }), jsx(CartesianGrid, { vertical: false, stroke: "#FFFFFF", strokeOpacity: 0.04 }), jsx(ReferenceLine, { y: 0, stroke: "rgba(0,0,0,0.04)" }), !e3 && jsx(Bar, { dataKey: "pnl", shape: jsx(at$1, {}), children: t.data.map((i, a2) => jsx(Cell, { fill: i.pnl > 0 ? r3.profit : r3.loss }, `cell-${a2}`)) }), jsx(YAxis, { tick: { fontSize: 10, fill: "rgba(255,255,255,0.54)" }, tickFormatter: (i) => h(i), tickLine: false, axisLine: false, dataKey: "pnl" }), jsx(XAxis, { dataKey: "date", tickLine: false, interval: t.data.length - 2, height: 1, tick: jsx(nt, { containerWidth: o.current }), stroke: "#FFFFFF", strokeOpacity: 0.04 })] }) });
};
var y = (t) => {
  let { x: e3, y: r3, stroke: o, payload: i, index: a2 } = t, { t: n4 } = Z$2();
  return jsx("g", { transform: `translate(${e3},${r3 - 6})`, children: jsx("text", { x: 0, y: 0, dy: 16, textAnchor: "end", fontSize: 10, fill: "rgba(255,255,255,0.54)", children: a2 === 0 ? i.value : n4("chart.now") }) });
};
var vt$1 = (t) => {
  let { active: e3, payload: r3, label: o } = t, i = useRef((/* @__PURE__ */ new Date()).toISOString().split("T")[0]), { t: a2 } = Z$2();
  return e3 && r3 && r3.length ? jsx(d$1, { label: o === i.current ? a2("chart.now") : o, value: r3[0].value, coloring: true }) : null;
}, Ft$4 = (t) => {
  let e3 = f(t.colors), r3 = (i) => {
    let a2 = [];
    return i == null ? void 0 : i.reduce((n4, c2) => (n4 += c2.pnl, a2.push({ ...c2, pnl: n4, _pnl: c2.pnl }), n4), 0), a2;
  }, o = useMemo(() => r3(t.data), [t.data]);
  return jsx(ResponsiveContainer, { className: t.invisible ? "chart-invisible" : "", children: jsxs(LineChart, { data: o, margin: { top: 20, right: 10, left: -10, bottom: 0 }, children: [jsx(CartesianGrid, { vertical: false, stroke: "#FFFFFF", strokeOpacity: 0.04 }), jsx(XAxis, { dataKey: "date", interval: t.data.length - 2, tick: jsx(y, {}), stroke: "#FFFFFF", strokeOpacity: 0.04 }), jsx(YAxis, { dataKey: "pnl", tick: { fontSize: 10, fill: "rgba(255,255,255,0.54)" }, tickLine: false, axisLine: false, tickFormatter: (i) => h(i) }), !t.invisible && jsx(Tooltip, { cursor: { strokeDasharray: "3 2", strokeOpacity: 0.16 }, content: jsx(vt$1, {}) }), !t.invisible && jsx(Line, { type: "natural", dataKey: "pnl", stroke: e3.primary, strokeWidth: 2, dot: false, isAnimationActive: false })] }) });
};
var Bt$2 = (t) => {
  let { active: e3, payload: r3, label: o } = t, i = useRef((/* @__PURE__ */ new Date()).toISOString().split("T")[0]), { t: a2 } = Z$2();
  return e3 && r3 && r3.length ? jsx(d$1, { label: o === i.current ? a2("chart.now") : o, value: r3[0].value }) : null;
}, zt$3 = (t) => {
  let e3 = f(t.colors);
  return jsx(ResponsiveContainer, { className: t.invisible ? "chart-invisible" : "", children: jsxs(LineChart, { width: 530, height: 180, data: t.data, margin: { top: 20, right: 10, left: -20, bottom: -10 }, children: [jsx(CartesianGrid, { vertical: false, stroke: "#FFFFFF", strokeOpacity: 0.04 }), jsx(XAxis, { dataKey: "date", interval: t.data.length - 2, tick: jsx(y, {}), stroke: "#FFFFFF", strokeOpacity: 0.04 }), jsx(YAxis, { dataKey: "account_value", tick: { fontSize: 10, fill: "rgba(255,255,255,0.54)" }, tickLine: false, axisLine: false, tickFormatter: (r3) => h(r3) }), !t.invisible && jsx(Tooltip, { cursor: { strokeDasharray: "3 2", strokeOpacity: 0.16 }, content: jsx(Bt$2, {}) }), !t.invisible && jsx(Line, { type: "natural", dataKey: "account_value", stroke: e3.profit, strokeWidth: 2, dot: false, isAnimationActive: false })] }) });
};
G$3(V$2());
var X$1 = (e3) => {
  let { pnl: t, hide: o } = e3, r3 = t == null ? void 0 : t.entity, n4 = useSymbolsInfo(), { getFirstRefCode: i } = useReferralInfo(), s = useMemo(() => {
    var _a2;
    let a2 = (_a2 = i()) == null ? void 0 : _a2.code;
    return { code: (t == null ? void 0 : t.refCode) ?? a2, slogan: t == null ? void 0 : t.refSlogan, link: t == null ? void 0 : t.refLink };
  }, [i, t]), c2 = useMemo(() => {
    if (r3) return n4[r3 == null ? void 0 : r3.symbol]("base_dp");
  }, [r3, n4]), l2 = useMemo(() => {
    if (r3) return n4[r3 == null ? void 0 : r3.symbol]("quote_dp");
  }, [r3, n4]);
  return { entity: r3, leverage: t == null ? void 0 : t.leverage, baseDp: c2, quoteDp: l2, referralInfo: s, shareOptions: t, hide: o };
};
function j$1(e3, t, o, r3, n4, i, s, c2, l2) {
  let { t: a2 } = Z$2(), { symbol: u2, currency: x2 } = Xe$4(e3.symbol), f2 = { symbol: u2, currency: x2, side: e3.side };
  switch (n4) {
    case "pnl": {
      e3.pnl != null && (f2.pnl = new g$6(e3.pnl).toFixed(2, g$6.ROUND_DOWN));
      break;
    }
    case "roi": {
      e3.roi != null && (f2.ROI = new g$6(e3.roi).toFixed(2, g$6.ROUND_DOWN));
      break;
    }
    case "roi_pnl": {
      e3.pnl != null && (f2.pnl = new g$6(e3.pnl).toFixed(2, g$6.ROUND_DOWN)), e3.roi != null && (f2.ROI = new g$6(e3.roi).toFixed(2, g$6.ROUND_DOWN));
      break;
    }
  }
  let y2 = [];
  i.has("leverage") && (f2.leverage = t), ["openPrice", "closePrice", "openTime", "closeTime", "markPrice", "quantity"].forEach((P2) => {
    if (i.has(P2)) switch (P2) {
      case "leverage":
        break;
      case "openPrice": {
        e3.openPrice != null && y2.push({ title: a2("share.pnl.optionalInfo.openPrice"), value: Y$1(e3.openPrice, c2 || 2) });
        break;
      }
      case "closePrice": {
        e3.closePrice != null && y2.push({ title: a2("share.pnl.optionalInfo.closePrice"), value: Y$1(e3.closePrice, c2 || 2) });
        break;
      }
      case "openTime": {
        e3.openTime != null && y2.push({ title: a2("share.pnl.optionalInfo.openTime"), value: Pe$3(e3.openTime) });
        break;
      }
      case "closeTime": {
        e3.closeTime != null && y2.push({ title: a2("share.pnl.optionalInfo.closeTime"), value: Pe$3(e3.closeTime) });
        break;
      }
      case "markPrice": {
        e3.markPrice != null && y2.push({ title: a2("common.markPrice"), value: Y$1(e3.markPrice, c2 || 2) });
        break;
      }
      case "quantity":
        e3.quantity != null && y2.push({ title: a2("common.quantity"), value: Y$1(e3.quantity, s || 2) });
    }
  }), f2.informations = y2;
  let w5 = { position: f2, updateTime: Ye$4(/* @__PURE__ */ new Date()), domain: r3 };
  return o.length > 0 && (w5.message = o), typeof l2 < "u" && l2.code !== void 0 && (w5.referral = l2), w5;
}
function Xe$4(e3) {
  let t = e3.split("_");
  if (t.length !== 3) return { symbol: e3, currency: "USDC" };
  let [o, r3, n4] = t;
  return { symbol: `${r3}-${o}`, currency: n4 || "USDC" };
}
function Ye$4(e3) {
  var _a2, _b2, _c2, _d2, _e4;
  let t = e3 instanceof Date ? e3 : new Date(e3), o = { year: "numeric", month: "2-digit", day: "2-digit", hour: "2-digit", minute: "2-digit", hourCycle: "h23" }, n4 = new Intl.DateTimeFormat("en-US", o).formatToParts(t), i = (_a2 = n4.find((u2) => u2.type === "year" ? u2.value : "")) == null ? void 0 : _a2.value, s = (_b2 = n4.find((u2) => u2.type === "month" ? u2.value : "")) == null ? void 0 : _b2.value, c2 = (_c2 = n4.find((u2) => u2.type === "day" ? u2.value : "")) == null ? void 0 : _c2.value, l2 = (_d2 = n4.find((u2) => u2.type === "hour" ? u2.value : "")) == null ? void 0 : _d2.value, a2 = (_e4 = n4.find((u2) => u2.type === "minute" ? u2.value : "")) == null ? void 0 : _e4.value;
  return `${i}-${s}-${c2} ${l2}:${a2}`;
}
function Pe$3(e3) {
  var _a2, _b2, _c2, _d2;
  let t = e3 instanceof Date ? e3 : new Date(e3), o = { year: "numeric", month: "short", day: "2-digit", hour: "2-digit", minute: "2-digit", hourCycle: "h23" }, n4 = new Intl.DateTimeFormat("en-US", o).formatToParts(t), i = (_a2 = n4.find((a2) => a2.type === "month" ? a2.value : "")) == null ? void 0 : _a2.value, s = (_b2 = n4.find((a2) => a2.type === "day" ? a2.value : "")) == null ? void 0 : _b2.value, c2 = (_c2 = n4.find((a2) => a2.type === "hour" ? a2.value : "")) == null ? void 0 : _c2.value, l2 = (_d2 = n4.find((a2) => a2.type === "minute" ? a2.value : "")) == null ? void 0 : _d2.value;
  return `${i}-${s} ${c2}:${l2}`;
}
function Y$1(e3, t) {
  return new g$6(e3).toFixed(t, g$6.ROUND_DOWN);
}
function ee(e3, t, o, r3) {
  localStorage.setItem("pnl_config_key", JSON.stringify({ bgIndex: o, pnlFormat: e3, options: Array.from(t), message: r3 }));
}
function te$4() {
  let e3 = localStorage.getItem("pnl_config_key");
  if (e3 && e3.length > 0) try {
    return JSON.parse(e3);
  } catch {
  }
  return { bgIndex: 0, pnlFormat: "roi_pnl", options: ["openPrice", "closePrice", "openTime", "closeTime", "markPrice", "quantity", "leverage"], message: "" };
}
var V$1 = forwardRef((e3, t) => {
  let { width: o, height: r3, className: n4, data: i, style: s } = e3, { ref: c2, download: l2, toDataURL: a2, copy: u2, toBlob: x2 } = usePoster(i, { ratio: e3.ratio });
  return useImperativeHandle(t, () => ({ download: l2, toDataURL: a2, toBlob: x2, copy: u2 })), jsx("canvas", { ref: c2, width: o, height: r3, className: n4, style: s });
});
var Se$4 = (e3) => {
  let { children: t, ...o } = e3;
  return jsx("button", { ...o, children: jsxs("svg", { width: "20", height: "20", viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsx("rect", { width: "20", height: "20", rx: "10", fill: "#333948" }), jsx("path", { d: "M11.186 5.348a.67.67 0 0 0-.436.27l-2.657 4a.69.69 0 0 0 0 .75l2.657 4a.68.68 0 0 0 .934.188.685.685 0 0 0 .187-.937L9.463 9.993 11.87 6.37a.685.685 0 0 0-.187-.938.65.65 0 0 0-.498-.083", fill: "#fff", fillOpacity: ".54" })] }) });
}, be$4 = (e3) => {
  let { children: t, ...o } = e3;
  return jsx("button", { ...o, children: jsxs("svg", { width: "20", height: "20", viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsx("rect", { width: "20", height: "20", rx: "10", fill: "#333948" }), jsx("path", { d: "M8.777 5.348a.65.65 0 0 0-.498.083.685.685 0 0 0-.187.938L10.5 9.993 8.092 13.62a.685.685 0 0 0 .187.937.68.68 0 0 0 .934-.187l2.657-4a.69.69 0 0 0 0-.75l-2.657-4a.67.67 0 0 0-.436-.271", fill: "#fff", fillOpacity: ".54" })] }) });
};
var ke$1 = (e3) => {
  let { backgroundImages: t, selectedSnap: o, setSelectedSnap: r3 } = e3, [n4, i] = nt$4({ containScroll: "keepSnaps", dragFree: true }), s = useCallback(() => {
    i && ((i == null ? void 0 : i.canScrollPrev()) ? i.scrollPrev() : o - 1 >= 0 && r3(o - 1));
  }, [i, o]), c2 = useCallback(() => {
    i && ((i == null ? void 0 : i.canScrollNext()) ? i.scrollNext() : o + 1 < t.length && r3(o + 1));
  }, [i, o]), l2 = useCallback((a2) => {
    r3(a2.selectedScrollSnap());
  }, []);
  return useEffect(() => {
    i && (l2(i), i.on("reInit", l2), i.on("select", l2), i == null ? void 0 : i.scrollTo(o));
  }, [i, l2]), jsxs(z$1, { mt: 4, px: 2, children: [jsx(Se$4, { onClick: s }), jsx("div", { ref: n4, className: "oui-w-full oui-overflow oui-overflow-x-auto oui-scrollbar-hidden oui-hide-scrollbar oui-mx-0", children: jsx(z$1, { children: t.map((a2, u2) => jsx(_$1, { onClick: () => {
    (i == null ? void 0 : i.canScrollPrev()) || (i == null ? void 0 : i.canScrollNext()) ? i == null ? void 0 : i.scrollTo(u2) : r3(u2);
  }, mx: 2, my: 1, mr: 6, r: "base", className: cnBase("oui-shrink-0 oui-w-[162px]", o === u2 && "oui-outline oui-outline-1 oui-outline-primary-darken"), children: jsx("img", { src: a2, className: "oui-rounded-sm" }) }, a2)) }) }), jsx(be$4, { onClick: c2 })] });
};
var Ie$1 = (e3) => {
  let { type: t, curType: o, setPnlFormat: r3 } = e3, { t: n4 } = Z$2(), i = useMemo(() => {
    switch (t) {
      case "roi_pnl":
        return n4("share.pnl.displayFormat.roi&Pnl");
      case "roi":
        return n4("share.pnl.displayFormat.roi");
      case "pnl":
        return n4("share.pnl.displayFormat.pnl");
    }
  }, [t, n4]), s = t === o, c2 = "oui-flex oui-items-center oui-gap-1 oui-cursor-pointer";
  return s ? c2 += " oui-text-base-contrast" : c2 += "", jsxs("div", { className: c2, onClick: () => {
    r3(t);
  }, children: [jsx(pt$3, { sel: s }), jsx($$4, { size: "xs", intensity: 54, className: cnBase("oui-ml-2 "), children: i })] });
}, pt$3 = (e3) => jsx("button", { type: "button", children: e3.sel === true ? jsx(ft$2, {}) : jsx(dt$2, {}) }), ft$2 = () => jsxs("svg", { width: "16", height: "16", viewBox: "0 0 16 16", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", className: "oui-fill-primary-darken", children: [jsx("path", { d: "M8.01 1.333a6.667 6.667 0 1 0 0 13.333 6.667 6.667 0 0 0 0-13.333m0 1.333a5.334 5.334 0 1 1-.001 10.667 5.334 5.334 0 0 1 0-10.667", fill: "#fff", fillOpacity: ".36" }), jsx("circle", { cx: "8", cy: "8", r: "3.333" })] }), dt$2 = () => jsx("svg", { width: "16", height: "16", viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: jsx("path", { d: "M8.01 1.333a6.667 6.667 0 1 0 0 13.333 6.667 6.667 0 0 0 0-13.333m0 1.333a5.334 5.334 0 1 1-.001 10.667 5.334 5.334 0 0 1 0-10.667", fill: "#fff", fillOpacity: ".54" }) });
var oe$1 = (e3) => {
  let { size: t = 16, className: o } = e3;
  return jsx("button", { type: "button", onClick: (r3) => {
    e3.onCheckedChange(!e3.checked);
  }, className: o, children: e3.checked ? jsx("svg", { width: t, height: t, viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M4.66 1.953A2.667 2.667 0 0 0 1.995 4.62v6.667a2.667 2.667 0 0 0 2.667 2.666h6.666a2.667 2.667 0 0 0 2.667-2.666V4.62a2.667 2.667 0 0 0-2.667-2.667zm6.664 2.922a.8.8 0 0 1 .557-.208c.2 0 .406.063.558.208a.734.734 0 0 1 0 1.063l-5.434 5.179a.826.826 0 0 1-1.115 0l-2.33-2.22a.736.736 0 0 1 0-1.063.827.827 0 0 1 1.117 0l1.77 1.687z", fill: "#fff", fillOpacity: ".8" }) }) : jsx("svg", { width: t, height: t, viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: jsx("path", { d: "M4.66 1.953A2.667 2.667 0 0 0 1.995 4.62v6.667a2.667 2.667 0 0 0 2.667 2.666h6.666a2.667 2.667 0 0 0 2.667-2.666V4.62a2.667 2.667 0 0 0-2.667-2.667zm0 1.334h6.667c.737 0 1.334.596 1.334 1.333v6.667c0 .736-.597 1.333-1.334 1.333H4.661a1.333 1.333 0 0 1-1.334-1.333V4.62c0-.737.597-1.333 1.334-1.333", fill: "#fff", fillOpacity: ".8" }) }) });
};
var Oe = (e3) => {
  let { type: t, curType: o, setShareOption: r3 } = e3, { t: n4 } = Z$2(), i = useMemo(() => {
    switch (t) {
      case "openPrice":
        return n4("share.pnl.optionalInfo.openPrice");
      case "closePrice":
        return n4("share.pnl.optionalInfo.closePrice");
      case "openTime":
        return n4("share.pnl.optionalInfo.openTime");
      case "closeTime":
        return n4("share.pnl.optionalInfo.closeTime");
      case "markPrice":
        return n4("common.markPrice");
      case "quantity":
        return n4("common.quantity");
      case "leverage":
        return n4("common.leverage");
    }
  }, [t, n4]), s = o.has(t);
  return jsxs(z$1, { itemAlign: "center", gap: 1, className: cnBase("hover:oui-cursor-pointer"), onClick: () => {
    r3((c2) => {
      let l2 = new Set(c2);
      return s ? l2.delete(t) : l2.add(t), l2;
    });
  }, children: [jsx(oe$1, { size: 16, checked: s, className: "oui-pt-[2px]", onCheckedChange: (c2) => {
    r3((l2) => {
      let a2 = new Set(l2);
      return s ? a2.delete(t) : a2.add(t), a2;
    });
  } }), jsx($$4, { size: "xs", intensity: 54, children: i })] });
};
var Fe$2 = (e3) => {
  let { message: t, setMessage: o, check: r3, setCheck: n4 } = e3, [i, s] = useState(false), c2 = useRef(null), { t: l2 } = Z$2();
  return jsxs("div", { className: "oui-mt-3 oui-mb-6 oui-flex oui-items-center", children: [jsx(oe$1, { className: "oui-mt-[2px]", checked: r3, onCheckedChange: (a2) => {
    n4(a2);
  } }), jsx("div", { className: "oui-text-xs oui-text-base-contrast-54 oui-ml-1 hover:oui-cursor-pointer", onClick: () => {
    n4(!e3.check);
  }, children: l2("share.pnl.optionalInfo.message") }), jsx("div", { className: "oui-bg-base-900 oui-mx-2 oui-rounded-sm", children: jsx(So$4, { ref: c2, placeholder: l2("share.pnl.optionalInfo.message.placeholder"), classNames: { root: "oui-w-[320px]" }, size: "sm", value: t, autoFocus: false, suffix: i && jsx("button", { className: "oui-mr-3 oui-cursor-pointer", onMouseDown: (a2) => {
    o(""), setTimeout(() => {
      var _a2;
      (_a2 = c2.current) == null ? void 0 : _a2.focus();
    }, 50), a2.stopPropagation();
  }, children: jsx(za, { size: 18, color: "white" }) }), onFocus: () => s(true), onBlur: () => s(false), onChange: (a2) => {
    if (a2.target.value.length > 25) {
      toast$2.error(l2("share.pnl.optionalInfo.message.maxLength"));
      return;
    }
    n4(a2.target.value.length > 0), o(a2.target.value);
  } }) })] });
};
var Re$4 = (e3) => {
  let { onClickDownload: t, onClickCopy: o } = e3, { t: r3 } = Z$2();
  return jsxs(z$1, { px: 8, gap: 3, mt: 3, itemAlign: "center", children: [jsxs(_e$5, { color: "secondary", className: "oui-flex-1 oui-flex oui-gap-1", onClick: t, children: [jsx("span", { children: jsx(Ot$2, {}) }), r3("common.download")] }), jsxs(_e$5, { className: "oui-flex-1 oui-flex oui-gap-1", onClick: o, children: [jsx("span", { children: jsx(Ft$3, {}) }), r3("common.copy")] })] });
}, Ot$2 = () => jsx("svg", { width: "16", height: "16", viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: jsx("path", { d: "M4.66 1.994A2.667 2.667 0 0 0 1.995 4.66v6.666a2.667 2.667 0 0 0 2.667 2.667h6.666a2.667 2.667 0 0 0 2.667-2.667V4.661a2.667 2.667 0 0 0-2.667-2.667zM7.995 4.66c.368 0 .667.298.667.666V8.66h2l-2.667 2.666L5.328 8.66h2V5.327c0-.368.299-.667.667-.667", fill: "#fff", fillOpacity: ".98" }) }), Ft$3 = () => jsx("svg", { width: "17", height: "16", viewBox: "0 0 17 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: jsx("path", { d: "M5.166 1.994A2.667 2.667 0 0 0 2.499 4.66v4a2.667 2.667 0 0 0 2.667 2.667 2.667 2.667 0 0 0 2.666 2.667h4a2.667 2.667 0 0 0 2.667-2.667v-4a2.667 2.667 0 0 0-2.667-2.667 2.667 2.667 0 0 0-2.666-2.666zm6.666 4c.737 0 1.334.596 1.334 1.333v4c0 .737-.597 1.334-1.334 1.334h-4A1.333 1.333 0 0 1 6.5 11.327h2.667a2.667 2.667 0 0 0 2.666-2.667z", fill: "#fff", fillOpacity: ".98" }) });
var Ee$3 = (e3) => {
  let { shareOptions: t } = e3, { t: o } = Z$2(), r3 = te$4(), i = e3.entity.roi != null && e3.entity.pnl != null ? ["roi_pnl", "roi", "pnl"] : e3.entity.roi != null ? ["roi"] : e3.entity.pnl != null ? ["pnl"] : [], [s, c2] = useState(i.length == 1 ? i[0] : r3.pnlFormat), [l2, a2] = useState(new Set(r3.options)), [u2, x2] = useState(r3.bgIndex), [f2, y2] = useState(r3.message), [M2, w5] = useState(false), { backgroundImages: P2, ...W2 } = t ?? { backgroundImages: [] }, [S2, O2] = useState(""), v2 = useRef(null);
  useEffect(() => {
    let k2 = window.location.hostname;
    O2(k2);
  }, []);
  let $2 = useMemo(() => {
    var _a2;
    return (_a2 = t == null ? void 0 : t.backgroundImages) == null ? void 0 : _a2[u2];
  }, [t == null ? void 0 : t.backgroundImages, u2]), h2 = j$1(e3.entity, e3.leverage, M2 ? f2 : "", S2, s, l2, e3.baseDp, e3.quoteDp, e3.referral), re2 = () => {
    var _a2;
    (_a2 = v2.current) == null ? void 0 : _a2.copy().then(() => {
      var _a3;
      (_a3 = e3.hide) == null ? void 0 : _a3.call(e3), toast$2.success(o("share.pnl.image.copied"));
    }).catch((k2) => {
      toast$2.error(() => jsxs("div", { children: [jsx("div", { children: o("common.copy.failed") }), jsx("div", { className: "oui-text-2xs oui-max-w-[396px] oui-mt-2 oui-text-base-contrast-54", children: o("share.pnl.copy.failed.description") })] }));
    });
  }, Q2 = () => {
    var _a2, _b2;
    (_a2 = v2.current) == null ? void 0 : _a2.download("Poster.png"), (_b2 = e3.hide) == null ? void 0 : _b2.call(e3);
  }, ae3 = [...e3.entity.openPrice ? ["openPrice"] : [], ...e3.entity.closePrice ? ["closePrice"] : [], ...e3.entity.markPrice ? ["markPrice"] : [], ...e3.entity.openTime ? ["openTime"] : [], ...e3.entity.closeTime ? ["closeTime"] : [], ...e3.leverage ? ["leverage"] : [], ...e3.entity.quantity ? ["quantity"] : []];
  return ee(s, l2, u2, f2), jsxs("div", { className: "oui-h-full oui-flex oui-flex-col oui-relative oui-w-full", children: [jsxs("div", { className: "oui-flex-1 oui-h-full oui-overflow-y-auto", children: [jsxs(_$1, { mt: 9, height: 422, children: [jsx(z$1, { itemAlign: "center", justify: "center", children: jsx(V$1, { width: 552, height: 310, data: { backgroundImg: $2, ...W2, data: h2 }, ratio: 3, ref: v2 }) }), jsx(ke$1, { backgroundImages: (t == null ? void 0 : t.backgroundImages) ?? [], selectedSnap: u2, setSelectedSnap: x2 })] }), jsxs(z$1, { direction: "column", px: 10, mt: 6, justify: "start", itemAlign: "start", width: "100%", children: [jsx($$4, { size: "sm", intensity: 80, children: o("share.pnl.displayFormat") }), jsx(z$1, { pt: 3, gap: 3, itemAlign: "center", children: i.map((k2, E3) => jsx(Ie$1, { setPnlFormat: c2, type: k2, curType: s }, E3)) }), jsx(te$6, { className: "oui-w-full oui-pt-6 oui-border-white/10" }), jsxs(z$1, { mt: 6, direction: "column", justify: "start", itemAlign: "start", children: [jsx($$4, { size: "sm", intensity: 80, children: o("share.pnl.optionalInfo") }), jsx(z$1, { mt: 3, gap: 4, className: "oui-flex-wrap", children: ae3.map((k2, E3) => jsx(Oe, { setShareOption: a2, type: k2, curType: l2 }, E3)) })] }), jsx(Fe$2, { message: f2, setMessage: y2, check: M2, setCheck: w5 })] })] }), jsx(Re$4, { onClickCopy: re2, onClickDownload: Q2 })] });
};
var ze$5 = Ce__default__default.createContext(null);
function L$1() {
  let e3 = Ce__default__default.useContext(ze$5);
  if (!e3) throw new Error("useCarousel must be used within a <Carousel />");
  return e3;
}
var ce$4 = Ce__default__default.forwardRef(({ orientation: e3 = "horizontal", opts: t, setApi: o, plugins: r3, className: n4, children: i, ...s }, c2) => {
  let [l2, a2] = nt$4({ ...t, axis: e3 === "horizontal" ? "x" : "y" }, r3), [u2, x2] = Ce__default__default.useState(false), [f2, y2] = Ce__default__default.useState(false), [M2, w5] = Ce__default__default.useState(s.initIndex || 0), [P2, W2] = Ce__default__default.useState([]), S2 = Ce__default__default.useCallback((h2) => {
    h2 && (P2.length === 0 && W2(h2.scrollSnapList()), w5(h2.selectedScrollSnap()), x2(h2.canScrollPrev()), y2(h2.canScrollNext()));
  }, [P2]), O2 = Ce__default__default.useCallback(() => {
    a2 == null ? void 0 : a2.scrollPrev();
  }, [a2]), v2 = Ce__default__default.useCallback(() => {
    a2 == null ? void 0 : a2.scrollNext();
  }, [a2]), $2 = Ce__default__default.useCallback((h2) => {
    h2.key === "ArrowLeft" ? (h2.preventDefault(), O2()) : h2.key === "ArrowRight" && (h2.preventDefault(), v2());
  }, [O2, v2]);
  return Ce__default__default.useEffect(() => {
    !a2 || !o || o(a2);
  }, [a2, o]), Ce__default__default.useEffect(() => {
    if (a2) return S2(a2), a2.on("reInit", S2), a2.on("select", S2), s.initIndex && a2.scrollTo(s.initIndex), () => {
      a2 == null ? void 0 : a2.off("select", S2);
    };
  }, [a2, S2]), jsx(ze$5.Provider, { value: { carouselRef: l2, api: a2, opts: t, orientation: e3 || ((t == null ? void 0 : t.axis) === "y" ? "vertical" : "horizontal"), scrollPrev: O2, scrollNext: v2, canScrollPrev: u2, canScrollNext: f2, selectedIndex: M2, scrollSnaps: P2 }, children: jsx("div", { ref: c2, onKeyDownCapture: $2, className: cnBase("oui-relative", n4), role: "region", "aria-roledescription": "carousel", ...s, children: i }) });
});
ce$4.displayName = "Carousel";
var Z$1 = Ce__default__default.forwardRef(({ className: e3, ...t }, o) => {
  let { carouselRef: r3, orientation: n4 } = L$1();
  return jsx("div", { ref: r3, className: "oui-overflow-hidden", children: jsx("div", { ref: o, className: cnBase("oui-flex", n4 === "horizontal" ? "oui--ml-4" : "oui--mt-4 oui-flex-col", e3), ...t }) });
});
Z$1.displayName = "CarouselContent";
var G$2 = Ce__default__default.forwardRef(({ className: e3, ...t }, o) => {
  let { orientation: r3 } = L$1();
  return jsx("div", { ref: o, role: "group", "aria-roledescription": "slide", className: cnBase("oui-min-w-0 oui-shrink-0 oui-grow-0 oui-basis-full", r3 === "horizontal" ? "oui-pl-4" : "oui-pt-4", e3), ...t });
});
G$2.displayName = "CarouselItem";
var ue$4 = Ce__default__default.forwardRef(({ className: e3, variant: t = "contained", size: o = "icon", ...r3 }, n4) => {
  let { orientation: i, scrollPrev: s, canScrollPrev: c2 } = L$1();
  return jsxs(_e$5, { ref: n4, variant: t, className: cnBase("oui-absolute  oui-h-8 oui-w-8 oui-rounded-full", i === "horizontal" ? "oui--left-12 oui-top-1/2 oui--translate-y-1/2" : "oui--top-12 oui-left-1/2 oui--translate-x-1/2 oui-rotate-90", e3), disabled: !c2, onClick: s, ...r3, children: [jsx(ChevronLeft, { size: 20 }), jsx("span", { className: "oui-sr-only", children: "Previous slide" })] });
});
ue$4.displayName = "CarouselPrevious";
var me$3 = Ce__default__default.forwardRef(({ className: e3, variant: t = "contained", size: o = "icon", ...r3 }, n4) => {
  let { orientation: i, scrollNext: s, canScrollNext: c2 } = L$1();
  return jsxs(_e$5, { ref: n4, variant: t, className: cnBase("oui-absolute oui-h-8 oui-w-8 oui-rounded-full", i === "horizontal" ? "oui--right-12 oui-top-1/2 oui--translate-y-1/2" : "oui--bottom-12 oui-left-1/2 oui--translate-x-1/2 oui-rotate-90", e3), disabled: !c2, onClick: s, ...r3, children: [jsx(ChevronRight, { size: 20 }), jsx("span", { className: "oui-sr-only", children: "Next slide" })] });
});
me$3.displayName = "CarouselNext";
var pe$1 = (e3) => {
  let { scrollSnaps: t, selectedIndex: o } = L$1();
  return jsx("div", { className: cnBase("oui-flex oui-gap-1", e3.className), children: t.map((r3, n4) => jsx(fe$3, { index: n4, active: n4 === o, onClick: e3.onClick, className: e3.dotClassName, activeClassName: e3.dotActiveClassName }, n4)) });
};
pe$1.displayName = "CarouselIdentifier";
var fe$3 = ({ index: e3, active: t, onClick: o, className: r3, activeClassName: n4 }) => jsx("button", { onClick: () => o == null ? void 0 : o(e3), className: cnBase("oui-w-2 oui-h-2 oui-rounded-full oui-bg-white/30", r3, t && `active ${n4 || "oui-bg-primary-darken"}`) });
var R = ce$4;
R.Content = Z$1;
R.Item = G$2;
R.Next = me$3;
R.Previous = ue$4;
R.indentify = pe$1;
var _e$3 = (e3) => {
  var _a2, _b2;
  let { shareOptions: t } = e3, { t: o } = Z$2(), r3 = te$4(), i = e3.entity.roi != null && e3.entity.pnl != null ? ["roi_pnl", "roi", "pnl"] : e3.entity.roi != null ? ["roi"] : e3.entity.pnl != null ? ["pnl"] : [], [s, c2] = useState(i.length == 1 ? i[0] : r3.pnlFormat), [l2, a2] = useState(new Set(r3.options)), [u2, x2] = useState(r3.message), [f2, y2] = useState(r3.bgIndex), { backgroundImages: M2, ...w5 } = t ?? { backgroundImages: [] }, [P2, W2] = useState(""), S2 = (_a2 = t == null ? void 0 : t.backgroundImages) == null ? void 0 : _a2.map(() => useRef(null));
  useEffect(() => {
    let p2 = window.location.hostname;
    W2(p2);
  }, []);
  let O2 = j$1(e3.entity, e3.leverage, u2, P2, s, l2, e3.baseDp, e3.quoteDp, e3.referral), v2 = useRef(), $2 = 552 / 310, [h2, re2] = useState(1), [Q2, ae3] = useState(0), [k2, E3] = useState(false), xe2 = useRef(null);
  useEffect(() => {
    if (v2.current) {
      let p2 = v2.current.offsetWidth, A2 = p2 / $2;
      ae3(A2), re2(p2 / 552);
    }
  }, [v2, P2]);
  let Ke3 = async (p2) => {
    var _a3, _b3;
    if (!p2.current) return;
    let A2 = (_a3 = p2.current) == null ? void 0 : _a3.toDataURL(), Je2 = Vt$2(A2);
    try {
      navigator.share && await navigator.share({ text: u2, files: [new File([Je2], "image.png", { type: "image/png" })] }), (_b3 = e3.hide) == null ? void 0 : _b3.call(e3);
    } catch {
    }
  };
  return ee(s, l2, f2, u2), jsxs("div", { className: "oui-w-full", children: [jsx("div", { ref: v2, className: "oui-w-full oui-mt-4 oui-overflow-hidden", style: { height: `${Q2 + 20}px` }, children: jsxs(R, { className: "oui-w-full oui-overflow-hidden", opts: { align: "start" }, initIndex: f2, children: [jsx(Z$1, { style: { height: `${Q2}px` }, children: (_b2 = t == null ? void 0 : t.backgroundImages) == null ? void 0 : _b2.map((p2, A2) => jsx(G$2, { children: jsx(V$1, { className: "oui-transform oui-origin-top-left", style: { scale: `${h2}` }, width: 552, height: 310, data: { backgroundImg: p2, ...w5, data: O2 }, ratio: 3, ref: S2 == null ? void 0 : S2[A2] }) }, A2)) }), jsx("div", { className: "oui-mt-2 oui-mb-1 oui-flex oui-justify-center", children: jsx(Kt$2, { dotClassName: "oui-w-[16px] oui-h-[4px] oui-bg-base-300", dotActiveClassName: "!oui-bg-primary-darken oui-w-[20px]", setSelectIndex: y2 }) })] }) }), jsxs($e$5, { className: "oui-max-h-[200px] oui-overflow-y-auto oui-custom-scrollbar", children: [jsxs("div", { className: "oui-mt-4", children: [jsx("div", { className: "oui-text-3xs oui-text-base-contrast-54", children: o("share.pnl.displayFormat") }), jsx("div", { className: "oui-pt-3 oui-px-1 oui-justify-between oui-gap-3 oui-grid oui-grid-cols-3 oui-row-span-1", children: i.map((p2) => jsx($t$4, { setPnlFormat: c2, type: p2, curType: s })) })] }), jsxs("div", { className: "oui-mt-3", children: [jsx("div", { className: "oui-text-3xs oui-text-base-contrast-54 oui-h-[18px]", children: o("share.pnl.optionalInfo") }), jsxs("div", { className: "oui-flex oui-flex-wrap oui-gap-3 oui-mt-3", children: [e3.entity.openPrice && jsx(B$3, { setShareOption: a2, type: "openPrice", curType: l2 }), e3.entity.closePrice && jsx(B$3, { setShareOption: a2, type: "closePrice", curType: l2 }), e3.entity.openTime && jsx(B$3, { setShareOption: a2, type: "openTime", curType: l2 }), e3.entity.closeTime && jsx(B$3, { setShareOption: a2, type: "closeTime", curType: l2 }), e3.leverage && jsx(B$3, { setShareOption: a2, type: "leverage", curType: l2 }), e3.entity.markPrice && jsx(B$3, { setShareOption: a2, type: "markPrice", curType: l2 }), e3.entity.quantity && jsx(B$3, { setShareOption: a2, type: "quantity", curType: l2 })] })] }), jsxs("div", { className: "oui-mt-3 oui-mb-8", children: [jsx("div", { className: "oui-text-3xs oui-text-base-contrast-54 oui-h-[18px]", children: o("share.pnl.optionalInfo.message") }), jsx("div", { className: "oui-mt-3 oui-h-[48px] oui-bg-base-600 oui-mx-1", children: jsx(So$4, { placeholder: o("share.pnl.optionalInfo.message.placeholder"), containerClassName: "oui-bg-transparent oui-h-[48px]", value: u2, autoFocus: false, onChange: (p2) => {
    if (p2.target.value.length > 25) {
      toast$2.error(o("share.pnl.optionalInfo.message.maxLength"));
      return;
    }
    x2(p2.target.value);
  }, ref: xe2, onFocus: () => E3(true), onBlur: () => E3(false), suffix: k2 && jsx("button", { className: "oui-mr-3 oui-cursor-pointer", onMouseDown: (p2) => {
    x2(""), setTimeout(() => {
      var _a3;
      (_a3 = xe2.current) == null ? void 0 : _a3.focus();
    }, 50), p2.stopPropagation();
  }, children: jsx(za, { size: 18, color: "white" }) }) }) })] })] }), jsx("div", { className: "oui-pt-2", children: jsx(_e$5, { fullWidth: true, className: "oui-h-[40px] oui-text-[16px]", onClick: () => {
    let p2 = S2 == null ? void 0 : S2[f2];
    p2 && Ke3(p2);
  }, children: o("common.share") }) })] });
}, $t$4 = (e3) => {
  let { type: t, curType: o, setPnlFormat: r3 } = e3, { t: n4 } = Z$2(), i = useMemo(() => {
    switch (t) {
      case "roi_pnl":
        return n4("share.pnl.displayFormat.roi&Pnl");
      case "roi":
        return n4("share.pnl.displayFormat.roi");
      case "pnl":
        return n4("share.pnl.displayFormat.pnl");
    }
  }, [t]);
  return jsx("div", { className: cnBase("oui-shadow-lg oui-rounded-lg oui-h-[46px] oui-flex-1 oui-bg-base-4 hover:oui-cursor-pointer oui-flex oui-items-center oui-px-3 oui-referral-shadow", t === o && "oui-bg-primary-darken oui-dot-sel"), onClick: () => {
    r3(t);
  }, children: jsx("div", { className: "oui-text-sm oui-text-base-contrast", children: i }) });
}, B$3 = (e3) => {
  let { type: t, curType: o, setShareOption: r3 } = e3, { t: n4 } = Z$2(), i = useMemo(() => {
    switch (t) {
      case "openPrice":
        return n4("share.pnl.optionalInfo.openPrice");
      case "closePrice":
        return n4("share.pnl.optionalInfo.closePrice");
      case "openTime":
        return n4("share.pnl.optionalInfo.openTime");
      case "closeTime":
        return n4("share.pnl.optionalInfo.closeTime");
      case "markPrice":
        return n4("common.markPrice");
      case "quantity":
        return n4("common.quantity");
      case "leverage":
        return n4("common.leverage");
    }
  }, [t, n4]), s = o.has(t);
  return jsxs("div", { className: cnBase("oui-shadow-lg oui-rounded-lg oui-h-[46px] oui-mt-0 oui-w-[calc(50%-6px)] oui-bg-base-4 hover:oui-cursor-pointer oui-items-center oui-flex oui-p-3 oui-referral-shadow"), onClick: () => {
    r3((c2) => {
      let l2 = new Set(c2);
      return s ? l2.delete(t) : l2.add(t), l2;
    });
  }, children: [jsx("div", { className: "oui-text-sm oui-flex-1 oui-text-base-contrast", children: i }), s && jsx(Jt$1, {})] });
};
function Vt$2(e3) {
  let t = atob(e3.split(",")[1]), o = e3.split(",")[0].split(":")[1].split(";")[0], r3 = new ArrayBuffer(t.length), n4 = new Uint8Array(r3);
  for (let i = 0; i < t.length; i++) n4[i] = t.charCodeAt(i);
  return new Blob([r3], { type: o });
}
var Kt$2 = (e3) => {
  let { scrollSnaps: t, selectedIndex: o } = L$1();
  return useEffect(() => {
    e3.setSelectIndex(o);
  }, [o]), jsx("div", { className: cnBase("oui-flex oui-gap-1"), children: t.map((r3, n4) => jsx(fe$3, { index: n4, active: n4 === o, onClick: e3.onClick, className: e3.dotClassName, activeClassName: e3.dotActiveClassName }, n4)) });
}, Jt$1 = () => jsx("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M2.01416 11.9989C2.01416 6.47589 6.49136 1.9989 12.0142 1.9989C17.5372 1.9989 22.0142 6.47589 22.0142 11.9989C22.0142 17.5219 17.5372 21.9989 12.0142 21.9989C6.49136 21.9989 2.01416 17.5219 2.01416 11.9989ZM16.9853 7.31211C17.2125 7.09537 17.5236 7 17.8218 7C18.1201 7 18.4312 7.09537 18.6583 7.31211C19.1139 7.74546 19.1139 8.47384 18.6583 8.9072L10.5077 16.675C10.0534 17.1083 9.28909 17.1083 8.83472 16.675L5.34077 13.3459C4.88641 12.9126 4.88641 12.1841 5.34077 11.7508C5.79631 11.3175 6.56057 11.3175 7.01493 11.7508L9.67122 14.2822L16.9853 7.31211Z", fill: "white", fillOpacity: "1" }) });
var Ue$4 = (e3) => {
  let { leverage: t, entity: o, baseDp: r3, quoteDp: n4, referralInfo: i, shareOptions: s, hide: c2 } = e3, [l2, a2] = useState(window.innerHeight < 900 ? 660 : 807);
  return useEffect(() => {
    let u2 = () => {
      a2(window.innerHeight < 900 ? 660 : 807);
    };
    return window.addEventListener("resize", u2), () => {
      window.removeEventListener("resize", u2);
    };
  }, []), s == null || o == null ? jsx(Fragment$1, {}) : jsx(Ee$3, { entity: o, leverage: t, hide: c2, baseDp: r3, quoteDp: n4, referral: i, shareOptions: s });
}, We$5 = (e3) => {
  let { leverage: t, entity: o, baseDp: r3, quoteDp: n4, referralInfo: i, shareOptions: s, hide: c2 } = e3;
  return s == null || o == null ? jsx(Fragment$1, {}) : jsx(_e$3, { entity: o, leverage: t, hide: c2, baseDp: r3, quoteDp: n4, referral: i, shareOptions: s });
};
var ve$3 = (e3) => {
  let t = X$1({ hide: e3.hide, pnl: e3.pnl });
  return jsx(We$5, { ...t });
}, Ce$2 = (e3) => {
  let t = X$1({ hide: e3.hide, pnl: e3.pnl });
  return jsx(Ue$4, { ...t });
};
var jt$4 = "sharePnLDialog", eo$3 = "sharePnLBottomSheet";
Pg(jt$4, Ce$2, { classNames: { content: "!oui-max-w-[624px] oui-p-0" } });
ng(eo$3, ve$3, { title: e2.t("share.pnl.sharePnl"), classNames: { body: "oui-pb-4 oui-pt-0" } });
var J$1 = (e3) => {
  let { type: t, values: o } = e3, [i, a2] = useLocalStorage("TP/SL_Mode", "Offset%"), [l2, p2] = useState(true), { t: g2 } = Z$2(), r3 = useMemo(() => {
    switch (i) {
      case "Offset":
        return `${t.toLowerCase()}_offset`;
      case "Offset%":
        return `${t.toLowerCase()}_offset_percentage`;
      default:
        return `${t.toLowerCase()}_pnl`;
    }
  }, [i]), P2 = useMemo(() => o[i], [o, i]), _2 = useMemo(() => [{ label: g2("tpsl.pnl"), value: "PnL", testId: "PnL_menu_item" }, { label: g2("tpsl.offset"), value: "Offset", testId: "Offset_mneu_item" }, { label: `${g2("tpsl.offset")}%`, value: "Offset%", testId: "Offset%_menu_item" }], [g2]), m2 = useRef(""), T2 = (c2) => {
    e3.onChange(r3, c2);
  }, x2 = (c2) => {
    let { dp: u2 = 2 } = c2;
    return { onRenderBefore: (s, L2) => (s = `${s}`, l2 && t === "SL" && i === "PnL" && (s = s.startsWith("-") ? s : "-" + s), s === "" || s === "-" ? "" : i === "Offset%" ? `${new g$6(s.replace(new RegExp(m2.current.replace(".", "\\.") + "$"), "")).mul(100).todp(2, 4).toString()}${m2.current}` : (i === "Offset" && (s = A$7(s, u2)), `${s}`)), onSendBefore: (s) => {
      if (/^\-?0{2,}$/.test(s)) return "0";
      if (i === "Offset%") {
        if (s !== "") {
          s = A$7(s, 2);
          let L2 = s.match(/\.0{0,2}$/);
          L2 ? m2.current = L2[0] : m2.current = "", s = new g$6(s).div(100).toString(), s = `${s}${m2.current}`;
        }
      } else i === "PnL" && t === "SL" && l2 ? s = s.startsWith("-") ? s : "-" + s : s = A$7(s, u2);
      return s === "" || s === "-" ? "" : s;
    } };
  };
  return { mode: i, modes: _2, type: e3.type, formatter: x2, onModeChange: (c2) => {
    a2(c2);
  }, value: P2, pnl: o.PnL, onValueChange: T2, quote_dp: e3.quote_dp, setFocus: p2 };
};
var te$3 = (e3) => {
  let { mode: t, modes: o, onModeChange: i, onValueChange: a2, quote: l2, quote_dp: p2, value: g2, pnl: r3 } = e3, { t: P2 } = Z$2(), [_2, m2] = useState(t), [T2, x2] = useState(t === "Offset%" ? "%" : l2), c2 = useMemo(() => {
    let u2 = Number(r3);
    if (isNaN(u2) || u2 === 0) return "";
    if (u2 > 0) return "oui-text-trade-profit";
    if (u2 < 0) return "oui-text-trade-loss";
  }, [r3]);
  return useEffect(() => {
    var _a2;
    let u2 = (_a2 = o.find((s) => s.value === t)) == null ? void 0 : _a2.label;
    m2(u2), x2(t === "Offset%" ? "%" : l2);
  }, [t, o]), jsx(So$4, { prefix: _2, size: { initial: "lg", lg: "md" }, placeholder: T2, align: "right", value: g2, "data-testid": e3.testId, autoComplete: "off", onValueChange: a2, formatters: [e3.formatter({ dp: p2, mode: t }), Xr$1.currencyFormatter, Xr$1.decimalPointFormatter], classNames: { input: c2, prefix: "oui-text-base-contrast-54", root: "oui-outline-line-12 focus-within:oui-outline-primary-light" }, onFocus: () => {
    x2(""), e3.setFocus(true);
  }, onBlur: () => {
    x2(t === "Offset%" ? "%" : l2), e3.setFocus(false);
  }, suffix: jsxs(Fragment$1, { children: [t === "Offset%" && !!g2 && jsx($$4, { size: "2xs", color: "inherit", className: cnBase("oui-ml-[2px]", c2), children: "%" }), jsx(Ae$1, { mode: t, modes: o, onModeChange: (u2) => i(u2.value) })] }) });
}, Ae$1 = (e3) => jsx(If, { currentValue: e3.mode, menu: e3.modes, align: "end", size: "xs", className: "oui-min-w-[80px]", onSelect: (t) => e3.onModeChange(t), children: jsx("button", { className: "oui-p-2", children: jsx(Q$4, { size: 12, color: "white" }) }) });
var U$1 = (e3) => {
  let { testId: t, quote: o, ...i } = e3, a2 = J$1(i);
  return jsx(te$3, { ...a2, testId: t, quote: o });
};
var le$2 = (e3) => {
  let { TPSL_OrderEntity: t, symbolInfo: o, onCancel: i, onComplete: a2, status: l2, errors: p2, isPosition: g2 } = e3, { t: r3 } = Z$2(), { parseErrorMsg: P2 } = Tr$1(p2);
  return jsxs("div", { id: "orderly-tp_sl-order-edit-content", children: [(!e3.isEditing || e3.isEditing && !e3.isPosition) && jsxs(Fragment$1, { children: [jsx(Ke$2, { maxQty: e3.maxQty, quantity: e3.orderQuantity ?? e3.maxQty, baseTick: o("base_tick"), dp: o("base_dp"), onQuantityChange: e3.setQuantity, quote: o("base"), isEditing: e3.isEditing, isPosition: g2, errorMsg: P2("quantity") }), jsx(te$6, { my: 4, intensity: 8 })] }), jsx(Ye$3, { sl_pnl: t.sl_pnl, tp_pnl: t.tp_pnl, quote: o("quote"), quote_dp: o("quote_dp"), onPriceChange: e3.setOrderPrice, onPnLChange: e3.setPnL, errors: p2, tp_values: { PnL: `${t.tp_pnl ?? ""}`, Offset: `${t.tp_offset ?? ""}`, "Offset%": `${t.tp_offset_percentage ?? ""}` }, sl_values: { PnL: `${t.sl_pnl ?? ""}`, Offset: `${t.sl_offset ?? ""}`, "Offset%": `${t.sl_offset_percentage ?? ""}` }, tp_trigger_price: t.tp_trigger_price ?? "", sl_trigger_price: t.sl_trigger_price ?? "" }), jsxs(ia$1, { cols: 2, gap: 3, mt: 4, children: [jsx(_e$5, { size: "md", color: "secondary", "data-testid": "tpsl-cancel", onClick: () => {
    i == null ? void 0 : i();
  }, children: r3("common.cancel") }), jsx(dr$3, { size: "md", "data-testid": "tpsl-confirm", disabled: !e3.valid || l2.isCreateMutating, loading: l2.isCreateMutating || l2.isUpdateMutating, onClick: () => {
    e3.onSubmit().then(() => {
      a2 == null ? void 0 : a2();
    }, () => {
    });
  }, children: r3("common.confirm") })] })] });
}, Ke$2 = (e3) => {
  let { isPosition: t } = e3, o = useRef(null), i = or$2(e3.quantity, 0, e3.maxQty) / 100, { t: a2 } = Z$2(), l2 = () => {
    var _a2, _b2;
    (_a2 = e3.onQuantityChange) == null ? void 0 : _a2.call(e3, 0), (_b2 = o.current) == null ? void 0 : _b2.focus(), setTimeout(() => {
      var _a3;
      (_a3 = o.current) == null ? void 0 : _a3.setSelectionRange(0, 1);
    }, 0);
  }, p2 = (r3) => {
    var _a2;
    if (e3.baseTick > 0) {
      (_a2 = e3.onQuantityChange) == null ? void 0 : _a2.call(e3, utils_exports.formatNumber(r3, e3.baseTick) ?? r3);
    }
  }, g2 = (t ? "" : e3.quantity).toString().length > 0 ? e3.errorMsg : void 0;
  return jsxs(Fragment$1, { children: [jsxs(z$1, { gap: 2, children: [jsx("div", { className: "oui-flex-1", children: jsx(So$4.tooltip, { "data-testid": "oui-testid-tpsl-popUp-quantity-input", ref: o, prefix: a2("common.quantity"), size: { initial: "lg", lg: "md" }, align: "right", value: t ? "" : e3.quantity, autoComplete: "off", classNames: { prefix: "oui-text-base-contrast-54", root: cnBase("oui-bg-base-5 oui-outline-line-12", g2 && "oui-outline-danger") }, tooltipProps: { content: { className: "oui-bg-base-6 oui-text-base-contrast-80" }, arrow: { className: "oui-fill-base-6" } }, tooltip: g2, color: g2 ? "danger" : void 0, formatters: [Xr$1.dpFormatter(e3.dp), Xr$1.numberFormatter, Xr$1.currencyFormatter, Xr$1.decimalPointFormatter], onValueChange: (r3) => {
    var _a2, _b2, _c2;
    (_a2 = e3.onQuantityChange) == null ? void 0 : _a2.call(e3, r3);
    let P2 = Number(r3);
    if (P2 && P2 > e3.maxQty) {
      let _2 = t ? 0 : e3.maxQty;
      (_b2 = e3.onQuantityChange) == null ? void 0 : _b2.call(e3, _2), (_c2 = o.current) == null ? void 0 : _c2.blur();
    }
  }, onBlur: (r3) => p2(r3.target.value), suffix: t ? jsx("button", { className: "oui-text-2xs oui-text-base-contrast-54 oui-px-3", onClick: () => {
    l2();
  }, children: a2("tpsl.entirePosition") }) : jsx("span", { className: "oui-text-2xs oui-text-base-contrast-54 oui-px-3", children: e3.quote }) }) }), !e3.isEditing && jsx(_e$5, { onClick: () => {
    var _a2;
    let r3 = t ? 0 : e3.maxQty;
    (_a2 = e3.onQuantityChange) == null ? void 0 : _a2.call(e3, r3), r3 === 0 && l2();
  }, variant: "outlined", className: cnBase("oui-text-2xs oui-w-[68px] oui-h-[40px] xl:oui-h-[32px]", t ? "oui-border-primary-light oui-text-primary-light hover:oui-bg-primary-light/20" : "oui-bg-base-6 oui-border-line-12 oui-text-base-contrast-54 hover:oui-bg-base-5"), children: a2("common.position") })] }), jsx(z$1, { mt: 2, itemAlign: "center", height: "15px", children: jsx(Bl.single, { markCount: 5, color: "primary", max: e3.maxQty, min: 0, showTip: true, step: e3.baseTick, value: e3.quantity, onValueCommit: (r3) => {
    p2(`${r3}`);
  }, onValueChange: (r3) => {
    var _a2;
    (_a2 = e3.onQuantityChange) == null ? void 0 : _a2.call(e3, r3);
  } }) }), jsxs(z$1, { justify: "between", children: [jsx($$4.numeral, { rule: "percentages", color: "primary", size: "2xs", children: i }), jsxs(z$1, { itemAlign: "center", gap: 1, children: [jsx("button", { className: "oui-leading-none", style: { lineHeight: 0 }, onClick: () => {
    var _a2;
    (_a2 = e3.onQuantityChange) == null ? void 0 : _a2.call(e3, e3.maxQty);
  }, children: jsx($$4, { color: "primary", size: "2xs", children: a2("common.max") }) }), jsx($$4.numeral, { rule: "price", size: "2xs", intensity: 54, tick: e3.baseTick, children: e3.maxQty })] })] })] });
}, Ye$3 = (e3) => {
  var _a2, _b2;
  let { t } = Z$2(), { parseErrorMsg: o } = Tr$1(e3.errors), i = (a2, l2) => {
    e3.onPnLChange(a2, l2);
  };
  return jsxs(Fragment$1, { children: [jsxs("div", { children: [jsxs(z$1, { justify: "between", children: [jsxs(z$1, { gap: 1, children: [jsx($$4, { size: "2xs", intensity: 80, children: t("tpsl.takeProfit") }), jsx($$4, { size: "2xs", intensity: 36, children: `(${(_a2 = t("orderEntry.orderType.marketOrder")) == null ? void 0 : _a2.toLowerCase()})` })] }), jsxs(z$1, { children: [jsx($$4, { size: "2xs", intensity: 36, children: `${t("tpsl.estPnl")}:` }), jsx($$4.numeral, { size: "2xs", coloring: true, showIdentifier: true, className: "oui-ml-1", children: e3.tp_pnl ?? "-" })] })] }), jsxs(ia$1, { cols: 2, gap: 2, pt: 2, pb: 4, children: [jsx(re$2, { type: "TP", value: e3.tp_trigger_price, error: o("tp_trigger_price"), onValueChange: (a2) => {
    e3.onPriceChange("tp_trigger_price", a2);
  }, quote_dp: e3.quote_dp ?? 2 }), jsx(U$1, { type: "TP", onChange: i, quote: e3.quote, quote_dp: e3.quote_dp, values: e3.tp_values })] })] }), jsxs("div", { children: [jsxs(z$1, { justify: "between", children: [jsxs(z$1, { gap: 1, children: [jsx($$4, { size: "2xs", intensity: 80, children: t("tpsl.stopLoss") }), jsx($$4, { size: "2xs", intensity: 36, children: `(${(_b2 = t("orderEntry.orderType.marketOrder")) == null ? void 0 : _b2.toLowerCase()})` })] }), jsxs(z$1, { children: [jsx($$4, { size: "2xs", intensity: 36, children: `${t("tpsl.estPnl")}:` }), jsx($$4.numeral, { size: "2xs", coloring: true, showIdentifier: true, className: "oui-ml-1", children: e3.sl_pnl ?? "-" })] })] }), jsxs(ia$1, { cols: 2, gap: 2, pt: 2, pb: 4, children: [jsx(re$2, { type: "SL", value: e3.sl_trigger_price, error: o("sl_trigger_price"), onValueChange: (a2) => {
    e3.onPriceChange("sl_trigger_price", a2);
  }, quote_dp: e3.quote_dp ?? 2 }), jsx(U$1, { type: "SL", onChange: i, quote: e3.quote, quote_dp: e3.quote_dp, values: e3.sl_values })] })] })] });
}, re$2 = (e3) => {
  let [t, o] = useState("USDC"), { t: i } = Z$2();
  return jsx(So$4.tooltip, { "data-testid": `oui-testid-tpsl-popUp-${e3.type.toLowerCase()}-input`, prefix: i("common.markPrice"), size: { initial: "lg", lg: "md" }, tooltip: e3.error, placeholder: t, align: "right", autoComplete: "off", value: e3.value, color: e3.error ? "danger" : void 0, classNames: { prefix: "oui-text-base-contrast-54", root: "oui-outline-line-12 focus-within:oui-outline-primary-light" }, onValueChange: e3.onValueChange, onFocus: () => {
    o("");
  }, onBlur: () => {
    o("USDC");
  }, formatters: [Xr$1.numberFormatter, Xr$1.dpFormatter(e3.quote_dp), Xr$1.currencyFormatter, Xr$1.decimalPointFormatter] });
}, B$2 = (e3) => {
  let { symbol: t, tpPrice: o, slPrice: i, qty: a2, maxQty: l2, side: p2, quoteDP: g2, baseDP: r3, isEditing: P2, isPositionTPSL: _2 } = e3, { t: m2 } = Z$2(), [T2, x2] = useLocalStorage("orderly_order_confirm", true), c2 = na$1({ size: "xs", intensity: 54 }), u2 = _2 ?? a2 >= l2;
  return jsxs(Fragment$1, { children: [P2 && jsx($$4, { as: "div", size: "2xs", intensity: 80, className: "oui-mb-3", children: `You agree to edit your ${j$3(t)} order.` }), jsxs(z$1, { pb: 4, children: [jsx(_$1, { grow: true, children: jsx($$4.formatted, { rule: "symbol", formatString: "base-type", size: "base", showIcon: true, as: "div", intensity: 80, children: t }) }), jsxs(z$1, { gap: 1, children: [u2 && jsx(od, { size: "xs", color: "primary", children: m2("common.position") }), jsx(Xe$3, { tpPrice: o, slPrice: i }), p2 === OrderSide.SELL ? jsx(od, { size: "xs", color: "success", children: m2("common.buy") }) : jsx(od, { size: "xs", color: "danger", children: m2("common.sell") })] })] }), jsx(te$6, {}), jsxs(z$1, { direction: "column", itemAlign: "stretch", gapY: 1, pt: 4, className: cnBase(c2, "oui-pb-4 xl:oui-pb-5"), children: [jsxs(z$1, { children: [jsx(_$1, { grow: true, children: m2("common.qty") }), jsx("div", { children: u2 ? jsx("span", { className: "oui-text-base-contrast", children: m2("tpsl.entirePosition") }) : jsx($$4.numeral, { intensity: 98, dp: r3, padding: false, children: a2 }) })] }), typeof o == "number" && o > 0 ? jsxs(z$1, { children: [jsx(_$1, { grow: true, children: m2("tpsl.tpPrice") }), jsx($$4.numeral, { as: "div", coloring: true, unit: "USDC", size: "sm", dp: g2, unitClassName: "oui-text-base-contrast-54 oui-ml-1", children: o })] }) : null, typeof i == "number" && i > 0 ? jsxs(z$1, { children: [jsx(_$1, { grow: true, children: m2("tpsl.slPrice") }), jsx($$4.numeral, { as: "div", coloring: true, unit: "USDC", size: "sm", dp: g2, className: "oui-text-trade-loss", unitClassName: "oui-text-base-contrast-54 oui-ml-1", children: i })] }) : null, jsxs(z$1, { children: [jsx(_$1, { grow: true, children: m2("common.price") }), jsx("div", { className: "oui-text-base-contrast", children: m2("common.marketPrice") })] })] }), jsx(_$1, { pt: 2, children: jsxs(z$1, { gap: 1, children: [jsx($r$1, { id: "disabledConfirm", color: "white", checked: !T2, onCheckedChange: (s) => {
    x2(!s);
  } }), jsx("label", { htmlFor: "disabledConfirm", className: na$1({ size: "xs", intensity: 54, className: "oui-ml-1" }), children: m2("orderEntry.disableOrderConfirm") })] }) })] });
}, Xe$3 = (e3) => {
  let { tpPrice: t, slPrice: o } = e3, { t: i } = Z$2();
  return t && o ? jsx(od, { size: "xs", color: "neutral", children: i("common.tpsl") }) : t ? jsx(od, { size: "xs", color: "neutral", children: i("tpsl.tp") }) : o ? jsx(od, { size: "xs", color: "neutral", children: i("tpsl.sl") }) : null;
};
var ce$3 = (e3) => {
  let { position: t, order: o, isEditing: i } = e3;
  if (i && !o) throw new SDKError("order is required when isEditing is true");
  let a2 = i ? o.symbol : t.symbol, l2 = useSymbolsInfo(), p2 = useRef(AlgoOrderRootType.TP_SL), [g2] = useLocalStorage("orderly_order_confirm", true), [r3, { submit: P2, deleteOrder: _2, setValue: m2, validate: T2, errors: x2, isCreateMutating: c2, isUpdateMutating: u2 }] = useTPSLOrder({ symbol: a2, position_qty: t.position_qty, average_open_price: t.average_open_price }, { defaultOrder: o, isEditing: i }), s = (f2) => {
    m2("quantity", f2);
  }, L2 = (f2, h2) => {
    m2(f2, h2);
  }, $2 = (f2, h2) => {
    m2(f2, h2);
  }, C2 = useMemo(() => Math.abs(Number(t.position_qty)), [t.position_qty]), Y2 = useMemo(() => {
    let f2 = (o == null ? void 0 : o.algo_type) === AlgoOrderRootType.POSITIONAL_TP_SL ? C2 : o == null ? void 0 : o.quantity, h2 = 0;
    if ((Number(r3.quantity) !== f2 || !i && r3.quantity) && (h2 = 1), o && i) {
      let Te2 = o.child_orders.find((D2) => D2.algo_type === AlgoOrderType.TAKE_PROFIT), Le3 = o.child_orders.find((D2) => D2.algo_type === AlgoOrderType.STOP_LOSS);
      (Te2 == null ? void 0 : Te2.trigger_price) !== Number(r3.tp_trigger_price) && typeof typeof r3.tp_trigger_price < "u" && (h2 = 2), (Le3 == null ? void 0 : Le3.trigger_price) !== Number(r3.sl_trigger_price) && typeof r3.sl_trigger_price < "u" && (h2 = 3);
    }
    return h2 === 1 && !r3.tp_trigger_price && !r3.sl_trigger_price && (h2 = -1), h2;
  }, [r3.tp_trigger_price, r3.sl_trigger_price, r3.quantity, o, i]), _e4 = useMemo(() => (o == null ? void 0 : o.algo_type) === AlgoOrderRootType.POSITIONAL_TP_SL && Number(r3.quantity) < C2 && !r3.tp_trigger_price && !r3.sl_trigger_price ? false : Y2 > 0 && !!r3.quantity && !x2, [r3.quantity, C2, Y2, x2]), V2 = useMemo(() => i ? o && o.algo_type !== AlgoOrderRootType.POSITIONAL_TP_SL ? false : r3.algo_order_id && r3.quantity == 0 ? true : Number(r3.quantity) >= C2 : Number(r3.quantity) >= C2, [r3.quantity, C2, o == null ? void 0 : o.algo_type, i]);
  useEffect(() => {
    if (!i && V2) {
      let f2 = utils_exports.findTPSLFromOrder(o);
      !r3.tp_trigger_price && f2.tp_trigger_price && L2("tp_trigger_price", f2.tp_trigger_price), !r3.sl_trigger_price && f2.sl_trigger_price && L2("sl_trigger_price", f2.sl_trigger_price);
    }
  }, [i, V2, r3]), useEffect(() => {
    let f2 = Number(r3.quantity) < C2 ? AlgoOrderRootType.TP_SL : AlgoOrderRootType.POSITIONAL_TP_SL;
    typeof e3.onTPSLTypeChange == "function" && p2.current !== f2 && e3.onTPSLTypeChange(f2), p2.current = f2;
  }, [r3.quantity, C2]);
  let be4 = () => (o == null ? void 0 : o.algo_order_id) && (o == null ? void 0 : o.symbol) ? _2(o == null ? void 0 : o.algo_order_id, o == null ? void 0 : o.symbol) : Promise.reject("order id or symbol is invalid"), xe2 = async () => Promise.resolve().then(() => typeof e3.onConfirm != "function" || !g2 ? P2().then(() => true, (f2) => ((f2 == null ? void 0 : f2.message) && toast$2.error(f2.message), Promise.reject(false))) : e3.onConfirm(r3, { position: t, submit: P2, cancel: be4 })).then((f2) => {
  });
  return { isEditing: i, symbolInfo: l2[a2], maxQty: C2, setQuantity: s, orderQuantity: r3.quantity, isPosition: V2, TPSL_OrderEntity: r3, setOrderValue: m2, setPnL: $2, setOrderPrice: L2, onSubmit: xe2, valid: _e4, errors: x2, status: { isCreateMutating: c2, isUpdateMutating: u2 } };
};
var M$1 = (e3) => {
  let { onCancel: t, onComplete: o, ...i } = e3, a2 = ce$3(i);
  return jsx(le$2, { ...a2, onCancel: t, onComplete: o });
};
var pt$2 = (e3) => {
  let { position: t, order: o, baseDP: i, quoteDP: a2, buttonProps: l2, isEditing: p2 } = e3, [g2, r3] = useState(false), [P2, _2] = useState(true), [m2] = useLocalStorage("orderly_order_confirm", true), { t: T2 } = Z$2(), x2 = p2 ? (o == null ? void 0 : o.algo_type) === AlgoOrderRootType.POSITIONAL_TP_SL : void 0;
  return jsxs(gt$2, { onOpenChange: (c2) => {
    P2 && r3(c2);
  }, open: g2, children: [jsx(En$2, { asChild: true, onClick: () => {
    r3(true);
  }, children: e3.children || jsx(_e$5, { variant: "outlined", size: "sm", color: "secondary", ...l2, children: e3.label }) }), jsx(vo$6, { className: cnBase("oui-w-[360px]", P2 ? "oui-visible" : "oui-invisible"), align: "end", side: "top", children: jsx(M$1, { position: t, order: o, isEditing: p2, onComplete: () => {
    r3(false);
  }, onCancel: () => {
    r3(false);
  }, onConfirm: (c2, u2) => {
    if (!m2) return Promise.resolve(true);
    _2(false);
    let s = Math.abs(Number(t.position_qty));
    if (`${c2.tp_trigger_price ?? ""}`.length === 0 && `${c2.sl_trigger_price ?? ""}`.length === 0) return uo$3.confirm({ title: T2("orders.cancelOrder"), content: T2("tpsl.cancelOrder.description"), onOk: () => u2.cancel() }).then(() => (r3(false), _2(true), true), () => (_2(true), Promise.reject(false)));
    let L2 = p2 || !!c2 && c2.algo_type === AlgoOrderRootType.POSITIONAL_TP_SL && c2.quantity === s;
    return uo$3.confirm({ title: T2(L2 ? "orders.editOrder" : "tpsl.confirmOrder"), onOk: () => u2.submit(), classNames: { body: "!oui-pb-0" }, content: jsx(B$2, { isPositionTPSL: x2, isEditing: L2, symbol: c2.symbol, qty: Number(c2.quantity), maxQty: s, tpPrice: Number(c2.tp_trigger_price), slPrice: Number(c2.sl_trigger_price), side: c2.side, quoteDP: a2 ?? 2, baseDP: i ?? 2 }) }).then(() => (r3(false), _2(true), true), () => (_2(true), Promise.reject(false)));
  } }) })] });
};
var Lt = (e3) => {
  let { position: t, order: o, symbolInfo: i, isEditing: a2 } = e3, { resolve: l2, hide: p2, updateArgs: g2 } = X$5(), [r3] = useLocalStorage("orderly_order_confirm", true), { t: P2 } = Z$2(), _2 = a2 ? (o == null ? void 0 : o.algo_type) === AlgoOrderRootType.POSITIONAL_TP_SL : void 0, m2 = (u2) => {
    a2 || g2({ title: u2 });
  }, T2 = () => {
    l2(), p2();
  }, { quote_dp: x2, base_dp: c2 } = i;
  return jsxs(Fragment$1, { children: [jsx(St$2, { position: t, symbolInfo: i }), jsx(M$1, { ...e3, onTPSLTypeChange: (u2) => {
    m2(u2 === AlgoOrderRootType.TP_SL ? P2("common.tpsl") : P2("tpsl.positionTpsl"));
  }, onComplete: T2, onConfirm: (u2, s) => {
    if (!r3) return Promise.resolve(true);
    let L2 = Math.abs(Number(t.position_qty)), $2 = a2 || !!u2 && u2.algo_type === AlgoOrderRootType.POSITIONAL_TP_SL && u2.quantity === L2;
    return uo$3.confirm({ title: P2($2 ? "orders.editOrder" : "tpsl.confirmOrder"), bodyClassName: "oui-pb-0 lg:oui-pb-0", onOk: () => s.submit(), content: jsx(B$2, { isPositionTPSL: _2, isEditing: a2, symbol: u2.symbol, qty: Number(u2.quantity), maxQty: L2, tpPrice: Number(u2.tp_trigger_price), slPrice: Number(u2.sl_trigger_price), side: u2.side, quoteDP: x2 ?? 2, baseDP: c2 ?? 2 }) }).then(() => true, (C2) => ((C2 == null ? void 0 : C2.message) && toast$2.error(C2.message), Promise.reject(false)));
  }, onCancel: () => {
    p2();
  } })] });
};
var St$2 = (e3) => {
  var _a2;
  let { position: t, symbolInfo: o } = e3, { data: i } = useMarkPrice(t.symbol), a2 = X$5(), { t: l2 } = Z$2(), p2 = useMemo(() => {
    var _a3;
    return ((_a3 = a2.args) == null ? void 0 : _a3.title) === l2("tpsl.positionTpsl");
  }, [(_a2 = a2.args) == null ? void 0 : _a2.title, l2]);
  return jsxs(Fragment$1, { children: [jsxs(z$1, { justify: "between", pb: 3, itemAlign: "center", children: [jsx($$4.formatted, { rule: "symbol", className: "oui-text-xs", showIcon: true, children: t.symbol }), jsxs(z$1, { gapX: 1, children: [p2 && jsx(od, { size: "xs", color: "primary", children: l2("common.position") }), jsx(od, { size: "xs", color: "neutral", children: l2("common.tpsl") }), t.position_qty < 0 ? jsx(od, { size: "xs", color: "buy", children: l2("common.buy") }) : jsx(od, { size: "xs", color: "sell", children: l2("common.sell") })] })] }), jsx(te$6, { intensity: 8 }), jsxs(_$1, { py: 3, className: "oui-space-y-1", children: [jsxs(z$1, { justify: "between", children: [jsx($$4, { size: "sm", intensity: 54, children: l2("common.avgOpen") }), jsx($$4.numeral, { className: "oui-text-xs", unit: o.quote, dp: o.quote_dp, unitClassName: "oui-ml-1 oui-text-base-contrast-36", children: t.average_open_price })] }), jsxs(z$1, { justify: "between", children: [jsx($$4, { size: "sm", intensity: 54, children: l2("common.markPrice") }), jsx($$4.numeral, { className: "oui-text-xs", unit: o.quote, dp: o.quote_dp, unitClassName: "oui-ml-1 oui-text-base-contrast-36", children: i })] })] })] });
};
var to$2 = createContext({}), O$1 = () => useContext(to$2), oe = (t) => {
  var _a2;
  let [e3, o] = useState(Math.abs(t.position.position_qty).toString()), { t: i } = Z$2();
  useEffect(() => {
    o(Math.abs(t.position.position_qty).toString());
  }, [t.position.position_qty]);
  let [s, n4] = useState(""), r3 = t.position.position_qty > 0 ? OrderSide.SELL : OrderSide.BUY, [a2, l2] = useState(void 0), [u2, c2] = useState(OrderType.MARKET), d2 = useSymbolsInfo(), b2 = t.position.symbol, S2 = d2 == null ? void 0 : d2[b2], m2 = S2("quote_dp"), f2 = S2("base_dp"), P2 = S2("base_tick"), { helper: C2, onSubmit: y2, submitting: D2 } = useOrderEntry((_a2 = t.position) == null ? void 0 : _a2.symbol, r3, true), k2 = (q2, z2) => {
    if (c2(q2), q2 === OrderType.LIMIT) {
      if (!z2) throw new Error(i("orderEntry.orderPrice.error.required"));
      n4(z2);
    } else n4("");
  }, Q2 = useMemo(() => {
    let { position: q2 } = t;
    if (!q2) return null;
    let z2 = { order_quantity: e3, symbol: t.position.symbol, order_type: u2, side: r3, reduce_only: true };
    return u2 === OrderType.LIMIT && (z2.order_price = s), z2;
  }, [t.position, s, u2, e3]), T2 = (q2) => {
    let z2 = C2.calculate({}, "order_quantity", q2);
    o(z2.order_quantity);
  }, G2 = (q2) => {
    let z2 = C2.calculate({}, "order_price", q2);
    n4(z2.order_price);
  };
  useEffect(() => {
    let q2 = Q2;
    C2.validator(q2).then((z2) => {
      l2(z2);
    });
  }, [Q2]);
  let kt2 = () => y2(Q2).catch((q2) => (typeof q2 == "string" ? toast$2.error(q2) : toast$2.error(q2.message), Promise.resolve()));
  return jsx(to$2.Provider, { value: { quantity: e3, price: s, type: u2, side: r3, position: t.position, updatePriceChange: G2, updateQuantity: T2, updateOrderType: k2, tpslOrder: t.position.algo_order, onSubmit: kt2, submitting: D2, closeOrderData: Q2, quoteDp: m2, baseDp: f2, baseTick: P2, errors: a2 }, children: t.children });
};
var eo$2 = createContext({}), I$2 = () => useContext(eo$2), Pt$2 = (t) => {
  let e3 = useSymbolsInfo()[t.symbol];
  return jsx(eo$2.Provider, { value: { base_dp: e3("base_dp"), quote_dp: e3("quote_dp"), base_tick: e3("base_tick"), quote_tick: e3("quote_tick"), base: e3("base"), quote: e3("quote"), symbol: t.symbol, origin: e3(), quote_max: e3("quote_max"), quote_min: e3("quote_min") }, children: t.children });
};
var ao$1 = () => {
  let [t, e3] = useState(false), { onSubmit: o, price: i, quantity: s, closeOrderData: n4, type: r3, submitting: a2, quoteDp: l2, errors: u2 } = O$1(), { base: c2, quote: d2 } = I$2(), [b2] = useLocalStorage("orderly_order_confirm", true), { t: S2 } = Z$2(), { parseErrorMsg: m2 } = Tr$1(u2), f2 = () => o().then((y2) => {
    e3(false);
  }, (y2) => {
    typeof y2 == "string" ? toast$2.error(y2) : toast$2.error(y2.message);
  }).catch((y2) => {
    typeof y2 == "string" ? toast$2.error(y2) : toast$2.error(y2.message);
  }), P2 = () => {
    e3(false);
  }, C2 = useMemo(() => r3 === OrderType.MARKET ? !s : !i || !s, [i, s, r3]);
  return jsxs(Fragment$1, { children: [jsx(_e$5, { variant: "outlined", size: "sm", color: "secondary", disabled: C2 || a2, loading: a2, onClick: (y2) => {
    y2.stopPropagation();
    let D2 = m2("order_quantity"), k2 = m2("order_price");
    if (D2 || k2) {
      toast$2.error(D2 ?? k2);
      return;
    }
    if (!b2) {
      o();
      return;
    }
    e3(true);
  }, children: S2("positions.column.close") }), jsx(me$4, { open: t, onOpenChange: e3, size: "sm", children: r3 === OrderType.MARKET ? jsx(qt$2, { base: c2, quantity: s, onClose: P2, onConfirm: f2, submitting: a2, classNames: { root: "oui-items-start" }, hideCloseIcon: true }) : jsx(ne$3, { base: c2, quantity: s, price: i, onClose: P2, onConfirm: f2, submitting: a2, quoteDp: l2, order: n4, hideCloseIcon: true }) })] });
}, lo$3 = (t) => {
  let { hideCloseIcon: e3 = false } = t;
  return jsxs("div", { className: "oui-pb-3 oui-border-b oui-border-line-4 oui-relative oui-w-full", children: [jsx($$4, { size: "base", children: t.title }), !e3 && jsx("button", { onClick: t.onClose, className: "oui-absolute oui-right-0 oui-top-0 oui-text-base-contrast-54 hover:oui-text-base-contrast-80 oui-p-2", children: jsx(ye$7, { size: 18, color: "white" }) })] });
}, mo$2 = ({ onCancel: t, onConfirm: e3, submitting: o }) => {
  let { t: i } = Z$2();
  return jsxs(z$1, { id: "oui-positions-confirm-footer", gap: 2, width: "100%", className: "oui-mt-3 oui-pb-1", children: [jsx(_e$5, { id: "oui-positions-confirm-footer-cancel-button", color: "secondary", fullWidth: true, onClick: t, size: "md", children: i("common.cancel") }), jsx(dr$3, { id: "oui-positions-confirm-footer-confirm-button", onClick: e3, fullWidth: true, loading: o, size: "md", children: i("common.confirm") })] });
}, Zi$1 = (t) => {
  let { quantity: e3, price: o, quoteDp: i, side: s } = t, { t: n4 } = Z$2(), r3 = useMemo(() => o && e3 ? new g$6(o).mul(e3).toFixed(i, g$6.ROUND_DOWN) : "--", [o, e3]);
  return jsxs(z$1, { direction: "column", gap: 1, width: "100%", className: "oui-text-sm oui-text-base-contrast-54", py: 5, children: [jsxs(z$1, { justify: "between", width: "100%", gap: 1, children: [jsx($$4, { children: n4("common.qty") }), jsx($$4, { color: s === OrderSide.BUY ? "success" : "danger", children: e3 })] }), jsxs(z$1, { justify: "between", width: "100%", gap: 1, children: [jsx($$4, { children: n4("common.price") }), jsx($$4.formatted, { intensity: 98, suffix: jsx($$4, { intensity: 54, children: "USDC" }), children: o })] }), jsxs(z$1, { justify: "between", width: "100%", gap: 1, children: [jsx($$4, { children: n4("common.notional") }), jsx($$4.formatted, { intensity: 98, suffix: jsx($$4, { intensity: 54, children: "USDC" }), children: r3 })] })] });
}, qt$2 = (t) => {
  var _a2;
  let { t: e3 } = Z$2(), o = () => {
    var _a3;
    (_a3 = (t == null ? void 0 : t.onClose) ?? t.close) == null ? void 0 : _a3();
  };
  return jsxs(z$1, { direction: "column", className: (_a2 = t.classNames) == null ? void 0 : _a2.root, children: [jsx(lo$3, { onClose: o, title: e3("positions.marketClose"), hideCloseIcon: t.hideCloseIcon }), jsx($$4, { intensity: 54, size: "sm", className: "oui-my-5", children: e3("positions.marketClose.description", { quantity: $$5(t.quantity), base: t.base }) }), jsx(mo$2, { onCancel: o, onConfirm: async () => {
    var _a3;
    await ((_a3 = t.onConfirm) == null ? void 0 : _a3.call(t)), o();
  }, submitting: t.submitting })] });
}, ne$3 = (t) => {
  let { order: e3, quoteDp: o, quantity: i, price: s, submitting: n4 } = t, { side: r3 } = e3, { t: a2 } = Z$2(), l2 = () => {
    var _a2;
    (_a2 = t.onClose) == null ? void 0 : _a2.call(t);
  };
  return jsxs(Fragment$1, { children: [jsx(lo$3, { onClose: l2, title: a2("positions.limitClose"), hideCloseIcon: t.hideCloseIcon }), jsx(_$1, { mt: 5, children: jsx($$4, { intensity: 54, size: "sm", children: a2("positions.limitClose.description", { quantity: d$3(t.quantity), base: t.base }) }) }), jsxs(z$1, { gap: 2, mb: 4, mt: 5, justify: "between", children: [jsx($$4.formatted, { rule: "symbol", formatString: "base-type", size: "base", showIcon: true, children: e3.symbol }), jsxs(z$1, { gap: 1, children: [jsx(od, { color: "neutral", size: "xs", children: a2("orderEntry.orderType.limit") }), jsx(od, { color: r3 === OrderSide.BUY ? "success" : "danger", size: "xs", children: r3 === OrderSide.BUY ? a2("common.buy") : a2("common.sell") })] })] }), jsx(te$6, { className: "oui-w-full" }), jsx(Zi$1, { className: "oui-text-sm", price: s, quantity: i, side: e3.side, quoteDp: o ?? 2 }), jsx(mo$2, { onCancel: l2, onConfirm: t.onConfirm, submitting: t.submitting })] });
};
var po$2 = () => {
  let { type: t, quoteDp: e3, price: o, updatePriceChange: i, updateOrderType: s, position: n4 } = O$1(), [r3, a2] = useState(false), { t: l2 } = Z$2();
  return jsxs(Yi, { children: [jsx(So$4, { size: "sm", value: t === OrderType.LIMIT ? o : l2("orderEntry.orderType.market"), onValueChange: (u2) => i(u2), formatters: [Xr$1.numberFormatter, ...e3 ? [Xr$1.dpFormatter(e3)] : []], onFocus: (u2) => {
    t === OrderType.MARKET && s(OrderType.LIMIT, `${n4.mark_price}`), a2(true);
  }, onBlur: (u2) => {
    setTimeout(() => {
      a2(false);
    }, 100);
  }, suffix: jsx(Xi$1, { asChild: true, children: jsx("button", { className: "oui-px-1 oui-h-full", children: jsx(Q$4, { size: 12, color: "white" }) }) }), classNames: { root: cnBase("oui-outline-line-12 focus-within:oui-outline-primary-light") } }), jsx(rr$2, { align: "end", className: "oui-w-[96px] oui-min-w-[96px]", onCloseAutoFocus: (u2) => u2.preventDefault(), children: jsx(kf, { children: jsx(ir$3, { size: "xs", onSelect: (u2) => {
    s(OrderType.MARKET);
  }, children: jsx("span", { children: l2("common.marketPrice") }) }) }) })] });
};
var xo$2 = (t) => {
  let [e3, o] = useState(false), [i, s] = useState(100), { baseDp: n4, quoteDp: r3, updateQuantity: a2, quantity: l2, type: u2, errors: c2, baseTick: d2 } = O$1();
  useEffect(() => {
    let m2 = (f2) => {
      f2.target.closest("[data-popover-root]") || o(false);
    };
    return document.addEventListener("click", m2), () => {
      document.removeEventListener("click", m2);
    };
  }, []);
  let b2 = (m2) => {
    S2(`${t.value * (m2 / 100)}`);
  }, S2 = (m2) => {
    if (d2 && d2 > 0) {
      let f2 = utils_exports.formatNumber(m2, d2) ?? m2;
      a2(f2);
    }
  };
  return jsxs(gt$2, { children: [jsx(En$2, { children: jsx(So$4, { size: "sm", onFocus: () => {
    o(true);
  }, classNames: { root: "oui-outline-line-12 " }, formatters: [Xr$1.numberFormatter, ...n4 ? [Xr$1.dpFormatter(n4)] : []], value: l2, onBlur: (m2) => S2(m2.target.value), onValueChange: (m2) => {
    if (a2(m2), m2 == "0" || m2 == "") {
      s(0);
      return;
    }
    let f2 = new g$6(m2).div(t.value).mul(100).abs().toFixed(0, g$6.ROUND_DOWN);
    s(Math.min(100, Number(f2)));
  } }) }), jsx(vo$6, { className: "oui-w-[360px] oui-rounded-xl", align: "start", side: "bottom", onOpenAutoFocus: (m2) => {
    m2.preventDefault();
  }, children: jsxs(z$1, { p: 1, gap: 2, width: "100%", itemAlign: "start", children: [jsx($$4, { size: "xs", intensity: 98, className: "oui-min-w-[30px]", children: `${i}%` }), jsxs(z$1, { direction: "column", width: "100%", gap: 2, children: [jsx(Bl, { markCount: 4, value: [i], onValueChange: (m2) => {
    let f2 = Array.from(m2.values());
    s(f2[0]), b2(f2[0]);
  } }), jsx(Sn$1, { onClick: (m2) => {
    s(m2 * 100), b2(m2 * 100);
  } })] })] }) })] });
}, Sn$1 = (t) => {
  let { t: e3 } = Z$2(), o = [{ label: "0%", value: 0 }, { label: "25%", value: 0.25 }, { label: "50%", value: 0.5 }, { label: "75%", value: 0.75 }, { label: e3("common.max"), value: 1 }];
  return jsx(z$1, { gap: 2, width: "100%", children: o.map((i, s) => jsx(_e$5, { variant: "outlined", color: "secondary", size: "xs", onClick: (n4) => {
    n4.stopPropagation(), t.onClick(i.value);
  }, className: "oui-w-1/5", children: i.label }, s)) });
};
var bo$3 = (t, e3) => {
  let o = I$2();
  return jsx($$4.numeral, { dp: o.base_dp, rm: g$6.ROUND_DOWN, padding: false, coloring: true, children: t });
}, Po$2 = (t, e3) => jsx(xo$2, { value: e3.position_qty }), Co$5 = (t) => jsx(po$2, {});
var me$2 = (t) => {
  if (t.sharePnLConfig == null) return jsx(Fragment$1, {});
  let { position: e3 } = t, o = () => {
    let i = t.isPositionHistory ? { side: e3.side, pnl: e3.netPnL, openPrice: Math.abs(e3.avg_open_price), closePrice: Math.abs(e3.avg_close_price), openTime: e3.open_timestamp, closeTime: e3.close_timestamp, quantity: e3.closed_position_qty } : { side: e3.position_qty > 0 ? "LONG" : "SHORT", pnl: e3.unrealized_pnl, roi: new g$6(e3.unrealized_pnl_ROI * 100).toFixed(2, g$6.ROUND_DOWN), openPrice: Math.abs(e3.average_open_price), markPrice: e3.mark_price, openTime: e3.timestamp, quantity: e3.position_qty };
    uo$3.show(t.modalId, { pnl: { entity: { symbol: e3.symbol, ...i }, refCode: t.refCode, ...t.sharePnLConfig, leverage: t.isPositionHistory ? void 0 : t.leverage } });
  };
  return jsx("button", { type: "button", onClick: (i) => {
    i.stopPropagation(), o();
  }, children: jsx(rn, { color: "white", opacity: 0.54, size: t.iconSize ?? 16 }) });
};
var ho$4 = (t) => {
  let { sharePnLConfig: e3, position: o, modalId: i, iconSize: s, isPositionHistory: n4 } = t, { getFirstRefCode: r3 } = useReferralInfo(), a2 = useMemo(() => {
    var _a2;
    return (_a2 = r3()) == null ? void 0 : _a2.code;
  }, [r3]), l2 = useSymbolLeverage(t.position.symbol);
  return { iconSize: s, position: o, refCode: a2, leverage: l2, sharePnLConfig: e3, modalId: i, isPositionHistory: n4 };
};
var Z2 = (t) => {
  let e3 = ho$4(t);
  return jsx(me$2, { ...e3 });
};
var To$1 = () => {
  let { position: t, baseDp: e3, quoteDp: o, tpslOrder: i } = O$1(), { t: s } = Z$2();
  return jsx(pt$2, { position: t, order: i, label: s("common.tpsl"), baseDP: e3, quoteDP: o, isEditing: false });
}, wo$3 = () => {
  let { position: t, baseDp: e3, quoteDp: o, tpslOrder: i } = O$1();
  return jsx(pt$2, { position: t, order: i, baseDP: e3, quoteDP: o, isEditing: true, children: jsx(Ja, { opacity: 1, className: "oui-text-base-contrast-54 oui-cursor-pointer", size: 16 }) });
};
var qo$1 = (t) => {
  let { stopLossPrice: e3, takeProfitPrice: o } = t, { tpslOrder: i, position: s } = O$1();
  return jsx(An, { stopLossPrice: e3, takeProfitPrice: o, direction: "column", order: i, position: s, tooltip: true });
}, Do$2 = (t) => {
  let { qty: e3, price: o, entryPrice: i, orderSide: s, orderType: n4, symbolInfo: r3 } = t, a2 = utils_exports.priceToPnl({ qty: e3, price: o, entryPrice: i, orderSide: s, orderType: n4 }, { symbol: r3 }), l2 = n4 === AlgoOrderType.TAKE_PROFIT ? "TP" : "SL";
  return jsxs(z$1, { children: [jsx($$4, { intensity: 54, className: "oui-mr-1", children: `${l2} PnL:` }), jsx($$4.formatted, { rule: "price", className: a2 === 0 ? "oui-text-base-contrast-36" : a2 > 0 ? "oui-text-trade-profit oui-gap-0" : "oui-text-trade-loss oui-gap-0", prefix: jsx($$4, { children: a2 === 0 ? "" : a2 > 0 ? "+" : "-" }), suffix: jsx($$4, { intensity: 36, className: "oui-ml-1", children: "USDC" }), children: `${Math.abs(a2)}` })] });
}, An = (t) => {
  let { direction: e3 = "row", order: o, position: i } = t, s = useSymbolsInfo(), { t: n4 } = Z$2(), r3 = useMemo(() => {
    let c2 = [];
    if (!t.tooltip || !o || !i) return;
    let d2 = o.quantity;
    return d2 === 0 && o.child_orders[0].type === "CLOSE_POSITION" && (d2 = i.position_qty), t.takeProfitPrice && c2.push(jsx(Do$2, { qty: d2, price: t.takeProfitPrice, entryPrice: i.average_open_price, orderSide: o.side, orderType: AlgoOrderType.TAKE_PROFIT, symbolInfo: s[o.symbol]() }, "tp")), t.stopLossPrice && c2.push(jsx(Do$2, { qty: d2, price: t.stopLossPrice, entryPrice: i.average_open_price, orderSide: o.side, orderType: AlgoOrderType.STOP_LOSS, symbolInfo: s[o.symbol]() }, "sl")), jsx("div", { children: c2 });
  }, [t.takeProfitPrice, t.stopLossPrice, i == null ? void 0 : i.average_open_price, o == null ? void 0 : o.side, o == null ? void 0 : o.quantity, o == null ? void 0 : o.algo_type]), a2 = useMemo(() => {
    let c2 = [];
    if (!(o == null ? void 0 : o.symbol)) return jsx("span", { children: "-" });
    return t.takeProfitPrice && c2.push(jsx($$4.formatted, { className: cnBase("oui-text-trade-profit oui-gap-0 oui-decoration-white/20"), rule: "price", dp: s[o.symbol]("quote_dp", 2), children: t.takeProfitPrice, prefix: !t.stopLossPrice || e3 === "column" ? jsx($$4, { intensity: 54, children: `${n4("tpsl.tp")} - ` }) : "" }, "tp")), t.stopLossPrice && c2.push(jsx($$4.formatted, { className: cnBase("oui-text-trade-loss oui-gap-0 oui-decoration-white/20 "), rule: "price", dp: s[o.symbol]("quote_dp", 2), children: t.stopLossPrice, prefix: !t.takeProfitPrice || e3 === "column" ? jsx($$4, { intensity: 54, children: `${n4("tpsl.sl")} - ` }) : "" }, "sl")), c2.length === 0 ? jsx($$4, { children: "-" }) : (c2.length === 2 && e3 === "row" && c2.splice(1, 0, jsx($$4, { children: "/" }, "split")), c2);
  }, [t.takeProfitPrice, t.stopLossPrice, o == null ? void 0 : o.symbol, n4]), l2 = jsx("div", { className: cnBase("oui-inline-flex oui-text-base-contrast-36", t.direction === "column" ? "oui-flex-col" : "oui-flex-row oui-gap-1", t.className), children: a2 }), u2 = Array.isArray(a2) ? !!a2.length : !a2;
  return t.tooltip ? jsxs(z$1, { gapX: 2, children: [jsx(Xn$2, { content: r3, children: l2 }), u2 && jsx(wo$3, {})] }) : l2;
};
var Bo$2 = (t) => {
  let [e3, o] = useLocalStorage("unPnlPriceBasis", "markPrice"), { t: i } = Z$2();
  return jsxs(z$1, { direction: "column", gap: 3, className: "oui-text-base-contrast-54 oui-items-start", children: [jsx($$4, { children: i("positions.column.unrealPnl.tooltip") }), jsx(te$6, { className: "oui-w-full" }), jsx("div", { className: "oui-mb-0", children: i("positions.column.unrealPnl.priceBasis") }), jsx(zn, { value: e3, onValueChange: o })] });
}, zn = (t) => {
  let { value: e3, onValueChange: o } = t, { t: i } = Z$2();
  return jsxs(z$1, { gap: 2, children: [jsx(vo$4, { sel: e3 === "markPrice", label: i("common.markPrice"), value: "markPrice", onCheckChange: o }), jsx(vo$4, { sel: e3 === "lastPrice", label: i("common.lastPrice"), value: "lastPrice", onCheckChange: o })] });
}, vo$4 = (t) => {
  let { sel: e3, label: o, value: i, onCheckChange: s } = t;
  return jsxs(z$1, { onClick: (n4) => {
    s(i), n4.stopPropagation();
  }, gap: 1, className: "oui-cursor-pointer", children: [e3 ? jsx(En, {}) : jsx(Wn, {}), jsx($$4, { size: "xs", intensity: e3 ? 98 : 54, children: o })] });
}, En = () => jsxs("svg", { width: "16", height: "16", viewBox: "0 0 16 16", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", className: "oui-fill-white", children: [jsx("path", { d: "M8.01 1.333a6.667 6.667 0 1 0 0 13.333 6.667 6.667 0 0 0 0-13.333m0 1.333a5.334 5.334 0 1 1-.001 10.667 5.334 5.334 0 0 1 0-10.667", fill: "#fff", fillOpacity: ".36" }), jsx("circle", { cx: "8", cy: "8", r: "3.333" })] }), Wn = () => jsx("svg", { width: "16", height: "16", viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: jsx("path", { d: "M8.01 1.333a6.667 6.667 0 1 0 0 13.333 6.667 6.667 0 0 0 0-13.333m0 1.333a5.334 5.334 0 1 1-.001 10.667 5.334 5.334 0 0 1 0-10.667", fill: "#fff", fillOpacity: ".54" }) });
var Et$4 = (t) => {
  let { tick: e3 = "quote_dp", ...o } = t, i = I$2();
  if (!i) throw new Error("NumeralWithCtx must be used inside SymbolProvider");
  return jsx($$4.numeral, { as: "span", ...o, dp: i[e3] });
};
var ko$3 = (t) => {
  let { pnlNotionalDecimalPrecision: e3, sharePnLConfig: o } = t, { t: i } = Z$2();
  return useMemo(() => [{ title: i("common.symbol"), dataIndex: "symbol", fixed: "left", width: 140, onSort: (n4, r3) => n4.symbol.localeCompare(r3.symbol), render: (n4, r3) => jsxs(z$1, { gap: 2, children: [jsx(_$1, { width: 4, height: 20, className: cnBase("oui-rounded-[1px]", r3.position_qty > 0 ? "oui-bg-trade-profit" : "oui-bg-trade-loss") }), jsx($$4.formatted, { formatString: "base-type", className: "oui-cursor-pointer", onClick: (a2) => {
    var _a2;
    (_a2 = t.onSymbolChange) == null ? void 0 : _a2.call(t, { symbol: n4 }), a2.stopPropagation(), a2.preventDefault();
  }, children: `${n4.split("_")[1]}-PERP` })] }) }, { title: i("common.quantity"), dataIndex: "position_qty", onSort: (n4, r3) => n4.position_qty - r3.position_qty, width: 120, className: "oui-pl-6", render: bo$3 }, { title: i("common.avgOpen"), className: "oui-h-[48px]", width: 120, onSort: true, dataIndex: "average_open_price", render: (n4, r3) => jsx(Et$4, { rm: g$6.ROUND_DOWN, children: n4 }) }, { title: i("common.markPrice"), dataIndex: "mark_price", width: 120, onSort: true, className: "oui-h-[48px]", render: (n4, r3) => jsx(Et$4, { rm: g$6.ROUND_DOWN, children: n4 }) }, { title: jsx(Xn$2, { className: "oui-max-w-[280px] oui-text-2xs oui-text-base-contrast-54 oui-p-3 oui-bg-base-8", content: i("positions.column.liqPrice.tooltip"), children: jsx($$4, { children: i("positions.column.liqPrice") }) }), width: 100, onSort: true, dataIndex: "est_liq_price", render: (n4, r3) => Number(n4) === 0 ? "--" : jsx(Et$4, { rm: g$6.ROUND_DOWN, className: Number(n4) > 0 ? "oui-text-warning-light" : "", children: n4 ?? "--" }) }, { title: jsx(Wg, { content: jsx(Bo$2, {}), side: "top", align: "center", className: "oui-max-w-[280px] oui-text-2xs", children: jsx($$4, { children: i("common.unrealizedPnl") }) }), dataIndex: "unrealized_pnl", width: 180, onSort: true, rule: "price", numeralProps: { coloring: true }, render: (n4, r3) => jsxs(z$1, { gap: 2, children: [jsxs(z$1, { children: [jsx($$4.numeral, { dp: t.pnlNotionalDecimalPrecision, rm: g$6.ROUND_DOWN, coloring: true, className: "oui-font-semibold", children: n4 }), jsx($$4.numeral, { rule: "percentages", dp: t.pnlNotionalDecimalPrecision, rm: g$6.ROUND_DOWN, coloring: true, className: "oui-font-semibold", prefix: "(", suffix: ")", children: r3.unrealized_pnl_ROI })] }), jsx(Z2, { position: r3, sharePnLConfig: t.sharePnLConfig, modalId: jt$4 })] }) }, { title: i("common.tpsl"), dataIndex: "__", width: 150, render: (n4, r3) => jsx(qo$1, { stopLossPrice: r3.sl_trigger_price, takeProfitPrice: r3.tp_trigger_price }) }, { title: i("common.notional"), dataIndex: "notional", className: "oui-h-[48px]", width: 100, onSort: true, render: (n4) => jsx($$4.numeral, { dp: e3, children: n4 }) }, { title: jsx(Xn$2, { className: "oui-max-w-[280px] oui-text-2xs oui-text-base-contrast-54 oui-p-3 oui-bg-base-8", content: jsxs(z$1, { direction: "column", gap: 3, className: "oui-text-base-contrast-54 oui-bg-base-8 oui-rounded-sm", children: [jsx("span", { children: i("positions.column.margin.tooltip") }), jsx(te$6, { className: "oui-w-full" }), jsx("span", { children: i("positions.column.margin.formula") })] }), children: jsx($$4, { children: i("positions.column.margin") }) }), dataIndex: "mm", onSort: true, width: 100, rule: "price", render: (n4) => jsx($$4.numeral, { children: n4 }) }, { title: i("common.qty"), dataIndex: "close_qty", width: 100, fixed: "right", render: Po$2 }, { title: i("common.price"), dataIndex: "close_price", width: 100, fixed: "right", render: Co$5 }, { title: "", dataIndex: "close_position", align: "right", width: 160, fixed: "right", render: (n4) => jsxs(z$1, { gapX: 2, justify: "end", children: [jsx(ao$1, {}), jsx(To$1, {})] }) }], [e3, o, i]);
};
var Ao$4 = (t) => {
  let { item: e3 } = t, o = e3.position_qty > 0, { t: i } = Z$2();
  return jsx($$4.formatted, { rule: "symbol", formatString: "base-type", size: "2xs", suffix: jsx(od, { color: o ? "success" : "danger", size: "xs", children: i(o ? "common.buy" : "common.sell") }), showIcon: true, onClick: () => {
    var _a2;
    (_a2 = t.onSymbolChange) == null ? void 0 : _a2.call(t, { symbol: e3.symbol });
  }, children: e3.symbol });
}, Ho$1 = (t) => {
  let { item: e3 } = t, { t: o } = Z$2();
  return jsxs(z$1, { gap: 3, children: [jsxs(z$1, { direction: "column", className: "oui-text-2xs", itemAlign: "end", children: [jsxs("div", { children: [jsx($$4, { intensity: 36, children: o("common.unrealizedPnl") }), jsx($$4, { intensity: 20, children: "(USDC)" })] }), jsx($$4.numeral, { size: "xs", dp: t.pnlNotionalDecimalPrecision, rm: g$6.ROUND_DOWN, coloring: true, className: "orderly-font-semibold", suffix: jsx($$4.numeral, { rule: "percentages", dp: t.pnlNotionalDecimalPrecision, rm: g$6.ROUND_DOWN, prefix: "(", suffix: ")", className: cnBase("oui-ml-1", e3.unrealized_pnl_ROI > 0 ? "oui-text-success-darken" : "oui-text-danger-darken"), children: e3.unrealized_pnl_ROI }), children: e3.unrealized_pnl })] }), jsx(Z2, { position: e3, sharePnLConfig: t.sharePnLConfig, modalId: eo$3, iconSize: 12 })] });
}, Ro$2 = (t) => {
  let { item: e3 } = t, { t: o } = Z$2();
  return jsx(da$2, { label: o("common.qty"), classNames: { root: "oui-text-xs", label: "oui-text-2xs" }, children: jsx($$4.numeral, { dp: t.base_dp, padding: false, coloring: true, children: e3.position_qty }) });
}, zo = (t) => {
  let { item: e3 } = t, { t: o } = Z$2();
  return jsx(da$2, { label: jsxs("span", { children: [o("positions.column.margin"), jsx($$4, { intensity: 20, children: "(USDC)" })] }), classNames: { root: "oui-text-xs", label: "oui-text-2xs" }, children: jsx($$4.numeral, { dp: t.quote_dp, intensity: 80, children: e3.mm }) });
}, Eo$2 = (t) => {
  let { item: e3 } = t, { t: o } = Z$2();
  return jsx(da$2, { align: "end", label: jsxs("span", { children: [o("common.notional"), jsx($$4, { intensity: 20, children: "(USDC)" })] }), classNames: { root: "oui-text-xs", label: "oui-text-2xs" }, children: jsx($$4.numeral, { dp: t.quote_dp, intensity: 80, children: e3.notional }) });
}, Wo$1 = (t) => {
  let { item: e3 } = t, { t: o } = Z$2();
  return jsx(da$2, { label: o("common.avgOpen"), classNames: { root: "oui-text-xs", label: "oui-text-2xs" }, children: jsx($$4.numeral, { dp: t.quote_dp, rm: g$6.ROUND_DOWN, intensity: 80, children: e3.average_open_price }) });
}, Uo$2 = (t) => {
  let { item: e3 } = t, { t: o } = Z$2();
  return jsx(da$2, { label: o("common.markPrice"), classNames: { root: "oui-text-xs", label: "oui-text-2xs" }, children: jsx($$4.numeral, { dp: t.quote_dp, rm: g$6.ROUND_DOWN, intensity: 80, children: e3.mark_price }) });
}, Qo$1 = (t) => {
  let { item: e3 } = t, { t: o } = Z$2(), i = e3.est_liq_price && e3.est_liq_price > 0 ? e3.est_liq_price : "-";
  return jsx(da$2, { label: o("positions.column.liqPrice"), align: "end", classNames: { root: "oui-text-xs", label: "oui-text-2xs" }, children: jsx($$4.numeral, { dp: t.quote_dp, rm: g$6.ROUND_DOWN, color: "warning", children: i }) });
}, $o$2 = (t) => {
  let { item: e3 } = t, { t: o } = Z$2();
  return e3.tp_trigger_price == null && e3.sl_trigger_price == null ? jsx(Fragment$1, {}) : jsxs(z$1, { className: "oui-text-2xs oui-text-base-contrast-36", children: [jsxs($$4, { children: [`${o("common.tpsl")}:`, ""] }), jsxs(z$1, { className: "oui-gap-[2px]", children: [e3.tp_trigger_price && jsx($$4.numeral, { color: "buy", children: e3.tp_trigger_price }), e3.sl_trigger_price && "/", e3.sl_trigger_price && jsx($$4.numeral, { color: "sell", children: e3.sl_trigger_price })] })] });
};
var ye$4 = (t) => {
  var _a2, _b2;
  let { item: e3, sheetOpen: o, setSheetOpen: i, dialogOpen: s, setDialogOpen: n4, updatePriceChange: r3, base: a2, quantity: l2, price: u2, onClose: c2, onConfirm: d2, submitting: b2, quote_dp: S2, closeOrderData: m2, onCloseDialog: f2 } = t, P2 = e3.position_qty > 0, { t: C2 } = Z$2(), { parseErrorMsg: y2 } = Tr$1(t.errors), D2 = y2("order_quantity"), k2 = y2("order_price"), Q2 = (T2) => {
    if (t.baseTick && t.baseTick > 0) {
      let G2 = utils_exports.formatNumber(T2, t.baseTick) ?? T2;
      t.updateQuantity(G2);
    }
  };
  return jsxs(Fragment$1, { children: [jsx(_e$5, { variant: "outlined", color: "secondary", size: "sm", className: "oui-border-base-contrast-36", onClick: () => {
    r3("limit"), i(true);
  }, children: C2("positions.limitClose") }), o && jsx(Yo$1, { title: C2("positions.limitClose"), open: o, onOpenChange: i, children: jsxs(z$1, { direction: "column", gap: 3, width: "100%", itemAlign: "start", className: "oui-text-sm", children: [jsxs(z$1, { width: "100%", justify: "between", children: [jsx($$4.formatted, { rule: "symbol", showIcon: true, children: e3.symbol }), jsxs(z$1, { gap: 1, children: [jsx(od, { color: "neutral", size: "xs", children: C2("orderEntry.orderType.limit") }), P2 && jsx(od, { color: "success", size: "xs", children: C2("common.buy") }), !P2 && jsx(od, { color: "danger", size: "xs", children: C2("common.sell") })] })] }), jsx(te$6, { className: "oui-w-full" }), jsxs(z$1, { width: "100%", justify: "between", children: [jsx($$4, { intensity: 54, children: C2("common.lastPrice") }), jsx($$4.numeral, { dp: (_b2 = (_a2 = t.item) == null ? void 0 : _a2.symbolInfo) == null ? void 0 : _b2.quote_dp, suffix: jsx($$4, { intensity: 36, children: " USDC" }), children: t.curMarkPrice })] }), jsxs(z$1, { width: "100%", direction: "column", gap: 2, children: [jsx(So$4.tooltip, { prefix: C2("common.price"), suffix: t.quote, align: "right", fullWidth: true, autoComplete: "off", formatters: [Xr$1.numberFormatter, Xr$1.dpFormatter(t.quote_dp)], triggerClassName: "oui-w-full", tooltip: k2, color: k2 ? "danger" : void 0, value: t.price, onValueChange: (T2) => t.updatePriceChange(T2), classNames: { prefix: "oui-text-base-contrast-54", suffix: "oui-text-base-contrast-54", root: cnBase("oui-outline-line-12 oui-w-full", k2 ? "oui-outline-danger" : void 0) } }), jsx(So$4, { prefix: C2("common.quantity"), suffix: t.base, align: "right", fullWidth: true, autoComplete: "off", formatters: [Xr$1.numberFormatter, Xr$1.dpFormatter(t.base_dp)], value: t.quantity, onBlur: (T2) => Q2(T2.target.value), onValueChange: (T2) => {
    t.updateQuantity(T2);
    let G2 = new g$6(T2).div(t.item.position_qty).mul(100).toDecimalPlaces(2, g$6.ROUND_DOWN).toNumber();
    t.setSliderValue(G2);
  }, classNames: { prefix: "oui-text-base-contrast-54", suffix: "oui-text-base-contrast-54", root: cnBase("oui-outline-line-12 oui-w-full") } }), jsx(Bl, { markCount: 4, value: [t.sliderValue], color: "primary", onValueChange: (T2) => {
    t.setSliderValue(T2[0]);
    let G2 = new g$6(T2[0]).div(100).mul(t.item.position_qty).toFixed(t.base_dp, g$6.ROUND_DOWN);
    Q2(G2);
  } }), jsxs(z$1, { width: "100%", justify: "between", children: [jsx($$4, { color: "primary", size: "2xs", children: `${t.sliderValue}%` }), jsxs(z$1, { gap: 1, children: [jsx($$4, { size: "2xs", color: "primary", children: C2("common.max") }), jsx($$4.numeral, { intensity: 54, size: "2xs", children: Math.abs(t.item.position_qty) })] })] })] }), jsxs(z$1, { width: "100%", gap: 3, mt: 2, children: [jsx(_e$5, { fullWidth: true, color: "secondary", onClick: (T2) => {
    c2();
  }, children: C2("common.cancel") }), jsx(dr$3, { fullWidth: true, disabled: b2, loading: b2, onClick: (T2) => {
    if (T2.stopPropagation(), T2.preventDefault(), D2 || k2) {
      toast$2.error(D2 ?? k2);
      return;
    }
    if (!t.orderConfirm) {
      d2();
      return;
    }
    n4(true);
  }, children: C2("common.confirm") })] })] }) }), s && jsx(me$4, { open: s, onOpenChange: n4, size: "xs", children: jsx(ne$3, { base: a2, quantity: l2, price: u2, onClose: f2, onConfirm: d2, submitting: b2, quoteDp: S2, order: m2, hideCloseIcon: true }) })] });
};
var xe$2 = (t) => {
  let { state: e3 } = t, [o, i] = useState(false), [s, n4] = useState(false), { onSubmit: r3, price: a2, quantity: l2, closeOrderData: u2, submitting: c2, type: d2, updatePriceChange: b2, updateOrderType: S2, updateQuantity: m2, errors: f2, baseTick: P2 } = O$1(), C2 = useRef(false), [y2, D2] = useState(100), [k2] = useLocalStorage("orderly_order_confirm", true), Q2 = () => r3().then((At3) => {
    i(false), n4(false);
  }, (At3) => {
    typeof At3 == "string" ? toast$2.error(At3) : toast$2.error(At3.message);
  }), T2 = () => {
    i(false);
  }, G2 = () => {
    n4(false);
  }, kt2 = useMarkPricesStream(), q2 = useMemo(() => {
    var _a2;
    return ((_a2 = kt2 == null ? void 0 : kt2.data) == null ? void 0 : _a2[e3.item.symbol]) ?? "--";
  }, [kt2]), { quote_dp: z2, base_dp: Li2, base: qi2, quote: Ni2 } = I$2();
  return useEffect(() => {
    !C2.current && q2 && o && (C2.current = true, S2(OrderType.LIMIT, `${q2}`));
  }, [C2, q2, o]), useEffect(() => {
    o || (S2(OrderType.MARKET), C2.current = false);
  }, [o]), { ...e3, sheetOpen: o, setSheetOpen: i, curMarkPrice: q2, quote_dp: z2, base_dp: Li2, base: qi2, quote: Ni2, baseTick: P2, orderConfirm: k2, onClose: T2, onConfirm: Q2, price: a2, quantity: l2, closeOrderData: u2, submitting: c2, updatePriceChange: b2, updateQuantity: m2, errors: f2, sliderValue: y2, setSliderValue: D2, dialogOpen: s, setDialogOpen: n4, onCloseDialog: G2 };
};
var be$3 = (t) => {
  let e3 = xe$2(t);
  return jsx(ye$4, { ...e3 });
};
var Ce$1 = (t) => {
  let { t: e3 } = Z$2();
  return jsxs(Fragment$1, { children: [jsx(_e$5, { variant: "outlined", color: "secondary", size: "sm", className: "oui-border-base-contrast-36", disabled: t.submitting, loading: t.submitting, onClick: (o) => {
    if (o.stopPropagation(), o.preventDefault(), t.updateOrderType(OrderType.MARKET), !t.orderConfirm) {
      t.onConfirm();
      return;
    }
    t.setDialogOpen(true);
  }, children: e3("positions.marketClose") }), jsx(me$4, { open: t.dialogOpen, onOpenChange: t.setDialogOpen, size: "xs", children: jsx(qt$2, { base: t.base, quantity: t.quantity, onClose: t.onClose, onConfirm: t.onConfirm, submitting: t.submitting, hideCloseIcon: true }) })] });
};
var Se$3 = (t) => {
  let e3 = I$2(), [o, i] = useState(false), { onSubmit: s, price: n4, quantity: r3, closeOrderData: a2, submitting: l2, type: u2, updatePriceChange: c2, updateOrderType: d2, updateQuantity: b2 } = O$1(), [S2] = useLocalStorage("orderly_order_confirm", true);
  return { ...t, ...e3, dialogOpen: o, setDialogOpen: i, orderConfirm: S2, onSubmit: s, quantity: r3, onClose: () => {
    i(false);
  }, onConfirm: () => s().then((P2) => {
    i(false);
  }, (P2) => {
    typeof P2 == "string" ? toast$2.error(P2) : toast$2.error(P2.message);
  }), submitting: l2, updateOrderType: d2, updateQuantity: b2 };
};
var he$3 = (t) => {
  let e3 = Se$3(t);
  return jsx(Ce$1, { ...e3 });
};
var _e$2 = (t) => {
  let { t: e3 } = Z$2();
  return jsx(_e$5, { variant: "outlined", color: "secondary", size: "sm", className: "oui-border-base-contrast-36", onClick: (o) => {
    o.stopPropagation(), o.preventDefault(), t.openTP_SL();
  }, children: e3("common.tpsl") });
};
var Te$1 = (t) => {
  let e3 = useSymbolsInfo()[t.state.item.symbol](), { tpslOrder: o } = O$1(), { t: i } = Z$2();
  return { openTP_SL: () => {
    uo$3.sheet({ title: i("common.tpsl"), content: jsx(Lt, { position: t.state.item, symbolInfo: e3, order: o, isEditing: false }) });
  }, ...t, ...e3 };
};
var we$3 = (t) => {
  let e3 = Te$1(t);
  return jsx(_e$2, { ...e3 });
};
var Fe$1 = (t) => {
  let { className: e3, ...o } = t;
  return jsxs(z$1, { direction: "column", width: "100%", gap: 2, p: 2, r: "xl", itemAlign: "start", className: cnBase(e3, "oui-bg-base-9"), children: [jsx(Ar$1, { ...o }), jsx(te$6, { intensity: 6, className: "oui-w-full" }), jsx(Hr$1, { ...o }), jsx($o$2, { ...o }), jsx(Rr, { ...o })] });
}, Ar$1 = (t) => jsxs(z$1, { justify: "between", width: "100%", children: [jsx(Ao$4, { ...t }), jsx(Ho$1, { ...t })] }), Hr$1 = (t) => jsxs(ia$1, { cols: 3, rows: 2, gap: 2, width: "100%", children: [jsx(Ro$2, { ...t }), jsx(zo, { ...t }), jsx(Eo$2, { ...t }), jsx(Wo$1, { ...t }), jsx(Uo$2, { ...t }), jsx(Qo$1, { ...t })] }), Rr = (t) => jsxs(ia$1, { width: "100%", gap: 2, cols: 3, rows: 1, children: [jsx(we$3, { state: t }), jsx(be$3, { state: t }), jsx(he$3, { state: t })] });
var De$2 = (t) => {
  let e3 = I$2();
  return { ...t, ...e3 };
};
var Le$3 = (t) => {
  let e3 = De$2(t);
  return jsx(Fe$1, { ...e3, className: t.className });
};
var ei$2 = (t) => {
  let { pnlNotionalDecimalPrecision: e3, sharePnLConfig: o, pagination: i } = t, s = ko$3({ pnlNotionalDecimalPrecision: e3, sharePnLConfig: o, onSymbolChange: t.onSymbolChange });
  return jsx(dt$3, { loading: t.isLoading, id: "oui-desktop-positions-content", columns: s, bordered: true, dataSource: t.dataSource, generatedRowKey: (n4) => n4.symbol, renderRowContainer: (n4, r3, a2) => jsx(Pt$2, { symbol: n4.symbol, children: jsx(oe, { position: n4, children: a2 }) }), manualPagination: false, pagination: i, testIds: { body: "oui-testid-dataList-position-tab-body" } });
}, oi$2 = (t) => {
  let { pnlNotionalDecimalPrecision: e3, sharePnLConfig: o } = t;
  return jsx(gf, { className: "oui-w-full oui-hide-scrollbar oui-overflow-y-hidden oui-space-y-0", contentClassName: "!oui-space-y-1", dataSource: t.dataSource, renderItem: (i, s) => jsx(Pt$2, { symbol: i.symbol, children: jsx(oe, { position: i, children: jsx(Le$3, { item: i, index: s, pnlNotionalDecimalPrecision: e3, sharePnLConfig: o, onSymbolChange: t.onSymbolChange }) }) }) });
};
var qe$2 = (t) => {
  let { symbol: e3, calcMode: o, includedPendingOrder: i, pnlNotionalDecimalPrecision: s, sharePnLConfig: n4, onSymbolChange: r3 } = t, { pagination: a2, setPage: l2 } = mm({ pageSize: 50 }), [u2, c2, { isLoading: d2 }] = usePositionStream(e3, { calcMode: o, includedPendingOrder: i });
  return useEffect(() => {
    l2(1);
  }, [e3]), { dataSource: xr$2(u2 == null ? void 0 : u2.rows, { fallbackData: [] }) ?? void 0, isLoading: d2, pnlNotionalDecimalPrecision: s, sharePnLConfig: n4, symbol: e3, onSymbolChange: r3, pagination: a2 };
};
var Gr$2 = (t) => {
  let e3 = qe$2(t);
  return jsx(ei$2, { ...e3 });
}, Kr$1 = (t) => {
  let e3 = qe$2(t);
  return jsx(oi$2, { ...e3 });
};
var si$1 = (t) => {
  let { onSymbolChange: e3, pnlNotionalDecimalPrecision: o } = t, { t: i } = Z$2();
  return useMemo(() => [{ title: i("common.symbol"), dataIndex: "symbol", fixed: "left", width: 200, onSort: (n4, r3) => n4.symbol.localeCompare(r3.symbol), render: (n4, r3) => jsx(jr$1, { record: r3, onSymbolChange: e3 }) }, { title: i("positions.history.column.closed&maxClosed"), dataIndex: "close_maxClose", width: 200, render: (n4, r3) => jsx(ts, { record: r3 }) }, { title: i("positions.history.column.netPnl"), dataIndex: "netPnL", width: 140, onSort: (n4, r3) => n4.netPnL == null || r3.netPnL == null ? -1 : (n4.netPnL ?? 0) - (r3.netPnL ?? 0), render: (n4, r3) => jsxs(z$1, { gapX: 1, children: [jsx(es$1, { record: r3, pnlNotionalDecimalPrecision: o }), jsx(Z2, { position: r3, sharePnLConfig: t.sharePnLConfig, modalId: jt$4, isPositionHistory: true })] }) }, { title: i("common.avgOpen"), dataIndex: "avg_open", width: 140, render: (n4, r3) => {
    let a2 = r3.avg_open_price != null ? Math.abs(r3.avg_open_price) : "--", { quote_dp: l2 } = I$2();
    return jsx($$4.numeral, { dp: l2, padding: false, children: a2 });
  } }, { title: i("common.avgClose"), dataIndex: "avg_close", width: 175, render: (n4, r3) => {
    let a2 = r3.avg_close_price != null ? Math.abs(r3.avg_close_price) : "--", { quote_dp: l2 } = I$2();
    return jsx($$4.numeral, { dp: l2, padding: false, children: a2 });
  } }, { title: i("positions.history.column.timeOpened"), dataIndex: "open_timestamp", width: 175, onSort: true, render: (n4, r3) => jsx($$4.formatted, { rule: "date", formatString: "yyyy-MM-dd HH:mm:ss", children: r3.open_timestamp }) }, { title: i("positions.history.column.timeClosed"), dataIndex: "close_timestamp", width: 175, onSort: true, render: (n4, r3) => r3.position_status == "closed" && r3.close_timestamp ? jsx($$4.formatted, { rule: "date", formatString: "yyyy-MM-dd HH:mm:ss", children: r3.close_timestamp ?? "--" }) : "--" }, { title: i("positions.history.column.updatedTime"), dataIndex: "last_update_time", width: 175, onSort: true, render: (n4, r3) => jsx($$4.formatted, { rule: "date", formatString: "yyyy-MM-dd HH:mm:ss", children: r3.last_update_time }) }], [o, i]);
}, jr$1 = (t) => {
  let { record: e3, onSymbolChange: o } = t, { t: i } = Z$2(), s = useMemo(() => {
    let n4 = [], r3 = e3.position_status, a2 = () => r3 === "closed" ? i("positions.history.status.closed") : r3 === "partial_closed" ? i("positions.history.status.partialClosed") : Ef(r3.replace("_", " "));
    return n4.push(jsx(od, { color: r3 !== "closed" ? "primaryLight" : "neutral", size: "xs", className: "oui-break-normal oui-whitespace-nowrap", children: a2() })), e3.type === "adl" ? n4.push(jsx(od, { color: "danger", size: "xs", children: i("positions.history.type.adl") })) : e3.type === "liquidated" && n4.push(jsx(Xn$2, { className: "oui-min-w-[204px] oui-bg-base-5", arrow: { className: "oui-fill-base-5" }, content: jsxs(z$1, { direction: "column", itemAlign: "start", className: "oui-text-2xs", children: [e3.liquidation_id != null && jsxs(z$1, { justify: "between", width: "100%", gap: 2, children: [jsx($$4, { intensity: 54, children: i("positions.history.liquidated.liquidationId") }), jsx($$4, { intensity: 98, children: e3.liquidation_id })] }), jsxs(z$1, { justify: "between", width: "100%", gap: 2, children: [jsx($$4, { intensity: 54, children: i("positions.history.liquidated.liquidatorFee") }), jsxs($$4, { color: "lose", children: [e3.liquidator_fee > 0 && "-", $$5(e3.liquidator_fee)] })] }), jsxs(z$1, { justify: "between", width: "100%", gap: 2, children: [jsx($$4, { intensity: 54, children: i("positions.history.liquidated.insFundFee") }), jsxs($$4, { color: "lose", children: [e3.insurance_fund_fee > 0 && "-", $$5(e3.insurance_fund_fee)] })] })] }), children: jsx("div", { children: jsx(od, { size: "xs", color: "danger", className: "oui-cursor-pointer", children: jsx("span", { className: "oui-underline oui-decoration-dashed oui-decoration-[1px]", children: i("positions.history.type.liquidated") }) }) }) })), n4;
  }, [e3, i]);
  return jsxs(z$1, { gap: 2, height: 48, children: [jsx(_$1, { width: 4, height: 38, className: cnBase("oui-rounded-[1px] oui-shrink-0", e3.side === "LONG" ? "oui-bg-trade-profit" : "oui-bg-trade-loss") }), jsxs(z$1, { direction: "column", itemAlign: "start", children: [jsx($$4.formatted, { formatString: "base-type", className: "oui-cursor-pointer", onClick: (n4) => {
    o == null ? void 0 : o({ symbol: e3.symbol }), n4.stopPropagation(), n4.preventDefault();
  }, children: `${e3.symbol.split("_")[1]}-PERP` }), jsx(z$1, { gap: 1, children: s })] })] });
}, ts = (t) => {
  let { record: e3 } = t, { base_dp: o } = I$2();
  return jsxs(z$1, { gap: 1, direction: "column", itemAlign: "start", className: "oui-overflow-hidden oui-whitespace-nowrap oui-text-ellipsis", children: [jsx($$4.numeral, { dp: o, padding: false, children: Math.abs(e3.closed_position_qty) }), jsx($$4.numeral, { dp: o, padding: false, className: "oui-truncate", children: Math.abs(e3.max_position_qty) })] });
}, es$1 = (t) => {
  let { record: e3, pnlNotionalDecimalPrecision: o } = t, { t: i } = Z$2(), s = e3.netPnL != null ? e3.netPnL : void 0, n4 = () => jsx($$4.numeral, { dp: o, color: e3.netPnL != null ? e3.netPnL > 0 ? "profit" : "lose" : void 0, className: s == null ? "" : "oui-cursor-pointer oui-border-b oui-border-dashed oui-border-line-12", children: s ?? "--" });
  return e3.netPnL == null ? n4() : jsx(Xn$2, { delayDuration: 200, content: jsxs(z$1, { direction: "column", itemAlign: "start", className: "oui-text-2xs", children: [jsx($$4, { intensity: 80, children: i("positions.history.column.netPnl") }), jsxs(z$1, { justify: "between", width: "100%", gap: 2, children: [jsx($$4, { intensity: 54, children: i("common.realizedPnl") }), jsx($$4, { color: e3.realized_pnl >= 0 ? "profit" : "lose", className: "oui-cursor-pointer", children: $$5(e3.realized_pnl) })] }), jsxs(z$1, { justify: "between", width: "100%", gap: 2, children: [jsx($$4, { intensity: 54, children: i("positions.history.netPnl.fundingFee") }), jsx($$4, { color: e3.accumulated_funding_fee > 0 ? "lose" : "profit", className: "oui-cursor-pointer", children: $$5(-e3.accumulated_funding_fee) })] }), jsxs(z$1, { justify: "between", width: "100%", gap: 2, children: [jsx($$4, { intensity: 54, children: i("positions.history.netPnl.tradingFee") }), jsx($$4, { color: e3.trading_fee > 0 ? "lose" : "profit", className: "oui-cursor-pointer", children: $$5(-e3.trading_fee) })] })] }), className: "oui-min-w-[204px] oui-bg-base-5", arrow: { className: "oui-fill-base-5" }, children: jsx("div", { children: n4() }) });
};
function B$1(t) {
  if (t == null) return t;
  let e3 = new Date(t);
  return e3.setHours(0, 0, 0, 0), e3;
}
function M(t) {
  if (t == null) return t;
  let e3 = new Date(t);
  return e3.setHours(23, 59, 59, 999), e3;
}
var St$1 = (t) => ({ from: B$1(t.from), to: M(t.to ?? t.from) }), ht$1 = (t, e3) => t.getTime() === e3.getTime();
var Gt$2 = (t) => {
  let { onSymbolChange: e3, symbol: o, pnlNotionalDecimalPrecision: i } = t, { state: s } = useAccount(), { data: n4, isLoading: r3 } = usePrivateQuery(o ? `/v1/position_history?symbol=${o}&limit=1000` : "/v1/position_history?limit=1000", { formatter(y2) {
    var _a2;
    return (_a2 = y2.rows ?? null) == null ? void 0 : _a2.map((D2) => {
      if (D2.realized_pnl != null && D2.accumulated_funding_fee != null && D2.trading_fee != null) {
        let k2 = D2.realized_pnl - D2.accumulated_funding_fee - D2.trading_fee;
        return { ...D2, netPnL: k2 };
      }
      return D2;
    });
  }, revalidateOnFocus: true }), { pagination: a2, setPage: l2 } = mm({ pageSize: 10 }), { status: u2, side: c2, dateRange: d2, filterDays: b2, updateFilterDays: S2, filterItems: m2, onFilter: f2 } = us();
  useEffect(() => {
    l2(1);
  }, [u2, c2, d2, b2, o]);
  let P2 = useMemo(() => n4 == null ? n4 : n4.filter((y2) => {
    let D2 = c2 === "all" ? true : y2.side.toLowerCase() === c2.toLowerCase(), k2 = u2 === "all" ? true : y2.position_status.toLowerCase() === u2.toLowerCase(), Q2 = (y2 == null ? void 0 : y2.last_update_time) ?? y2.open_timestamp, T2 = d2.from && d2.to ? Q2 >= d2.from.getTime() && Q2 <= d2.to.getTime() : true, G2 = o ? y2.symbol == o : true;
    return D2 && k2 && T2 && G2;
  }), [u2, c2, d2, n4, o]);
  return { dataSource: xr$2(P2, { accountStatus: s.status === AccountStatusEnum.EnableTradingWithoutConnected ? AccountStatusEnum.EnableTradingWithoutConnected : AccountStatusEnum.EnableTrading, fallbackData: [] }), isLoading: r3, onSymbolChange: e3, pagination: a2, filterItems: m2, onFilter: f2, symbol: o, filterDays: b2, updateFilterDays: S2, pnlNotionalDecimalPrecision: i };
}, us = () => {
  let { t } = Z$2(), [e3, o] = useState("all"), [i, s] = useState("all"), n4 = St$1({ to: M(/* @__PURE__ */ new Date()), from: B$1(subDays(/* @__PURE__ */ new Date(), 89)) }), [r3, a2] = useState(90), [l2, u2] = useState(n4), c2 = (m2) => {
    a2(m2), u2({ from: B$1(subDays(/* @__PURE__ */ new Date(), m2 - 1)), to: M(/* @__PURE__ */ new Date()) });
  }, d2 = (m2) => {
    if (m2.name === "side" && s(m2.value), m2.name === "status" && o(m2.value), m2.name === "dateRange") {
      let f2 = St$1(m2.value);
      if (u2(f2), f2.from && f2.to) {
        let P2 = Math.abs(differenceInDays(f2.from, f2.to)) + 1, y2 = { 1: { from: B$1(/* @__PURE__ */ new Date()), to: M(/* @__PURE__ */ new Date()) }, 7: { from: B$1(subDays(/* @__PURE__ */ new Date(), 6)), to: M(/* @__PURE__ */ new Date()) }, 30: { from: B$1(subDays(/* @__PURE__ */ new Date(), 29)), to: M(/* @__PURE__ */ new Date()) }, 90: { from: B$1(subDays(/* @__PURE__ */ new Date(), 89)), to: M(/* @__PURE__ */ new Date()) } }[P2];
        y2 && ht$1(y2.from, f2.from) && ht$1(y2.to, f2.to) ? a2(P2) : a2(null);
      }
    }
  }, { isMobile: b2 } = Ao$6();
  return { filterItems: useMemo(() => {
    let m2 = { type: "select", name: "side", options: [{ label: t("common.side.all"), value: "all" }, { label: t("common.buy"), value: "LONG" }, { label: t("common.sell"), value: "SHORT" }], value: i }, f2 = { type: "range", name: "dateRange", value: l2, fromDate: B$1(subDays(/* @__PURE__ */ new Date(), 89)), toDate: M(/* @__PURE__ */ new Date()) }, P2 = { type: "select", name: "status", options: [{ label: t("common.status.all"), value: "all" }, { label: t("positions.history.status.closed"), value: "closed" }, { label: t("positions.history.status.partialClosed"), value: "partial_closed" }], value: e3 };
    return b2 ? [m2, P2] : [m2, P2, f2];
  }, [i, e3, l2]), onFilter: d2, side: i, dateRange: l2, status: e3, filterDays: r3, updateFilterDays: c2 };
};
var mi$1 = (t) => {
  let { side: e3, symbol: o } = t.item, { t: i } = Z$2(), s = e3 === "LONG";
  return jsx($$4.formatted, { intensity: 80, rule: "symbol", formatString: "base-type", size: "sm", prefix: jsx(od, { color: s ? "success" : "danger", size: "xs", children: i(s ? "common.buy" : "common.sell") }), onClick: () => {
    var _a2;
    (_a2 = t.onSymbolChange) == null ? void 0 : _a2.call(t, { symbol: o });
  }, children: o });
};
var ui$1 = (t) => {
  let { item: e3 } = t, { t: o } = Z$2(), i = () => {
    uo$3.alert({ title: o("positions.liquidation"), message: jsxs(z$1, { direction: "column", width: "100%", gap: 2, className: "oui-text-2xs oui-text-base-contrast-54", children: [e3.liquidation_id != null && jsxs(z$1, { justify: "between", width: "100%", children: [jsx($$4, { children: o("positions.history.liquidated.liquidationId") }), jsx($$4, { intensity: 98, children: e3.liquidation_id })] }), jsxs(z$1, { justify: "between", width: "100%", children: [jsx($$4, { children: o("positions.history.liquidated.liquidatorFee") }), jsxs($$4, { color: "lose", children: [e3.liquidator_fee > 0 && "-", $$5(e3.liquidator_fee)] })] }), jsxs(z$1, { justify: "between", width: "100%", children: [jsx($$4, { children: o("positions.history.liquidated.insFundFee") }), jsxs($$4, { color: "lose", children: [e3.insurance_fund_fee > 0 && "-", $$5(e3.insurance_fund_fee)] })] })] }) });
  }, s = useMemo(() => {
    let n4 = [], r3 = e3.position_status, a2 = () => r3 === "closed" ? o("positions.history.status.closed") : r3 === "partial_closed" ? o("positions.history.status.partialClosed") : Ef(r3.replace("_", " "));
    return n4.push(jsx(od, { color: r3 !== "closed" ? "primaryLight" : "neutral", size: "xs", children: a2() })), e3.type === "adl" ? n4.push(jsx(od, { color: "danger", size: "xs", children: o("positions.history.type.adl") })) : e3.type === "liquidated" && n4.push(jsx(od, { size: "xs", color: "danger", className: "oui-cursor-pointer", onClick: i, children: jsx("span", { className: "oui-underline oui-decoration-dashed oui-decoration-[1px]", children: o("positions.history.type.liquidated") }) })), n4;
  }, [e3]);
  return jsx(z$1, { gap: 1, children: s });
}, ci$2 = (t) => {
  let { item: e3 } = t, { t: o } = Z$2(), i = e3.closed_position_qty != null ? Math.abs(e3.closed_position_qty) : "--";
  return jsx(da$2, { label: jsx($$4, { children: o("positions.history.column.closed") }), classNames: { root: "oui-text-xs", label: "oui-text-2xs" }, children: jsx($$4.numeral, { dp: t.base_dp, padding: false, coloring: true, intensity: 80, children: i }) });
}, di = (t) => {
  let { item: e3 } = t, { t: o } = Z$2(), i = e3.max_position_qty != null ? Math.abs(e3.max_position_qty) : "--";
  return jsx(da$2, { label: jsx($$4, { children: o("positions.history.column.maxClosed") }), classNames: { root: "oui-text-xs", label: "oui-text-2xs" }, children: jsx($$4.numeral, { dp: t.base_dp, padding: false, coloring: true, intensity: 80, children: i }) });
}, pi = (t) => {
  let { item: e3 } = t, o = e3.avg_open_price != null ? Math.abs(e3.avg_open_price) : "--", { t: i } = Z$2();
  return jsx(da$2, { label: jsxs(z$1, { gap: 1, children: [i("common.avgOpen"), jsx($$4, { intensity: 20, children: "(USDC)" })] }), classNames: { root: "oui-text-xs", label: "oui-text-2xs" }, children: jsx($$4.numeral, { dp: t.quote_dp, padding: false, coloring: true, intensity: 80, children: o }) });
}, fi$1 = (t) => {
  let { item: e3 } = t, o = e3.avg_close_price != null ? Math.abs(e3.avg_close_price) : "--", { t: i } = Z$2();
  return jsx(da$2, { label: jsxs(z$1, { gap: 1, children: [i("common.avgClose"), jsx($$4, { intensity: 20, children: "(USDC)" })] }), classNames: { root: "oui-text-xs", label: "oui-text-2xs" }, children: jsx($$4.numeral, { dp: t.quote_dp, padding: false, coloring: true, intensity: 80, children: o }) });
}, yi$4 = (t) => {
  let { item: e3 } = t, { t: o } = Z$2();
  return jsx(da$2, { label: jsx($$4, { children: o("positions.history.column.timeOpened") }), classNames: { root: "oui-text-xs", label: "oui-text-2xs" }, align: "end", children: jsx($$4.formatted, { intensity: 80, formatString: "yyyy-MM-dd HH:mm:ss", rule: "date", children: e3.open_timestamp }) });
}, gi$1 = (t) => {
  let { item: e3 } = t, { t: o } = Z$2(), i = e3.position_status == "closed" && e3.close_timestamp ? jsx($$4.formatted, { intensity: 80, formatString: "yyyy-MM-dd HH:mm:ss", rule: "date", children: e3.close_timestamp }) : "--";
  return jsx(da$2, { label: jsx($$4, { children: o("positions.history.column.timeClosed") }), classNames: { root: "oui-text-xs", label: "oui-text-2xs" }, align: "end", children: i });
};
var Be$3 = (t) => {
  var _a2;
  return jsxs(z$1, { direction: "column", width: "100%", gap: 2, itemAlign: "start", className: (_a2 = t.classNames) == null ? void 0 : _a2.root, children: [jsx(Ps$1, { ...t }), jsx(te$6, { intensity: 6, className: "oui-w-full" }), jsx(Cs, { ...t })] });
}, Ps$1 = (t) => {
  let { t: e3 } = Z$2(), o = () => {
    let { item: i } = t;
    uo$3.alert({ title: e3("positions.history.column.netPnl"), message: jsxs(z$1, { direction: "column", width: "100%", gap: 2, className: "oui-text-2xs oui-text-base-contrast-54", children: [jsxs(z$1, { justify: "between", width: "100%", gap: 2, children: [jsx($$4, { intensity: 54, children: e3("common.realizedPnl") }), jsx($$4, { color: i.realized_pnl >= 0 ? "profit" : "lose", children: $$5(i.realized_pnl) })] }), jsxs(z$1, { justify: "between", width: "100%", gap: 2, children: [jsx($$4, { intensity: 54, children: e3("positions.history.netPnl.fundingFee") }), jsx($$4, { color: i.accumulated_funding_fee > 0 ? "lose" : "profit", children: $$5(-i.accumulated_funding_fee) })] }), jsxs(z$1, { justify: "between", width: "100%", gap: 2, children: [jsx($$4, { intensity: 54, children: e3("positions.history.netPnl.tradingFee") }), jsx($$4, { color: i.trading_fee > 0 ? "lose" : "profit", children: $$5(-i.trading_fee) })] })] }) });
  };
  return jsxs(z$1, { gap: 1, width: "100%", children: [jsxs(z$1, { direction: "column", itemAlign: "start", className: "oui-flex-1", gap: 1, children: [jsx(mi$1, { ...t }), jsx(ui$1, { ...t })] }), jsxs(z$1, { direction: "column", itemAlign: "end", className: "oui-flex-1", children: [jsx($$4, { size: "2xs", intensity: 36, children: e3("positions.history.column.netPnl") }), jsxs(z$1, { gapX: 1, children: [jsx("button", { onClick: o, children: jsx($$4.numeral, { size: "xs", coloring: true, children: t.item.netPnL ?? "--" }) }), jsx(Z2, { position: t.item, sharePnLConfig: t.sharePnLConfig, modalId: eo$3, iconSize: 12, isPositionHistory: true })] })] })] });
}, Cs = (t) => jsxs(ia$1, { cols: 3, rows: 2, width: "100%", gap: 0, className: "oui-grid-cols-[1fr,1fr,135px]", children: [jsx(ci$2, { ...t }), jsx(di, { ...t }), jsx(yi$4, { ...t }), jsx(pi, { ...t }), jsx(fi$1, { ...t }), jsx(gi$1, { ...t })] });
var Me$3 = (t) => {
  let e3 = I$2();
  return { ...t, ...e3 };
};
var ke = (t) => {
  let e3 = Me$3(t);
  return jsx(Be$3, { ...e3 });
};
var Re$3 = (t) => {
  let { onSymbolChange: e3, pagination: o, pnlNotionalDecimalPrecision: i } = t, s = si$1({ onSymbolChange: e3, pnlNotionalDecimalPrecision: i, sharePnLConfig: t.sharePnLConfig }), { t: n4 } = Z$2(), r3 = useMemo(() => ({ 1: n4("common.select.1d"), 7: n4("common.select.7d"), 30: n4("common.select.30d"), 90: n4("common.select.90d") }), [n4]);
  return jsxs(z$1, { direction: "column", width: "100%", height: "100%", itemAlign: "start", children: [jsxs(z$1, { gap: 3, children: [t.filterItems.length > 0 && jsx(lm, { items: t.filterItems, onFilter: (a2) => {
    t.onFilter(a2);
  } }), [1, 7, 30, 90].map((a2) => jsxs("button", { className: "oui-relative oui-px-2 oui-py-[2px] oui-text-sm", children: [jsx("div", { className: "oui-z-10", children: jsx($$4.gradient, { color: t.filterDays === a2 ? "brand" : void 0, className: cnBase("oui-break-normal oui-whitespace-nowrap", t.filterDays !== a2 ? "oui-text-base-contrast-54" : ""), children: r3[a2] || `${a2}D` }) }), jsx("div", { className: "oui-gradient-primary oui-opacity-[.12] oui-absolute oui-left-0 oui-right-0 oui-top-0 oui-bottom-0 oui-rounded", onClick: () => {
    t.updateFilterDays(a2);
  } })] }))] }), jsx(dt$3, { loading: t.isLoading, id: "oui-desktop-positions-content", columns: s, bordered: true, dataSource: t.dataSource, generatedRowKey: (a2) => `${a2.symbol}_${a2.position_id}`, renderRowContainer: (a2, l2, u2) => jsx(Pt$2, { symbol: a2.symbol, children: u2 }), manualPagination: false, pagination: o, testIds: { body: "oui-testid-dataList-positionHistory-tab-body" }, classNames: { root: "!oui-h-[calc(100%_-_49px)]" } })] });
}, ze$4 = (t) => {
  var _a2, _b2;
  return jsxs(ia$1, { cols: 1, rows: 2, className: "oui-grid-rows-[auto,1fr] oui-w-full", gap: 1, children: [jsx(z$1, { gap: 2, p: 2, className: "oui-bg-base-9 oui-rounded-b-xl", children: jsx(lm, { className: "oui-pt-0 oui-pb-0 oui-border-none", items: t.filterItems, onFilter: (e3) => {
    t.onFilter(e3);
  } }) }), jsx(gf, { className: cnBase("oui-w-full oui-hide-scrollbar oui-overflow-y-hidden oui-space-y-0", (_a2 = t.classNames) == null ? void 0 : _a2.root), contentClassName: cnBase("!oui-space-y-1", (_b2 = t.classNames) == null ? void 0 : _b2.content), dataSource: t.dataSource, renderItem: (e3, o) => {
    var _a3;
    return jsx(Pt$2, { symbol: e3.symbol, children: jsx(ke, { item: e3, index: o, onSymbolChange: t.onSymbolChange, classNames: { root: (_a3 = t.classNames) == null ? void 0 : _a3.cell }, sharePnLConfig: t.sharePnLConfig }) });
  } })] });
};
var Ls = (t) => {
  let e3 = Gt$2(t);
  return jsx(Re$3, { ...e3, sharePnLConfig: t.sharePnLConfig });
}, qs = (t) => {
  let { classNames: e3, ...o } = t, i = Gt$2(o);
  return jsx(ze$4, { ...i, classNames: e3, sharePnLConfig: t.sharePnLConfig });
};
var Ci$2 = (t) => {
  let { t: e3 } = Z$2();
  return useMemo(() => [{ title: e3("common.time"), dataIndex: "timestamp", fixed: "left", width: 202, render: (i) => jsx($$4.formatted, { rule: "date", formatString: "yyyy-MM-dd HH:mm:ss", children: i }) }, { title: e3("positions.Liquidation.column.liquidationId"), dataIndex: "liquidation_id", width: 202, render: (i) => jsx($$4, { children: i }) }, { title: e3("positions.Liquidation.column.insFundTransfer"), dataIndex: "transfer_amount_to_insurance_fund", width: 202, render: (i) => jsx($$4, { children: $$5(i) }) }, { title: e3("common.symbol"), dataIndex: "Symbol", width: 202, render: (i, s) => {
    var _a2;
    return jsx(z$1, { direction: "column", itemAlign: "start", children: (_a2 = s.positions_by_perp) == null ? void 0 : _a2.map((n4) => jsx($$4.formatted, { rule: "symbol", formatString: "base-quote", children: n4.symbol })) });
  } }, { title: `${e3("common.price")} (USDC)`, dataIndex: "Price_(USDC)", width: 202, render: (i, s) => {
    var _a2;
    return jsx(z$1, { direction: "column", itemAlign: "start", children: (_a2 = s.positions_by_perp) == null ? void 0 : _a2.map((n4) => jsx(Ee$2, { value: n4.transfer_price, type: "quote" })) });
  } }, { title: e3("common.quantity"), dataIndex: "Quantity", width: 202, render: (i, s) => {
    var _a2;
    return jsx(z$1, { direction: "column", itemAlign: "start", children: (_a2 = s.positions_by_perp) == null ? void 0 : _a2.map((n4) => jsx(Ee$2, { value: n4.position_qty, type: "base" })) });
  } }, { title: e3("positions.Liquidation.column.liquidationFee"), dataIndex: "abs_liquidation_fee", width: 202, render: (i, s) => {
    var _a2;
    return jsx(z$1, { direction: "column", itemAlign: "start", children: (_a2 = s.positions_by_perp) == null ? void 0 : _a2.map((n4) => jsx(Ee$2, { value: n4.abs_liquidation_fee, type: "quote" })) });
  } }], [e3]);
}, Ee$2 = (t) => jsx($$4, { children: $$5(t.value) });
var Si$2 = (t) => {
  let { t: e3 } = Z$2();
  return jsxs(z$1, { width: "100%", justify: "between", children: [jsxs(z$1, { gap: 1, children: [jsx($$4, { size: "2xs", intensity: 36, children: e3("common.price") }), jsx($$4, { size: "2xs", intensity: 20, children: "(USDC)" })] }), jsx($$4, { size: "2xs", intensity: 80, children: $$5(t.transfer_price) })] });
}, hi$1 = (t) => {
  let { t: e3 } = Z$2();
  return jsxs(z$1, { width: "100%", justify: "between", children: [jsx($$4, { size: "2xs", intensity: 36, children: e3("common.quantity") }), jsx($$4, { size: "2xs", intensity: 80, children: $$5(t.position_qty) })] });
}, _i$2 = (t) => {
  let { t: e3 } = Z$2();
  return jsxs(z$1, { width: "100%", justify: "between", children: [jsx($$4, { size: "2xs", intensity: 36, children: e3("positions.Liquidation.column.liquidationFee") }), jsx($$4, { size: "2xs", intensity: 80, children: $$5(t.abs_liquidation_fee) })] });
};
var Qe$2 = (t) => {
  var _a2;
  return jsxs(z$1, { direction: "column", width: "100%", gap: 2, itemAlign: "start", className: (_a2 = t.classNames) == null ? void 0 : _a2.root, children: [jsx(ks$1, { ...t }), jsx(As$1, { ...t })] }, t.item.timestamp);
}, ks$1 = (t) => {
  let { t: e3 } = Z$2();
  return jsxs(z$1, { gap: 1, width: "100%", children: [jsxs(z$1, { direction: "column", itemAlign: "start", className: "oui-flex-1", gap: 1, children: [jsx($$4.formatted, { size: "2xs", intensity: 36, rule: "date", formatString: "yyyy-MM-dd HH:mm:ss", children: t.item.timestamp }), jsxs(z$1, { gap: 1, children: [jsx($$4, { size: "2xs", intensity: 36, children: `${e3("positions.Liquidation.column.liquidationId")}:` }), jsx($$4, { size: "2xs", intensity: 80, children: ` ${t.item.liquidation_id}` })] })] }), jsxs(z$1, { direction: "column", itemAlign: "end", className: "oui-flex-1", children: [jsx($$4, { size: "2xs", intensity: 36, children: `${e3("positions.Liquidation.column.insFundTransfer")}:` }), jsx($$4, { intensity: 80, size: "xs", children: $$5(t.item.transfer_amount_to_insurance_fund) })] })] });
}, As$1 = (t) => {
  var _a2;
  return jsx(z$1, { direction: "column", width: "100%", children: (_a2 = t.item.positions_by_perp) == null ? void 0 : _a2.map((e3, o) => jsx(Hs, { isLast: o === t.item.positions_by_perp.length - 1, ...e3 }, `${o}-${e3.symbol}`)) });
}, Hs = (t) => jsxs(z$1, { width: "100%", itemAlign: "start", className: cnBase("oui-border-t-[1px] oui-border-line-6 oui-pt-2", !t.isLast && "oui-pb-2"), children: [jsx($$4.formatted, { rule: "symbol", formatString: "base-quote", size: "xs", intensity: 80, className: "oui-flex-1", children: t.symbol }), jsxs(ia$1, { cols: 1, rows: 3, width: "100%", gap: 1, className: "oui-flex-1", children: [jsx(Si$2, { ...t }), jsx(hi$1, { ...t }), jsx(_i$2, { ...t })] })] }, t.key);
var $e$3 = (t) => ({ ...t });
var Ve$1 = (t) => {
  let { classNames: e3, ...o } = t, i = $e$3(o);
  return jsx(Qe$2, { classNames: e3, ...i });
};
var Ke$1 = (t) => {
  let e3 = Ci$2();
  return jsxs(z$1, { direction: "column", width: "100%", height: "100%", itemAlign: "start", children: [jsxs(z$1, { gap: 3, children: [t.filterItems.length > 0 && jsx(lm, { items: t.filterItems, onFilter: (o) => {
    t.onFilter(o);
  } }), [1, 7, 30, 90].map((o) => jsxs("button", { className: "oui-relative oui-px-2 oui-py-[2px] oui-text-sm", children: [jsx("div", { className: "oui-z-10", children: jsx($$4.gradient, { color: t.filterDays === o ? "brand" : void 0, className: t.filterDays !== o ? "oui-text-base-contrast-54" : "", children: `${o}D` }) }), jsx("div", { className: "oui-gradient-primary oui-opacity-[.12] oui-absolute oui-left-0 oui-right-0 oui-top-0 oui-bottom-0 oui-rounded", onClick: () => {
    t.updateFilterDays(o);
  } })] }))] }), jsx(dt$3, { loading: t.isLoading, id: "oui-desktop-liquidation-content", columns: e3, bordered: true, dataSource: t.dataSource, generatedRowKey: (o) => `${o.liquidation_id}`, pagination: t.pagination, testIds: { body: "oui-testid-dataList-liquidation-tab-body" }, classNames: { root: "!oui-h-[calc(100%_-_49px)]" } })] });
}, Xe$2 = (t) => {
  var _a2, _b2;
  return jsxs(ia$1, { cols: 1, rows: 2, className: "oui-grid-rows-[auto,1fr] oui-w-full", gap: 1, children: [jsx(z$1, { gap: 2, p: 2, className: "oui-bg-base-9 oui-rounded-b-xl", children: jsx(lm, { className: "oui-pt-0 oui-pb-0 oui-border-none", items: t.filterItems, onFilter: (e3) => {
    t.onFilter(e3);
  } }) }), jsx(gf, { className: cnBase("oui-w-full oui-hide-scrollbar oui-overflow-y-hidden oui-space-y-0", (_a2 = t.classNames) == null ? void 0 : _a2.root), contentClassName: cnBase("!oui-space-y-1", (_b2 = t.classNames) == null ? void 0 : _b2.content), dataSource: t.dataSource, loadMore: t.loadMore, renderItem: (e3, o) => {
    var _a3;
    return jsx(Ve$1, { item: e3, index: o, classNames: { root: (_a3 = t.classNames) == null ? void 0 : _a3.cell } });
  } })] });
};
var te$2 = (t) => {
  let { symbol: e3, enableLoadMore: o } = t, { page: i, pageSize: s, setPage: n4, parsePagination: a2 } = mm({ pageSize: 10 }), { dateRange: l2, filterDays: u2, updateFilterDays: c2, filterItems: d2, onFilter: b2 } = Js();
  useEffect(() => {
    n4(1);
  }, [e3, l2, u2]);
  let [S2, { meta: m2, isLoading: f2, loadMore: P2 }] = Ys({ page: o ? void 0 : i, size: s, symbol: e3, start_t: l2.from != null ? l2.from.getTime() : void 0, end_t: l2.to != null ? l2.to.getTime() : void 0 });
  return { dataSource: xr$2(S2, { fallbackData: [] }), isLoading: f2, loadMore: P2, pagination: a2(m2), dateRange: l2, filterDays: u2, updateFilterDays: c2, filterItems: d2, onFilter: b2 };
}, Ys = (t) => {
  var _a2;
  let e3 = usePrivateInfiniteQuery(Zs(t), { initialSize: 1, formatter: (r3) => r3, revalidateOnFocus: true }), o = useMemo(() => {
    var _a3, _b2;
    return (_b2 = (_a3 = e3.data) == null ? void 0 : _a3[0]) == null ? void 0 : _b2.meta;
  }, [(_a2 = e3.data) == null ? void 0 : _a2[0]]), i = useMemo(() => {
    var _a3, _b2;
    return (_b2 = (_a3 = e3.data) == null ? void 0 : _a3.map((r3) => r3.rows)) == null ? void 0 : _b2.flat();
  }, [e3.data]), s = e3.isLoading;
  return [i, { meta: o, isLoading: s, loadMore: () => {
    e3.setSize(e3.size + 1);
  } }];
}, Js = () => {
  let t = St$1({ to: M(/* @__PURE__ */ new Date()), from: B$1(subDays(/* @__PURE__ */ new Date(), 89)) }), [e3, o] = useState(90), [i, s] = useState(t), n4 = (u2) => {
    o(u2), s({ from: B$1(subDays(/* @__PURE__ */ new Date(), u2 - 1)), to: M(/* @__PURE__ */ new Date()) });
  }, r3 = (u2) => {
    if (u2.name === "dateRange") {
      let c2 = St$1(u2.value);
      if (s(c2), c2.from && c2.to) {
        let d2 = Math.abs(differenceInDays(c2.from, c2.to)) + 1, S2 = { 1: { from: B$1(/* @__PURE__ */ new Date()), to: M(/* @__PURE__ */ new Date()) }, 7: { from: B$1(subDays(/* @__PURE__ */ new Date(), 6)), to: M(/* @__PURE__ */ new Date()) }, 30: { from: B$1(subDays(/* @__PURE__ */ new Date(), 29)), to: M(/* @__PURE__ */ new Date()) }, 90: { from: B$1(subDays(/* @__PURE__ */ new Date(), 89)), to: M(/* @__PURE__ */ new Date()) } }[d2];
        S2 && ht$1(S2.from, c2.from) && ht$1(S2.to, c2.to) ? o(d2) : o(null);
      }
    }
  }, { isMobile: a2 } = Ao$6();
  return { filterItems: useMemo(() => {
    let u2 = { type: "range", name: "dateRange", value: i, fromDate: B$1(subDays(/* @__PURE__ */ new Date(), 89)), toDate: M(/* @__PURE__ */ new Date()) };
    return a2 ? [u2] : [u2];
  }, [i]), onFilter: r3, dateRange: i, filterDays: e3, updateFilterDays: n4 };
}, Zs = (t) => (e3, o) => {
  var _a2;
  if (o && !((_a2 = o.rows) == null ? void 0 : _a2.length)) return null;
  let { symbol: i, size: s = 10, page: n4, end_t: r3, start_t: a2 } = t, l2 = new URLSearchParams([["size", s.toString()], ["page", `${e3 + 1}`]]);
  return n4 && l2.set("page", `${n4}`), i && l2.set("symbol", i), r3 && l2.set("end_t", `${r3}`), a2 && l2.set("start_t", `${a2}`), `/v1/liquidations?${l2.toString()}`;
};
var js = (t) => {
  let e3 = te$2(t);
  return jsx(Ke$1, { ...e3 });
}, ta$1 = (t) => {
  let { classNames: e3, ...o } = t, i = te$2(o);
  return jsx(Xe$2, { classNames: e3, ...i });
};
var oa$1 = "MarketCloseConfirmID";
Pg(oa$1, qt$2, { size: "md", closable: false });
var Ct$2 = (e3) => {
  let { current: t, pnlNotionalDecimalPrecision: r3, sharePnLConfig: o } = e3, n4 = useRef(null);
  return useImperativeHandle(e3.ref, () => ({ download: () => {
    var _a2, _b2;
    (_b2 = (_a2 = n4.current) == null ? void 0 : _a2.download) == null ? void 0 : _b2.call(_a2);
  } })), { current: t, pnlNotionalDecimalPrecision: r3, orderListRef: n4, sharePnLConfig: o };
};
var Te = (e3) => e3 === void 0 || e3.length === 0 ? e3 : e3.length === 1 ? e3.charAt(0).toUpperCase() : e3.charAt(0).toUpperCase() + e3.toLowerCase().slice(1);
function ue$3(e$1) {
  var _a2, _b2;
  let t = e$1.type, r3 = e$1.algo_type;
  if (typeof t < "u") {
    let o = [];
    if (e$1.parent_algo_type) {
      if (r3 === AlgoOrderType.STOP_LOSS) {
        let i = t === OrderType.CLOSE_POSITION ? [e2.t("common.position"), e2.t("tpsl.sl")] : [e2.t("tpsl.sl")];
        o.push(...i);
      }
      if (r3 === AlgoOrderType.TAKE_PROFIT) {
        let i = t === OrderType.CLOSE_POSITION ? [e2.t("common.position"), e2.t("tpsl.tp")] : [e2.t("tpsl.tp")];
        o.push(...i);
      }
      return o;
    }
    let n4 = typeof t == "string" ? t.replace("_ORDER", "") : "";
    if ([OrderType.ASK, OrderType.BID].includes(t)) return [e2.t("orderEntry.orderType.limit")];
    if (e$1.algo_order_id === void 0 || e$1.algo_order_id && r3 === "BRACKET") return [{ [OrderType.LIMIT]: e2.t("orderEntry.orderType.limit"), [OrderType.MARKET]: e2.t("orderEntry.orderType.market"), [OrderType.POST_ONLY]: e2.t("orderEntry.orderType.postOnly"), [OrderType.IOC]: e2.t("orderEntry.orderType.ioc"), [OrderType.FOK]: e2.t("orderEntry.orderType.fok") }[n4] || Te(n4)];
    if (n4) return [{ [OrderType.LIMIT]: e2.t("orderEntry.orderType.stopLimit"), [OrderType.MARKET]: e2.t("orderEntry.orderType.stopMarket") }[n4] || n4];
  }
  if (typeof r3 < "u") {
    let o = [];
    r3 === AlgoOrderRootType.POSITIONAL_TP_SL && o.push(e2.t("common.position"));
    let n4 = (_a2 = e$1 == null ? void 0 : e$1.child_orders) == null ? void 0 : _a2.find((a2) => a2.algo_type === AlgoOrderType.TAKE_PROFIT && !!a2.trigger_price), i = (_b2 = e$1 == null ? void 0 : e$1.child_orders) == null ? void 0 : _b2.find((a2) => a2.algo_type === AlgoOrderType.STOP_LOSS && !!a2.trigger_price);
    return (n4 || i) && o.push(n4 && i ? e2.t("common.tpsl") : n4 ? e2.t("tpsl.tp") : e2.t("tpsl.sl")), o;
  }
}
function ne$2(e3) {
  return e3.status === OrderStatus.CANCELLED || e3.algo_status === OrderStatus.CANCELLED;
}
function ln$1(e3) {
  var _a2, _b2, _c2;
  if (e3.algo_type !== AlgoOrderRootType.BRACKET) return { tpOrder: void 0, slOrder: void 0 };
  let t = (_a2 = e3.child_orders) == null ? void 0 : _a2[0];
  if (!t) return { tpOrder: void 0, slOrder: void 0 };
  let r3 = (_b2 = t == null ? void 0 : t.child_orders) == null ? void 0 : _b2.find((n4) => n4.algo_type === AlgoOrderType.TAKE_PROFIT), o = (_c2 = t == null ? void 0 : t.child_orders) == null ? void 0 : _c2.find((n4) => n4.algo_type === AlgoOrderType.STOP_LOSS);
  return { tpOrder: r3, slOrder: o };
}
function lt$1(e3) {
  let t = { pnl: { tpPnL: void 0, slPnL: void 0 }, roi: { tpRoi: void 0, slRoi: void 0 } }, { tpOrder: r3, slOrder: o } = ln$1(e3);
  if (!r3 && !o || typeof e3.price === void 0 || !e3.price) return t;
  let n4 = e3.side === OrderSide.BUY ? e3.quantity : e3.quantity * -1, i = (r3 == null ? void 0 : r3.trigger_price) && utils_exports.priceToPnl({ qty: n4, price: r3 == null ? void 0 : r3.trigger_price, entryPrice: e3.price, orderSide: e3.side, orderType: r3.algo_type }), a2 = (o == null ? void 0 : o.trigger_price) && utils_exports.priceToPnl({ qty: n4, price: o == null ? void 0 : o.trigger_price, entryPrice: e3.price, orderSide: e3.side, orderType: o.algo_type }), s = i ? utils_exports.calcTPSL_ROI({ pnl: i, qty: e3.quantity, price: e3.price }) : void 0, d2 = a2 ? utils_exports.calcTPSL_ROI({ pnl: a2, qty: e3.quantity, price: e3.price }) : void 0;
  return { pnl: { tpPnL: i, slPnL: a2 }, roi: { tpRoi: s, slRoi: d2 } };
}
var Cr = createContext({}), W$1 = () => useContext(Cr), Tt$3 = (e3) => {
  let t = useSymbolsInfo()[e3.symbol];
  return jsx(Cr.Provider, { value: { base_dp: t("base_dp"), quote_dp: t("quote_dp"), base_tick: t("base_tick"), quote_tick: t("quote_tick"), base: t("base"), quote: t("quote"), symbol: e3.symbol, origin: t(), quote_max: t("quote_max"), quote_min: t("quote_min") }, children: e3.children });
};
var Lr = createContext({}), X = () => useContext(Lr), Nt$2 = (e3) => {
  let { cancelOrder: t, editOrder: r3, cancelAlgoOrder: o, editAlgoOrder: n4 } = e3, { t: i } = Z$2(), a2 = useSymbolsInfo(), s = useCallback(async (l2) => l2.algo_order_id !== void 0 ? "root_algo_order_id" in l2 && l2.root_algo_order_id !== l2.algo_order_id ? o(l2.root_algo_order_id, l2.symbol) : o(l2.algo_order_id, l2.symbol).then(() => {
  }) : t(l2.order_id, l2.symbol).then(() => {
  }), []), d2 = useCallback(async (l2, b2) => {
    l2.visible_quantity !== void 0 ? l2.visible_quantity === 0 : l2.visible !== void 0 ? l2.visible === 0 : false;
    await uo$3.sheet({ title: i("orders.editOrder"), classNames: { content: "oui-edit-order-sheet-content" }, content: jsx(Fragment$1, { children: "Content" }) });
  }, [i]), u2 = useCallback((l2, b2, m2) => {
    let { min_notional: O2 } = a2[l2](), _2 = getMinNotional({ price: b2, qty: m2, min_notional: O2 });
    if (_2 !== void 0) return i("orderEntry.total.error.min", { value: _2 });
  }, [a2, i]);
  return jsx(Lr.Provider, { value: { onCancelOrder: s, onEditOrder: d2, editOrder: r3, editAlgoOrder: n4, checkMinNotional: u2 }, children: e3.children });
};
var Ir$1 = createContext({}), G$1 = () => useContext(Ir$1), It = (e3) => {
  let { quote_dp: t } = W$1(), [r3, o] = useState(), [n4] = useMutation("/v1/algo/order", "DELETE"), [i] = useMutation("/v1/algo/order", "PUT"), a2 = useSWRConfig(), { state: s } = useAccount(), d2 = useMemo(() => unstable_serialize$1(() => ["/v1/positions", s.accountId]), [s.accountId]), u2 = async (h2) => n4(null, { order_id: h2.algo_order_id, symbol: h2.symbol }), l2 = async (h2, F2) => i({ order_id: h2.algo_order_id, child_orders: h2.child_orders.map((T2) => ({ order_id: T2.algo_order_id, quantity: F2.order_quantity })) }), b2 = (h2) => {
    var _a2;
    return (_a2 = a2.cache.get(d2)) == null ? void 0 : _a2.data.rows.find((T2) => T2.symbol === h2);
  }, { sl_trigger_price: m2, tp_trigger_price: O2, tpPnL: _2, slPnL: I2 } = wn({ order: e3.order, position: r3, quote_dp: t });
  return useEffect(() => {
    var _a2;
    if ("algo_type" in e3.order || (((_a2 = e3.order) == null ? void 0 : _a2.reduce_only) ?? false)) {
      let h2 = b2(e3.order.symbol);
      h2 && o(h2);
    }
  }, [e3.order.symbol]), jsx(Ir$1.Provider, { value: { order: e3.order, sl_trigger_price: m2, tp_trigger_price: O2, tpPnL: _2, slPnL: I2, onCancelOrder: u2, onUpdateOrder: l2, getRelatedPosition: b2, position: r3 }, children: e3.children });
};
function wn(e3) {
  var _a2;
  let { order: t, position: r3, quote_dp: o } = e3;
  if (!r3) return { sl_trigger_price: void 0, tp_trigger_price: void 0, slPnL: void 0, tpPnL: void 0 };
  let { sl_trigger_price: n4, tp_trigger_price: i } = !("algo_type" in t) || !Array.isArray(t.child_orders) ? {} : utils_exports.findTPSLFromOrder(t), a2 = t.quantity;
  a2 === 0 && ((_a2 = t.child_orders) == null ? void 0 : _a2[0].type) === "CLOSE_POSITION" && (a2 = r3.position_qty);
  let s = r3.average_open_price, d2 = typeof a2 == "number" && typeof i == "number" && typeof s == "number" ? utils_exports.priceToPnl({ qty: a2, price: i, entryPrice: r3.average_open_price, orderSide: t.side, orderType: AlgoOrderType.TAKE_PROFIT }, { symbol: { quote_dp: o } }) : void 0, u2 = typeof a2 == "number" && typeof n4 == "number" && typeof s == "number" ? utils_exports.priceToPnl({ qty: a2, price: n4, entryPrice: r3.average_open_price, orderSide: t.side, orderType: AlgoOrderType.STOP_LOSS }, { symbol: { quote_dp: o } }) : void 0;
  return { sl_trigger_price: n4, tp_trigger_price: i, slPnL: u2, tpPnL: d2 };
}
var qe$1 = (e3) => {
  let { type: t, base: r3, value: o, cancelPopover: n4, isSubmitting: i, onConfirm: a2 } = e3, { t: s } = Z$2();
  return jsxs("div", { className: "oui-pt-5 oui-relative", children: [jsx("div", { className: "oui-text-base-contrast-54 oui-text-2xs desktop:oui-text-sm", children: (() => {
    let u2 = { values: { base: r3, value: d$3(o) }, components: [jsx("span", { className: "oui-text-warning-darken" })] };
    switch (t) {
      case 0:
        return jsx(Trans, { i18nKey: "order.edit.confirm.quantity", ...u2 });
      case 1:
        return jsx(Trans, { i18nKey: "order.edit.confirm.price", ...u2 });
      case 2:
        return jsx(Trans, { i18nKey: "order.edit.confirm.triggerPrice", ...u2 });
    }
  })() }), jsxs("div", { className: "oui-grid oui-grid-cols-2 oui-gap-2 oui-mt-5", children: [jsx(_e$5, { color: "secondary", size: "md", onClick: n4, disabled: i, children: s("common.cancel") }), jsx(dr$3, { size: "md", loading: i, onClick: a2, children: s("common.confirm") })] }), jsx("button", { className: "oui-absolute oui-right-0 oui-top-0 oui-text-base-contrast-54", onClick: n4, children: jsx(ye$7, { size: 16, color: "white", opacity: 1 }) })] });
};
var Re$2 = (e3) => {
  let { inputRef: t, dp: r3, value: o, setValue: n4, setEditing: i, error: a2, handleKeyDown: s, onClick: d2, onClose: u2, onFocus: l2, onBlur: b2, hintInfo: m2 } = e3;
  useEffect(() => {
    let _2 = t.current;
    if (_2) {
      let I2 = _2.value.length;
      _2.setSelectionRange(I2, I2);
    }
    i(true);
  }, []);
  let O2 = ((m2 == null ? void 0 : m2.length) || 0) > 0;
  return jsx(Xn$2, { content: m2, open: O2, children: jsx(So$4, { ref: t, type: "text", size: "sm", formatters: [Xr$1.numberFormatter, Xr$1.dpFormatter(r3), Xr$1.currencyFormatter], value: o, onValueChange: (_2) => n4(_2), helpText: a2, onClick: (_2) => {
    _2.stopPropagation(), _2.preventDefault();
  }, autoComplete: "off", onFocus: l2, onBlur: b2, onKeyDown: s, autoFocus: true, color: O2 ? "danger" : void 0, classNames: { root: "oui-bg-base-700 oui-px-2 oui-py-1 oui-rounded", input: "oui-pr-2" }, suffix: jsx("button", { onClick: d2, children: jsx(fa$1, { size: 18, color: "white", opacity: 1, className: "oui-cursor-pointer oui-opacity-50 hover:oui-opacity-100" }) }) }) });
};
var Ft$2 = (e3) => {
  let { order: t, otherOrderQuantity: r3 } = e3, { reduce_only: o } = t, [n4, i] = useState(t.quantity.toString()), [a2, s] = useState(false), { t: d2 } = Z$2();
  useEffect(() => {
    w5(t.quantity.toString());
  }, [e3.order.quantity]);
  let [u2, l2] = useState(false), [b2, m2] = useState(), { editOrder: O2, editAlgoOrder: _2, checkMinNotional: I2 } = X(), { onUpdateOrder: h2, position: F2 } = G$1(), { base_dp: T2, base: V2, base_tick: f2 } = W$1(), w5 = async (g2, y2) => {
    i(g2);
    let k2 = Math.abs((F2 == null ? void 0 : F2.position_qty) || 0);
    if (F2 && o && Number(g2) > k2) m2(d2("orders.quantity.lessThanPosition", { quantity: k2 }));
    else {
      let Ce2 = Number(g2);
      y2 && Ce2 > y2 ? m2(d2("orders.quantity.lessThan", { quantity: $$5(y2, { fix: T2 }) })) : m2(void 0);
    }
    return Promise.resolve();
  }, M2 = () => {
    l2(false), s(false);
  }, R2 = () => {
    l2(false), w5(t.quantity.toString()), s(false);
  }, [x2, C2] = useState(false), D2 = useRef(null), te2 = () => {
    if (b2) return;
    if (Number(n4) === Number(t.quantity)) {
      s(false);
      return;
    }
    let g2 = t.algo_order_id !== void 0 ? t.trigger_price : t.price;
    if (g2 !== null && t.reduce_only !== true) {
      let y2 = I2(t.symbol, g2, n4);
      if (y2) {
        toast$2.error(y2), C2(false), R2();
        return;
      }
    }
    l2(true);
  }, E3 = (g2) => {
    g2 == null ? void 0 : g2.stopPropagation(), g2 == null ? void 0 : g2.preventDefault(), te2();
  }, Y2 = (g2) => {
    g2.key === "Enter" && (g2 == null ? void 0 : g2.stopPropagation(), g2 == null ? void 0 : g2.preventDefault(), te2());
  }, v2 = useCallback(() => {
    C2(true);
    let g2 = { symbol: t.symbol, order_type: t.type, side: t.side, order_price: t.price, order_quantity: n4, algo_order_id: t.algo_order_id };
    if (typeof g2.algo_order_id < "u" && g2.order_type === "MARKET") {
      let { order_price: k2, ...Ce2 } = g2;
      g2 = Ce2;
    }
    typeof t.reduce_only < "u" && (g2.reduce_only = t.reduce_only), t.order_tag !== void 0 && (g2 = { ...g2, order_tag: t.order_tag }), (t == null ? void 0 : t.visible_quantity) === 0 && (g2.visible_quantity = 0), (t == null ? void 0 : t.tag) !== void 0 && (g2.order_tag = t.tag);
    let y2;
    "algo_type" in t && t.algo_type === AlgoOrderRootType.TP_SL ? y2 = h2(t, g2) : t.algo_order_id !== void 0 ? y2 = _2(t.algo_order_id.toString(), g2) : y2 = O2(t.order_id.toString(), g2), y2.then((k2) => {
      M2(), w5(n4.toString());
    }, (k2) => {
      toast$2.error(k2.message), w5(t.quantity.toString()), R2();
    }).finally(() => C2(false));
  }, [n4]), A2 = useRef(null), re2 = useRef(null), de2 = (g2) => {
    A2.current && re2.current && !A2.current.contains(g2.target) && !re2.current.contains(g2.target) && !u2 && R2();
  };
  useEffect(() => (document.addEventListener("mousedown", de2), () => {
    document.removeEventListener("mousedown", de2);
  }), [u2, t.quantity]);
  let De2 = () => !a2 || e3.disableEdit ? jsx(Gn$1, { order: t, quantity: n4, setEditing: s, disableEdit: e3.disableEdit }) : jsx(Jn$2, { inputRef: D2, quantitySliderRef: re2, base_dp: T2, base_tick: f2, quantity: n4, setQuantity: w5, editing: a2, setEditing: s, handleKeyDown: Y2, onClick: E3, onClose: R2, symbol: t.symbol, reduce_only: o, positionQty: F2 == null ? void 0 : F2.position_qty, error: b2, confirmOpen: u2, side: t.side, order: t, setError: m2 });
  return jsx(yo$3, { open: u2, onOpenChange: l2, content: jsx(qe$1, { type: 0, base: V2, value: n4, cancelPopover: R2, isSubmitting: x2, onConfirm: v2 }), contentProps: { onOpenAutoFocus: (g2) => {
  } }, children: jsx("div", { onClick: (g2) => {
    g2.stopPropagation(), g2.preventDefault();
  }, ref: A2, children: De2() }) });
}, Gn$1 = (e3) => {
  let { order: t, quantity: r3 } = e3, o = t.total_executed_quantity;
  return jsxs(z$1, { direction: "row", justify: "start", gap: 1, className: cnBase("oui-max-w-[110px] oui-relative", t.side === OrderSide.BUY && "oui-text-trade-profit", t.side === OrderSide.SELL && "oui-text-trade-loss", ne$2(t) && "oui-text-base-contrast-20"), onClick: (n4) => {
    n4.stopPropagation(), n4.preventDefault(), e3.setEditing(true);
  }, children: ["algo_type" in t && t.algo_type === AlgoOrderRootType.TP_SL ? null : jsxs(Fragment$1, { children: [jsx("span", { children: o }), jsx("span", { children: "/" })] }), jsx(z$1, { r: "base", className: cnBase("oui-min-w-[70px] oui-h-[28px]", !e3.disableEdit && "oui-bg-base-7 oui-px-2 oui-border oui-border-line-12"), children: jsx($$4, { size: "2xs", children: r3 }) })] });
}, Jn$2 = (e3) => {
  let { inputRef: t, quantitySliderRef: r3, base_dp: o, base_tick: n4, quantity: i, setQuantity: a2, editing: s, setEditing: d2, handleKeyDown: u2, onClick: l2, onClose: b2, error: m2, symbol: O2, reduce_only: _2, positionQty: I2, confirmOpen: h2, side: F2, order: T2 } = e3, V2 = useMaxQty(O2, T2.side, T2.reduce_only), f2 = useMemo(() => _2 ? Math.abs(I2 ?? 0) : T2.quantity + Math.abs(V2), [T2.quantity, V2, _2, I2]), [w5, M2] = useState(void 0);
  useEffect(() => {
    if (w5 === void 0) {
      let x2 = new g$6(i).div(f2).abs().mul(100).toNumber();
      M2(x2);
    }
  }, [w5, f2, i]);
  let R2 = async (x2) => (n4 > 0 && (x2 = utils_exports.formatNumber(x2, n4) ?? x2), a2(`${x2}`, f2));
  return jsxs(gt$2, { open: !h2, children: [jsx(En$2, { children: jsx(Re$2, { inputRef: t, dp: o, value: i, setValue: (x2) => {
    let C2 = Math.abs(Math.min(Number(x2), f2)).toString();
    if (a2(x2, f2), x2.endsWith(".")) return;
    if (Number(C2) === 0) {
      M2(0);
      return;
    }
    let D2 = new g$6(x2).div(f2).mul(100).toDecimalPlaces(2, g$6.ROUND_DOWN).toNumber();
    M2(Math.min(100, D2));
  }, setEditing: d2, handleKeyDown: u2, onClick: l2, onClose: b2, onBlur: (x2) => {
    R2(x2.target.value);
  }, hintInfo: m2 }) }), jsx(vo$6, { className: "oui-w-[360px] oui-rounded-xl", align: "start", side: "bottom", onOpenAutoFocus: (x2) => {
    x2.preventDefault();
  }, children: jsxs(z$1, { p: 1, gap: 2, width: "100%", itemAlign: "start", ref: r3, children: [jsx($$4.numeral, { size: "xs", intensity: 98, className: "oui-min-w-[30px] ", dp: 2, padding: false, unit: "%", rm: g$6.ROUND_DOWN, children: `${w5}` }), jsxs(z$1, { direction: "column", width: "100%", gap: 2, className: "oui-mt-[6px]", children: [jsx(Bl, { markCount: 4, value: [w5 ?? 0], onValueChange: (x2) => {
    let C2 = Array.from(x2.values());
    M2(C2[0]);
    let D2 = new g$6(C2[0]).div(100).mul(f2).abs().toFixed(o, g$6.ROUND_DOWN);
    a2(D2, f2);
  }, onValueCommit: (x2) => {
    let C2 = new g$6(x2[0]).div(100).mul(f2).abs().toFixed(o, g$6.ROUND_DOWN);
    R2(C2).finally(() => {
      t.current.focus();
    });
  } }), jsx(Xn$1, { onClick: (x2) => {
    M2(x2 * 100);
    let C2 = new g$6(x2).mul(f2).abs().toFixed(o, g$6.ROUND_DOWN);
    C2 = utils_exports.formatNumber(C2, n4) ?? C2, a2(C2, f2), setTimeout(() => {
      t.current.focus(), t.current.setSelectionRange(C2.length, C2.length);
    }, 100);
  } })] })] }) })] });
}, Xn$1 = (e3) => {
  let { t } = Z$2(), r3 = [{ label: "0%", value: 0 }, { label: "25%", value: 0.25 }, { label: "50%", value: 0.5 }, { label: "75%", value: 0.75 }, { label: t("common.max"), value: 1 }];
  return jsx(z$1, { gap: 2, width: "100%", children: r3.map((o, n4) => jsx(_e$5, { variant: "outlined", color: "secondary", size: "xs", onClick: (i) => {
    i.stopPropagation(), i.preventDefault(), e3.onClick(o.value);
  }, className: "oui-w-1/5", children: o.label }, n4)) });
};
var Ur$2 = (e3) => {
  let { order: t } = e3, { t: r3 } = Z$2(), [o, n4] = useState(() => {
    var _a2;
    return t.type === OrderType.MARKET && !t.price ? "Market" : ((_a2 = t.price) == null ? void 0 : _a2.toString()) ?? "Market";
  }), [i, a2] = useState(false), [s, d2] = useState(false), u2 = (t == null ? void 0 : t.algo_order_id) !== void 0, l2 = (t == null ? void 0 : t.type) === "MARKET" && u2, [b2, m2] = useState(false), { editOrder: O2, editAlgoOrder: _2, checkMinNotional: I2 } = X(), { base: h2, quote_dp: F2 } = W$1(), T2 = useSymbolPriceRange(t.symbol, t.side, u2 ? t.trigger_price : void 0), V2 = () => {
    a2(false), d2(false);
  }, f2 = () => {
    var _a2;
    a2(false), n4(((_a2 = t.price) == null ? void 0 : _a2.toString()) ?? "Market"), d2(false);
  }, w5 = useMemo(() => !T2 || l2 || !s ? "" : Number(o) > T2.max ? r3("orders.price.greaterThan", { max: T2.max }) : Number(o) < T2.min ? r3("orders.price.lessThan", { min: T2.min }) : "", [l2, s, T2, o, r3]), M2 = (v2) => {
    if (v2 == null ? void 0 : v2.stopPropagation(), v2 == null ? void 0 : v2.preventDefault(), !(w5.length > 0)) {
      if (o === `${t.price}`) {
        d2(false);
        return;
      }
      if (t.reduce_only !== true) {
        let A2 = I2(t.symbol, o, t.quantity);
        if (A2) {
          toast$2.error(A2), m2(false), f2();
          return;
        }
      }
      a2(true);
    }
  }, R2 = (v2) => {
    v2.key === "Enter" && M2(v2);
  }, x2 = () => {
    m2(true);
    let v2 = t.order_id, A2 = { order_price: o, order_quantity: t.quantity, symbol: t.symbol, order_type: t.type, side: t.side };
    typeof t.reduce_only < "u" && (A2.reduce_only = t.reduce_only), t.order_tag !== void 0 && (A2 = { ...A2, order_tag: t.order_tag }), u2 && (v2 = t.algo_order_id, A2 = { ...A2, order_id: v2, price: o, algo_order_id: v2 }), (t == null ? void 0 : t.visible_quantity) === 0 && (A2.visible_quantity = 0), t.tag !== void 0 && (A2.order_tag = t.tag);
    let re2;
    t.algo_order_id !== void 0 ? re2 = _2(t.algo_order_id.toString(), A2) : re2 = O2(t.order_id.toString(), A2), re2.then((de2) => {
      V2(), n4(o);
    }, (de2) => {
      toast$2.error(de2.message), f2();
    }).finally(() => m2(false));
  }, C2 = useRef(null);
  useEffect(() => {
    e3.order.price && n4(`${e3.order.price}`);
  }, [e3.order.price]);
  let D2 = useRef(null), te2 = (v2) => {
    D2.current && !D2.current.contains(v2.target) && !i && f2();
  };
  if (useEffect(() => (document.addEventListener("mousedown", te2), () => {
    document.removeEventListener("mousedown", te2);
  }), [i, t.price]), t.algo_order_id && t.type == "MARKET" || o === "Market") return jsx("span", { children: r3("common.marketPrice") });
  let Y2 = () => !s || e3.disableEdit ? jsx(si, { order: t, price: o, setEditing: d2, disableEdit: e3.disableEdit }) : jsx(Re$2, { inputRef: C2, dp: F2, value: o, setValue: n4, setEditing: d2, handleKeyDown: R2, onClick: M2, onClose: f2, hintInfo: w5 });
  return jsx(yo$3, { open: i, onOpenChange: a2, content: jsx(qe$1, { type: 1, base: h2, value: o, cancelPopover: f2, isSubmitting: b2, onConfirm: x2 }), children: jsx("div", { onClick: (v2) => {
    v2.stopPropagation(), v2.preventDefault();
  }, ref: D2, children: Y2() }) });
}, si = (e3) => {
  let { order: t, price: r3 } = e3;
  return jsx("div", { className: cnBase("oui-flex oui-max-w-[110px] oui-justify-start oui-items-center oui-gap-1 oui-relative oui-font-semibold", ne$2(t) && "oui-text-base-contrast-20"), onClick: (o) => {
    o.stopPropagation(), o.preventDefault(), e3.setEditing(true);
  }, children: jsx(z$1, { r: "base", className: cnBase("oui-min-w-[70px] oui-h-[28px]", !e3.disableEdit && "oui-bg-base-7 oui-px-2  oui-border oui-border-line-12"), children: jsx($$4, { size: "2xs", children: $$5(r3) }) }) });
};
var Gr$1 = (e3) => {
  let { order: t } = e3, [r3, o] = useState("");
  useEffect(() => {
    var _a2;
    o(((_a2 = t.trigger_price) == null ? void 0 : _a2.toString()) ?? "0");
  }, [t.trigger_price]);
  let n4 = (t == null ? void 0 : t.algo_order_id) !== void 0, i = (t == null ? void 0 : t.algo_type) === "BRACKET", [a2, s] = useState(false), [d2, u2] = useState(false), [l2, b2] = useState(false), { editAlgoOrder: m2, checkMinNotional: O2 } = X(), { base: _2, quote_dp: I2, quote_max: h2, quote_min: F2 } = W$1(), T2 = useMemo(() => {
    if (!((!n4 || i) && !d2)) {
      if (Number(r3) > h2) return `Trigger price must be less than ${h2}`;
      if (Number(r3) < F2) return `Trigger price must be greater than ${F2}`;
    }
  }, [d2, r3, n4, i]), V2 = () => {
    s(false), u2(false);
  }, f2 = () => {
    var _a2;
    o(((_a2 = t.trigger_price) == null ? void 0 : _a2.toString()) ?? "0"), s(false), u2(false);
  }, w5 = useRef(null), M2 = (E3) => {
    w5.current && !w5.current.contains(E3.target) && !a2 && f2();
  };
  useEffect(() => (document.addEventListener("mousedown", M2), () => {
    document.removeEventListener("mousedown", M2);
  }), [a2, t.trigger_price]);
  let R2 = (E3) => {
    if (E3 == null ? void 0 : E3.stopPropagation(), E3 == null ? void 0 : E3.preventDefault(), u2(false), Number(r3) !== Number(t.trigger_price)) {
      if (t.price && t.reduce_only !== true) {
        let Y2 = O2(t.symbol, t.price, t.quantity);
        if (Y2) {
          toast$2.error(Y2), b2(false), f2();
          return;
        }
      }
      s(true);
    }
  }, x2 = (E3) => {
    E3.key === "Enter" && R2(E3);
  }, C2 = () => {
    if ((T2 ?? "").length > 0) return;
    b2(true);
    let E3 = { quantity: t.quantity, trigger_price: r3, symbol: t.symbol, algo_order_id: t.algo_order_id };
    t.order_tag !== void 0 && (E3 = { ...E3, order_tag: t.order_tag }), m2(`${t.algo_order_id}`, E3).then((Y2) => {
      V2(), o(r3);
    }, (Y2) => {
      var _a2;
      toast$2.error(Y2.message), o(((_a2 = t.trigger_price) == null ? void 0 : _a2.toString()) ?? "--"), f2();
    }).finally(() => b2(false));
  }, D2 = useRef(null);
  if (!n4 || i) return jsx($$4, { children: "--" });
  let te2 = () => !d2 || e3.disableEdit ? jsx(ci$1, { order: t, price: r3, setEditing: u2, disableEdit: e3.disableEdit }) : jsx(Re$2, { inputRef: D2, dp: I2, value: r3, setValue: o, setEditing: u2, handleKeyDown: x2, onClick: R2, onClose: f2, hintInfo: T2 });
  return jsx(yo$3, { open: a2, onOpenChange: s, content: jsx(qe$1, { type: 2, base: _2, value: r3, cancelPopover: f2, isSubmitting: l2, onConfirm: C2 }), children: jsx("div", { onClick: (E3) => {
    E3.stopPropagation(), E3.preventDefault();
  }, ref: w5, children: te2() }) });
}, ci$1 = (e3) => {
  let { order: t, price: r3 } = e3;
  return jsx("div", { className: cnBase("oui-flex oui-max-w-[110px] oui-justify-start oui-items-center oui-gap-1 oui-relative oui-font-semibold", ne$2(t) && "oui-text-base-contrast-20"), onClick: (o) => {
    o.stopPropagation(), o.preventDefault(), e3.setEditing(true);
  }, children: jsx(z$1, { r: "base", className: cnBase("oui-min-w-[70px] oui-h-[28px]", !e3.disableEdit && "oui-bg-base-7 oui-px-2 oui-border oui-border-line-12"), children: jsx($$4, { size: "2xs", children: r3 }) }) });
};
var mt$2 = (e3) => {
  let { order: t } = e3, { t: r3 } = Z$2(), { onCancelOrder: o } = X(), [n4, i] = useState(false);
  return jsx(dr$3, { size: "sm", variant: "outlined", color: "secondary", onClick: (a2) => {
    o && (a2.preventDefault(), a2.stopPropagation(), i(true), o(t).then((s) => s, (s) => {
      toast$2.error(s.message);
    }).finally(() => {
      i(false);
    }));
  }, loading: n4, children: r3("common.cancel") });
};
var Jr$2 = (e3) => {
  let { record: t } = e3, [r3, o] = useState(false), [n4, { data: i, error: a2, reset: s, isMutating: d2 }] = useMutation("/v1/order"), { t: u2 } = Z$2(), l2 = useConfig("brokerId"), b2 = useCallback(() => {
    o(false);
    let m2 = { symbol: t.symbol, order_type: t.type, order_price: t.price, order_quantity: t.quantity, order_amount: t.amount, side: t.side, broker_id: l2 };
    Number(t.visible_quantity) < Number(t.quantity) && (m2.visible_quantity = 0), typeof t.reduce_only < "u" && (m2.reduce_only = t.reduce_only), n4(m2);
  }, []);
  return jsx(_e$5, { size: "sm", variant: "outlined", color: "secondary", loading: d2, disabled: d2, onClick: (m2) => {
    d2 || (m2.preventDefault(), m2.stopPropagation(), b2());
  }, children: u2("orders.history.renew") });
};
var eo$1 = () => {
  let { sl_trigger_price: e3, tp_trigger_price: t, order: r3, position: o } = G$1();
  return jsx(Ni, { stopLossPrice: e3, takeProfitPrice: t, direction: "column", order: r3, position: o, tooltip: true });
}, Ni = (e3) => {
  let { direction: t = "row", order: r3, position: o } = e3, n4 = useSymbolsInfo(), { t: i } = Z$2(), a2 = useMemo(() => {
    var _a2;
    let u2 = [];
    if (!e3.tooltip || !r3 || !o) return;
    let l2 = r3.quantity;
    return l2 === 0 && ((_a2 = r3.child_orders) == null ? void 0 : _a2[0].type) === "CLOSE_POSITION" && (l2 = o.position_qty), e3.takeProfitPrice && u2.push(jsx(Zr$1, { qty: l2, price: e3.takeProfitPrice, entryPrice: o.average_open_price, orderSide: r3.side, orderType: AlgoOrderType.TAKE_PROFIT, symbolInfo: n4[r3.symbol]() }, "tp")), e3.stopLossPrice && u2.push(jsx(Zr$1, { qty: l2, price: e3.stopLossPrice, entryPrice: o.average_open_price, orderSide: r3.side, orderType: AlgoOrderType.STOP_LOSS, symbolInfo: n4[r3.symbol]() }, "sl")), jsx("div", { children: u2 });
  }, [e3.takeProfitPrice, e3.stopLossPrice, o == null ? void 0 : o.average_open_price, r3 == null ? void 0 : r3.side, r3 == null ? void 0 : r3.quantity, r3 == null ? void 0 : r3.algo_type]), s = useMemo(() => {
    let u2 = [];
    return (r3 == null ? void 0 : r3.symbol) ? (e3.takeProfitPrice && u2.push(jsx($$4.numeral, { className: cnBase("oui-text-trade-profit oui-gap-0  oui-decoration-white/20 oui-border-b oui-border-dashed oui-border-base-contrast-12"), rule: "price", dp: n4[r3.symbol]("quote_dp", 2), children: e3.takeProfitPrice, prefix: !e3.stopLossPrice || t === "column" ? jsxs("span", { className: "oui-text-base-contrast-54", children: [`${i("tpsl.tp")} -`, ""] }) : "" }, "tp")), e3.stopLossPrice && u2.push(jsx($$4.numeral, { className: cnBase("oui-text-trade-loss oui-gap-0 oui-decoration-white/20 oui-border-b oui-border-dashed oui-border-base-contrast-12"), rule: "price", dp: n4[r3.symbol]("quote_dp", 2), children: e3.stopLossPrice, prefix: !e3.takeProfitPrice || t === "column" ? jsxs("span", { className: "oui-text-base-contrast-54", children: [`${i("tpsl.sl")} -`, ""] }) : "" }, "sl")), u2.length === 0 ? jsx("span", { children: "-" }) : (u2.length === 2 && t === "row" && u2.splice(1, 0, jsx("span", { children: "/" }, "split")), u2)) : jsx("span", { children: "-" });
  }, [e3.takeProfitPrice, e3.stopLossPrice, r3 == null ? void 0 : r3.symbol, i]), d2 = jsx("div", { className: cnBase("oui-inline-flex oui-text-base-contrast-36", e3.direction === "column" ? "oui-flex-col" : "oui-flex-row oui-gap-1", e3.className), children: s });
  return e3.tooltip ? jsx(Xn$2, { content: a2, className: "oui-bg-base-5", arrow: { className: "oui-fill-base-5" }, children: d2 }) : d2;
}, Zr$1 = (e3) => {
  let { qty: t, price: r3, entryPrice: o, orderSide: n4, orderType: i, symbolInfo: a2 } = e3, { t: s } = Z$2(), d2 = utils_exports.priceToPnl({ qty: t, price: r3, entryPrice: o, orderSide: n4, orderType: i }, { symbol: a2 }), l2 = (i === AlgoOrderType.TAKE_PROFIT ? "TP" : "SL") === "TP" ? `${s("tpsl.tpPnl")}:` : `${s("tpsl.slPnl")}:`;
  return jsxs("div", { className: "oui-flex oui-items-center", children: [jsx("span", { className: "oui-text-base-contrast-54 oui-mr-1", children: l2 }), jsx($$4.numeral, { rule: "price", dp: a2.quote_dp, padding: false, className: d2 === 0 ? "oui-text-base-contrast-36" : d2 > 0 ? "oui-text-trade-profit oui-gap-0" : "oui-text-trade-loss oui-gap-0", prefix: jsx("span", { children: d2 === 0 ? "" : d2 > 0 ? "+" : "-" }), suffix: jsx("span", { className: "oui-text-base-contrast-36 oui-ml-1", children: "USDC" }), children: `${Math.abs(d2)}` })] });
};
var no$2 = (e3) => {
  let { order: t } = e3, { quote_dp: r3, base_dp: o } = W$1(), { t: n4 } = Z$2(), { sl_trigger_price: i, tp_trigger_price: a2 } = useMemo(() => !("algo_type" in t) || !Array.isArray(t.child_orders) ? {} : utils_exports.findTPSLFromOrder(e3.order.child_orders[0]), [e3.order]), { pnl: s, roi: d2 } = lt$1(t);
  return !a2 && !i ? "--" : jsx(Xn$2, { content: jsxs(z$1, { direction: "column", itemAlign: "start", gap: 1, children: [typeof s.tpPnL < "u" && jsx($$4.numeral, { prefix: jsxs($$4, { intensity: 80, children: [`${n4("tpsl.tpPnl")}:`, " "] }), suffix: jsx($$4, { intensity: 20, children: " USDC" }), dp: r3, color: "buy", showIdentifier: true, children: s.tpPnL }), typeof s.slPnL < "u" && jsx($$4.numeral, { prefix: jsxs($$4, { intensity: 80, children: [`${n4("tpsl.slPnl")}:`, " "] }), suffix: jsx($$4, { intensity: 20, children: " USDC" }), dp: r3, color: "sell", children: s.slPnL })] }), className: "oui-bg-base-6", children: jsxs(z$1, { direction: "column", width: "100%", justify: "start", itemAlign: "start", children: [jsx(ro$3, { type: "TP", value: a2, quote_dp: r3 }), jsx(ro$3, { type: "SL", value: i, quote_dp: r3 })] }) });
}, ro$3 = (e3) => {
  let { type: t, value: r3, quote_dp: o } = e3, { t: n4 } = Z$2();
  return r3 ? jsx($$4.numeral, { className: cnBase("oui-gap-0 oui-decoration-white/20 oui-border-b oui-border-dashed oui-border-base-contrast-12", t === "TP" ? "oui-text-trade-profit" : "oui-text-trade-loss"), rule: "price", dp: o, prefix: jsxs("span", { className: "oui-text-base-contrast-54", children: [t === "TP" ? `${n4("tpsl.tp")} -` : `${n4("tpsl.sl")} -`, ""] }), children: r3 }, "tp") : jsx(Fragment$1, {});
};
var io$3 = (e3) => {
  let { position: t, order: r3 } = G$1(), { quote_dp: o, base_dp: n4 } = W$1(), { t: i } = Z$2();
  return jsx(pt$2, { quoteDP: o, baseDP: n4, position: t, order: r3, label: i("common.edit"), isEditing: true });
};
var so$3 = () => {
  let { sl_trigger_price: e3, tp_trigger_price: t } = G$1(), { t: r3 } = Z$2();
  return jsxs("div", { children: [t ? jsxs("div", { className: "oui-text-base-contrast-80 oui-td-bg-transparent", children: [jsxs($$4, { intensity: 54, children: [`${r3("tpsl.tp")} -`, ""] }), jsx("span", { children: r3("common.marketPrice") })] }) : null, e3 ? jsxs("div", { className: "oui-text-base-contrast-80 oui-td-bg-transparent", children: [jsxs("span", { className: "oui-text-base-contrast-54", children: [`${r3("tpsl.sl")} -`, ""] }), jsx("span", { children: r3("common.marketPrice") })] }) : null] });
};
function lo$2(e$1) {
  let { sl_trigger_price: t, tp_trigger_price: r3 } = !("algo_type" in e$1) || !Array.isArray(e$1.child_orders) ? {} : utils_exports.findTPSLFromOrder(e$1), o = r3 ? `${e2.t("tpsl.tp")} - ${e2.t("common.marketPrice")}` : void 0, n4 = t ? `${e2.t("tpsl.sl")} - ${e2.t("common.marketPrice")}` : void 0;
  return { tpTriggerPrice: o, slTriggerPrice: n4 };
}
var Wt$2 = (e3) => {
  let { t } = Z$2();
  return e3.sharePnLConfig == null ? jsx(Fragment$1, {}) : jsx("button", { type: "button", onClick: (r3) => {
    r3.stopPropagation(), uo$3.show(e3.modalId, { pnl: { entity: { symbol: e3.order.symbol, pnl: e3.order.realized_pnl, side: e3.order.side == "BUY" ? t("share.pnl.share.long") : t("share.pnl.share.short"), openPrice: e3.order.average_executed_price, openTime: e3.order.updated_time, quantity: e3.order.quantity }, refCode: e3.refCode, leverage: e3.leverage, ...e3.sharePnLConfig } });
  }, children: jsx(rn, { color: "white", opacity: 0.54, size: e3.iconSize ?? 16 }) });
};
var uo$2 = (e3) => {
  let { sharePnLConfig: t, order: r3, modalId: o, iconSize: n4 } = e3, { getFirstRefCode: i } = useReferralInfo(), a2 = useMemo(() => {
    var _a2;
    return (_a2 = i()) == null ? void 0 : _a2.code;
  }, [i]), s = useSymbolLeverage(e3.order.symbol);
  return { iconSize: n4, order: r3, refCode: a2, leverage: s, sharePnLConfig: t, modalId: o };
};
var Ze$1 = (e3) => {
  let t = uo$2(e3);
  return jsx(Wt$2, { ...t });
};
var fo$4 = (e3) => {
  let { _type: t, onSymbolChange: r3, pnlNotionalDecimalPrecision: o, sharePnLConfig: n4 } = e3, { t: i } = Z$2();
  return useMemo(() => {
    switch (t) {
      case "all":
        return [Ne$2({ width: 130, showType: true, onSymbolChange: r3, enableSort: false }), Me$2({ width: 130, disableEdit: true, className: "oui-pl-0 oui-pr-0", enableSort: false }), We$4({ width: 130, title: i("orders.column.orderPrice"), disableEdit: true, enableSort: false }), ft$1({ width: 130, enableSort: false }), co$3({ width: 130, symbolsInfo: e3.symbolsInfo }), zt$2({ width: 124, pnlNotionalDecimalPrecision: o, sharePnLConfig: n4, symbolsInfo: e3.symbolsInfo }), ze$3({ width: 130, enableSort: false }), et$1({ width: 130 }), tt$1({ width: 130 }), we$2({ width: 130 }), $e$2({ width: 130 }), mo$1({ width: 130 }), Ue$3({ width: 160, enableSort: false })];
      case "pending":
        return [Ne$2({ width: 172, showType: true, onSymbolChange: r3, enableSort: false }), Me$2({ width: 162, className: "oui-pr-0", enableSort: false }), We$4({ width: 162, className: "oui-pr-0", enableSort: false }), je$3({ width: 162, className: "oui-pr-0" }), oa({ width: 130 }), ze$3({ width: 162, isPending: true }), we$2({ width: 162 }), $e$2({ width: 162 }), Ue$3({ width: 162, enableSort: false }), ia({ width: 162 })];
      case "tp_sl":
        return [Ne$2({ width: 176, showType: true, onSymbolChange: r3, enableSort: false }), ea$1({ width: 176 }), co$3({ width: 176, symbolsInfo: e3.symbolsInfo }), ta({ width: 176 }), na({ width: 176 }), we$2({ width: 176 }), Ue$3({ width: 176, enableSort: false }), aa$1({ width: 176 })];
      case "filled":
        return [Ne$2({ showType: true, width: 154, onSymbolChange: r3 }), Me$2({ width: 124, disableEdit: true, className: "oui-pl-0 oui-pr-0" }), We$4({ width: 124, title: i("orders.column.orderPrice"), disableEdit: true }), ra$1({ width: 124 }), je$3({ width: 124, disableEdit: true }), zt$2({ width: 124, pnlNotionalDecimalPrecision: o, sharePnLConfig: n4, symbolsInfo: e3.symbolsInfo, hideShare: true }), ze$3({ width: 124 }), et$1({ width: 124 }), tt$1({ width: 124 }), we$2({ width: 124 }), $e$2({ width: 124 }), Ue$3({ width: 176 })];
      case "cancelled":
        return [Ne$2({ showType: true, width: 154, onSymbolChange: r3, enableSort: false }), Me$2({ width: 124, disableEdit: true, className: "oui-pl-0 oui-pr-0", enableSort: false }), We$4({ width: 124, disableEdit: true, enableSort: false }), ft$1({ width: 124, enableSort: false }), je$3({ width: 124, disableEdit: true }), ze$3({ width: 124 }), et$1({ width: 124 }), tt$1({ width: 124 }), we$2({ width: 124 }), $e$2({ width: 124 })];
      case "rejected":
        return [Ne$2({ showType: true, width: 154, onSymbolChange: r3 }), Me$2({ width: 124, disableEdit: true, className: "oui-pl-0 oui-pr-0" }), We$4({ width: 124, disableEdit: true }), ft$1({ width: 124 }), je$3({ width: 124, disableEdit: true }), ze$3({ width: 124 }), et$1({ width: 124 }), tt$1({ width: 124 }), we$2({ width: 124 }), $e$2({ width: 124 }), Ue$3({ width: 176 })];
      case "orderHistory":
        return [Ne$2({ showType: true, width: 154, onSymbolChange: r3 }), Me$2({ width: 150, disableEdit: true, className: "oui-pl-6 oui-pr-0" }), We$4({ width: 124, disableEdit: true }), ft$1({ width: 124 }), je$3({ width: 124, disableEdit: true }), zt$2({ width: 124, pnlNotionalDecimalPrecision: o, sharePnLConfig: n4, symbolsInfo: e3.symbolsInfo }), ze$3({ width: 124 }), et$1({ width: 124 }), tt$1({ width: 124 }), we$2({ width: 124 }), $e$2({ width: 124 }), Ue$3({ width: 150 }), mo$1({ width: 80 })];
    }
  }, [t, o, n4, i]);
};
function Ne$2(e$1) {
  return { title: e2.t("common.symbol"), dataIndex: "symbol", fixed: "left", width: e$1 == null ? void 0 : e$1.width, onSort: (e$1 == null ? void 0 : e$1.enableSort) ? (t, r3) => t.symbol.localeCompare(r3.symbol) : void 0, renderPlantText: (t, r3) => {
    var _a2;
    let o = (_a2 = ue$3(r3)) == null ? void 0 : _a2.join(","), n4 = (o == null ? void 0 : o.length) ? ` (${o})` : "";
    return `${t.split("_")[1]}-PERP${n4}`;
  }, render: (t, r3) => {
    var _a2;
    let o = ne$2(r3);
    return jsxs(z$1, { gap: 2, children: [jsx("div", { className: cnBase("oui-rounded-[1px] oui-w-1 oui-h-7 oui-shrink-0", r3.side === OrderSide.BUY ? "oui-bg-trade-profit" : "oui-bg-trade-loss") }), jsxs(z$1, { direction: "column", itemAlign: "start", children: [jsx($$4.formatted, { size: "xs", className: "oui-cursor-pointer oui-text-xs", onClick: (n4) => {
      var _a3;
      (_a3 = e$1 == null ? void 0 : e$1.onSymbolChange) == null ? void 0 : _a3.call(e$1, { symbol: t }), n4.stopPropagation(), n4.preventDefault();
    }, children: `${t.split("_")[1]}-PERP` }), (e$1 == null ? void 0 : e$1.showType) && jsx(z$1, { direction: "row", gap: 1, children: (_a2 = ue$3(r3)) == null ? void 0 : _a2.map((n4, i) => jsx(od, { color: n4.toLocaleLowerCase() === "position" ? o ? "neutral" : "primary" : "neutral", size: "xs", className: "oui-break-normal oui-whitespace-nowrap", children: n4 }, i)) })] })] });
  } };
}
function Me$2(e$1) {
  return { title: e2.t("orders.column.fill&Quantity"), dataIndex: "fill_quantity", className: e$1 == null ? void 0 : e$1.className, width: e$1 == null ? void 0 : e$1.width, onSort: (e$1 == null ? void 0 : e$1.enableSort) ?? false ? (t, r3) => {
    let o = (t.algo_type === AlgoOrderRootType.POSITIONAL_TP_SL ? 0 : t.quantity) ?? 0, n4 = (r3.algo_type === AlgoOrderRootType.POSITIONAL_TP_SL ? 0 : r3.quantity) ?? 0;
    return ot$2(o, n4);
  } : void 0, renderPlantText: (t, r3) => {
    if (r3.type === OrderType.CLOSE_POSITION && r3.status !== OrderStatus.FILLED) return e2.t("tpsl.entirePosition");
    let o = r3.total_executed_quantity;
    return ("algo_type" in r3 && r3.algo_type === AlgoOrderRootType.TP_SL ? "" : `${o} / `) + `${r3.quantity}`;
  }, render: (t, r3) => r3.type === OrderType.CLOSE_POSITION && r3.status !== OrderStatus.FILLED ? e2.t("tpsl.entirePosition") : jsx(Ft$2, { order: r3, disableEdit: e$1 == null ? void 0 : e$1.disableEdit }) };
}
function ea$1(e$1) {
  return { title: e2.t("common.quantity"), className: e$1 == null ? void 0 : e$1.className, dataIndex: "quantity", width: e$1 == null ? void 0 : e$1.width, onSort: (e$1 == null ? void 0 : e$1.enableSort) ?? false ? (t, r3) => {
    let o = (t.algo_type === AlgoOrderRootType.POSITIONAL_TP_SL ? 0 : t.quantity) ?? 0, n4 = (r3.algo_type === AlgoOrderRootType.POSITIONAL_TP_SL ? 0 : r3.quantity) ?? 0;
    return ot$2(o, n4);
  } : void 0, renderPlantText: (t, r3) => {
    if (r3.algo_type === AlgoOrderRootType.POSITIONAL_TP_SL) return e2.t("tpsl.entirePosition");
    let o = r3.total_executed_quantity;
    return ("algo_type" in r3 && r3.algo_type === AlgoOrderRootType.TP_SL ? "" : `${o}/`) + `${r3.quantity}`;
  }, render: (t, r3) => r3.algo_type === AlgoOrderRootType.POSITIONAL_TP_SL ? e2.t("tpsl.entirePosition") : jsx(Ft$2, { order: r3 }) };
}
function We$4(e$1) {
  return { title: (e$1 == null ? void 0 : e$1.title) ?? e2.t("common.price"), dataIndex: "price", className: e$1 == null ? void 0 : e$1.className, width: e$1 == null ? void 0 : e$1.width, onSort: (e$1 == null ? void 0 : e$1.enableSort) ?? false ? (t, r3, o) => ot$2(t.price ?? 0, r3.price ?? 0) : void 0, renderPlantText: (t, r3) => {
    var _a2;
    return $$5((_a2 = r3.price) == null ? void 0 : _a2.toString(), { fallback: e2.t("common.marketPrice") });
  }, render: (t, r3) => jsx(Ur$2, { order: r3, disableEdit: e$1 == null ? void 0 : e$1.disableEdit }) };
}
function ta(e$1) {
  return { title: (e$1 == null ? void 0 : e$1.title) ?? e2.t("common.price"), dataIndex: "price", className: e$1 == null ? void 0 : e$1.className, width: e$1 == null ? void 0 : e$1.width, onSort: e$1 == null ? void 0 : e$1.enableSort, renderPlantText: (t, r3) => {
    let { tpTriggerPrice: o, slTriggerPrice: n4 } = lo$2(r3), i = `${o || ""}${n4 ? `${o ? `
` : ""}${n4}` : ""}`;
    return i.length > 0 ? i : "--";
  }, render: (t, r3) => jsx(so$3, {}) };
}
function ra$1(e$1) {
  return { title: e2.t("common.avgPrice"), dataIndex: "average_executed_price", className: e$1 == null ? void 0 : e$1.className, width: e$1 == null ? void 0 : e$1.width, onSort: e$1 == null ? void 0 : e$1.enableSort, render: (t, r3) => $$5(t) };
}
function je$3(e$1) {
  return { title: e2.t("common.trigger"), className: e$1 == null ? void 0 : e$1.className, dataIndex: "trigger_price", width: e$1 == null ? void 0 : e$1.width, onSort: e$1 == null ? void 0 : e$1.enableSort, renderPlantText: (t, r3) => {
    let o = (r3 == null ? void 0 : r3.algo_order_id) !== void 0, n4 = (r3 == null ? void 0 : r3.algo_type) === "BRACKET";
    return !o || n4 ? "--" : $$5(t);
  }, render: (t, r3) => jsx(Gr$1, { order: r3, disableEdit: e$1 == null ? void 0 : e$1.disableEdit }) };
}
function co$3(e$1) {
  return { title: (e$1 == null ? void 0 : e$1.title) ?? e2.t("common.trigger"), className: e$1 == null ? void 0 : e$1.className, dataIndex: "tpsl_trigger_price", width: e$1 == null ? void 0 : e$1.width, onSort: e$1 == null ? void 0 : e$1.enableSort, renderPlantText: (t, r3) => {
    var _a2;
    let o = (_a2 = e$1 == null ? void 0 : e$1.symbolsInfo) == null ? void 0 : _a2[r3.symbol], n4 = o == null ? void 0 : o("quote_dp"), { sl_trigger_price: i, tp_trigger_price: a2 } = !("algo_type" in r3) || !Array.isArray(r3.child_orders) ? {} : utils_exports.findTPSLFromOrder(r3), s = (a2 != null ? `${e2.t("tpsl.tp")}: ${$$5(a2, { fix: n4, padEnd: true })}` : "") + (i != null ? `${a2 ? `
` : ""}${e2.t("tpsl.sl")}: ${$$5(i, { fix: n4, padEnd: true })}` : "");
    return s.length > 0 ? s : "--";
  }, render: (t, r3) => jsx(eo$1, {}) };
}
function oa(e$1) {
  return { title: e2.t("common.tpsl"), className: e$1 == null ? void 0 : e$1.className, dataIndex: "bracketOrderPrice", width: e$1 == null ? void 0 : e$1.width, onSort: e$1 == null ? void 0 : e$1.enableSort, renderPlantText: (t, r3) => {
    let o = () => !("algo_type" in r3) || !Array.isArray(r3.child_orders) ? {} : utils_exports.findTPSLFromOrder(r3.child_orders[0]), { sl_trigger_price: n4, tp_trigger_price: i } = o(), a2 = (i != null ? `${e2.t("tpsl.tp")}: ${i}` : "") + (n4 != null ? `${i ? `
` : ""}${e2.t("tpsl.sl")}: ${n4}` : "");
    return a2.length > 0 ? a2 : "--";
  }, render: (t, r3) => jsx(no$2, { order: r3 }) };
}
function ze$3(e$1) {
  return { title: e2.t("common.notional"), dataIndex: "executed", width: e$1 == null ? void 0 : e$1.width, className: e$1 == null ? void 0 : e$1.className, onSort: (e$1 == null ? void 0 : e$1.enableSort) ?? false ? (t, r3, o) => {
    let n4 = t.type === OrderType.CLOSE_POSITION && t.status !== OrderStatus.FILLED || t.total_executed_quantity === 0 || Number.isNaN(t.average_executed_price) || t.average_executed_price === null ? 0 : t.total_executed_quantity * t.average_executed_price, i = r3.type === OrderType.CLOSE_POSITION && r3.status !== OrderStatus.FILLED || r3.total_executed_quantity === 0 || Number.isNaN(r3.average_executed_price) || r3.average_executed_price === null ? 0 : r3.total_executed_quantity * r3.average_executed_price;
    return ot$2(n4, i);
  } : void 0, renderPlantText: (t, r3) => $t$3(r3, (e$1 == null ? void 0 : e$1.isPending) ?? false) === "Entire position" ? e2.t("tpsl.entirePosition") : $$5($t$3(r3, (e$1 == null ? void 0 : e$1.isPending) ?? false), { fix: 2 }), render: (t, r3) => {
    let o = $t$3(r3, (e$1 == null ? void 0 : e$1.isPending) ?? false);
    return o === "Entire position" ? e2.t("tpsl.entirePosition") : jsx($$4.numeral, { rm: g$6.ROUND_DOWN, dp: 2, children: o });
  } };
}
function zt$2(e$1) {
  return { title: e2.t("common.realizedPnl"), dataIndex: "realized_pnl", width: e$1 == null ? void 0 : e$1.width, className: e$1 == null ? void 0 : e$1.className, renderPlantText: (t, r3) => {
    var _a2;
    let o = (_a2 = e$1 == null ? void 0 : e$1.symbolsInfo) == null ? void 0 : _a2[r3.symbol], n4 = o == null ? void 0 : o("quote_dp"), i = (e$1 == null ? void 0 : e$1.pnlNotionalDecimalPrecision) ?? n4, a2 = new g$6(t ?? 0).toDecimalPlaces(i, g$6.ROUND_DOWN).toNumber(), s = $$5(a2);
    return a2 > 0 ? `+${s}` : s;
  }, render: (t, r3) => {
    let { quote_dp: o } = W$1(), n4 = (e$1 == null ? void 0 : e$1.pnlNotionalDecimalPrecision) ?? o, i = new g$6(t ?? 0).toDecimalPlaces(n4, g$6.ROUND_DOWN).toNumber();
    return jsxs(z$1, { gap: 1, children: [jsx($$4.numeral, { dp: n4, rm: g$6.ROUND_DOWN, padding: false, intensity: (i ?? 0) == 0 ? 80 : void 0, showIdentifier: (i ?? 0) > 0, coloring: (i ?? 0) != 0, children: i ?? "--" }), !(e$1 == null ? void 0 : e$1.hideShare) && jsx(Ze$1, { order: r3, sharePnLConfig: e$1 == null ? void 0 : e$1.sharePnLConfig, modalId: jt$4 })] });
  } };
}
function we$2(e$1) {
  return { title: e2.t("orderEntry.reduceOnly"), dataIndex: "reduce_only", width: e$1 == null ? void 0 : e$1.width, className: e$1 == null ? void 0 : e$1.className, renderPlantText: (t, r3) => t ? e2.t("common.yes") : e2.t("common.no"), render: (t) => jsx($$4, { children: t ? e2.t("common.yes") : e2.t("common.no") }) };
}
function $e$2(e$1) {
  return { title: e2.t("orders.column.hidden"), dataIndex: "visible", width: e$1 == null ? void 0 : e$1.width, className: e$1 == null ? void 0 : e$1.className, renderPlantText: (t, r3) => t !== 0 ? e2.t("common.no") : e2.t("common.yes"), render: (t, r3) => jsx($$4, { children: r3.visible_quantity !== 0 ? e2.t("common.no") : e2.t("common.yes") }) };
}
function Ue$3(e$1) {
  return { title: e2.t("orders.column.orderTime"), dataIndex: "created_time", width: e$1 == null ? void 0 : e$1.width, onSort: e$1 == null ? void 0 : e$1.enableSort, className: e$1 == null ? void 0 : e$1.className, renderPlantText: (t, r3) => {
    let o = new Date(t);
    return format(o, "yyyy-MM-dd HH:mm:ss");
  }, render: (t) => jsx($$4.formatted, { rule: "date", formatString: (e$1 == null ? void 0 : e$1.formatString) || "yyyy-MM-dd HH:mm:ss", className: "oui-break-normal oui-whitespace-nowrap oui-font-semibold", children: t }) };
}
function et$1(e$1) {
  return { title: e2.t("common.fee"), dataIndex: "total_fee", width: e$1 == null ? void 0 : e$1.width, onSort: e$1 == null ? void 0 : e$1.enableSort, className: e$1 == null ? void 0 : e$1.className };
}
function na(e$1) {
  return { title: e2.t("common.notional"), dataIndex: "executed", width: e$1 == null ? void 0 : e$1.width, onSort: e$1 == null ? void 0 : e$1.enableSort, className: e$1 == null ? void 0 : e$1.className, renderPlantText: (t, r3) => r3.algo_type === AlgoOrderRootType.POSITIONAL_TP_SL ? e2.t("tpsl.entirePosition") : $$5(r3.quantity === 0 ? "--" : `${new g$6(r3.mark_price).mul(r3.quantity).todp(2).toNumber()}`), render: (t, r3) => r3.algo_type === AlgoOrderRootType.POSITIONAL_TP_SL ? e2.t("tpsl.entirePosition") : jsx($$4.numeral, { className: "oui-break-normal oui-whitespace-nowrap oui-font-semibold", children: r3.quantity === 0 ? "--" : `${new g$6(r3.mark_price).mul(r3.quantity).todp(2).toNumber()}` }) };
}
function tt$1(e$1) {
  let t = { [OrderStatus.NEW]: e2.t("orders.status.pending"), [OrderStatus.FILLED]: e2.t("orders.status.filled"), [OrderStatus.PARTIAL_FILLED]: e2.t("orders.status.partialFilled"), [OrderStatus.CANCELLED]: e2.t("orders.status.canceled"), [OrderStatus.REJECTED]: e2.t("orders.status.rejected"), [OrderStatus.INCOMPLETE]: e2.t("orders.status.incomplete"), [OrderStatus.COMPLETED]: e2.t("orders.status.completed") };
  return { title: e2.t("common.status"), dataIndex: "status", width: e$1 == null ? void 0 : e$1.width, onSort: e$1 == null ? void 0 : e$1.enableSort, className: e$1 == null ? void 0 : e$1.className, renderPlantText: (r3, o) => {
    let n4 = r3 || o.algo_status;
    return t[n4] || Te(n4);
  }, render: (r3, o) => {
    let n4 = r3 || o.algo_status;
    return t[n4] || Te(n4);
  } };
}
function ft$1(e$1) {
  return { title: e2.t("common.avgOpen"), dataIndex: "average_executed_price", width: e$1 == null ? void 0 : e$1.width, onSort: (e$1 == null ? void 0 : e$1.enableSort) ?? false ? (t, r3) => ot$2(t.average_executed_price ?? 0, r3.average_executed_price ?? 0) : void 0, className: e$1 == null ? void 0 : e$1.className, render: (t, r3) => r3.type === OrderType.MARKET && !t ? "--" : jsx($$4.numeral, { className: "oui-break-normal oui-whitespace-nowrap oui-font-semibold", children: t }), renderPlantText: (t, r3) => $$5(t, { fix: 2 }) };
}
function mo$1(e3) {
  return { title: "", type: "action", dataIndex: "action", width: e3 == null ? void 0 : e3.width, className: e3 == null ? void 0 : e3.className, align: "right", fixed: "right", render: (t, r3) => r3.status === OrderStatus.CANCELLED ? jsx(Jr$2, { record: r3 }) : r3.status === OrderStatus.NEW || r3.algo_status === OrderStatus.NEW ? jsx(mt$2, { order: r3 }) : null };
}
function ia(e3) {
  return { title: "", type: "action", dataIndex: "action", width: e3 == null ? void 0 : e3.width, className: e3 == null ? void 0 : e3.className, align: "right", fixed: "right", render: (t, r3) => jsx(mt$2, { order: r3 }) };
}
function aa$1(e3) {
  return { title: "", type: "action", dataIndex: "action", width: e3 == null ? void 0 : e3.width, className: e3 == null ? void 0 : e3.className, align: "right", fixed: "right", render: (t, r3) => jsxs(z$1, { gap: 3, children: [jsx(io$3, { order: r3 }), jsx(mt$2, { order: r3 })] }) };
}
function ot$2(e3, t) {
  return e3 > t ? 1 : e3 < t ? -1 : 0;
}
function $t$3(e$1, t) {
  return t ? e$1.price && e$1.quantity ? new g$6(e$1.price).mul(e$1.quantity).toFixed(2, g$6.ROUND_DOWN) : "--" : e$1.type === OrderType.CLOSE_POSITION && e$1.status !== OrderStatus.FILLED ? e2.t("tpsl.entirePosition") : e$1.total_executed_quantity === 0 || Number.isNaN(e$1.average_executed_price) || e$1.average_executed_price === null ? "--" : `${e$1.total_executed_quantity * e$1.average_executed_price}`;
}
var Po$1 = (e3) => {
  let { item: t } = e3, r3 = t.side === OrderSide.BUY, { t: o } = Z$2();
  return jsx($$4.formatted, { intensity: 80, rule: "symbol", formatString: "base-type", size: "sm", prefix: jsx(od, { color: r3 ? "success" : "danger", size: "xs", children: o(r3 ? "common.buy" : "common.sell") }), onClick: () => {
    var _a2;
    (_a2 = e3.onSymbolChange) == null ? void 0 : _a2.call(e3, { symbol: t.symbol });
  }, children: t.symbol });
}, xo$1 = (e3) => {
  var _a2;
  let { item: t } = e3;
  useCallback(() => {
    let o = typeof t.type == "string" ? t.type.replace("_ORDER", "").toLowerCase() : t.type;
    return t.algo_order_id && t.algo_type !== AlgoOrderRootType.BRACKET ? `Stop ${o}` : Te(t.type);
  }, [t]);
  return jsx(z$1, { direction: "row", gap: 1, children: (_a2 = ue$3(e3.item)) == null ? void 0 : _a2.map((o, n4) => jsx(od, { color: o.toLocaleLowerCase() === "position" ? "primary" : "neutral", size: "xs", children: o }, n4)) });
}, So$3 = (e3) => {
  let { item: t } = e3;
  return jsx($$4.formatted, { rule: "date", formatString: "yyyy-MM-dd hh:mm:ss", intensity: 36, size: "2xs", children: t.updated_time });
}, _o$1 = (e3) => {
  let { item: t } = e3, { t: r3 } = Z$2(), o = t.status || t.algo_status, n4 = useMemo(() => ({ [OrderStatus.NEW]: r3("orders.status.pending"), [OrderStatus.FILLED]: r3("orders.status.filled"), [OrderStatus.PARTIAL_FILLED]: r3("orders.status.partialFilled"), [OrderStatus.CANCELLED]: r3("orders.status.canceled"), [OrderStatus.REJECTED]: r3("orders.status.rejected"), [OrderStatus.INCOMPLETE]: r3("orders.status.incomplete"), [OrderStatus.COMPLETED]: r3("orders.status.completed") }), [r3]);
  return jsx($$4.formatted, { intensity: 80, size: "2xs", children: n4[o] || Te(o) });
}, Kt$1 = (e3) => {
  let { item: t } = e3, { t: r3 } = Z$2(), o = t.type === OrderType.CLOSE_POSITION && (t == null ? void 0 : t.status) !== OrderStatus.FILLED;
  return jsx(da$2, { label: r3("common.qty"), classNames: { root: "oui-text-xs", label: "oui-text-2xs" }, children: jsx($$4.numeral, { dp: e3.base_dp, padding: false, coloring: true, placeholder: r3("tpsl.entirePosition"), intensity: 80, children: o ? r3("tpsl.entirePosition") : t.quantity }) });
}, Qt$3 = (e3) => {
  let { item: t } = e3, { t: r3 } = Z$2();
  return jsx(da$2, { label: jsx($$4, { children: r3("orders.status.filled") }), classNames: { root: "oui-text-xs", label: "oui-text-2xs" }, children: jsx($$4.numeral, { dp: e3.base_dp, intensity: 80, padding: false, rm: g$6.ROUND_DOWN, children: t.total_executed_quantity }) });
};
var Oo$1 = (e3) => {
  let { item: t } = e3, { t: r3 } = Z$2(), o = useMemo(() => t.price && t.quantity ? new g$6(t.price).mul(t.quantity).toFixed(e3.quote_dp, g$6.ROUND_DOWN) : "--", [t.price, t.quantity]);
  return jsx(da$2, { align: "end", label: jsxs($$4, { children: [r3("common.notional"), jsx($$4, { intensity: 20, children: "(USDC)" })] }), classNames: { root: "oui-text-xs", label: "oui-text-2xs" }, children: jsx($$4.numeral, { dp: e3.quote_dp, coloring: true, intensity: 80, padding: false, rm: g$6.ROUND_DOWN, children: o }) });
}, Ht$3 = (e3) => {
  let { item: t } = e3, { t: r3 } = Z$2();
  return jsx(da$2, { label: r3("orders.column.triggerPrice"), classNames: { root: "oui-text-xs", label: "oui-text-2xs" }, align: e3.align, children: jsx($$4.numeral, { dp: e3.quote_dp, intensity: 80, padding: false, rm: g$6.ROUND_DOWN, children: t.trigger_price ?? "--" }) });
}, ho$3 = (e3) => {
  let { item: t } = e3, { t: r3 } = Z$2();
  return jsx(da$2, { label: r3("common.markPrice"), align: "end", classNames: { root: "oui-text-xs", label: "oui-text-2xs" }, children: jsx($$4.numeral, { dp: e3.quote_dp, rm: g$6.ROUND_DOWN, intensity: 80, padding: false, children: t.mark_price }) });
}, Co$4 = (e3) => {
  let { item: t } = e3, { t: r3 } = Z$2(), o = (t == null ? void 0 : t.algo_order_id) !== void 0, n4 = (t == null ? void 0 : t.type) === "MARKET" && o;
  return jsx(da$2, { label: r3("common.limitPrice"), classNames: { root: "oui-text-xs", label: "oui-text-2xs" }, children: n4 ? jsx($$4, { children: r3("common.marketPrice") }) : jsx($$4.numeral, { dp: e3.quote_dp, rm: g$6.ROUND_DOWN, intensity: 80, padding: false, children: t.price ?? "--" }) });
}, To = (e3) => {
  let { tp_trigger_price: t, tpPnL: r3 } = G$1(), { t: o } = Z$2();
  return jsx(da$2, { label: o("tpsl.tpTrigger"), classNames: { root: "oui-text-xs", label: "oui-text-2xs" }, children: jsx(yt$2, { content: r3 && jsx($$4.numeral, { size: "2xs", showIdentifier: true, prefix: jsxs($$4, { intensity: 54, children: [`${o("tpsl.tpPnl")}:`, ""] }), suffix: jsx($$4, { intensity: 20, children: "USDC" }), coloring: true, children: r3 }), classNames: { content: "oui-bg-base-6 oui-ml-2", arrow: "oui-fill-base-6" }, children: jsx($$4.numeral, { dp: e3.quote_dp, rm: g$6.ROUND_DOWN, color: "buy", padding: false, className: t ? "oui-border-b oui-border-dashed oui-border-base-contrast-12" : void 0, children: t ?? "--" }) }) });
}, Lo$2 = (e3) => {
  let { sl_trigger_price: t, slPnL: r3 } = G$1(), { t: o } = Z$2();
  return jsx(da$2, { label: o("tpsl.slTrigger"), classNames: { root: "oui-text-xs", label: "oui-text-2xs" }, children: jsx(yt$2, { content: r3 && jsx($$4.numeral, { size: "2xs", prefix: jsxs($$4, { intensity: 54, children: [`${o("tpsl.slPnl")}:`, ""] }), suffix: jsx($$4, { intensity: 20, children: "USDC" }), coloring: true, children: r3 }), classNames: { content: "oui-bg-base-6 oui-ml-2", arrow: "oui-fill-base-6" }, children: jsx($$4.numeral, { dp: e3.quote_dp, rm: g$6.ROUND_DOWN, color: "sell", padding: false, className: t ? "oui-border-b oui-border-dashed oui-border-base-contrast-12" : void 0, children: t ?? "--" }) }) });
}, No$3 = (e3) => {
  let { t } = Z$2();
  return jsx(da$2, { label: t("tpsl.tpPrice"), classNames: { root: "oui-text-xs", label: "oui-text-2xs" }, children: jsx($$4, { intensity: 80, children: t("common.marketPrice") }) });
}, wo$2 = (e3) => {
  let { t } = Z$2();
  return jsx(da$2, { label: t("tpsl.slPrice"), classNames: { root: "oui-text-xs", label: "oui-text-2xs" }, children: jsx($$4, { intensity: 80, children: t("common.marketPrice") }) });
}, Io$3 = (e3) => {
  let { item: t } = e3, { t: r3 } = Z$2(), o = useMemo(() => t.algo_type === AlgoOrderRootType.POSITIONAL_TP_SL ? jsx("span", { className: "oui-text-base-contrast-80", children: r3("tpsl.entirePosition") }) : jsx($$4.numeral, { dp: e3.quote_dp, rm: g$6.ROUND_DOWN, intensity: 80, padding: false, children: t.quantity }), [t, r3]);
  return jsx(da$2, { label: r3("common.quantity"), classNames: { root: "oui-text-xs", label: "oui-text-2xs" }, align: "end", children: o });
}, Eo$1 = (e3) => {
  var _a2;
  let { t } = Z$2();
  return jsx(da$2, { label: jsxs($$4, { children: [t("common.avgPrice"), jsx($$4, { intensity: 20, children: "(USDC)" })] }), classNames: { root: "oui-text-xs", label: "oui-text-2xs" }, children: jsx($$4.numeral, { dp: e3.quote_dp, rm: g$6.ROUND_DOWN, intensity: 80, padding: false, children: ((_a2 = e3.item) == null ? void 0 : _a2.average_executed_price) ?? "--" }) });
}, vo$3 = (e3) => {
  var _a2;
  let { t } = Z$2();
  return jsx(da$2, { label: jsxs($$4, { children: [t("orders.column.orderPrice"), jsx($$4, { intensity: 20, children: "(USDC)" })] }), classNames: { root: "oui-text-xs", label: "oui-text-2xs" }, children: jsx($$4.numeral, { dp: e3.quote_dp, rm: g$6.ROUND_DOWN, intensity: 80, padding: false, placeholder: t("common.marketPrice"), children: ((_a2 = e3.item) == null ? void 0 : _a2.price) ?? "--" }) });
}, Ao$3 = (e3) => {
  var _a2;
  let t = (_a2 = e3 == null ? void 0 : e3.item) == null ? void 0 : _a2.realized_pnl, { t: r3 } = Z$2();
  return jsx(da$2, { label: jsxs($$4, { children: [r3("common.realizedPnl"), jsx($$4, { intensity: 20, children: "(USDC)" })] }), classNames: { root: "oui-text-xs", label: "oui-text-2xs" }, align: "end", children: jsxs(z$1, { gap: 1, children: [jsx($$4.numeral, { dp: e3.quote_dp, rm: g$6.ROUND_DOWN, padding: false, intensity: (t ?? 0) == 0 ? 80 : void 0, showIdentifier: (t ?? 0) > 0, coloring: (t ?? 0) != 0, children: t ?? "--" }), jsx(Ze$1, { order: e3.item, sharePnLConfig: e3.sharePnLConfig, modalId: eo$3, iconSize: 12 })] }) });
}, yt$2 = (e3) => {
  let { classNames: t, content: r3 } = e3, [o, n4] = useState(false);
  return typeof r3 > "u" ? e3.children : jsx(Xn$2, { content: r3, className: t == null ? void 0 : t.content, open: o, onOpenChange: n4, arrow: { className: t == null ? void 0 : t.arrow }, children: jsx("div", { onClick: () => n4((i) => !i), children: e3.children }) });
};
var Vt$1 = (e3) => {
  let { t } = Z$2(), { item: r3 } = e3;
  r3.quantity > 0;
  return jsx(Fragment$1, { children: jsx(_e$5, { variant: "outlined", fullWidth: true, color: "secondary", size: "sm", className: "oui-border-base-contrast-36", onClick: () => {
    e3.onShowEditSheet();
  }, children: t("common.edit") }) });
};
var ko$2 = (e3) => {
  var _a2;
  let { side: t } = e3.item, { price: r3, quantity: o, triggerPrice: n4, isAlgoOrder: i } = e3, a2 = t === OrderSide.BUY, { t: s } = Z$2();
  return jsxs("div", { className: "oui-pt-2", children: [jsx($$4, { intensity: 80, children: `You agree to edit your ${e3.base}-PERP order.` }), jsxs(z$1, { gap: 2, mb: 3, mt: 2, justify: "between", children: [jsx($$4.formatted, { rule: "symbol", formatString: "base-type", size: "base", showIcon: true, children: e3.item.symbol }), jsxs(z$1, { direction: "row", gap: 1, children: [(_a2 = ue$3(e3.item)) == null ? void 0 : _a2.map((d2, u2) => jsx(od, { color: d2.toLocaleLowerCase() === "position" ? "primary" : "neutral", size: "xs", children: d2 }, u2)), a2 && jsx(od, { color: "success", size: "xs", children: s("common.buy") }), !a2 && jsx(od, { color: "danger", size: "xs", children: s("common.sell") })] })] }), jsx(te$6, {}), jsxs(z$1, { direction: "column", gap: 1, width: "100%", className: "oui-text-sm oui-text-base-contrast-54", py: 3, children: [i && jsxs(z$1, { justify: "between", width: "100%", gap: 1, children: [jsx($$4, { children: s("orders.column.triggerPrice") }), jsx($$4.numeral, { intensity: 80, dp: e3.quote_dp, padding: false, rm: g$6.ROUND_DOWN, suffix: jsx($$4, { intensity: 54, children: " USDC" }), children: n4 ?? "--" })] }), jsxs(z$1, { justify: "between", width: "100%", gap: 1, children: [jsx($$4, { children: s("common.price") }), jsx($$4.numeral, { intensity: 80, dp: e3.quote_dp, padding: false, rm: g$6.ROUND_DOWN, suffix: jsx($$4, { intensity: 54, children: " USDC" }), placeholder: e3.isStopMarket ? s("common.marketPrice") : "--", children: e3.isStopMarket ? s("common.marketPrice") : r3 ?? "--" })] }), jsxs(z$1, { justify: "between", width: "100%", gap: 1, children: [jsx($$4, { children: s("common.qty") }), jsx($$4.numeral, { color: t === OrderSide.BUY ? "buy" : "sell", dp: e3.base_dp, padding: false, rm: g$6.ROUND_DOWN, children: o ?? "--" })] })] }), jsxs(z$1, { className: "oui-gap-[2px]", children: [jsx($r$1, { color: "white", id: "oui-checkbox-disableOrderConfirmation", checked: !e3.orderConfirm, onCheckedChange: (d2) => {
    e3.setOrderConfirm(!d2);
  } }), jsx("label", { className: "oui-text-2xs oui-text-base-contrast-54", htmlFor: "oui-checkbox-disableOrderConfirmation", children: s("orderEntry.disableOrderConfirm") })] })] });
};
var jt$3 = (e3) => {
  var _a2, _b2, _c2;
  let { item: t } = e3, r3 = t.side === OrderSide.BUY, { t: o } = Z$2(), { parseErrorMsg: n4 } = Tr$1(e3.errors), i = n4("order_quantity"), a2 = n4("order_price"), s = n4("trigger_price"), d2 = e3.quantity && e3.maxQty ? Math.min(Number(e3.quantity) / e3.maxQty, 1) : void 0, u2 = (l2) => {
    let b2 = e3.baseTick;
    if (b2 && b2 > 0) {
      let m2 = utils_exports.formatNumber(l2, b2) ?? l2;
      e3.setQuantity(m2);
    }
  };
  return jsxs(Fragment$1, { children: [jsxs(z$1, { direction: "column", gap: 3, width: "100%", itemAlign: "start", className: "oui-text-sm", children: [jsxs(z$1, { width: "100%", justify: "between", children: [jsx($$4.formatted, { rule: "symbol", showIcon: true, intensity: 80, children: t.symbol }), jsxs(z$1, { direction: "row", gap: 1, children: [(_a2 = ue$3(e3.item)) == null ? void 0 : _a2.map((l2, b2) => jsx(od, { color: l2.toLocaleLowerCase() === "position" ? "primary" : "neutral", size: "xs", children: l2 }, b2)), r3 && jsx(od, { color: "success", size: "xs", children: o("common.buy") }), !r3 && jsx(od, { color: "danger", size: "xs", children: o("common.sell") })] })] }), jsx(te$6, { intensity: 8, className: "oui-w-full" }), jsxs(z$1, { width: "100%", justify: "between", children: [jsx($$4, { children: o("common.lastPrice") }), jsx($$4.numeral, { dp: (_c2 = (_b2 = e3.item) == null ? void 0 : _b2.symbolInfo) == null ? void 0 : _c2.duote_dp, children: e3.curMarkPrice ?? "--" })] }), jsxs(z$1, { width: "100%", direction: "column", itemAlign: "stretch", gap: 2, children: [e3.isAlgoOrder && jsx(So$4.tooltip, { prefix: jsx($$4, { intensity: 54, className: "oui-px-3", children: o("orders.column.triggerPrice") }), suffix: jsx($$4, { intensity: 54, className: "oui-px-3", children: e3.quote }), color: s ? "danger" : void 0, align: "right", fullWidth: true, autoComplete: "off", formatters: [Xr$1.numberFormatter, Xr$1.dpFormatter(e3.quote_dp)], value: e3.triggerPrice, onValueChange: (l2) => e3.setTriggerPrice(l2), tooltip: s, tooltipProps: { content: { className: "oui-bg-base-6 oui-text-base-contrast-80" }, arrow: { className: "oui-fill-base-6" } }, classNames: { input: "oui-text-base-contrast-98 oui-w-full", root: cnBase("oui-outline-line-12", s && "oui-outline-danger") } }), jsx(So$4.tooltip, { prefix: jsx($$4, { intensity: 54, className: "oui-px-3", children: o("common.price") }), suffix: jsx($$4, { intensity: 54, className: "oui-px-3", children: e3.quote }), color: a2 ? "danger" : void 0, align: "right", fullWidth: true, autoComplete: "off", formatters: [Xr$1.numberFormatter, Xr$1.dpFormatter(e3.quote_dp)], disabled: !e3.priceEdit, value: e3.isStopMarket ? o("orderEntry.orderType.market") : e3.price, onValueChange: (l2) => e3.setPrice(l2), tooltip: a2, tooltipProps: { content: { className: "oui-bg-base-5" }, arrow: { className: "oui-fill-base-5" } }, classNames: { input: "oui-text-base-contrast-98", root: cnBase("oui-outline-line-12", a2 && "oui-outline-danger") } }), jsx(So$4.tooltip, { prefix: jsx($$4, { intensity: 54, className: "oui-px-3", children: o("common.quantity") }), suffix: jsx($$4, { intensity: 54, className: "oui-px-3", children: e3.base }), color: i ? "danger" : void 0, align: "right", fullWidth: true, autoComplete: "off", formatters: [Xr$1.numberFormatter, Xr$1.dpFormatter(e3.base_dp)], value: e3.quantity, onValueChange: (l2) => {
    e3.setQuantity(l2);
  }, onBlur: (l2) => u2(l2.target.value), tooltip: i, tooltipProps: { content: { className: "oui-bg-base-6" }, arrow: { className: "oui-fill-base-6" } }, classNames: { input: "oui-text-base-contrast-98", root: cnBase("oui-outline-line-12", i && "oui-outline-danger") } }), jsx(Bl, { markCount: 4, value: [e3.sliderValue ?? 0], onValueChange: (l2) => {
    e3.setSliderValue(l2[0]);
  }, color: "primary" }), jsxs(z$1, { width: "100%", justify: "between", children: [jsx($$4.numeral, { color: "primary", size: "2xs", dp: 2, padding: false, rule: "percentages", children: `${d2 ?? 0}` }), jsxs(z$1, { gap: 1, children: [jsx($$4, { size: "2xs", color: "primary", children: o("common.max") }), jsx($$4.numeral, { intensity: 54, size: "2xs", dp: e3.base_dp, children: e3.maxQty })] })] })] }), jsxs(z$1, { width: "100%", gap: 3, mt: 2, children: [jsx(_e$5, { fullWidth: true, color: "secondary", onClick: (l2) => {
    e3.onClose();
  }, children: o("common.cancel") }), jsx(dr$3, { fullWidth: true, onClick: (l2) => {
    l2.stopPropagation(), l2.preventDefault(), e3.onSheetConfirm();
  }, loading: e3.submitting, disabled: !e3.isChanged, children: o("common.confirm") })] })] }), jsx(me$4, { open: e3.dialogOpen, onOpenChange: e3.setDialogOpen, title: o("orders.editOrder"), size: "xs", actions: { primary: { label: o("common.confirm"), onClick: e3.onDialogConfirm, loading: e3.submitting, fullWidth: true }, secondary: { label: o("common.cancel"), onClick: e3.onCloseDialog, fullWidth: true } }, classNames: { content: "oui-pb-4", body: "oui-p-0", footer: "oui-pt-3 oui-pb-0" }, children: jsx(ko$2, { ...e3 }) })] });
};
var or$1 = (e3) => {
  let { state: t, editAlgoOrder: r3, editOrder: o, autoCheckInput: n4 = true, position: i } = e3, { item: a2 } = t, { hide: s } = X$5(), [d2, u2] = useState(false), l2 = (a2 == null ? void 0 : a2.algo_order_id) !== void 0 && a2.algo_type !== AlgoOrderRootType.BRACKET, b2 = (a2 == null ? void 0 : a2.type) === "MARKET" && l2;
  b2 || (a2 == null ? void 0 : a2.type) === "MARKET";
  let [O2, _2] = useState(false), I2 = useMemo(() => l2 && a2.algo_type !== AlgoOrderRootType.BRACKET ? `STOP_${a2.type}` : a2.type, [a2, l2]), [h2, F2] = useLocalStorage("orderly_order_confirm", true), { base_dp: T2, base_tick: V2 } = e3.state, { formattedOrder: f2, setValue: w5, markPrice: R2, errors: x2, validate: C2, maxQty: D2 } = ka$1({ order: a2, orderType: I2, position: i }), te2 = () => {
    C2().then((y2) => {
      h2 ? u2(true) : A2(f2);
    }, (y2) => {
      var _a2;
      ((_a2 = y2 == null ? void 0 : y2.total) == null ? void 0 : _a2.message) && toast$2.error(y2 == null ? void 0 : y2.total.message);
    }).catch((y2) => {
    });
  }, E3 = useCallback(() => {
    u2(false);
  }, []), Y2 = () => f2 ? A2(f2) : Promise.reject(), v2 = useCallback(() => {
    s();
  }, []), A2 = useCallback(async (y2) => {
    let k2, Ce2 = a2.visible_quantity !== void 0 ? a2.visible_quantity === 0 : a2.visible !== void 0 ? a2.visible === 0 : false;
    if (a2.algo_order_id !== void 0) {
      if (b2 && "order_price" in y2) {
        let { order_price: Fe2, ...Ot2 } = y2;
        y2 = Ot2;
      }
      k2 = r3(a2.algo_order_id.toString(), { ...y2 });
    } else k2 = o(a2.order_id.toString(), { ...y2, ...Ce2 ? { visible_quantity: 0 } : {} });
    try {
      _2(true);
      let Fe2 = await k2;
      v2();
    } catch (Fe2) {
      toast$2.error((Fe2 == null ? void 0 : Fe2.message) ?? `${Fe2}`);
    } finally {
      _2(false);
    }
  }, [r3, o]), re2 = useMemo(() => {
    let y2 = f2.order_quantity;
    return y2 && Number(y2) !== 0 && D2 !== 0 ? new g$6(y2).div(D2).mul(100).toDecimalPlaces(2, g$6.ROUND_DOWN).toNumber() : 0;
  }, [f2.order_quantity, D2]), de2 = a2.price != f2.order_price || a2.quantity != f2.order_quantity || a2.trigger_price != f2.trigger_price, De2 = useThrottledCallback((y2) => {
    let k2 = new g$6(y2).div(100).mul(D2).toDecimalPlaces(T2, g$6.ROUND_DOWN).toNumber();
    w5("order_quantity", utils_exports.formatNumber(k2, V2));
  }, 50, {}), g2 = (y2, k2) => {
    w5(y2, k2);
  };
  return { ...t, curMarkPrice: R2, isAlgoOrder: l2, isStopMarket: b2, price: f2.order_price, setPrice: (y2) => g2("order_price", y2), priceEdit: !b2, triggerPrice: f2.trigger_price, setTriggerPrice: (y2) => g2("trigger_price", y2), quantity: f2.order_quantity, setQuantity: (y2) => {
    g2("order_quantity", y2);
  }, maxQty: D2, sliderValue: re2, setSliderValue: De2, onClose: v2, onSheetConfirm: te2, errors: x2, orderType: I2, isChanged: de2, baseTick: V2, dialogOpen: d2, setDialogOpen: u2, onDialogConfirm: Y2, onCloseDialog: E3, submitting: O2, orderConfirm: h2, setOrderConfirm: F2 };
}, ka$1 = (e3) => {
  let { order: t, orderType: r3, position: o } = e3, [n4, i] = useState({ side: t.side, order_type: r3, order_price: t.price, order_quantity: t.quantity, trigger_price: t.trigger_price, reduce_only: t.reduce_only, symbol: t.symbol }), { reduce_only: a2 } = t, s = o == null ? void 0 : o.position_qty, d2 = useMaxQty(t.symbol, t.side, t.reduce_only), u2 = useMemo(() => a2 ? Math.abs(s ?? 0) : t.quantity + Math.abs(d2), [t.quantity, d2, a2, s]), { symbolInfo: l2, markPrice: b2, errors: m2, validate: O2 } = useOrderEntity({ ...n4, symbol: t.symbol }, { maxQty: u2 });
  return { symbolInfo: l2, markPrice: b2, errors: m2, validate: O2, setValue: (I2, h2) => {
    i((F2) => ({ ...F2, [I2]: h2 }));
  }, formattedOrder: n4, maxQty: u2 };
};
var nr = (e3) => {
  let t = or$1(e3);
  return jsx(jt$3, { ...t });
};
var ir$2 = (e3) => {
  let { state: t } = e3, { t: r3 } = Z$2(), { editAlgoOrder: o, editOrder: n4 } = X(), { order: i, position: a2 } = G$1(), s = useCallback(() => {
    e3.state.type === "tp_sl" ? uo$3.sheet({ title: r3("common.tpsl"), content: jsx(Lt, { isEditing: true, order: e3.state.item, position: a2, symbolInfo: e3.state.origin }) }).catch((d2) => {
    }) : uo$3.sheet({ title: r3("orders.editOrder"), classNames: { content: "oui-bg-base-8" }, content: jsx(nr, { position: a2, state: t, editAlgoOrder: o, editOrder: n4 }) }).catch((d2) => {
    });
  }, [t]);
  return { ...t, onShowEditSheet: s };
};
var ar = (e3) => {
  let t = ir$2(e3);
  return jsx(Vt$1, { ...t });
};
var lr$3 = (e3) => {
  let { t } = Z$2();
  return jsxs(Fragment$1, { children: [jsx(_e$5, { variant: "outlined", fullWidth: true, color: "secondary", size: "sm", className: "oui-border-base-contrast-36", onClick: (r3) => e3.setOpen(true), children: t("common.cancel") }), e3.open && jsx(me$4, { size: "xs", open: e3.open, onOpenChange: e3.setOpen, title: t("orders.cancelOrder"), actions: { primary: { label: t("common.confirm"), loading: e3.isLoading, fullWidth: true, size: "md", onClick: (r3) => {
    e3.onCancel(r3);
  } }, secondary: { label: t("common.cancel"), fullWidth: true, size: "md", onClick: () => {
    e3.onClose();
  } } }, children: jsx($$4, { size: "2xs", intensity: 54, children: t("orders.cancelOrder.description") }) })] });
};
var dr$2 = (e3) => {
  let { state: t } = e3, [r3, o] = useState(false), { onCancelOrder: n4 } = X(), [i, a2] = useState(false);
  return { ...t, open: r3, setOpen: o, onCancel: (u2) => n4 ? (u2 == null ? void 0 : u2.preventDefault(), u2 == null ? void 0 : u2.stopPropagation(), a2(true), n4(t.item).then((l2) => {
    o(false);
  }, (l2) => {
    toast$2.error(l2.message);
  }).finally(() => {
    a2(false);
  })) : Promise.resolve(), onClose: () => {
    o(false);
  }, isLoading: i };
};
var ur$2 = (e3) => {
  let t = dr$2(e3);
  return jsx(lr$3, { ...t });
};
var mr$2 = (e3) => {
  var _a2, _b2, _c2, _d2;
  let { t } = Z$2();
  return !e3.sl_trigger_price && !e3.tp_trigger_price ? jsx(Fragment$1, {}) : jsx(Fragment$1, { children: jsx(yt$2, { classNames: { content: "oui-bg-base-6 oui-ml-2", arrow: "oui-fill-base-6" }, content: jsxs(z$1, { direction: "column", itemAlign: "start", gap: 1, children: [typeof ((_a2 = e3.pnl) == null ? void 0 : _a2.tpPnL) < "u" && jsx($$4.numeral, { prefix: jsxs($$4, { intensity: 80, children: [`${t("tpsl.tpPnl")}:`, " "] }), suffix: jsx($$4, { intensity: 20, children: " USDC" }), dp: e3.quote_dp, color: "buy", showIdentifier: true, children: (_b2 = e3.pnl) == null ? void 0 : _b2.tpPnL }), typeof ((_c2 = e3.pnl) == null ? void 0 : _c2.slPnL) < "u" && jsx($$4.numeral, { prefix: jsxs($$4, { intensity: 80, children: [`${t("tpsl.slPnl")}:`, " "] }), suffix: jsx($$4, { intensity: 20, children: " USDC" }), dp: e3.quote_dp, color: "sell", children: (_d2 = e3.pnl) == null ? void 0 : _d2.slPnL })] }), children: jsx("button", { onClick: () => {
    e3.setOpen(!e3.open);
  }, children: jsxs(z$1, { gap: 1, width: "1", children: [e3.tp_trigger_price && jsx($o$1, { type: "TP", value: e3.tp_trigger_price, quote_dp: e3.quote_dp }), e3.sl_trigger_price && jsx($o$1, { type: "SL", value: e3.sl_trigger_price, quote_dp: e3.quote_dp })] }) }) }) });
}, $o$1 = (e3) => {
  let { type: t, value: r3, quote_dp: o } = e3;
  return r3 ? jsx($$4.numeral, { size: "2xs", className: cnBase("oui-border-b oui-border-dashed oui-border-base-contrast-12", t === "TP" ? "oui-text-trade-profit" : "oui-text-trade-loss"), rule: "price", dp: o, padding: false, rm: g$6.ROUND_DOWN, prefix: jsxs("span", { className: "oui-text-base-contrast-36", children: [`${t} `, ":"] }), children: r3 }, "tp") : jsx(Fragment$1, {});
};
var pr$2 = (e3) => {
  let { item: t, quote_dp: r3, base_dp: o } = e3, [n4, i] = useState(false), { sl_trigger_price: a2, tp_trigger_price: s } = useMemo(() => !("algo_type" in t) || !Array.isArray(t.child_orders) ? {} : utils_exports.findTPSLFromOrder(t.child_orders[0]), [t]), { pnl: d2, roi: u2 } = lt$1(t);
  return { sl_trigger_price: a2, tp_trigger_price: s, pnl: d2, roi: u2, quote_dp: r3, open: n4, setOpen: i };
};
var fr$3 = (e3) => {
  let t = pr$2(e3);
  return jsx(mr$2, { ...t });
};
var gr$2 = (e3) => jsxs(z$1, { direction: "column", width: "100%", gap: 2, itemAlign: "start", className: e3.className, children: [jsx(os, { ...e3 }), jsx(te$6, { intensity: 6, className: "oui-w-full" }), jsx(ns$1, { ...e3 }), e3.type === "pending" && jsx(fr$3, { ...e3 }), e3.type !== "orderHistory" && jsx(is$1, { ...e3 })] }), os = (e3) => jsxs(z$1, { direction: "column", gap: 1, width: "100%", children: [jsxs(z$1, { justify: "between", width: "100%", children: [jsx(Po$1, { ...e3 }), jsx(So$3, { ...e3 })] }), jsxs(z$1, { width: "100%", justify: "between", children: [jsx(xo$1, { ...e3 }), e3.type === "orderHistory" && jsx(_o$1, { ...e3 })] })] }), ns$1 = (e3) => jsx(ia$1, { cols: 3, rows: 2, width: "100%", gap: 1, children: as(e3) }), is$1 = (e3) => jsxs(ia$1, { cols: 3, rows: 1, width: "100%", gap: 2, children: [jsx("div", {}), jsx(ar, { state: e3 }), jsx(ur$2, { state: e3 })] });
function as(e3) {
  switch (e3.type) {
    case "all":
      return jsx(Fragment$1, {});
    case "pending":
      return jsxs(Fragment$1, { children: [jsx(Kt$1, { ...e3 }), jsx(Qt$3, { ...e3 }), jsx(Oo$1, { ...e3 }), jsx(Ht$3, { ...e3 }), jsx(Co$4, { ...e3 }), jsx(ho$3, { ...e3 })] });
    case "tp_sl":
      return jsxs(Fragment$1, { children: [jsx(To, { ...e3 }), jsx(No$3, { ...e3 }), jsx(Io$3, { ...e3 }), jsx(Lo$2, { ...e3 }), jsx(wo$2, { ...e3 })] });
    case "filled":
      return jsx(Fragment$1, {});
    case "cancelled":
      return jsx(Fragment$1, {});
    case "rejected":
      return jsx(Fragment$1, {});
    case "orderHistory":
      return jsxs(Fragment$1, { children: [jsx(Kt$1, { ...e3 }), jsx(Qt$3, { ...e3 }), jsx(Ht$3, { ...e3, align: "end" }), jsx(Eo$1, { ...e3 }), jsx(vo$3, { ...e3 }), jsx(Ao$3, { ...e3 })] });
  }
}
var yr$1 = (e3) => {
  let t = W$1();
  return { ...e3, ...t };
};
var br$1 = (e3) => {
  let { className: t, ...r3 } = e3, o = yr$1(r3);
  return jsx(gr$2, { ...o, className: t });
};
var Pr$1 = (e3) => {
  var _a2;
  let { sharePnLConfig: t, ...r3 } = e3, o = fo$4({ _type: e3.type, onSymbolChange: e3.onSymbolChange, pnlNotionalDecimalPrecision: e3.pnlNotionalDecimalPrecision, sharePnLConfig: t, symbolsInfo: e3.symbolsInfo });
  return jsx(Nt$2, { cancelOrder: e3.cancelOrder, editOrder: e3.updateOrder, cancelAlgoOrder: e3.cancelAlgoOrder, editAlgoOrder: e3.updateAlgoOrder, children: jsxs(z$1, { direction: "column", width: "100%", height: "100%", itemAlign: "start", children: [e3.filterItems.length > 0 && jsx(lm, { items: e3.filterItems, onFilter: (n4) => {
    e3.onFilter(n4);
  }, trailing: ["pending", "tp_sl"].includes(e3.type) && jsx(ys$1, { ...e3 }) }), jsx(dt$3, { columns: o, loading: e3.isLoading, dataSource: e3.dataSource, bordered: true, ignoreLoadingCheck: true, testIds: { body: (_a2 = e3.testIds) == null ? void 0 : _a2.tableBody }, classNames: { header: "oui-h-[38px]", root: "oui-items-start !oui-h-[calc(100%_-_49px)]" }, onRow: (n4, i) => ({ className: cnBase("oui-h-[48px]", ne$2(n4) ? "oui-text-base-contrast-20" : "oui-text-base-contrast-80") }), generatedRowKey: (n4, i) => `${e3.type}${i}${n4.order_id || n4.algo_order_id}_index${i}`, renderRowContainer: (n4, i, a2) => ((e3.type === "tp_sl" || e3.type === "pending") && (a2 = jsx(It, { order: n4, children: a2 })), jsx(Tt$3, { symbol: n4.symbol, children: a2 })), pagination: e3.pagination, manualPagination: e3.manualPagination, features: [js$1.DownloadFeature], getTableInstance: (n4) => {
    e3.tableInstance.current = n4;
  } })] }) });
}, xr$1 = (e3) => {
  var _a2, _b2;
  let { t } = Z$2();
  return jsx(Nt$2, { cancelOrder: e3.cancelOrder, editOrder: e3.updateOrder, cancelAlgoOrder: e3.cancelAlgoOrder, editAlgoOrder: e3.updateAlgoOrder, children: jsxs(ia$1, { cols: 1, rows: 2, className: "oui-grid-rows-[auto,1fr] oui-w-full", gap: 2, children: [e3.showFilter ? jsx(z$1, { gap: 2, p: 2, className: "oui-bg-base-9 oui-rounded-b-xl", children: e3.filterItems.map((r3) => r3.type !== "select" ? jsx(Fragment$1, {}) : jsx(jg$1, { options: r3.options, size: "sm", value: r3.value, className: "oui-text-2xs oui-text-base-contrast-54 ", placeholder: r3.name === "side" ? t("common.side.all") : r3.name === "status" ? t("common.status.all") : "", onValueChange: (o) => {
    var _a3;
    (_a3 = e3.onFilter) == null ? void 0 : _a3.call(e3, { name: r3.name, value: o });
  } })) }) : jsx("div", {}), jsx(gf, { className: (_a2 = e3.classNames) == null ? void 0 : _a2.root, contentClassName: (_b2 = e3.classNames) == null ? void 0 : _b2.content, dataSource: e3.dataSource, loadMore: e3.loadMore, isLoading: e3.isLoading, renderItem: (r3, o) => {
    var _a3;
    let n4 = jsx(br$1, { item: r3, index: o, className: (_a3 = e3.classNames) == null ? void 0 : _a3.cell, type: e3.type, onSymbolChange: e3.onSymbolChange, sharePnLConfig: e3.sharePnLConfig });
    return ["tp_sl", "pending"].includes(e3.type) && (n4 = jsx(It, { order: r3, children: n4 })), jsx(Tt$3, { symbol: r3.symbol, children: n4 });
  } })] }) });
}, ys$1 = (e3) => {
  var _a2;
  let { t } = Z$2();
  return jsx(_e$5, { variant: "outlined", color: "secondary", size: "xs", disabled: (((_a2 = e3.dataSource) == null ? void 0 : _a2.length) ?? 0) == 0, className: "disabled:oui-bg-transport", onClick: (r3) => e3.onCancelAll(), "data-testid": `oui-testid-dataList-${e3.type.toLowerCase()}-cancelAll-button`, children: t("orders.cancelAll") });
};
var Yo = (e3) => useMemo(() => {
  let r3 = [];
  for (let o = 0; o < e3.length; o++) {
    let n4 = e3[o];
    if (n4.algo_type === AlgoOrderRootType.POSITIONAL_TP_SL || n4.algo_type === AlgoOrderRootType.TP_SL) if (n4.algo_status !== OrderStatus.FILLED && n4.algo_status !== OrderStatus.PARTIAL_FILLED) for (let i = 0; i < n4.child_orders.length; i++) {
      let a2 = n4.child_orders[i];
      !a2.is_activated || !a2.trigger_price || (a2.parent_algo_type = n4.algo_type, r3.push(a2));
    }
    else for (let i = 0; i < n4.child_orders.length; i++) {
      let a2 = n4.child_orders[i];
      a2 && (a2.algo_status === OrderStatus.FILLED || a2.algo_status === OrderStatus.PARTIAL_FILLED) && (a2.parent_algo_type = n4.algo_type, r3.push(a2));
    }
    else r3.push(n4);
  }
  return r3;
}, [e3]);
var _t$1 = (e3) => {
  let { ordersStatus: t, type: r3, enableLoadMore: o = false, onSymbolChange: n4, filterConfig: i, pnlNotionalDecimalPrecision: a2, sharePnLConfig: s } = e3, { t: d2 } = Z$2(), u2 = useSymbolsInfo(), l2 = useMemo(() => t !== OrderStatus.INCOMPLETE, [t]), b2 = 50, { page: m2, pageSize: O2, setPage: _2, pagination: I2, parsePagination: h2 } = mm({ pageSize: b2 });
  useEffect(() => {
    _2(1);
  }, [e3.symbol]);
  let { orderStatus: F2, ordersSide: T2, dateRange: V2, filterItems: f2, onFilter: w5 } = vs$1(r3, { ordersStatus: t, setPage: _2, filterConfig: i }), M2 = useMemo(() => {
    if (r3 === "tp_sl") return [AlgoOrderRootType.POSITIONAL_TP_SL, AlgoOrderRootType.TP_SL];
  }, [r3]), R2 = useMemo(() => {
    if (r3 === "pending") return [AlgoOrderRootType.POSITIONAL_TP_SL, AlgoOrderRootType.TP_SL];
  }, [r3]), x2 = useRef();
  useImperativeHandle(e3.ref, () => ({ download: () => {
    var _a2;
    let ht2 = `orders_${format(/* @__PURE__ */ new Date(), "yyyyMMdd_HHmmss")}`;
    (_a2 = x2.current) == null ? void 0 : _a2.download(ht2);
  } }));
  let [C2, { isLoading: D2, loadMore: te2, cancelOrder: E3, updateOrder: Y2, cancelAlgoOrder: v2, updateAlgoOrder: A2, cancelAllOrders: re2, cancelAllTPSLOrders: de2, meta: De2, refresh: g2 }] = useOrderStream({ symbol: e3.symbol, status: F2, side: T2, page: o || !l2 ? void 0 : m2, size: l2 ? O2 : 500, dateRange: V2, includes: M2, excludes: R2 }), y2 = `orderly_${r3}_pageSize`, [k2, Ce2] = useLocalStorage(y2, b2);
  useEffect(() => {
    k2 !== O2 && Ce2(O2);
  }, [O2, k2]);
  let Fe2 = useCallback(() => {
    let ht2 = e3.type === "pending" ? d2("orders.pending.cancelAll") : e3.type === "tp_sl" ? d2("orders.tpsl.cancelAll") : "", on2 = d2("orders.pending.cancelAll.description");
    uo$3.confirm({ title: ht2, content: jsx($$4, { size: "sm", children: on2 }), onCancel: async () => {
    }, onOk: async () => {
      try {
        return r3 === "tp_sl" ? await de2() : await re2(), g2(), Promise.resolve(true);
      } catch (_r3) {
        return (_r3 == null ? void 0 : _r3.message) !== void 0 && toast.error(_r3.message), Promise.resolve(false);
      } finally {
        Promise.resolve();
      }
    } });
  }, [r3, d2]), Ot2 = Yo(C2 ?? []), tn2 = xr$2(r3 !== "tp_sl" ? Ot2 : C2, { fallbackData: [] }) ?? void 0, rn2 = useMemo(() => l2 ? h2(De2) : I2, [De2, l2, h2, I2]);
  return { type: r3, dataSource: tn2, isLoading: D2, loadMore: te2, cancelOrder: E3, updateOrder: Y2, cancelAlgoOrder: v2, updateAlgoOrder: A2, pagination: rn2, manualPagination: l2, pnlNotionalDecimalPrecision: a2, onFilter: w5, filterItems: f2, onCancelAll: Fe2, onSymbolChange: n4, sharePnLConfig: s, tableInstance: x2, symbolsInfo: u2 };
}, vs$1 = (e3, t) => {
  var _a2, _b2;
  let { t: r3 } = Z$2(), [o, n4] = useState(t.ordersStatus ?? "all"), [i, a2] = useState(((_a2 = t.filterConfig) == null ? void 0 : _a2.side) ?? "all"), s = ((_b2 = t.filterConfig) == null ? void 0 : _b2.range) ?? (e3 === "all" || e3 === "orderHistory" ? Jo({ to: /* @__PURE__ */ new Date(), from: Zo(subDays(/* @__PURE__ */ new Date(), 7)) }) : {}), [d2, u2] = useState(s), l2 = (m2) => {
    m2.name === "side" && (a2(m2.value), t.setPage(1)), m2.name === "status" && (n4(m2.value), t.setPage(1)), m2.name === "dateRange" && (u2(Jo(m2.value)), t.setPage(1));
  };
  return { filterItems: useMemo(() => {
    let m2 = { type: "select", name: "side", options: [{ label: r3("common.side.all"), value: "all" }, { label: r3("common.buy"), value: "BUY" }, { label: r3("common.sell"), value: "SELL" }], value: i }, O2 = { type: "range", name: "dateRange", value: d2 }, _2 = { type: "select", name: "status", options: [{ label: r3("common.status.all"), value: "all" }, { label: r3("orders.status.pending"), value: OrderStatus.INCOMPLETE }, { label: r3("orders.status.filled"), value: OrderStatus.FILLED }, { label: r3("orders.status.partialFilled"), value: OrderStatus.PARTIAL_FILLED }, { label: r3("orders.status.canceled"), value: OrderStatus.CANCELLED }, { label: r3("orders.status.rejected"), value: OrderStatus.REJECTED }], value: o };
    switch (e3) {
      case "all":
        return [m2, _2, O2];
      case "pending":
        return [m2];
      case "tp_sl":
        return [m2];
      case "filled":
        return [m2];
      case "cancelled":
        return [m2];
      case "rejected":
        return [m2];
      case "orderHistory":
        return [m2, _2, O2];
    }
  }, [e3, i, o, d2, r3]), onFilter: l2, ordersSide: i === "all" ? void 0 : i, dateRange: d2, orderStatus: o === "all" ? void 0 : o };
};
function As(e3) {
  if (e3 == null) return e3;
  let t = new Date(e3);
  return t.setHours(0, 0, 0, 0), t;
}
function Zo(e3) {
  if (e3 == null) return e3;
  let t = new Date(e3);
  return t.setHours(23, 59, 59, 999), t;
}
var Jo = (e3) => ({ from: As(e3.from), to: Zo(e3.to ?? e3.from) });
var he$2 = forwardRef((e3, t) => {
  let { testIds: r3, ...o } = e3, n4 = _t$1({ ...o, ref: t });
  return jsx(Pr$1, { ...n4, testIds: r3 });
}), ks = (e3) => {
  let t = _t$1({ ...e3, enableLoadMore: true });
  return jsx(xr$1, { ...t, classNames: e3.classNames, showFilter: e3.showFilter });
};
var en = (e3) => {
  let { t } = Z$2(), r3 = { pnlNotionalDecimalPrecision: e3.pnlNotionalDecimalPrecision };
  return jsxs(Cl, { defaultValue: e3.current || "all", variant: "contained", className: "oui-h-full", classNames: { tabsContent: "oui-h-[calc(100%_-_28px)]" }, children: [jsx(Sl, { value: "all", title: t("common.all"), children: jsx(he$2, { ref: e3.orderListRef, type: "all", pnlNotionalDecimalPrecision: e3.pnlNotionalDecimalPrecision, sharePnLConfig: e3.sharePnLConfig, ...r3 }) }), jsx(Sl, { value: "pending", title: t("orders.status.pending"), children: jsx(he$2, { ref: e3.orderListRef, type: "pending", ordersStatus: OrderStatus.INCOMPLETE, ...r3 }) }), jsx(Sl, { value: "tp_sl", title: t("common.tpsl"), children: jsx(he$2, { ref: e3.orderListRef, type: "tp_sl", ordersStatus: OrderStatus.INCOMPLETE, ...r3 }) }), jsx(Sl, { value: "filled", title: t("orders.status.filled"), children: jsx(he$2, { ref: e3.orderListRef, type: "filled", ordersStatus: OrderStatus.FILLED, pnlNotionalDecimalPrecision: e3.pnlNotionalDecimalPrecision, sharePnLConfig: e3.sharePnLConfig, ...r3 }) }), jsx(Sl, { value: "cancelled", title: t("orders.status.canceled"), children: jsx(he$2, { ref: e3.orderListRef, type: "cancelled", ordersStatus: OrderStatus.CANCELLED, ...r3 }) }), jsx(Sl, { value: "rejected", title: t("orders.status.rejected"), children: jsx(he$2, { ref: e3.orderListRef, type: "rejected", ordersStatus: OrderStatus.REJECTED, ...r3 }) })] });
};
var Pe$2 = ((s) => (s.all = "all", s.pending = "pending", s.tp_sl = "tp_sl", s.filled = "filled", s.cancelled = "cancelled", s.rejected = "rejected", s.orderHistory = "orderHistory", s))(Pe$2 || {}), Ws = forwardRef((e3, t) => {
  let r3 = Ct$2({ ...e3, ref: t });
  return jsx(en, { ...r3 });
});
var ci = Object.defineProperty;
var $$1 = (e3, t) => {
  for (var o in t) ci(e3, o, { get: t[o], enumerable: true });
};
var ot$1 = (e3) => {
  var _a2;
  let { children: t, leftSideProps: o } = e3;
  return jsx(Va, { leftSidebar: e3.hideSideBar ? null : jsx(yi$3, { items: e3.items, current: (_a2 = e3.routerAdapter) == null ? void 0 : _a2.currentPath, ...o, routerAdapter: e3.routerAdapter }), routerAdapter: e3.routerAdapter, classNames: { content: "lg:oui-mb-0", topNavbar: "oui-bg-base-9", leftSidebar: "oui-m-3 oui-p-4 oui-broder oui-border-[1px] oui-border-line oui-rounded-xl oui-bg-base-9" }, ...e3, children: jsx(_$1, { mx: 3, my: 6, children: t }) });
}, yi$3 = (e3) => {
  let { expanded: t, setExpand: o } = le$4(), { t: i } = Z$2();
  return jsx(ge$3, { title: i("common.portfolio"), ...e3, open: t, onOpenChange: (r3) => o(r3), onItemSelect: (r3) => {
    var _a2, _b2, _c2;
    (_a2 = e3.onItemSelect) == null ? void 0 : _a2.call(e3, r3), (_c2 = (_b2 = e3.routerAdapter) == null ? void 0 : _b2.onRouteChange) == null ? void 0 : _c2.call(_b2, { href: r3.href || "", name: r3.name });
  } });
};
var Et$3 = ((n4) => (n4.Overview = "/portfolio", n4.Positions = "/portfolio/positions", n4.Orders = "/portfolio/orders", n4.FeeTier = "/portfolio/feeTier", n4.ApiKey = "/portfolio/apiKey", n4.Setting = "/portfolio/setting", n4))(Et$3 || {}), it = (e3) => {
  let { routerAdapter: t } = le$4(), [o, i] = useState(e3.current ?? (t == null ? void 0 : t.currentPath) ?? "/portfolio"), { t: r3 } = Z$2();
  useEffect(() => {
    (o || (t == null ? void 0 : t.currentPath)) && i(o || (t == null ? void 0 : t.currentPath) || "/portfolio");
  }, [o, t == null ? void 0 : t.currentPath]);
  let a2 = useMemo(() => [{ name: r3("common.overview"), href: "/portfolio", icon: jsx("svg", { width: "18", height: "18", viewBox: "0 0 18 18", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: jsx("path", { d: "M5.24316 2.19727C3.58641 2.19727 2.24316 3.54044 2.24316 5.19727V12.6973C2.24316 14.3541 3.58641 15.6973 5.24316 15.6973H12.7432C14.3999 15.6973 15.7432 14.3541 15.7432 12.6973V5.19727C15.7432 3.54044 14.3999 2.19727 12.7432 2.19727H5.24316ZM5.24316 3.69727H12.7432C13.5719 3.69727 14.2432 4.36882 14.2432 5.19727V12.6973C14.2432 13.2484 13.9319 13.734 13.4894 13.9947C13.3454 12.2235 11.4427 11.1973 8.99316 11.1973C6.54366 11.1973 4.60341 12.251 4.48566 13.9997C4.04241 13.739 3.74316 13.2484 3.74316 12.6973V5.19727C3.74316 4.36882 4.41441 3.69727 5.24316 3.69727ZM8.99316 5.19727C7.54341 5.19727 6.36816 6.37252 6.36816 7.82227C6.36816 9.27202 7.54341 10.4473 8.99316 10.4473C10.4429 10.4473 11.6182 9.27202 11.6182 7.82227C11.6182 6.37252 10.4429 5.19727 8.99316 5.19727Z", className: "oui-fill-current group-data-[actived=true]:oui-fill-[url(#side-menu-gradient)]" }) }) }, { name: r3("common.positions"), href: "/portfolio/positions", icon: jsx("svg", { width: "18", height: "18", viewBox: "0 0 18 18", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: jsx("path", { d: "M4.51 3.021a3 3 0 0 0-3 3v6a3 3 0 0 0 3 3h9a3 3 0 0 0 3-3v-6a3 3 0 0 0-3-3zm2.25 3a.76.76 0 0 1 .54.211.77.77 0 0 1 0 1.078l-.75.75a.77.77 0 0 1-.54.211h-.75a.75.75 0 0 1 0-1.5h.422l.54-.539a.76.76 0 0 1 .539-.21m3 .75h3a.75.75 0 0 1 0 1.5h-3a.75.75 0 0 1 0-1.5m-3 2.25a.76.76 0 0 1 .54.211.77.77 0 0 1 0 1.079l-.75.75a.77.77 0 0 1-.54.21h-.75a.75.75 0 0 1 0-1.5h.422l.54-.539a.76.76 0 0 1 .539-.21m3 .75h3a.75.75 0 0 1 0 1.5h-3a.75.75 0 0 1 0-1.5", className: "oui-fill-current group-data-[actived=true]:oui-fill-[url(#side-menu-gradient)]" }) }) }, { name: r3("common.orders"), href: "/portfolio/orders", icon: jsx("svg", { width: "18", height: "18", viewBox: "0 0 18 18", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: jsx("path", { d: "M5.693 1.5C4.229 1.5 3.02 2.61 3.02 4.006v9.984c0 1.398 1.208 2.508 2.672 2.508h6.657c1.463 0 2.671-1.11 2.671-2.508V6.726c0-2.672-2.579-5.227-5.25-5.227zm4.828 1.593c1.33.352 2.562 1.58 2.906 2.906h-1.734c-.667 0-1.172-.472-1.172-1.008zm-3.75 2.906h.75a.75.75 0 0 1 0 1.5h-.75a.75.75 0 0 1 0-1.5m0 3h4.5a.75.75 0 0 1 0 1.5h-4.5a.75.75 0 0 1 0-1.5m0 3h4.5a.75.75 0 0 1 0 1.5h-4.5a.75.75 0 0 1 0-1.5", className: "oui-fill-current group-data-[actived=true]:oui-fill-[url(#side-menu-gradient)]" }) }) }, { name: r3("portfolio.feeTier"), href: "/portfolio/feeTier", icon: jsx("svg", { width: "18", height: "18", viewBox: "0 0 18 18", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: jsx("path", { d: "M5.99829 1.51062C4.34154 1.51062 2.99829 2.85387 2.99829 4.51062V13.5106C2.99829 15.1674 4.34154 16.5106 5.99829 16.5106H11.9983C13.655 16.5106 14.9983 15.1674 14.9983 13.5106V4.51062C14.9983 2.85387 13.655 1.51062 11.9983 1.51062H5.99829ZM5.99829 3.76062H11.9983C12.4123 3.76062 12.7483 4.09662 12.7483 4.51062V6.01062C12.7483 6.42462 12.4123 6.76062 11.9983 6.76062H5.99829C5.58429 6.76062 5.24829 6.42462 5.24829 6.01062V4.51062C5.24829 4.09662 5.58429 3.76062 5.99829 3.76062ZM5.99829 8.26062C6.41229 8.26062 6.74829 8.59662 6.74829 9.01062C6.74829 9.42462 6.41229 9.76062 5.99829 9.76062C5.58429 9.76062 5.24829 9.42462 5.24829 9.01062C5.24829 8.59662 5.58429 8.26062 5.99829 8.26062ZM8.99829 8.26062C9.41229 8.26062 9.74829 8.59662 9.74829 9.01062C9.74829 9.42462 9.41229 9.76062 8.99829 9.76062C8.58429 9.76062 8.24829 9.42462 8.24829 9.01062C8.24829 8.59662 8.58429 8.26062 8.99829 8.26062ZM11.9983 8.26062C12.4123 8.26062 12.7483 8.59662 12.7483 9.01062C12.7483 9.42462 12.4123 9.76062 11.9983 9.76062C11.5843 9.76062 11.2483 9.42462 11.2483 9.01062C11.2483 8.59662 11.5843 8.26062 11.9983 8.26062ZM5.99829 10.5106C6.41229 10.5106 6.74829 10.8466 6.74829 11.2606C6.74829 11.6746 6.41229 12.0106 5.99829 12.0106C5.58429 12.0106 5.24829 11.6746 5.24829 11.2606C5.24829 10.8466 5.58429 10.5106 5.99829 10.5106ZM8.99829 10.5106C9.41229 10.5106 9.74829 10.8466 9.74829 11.2606C9.74829 11.6746 9.41229 12.0106 8.99829 12.0106C8.58429 12.0106 8.24829 11.6746 8.24829 11.2606C8.24829 10.8466 8.58429 10.5106 8.99829 10.5106ZM11.9983 10.5106C12.4123 10.5106 12.7483 10.8466 12.7483 11.2606V13.5106C12.7483 13.9246 12.4123 14.2606 11.9983 14.2606C11.5843 14.2606 11.2483 13.9246 11.2483 13.5106V11.2606C11.2483 10.8466 11.5843 10.5106 11.9983 10.5106ZM5.99829 12.7606C6.41229 12.7606 6.74829 13.0966 6.74829 13.5106C6.74829 13.9246 6.41229 14.2606 5.99829 14.2606C5.58429 14.2606 5.24829 13.9246 5.24829 13.5106C5.24829 13.0966 5.58429 12.7606 5.99829 12.7606ZM8.99829 12.7606C9.41229 12.7606 9.74829 13.0966 9.74829 13.5106C9.74829 13.9246 9.41229 14.2606 8.99829 14.2606C8.58429 14.2606 8.24829 13.9246 8.24829 13.5106C8.24829 13.0966 8.58429 12.7606 8.99829 12.7606Z", className: "oui-fill-current group-data-[actived=true]:oui-fill-[url(#side-menu-gradient)]" }) }) }, { name: r3("portfolio.apiKeys"), href: "/portfolio/apiKey", icon: jsx("svg", { width: "18", height: "18", viewBox: "0 0 18 18", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: jsx("path", { d: "M9.02124 1.49915C7.77849 1.49915 6.77124 2.5064 6.77124 3.74915C6.77124 4.70015 7.40049 5.55517 8.26974 5.86942L8.27124 8.24915H5.27124C4.85724 8.24915 4.52124 8.58515 4.52124 8.99915L4.52048 12.1304C3.65723 12.4274 3.02124 13.2981 3.02124 14.2491C3.02124 15.4919 4.02849 16.4991 5.27124 16.4991C6.51399 16.4991 7.52124 15.4919 7.52124 14.2491C7.52124 13.2981 6.92499 12.4596 6.02949 12.1206L6.02124 9.74915H9.02124H12.0212L12.0265 12.1319C11.1257 12.4446 10.5212 13.2981 10.5212 14.2491C10.5212 15.4919 11.5285 16.4991 12.7712 16.4991C14.014 16.4991 15.0212 15.4919 15.0212 14.2491C15.0212 13.2981 14.407 12.4611 13.5272 12.1281L13.5212 8.99915C13.5212 8.58515 13.1852 8.24915 12.7712 8.24915H9.77124L9.76899 5.86639C10.642 5.55814 11.2712 4.70015 11.2712 3.74915C11.2712 2.5064 10.264 1.49915 9.02124 1.49915Z", className: "oui-fill-current group-data-[actived=true]:oui-fill-[url(#side-menu-gradient)]" }) }) }, { name: r3("portfolio.setting"), href: "/portfolio/setting", icon: jsx("svg", { width: "18", height: "18", viewBox: "0 0 18 18", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: jsx("path", { d: "M6.72601 1.84159C5.66251 2.17834 4.74527 2.7296 3.93677 3.48185C3.68702 3.7151 3.61052 4.09534 3.77252 4.39609C4.37327 5.50684 3.74476 6.69484 2.39026 6.76309C2.05801 6.78034 1.76477 7.02559 1.68677 7.34884C1.55252 7.90759 1.49927 8.37559 1.49927 8.98984C1.49927 9.50509 1.55476 10.0878 1.66351 10.6068C1.73101 10.9308 2.01302 11.1641 2.34302 11.1933C3.70652 11.3111 4.38152 12.3506 3.77252 13.6773C3.63752 13.9721 3.69902 14.3246 3.93677 14.5443C4.73327 15.2816 5.64826 15.8006 6.72601 16.1381C7.03351 16.2348 7.38076 16.1186 7.56976 15.8568C8.40376 14.7033 9.61352 14.6988 10.4055 15.8568C10.5923 16.1298 10.9343 16.2611 11.2493 16.1613C12.2895 15.8343 13.2585 15.2771 14.0618 14.5443C14.3093 14.3193 14.3745 13.9541 14.226 13.6541C13.602 12.3948 14.3198 11.2383 15.6083 11.2166C15.9503 11.2106 16.2548 10.9856 16.335 10.6541C16.4648 10.1163 16.4993 9.64759 16.4993 8.98984C16.4993 8.42434 16.4325 7.86709 16.3118 7.32559C16.2353 6.98359 15.936 6.74059 15.585 6.73984C14.3168 6.73759 13.6058 5.49109 14.226 4.39609C14.3985 4.09084 14.3445 3.71735 14.085 3.48185C13.2675 2.73935 12.2708 2.15959 11.226 1.84159C10.905 1.74409 10.5638 1.86409 10.3823 2.14609C9.65776 3.27109 8.30477 3.29135 7.59302 2.16935C7.41077 1.8821 7.05001 1.73809 6.72601 1.84159ZM8.99927 5.98984C10.656 5.98984 11.9993 7.33309 11.9993 8.98984C11.9993 10.6466 10.656 11.9898 8.99927 11.9898C7.34252 11.9898 5.99927 10.6466 5.99927 8.98984C5.99927 7.33309 7.34252 5.98984 8.99927 5.98984Z", className: "oui-fill-current group-data-[actived=true]:oui-fill-[url(#side-menu-gradient)]" }) }) }], [r3]), n4 = useMediaQuery("(max-width: 768px)");
  return { items: a2, current: o, hideSideBar: n4, onItemSelect: (s) => {
    typeof s.href > "u" || (i(s.href), t == null ? void 0 : t.onRouteChange({ href: s.href, name: s.name }));
  } };
};
var wi$1 = (e3) => {
  var _a2;
  let t = it({ current: (_a2 = e3.leftSideProps) == null ? void 0 : _a2.current });
  return jsx(ot$1, { ...t, ...e3, children: e3.children });
};
var so$2 = {};
$$1(so$2, { AssetHistory: () => ce$2, AssetHistoryWidget: () => de, AssetWidget: () => ne$1, AssetsChartWidget: () => ze$2, AssetsUI: () => ae$3, DistributionHistoryUI: () => ge$2, DistributionHistoryWidget: () => ye$3, FundingHistoryWidget: () => fe$2, HistoryDataGroupWidget: () => xe$1, OverviewContextProvider: () => Le$2, OverviewPage: () => no$1, PerformanceUI: () => be$2, PerformanceWidget: () => ve$2, useAssetHistoryColumns: () => le$1, useAssetHistoryHook: () => ue$2, useAssetsLineChartScript: () => Me$1, useFundingHistoryColumns: () => me$1, useFundingHistoryHook: () => pe, usePerformanceScript: () => he$1 });
var at = () => {
  let { connect: e3 } = useWalletConnector(), { state: t } = useAccount(), { totalValue: o, freeCollateral: i } = useCollateral(), { wrongNetwork: r3, disabledConnect: a2 } = L$4(), [n4] = usePositionStream(), [s] = useLeverage(), [l2, u2] = useLocalStorage("orderly_assets_visible", true), m2 = useMemo(() => !r3 && !a2 && (t.status === AccountStatusEnum.EnableTrading || t.status === AccountStatusEnum.EnableTradingWithoutConnected), [t.status, r3, a2]), y2 = () => {
    uo$3.show(U$2);
  }, b2 = () => {
    uo$3.show(Lr$1, { activeTab: "deposit" });
  }, p2 = () => {
    uo$3.show(Lr$1, { activeTab: "withdraw" });
  };
  return { canTrade: m2, connect: e3, portfolioValue: o, freeCollateral: i, unrealPnL: n4.aggregated.total_unreal_pnl, unrealROI: n4.totalUnrealizedROI, currentLeverage: s, onLeverageEdit: y2, visible: l2, wrongNetwork: r3, toggleVisible: () => u2(!l2), onDeposit: b2, onWithdraw: p2 };
};
var Bt$1 = (e3) => {
  let { t } = Z$2();
  return jsxs(z$1, { justify: "between", children: [jsx(qt$3, { children: t("common.overview") }), jsxs(z$1, { gap: 3, children: [jsx(_e$5, { disabled: e3.disabled, size: "md", color: "secondary", onClick: () => {
    var _a2;
    return (_a2 = e3.onWithdraw) == null ? void 0 : _a2.call(e3);
  }, icon: jsx($a, {}), "data-testid": "oui-testid-portfolio-assets-withdraw-btn", children: t("common.withdraw") }), jsx(_e$5, { disabled: e3.disabled, size: "md", onClick: () => {
    var _a2;
    return (_a2 = e3.onDeposit) == null ? void 0 : _a2.call(e3);
  }, icon: jsx(qa$1, {}), "data-testid": "oui-testid-portfolio-assets-deposit-btn", children: t("common.deposit") })] })] });
};
var ae$3 = (e3) => {
  let { t } = Z$2();
  return jsx(Rl, { classNames: { footer: "oui-h-[48px]", root: "oui-h-[240px]" }, title: jsx(Bt$1, { disabled: !e3.canTrade, onDeposit: e3.onDeposit, onWithdraw: e3.onWithdraw }), children: jsxs(Fragment$1, { children: [jsx(da$2, { label: jsxs(z$1, { gap: 1, children: [jsx($$4, { intensity: 54, children: t("common.totalValue") }), jsx("button", { onClick: () => {
    e3.toggleVisible();
  }, "data-testid": "oui-testid-portfolio-assets-eye-btn", children: e3.visible ? jsx(on$1, { size: 16, color: "white" }) : jsx(nn$1, { size: 16, color: "white" }) })] }), children: jsx(Mf, { value: e3.canTrade, left: jsx(Zi, {}), children: jsx($$4.numeral, { visible: e3.visible, unit: "USDC", style: { "--oui-gradient-angle": "45deg" }, unitClassName: "oui-text-base oui-text-base-contrast-80 oui-h-9 oui-ml-1", className: Cn$3({ className: "oui-font-bold oui-text-3xl", color: "brand" }), children: e3.portfolioValue ?? "--" }) }) }), jsx(te$6, { className: "oui-my-4", intensity: 8 }), jsx(S$1, { buttonProps: { size: "lg", fullWidth: true }, children: jsx(qi$1, { unrealROI: e3.unrealROI, unrealPnL: e3.unrealPnL, freeCollateral: e3.freeCollateral, currentLeverage: e3.currentLeverage, onLeverageEdit: e3.onLeverageEdit, visible: e3.visible }) })] }) });
}, Zi = () => jsxs(z$1, { gap: 1, className: "oui-h-9", children: [jsx($$4.gradient, { color: "brand", weight: "bold", children: "--" }), jsx($$4, { children: "USDC" })] }), qi$1 = (e3) => {
  let { t } = Z$2();
  return jsxs(ia$1, { cols: 3, className: "oui-h-12", children: [jsx(da$2, { label: t("common.unrealizedPnl"), children: jsxs(z$1, { children: [jsx($$4.numeral, { coloring: true, size: "lg", weight: "semibold", visible: e3.visible, children: e3.unrealPnL }), jsx($$4.numeral, { coloring: true, rule: "percentages", size: "sm", weight: "semibold", prefix: "(", suffix: ")", visible: e3.visible, children: e3.unrealROI })] }) }), jsx(da$2, { label: t("leverage.maxAccountLeverage"), children: jsxs(z$1, { itemAlign: "center", children: [jsx("span", { "data-testid": "oui-testid-portfolio-assets-maxAccountLeverage-value", className: "oui-text-lg", children: e3.currentLeverage }), jsx("span", { children: "x" }), jsx("button", { className: "oui-ml-1", onClick: () => {
    var _a2;
    return (_a2 = e3.onLeverageEdit) == null ? void 0 : _a2.call(e3);
  }, "data-testid": "oui-testid-portfolio-assets-maxAccountLeverage-edit-btn", children: jsx(Ja, { color: "white", size: 18 }) })] }) }), jsx(da$2, { label: t("portfolio.overview.availableWithdraw"), align: "right", valueProps: { size: "lg", visible: e3.visible }, children: e3.freeCollateral })] });
};
var ne$1 = () => {
  let { canTrade: e3, connect: t, portfolioValue: o, onLeverageEdit: i, ...r3 } = at();
  return jsx(ae$3, { onConnectWallet: t, canTrade: e3, portfolioValue: o, onLeverageEdit: i, ...r3 });
};
var Ne$1 = ((i) => (i.WEEK = "7D", i.MONTH = "30D", i.QUARTER = "90D", i))(Ne$1 || {}), Gt$1 = (e3, t) => {
  var _a2;
  let [o] = useState(() => {
    let d2 = /* @__PURE__ */ new Date();
    return new Date(getYear(d2), getMonth(d2), getDate(d2), 0, 0, 0);
  }), { isRealtime: i = false } = t || {}, r3 = Object.values(Ne$1), [a2, n4] = useLocalStorage(e3, "7D"), { totalValue: s } = useCollateral(), l2 = (d2) => {
    switch (d2) {
      case "30D":
        return subDays(o, 35);
      case "90D":
        return subDays(o, 95);
      default:
        return subDays(o, 10);
    }
  }, u2 = useMemo(() => {
    switch (a2) {
      case "7D":
        return 7;
      case "30D":
        return 30;
      case "90D":
        return 90;
      default:
        return 7;
    }
  }, [a2]), [m2, y2] = useState(l2(a2)), b2 = useMemo(() => addDays(o, 1), [o]), [p2] = useStatisticsDaily({ startDate: m2.toISOString().split("T")[0], endDate: b2.toISOString().split("T")[0] }, { ignoreAggregation: true }), [c2] = useAssetsHistory({ startTime: subDays(o, 2).getTime().toString(), endTime: b2.getTime().toString(), pageSize: 50 }), f2 = (d2) => {
    y2(l2(d2)), n4(d2);
  }, ee2 = (d2) => {
    if (s == null) return null;
    let C2 = new g$6(s).sub(d2.lastItem.account_value);
    if (Array.isArray(d2.assetHistory) && d2.assetHistory.length > 0 && typeof d2.lastItem.snapshot_time < "u") {
      let S2 = [];
      for (let h2 = 0; h2 < d2.assetHistory.length; h2++) {
        let w5 = d2.assetHistory[h2];
        w5.created_time > d2.lastItem.snapshot_time && S2.push(w5);
      }
      for (let h2 = 0; h2 < S2.length; h2++) {
        let w5 = S2[h2];
        w5.side === "DEPOSIT" ? w5.trans_status === "COMPLETED" && (C2 = C2.sub(w5.amount)) : w5.side === "WITHDRAW" && w5.trans_status !== "FAILED" && (C2 = C2.add(w5.amount));
      }
    }
    return C2.toNumber();
  }, V2 = (d2, C2) => {
    let S2 = d2[d2.length - 1], h2 = format(o, "yyyy-MM-dd");
    return { ...S2, date: h2, perp_volume: 0, account_value: C2 !== null ? C2 : (S2 == null ? void 0 : S2.account_value) ?? 0, pnl: ee2({ lastItem: S2, assetHistory: c2 }) ?? 0 };
  }, G2 = (d2, C2) => !Array.isArray(d2) || d2.length === 0 ? d2 : (d2[d2.length - 1].date, format(o, "yyyy-MM-dd"), d2.concat([V2(d2, C2)])), te2 = (d2, C2) => {
    let S2 = C2 ? G2(d2, s) : d2;
    return S2.slice(Math.max(0, S2.length - u2));
  }, D2 = useMemo(() => s == null ? [] : te2(p2, i), [p2, s, c2, i]), et2 = useMemo(() => {
    var _a3;
    let d2 = y$3, C2 = y$3, S2 = y$3;
    if (Array.isArray(D2) && D2.length) {
      D2.forEach((ie2) => {
        C2 = C2.add(ie2.pnl);
      });
      let h2 = D2[0], w5 = p2.findIndex((ie2) => ie2.date === h2.date), oe2 = (_a3 = p2[w5 - 1]) == null ? void 0 : _a3.account_value;
      typeof oe2 > "u" || oe2 === 0 ? S2 = y$3 : S2 = C2.div(oe2);
    }
    if (p2.length > 0) for (let h2 = 0; h2 < u2; h2++) {
      let w5 = p2[p2.length - 1 - h2];
      w5 && (d2 = d2.add(w5.perp_volume ?? 0));
    }
    return { vol: d2.toNumber(), pnl: C2.toNumber(), roi: S2.toNumber() };
  }, [D2, p2, u2]);
  return { periodTypes: r3, period: a2, onPeriodChange: f2, data: D2, aggregateValue: et2, createFakeData: (d2, C2) => Array.from({ length: 2 }, (S2, h2) => ({ date: format(h2 === 0 ? m2 : /* @__PURE__ */ new Date(), "yyyy-MM-dd"), ...h2 === 0 ? d2 : C2 })), volumeUpdateDate: ((_a2 = p2 == null ? void 0 : p2[p2.length - 1]) == null ? void 0 : _a2.date) ?? "" };
};
var $t$2 = createContext({}), lr$2 = "portfolio_performance_period", Ee$1 = () => useContext($t$2), Le$2 = ({ children: e3 }) => {
  let t = Gt$1(lr$2, { isRealtime: true });
  return jsx($t$2.Provider, { value: { ...t }, children: e3 });
};
var Me$1 = () => {
  let e3 = Ee$1(), { wrongNetwork: t, disabledConnect: o } = L$4(), { state: i } = useAccount(), r3 = xr$2(e3.data, { accountStatus: i.status === AccountStatusEnum.EnableTradingWithoutConnected ? AccountStatusEnum.EnableTradingWithoutConnected : AccountStatusEnum.EnableTrading, fallbackData: e3.createFakeData({ account_value: 0 }, { account_value: 500 }) }), a2 = useMemo(() => (r3 == null ? void 0 : r3.length) ?? 0 > 0 ? r3 : e3.createFakeData({ account_value: 0 }, { account_value: 500 }), [r3]), n4 = t || o || !e3.data.length;
  return { ...e3, data: a2, invisible: n4 };
};
var We$3 = (e3) => {
  let { t } = Z$2(), o = useMemo(() => ({ "7D": t("common.select.7d"), "30D": t("common.select.30d"), "90D": t("common.select.90d") }), [t]);
  return jsxs(z$1, { justify: "between", children: [jsx(qt$3, { children: e3.title }), jsx("div", { className: "oui-min-w-14", children: jsx(ke$2.options, { size: "xs", value: e3.period, onValueChange: e3.onPeriodChange, options: e3.periodTypes.map((i) => ({ value: i, label: o[i] })) }) })] });
};
var Zt$2 = (e3) => {
  let { onPeriodChange: t, periodTypes: o, period: i, data: r3 } = e3, { t: a2 } = Z$2();
  return jsx(Rl, { title: jsx(We$3, { onPeriodChange: t, periodTypes: o, period: i, title: a2("common.assets") }), id: "portfolio-overview-assets-chart", classNames: { content: "oui-h-[168px] oui-pb-0" }, children: jsx(zt$3, { data: e3.data, invisible: e3.invisible }) });
};
var ze$2 = () => {
  let e3 = Me$1();
  return jsx(Zt$2, { ...e3 });
};
var le$1 = () => {
  let { data: e3 } = useQuery("/v1/public/chain_info"), { t } = Z$2();
  return useMemo(() => [{ title: t("common.token"), dataIndex: "token", width: 80, render: (i) => jsxs(z$1, { gapX: 1, children: [jsx(Pe$5, { name: i, size: "xs" }), jsx("span", { children: i })] }) }, { title: t("common.time"), dataIndex: "created_time", width: 80, rule: "date" }, { title: t("portfolio.overview.column.txId"), dataIndex: "tx_id", width: 120, render: (i, r3) => {
    var _a2;
    if (!i) return jsx("div", { className: "oui-text-base-contrast-54", children: "-" });
    let s = `${(_a2 = e3 == null ? void 0 : e3.find((l2) => parseInt(r3.chain_id) === parseInt(l2.chain_id))) == null ? void 0 : _a2.explorer_base_url}/tx/${i}`;
    return jsx("a", { href: s, target: "_blank", children: jsx($$4.formatted, { copyable: !!i, rule: "txId", className: "oui-underline-offset-4 oui-underline oui-decoration-dashed oui-decoration-line-16", onCopy: (l2) => {
      l2.preventDefault(), l2.stopPropagation(), toast$2.success(t("common.copy.copied"));
    }, children: i }) });
  } }, { title: t("common.status"), dataIndex: "trans_status", width: 100, render: (i) => ({ [AssetHistoryStatusEnum.NEW]: t("assetHistory.status.pending"), [AssetHistoryStatusEnum.CONFIRM]: t("assetHistory.status.confirm"), [AssetHistoryStatusEnum.PROCESSING]: t("assetHistory.status.processing"), [AssetHistoryStatusEnum.COMPLETED]: t("assetHistory.status.completed"), [AssetHistoryStatusEnum.FAILED]: t("assetHistory.status.failed") })[i] || Ef(i.toLowerCase()) }, { title: t("common.type"), dataIndex: "side", width: 80, render: (i) => jsx($$4, { color: i === "DEPOSIT" ? "deposit" : "withdraw", children: t(i === "DEPOSIT" ? "common.deposit" : "common.withdraw") }) }, { title: t("common.amount"), dataIndex: "amount", width: 100, rule: "price", formatter: (i, r3) => r3.side === "WITHDRAW" ? -(i - (r3.fee ?? 0)) : i - (r3.fee ?? 0), numeralProps: { coloring: true, showIdentifier: true } }], [e3, t]);
};
var Y = (e3) => {
  let { from: t, to: o } = e3;
  return typeof o > "u" && (o = /* @__PURE__ */ new Date()), differenceInDays(t, o) === 0 ? [t, setHours(o, 23)] : [t, o];
};
var ue$2 = () => {
  let [e3] = useState(() => {
    let c2 = /* @__PURE__ */ new Date();
    return new Date(getYear(c2), getMonth(c2), getDate(c2), 0, 0, 0);
  }), [t, o] = useState([k$3(90, e3), e3]), [i, r3] = useState("All"), { page: a2, pageSize: n4, setPage: s, parsePagination: l2 } = mm(), [u2, { meta: m2, isLoading: y2 }] = useAssetsHistory({ startTime: t[0].getTime().toString(), endTime: set(t[1], { hours: 23, minutes: 59, seconds: 59, milliseconds: 0 }).getTime().toString(), page: a2, pageSize: n4, side: i }), b2 = (c2) => {
    c2.name === "side" && (r3(c2.value), s(1)), c2.name === "dateRange" && (o(Y(c2.value)), s(1));
  }, p2 = useMemo(() => l2(m2), [l2, m2]);
  return { dataSource: u2, total: m2 == null ? void 0 : m2.total, isLoading: y2, queryParameter: { side: i, dateRange: t }, onFilter: b2, pagination: p2 };
};
var ce$2 = (e3) => {
  let { dataSource: t, queryParameter: o, onFilter: i, isLoading: r3 } = e3, { side: a2, dateRange: n4 } = o, s = le$1(), { t: l2 } = Z$2(), u2 = useMemo(() => [{ label: l2("common.all"), value: "All" }, { label: l2("common.deposit"), value: "DEPOSIT" }, { label: l2("common.withdraw"), value: "WITHDRAW" }], [l2]);
  return jsxs(Fragment$1, { children: [jsx(lm, { items: [{ type: "select", name: "side", options: u2, value: a2 }, { type: "range", name: "dateRange", value: { from: n4[0], to: n4[1] } }], onFilter: (m2) => {
    i(m2);
  } }), jsx(dt$3, { bordered: true, loading: r3, classNames: { root: "oui-h-[calc(100%_-_49px)]" }, columns: s, dataSource: t, pagination: e3.pagination })] });
};
var de = () => {
  let e3 = ue$2();
  return jsx(ce$2, { ...e3 });
};
var me$1 = () => {
  let { t: e3 } = Z$2();
  return useMemo(() => [{ title: e3("common.symbol"), dataIndex: "symbol", width: 80, rule: "symbol", textProps: { showIcon: true } }, { title: e3("common.time"), dataIndex: "created_time", width: 120, rule: "date" }, { title: e3("portfolio.overview.column.funding&AnnualRate"), dataIndex: "funding_rate", width: 80, render: (o, i) => jsxs(z$1, { gap: 1, children: [jsx($$4.numeral, { rule: "percentages", dp: 6, children: i.funding_rate }), jsx("span", { children: "/" }), jsx($$4.numeral, { rule: "percentages", dp: 6, children: i.annual_rate })] }) }, { title: e3("portfolio.overview.column.paymentType"), dataIndex: "payment_type", width: 80, render: (o) => {
    switch (o) {
      case "Pay":
      case "Paid":
        return e3("portfolio.overview.column.paymentType.paid");
      case "Receive":
      case "Received":
        return e3("portfolio.overview.column.paymentType.received");
      default:
        return o;
    }
  } }, { title: `${e3("portfolio.overview.column.fundingFee")} (USDC)`, dataIndex: "funding_fee", width: 80, rule: "price", formatter(o, i, r3) {
    return Number(o) * -1;
  }, numeralProps: { coloring: true, showIdentifier: true, ignoreDP: true } }], [e3]);
};
var mt$1 = (e3) => {
  let { dataSource: t, queryParameter: o, onFilter: i, isLoading: r3 } = e3, a2 = me$1(), n4 = useSymbolsInfo(), { symbol: s, dateRange: l2 } = o;
  return jsxs(Fragment$1, { children: [jsx(lm, { items: [{ type: "select", name: "symbol", isCombine: true, options: [{ label: "All", value: "All" }, ...Object.keys(n4).map((u2) => ({ label: u2.split("_")[1], value: u2 }))], value: s, valueFormatter: (u2) => u2 === "All" ? "All" : u2.split("_")[1] }, { type: "range", name: "dateRange", value: { from: l2[0], to: l2[1] } }], onFilter: (u2) => {
    i(u2);
  } }), jsx(dt$3, { bordered: true, columns: a2, dataSource: t, loading: r3, generatedRowKey: (u2) => `${u2.updated_time}`, classNames: { root: "oui-h-[calc(100%_-_49px)]" }, pagination: e3.pagination })] });
};
var pe = () => {
  let [e3] = useState(() => {
    let f2 = /* @__PURE__ */ new Date();
    return new Date(getYear(f2), getMonth(f2), getDate(f2), 0, 0, 0);
  }), [t, o] = useState([k$3(90, e3), e3]), [i, r3] = useState("All"), { page: a2, pageSize: n4, setPage: s, parsePagination: l2 } = mm(), [u2, { isLoading: m2, meta: y2, isValidating: b2 }] = useFundingFeeHistory({ dataRange: [t[0].getTime(), set(t[1], { hours: 23, minutes: 59, seconds: 59, milliseconds: 0 }).getTime()], symbol: i, page: a2, pageSize: n4 }, { keepPreviousData: true }), p2 = (f2) => {
    f2.name === "symbol" && (r3(f2.value), s(1)), f2.name === "dateRange" && (o(Y(f2.value)), s(1));
  }, c2 = useMemo(() => l2(y2), [l2, y2]);
  return { dataSource: u2, isLoading: m2, isValidating: b2, queryParameter: { symbol: i, dateRange: t }, onFilter: p2, pagination: c2 };
};
var fe$2 = () => {
  let e3 = pe();
  return jsx(mt$1, { ...e3 });
};
var jt$2 = () => {
  let { t: e3 } = Z$2();
  return useMemo(() => [{ title: e3("common.token"), dataIndex: "token", width: 80, render: (o, i) => jsxs(z$1, { gapX: 2, children: [jsx(Pe$5, { name: o, size: "xs" }), jsx("span", { children: o })] }) }, { title: e3("common.time"), dataIndex: "updated_time", width: 120, rule: "date" }, { title: e3("common.status"), dataIndex: "status", width: 120, formatter(o, i, r3) {
    switch (o) {
      case "CREATED":
      case "SPLIT":
        return e3("portfolio.assetHistory.status.processing");
      case "COMPLETED":
      default:
        return e3("portfolio.assetHistory.status.completed");
    }
  } }, { title: e3("common.type"), dataIndex: "type", width: 80, formatter: (o) => {
    switch (o) {
      case "REFERRER_REBATE":
        return e3("portfolio.overview.distribution.type.referralCommission");
      case "REFEREE_REBATE":
        return e3("portfolio.overview.distribution.type.refereeRebate");
      case "BROKER_FEE":
        return e3("portfolio.overview.distribution.type.brokerFee");
      default:
        return "-";
    }
  } }, { title: e3("common.amount"), dataIndex: "amount", width: 80 }], [e3]);
};
var ge$2 = (e3) => {
  let { dataSource: t, queryParameter: o, onFilter: i, isLoading: r3, isValidating: a2 } = e3, n4 = jt$2(), { type: s, dateRange: l2 } = o, { t: u2 } = Z$2(), m2 = useMemo(() => [{ label: u2("common.all"), value: "All" }, { label: u2("portfolio.overview.distribution.type.referralCommission"), value: "REFERRER_REBATE" }, { label: u2("portfolio.overview.distribution.type.refereeRebate"), value: "REFEREE_REBATE" }, { label: u2("portfolio.overview.distribution.type.brokerFee"), value: "BROKER_FEE" }], [u2]);
  return jsxs(Fragment$1, { children: [jsx(lm, { items: [{ type: "select", name: "type", options: m2, value: s }, { type: "range", name: "dateRange", value: { from: l2[0], to: l2[1] } }], onFilter: (y2) => {
    i(y2);
  } }), jsx(dt$3, { bordered: true, columns: n4, dataSource: t, loading: r3, className: "oui-font-semibold", classNames: { root: "oui-h-[calc(100%_-_49px)]" }, pagination: e3.pagination })] });
};
var to$1 = () => {
  let [e3] = useState(() => {
    let f2 = /* @__PURE__ */ new Date();
    return new Date(getYear(f2), getMonth(f2), getDate(f2), 0, 0, 0);
  }), [t, o] = useState([k$3(90, e3), e3]), [i, r3] = useState("All"), { page: a2, pageSize: n4, setPage: s, parsePagination: l2 } = mm(), [u2, { isLoading: m2, meta: y2, isValidating: b2 }] = useDistributionHistory({ dataRange: [t[0].getTime(), set(t[1], { hours: 23, minutes: 59, seconds: 59, milliseconds: 0 }).getTime()], type: i, pageSize: n4, page: a2 }), p2 = (f2) => {
    f2.name === "type" && (r3(f2.value), s(1)), f2.name === "dateRange" && (o(Y(f2.value)), s(1));
  }, c2 = useMemo(() => l2(y2), [l2, y2]);
  return { dataSource: u2, isLoading: m2, isValidating: b2, queryParameter: { type: i, dateRange: t }, onFilter: p2, pagination: c2 };
};
var ye$3 = () => {
  let e3 = to$1();
  return jsx(ge$2, { ...e3 });
};
var oo$1 = (e3) => {
  let { active: t = "deposit", onTabChange: o } = e3, { t: i } = Z$2();
  return jsx(Rl, { children: jsxs(Cl, { value: t, onValueChange: o, variant: "contained", size: "xl", children: [jsx(Sl, { title: i("portfolio.overview.deposits&Withdrawals"), icon: jsx(ja, {}), value: "deposit", children: jsx(de, {}) }), jsx(Sl, { title: i("common.funding"), icon: jsx(Ka, {}), value: "funding", children: jsx(fe$2, {}) }), jsx(Sl, { title: i("portfolio.overview.distribution"), icon: jsx(cn, {}), value: "distribution", children: jsx(ye$3, {}) })] }) });
};
var io$2 = () => {
  let [e3, t] = useState("deposit");
  return { active: e3, onTabChange: (o) => t(o) };
};
var xe$1 = () => {
  let e3 = io$2();
  return jsx(oo$1, { ...e3 });
};
var be$2 = (e3) => {
  var _a2;
  let { periodTypes: t, period: o, onPeriodChange: i, aggregateValue: r3, invisible: a2, visible: n4, volumeUpdateDate: s } = e3, { t: l2 } = Z$2(), u2 = useMemo(() => ({ "7D": l2("common.select.7d"), "30D": l2("common.select.30d"), "90D": l2("common.select.90d") }), [l2]);
  return jsxs(Rl, { title: jsx(We$3, { onPeriodChange: i, periodTypes: t, period: o, title: l2("portfolio.overview.performance") }), id: "portfolio-overview-performance", children: [jsxs(ia$1, { cols: 3, gap: 4, children: [jsx(_$1, { gradient: "neutral", r: "md", px: 4, py: 2, angle: 184, border: true, borderColor: 6, children: jsx(da$2, { label: l2("portfolio.overview.performance.roi", { period: u2[o] }), valueProps: { rule: "percentages", coloring: true, visible: n4 }, children: a2 ? "--" : r3.roi }) }), jsx(_$1, { gradient: "neutral", r: "md", px: 4, py: 2, angle: 184, border: true, borderColor: 6, children: jsx(da$2, { label: l2("portfolio.overview.performance.pnl", { period: u2[o] }), valueProps: { coloring: true, showIdentifier: true, visible: n4 }, children: a2 ? "--" : r3.pnl }) }), jsx(_$1, { gradient: "neutral", r: "md", px: 4, py: 2, angle: 184, border: true, borderColor: 6, children: jsx(da$2, { classNames: { label: "oui-w-full" }, label: jsxs(z$1, { justify: "between", children: [jsx("span", { children: l2("portfolio.overview.performance.volume", { period: u2[o] }) }), jsx("span", { children: s })] }), children: a2 ? "--" : r3.vol }) })] }), jsxs(ia$1, { cols: 2, gap: 4, children: [jsx(Za, { data: e3.data ?? [], invisible: e3.invisible }), jsx(qa, { data: e3.data ?? [], invisible: e3.invisible || (((_a2 = e3.data) == null ? void 0 : _a2.length) ?? 0) <= 2 })] })] });
}, Za = (e3) => {
  var _a2;
  let { t } = Z$2();
  return jsxs(_$1, { mt: 4, height: "188px", children: [jsx($$4, { as: "div", size: "sm", className: "oui-mb-3", children: t("portfolio.overview.performance.dailyPnl") }), jsx(_$1, { r: "md", className: "oui-border oui-border-line-4 oui-h-[188px]", children: jsx(ct$1, { data: e3.data, invisible: e3.invisible || (((_a2 = e3.data) == null ? void 0 : _a2.length) ?? 0) <= 2 }) })] });
}, qa = (e3) => {
  var _a2;
  let { t } = Z$2();
  return jsxs(_$1, { mt: 4, children: [jsx($$4, { as: "div", size: "sm", className: "oui-mb-3", children: t("portfolio.overview.performance.cumulativePnl") }), jsx(_$1, { r: "md", className: "oui-border oui-border-line-4 oui-h-[188px]", children: jsx(Ft$4, { data: e3.data, invisible: e3.invisible || (((_a2 = e3.data) == null ? void 0 : _a2.length) ?? 0) <= 2 }) })] });
};
var he$1 = () => {
  let e3 = Ee$1(), [t] = useLocalStorage("orderly_assets_visible", true), { wrongNetwork: o, disabledConnect: i } = L$4(), { state: r3 } = useAccount(), a2 = xr$2(e3.data, { accountStatus: r3.status === AccountStatusEnum.EnableTradingWithoutConnected ? AccountStatusEnum.EnableTradingWithoutConnected : AccountStatusEnum.EnableTrading, fallbackData: e3.createFakeData({ account_value: 0, pnl: 0 }, { account_value: 500, pnl: 500 }) }), n4 = useMemo(() => (a2 == null ? void 0 : a2.length) ?? 0 > 0 ? a2 : e3.createFakeData({ account_value: 0, pnl: 0 }, { account_value: 500, pnl: 500 }), [a2]), s = o || i || r3.status < AccountStatusEnum.EnableTrading && r3.status !== AccountStatusEnum.EnableTradingWithoutConnected;
  return { ...e3, data: n4, invisible: s, visible: t };
};
var ve$2 = () => {
  let e3 = he$1();
  return jsx(be$2, { ...e3 });
};
var no$1 = () => jsx(Le$2, { children: jsxs(ia$1, { cols: 2, gap: 4, children: [jsx(ne$1, {}), jsx(ze$2, {}), jsx(ia$1.span, { colSpan: 2, children: jsx(ve$2, {}) }), jsx(ia$1.span, { colSpan: 2, children: jsx(xe$1, {}) })] }) });
var yo$2 = {};
$$1(yo$2, { FeeTierPage: () => go$1 });
var Ct$1 = [{ tier: 1, maker_fee: "0.03%", taker_fee: "0.06%", volume_min: 0, volume_max: 5e5 }, { tier: 2, maker_fee: "0.02%", taker_fee: "0.05%", volume_min: 5e5, volume_max: 25e5 }, { tier: 3, maker_fee: "0.015%", taker_fee: "0.045%", volume_min: 25e5, volume_max: 1e7 }, { tier: 4, maker_fee: "0.01%", taker_fee: "0.04%", volume_min: 1e7, volume_max: 5e7 }, { tier: 5, maker_fee: "0.005%", taker_fee: "0.035%", volume_min: 5e7, volume_max: 125e6, or: "/", staking_min: 3e5, staking_max: null }, { tier: 6, maker_fee: "0%", taker_fee: "0.03%", volume_min: 125e6, volume_max: null, or: "/", staking: null, staking_min: null, staking_max: null }];
var uo$1 = () => {
  let { t: e3 } = Z$2();
  return useMemo(() => [{ title: e3("portfolio.feeTier.column.tier"), dataIndex: "tier", align: "left", width: 100 }, { title: `${e3("portfolio.feeTier.column.30dVolume")} (USDC)`, dataIndex: "volume", align: "center", width: 170, render: (o, i) => {
    let { volume_min: r3, volume_max: a2, volume_node: n4 } = i;
    return n4 || (!r3 && !a2 ? jsx("div", { style: { fontVariantLigatures: "none" }, children: "--" }) : r3 && !a2 ? jsx("div", { children: e3("portfolio.feeTier.column.30dVolume.above", { volume: _$3(r3, r3 === 25e5 ? 1 : 0) }) }) : jsxs("div", { children: [r3 && _$3(r3, r3 === 25e5 ? 1 : 0), " - ", a2 && _$3(a2, a2 === 25e5 ? 1 : 0)] }));
  } }, { title: e3("portfolio.feeTier.column.maker"), dataIndex: "maker_fee", align: "right", width: 100, render: (o) => jsx($$4, { children: o }) }, { title: e3("portfolio.feeTier.column.taker"), dataIndex: "taker_fee", align: "right", width: 100, render: (o) => jsx($$4, { children: o }) }], [e3]);
};
function co$2(e3) {
  let { dataAdapter: t } = e3 || {}, [o, i] = useState(), { data: r3 } = useAccountInfo2(), { state: a2 } = useAccount(), n4 = uo$1(), { data: s } = usePrivateQuery("/v1/volume/user/stats"), { columns: l2, dataSource: u2 } = useMemo(() => typeof t == "function" ? t(n4, Ct$1) : { columns: n4, dataSource: Ct$1 }, [t, n4]), m2 = (c2, f2) => {
    let { futures_taker_fee_rate: ee2 = 0, futures_maker_fee_rate: V2 = 0 } = f2, G2 = `${new g$6(ee2).mul(0.01).toString()}%`, te2 = `${new g$6(V2).mul(0.01).toString()}%`;
    for (let D2 of c2) if (G2 === D2.taker_fee && te2 === D2.maker_fee) return D2.tier;
  };
  useEffect(() => {
    if (!r3) return;
    let c2 = m2(u2, r3);
    i(c2);
  }, [r3, u2]);
  let y2 = useMemo(() => {
    let c2 = r3 == null ? void 0 : r3.futures_taker_fee_rate;
    if (!(typeof c2 > "u")) return `${new g$6(c2).mul(0.01).toString()}%`;
  }, [r3]), b2 = useMemo(() => {
    let c2 = r3 == null ? void 0 : r3.futures_maker_fee_rate;
    if (!(typeof c2 > "u")) return `${new g$6(c2).mul(0.01).toString()}%`;
  }, [r3]);
  return { ...xr$2({ tier: o, vol: s == null ? void 0 : s.perp_volume_last_30_days, takerFeeRate: y2, makerFeeRate: b2 }, { accountStatus: a2.status === AccountStatusEnum.EnableTradingWithoutConnected ? AccountStatusEnum.EnableTradingWithoutConnected : AccountStatusEnum.EnableTrading }), columns: l2, dataSource: u2, onRow: e3 == null ? void 0 : e3.onRow };
}
var po$1 = (e3) => {
  let { columns: t, dataSource: o, tier: i, vol: r3, takerFeeRate: a2, makerFeeRate: n4 } = e3, { t: s } = Z$2();
  return jsxs(Rl, { title: jsxs(z$1, { justify: "between", children: [jsx($$4, { size: "lg", children: s("portfolio.feeTier") }), jsxs(z$1, { gap: 1, children: [jsx($$4, { size: "xs", intensity: 54, children: s("portfolio.feeTier.updatedDailyBy") }), jsx($$4, { size: "xs", intensity: 80, children: "2:00 UTC" })] })] }), className: "w-full", id: "oui-portfolio-fee-tier", children: [jsx(te$6, {}), jsx(Cn$1, { tier: i, vol: r3, takerFeeRate: a2, makerFeeRate: n4 }), jsx(hn, { dataSource: o, columns: t, tier: i, onRow: e3.onRow })] });
}, Cn$1 = (e3) => {
  let { t } = Z$2();
  return jsxs(z$1, { direction: "row", gapX: 4, my: 4, itemAlign: "stretch", children: [jsx(Ue$2, { label: t("portfolio.feeTier.header.yourTier"), value: jsx($$4.gradient, { color: "brand", angle: 270, size: "base", children: e3.tier || "--" }) }), jsx(Ue$2, { label: `${t("portfolio.feeTier.header.30dVolume")} (USDC)`, value: jsx($$4.numeral, { rule: "price", dp: 2, rm: g$6.ROUND_DOWN, children: typeof e3.vol !== void 0 ? `${e3.vol}` : "-" }) }), jsx(Ue$2, { label: t("portfolio.feeTier.header.takerFeeRate"), value: jsx($$4.gradient, { color: "brand", angle: 270, size: "base", children: e3.takerFeeRate || "--" }) }), jsx(Ue$2, { label: t("portfolio.feeTier.header.makerFeeRate"), value: jsx($$4.gradient, { color: "brand", angle: 270, size: "base", children: e3.makerFeeRate || "--" }) })] });
}, Ue$2 = (e3) => jsxs(_$1, { gradient: "neutral", r: "lg", px: 4, py: 2, angle: 184, width: "100%", border: true, borderColor: 6, children: [jsx($$4, { as: "div", intensity: 36, size: "2xs", weight: "semibold", className: "oui-leading-[18px]", children: e3.label }), jsx($$4, { size: "base", intensity: 80, className: "oui-leading-[24px] oui-mt-[2px]", children: e3.value })] }), hn = (e3) => {
  let [t, o] = useState(void 0);
  useEffect(() => {
    var _a2, _b2;
    let r3 = (_a2 = document.getElementById("oui-fee-tier-content")) == null ? void 0 : _a2.getBoundingClientRect(), a2 = (_b2 = document.getElementById("oui-fee-tier-current")) == null ? void 0 : _b2.getBoundingClientRect();
    if (a2 && r3 && e3.tier) {
      let n4 = a2.top - r3.top;
      o(n4);
    } else o(void 0);
  }, [e3.tier]);
  let i = useCallback((r3, a2) => {
    var _a2;
    let n4 = ((_a2 = e3 == null ? void 0 : e3.onRow) == null ? void 0 : _a2.call(e3, r3, a2)) ?? { normal: void 0, active: void 0 };
    return a2 + 1 == e3.tier ? { ...{ id: "oui-fee-tier-current", "data-state": "active", className: "group oui-h-12 oui-text-[rgba(0,0,0,0.88)] oui-pointer-events-none" }, ...n4.active } : { "data-state": "none", className: "oui-h-12", ...n4.normal };
  }, [e3.tier, e3.onRow]);
  return jsxs(_$1, { id: "oui-fee-tier-content", className: "oui-border-b oui-border-line-4 oui-relative", children: [t && jsx(_$1, { angle: 90, gradient: "brand", className: "oui-rounded-md oui-absolute oui-w-full", style: { top: `${t}px`, height: "48px" } }), jsx(jd, { bordered: true, className: "oui-font-semibold", classNames: { root: "oui-bg-transparent" }, onRow: i, columns: e3.columns, dataSource: e3.dataSource })] });
};
var fo$3 = (e3) => {
  let t = co$2(e3);
  return jsx(po$1, { ...t });
};
var go$1 = (e3) => jsx(fo$3, { ...e3 });
var Co$3 = {};
$$1(Co$3, { PositionsPage: () => _n });
var _n = (e3) => {
  let [t, o] = useState("Positions"), { t: i } = Z$2();
  return jsxs(z$1, { direction: "column", itemAlign: "start", gap: 4, width: "100%", height: "100%", children: [jsx(z$1, { children: jsx($$4, { size: "lg", children: i("common.positions") }) }), jsx(te$6, { className: "oui-w-full" }), jsx(_$1, { width: "100%", className: "oui-h-[calc(100%_-_59px)]", children: jsxs(Cl, { value: t, onValueChange: (r3) => o(r3), classNames: { tabsList: "!oui-border-none oui-pb-1", tabsContent: "oui-h-[calc(100%_-_28px)]" }, className: "oui-h-full", children: [jsx(Sl, { value: "Positions", title: i("common.positions"), children: jsx(Gr$2, { ...e3 }) }), jsx(Sl, { value: "Position history", title: i("positions.positionHistory"), children: jsx(Ls, { ...e3 }) }), jsx(Sl, { value: "Liquidation", title: i("positions.liquidation"), children: jsx(js, {}) })] }) })] });
};
var vo$2 = {};
$$1(vo$2, { OrdersPage: () => On });
var On = (e3) => {
  let { sharePnLConfig: t } = e3, { t: o } = Z$2(), i = useRef(null), r3 = () => {
    var _a2, _b2;
    (_b2 = (_a2 = i.current) == null ? void 0 : _a2.download) == null ? void 0 : _b2.call(_a2);
  };
  return jsxs(z$1, { direction: "column", itemAlign: "start", gap: 4, width: "100%", height: "100%", children: [jsxs(z$1, { width: "100%", justify: "between", children: [jsx($$4, { size: "lg", children: o("common.orders") }), jsx(Xn$2, { content: o("orders.download.tooltip"), children: jsxs(_e$5, { color: "gray", size: "sm", className: "oui-bg-base-4", onClick: r3, children: [o("common.download"), jsx(Bn, { className: "oui-text-base-contrast-36 oui-ml-[5px]" })] }) })] }), jsx(te$6, { className: "oui-w-full" }), jsx(_$1, { width: "100%", className: "oui-h-[calc(100%_-_59px)]", children: jsx(Ws, { ref: i, sharePnLConfig: t }) })] });
}, Bn = (e3) => jsx("svg", { width: "12", height: "12", viewBox: "0 0 12 12", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...e3, children: jsx("path", { d: "M5.999 1.007a5 5 0 1 0 0 10 5 5 0 0 0 0-10m0 2.5a.5.5 0 1 1 0 1 .5.5 0 0 1 0-1m0 1.5a.5.5 0 0 1 .5.5v2.5a.5.5 0 0 1-1 0v-2.5a.5.5 0 0 1 .5-.5" }) });
var Mo$1 = {};
$$1(Mo$1, { APIManagerPage: () => Lo$1, APIManagerWidget: () => Je$2 });
var wo$1 = (e3) => {
  var _a2;
  let { filterTags: t, keyStatus: o } = e3 ?? {}, [i, r3] = useState(false), [a2, n4] = useState(false), [s, l2] = useState(), { configStore: u2 } = useContext(OrderlyContext), m2 = u2.get("brokerId"), { wrongNetwork: y2, disabledConnect: b2 } = L$4(), { state: p2, account: c2 } = useAccount(), { t: f2 } = Z$2(), ee2 = !y2 && !b2 && (p2.status === AccountStatusEnum.EnableTrading || p2.status === AccountStatusEnum.EnableTradingWithoutConnected), { data: V2 } = useQuery(`/v1/get_account?address=${c2.address}&broker_id=${m2}&chain_type=${(_a2 = c2.walletAdapter) == null ? void 0 : _a2.chainNamespace}`), [G2, { generateOrderlyKey: te2, setIPRestriction: D2, removeOrderlyKey: et2, resetOrderlyKeyIPRestriction: _t2, refresh: d2, isLoading: C2, error: S2 }] = useApiKeyManager({ keyInfo: { key_status: o } }), [h2, w5] = useState(void 0);
  useEffect(() => {
    var _a3;
    (_a3 = c2.keyStore.getOrderlyKey()) == null ? void 0 : _a3.getPublicKey().then((v2) => {
      w5(v2);
    });
  }, [c2, p2]);
  let oe2 = () => {
    r3(true);
  }, ie2 = () => {
    window.open("https://orderly.network/docs/build-on-evm/evm-api/api-authentication", "_blank");
  }, Kt2 = () => {
    r3(false);
  }, Zo2 = async (v2, _2) => {
    var _a3;
    try {
      let A2 = (tt2, Ie2) => {
        var _a4;
        let { key: si2, secretKey: li2 } = tt2;
        Kt2(), l2({ key: si2, screctKey: li2, ip: Ie2, permissions: (_a4 = _2 == null ? void 0 : _2.split(",")) == null ? void 0 : _a4.map((ui2) => Ft$1(ui2)).join(", ") }), n4(true);
      }, K2 = await te2(_2);
      if (toast$2.success(f2("portfolio.apiKey.created")), ((v2 == null ? void 0 : v2.length) || 0) > 0) {
        let tt2 = K2.key.startsWith("ed25519:") ? K2.key : `ed25519:${K2.key}`, Ie2 = await D2(tt2, v2);
        Ie2.success && A2(K2, (_a3 = Ie2.data.ip_restriction_list) == null ? void 0 : _a3.join(","));
      } else A2(K2, void 0);
    } catch (A2) {
      (A2 == null ? void 0 : A2.message) && toast$2.error(A2 == null ? void 0 : A2.message);
    }
    return Promise.resolve(0);
  }, Ht2 = () => {
    n4(false), d2();
  }, qo2 = () => {
    navigator.clipboard.writeText(JSON.stringify(s)), toast$2.success(f2("portfolio.apiKey.apiInfo.copied"));
  }, Qo2 = () => {
    Ht2();
  }, Yo2 = (v2) => new Promise(async (_2) => {
    await et2(v2.orderly_key).then(async (A2) => {
      var _a3;
      if (A2 == null ? void 0 : A2.success) {
        toast$2.success(f2("portfolio.apiKey.deleted")), d2();
        let K2 = await ((_a3 = c2.keyStore.getOrderlyKey()) == null ? void 0 : _a3.getPublicKey());
        v2.orderly_key === K2 && c2.destroyOrderlyKey();
      }
      _2(1);
    }, (A2) => {
    }).catch((A2) => {
    });
  }), Xo2 = async (v2, _2) => {
    let A2;
    ((_2 == null ? void 0 : _2.length) || 0) === 0 ? A2 = _t2(v2.orderly_key, "ALLOW_ALL_IPS") : A2 = D2(v2.orderly_key, _2);
    let K2 = await A2;
    return K2.success ? (toast$2.success(f2("portfolio.apiKey.updated")), d2(), Promise.resolve()) : (toast$2.error(K2.message), Promise.reject());
  }, Jo2 = () => toast$2.success(f2("portfolio.apiKey.accountId.copied")), jo2 = (v2) => {
    typeof v2 < "u" && navigator.clipboard.writeText(v2.replace("ed25519:", "")), toast$2.success(f2("portfolio.apiKey.column.apiKey.copy"));
  }, ei2 = () => toast$2.success(f2("portfolio.apiKey.secretKey.copied")), ti2 = () => toast$2.success(f2("portfolio.apiKey.column.restrictedIP.copy")), oi2 = useMemo(() => G2 == null ? void 0 : G2.filter((v2) => {
    let _2 = t ? t == null ? void 0 : t.includes(v2.tag) : true, A2 = h2 ? !v2.orderly_key.includes(h2) : true;
    return _2 && A2;
  }), [G2, t, h2]), ii2 = (v2) => /^((25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])(,((25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9]))*$/.test(v2) ? "" : "The IP restriction format is incorrect. Please use the correct format: [xx.xx.xxx.x],[xx.xxx.xxx.xxx]", Nt2 = p2.status === AccountStatusEnum.EnableTradingWithoutConnected ? AccountStatusEnum.EnableTradingWithoutConnected : AccountStatusEnum.EnableTrading, ri2 = xr$2(V2 == null ? void 0 : V2.account_id, { accountStatus: Nt2 }), ai2 = xr$2(V2 == null ? void 0 : V2.user_id, { accountStatus: Nt2 }), { pagination: ni2 } = mm();
  return { address: ri2 ?? "--", uid: `${ai2 ?? "--"}`, onCreateApiKey: oe2, onReadApiGuide: ie2, showCreateDialog: i, hideCreateDialog: Kt2, doCreate: Zo2, showCreatedDialog: a2, hideCreatedDialog: Ht2, onCopyApiKeyInfo: qo2, doConfirm: Qo2, doDelete: Yo2, doEdit: Xo2, canCreateApiKey: ee2, status: p2.status, keys: oi2, generateKey: s, onCopyAccountId: Jo2, wrongNetwork: y2, onCopyApiKey: jo2, onCopyApiSecretKey: ei2, onCopyIP: ti2, verifyIP: ii2, isLoading: C2, pagination: ni2 };
};
function Ft$1(e3) {
  return e3.charAt(0).toUpperCase() + e3.slice(1);
}
var Ao$2 = (e3) => {
  let [t, o] = useState(""), [i, r3] = useState(true), [a2, n4] = useState(true), [s, l2] = useState(""), { t: u2 } = Z$2();
  return useEffect(() => {
    e3.showCreateDialog || (o(""), r3(true), n4(true), l2(""));
  }, [e3.showCreateDialog]), useEffect(() => {
    t.length === 0 && l2("");
  }, [t]), jsx(me$4, { size: "sm", open: e3.showCreateDialog, onOpenChange: (m2) => {
    var _a2;
    (_a2 = e3.hideCreateDialog) == null ? void 0 : _a2.call(e3);
  }, title: u2("portfolio.apiKey.create.dialog.title"), actions: { primary: { label: u2("common.confirm"), className: "oui-w-[120px] lg:oui-w-[154px]", "data-testid": "oui-testid-apiKey-createApiKey-dialog-comfirm-btn", onClick: async () => {
    if (t.length > 0) {
      let y2 = e3.verifyIP(t);
      if (l2(y2), y2.length > 0) return;
    }
    let m2 = [];
    i && m2.push("read"), a2 && m2.push("trading"), await e3.doCreate(t, m2.join(","));
  }, disabled: !a2 && !i, size: "md" } }, classNames: { footer: "oui-justify-center", content: "oui-bg-base-8 oui-w-[300px] lg:oui-w-[360px] oui-font-semibold" }, children: jsxs(z$1, { direction: "column", gap: 6, children: [jsxs(z$1, { direction: "column", gap: 1, width: "100%", itemAlign: "start", children: [jsx($$4, { intensity: 54, size: "2xs", children: u2("portfolio.apiKey.create.ipRestriction") }), jsx("textarea", { "data-testid": "oui-testid-apiKey-createApiKey-dialog-textarea", placeholder: u2("portfolio.apiKey.create.ipRestriction.placeholder"), className: cnBase("oui-text-sm oui-text-base-contrast-80 oui-p-3 oui-h-[100px] oui-rounded-xl oui-bg-base-6 oui-w-full", "oui-border-0 focus:oui-border-2 focus:oui-border-primary-darken oui-outline-none", "oui-placeholder-base-contrast-20", s.length > 0 && "oui-outline-1 oui-outline-danger focus:oui-outline-none"), value: t, onChange: (m2) => {
    o(m2.target.value);
  }, style: { resize: "none" } }), s.length > 0 && jsxs(z$1, { gap: 1, className: "oui-relative", children: [jsx("div", { className: cnBase("oui-absolute oui-top-[10px]", "oui-h-1 oui-w-1 oui-rounded-full oui-bg-danger") }), jsx($$4, { color: "danger", size: "xs", className: "oui-ml-2", children: s })] })] }), jsx(da$2, { label: jsx($$4, { size: "xs", intensity: 54, children: u2("portfolio.apiKey.permissions") }), className: "oui-w-full", children: jsxs(z$1, { direction: "row", gap: 6, itemAlign: "start", className: "oui-mt-2", children: [jsx(Pe$1, { size: 18, checked: i, onCheckedChange: (m2) => r3(m2), label: u2("portfolio.apiKey.permissions.read"), testid: "oui-testid-apiKey-createApiKey-dialog-read-checkbox" }), jsx(Pe$1, { size: 18, checked: a2, onCheckedChange: (m2) => n4(m2), label: u2("portfolio.apiKey.permissions.trading"), testid: "oui-testid-apiKey-createApiKey-dialog-trading-checkbox" })] }) })] }) });
}, Pe$1 = (e3) => jsxs("button", { disabled: e3.disabled, onClick: (t) => {
  e3.onCheckedChange(!e3.checked);
}, className: "disabled:oui-cursor-not-allowed disabled:oui-opacity-50 oui-flex oui-items-center oui-gap-2", "data-testid": e3.testid, children: [e3.checked ? jsx("svg", { width: "props.size", height: e3.size, viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M6.99072 2.92981C4.78172 2.92981 2.99072 4.72071 2.99072 6.92981V16.9298C2.99072 19.1389 4.78172 20.9298 6.99072 20.9298H16.9907C19.1997 20.9298 20.9907 19.1389 20.9907 16.9298V6.92981C20.9907 4.72071 19.1997 2.92981 16.9907 2.92981H6.99072ZM16.9853 7.31211C17.2125 7.09537 17.5236 7 17.8218 7C18.1201 7 18.4312 7.09537 18.6584 7.31211C19.1139 7.74546 19.1139 8.47384 18.6584 8.9072L10.5077 16.675C10.0534 17.1083 9.28909 17.1083 8.83472 16.675L5.34077 13.3459C4.88641 12.9126 4.88641 12.1841 5.34077 11.7508C5.79631 11.3175 6.56057 11.3175 7.01493 11.7508L9.67122 14.2822L16.9853 7.31211Z", fill: "white", fillOpacity: "0.54" }) }) : jsx("svg", { width: e3.size, height: e3.size, viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: jsx("path", { d: "M6.99072 2.92981C4.78172 2.92981 2.99072 4.72071 2.99072 6.92981V16.9298C2.99072 19.1389 4.78172 20.9298 6.99072 20.9298H16.9907C19.1997 20.9298 20.9907 19.1389 20.9907 16.9298V6.92981C20.9907 4.72071 19.1997 2.92981 16.9907 2.92981H6.99072ZM6.99072 4.92981H16.9907C18.0957 4.92981 18.9907 5.82521 18.9907 6.92981V16.9298C18.9907 18.0344 18.0957 18.9298 16.9907 18.9298H6.99072C5.88572 18.9298 4.99072 18.0344 4.99072 16.9298V6.92981C4.99072 5.82521 5.88572 4.92981 6.99072 4.92981Z", fill: "white", fillOpacity: "0.54" }) }), jsx($$4, { intensity: 54, size: "sm", className: "oui-break-normal oui-whitespace-nowrap", children: e3.label })] });
var Do$1 = (e3) => {
  var _a2, _b2, _c2, _d2;
  let t = ((_a2 = e3.generateKey) == null ? void 0 : _a2.ip) ?? "--", { t: o } = Z$2();
  return jsx(me$4, { size: "sm", open: e3.showCreatedDialog, onOpenChange: (i) => {
    var _a3;
    (_a3 = e3.hideCreatedDialog) == null ? void 0 : _a3.call(e3);
  }, title: o("portfolio.apiKey.created"), actions: { primary: { label: o("common.ok"), "data-testid": "oui-testid-apiKey-createdApiKey-dialog-ok-btn", className: "oui-w-[120px] lg:oui-w-[154px] oui-bg-base-2 hover:oui-bg-base-3", size: "md", onClick: async () => e3.doConfirm() }, secondary: { label: o("portfolio.apiKey.created.button.copyApiInfo"), "data-testid": "oui-testid-apiKey-createdApiKey-dialog-copy-btn", className: "oui-w-[120px] lg:oui-w-[154px] oui-bg-primary-darken hover:oui-opacity-80", size: "md", onClick: async () => e3.onCopyApiKeyInfo() } }, classNames: { footer: "oui-justify-center", content: "oui-bg-base-8 oui-w-[300px] lg:oui-w-[360px] oui-font-semibold", body: "oui-py-0 oui-pt-5" }, children: jsxs(z$1, { direction: "column", gap: 4, itemAlign: "start", children: [jsx(da$2, { label: o("portfolio.apiKey.accountId"), children: jsx($$4.formatted, { size: "sm", intensity: 80, copyable: true, copyIconSize: 16, className: "oui-break-all", onCopy: e3.onCopyAccountId, "data-testid": "oui-testid-apiKey-createdApiKey-dialog-key-span", children: e3.address }) }), jsx(da$2, { label: o("portfolio.apiKey.column.apiKey"), children: jsx($$4.formatted, { size: "sm", intensity: 80, copyable: true, copyIconSize: 16, className: "oui-break-all", onCopy: () => {
    var _a3;
    return e3.onCopyApiKey((_a3 = e3.generateKey) == null ? void 0 : _a3.key);
  }, "data-testid": "oui-testid-apiKey-createdApiKey-dialog-key-span", children: (_b2 = e3.generateKey) == null ? void 0 : _b2.key }) }), jsxs(da$2, { label: o("portfolio.apiKey.secretKey"), children: [jsx($$4.formatted, { size: "sm", intensity: 80, copyable: true, copyIconSize: 16, className: "oui-break-all", onCopy: e3.onCopyApiSecretKey, children: (_c2 = e3.generateKey) == null ? void 0 : _c2.screctKey }), " "] }), jsx(da$2, { label: o("portfolio.apiKey.ip"), children: jsxs(z$1, { width: 320, gap: 1, itemAlign: "center", className: "oui-text-base-contrast-80 oui-text-sm", children: [jsx(_$1, { className: "oui-max-h-[100px] oui-flex-1 oui-overflow-hidden oui-text-ellipsis oui-line-clamp-5 oui-break-all", children: t }), t !== "--" && jsx(_$1, { width: 16, height: 16, className: "oui-cursor-pointer oui-flex-shrink-0", children: jsx(at$3, { color: "white", opacity: 0.54, size: 16, onClick: (i) => {
    var _a3, _b3;
    ((_a3 = e3.generateKey) == null ? void 0 : _a3.ip) && navigator.clipboard.writeText((_b3 = e3.generateKey) == null ? void 0 : _b3.ip), e3 == null ? void 0 : e3.onCopyIP();
  } }) })] }) }), jsx(da$2, { label: o("portfolio.apiKey.permissions"), children: jsx($$4, { size: "sm", intensity: 80, "data-testid": "oui-testid-apiKey-createdApiKey-dialog-permissions-span", children: (_d2 = e3.generateKey) == null ? void 0 : _d2.permissions }) }), jsx("div", {}), jsx($$4, { color: "warning", size: "xs", className: "oui-text-center", children: o("portfolio.apiKey.created.warning") })] }) });
};
var ko$1 = (e3) => {
  let { item: t, open: o, setOpen: i, onDelete: r3 } = e3, { t: a2 } = Z$2();
  return jsx(me$4, { size: "sm", open: o, onOpenChange: i, title: a2("portfolio.apiKey.delete.dialog.title"), actions: { primary: { label: a2("common.confirm"), "data-testid": "oui-testid-apiKey-deleteApiKey-dialog-confirm-btn", className: "oui-w-[120px] lg:oui-w-[154px]", size: "md", onClick: async () => {
    var _a2;
    await ((_a2 = e3.onDelete) == null ? void 0 : _a2.call(e3, t)), i(false);
  } }, secondary: { label: a2("common.cancel"), className: "oui-w-[120px] lg:oui-w-[154px]", size: "md", onClick: async () => {
    i(false);
  } } }, classNames: { footer: "oui-justify-center", content: "oui-bg-base-8 oui-w-[300px] lg:oui-w-[360px] oui-font-semibold" }, children: jsx(z$1, { className: "oui-text-xs", children: jsx(Trans, { i18nKey: "portfolio.apiKey.delete.dialog.description", values: { apiKey: Dt$2(t == null ? void 0 : t.orderly_key) }, components: [jsx($$4, { color: "primary", className: "oui-px-1" })] }) }) });
};
var Ko$1 = (e3) => {
  var _a2;
  let { item: t, open: o, setOpen: i, onUpdate: r3 } = e3, [a2, n4] = useState((_a2 = t.ip_restriction_list) == null ? void 0 : _a2.join(",")), [s, l2] = useState(true), [u2, m2] = useState(true), [y2, b2] = useState(""), { t: p2 } = Z$2();
  return useEffect(() => {
    var _a3, _b2;
    n4(t.ip_restriction_list.join(",")), l2(((_a3 = t.scope) == null ? void 0 : _a3.toLocaleLowerCase().includes("read")) || false), m2(((_b2 = t.scope) == null ? void 0 : _b2.toLocaleLowerCase().includes("trading")) || false);
  }, [t]), useEffect(() => {
    a2.length === 0 && b2("");
  }, [a2]), jsx(me$4, { size: "sm", open: o, onOpenChange: i, title: p2("portfolio.apiKey.edit.dialog.title"), actions: { primary: { label: p2("common.confirm"), "data-testid": "oui-testid-apiKey-editApiKey-dialog-confirm-btn", className: "oui-w-[120px] lg:oui-w-[154px]", onClick: async () => {
    var _a3;
    if (a2.length > 0) {
      let c2 = e3.verifyIP(a2);
      if (b2(c2), c2.length > 0) return;
    }
    await ((_a3 = e3.onUpdate) == null ? void 0 : _a3.call(e3, t, a2)), i(false);
  }, disabled: t.ip_restriction_list.join(",") === a2, size: "md", fullWidth: true } }, classNames: { footer: "oui-justify-center", content: "oui-bg-base-8 oui-w-[300px] lg:oui-w-[360px] oui-font-semibold" }, children: jsxs(z$1, { direction: "column", gap: 6, children: [jsxs(z$1, { direction: "column", gap: 1, width: "100%", itemAlign: "start", children: [jsx($$4, { intensity: 54, size: "2xs", children: p2("portfolio.apiKey.create.ipRestriction") }), jsx("textarea", { "data-testid": "oui-testid-apiKey-editApiKey-dialog-textarea", placeholder: p2("portfolio.apiKey.create.ipRestriction.placeholder"), className: cnBase("oui-text-sm oui-text-base-contrast-80 oui-p-3 oui-h-[100px] oui-rounded-xl oui-bg-base-6 oui-w-full", "oui-border-0 focus:oui-border-2 focus:oui-border-primary-darken oui-outline-none", "oui-placeholder-base-contrast-20", y2.length > 0 && "oui-outline-1 oui-outline-danger focus:oui-outline-none"), value: a2, onChange: (c2) => {
    n4(c2.target.value);
  }, style: { resize: "none" } }), y2.length > 0 && jsxs(z$1, { gap: 1, className: "oui-relative", children: [jsx("div", { className: cnBase("oui-absolute oui-top-[10px]", "oui-h-1 oui-w-1 oui-rounded-full oui-bg-danger") }), jsx($$4, { color: "danger", size: "xs", className: "oui-ml-2", children: y2 })] })] }), jsx(da$2, { label: jsx($$4, { size: "xs", intensity: 54, children: p2("portfolio.apiKey.permissions") }), className: "oui-w-full", children: jsxs(z$1, { direction: "row", gap: 6, itemAlign: "start", className: "oui-mt-2", children: [jsx(Pe$1, { disabled: true, size: 18, checked: s, onCheckedChange: (c2) => l2(c2), label: p2("portfolio.apiKey.permissions.read") }), jsx(Pe$1, { disabled: true, size: 18, checked: u2, onCheckedChange: (c2) => m2(c2), label: p2("portfolio.apiKey.permissions.trading") })] }) })] }) });
};
var No$2 = (e3) => {
  let { t } = Z$2();
  return jsxs(Rl, { title: t("portfolio.apiKeys"), id: "portfolio-apikey-manager", className: "oui-bg-base-9 oui-font-semibold", children: [jsxs(z$1, { direction: "column", gap: 4, width: "100%", className: "oui-font-semibold", children: [jsx(vs, { ...e3 }), jsx(Ts, { ...e3 })] }), jsxs("div", { children: [jsx(ws, { ...e3 }), jsx(Ao$2, { ...e3 }), jsx(Do$1, { ...e3 })] })] });
}, vs = (e3) => {
  let { t } = Z$2();
  return jsxs(z$1, { width: "100%", gap: 4, className: "oui-border-t-2 oui-border-line-6 oui-pt-4", children: [jsxs(z$1, { py: 2, px: 4, direction: "column", itemAlign: "start", r: "xl", gradient: "neutral", angle: 27, border: true, className: "oui-w-1/2", children: [jsx($$4, { size: "xs", intensity: 36, children: t("portfolio.apiKey.accountId") }), jsx($$4.formatted, { size: "base", inlist: 80, rule: "address", copyable: e3.address !== "--", copyIconSize: 16, onCopy: e3.onCopyAccountId, copyIconTestid: "oui-testid-apiKey-accountInfo-accountId-copy-btn", children: e3.address })] }), jsxs(z$1, { py: 2, px: 4, direction: "column", itemAlign: "start", r: "xl", gradient: "neutral", angle: 27, border: true, className: "oui-w-1/2", children: [jsx($$4, { size: "xs", intensity: 36, children: t("portfolio.apiKey.uid") }), jsx($$4, { size: "base", inlist: 80, children: e3.uid })] })] });
}, Ts = (e3) => {
  let { t } = Z$2();
  return jsxs(z$1, { width: "100%", direction: "row", className: "oui-text-sm oui-border-b-2 oui-border-line-6 oui-pb-4", children: [jsxs(z$1, { direction: "column", itemAlign: "start", width: "100%", gap: 1, children: [jsx($$4, { intensity: 54, children: t("portfolio.apiKey.description") }), jsxs(z$1, { itemAlign: "center", className: "oui-text-primary-light oui-fill-primary-light hover:oui-text-primary-darken oui-cursor-pointer oui-text-2xs md:oui-text-xs xl:oui-text-sm", onClick: e3.onReadApiGuide, children: [jsx($$4, { children: t("portfolio.apiKey.readApiGuide") }), jsx("svg", { width: "16", height: "16", viewBox: "0 0 16 16", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", children: jsx("path", { d: "M4.008 7.995c0-.368.298-.666.666-.666H9.71L7.733 5.331l.937-.936 3.143 3.122c.13.13.195.304.195.479a.67.67 0 0 1-.195.478L8.67 11.596l-.937-.937 1.978-1.998H4.674a.666.666 0 0 1-.666-.666" }) })] })] }), jsx(ue$7, { side: "top", tooltip: { connectWallet: t("portfolio.apiKey.create.connectWallet.tooltip"), signIn: t("portfolio.apiKey.create.signIn.tooltip"), enableTrading: t("portfolio.apiKey.create.enableTrading.tooltip"), wrongNetwork: t("portfolio.apiKey.create.wrongNetwork.tooltip") }, children: jsx(_e$5, { size: "md", icon: jsx(ac, {}), variant: "contained", color: "primary", onClick: e3.onCreateApiKey, disabled: !e3.canCreateApiKey, "data-testid": "oui-testid-apiKey-createApiKey-btn", children: t("portfolio.apiKey.create.dialog.title") }) })] });
}, ws = (e3) => {
  let { t } = Z$2(), o = [{ title: t("portfolio.apiKey.column.apiKey"), dataIndex: "orderly_key", render: (i) => jsx($$4.formatted, { rule: "", copyable: true, copyIconSize: 16, onCopy: () => {
    var _a2;
    (_a2 = e3.onCopyApiKey) == null ? void 0 : _a2.call(e3, i);
  }, children: Dt$2(i) }) }, { title: t("portfolio.apiKey.column.permissionType"), dataIndex: "scope", render: (i) => i == null ? void 0 : i.split(",").map((r3) => Ft$1(`${r3}`)).join(", ") }, { title: t("portfolio.apiKey.column.restrictedIP"), dataIndex: "ip_restriction_list", render: (i) => {
    let r3 = i.join(",");
    return r3.length === 0 && (r3 = "--"), jsx(Xn$2, { content: r3, className: "oui-max-w-[200px] oui-break-all", children: jsxs(z$1, { gap: 1, children: [jsx("div", { className: " oui-overflow-ellipsis oui-overflow-hidden", children: r3 }), r3 !== "--" && jsx(_$1, { width: 16, height: 16, className: "oui-cursor-pointer", children: jsx(at$3, { color: "white", opacity: 0.54, size: 16, onClick: (a2) => {
      navigator.clipboard.writeText(r3), e3 == null ? void 0 : e3.onCopyIP();
    } }) })] }) });
  } }, { title: t("portfolio.apiKey.column.expirationDate"), dataIndex: "expiration", render: (i) => jsx($$4.formatted, { rule: "date", formatString: "yyyy-MM-dd", children: i }) }, { title: "", type: "action", dataIndex: "action", width: 120, render: (i, r3) => jsxs(z$1, { direction: "row", gap: 2, children: [jsx(Ps, { item: r3, onUpdate: e3.doEdit, verifyIP: e3.verifyIP }), jsx(Ss, { item: r3, onDelete: e3.doDelete })] }) }];
  return jsx(dt$3, { bordered: true, columns: o, loading: e3.isLoading, dataSource: e3.keys, emptyView: jsx(le$5, {}), classNames: {}, pagination: e3.pagination, manualPagination: false });
}, Ps = (e3) => {
  let { item: t, onUpdate: o, verifyIP: i } = e3, [r3, a2] = useState(false), { t: n4 } = Z$2();
  return jsxs(Fragment$1, { children: [jsx(_e$5, { size: "xs", color: "primary", variant: "contained", onClick: (s) => {
    s.stopPropagation(), a2(true);
  }, "data-testid": "oui-testid-apiKey-keyList-edit-btn", children: n4("common.edit") }), r3 && jsx(Ko$1, { item: t, open: r3, setOpen: a2, onUpdate: o, verifyIP: i })] });
}, Ss = (e3) => {
  let { item: t, onDelete: o } = e3, [i, r3] = useState(false), { t: a2 } = Z$2();
  return jsxs(Fragment$1, { children: [jsx(_e$5, { size: "xs", color: "gray", variant: "contained", onClick: (n4) => {
    n4.stopPropagation(), r3(true);
  }, "data-testid": "oui-testid-apiKey-keyList-delete-btn", children: a2("common.delete") }), i && jsx(ko$1, { item: t, open: i, setOpen: r3, onDelete: o })] });
};
function Dt$2(e3) {
  return typeof e3 > "u" ? "-" : `${`${e3}`.replace("ed25519:", "").slice(0, 6)}*****`;
}
var Je$2 = (e3) => {
  let t = wo$1(e3);
  return jsx(No$2, { ...t });
};
var Lo$1 = (e3) => {
  let { filterTags: t, keyStatus: o = "ACTIVE" } = e3;
  return jsx(Je$2, { filterTags: t, keyStatus: o });
};
var $o = {};
$$1($o, { SettingPage: () => Go$1, SettingWidget: () => je$2 });
var Bo$1 = (e3) => {
  let { t } = Z$2();
  return jsx(Rl, { title: t("portfolio.setting.systemUpgrade"), id: "portfolio-apikey-manager", className: "oui-bg-base-9 oui-font-semibold", children: jsxs(z$1, { direction: "row", gap: 4, width: "100%", itemAlign: "center", pt: 4, className: "oui-font-semibold oui-border-t-2 oui-border-line-6", children: [jsxs(z$1, { direction: "column", itemAlign: "start", className: "oui-flex-1", children: [jsx($$4, { intensity: 80, size: "base", children: t("portfolio.setting.cancelOpenOrders") }), jsx($$4, { intensity: 54, size: "sm", children: t("portfolio.setting.cancelOpenOrders.description") })] }), jsx(ue$7, { align: "end", children: jsx(Zr$2, { checked: e3.maintenance_cancel_orders, onCheckedChange: (o) => {
    e3.setMaintainConfig(o);
  }, disabled: e3.isSetting || !e3.canTouch, "data-testid": "oui-testid-setting-switch-btn" }) })] }) });
};
var Vo$3 = () => {
  let { data: e3, mutate: t } = useAccountInfo2(), { wrongNetwork: o, disabledConnect: i } = L$4(), [r3, { isMutating: a2 }] = useMutation("/v1/client/maintenance_config"), [n4, s] = useState(false);
  useEffect(() => {
    s((e3 == null ? void 0 : e3.maintenance_cancel_orders) || false);
  }, [e3]);
  let l2 = useDebouncedCallback((b2) => {
    r3({ maintenance_cancel_order_flag: b2 }).then((p2) => {
      p2.success || s(!b2);
    });
  }, 300), u2 = (b2) => {
    s(b2), l2(b2);
  }, { state: m2 } = useAccount(), y2 = !o && !i && (m2.status === AccountStatusEnum.EnableTrading || m2.status === AccountStatusEnum.EnableTradingWithoutConnected);
  return { maintenance_cancel_orders: n4, setMaintainConfig: u2, isSetting: false, canTouch: y2 };
};
var je$2 = () => {
  let e3 = Vo$3();
  return jsx(Bo$1, { ...e3 });
};
var Go$1 = () => jsx(je$2, {});
var _excluded = ["prefixCls", "className", "children", "mode", "visiable", "visible", "renderBar", "lineBar", "disable", "onDragEnd", "onDragging"];
class Split extends Ce__default__default.Component {
  constructor(props) {
    super(props);
    this.state = {
      dragging: false
    };
    this.warpper = void 0;
    this.paneNumber = void 0;
    this.startX = void 0;
    this.startY = void 0;
    this.move = void 0;
    this.target = void 0;
    this.boxWidth = void 0;
    this.boxHeight = void 0;
    this.preWidth = void 0;
    this.nextWidth = void 0;
    this.preHeight = void 0;
    this.nextHeight = void 0;
    this.preSize = void 0;
    this.nextSize = void 0;
    this.onDragEnd = this.onDragEnd.bind(this);
    this.onDragging = this.onDragging.bind(this);
  }
  componentWillUnmount() {
    this.removeEvent();
  }
  removeEvent() {
    window.removeEventListener("mousemove", this.onDragging, false);
    window.removeEventListener("mouseup", this.onDragEnd, false);
  }
  onMouseDown(paneNumber, env) {
    if (!env.target || !this.warpper) {
      return;
    }
    this.paneNumber = paneNumber;
    this.startX = env.clientX;
    this.startY = env.clientY;
    this.move = true;
    this.target = env.target.parentNode;
    var prevTarget = this.target.previousElementSibling;
    var nextTarget = this.target.nextElementSibling;
    this.boxWidth = this.warpper.clientWidth;
    this.boxHeight = this.warpper.clientHeight;
    if (prevTarget) {
      this.preWidth = prevTarget.clientWidth;
      this.preHeight = prevTarget.clientHeight;
    }
    if (nextTarget) {
      this.nextWidth = nextTarget.clientWidth;
      this.nextHeight = nextTarget.clientHeight;
    }
    window.addEventListener("mousemove", this.onDragging);
    window.addEventListener("mouseup", this.onDragEnd, false);
    this.setState({
      dragging: true
    });
  }
  onDragging(env) {
    if (!this.move) {
      return;
    }
    if (!this.state.dragging) {
      this.setState({
        dragging: true
      });
    }
    var {
      mode: mode2,
      onDragging
    } = this.props;
    var nextTarget = this.target.nextElementSibling;
    var prevTarget = this.target.previousElementSibling;
    var x2 = env.clientX - this.startX;
    var y2 = env.clientY - this.startY;
    this.preSize = 0;
    this.nextSize = 0;
    if (mode2 === "horizontal") {
      this.preSize = this.preWidth + x2 > -1 ? this.preWidth + x2 : 0;
      this.nextSize = this.nextWidth - x2 > -1 ? this.nextWidth - x2 : 0;
      if (this.preSize === 0 || this.nextSize === 0) {
        return;
      }
      this.preSize = (this.preSize / this.boxWidth >= 1 ? 1 : this.preSize / this.boxWidth) * 100;
      this.nextSize = (this.nextSize / this.boxWidth >= 1 ? 1 : this.nextSize / this.boxWidth) * 100;
      if (prevTarget && nextTarget) {
        prevTarget.style.width = this.preSize + "%";
        nextTarget.style.width = this.nextSize + "%";
      }
    }
    if (mode2 === "vertical" && this.preHeight + y2 > -1 && this.nextHeight - y2 > -1) {
      this.preSize = this.preHeight + y2 > -1 ? this.preHeight + y2 : 0;
      this.nextSize = this.nextHeight - y2 > -1 ? this.nextHeight - y2 : 0;
      this.preSize = (this.preSize / this.boxHeight >= 1 ? 1 : this.preSize / this.boxHeight) * 100;
      this.nextSize = (this.nextSize / this.boxHeight >= 1 ? 1 : this.nextSize / this.boxHeight) * 100;
      if (this.preSize === 0 || this.nextSize === 0) {
        return;
      }
      if (prevTarget && nextTarget) {
        prevTarget.style.height = this.preSize + "%";
        nextTarget.style.height = this.nextSize + "%";
      }
    }
    onDragging && onDragging(this.preSize, this.nextSize, this.paneNumber);
  }
  onDragEnd() {
    var {
      onDragEnd
    } = this.props;
    this.move = false;
    onDragEnd && onDragEnd(this.preSize, this.nextSize, this.paneNumber);
    this.removeEvent();
    this.setState({
      dragging: false
    });
  }
  render() {
    var _this$props$visible;
    var _this$props = this.props, {
      prefixCls,
      className,
      children,
      mode: mode2,
      visible = (_this$props$visible = this.props.visible) != null ? _this$props$visible : this.props.visiable,
      renderBar,
      lineBar,
      disable
    } = _this$props, other = _objectWithoutPropertiesLoose(_this$props, _excluded);
    var {
      dragging
    } = this.state;
    var cls = [prefixCls, className, prefixCls + "-" + mode2, dragging ? "dragging" : null].filter(Boolean).join(" ").trim();
    var child = Ce__default__default.Children.toArray(children);
    return /* @__PURE__ */ jsx("div", _extends({
      className: cls
    }, other, {
      ref: (node) => this.warpper = node,
      children: Ce__default__default.Children.map(child, (element, idx) => {
        var props = Object.assign({}, element.props, {
          className: [prefixCls + "-pane", element.props.className].filter(Boolean).join(" ").trim(),
          style: _extends({}, element.props.style)
        });
        var visibleBar = visible === true || visible && visible.includes(idx + 1) || false;
        var barProps = {
          className: [prefixCls + "-bar", lineBar ? prefixCls + "-line-bar" : null, !lineBar ? prefixCls + "-large-bar" : null].filter(Boolean).join(" ").trim()
        };
        if (disable === true || disable && disable.includes(idx + 1)) {
          barProps.className = [barProps.className, disable ? "disable" : null].filter(Boolean).join(" ").trim();
        }
        var BarCom = null;
        if (idx !== 0 && visibleBar && renderBar) {
          BarCom = renderBar(_extends({}, barProps, {
            onMouseDown: this.onMouseDown.bind(this, idx + 1)
          }));
        } else if (idx !== 0 && visibleBar) {
          BarCom = /* @__PURE__ */ Ce__default__default.createElement("div", _extends({}, barProps), /* @__PURE__ */ jsx("div", {
            onMouseDown: this.onMouseDown.bind(this, idx + 1)
          }));
        }
        return /* @__PURE__ */ jsxs(Ce__default__default.Fragment, {
          children: [BarCom, /* @__PURE__ */ Ce__default__default.cloneElement(element, _extends({}, props))]
        }, idx);
      })
    }));
  }
}
Split.defaultProps = {
  prefixCls: "w-split",
  visiable: true,
  mode: "horizontal"
};
function Le$1(r3) {
  return jsx("div", { className: "top-toolbar oui-flex oui-h-[44px] oui-justify-between md:oui-justify-start oui-items-center oui-p-2 md:oui-px-3 md:oui-pt-3 md:oui-pb-[14px]", children: r3.children });
}
var Q = (r3) => jsx("svg", { viewBox: "0 0 12 12", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...r3, children: jsx("g", { id: "Caret-down", children: jsx("path", { id: "Vector", d: "M3.00349 3.9978C2.59149 3.9978 2.36564 4.4653 2.61289 4.7948C2.98789 5.2948 5.23784 8.29479 5.61289 8.79479C5.81289 9.06128 6.20974 9.06128 6.40974 8.79479L9.40974 4.7948C9.65694 4.4653 9.41554 3.9978 9.00349 3.9978H3.00349Z" }) }) }), we$1 = (r3) => jsx("svg", { viewBox: "0 0 18 18", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...r3, children: jsx("g", { id: "Display settings", children: jsx("path", { id: "Union", fillRule: "evenodd", clipRule: "evenodd", d: "M15.0571 10.9856L11.6295 5.06523L8.71377 10.8968C8.38933 11.5456 7.54464 11.7223 6.98733 11.2579L5.75311 10.2294L2.83709 14.7654L1.57532 13.9543L4.49134 9.41824C4.97892 8.65978 6.0207 8.49981 6.71338 9.07705L7.58387 9.80246L10.5991 3.77192C10.9997 2.97082 12.1302 2.93624 12.579 3.71137L14.6517 7.29147C14.7714 7.03643 15.0305 6.85983 15.3309 6.85983C15.7451 6.85983 16.0809 7.19562 16.0809 7.60983C16.0809 8.02405 15.7451 8.35983 15.3309 8.35983C15.31 8.35983 15.2892 8.35897 15.2687 8.35729L16.3553 10.2341L15.0571 10.9856ZM2.58093 6.85983C2.16672 6.85983 1.83093 7.19562 1.83093 7.60983C1.83093 8.02405 2.16672 8.35983 2.58093 8.35983C2.99515 8.35983 3.33093 8.02405 3.33093 7.60983C3.33093 7.19562 2.99515 6.85983 2.58093 6.85983ZM4.83093 6.85983C4.41672 6.85983 4.08093 7.19562 4.08093 7.60983C4.08093 8.02405 4.41672 8.35983 4.83093 8.35983C5.24515 8.35983 5.58093 8.02405 5.58093 7.60983C5.58093 7.19562 5.24515 6.85983 4.83093 6.85983ZM6.33093 7.60983C6.33093 7.19562 6.66672 6.85983 7.08093 6.85983C7.49515 6.85983 7.83093 7.19562 7.83093 7.60983C7.83093 8.02405 7.49515 8.35983 7.08093 8.35983C6.66672 8.35983 6.33093 8.02405 6.33093 7.60983ZM11.5809 6.85983C11.1667 6.85983 10.8309 7.19562 10.8309 7.60983C10.8309 8.02405 11.1667 8.35983 11.5809 8.35983C11.9951 8.35983 12.3309 8.02405 12.3309 7.60983C12.3309 7.19562 11.9951 6.85983 11.5809 6.85983Z" }) }) });
var ct = (r3) => jsx("svg", { viewBox: "0 0 18 18", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...r3, children: jsx("g", { id: "Indicators", children: jsx("path", { id: "Union", fillRule: "evenodd", clipRule: "evenodd", d: "M9.74483 2.25C8.96145 2.25 8.26885 2.76459 8.04549 3.51818L7.46202 5.48254H5.06262V7.08339H6.98652L5.00539 13.7532L4.31554 13.1112L3.22498 14.2831L4.4777 15.4489C5.08739 16.015 6.08317 15.7469 6.32134 14.945L8.65649 7.08339H11.6032V5.48254H9.13198L9.58033 3.97311C9.60167 3.90112 9.66833 3.85084 9.74483 3.85084H11.69V2.25H9.74483ZM10.6234 11.2354L10.2638 11.5172C10.0153 11.712 9.65591 11.6684 9.46115 11.4199C9.26639 11.1713 9.30998 10.812 9.55852 10.6172L10.1451 10.1575C10.5693 9.82514 11.1868 9.94011 11.4642 10.4005L11.4682 10.407L12.1304 11.5752L13.4594 10.3111C13.6882 10.0935 14.05 10.1025 14.2677 10.3313C14.4853 10.5601 14.4763 10.922 14.2475 11.1396L12.7116 12.6006L13.3897 13.797L13.6482 13.4503C13.8369 13.1972 14.1951 13.145 14.4483 13.3337C14.7014 13.5225 14.7536 13.8807 14.5649 14.1338L13.9917 14.9025L13.94 14.9457C13.5178 15.2981 12.8837 15.1886 12.6003 14.7226L12.5958 14.7151L11.8576 13.4129L10.3563 14.841C10.1275 15.0586 9.76561 15.0495 9.54798 14.8208C9.33036 14.592 9.3394 14.2301 9.56819 14.0125L11.2764 12.3875L10.6234 11.2354Z" }) }) }), ut = (r3) => jsx("svg", { viewBox: "0 0 18 18", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...r3, children: jsx("g", { id: "Setting", children: jsx("path", { id: "Vector", d: "M6.72589 1.84154C5.66239 2.17904 4.74515 2.72954 3.93665 3.48254C3.6869 3.71504 3.6104 4.09604 3.7724 4.39604C4.37315 5.50679 3.74464 6.69554 2.38939 6.76379C2.05789 6.78029 1.76465 7.0263 1.68665 7.34955C1.5524 7.9083 1.49915 8.37629 1.49915 8.98979C1.49915 9.50504 1.55464 10.0885 1.66339 10.6075C1.73089 10.9315 2.0129 11.1648 2.3429 11.1933C3.7064 11.311 4.3814 12.3513 3.7724 13.6773C3.6374 13.972 3.6989 14.3245 3.93665 14.545C4.73315 15.2815 5.64814 15.8013 6.72589 16.1388C7.03339 16.2348 7.38064 16.1185 7.56964 15.8575C8.40364 14.7033 9.6134 14.6995 10.4054 15.8575C10.5921 16.1298 10.9341 16.261 11.2491 16.162C12.2894 15.8343 13.2584 15.277 14.0616 14.545C14.3091 14.3193 14.3744 13.954 14.2259 13.654C13.6019 12.3948 14.3197 11.239 15.6082 11.2165C15.9502 11.2105 16.2547 10.9863 16.3349 10.654C16.4647 10.1163 16.4991 9.64829 16.4991 8.98979C16.4991 8.42429 16.4324 7.86704 16.3116 7.32629C16.2351 6.98354 15.9359 6.74054 15.5849 6.73979C14.3167 6.73754 13.6056 5.49104 14.2259 4.39604C14.3984 4.09154 14.3444 3.71804 14.0849 3.48254C13.2674 2.74004 12.2706 2.15954 11.2259 1.84154C10.9049 1.74404 10.5636 1.86404 10.3821 2.14604C9.65764 3.27179 8.30465 3.29129 7.5929 2.17004C7.41065 1.88204 7.04989 1.73879 6.72589 1.84154ZM11.2844 3.43455C11.7966 3.64905 12.2009 3.8733 12.6651 4.22505C12.1206 5.9478 13.0439 7.73729 14.9564 8.17304C15.0036 8.48279 14.9991 8.67029 14.9991 8.98979C14.9991 9.37154 15.0044 9.50579 14.9609 9.78179C13.0566 10.1763 12.1146 11.9155 12.6449 13.7538C12.1889 14.0845 11.8626 14.314 11.2904 14.5353C9.94639 13.1673 8.0804 13.1073 6.7079 14.5443C6.1724 14.3088 5.76066 14.0995 5.34441 13.7478C5.86041 11.881 4.98815 10.2693 3.05165 9.7803C2.9654 9.4383 2.9999 8.4723 3.0494 8.17905C5.0519 7.69905 5.8409 5.92679 5.34365 4.21979C5.78315 3.88904 6.1784 3.6483 6.69215 3.4398C7.9859 4.75605 9.92839 4.8873 11.2844 3.43455ZM8.99915 5.98979C7.3424 5.98979 5.99915 7.33304 5.99915 8.98979C5.99915 10.6473 7.3424 11.9898 8.99915 11.9898C10.6559 11.9898 11.9991 10.6473 11.9991 8.98979C11.9991 7.33304 10.6559 5.98979 8.99915 5.98979ZM8.99915 7.48979C9.8279 7.48979 10.4991 8.16179 10.4991 8.98979C10.4991 9.81855 9.8279 10.4898 8.99915 10.4898C8.1704 10.4898 7.49915 9.81855 7.49915 8.98979C7.49915 8.16179 8.1704 7.48979 8.99915 7.48979Z" }) }) }), dt$1 = (r3) => jsx("svg", { viewBox: "0 0 20 20", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...r3, children: jsx("g", { id: "Bars", children: jsx("path", { id: "Union", fillRule: "evenodd", clipRule: "evenodd", d: "M12.5 15.5C12.5 15.7761 12.7239 16 13 16H14C14.2761 16 14.5 15.7761 14.5 15.5V14H16C16.2761 14 16.5 13.7761 16.5 13.5V12.5C16.5 12.2239 16.2761 12 16 12H14.5V2.5C14.5 2.22386 14.2761 2 14 2H13C12.7239 2 12.5 2.22386 12.5 2.5V4H11C10.7239 4 10.5 4.22386 10.5 4.5V5.5C10.5 5.77614 10.7239 6 11 6H12.5V15.5ZM5.5 17.5C5.5 17.7761 5.72386 18 6 18H7C7.27614 18 7.5 17.7761 7.5 17.5V10H9C9.27614 10 9.5 9.77614 9.5 9.5V8.5C9.5 8.22386 9.27614 8 9 8H7.5V4.5C7.5 4.22386 7.27614 4 7 4H6C5.72386 4 5.5 4.22386 5.5 4.5V14H4C3.72386 14 3.5 14.2239 3.5 14.5V15.5C3.5 15.7761 3.72386 16 4 16H5.5V17.5Z" }) }) }), pt$1 = (r3) => jsx("svg", { viewBox: "0 0 20 20", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...r3, children: jsx("g", { id: "Candles", children: jsx("path", { id: "Union", fillRule: "evenodd", clipRule: "evenodd", d: "M7.25 2.5V4H8.5C8.77614 4 9 4.22386 9 4.5V15.5C9 15.7761 8.77614 16 8.5 16H7.25V17.5C7.25 17.7761 7.02614 18 6.75 18H6.25C5.97386 18 5.75 17.7761 5.75 17.5V16H4.5C4.22386 16 4 15.7761 4 15.5V4.5C4 4.22386 4.22386 4 4.5 4H5.75V2.5C5.75 2.22386 5.97386 2 6.25 2H6.75C7.02614 2 7.25 2.22386 7.25 2.5ZM5.5 5.5V14.5H7.5V5.5H5.5ZM14.25 4.5V7H15.5C15.7761 7 16 7.22386 16 7.5V15.5C16 15.7761 15.7761 16 15.5 16H14.25V17.5C14.25 17.7761 14.0261 18 13.75 18H13.25C12.9739 18 12.75 17.7761 12.75 17.5V16H11.5C11.2239 16 11 15.7761 11 15.5V7.5C11 7.22386 11.2239 7 11.5 7H12.75V4.5C12.75 4.22386 12.9739 4 13.25 4H13.75C14.0261 4 14.25 4.22386 14.25 4.5ZM12.5 8.5V14.5H14.5V8.5H12.5Z" }) }) }), mt = (r3) => jsx("svg", { viewBox: "0 0 20 20", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...r3, children: jsxs("g", { id: "Hollow Candles", children: [jsx("path", { id: "Subtract", fillRule: "evenodd", clipRule: "evenodd", d: "M5.5 14.5V5.5H7.5V14.5H5.5Z", fill: "white", fillOpacity: "0.12" }), jsx("path", { id: "Union", fillRule: "evenodd", clipRule: "evenodd", d: "M7.25 2.5V4H8.5C8.77614 4 9 4.22386 9 4.5V15.5C9 15.7761 8.77614 16 8.5 16H7.25V17.5C7.25 17.7761 7.02614 18 6.75 18H6.25C5.97386 18 5.75 17.7761 5.75 17.5V16H4.5C4.22386 16 4 15.7761 4 15.5V4.5C4 4.22386 4.22386 4 4.5 4H5.75V2.5C5.75 2.22386 5.97386 2 6.25 2H6.75C7.02614 2 7.25 2.22386 7.25 2.5ZM5.5 5.5V14.5H7.5V5.5H5.5ZM14.25 4.5V7H15.5C15.7761 7 16 7.22386 16 7.5V15.5C16 15.7761 15.7761 16 15.5 16H14.25V17.5C14.25 17.7761 14.0261 18 13.75 18H13.25C12.9739 18 12.75 17.7761 12.75 17.5V16H11.5C11.2239 16 11 15.7761 11 15.5V7.5C11 7.22386 11.2239 7 11.5 7H12.75V4.5C12.75 4.22386 12.9739 4 13.25 4H13.75C14.0261 4 14.25 4.22386 14.25 4.5ZM12.5 8.5V14.5H14.5V8.5H12.5Z" })] }) }), gt = (r3) => jsx("svg", { viewBox: "0 0 20 20", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...r3, children: jsx("g", { id: "Line", children: jsx("path", { id: "Vector 16 (Stroke)", fillRule: "evenodd", clipRule: "evenodd", d: "M18.3 2.72288C18.542 2.85596 18.6303 3.15999 18.4972 3.40195L13.495 12.4968C13.0776 13.2557 12.1061 13.5044 11.3754 13.0394L7.19878 10.3816L2.97738 17.558C2.83737 17.796 2.53092 17.8754 2.2929 17.7354L1.43097 17.2284C1.19295 17.0884 1.1135 16.7819 1.25351 16.5439L5.73746 8.92122C6.16792 8.18943 7.1194 7.96045 7.83567 8.41626L11.9995 11.0659L16.7448 2.43811C16.8778 2.19615 17.1819 2.10788 17.4238 2.24096L18.3 2.72288Z" }) }) }), ft = (r3) => jsx("svg", { viewBox: "0 0 20 20", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...r3, children: jsxs("g", { id: "Area", children: [jsx("path", { id: "Vector 16 (Stroke)", fillRule: "evenodd", clipRule: "evenodd", d: "M18.3 2.72288C18.542 2.85596 18.6303 3.15999 18.4972 3.40195L13.495 12.4968C13.0776 13.2557 12.1061 13.5044 11.3754 13.0394L7.19878 10.3816L2.97738 17.558C2.83737 17.796 2.53092 17.8754 2.2929 17.7354L1.43097 17.2284C1.19295 17.0884 1.1135 16.7819 1.25351 16.5439L5.73746 8.92122C6.16792 8.18943 7.1194 7.96045 7.83567 8.41626L11.9995 11.0659L16.7448 2.43811C16.8778 2.19615 17.1819 2.10788 17.4238 2.24096L18.3 2.72288Z" }), jsx("path", { id: "Subtract", fillRule: "evenodd", clipRule: "evenodd", d: "M2.7608 17.7562C2.84602 17.899 3.00106 18 3.19016 18H16.362C17.4665 18 18.362 17.1046 18.362 16V3.94663C18.362 3.86618 18.3453 3.79397 18.3162 3.73108L13.495 12.4968C13.0776 13.2557 12.1061 13.5044 11.3754 13.0394L7.19881 10.3816L2.9774 17.558C2.92465 17.6477 2.84826 17.7148 2.7608 17.7562Z", fill: "white", fillOpacity: "0.12" })] }) }), bt = (r3) => jsx("svg", { viewBox: "0 0 20 20", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...r3, children: jsx("g", { id: "Baseline", children: jsx("path", { id: "Union", fillRule: "evenodd", clipRule: "evenodd", d: "M6.05938 2.93544C6.55642 1.71198 8.27766 1.68139 8.81785 2.88642L11.4361 8.72723H9.24438L7.4717 4.77279L5.86521 8.72723H3.70647L6.05938 2.93544ZM13.9282 14.2865L13.0051 12.2272H10.8133L12.5586 16.1204C13.088 17.3014 14.7641 17.3026 15.2952 16.1224L17.048 12.2272H14.8549L13.9282 14.2865ZM2.28459 12.2272H4.44333L1.85293 18.6036L0 17.8509L2.28459 12.2272ZM16.4299 8.72723H18.623L19.3384 7.13759L17.5145 6.31686L16.4299 8.72723ZM1.42645 10.2272C1.42645 9.95109 1.65031 9.72723 1.92645 9.72723H2.92645C3.20259 9.72723 3.42645 9.95109 3.42645 10.2272V10.7272C3.42645 11.0034 3.20259 11.2272 2.92645 11.2272H1.92645C1.65031 11.2272 1.42645 11.0034 1.42645 10.7272V10.2272ZM4.42645 10.2272C4.42645 9.95109 4.65031 9.72723 4.92645 9.72723H5.92645C6.20259 9.72723 6.42645 9.95109 6.42645 10.2272V10.7272C6.42645 11.0034 6.20259 11.2272 5.92645 11.2272H4.92645C4.65031 11.2272 4.42645 11.0034 4.42645 10.7272V10.2272ZM7.92645 9.72723C7.65031 9.72723 7.42645 9.95109 7.42645 10.2272V10.7272C7.42645 11.0034 7.65031 11.2272 7.92645 11.2272H8.92645C9.20259 11.2272 9.42645 11.0034 9.42645 10.7272V10.2272C9.42645 9.95109 9.20259 9.72723 8.92645 9.72723H7.92645ZM10.4265 10.2272C10.4265 9.95109 10.6503 9.72723 10.9265 9.72723H11.9265C12.2026 9.72723 12.4265 9.95109 12.4265 10.2272V10.7272C12.4265 11.0034 12.2026 11.2272 11.9265 11.2272H10.9265C10.6503 11.2272 10.4265 11.0034 10.4265 10.7272V10.2272ZM13.9265 9.72723C13.6503 9.72723 13.4265 9.95109 13.4265 10.2272V10.7272C13.4265 11.0034 13.6503 11.2272 13.9265 11.2272H14.9265C15.2026 11.2272 15.4265 11.0034 15.4265 10.7272V10.2272C15.4265 9.95109 15.2026 9.72723 14.9265 9.72723H13.9265ZM16.4265 10.2272C16.4265 9.95109 16.6503 9.72723 16.9265 9.72723H17.9265C18.2026 9.72723 18.4265 9.95109 18.4265 10.2272V10.7272C18.4265 11.0034 18.2026 11.2272 17.9265 11.2272H16.9265C16.6503 11.2272 16.4265 11.0034 16.4265 10.7272V10.2272Z" }) }) }), ht = (r3) => jsx("svg", { viewBox: "0 0 12 12", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...r3, children: jsx("g", { id: "Unselected", children: jsx("path", { id: "Vector", d: "M6.00684 0.999023C3.24544 0.999023 1.00684 3.23752 1.00684 5.99902C1.00684 8.76051 3.24544 10.999 6.00684 10.999C8.76834 10.999 11.0068 8.76051 11.0068 5.99902C11.0068 3.23752 8.76834 0.999023 6.00684 0.999023ZM6.00684 1.99902C8.21584 1.99902 10.0068 3.79002 10.0068 5.99902C10.0068 8.20801 8.21584 9.99901 6.00684 9.99901C3.79769 9.99901 2.00684 8.20801 2.00684 5.99902C2.00684 3.79002 3.79769 1.99902 6.00684 1.99902Z", fill: "white", fillOpacity: "0.2" }) }) }), yt$1 = (r3) => jsx("svg", { viewBox: "0 0 12 12", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...r3, children: jsx("g", { id: "Selected-Multiple Choices-fill", children: jsx("path", { id: "Subtract", fillRule: "evenodd", clipRule: "evenodd", d: "M1.00684 5.99902C1.00684 3.23752 3.24544 0.999023 6.00684 0.999023C8.76834 0.999023 11.0068 3.23752 11.0068 5.99902C11.0068 8.76051 8.76834 10.999 6.00684 10.999C3.24544 10.999 1.00684 8.76051 1.00684 5.99902ZM8.49243 3.65563C8.60602 3.54726 8.76156 3.49957 8.91068 3.49957C9.05981 3.49957 9.21534 3.54726 9.32893 3.65563C9.5567 3.87231 9.5567 4.23649 9.32893 4.45317L5.25362 8.33706C5.02644 8.55374 4.6443 8.55374 4.41712 8.33706L2.67014 6.67253C2.44296 6.45585 2.44296 6.09161 2.67014 5.87499C2.89791 5.65831 3.28004 5.65831 3.50722 5.87499L4.83537 7.1407L8.49243 3.65563Z", fill: "#608CFF" }) }) });
var _t = () => {
  let { t: r3 } = Z$2();
  return { mobileTimeIntervalMoreMap: useMemo(() => [[{ value: "3", label: r3("tradingView.timeInterval.3m") }, { value: "5", label: r3("tradingView.timeInterval.5m") }, { value: "30", label: r3("tradingView.timeInterval.30m") }, { value: "120", label: r3("tradingView.timeInterval.2h") }], [{ value: "360", label: r3("tradingView.timeInterval.6h") }, { value: "720", label: r3("tradingView.timeInterval.12h") }, { value: "3d", label: r3("tradingView.timeInterval.3d") }, { value: "1M", label: r3("tradingView.timeInterval.1M") }]], [r3]) };
};
function Ee(r3) {
  return useMediaQuery(MEDIA_TABLET) ? jsx(Gr, { ...r3 }) : jsx(Wr$1, { ...r3 });
}
function Wr$1(r3) {
  let { t: e3 } = Z$2(), t = useMemo(() => [{ value: "1", label: e3("tradingView.timeInterval.1m") }, { value: "3", label: e3("tradingView.timeInterval.3m") }, { value: "5", label: e3("tradingView.timeInterval.5m") }, { value: "15", label: e3("tradingView.timeInterval.15m") }, { value: "30", label: e3("tradingView.timeInterval.30m") }, { value: "60", label: e3("tradingView.timeInterval.1h") }, { value: "240", label: e3("tradingView.timeInterval.4h") }, { value: "720", label: e3("tradingView.timeInterval.12h") }, { value: "1D", label: e3("tradingView.timeInterval.1d") }, { value: "1W", label: e3("tradingView.timeInterval.1w") }, { value: "1M", label: e3("tradingView.timeInterval.1M") }], [e3]);
  return jsx("div", { className: cnBase("oui-text-2xs oui-text-base-contrast-36 oui-flex oui-gap-[2px] oui-items-center oui-mr-3 oui-font-semibold", "oui-overflow-hidden"), children: t.map((o) => jsx("div", { className: cnBase("oui-cursor-pointer oui-px-2", "hover:oui-text-base-contrast-80", "oui-break-normal oui-whitespace-nowrap", r3.interval === o.value && "oui-text-base-contrast-80 oui-bg-white/[.06] oui-rounded"), id: o.value, onClick: () => r3.changeInterval(o.value), children: o.label }, o.value)) });
}
function Gr(r3) {
  let { t: e3 } = Z$2(), t = useMemo(() => [{ value: "1", label: e3("tradingView.timeInterval.1m") }, { value: "15", label: e3("tradingView.timeInterval.15m") }, { value: "60", label: e3("tradingView.timeInterval.1h") }, { value: "240", label: e3("tradingView.timeInterval.4h") }, { value: "1D", label: e3("tradingView.timeInterval.1d") }, { value: "1W", label: e3("tradingView.timeInterval.1w") }], [e3]), { mobileTimeIntervalMoreMap: o } = _t(), i = useMemo(() => {
    for (let s of o) for (let n4 of s) if (n4.value === r3.interval) return n4.label;
    return null;
  }, [r3.interval, o]);
  return jsxs(z$1, { justify: "start", itemAlign: "center", gap: 3, className: cnBase("oui-text-2xs oui-text-base-contrast-36", "oui-overflow-hidden"), children: [jsx("div", { className: " oui-flex oui-gap-1 oui-items-center oui-mr-3 oui-font-semibold", children: t.map((s) => jsx("div", { className: cnBase("oui-px-2", "oui-break-normal oui-whitespace-nowrap", r3.interval === s.value && "oui-text-base-contrast-80 oui-bg-white/[.06] oui-rounded"), onClick: () => r3.changeInterval(s.value), children: s.label }, s.value)) }), jsx(Qr$2, { ...r3, children: i ? jsx("div", { className: "oui-text-base-contrast-80", children: i }) : jsx($$4, { className: "oui-break-normal oui-whitespace-nowrap", children: e3("tradingView.timeInterval.more") }) })] });
}
function Qr$2(r3) {
  let [e3, t] = Ce__default__default.useState(false), { mobileTimeIntervalMoreMap: o } = _t();
  return jsxs(Yi, { open: e3, onOpenChange: t, children: [jsx(Xi$1, { asChild: true, children: jsxs("div", { className: "oui-flex oui-justify-start oui-items-center oui-gap-0.5", children: [r3.children, jsx(Q, { className: cnBase("oui-w-3 oui-h-3", e3 && "oui-text-base-contrast-80 oui-rotate-180") })] }) }), jsx(ji, { children: jsx(rr$2, { onCloseAutoFocus: (i) => i.preventDefault(), onClick: (i) => i.stopPropagation(), align: "start", alignOffset: 0, sideOffset: 0, className: cnBase("oui-markets-dropdown-menu-content oui-bg-base-9 oui-w-screen oui-flex oui-flex-col oui-gap-2 oui-p-3"), children: o.map((i, s) => jsx("div", { className: "oui-flex oui-gap-2", children: i.map((n4) => jsx("div", { className: cnBase("oui-w-full  oui-text-2xs oui-flex oui-items-center oui-justify-center oui-h-6  oui-rounded", n4.value === r3.interval ? "oui-text-base-contrast oui-bg-primary-darken" : "oui-text-base-contrast-36 oui-bg-base-5"), onClick: () => {
    r3.changeInterval(n4.value);
  }, children: jsx("div", { children: n4.label }) }, n4.value)) }, s)) }) })] });
}
function wt$2({ displayControlState: r3, changeDisplayControlState: e3 }) {
  let [t, o] = useState(false), { t: i } = Z$2(), s = useMemo(() => [{ label: i("common.position"), id: "position" }, { label: i("tradingView.displayControl.buySell"), id: "buySell" }, { label: i("tradingView.displayControl.limitOrders"), id: "limitOrders" }, { label: i("tradingView.displayControl.stopOrders"), id: "stopOrders" }, { label: i("common.tpsl"), id: "tpsl" }, { label: i("tpsl.positionTpsl"), id: "positionTpsl" }], [i]);
  return jsx(Fragment$1, { children: jsxs(Yi, { open: t, onOpenChange: o, children: [jsx(Xi$1, { asChild: true, children: jsxs(z$1, { justify: "start", itemAlign: "center", className: "oui-gap-[2px] oui-cursor-pointer oui-text-base-contrast-36  hover:oui-text-base-contrast-80", children: [jsx(we$1, { className: cnBase("oui-w-[18px] oui-h-[18px] ", t && "oui-text-base-contrast-80") }), jsx(Q, { className: cnBase("oui-w-3 oui-h-3", t && "oui-text-base-contrast-80 oui-rotate-180") })] }) }), jsx(ji, { children: jsx(rr$2, { onCloseAutoFocus: (n4) => n4.preventDefault(), onClick: (n4) => n4.stopPropagation(), align: "start", className: "oui-bg-base-8", children: jsx(z$1, { direction: "column", gap: 4, px: 5, py: 5, width: 240, justify: "start", itemAlign: "start", children: s.map((n4) => jsxs(z$1, { justify: "between", itemAlign: "center", className: "oui-w-full", children: [jsx($$4, { className: cnBase("oui-text-sm oui-text-base-contrast-80", !r3[n4.id] && "oui-text-base-contrast-36"), children: n4.label }), jsx(Zr$2, { className: "oui-h-4 oui-w-8", checked: r3[n4.id], onCheckedChange: (a2) => {
    e3({ ...r3, [n4.id]: a2 });
  } })] }, n4.id)) }) }) })] }) });
}
function Rt(r3) {
  let [e3, t] = useState(false), { t: o } = Z$2(), i = useMemo(() => [[{ label: o("common.position"), id: "position" }, { label: o("tradingView.displayControl.limitOrders"), id: "limitOrders" }], [{ label: o("tradingView.displayControl.stopOrders"), id: "stopOrders" }, { label: o("common.tpsl"), id: "tpsl" }], [{ label: o("tpsl.positionTpsl"), id: "positionTpsl" }, { label: o("tradingView.displayControl.buySell"), id: "buySell" }]], [o]);
  return jsxs(Yi, { open: e3, onOpenChange: t, children: [jsx(Xi$1, { asChild: true, children: jsxs("div", { className: cnBase("oui-flex oui-gap-0.5 oui-justify-center oui-text-base-contrast-36 oui-items-center", e3 && "oui-text-base-contrast-8"), children: [jsx(we$1, { className: cnBase("oui-w-[18px] oui-h-[18px] ", e3 && "oui-text-base-contrast-80") }), jsx(Q, { className: cnBase("oui-w-3 oui-h-3", e3 && "oui-text-base-contrast-80 oui-rotate-180") })] }) }), jsx(ji, { children: jsx(rr$2, { onCloseAutoFocus: (s) => s.preventDefault(), onClick: (s) => s.stopPropagation(), align: "start", alignOffset: 0, sideOffset: 0, className: cnBase("oui-tradingview-display-control-dropdown-menu-content oui-bg-base-9 oui-w-screen oui-flex oui-flex-col oui-gap-2 oui-p-3"), children: i.map((s, n4) => jsx("div", { className: "oui-flex oui-gap-2", children: s.map((a2) => jsxs("div", { className: cnBase("oui-w-full oui-bg-base-5  oui-text-2xs oui-flex oui-items-center oui-justify-between oui-h-6  oui-rounded oui-px-2", r3.displayControlState[a2.id] ? "oui-text-base-contrast" : "oui-text-base-contrast-36 "), onClick: () => {
    r3.changeDisplayControlState({ ...r3.displayControlState, [a2.id]: !r3.displayControlState[a2.id] });
  }, children: [jsx("div", { children: a2.label }), r3.displayControlState[a2.id] ? jsx(yt$1, { className: "oui-h-3 oui-w-3" }) : jsx(ht, { className: "oui-h-3 oui-w-3" })] }, a2.id)) }, n4)) }) })] });
}
var Et$2 = ({ url: r3, children: e3 }) => jsx("span", { onClick: () => {
  window.open(r3);
}, className: "oui-text-primary-light oui-underline oui-cursor-pointer", children: e3 });
function kt$1() {
  let { t: r3 } = Z$2();
  return jsx("div", { className: "oui-z-0 oui-text-base-contrast-80 oui-absolute oui-top-0 oui-left-0 oui-right-0 oui-bottom-0 oui-flex oui-flex-col oui-justify-start md:oui-justify-center oui-items-center oui-p-2 md:oui-p-10", children: jsxs("div", { children: [jsx("p", { className: "oui-mb-6 oui-text-xs", children: r3("tradingView.noScriptSrc") }), jsx("p", { className: "oui-mb-3 oui-text-2xs md:oui-text-xs oui-text-base-contrast-54 md:oui-text-base-contrast-80 md:oui-text-base oui-pl-0 md:oui-pl-2", children: jsx(Trans, { i18nKey: "tradingView.noScriptSrc.1", components: [jsx(Et$2, { url: "https://www.tradingview.com/advanced-charts" })] }) }), jsx("p", { className: "oui-text-2xs md:oui-text-xs oui-text-base-contrast-54 md:oui-text-base-contrast-80 md:oui-text-base oui-pl-0 md:oui-pl-2", children: jsx(Trans, { i18nKey: "tradingView.noScriptSrc.2", components: [jsx(Et$2, { url: "https://orderly.network/docs/sdks/react/components/trading#tradingviewconfig" })] }) })] }) });
}
function Me(r3) {
  let [e3, t] = useState(false), { t: o } = Z$2(), i = useMemo(() => [{ icon: jsx(dt$1, { fill: "currentColor", className: "oui-w-5 oui-h-5" }), label: o("tradingView.lineType.bars"), value: "0" }, { icon: jsx(pt$1, { fill: "currentColor", className: "oui-w-5 oui-h-5" }), label: o("tradingView.lineType.candles"), value: "1" }, { icon: jsx(mt, { fill: "currentColor", className: "oui-w-5 oui-h-5" }), label: o("tradingView.lineType.hollowCandles"), value: "9" }, { icon: jsx(gt, { fill: "currentColor", className: "oui-w-5 oui-h-5" }), label: o("tradingView.lineType.line"), value: "2" }, { icon: jsx(ft, { fill: "currentColor", className: "oui-w-5 oui-h-5" }), label: o("tradingView.lineType.area"), value: "3" }, { icon: jsx(bt, { fill: "currentColor", className: "oui-w-5 oui-h-5" }), label: o("tradingView.lineType.baseline"), value: "10" }], [o]), s = useMemo(() => {
    let n4 = i.find((a2) => a2.value === r3.lineType);
    return n4 ? n4.icon : i[1].icon;
  }, [r3.lineType]);
  return jsxs(Yi, { open: e3, onOpenChange: t, children: [jsx(Xi$1, { asChild: true, children: jsx(_$1, { className: cnBase("oui-w-[18px] oui-h-[18px] oui-cursor-pointer oui-text-base-contrast-36 hover:oui-text-base-contrast-80", e3 && "oui-text-base-contrast-80"), children: s }) }), jsx(ji, { children: jsx(rr$2, { onCloseAutoFocus: (n4) => n4.preventDefault(), onClick: (n4) => n4.stopPropagation(), align: "start", sideOffset: 20, className: "oui-bg-base-8", children: jsx(z$1, { direction: "column", gap: 4, px: 5, py: 5, width: 240, justify: "start", itemAlign: "start", children: i.map((n4) => jsxs(z$1, { justify: "start", itemAlign: "center", gap: 2, className: cnBase("oui-text-base-contrast-36 oui-cursor-pointer oui-w-full hover:oui-text-base-contrast", r3.lineType === n4.value && "oui-text-base-contrast"), onClick: () => r3.changeLineType(n4.value), children: [n4.icon, jsx($$4, { className: "oui-text-sm", children: n4.label })] }, n4.value)) }) }) })] });
}
var Nt$1 = ({ children: r3, onClick: e3 }) => jsx(_$1, { onClick: e3, className: "oui-cursor-pointer oui-w-[18px] oui-h-[18px] oui-text-base-contrast-36  hover:oui-text-base-contrast-80", children: r3 });
function De$1(r3) {
  let { chartRef: e3, interval: t, changeDisplaySetting: o, displayControlState: i, tradingViewScriptSrc: s, changeInterval: n4, lineType: a2, changeLineType: c2, openChartSetting: l2, openChartIndicators: u2 } = r3, m2 = useMediaQuery(MEDIA_TABLET);
  return jsx("div", { className: "oui-h-full oui-w-full  oui-relative", children: s ? jsxs("div", { className: "oui-z-[1] oui-absolute oui-top-0 oui-bottom-0 oui-right-0 oui-left-0 oui-h-full oui-w-full oui-flex oui-flex-col", children: [jsx(Le$1, { children: m2 ? jsxs(z$1, { gapX: 2, width: "100%", justify: "between", className: "oui-overflow-x-scroll oui-hide-scrollbar", children: [jsx(Ee, { interval: t ?? "1", changeInterval: n4 }), jsx(Rt, { displayControlState: i, changeDisplayControlState: o })] }) : jsxs(Fragment$1, { children: [jsx(Ee, { interval: t ?? "1", changeInterval: n4 }), jsx(te$6, { direction: "vertical", className: "oui-h-4", mx: 2, intensity: 8 }), jsxs(z$1, { justify: "start", itemAlign: "center", gap: 2, children: [jsx(wt$2, { displayControlState: i, changeDisplayControlState: o }), jsx(Nt$1, { onClick: u2, children: jsx(ct, {}) }), jsx(Me, { lineType: a2, changeLineType: c2 }), jsx(Nt$1, { onClick: l2, children: jsx(ut, {}) })] })] }) }), jsx("div", { className: "oui-h-full oui-w-full", ref: e3 })] }) : jsx(kt$1, {}) });
}
var po = "#008676", mo = "#D92D6B", Ae = "#131519", go = "#00B49E", fo$2 = "#FF447C", bo$2 = "#333948", ho$2 = "#FFFFFF", yo$1 = "#F4F7F9", Co$2 = "regular 11px Manrope", Ht$2 = { upColor: po, downColor: mo, chartBG: Ae, pnlUpColor: go, pnlDownColor: fo$2, pnlZoreColor: bo$2, textColor: ho$2, qtyTextColor: yo$1, font: Co$2, volumeUpColor: "#0C3E3A", volumeDownColor: "#5A1E36", closeIcon: "rgba(255, 255, 255, 0.8)" }, Ut = (r3, e3) => {
  let t = { "paneProperties.background": r3.chartBG, "paneProperties.backgroundType": "solid", "mainSeriesProperties.candleStyle.upColor": r3.upColor, "mainSeriesProperties.candleStyle.downColor": r3.downColor, "mainSeriesProperties.candleStyle.borderColor": r3.upColor, "mainSeriesProperties.candleStyle.borderUpColor": r3.upColor, "mainSeriesProperties.candleStyle.borderDownColor": r3.downColor, "mainSeriesProperties.candleStyle.wickUpColor": r3.upColor, "mainSeriesProperties.candleStyle.wickDownColor": r3.downColor, "paneProperties.separatorColor": "#2B2833", "paneProperties.vertGridProperties.color": "#26232F", "paneProperties.horzGridProperties.color": "#26232F", "scalesProperties.fontSize": e3 ? 8 : 12, "scalesProperties.textColor": "#97969B", "paneProperties.legendProperties.showSeriesTitle": false }, o = { "volume.volume.color.0": r3.volumeDownColor, "volume.volume.color.1": r3.volumeUpColor };
  return { overrides: t, studiesOverrides: o };
}, te$1 = "Orderly", O = (r3) => r3.includes(":") ? r3.split(":")[1] : r3, re$1 = (r3) => r3.startsWith(`${te$1}:`) ? r3 : `${te$1}:${r3}`;
var vo$1 = 2, So$2 = "--", Ve2 = ["BRACKET", "STOP_BRACKET"], ie = ["POSITIONAL_TP_SL", "TP_SL"];
var Ne = (r3) => r3.root_algo_order_id !== r3.algo_order_id && (r3.algo_type === "TAKE_PROFIT" || r3.algo_type === "STOP_LOSS"), Io$2 = (r3) => !!r3 && Ve2.includes(r3);
var He$3 = (r3) => r3.type === "CLOSE_POSITION", qt$1 = (r3) => He$3(r3) && r3.is_activated, Wt$1 = (r3) => Ne(r3) && r3.is_activated, Ue$1 = (r3) => r3.root_algo_order_algo_type === "TP_SL" || Io$2(r3.root_algo_order_algo_type) && r3.is_activated, Gt = (r3, e$1) => {
  let t = r3.algo_type, o = { TAKE_PROFIT: e2.t("tpsl.takeProfit"), STOP_LOSS: e2.t("tpsl.stopLoss") }[t];
  return o || null;
}, Qt$2 = (r3) => {
  let e3 = /* @__PURE__ */ new Map(), t = 1;
  return [...r3].reverse().filter(Ue$1).forEach((o) => {
    o.root_algo_order_id && !e3.has(o.root_algo_order_id) && e3.set(o.root_algo_order_id, t++);
  }), e3;
}, $t$1 = (r3, e3) => {
  let t = Math.abs(r3.type === "CLOSE_POSITION" ? e3.balance : r3.quantity), o = r3.side === "SELL" ? 1 : -1, i = e3.open.toString();
  return { estPnl: new g$6(r3.trigger_price).minus(i ?? 0).times(t).times(o).toString(), quantity: t, openPrice: i };
}, Zt$1 = (r3) => r3 !== void 0 && r3 !== "" ? new g$6(r3).todp(vo$1, g$6.ROUND_FLOOR) : So$2;
function Fe() {
  let [r3, { cancelOrder: e3, cancelAlgoOrder: t, cancelTPSLChildOrder: o }] = useOrderStream({ status: OrderStatus.INCOMPLETE });
  return useCallback((i) => {
    if (i.algo_order_id) {
      if (ie.includes(i.root_algo_order_algo_type)) {
        let s = r3 == null ? void 0 : r3.find((a2) => a2.algo_order_id === i.root_algo_order_id);
        return s.child_orders.every((a2) => !!a2.trigger_price) ? o(i.algo_order_id, i.root_algo_order_id) : t(s.algo_order_id, i.symbol).then();
      }
      return t(i.algo_order_id, i.symbol).then();
    }
    return e3(i.order_id, i.symbol).then();
  }, [e3, r3]);
}
function Ke2(r3) {
  useEventEmitter();
  let [, { updateOrder: t, cancelAlgoOrder: o, updateAlgoOrder: i, updateTPSLOrder: s }] = useOrderStream({ status: OrderStatus.INCOMPLETE });
  return useCallback((n4, a2) => {
    var _a2;
    if (n4.algo_order_id) if (ie.includes(n4.root_algo_order_algo_type)) {
      let l2 = [{ order_id: n4.algo_order_id, trigger_price: new g$6(a2.value).toString() }];
      return s(n4.root_algo_order_id, l2).then((u2) => {
      }).catch((u2) => {
        r3 && r3.error(u2.message);
      });
    } else {
      if (Ve2.includes(n4.algo_type)) return i(n4.algo_order_id, { order_price: new g$6(a2.value).toString() }).then((l2) => {
      }).catch((l2) => {
        r3 && r3.error(l2.message);
      });
      {
        let l2 = { quantity: n4.quantity, trigger_price: n4.trigger_price, symbol: n4.symbol, price: n4.price, algo_order_id: n4.algo_order_id };
        return n4.order_tag && (l2.order_tag = n4.order_tag), a2.type === "price" && (l2.price = new g$6(a2.value).toString()), a2.type === "trigger_price" && (l2.trigger_price = new g$6(a2.value).toString()), i(n4.algo_order_id, l2).then((u2) => {
        }).catch((u2) => {
          r3 && r3.error(u2.message);
        });
      }
    }
    let c2 = { order_price: (_a2 = n4.price) == null ? void 0 : _a2.toString(), order_quantity: n4.quantity.toString(), symbol: n4.symbol, order_type: n4.type, side: n4.side, visible_quantity: 0, reduce_only: n4.reduce_only };
    return new g$6(n4.visible_quantity ?? n4.visible ?? 0).eq(n4.quantity) && delete c2.visible_quantity, Object.keys(n4).includes("reduce_only") || delete c2.reduce_only, n4.order_tag && (c2.order_tag = n4.order_tag), a2.type === "price" && (c2.order_price = new g$6(a2.value).toString()), t(n4.order_id, c2).then((l2) => {
    }).catch((l2) => {
      r3.error(l2.message);
    });
  }, [t]);
}
function qe(r3) {
  let { onSubmit: e3 } = useOrderEntry({ symbol: r3, side: OrderSide.BUY, order_type: OrderType.MARKET }, { watchOrderbook: true });
  return { sendLimitOrder: () => {
  }, sendMarketOrder: (s) => (s.reduce_only = false, e3(s).catch((n4) => {
    toast$2.error(n4);
  })) };
}
var Vo$2 = (r3) => (e3) => r3(e3), No$1 = ({ closeConfirm: r3, colorConfig: e3, onToast: t, mode: o, symbol: i }) => {
  let s = Fe(), n4 = Ke2(t), a2 = useSymbolsInfo(), c2 = useCallback((f2) => r3 && r3(f2), [r3]), { sendMarketOrder: l2, sendLimitOrder: u2 } = qe(i), m2 = useCallback((f2) => {
    if (a2) return { baseMin: a2[f2]("base_min"), baseMax: a2[f2]("base_max"), baseTick: a2[f2]("base_tick"), quoteTick: a2[f2]("quote_tick") };
  }, [a2]), b2 = useRef({ cancelOrder: s, closePosition: c2, editOrder: n4, colorConfig: e3, sendLimitOrder: u2, getSymbolInfo: m2, sendMarketOrder: Vo$2(l2), mode: o });
  return useEffect(() => {
    b2.current.getSymbolInfo = m2;
  }, [a2]), useEffect(() => {
    b2.current.sendLimitOrder = u2, b2.current.sendMarketOrder = l2;
  }, [u2, l2]), useEffect(() => {
    b2.current.closePosition = c2;
  }, [r3]), useEffect(() => {
    b2.current.cancelOrder = s;
  }, [s]), b2.current;
}, jt$1 = No$1;
var se$1 = class r {
  constructor(e3, t) {
    this.instance = e3, this.currentSymbol = "", this.broker = t, this.positionLines = {}, this.lastPositions = null;
  }
  renderPositions(e3) {
    var _a2;
    if (e3 === null || e3.length === 0) {
      this.removePositions();
      return;
    }
    ((_a2 = this.lastPositions) == null ? void 0 : _a2.length) !== e3.length && this.removePositions(), e3[0].symbol !== this.currentSymbol && (this.removePositions(), this.currentSymbol = e3[0].symbol), e3.forEach((t, o) => this.drawPositionLine(t, o)), this.lastPositions = e3;
  }
  getBasePositionLine() {
    return this.instance.activeChart().createPositionLine().setTooltip(e2.t("positions.closePosition")).setQuantityBackgroundColor(this.broker.colorConfig.chartBG).setCloseButtonBackgroundColor(this.broker.colorConfig.chartBG).setBodyTextColor(this.broker.colorConfig.textColor).setQuantityTextColor(this.broker.colorConfig.qtyTextColor).setBodyFont(this.broker.colorConfig.font).setQuantityFont(this.broker.colorConfig.font).setLineLength(100).setLineStyle(1);
  }
  static getPositionQuantity(e3) {
    return d$3(new g$6(e3).todp(4, g$6.ROUND_DOWN).toString());
  }
  static getPositionPnL(e$1, t) {
    let o = e2.t("tpsl.pnl"), i = new g$6(e$1).toFixed(t, g$6.ROUND_DOWN);
    return new g$6(e$1).eq(0) ? `${o} 0` : new g$6(e$1).greaterThan(0) ? `${o} +${d$3(i)}` : `${o} ${d$3(i)}`;
  }
  removePositions() {
    Object.keys(this.positionLines).forEach((e3) => {
      this.positionLines[Number(e3)].remove(), delete this.positionLines[Number(e3)];
    });
  }
  drawPositionLine(e3, t) {
    let o = this.broker.colorConfig, i = e3.unrealPnl >= 0, s = e3.balance >= 0, n4 = o.pnlZoreColor, a2 = new g$6(e3.unrealPnl);
    a2.greaterThan(0) ? n4 = o.upColor : a2.lessThan(0) && (n4 = o.downColor);
    i ? o.pnlUpColor : o.pnlDownColor;
    let l2 = s ? o.upColor : o.downColor, u2 = new g$6(e3.open).toNumber();
    this.positionLines[t] = this.positionLines[t] ?? this.getBasePositionLine(), this.positionLines[t].setQuantity(r.getPositionQuantity(e3.balance)).setPrice(u2).setCloseButtonIconColor(o.closeIcon).setCloseButtonBorderColor(l2).setBodyBackgroundColor(n4).setQuantityTextColor(l2).setBodyBorderColor(n4).setLineColor(l2).setQuantityBorderColor(l2).setText(r.getPositionPnL(e3.unrealPnl, e3.unrealPnlDecimal)), this.broker.mode !== 3 && this.positionLines[t].onClose(null, () => {
      this.broker.closePosition(e3);
    });
  }
};
var $ = (r3) => {
  if (r3 != null) return r3.algo_order_id || r3.order_id;
};
var ae$2 = class ae {
  constructor() {
    this.quantityTpslNoMap = /* @__PURE__ */ new Map(), this.tpslPnlMap = /* @__PURE__ */ new Map(), this.positions = null;
  }
  getQuantityTpslNoMap() {
    return this.quantityTpslNoMap;
  }
  getTpslPnlMap() {
    return this.tpslPnlMap;
  }
  getFormattedEstPnl(e3) {
    if (this.positions === null) return "";
    let t = this.positions[0];
    if (!t) return "";
    let { estPnl: o } = $t$1(e3, t);
    return Zt$1(o);
  }
  prepareTpslPnlMap(e3) {
    let t = [];
    return e3.forEach((o) => {
      let i = $(o);
      if (i && Wt$1(o)) {
        let s = this.tpslPnlMap.get(i), n4 = this.getFormattedEstPnl(o);
        s !== n4 && (t.push(i), this.tpslPnlMap.set(i, n4));
      }
    }), t;
  }
  prepareQuantityTpslNoMap(e3) {
    this.quantityTpslNoMap = Qt$2(e3);
  }
  recalculatePnl(e3, t) {
    return this.positions = e3, this.prepareTpslPnlMap(t);
  }
  clear() {
    this.positions = null, this.quantityTpslNoMap.clear(), this.tpslPnlMap.clear();
  }
};
var w3 = class w4 {
  constructor(e3, t) {
    this.instance = e3, this.pendingOrderLineMap = /* @__PURE__ */ new Map(), this.pendingOrders = [], this.broker = t, this.tpslCalService = new ae$2();
  }
  renderPendingOrders(e3) {
    e3 && (this.pendingOrders = e3), this.cleanOldPendingOrders(this.pendingOrders), this.tpslCalService.prepareTpslPnlMap(this.pendingOrders), this.tpslCalService.prepareQuantityTpslNoMap(this.pendingOrders), this.pendingOrders.forEach((t) => this.renderPendingOrder(t));
  }
  updatePositions(e3) {
    let t = this.tpslCalService.recalculatePnl(e3, this.pendingOrders);
    this.pendingOrders.filter((o) => t.includes($(o))).forEach((o) => this.renderPendingOrder(o));
  }
  renderPendingOrder(e3) {
    let t = w4.getOrderId(e3);
    if (!t) return;
    let o = this.drawOrderLine(t, e3);
    o && this.pendingOrderLineMap.set(t, o);
  }
  cleanOldPendingOrders(e3) {
    let t = new Set(e3.map((o) => w4.getOrderId(o)));
    this.pendingOrderLineMap.forEach((o, i) => !t.has(i) && this.removePendingOrder(i));
  }
  removePendingOrder(e3) {
    if (e3 === void 0) return;
    let t = this.pendingOrderLineMap.get(e3);
    t && (this.pendingOrderLineMap.delete(e3), t.remove());
  }
  getBaseOrderLine() {
    let e$1 = this.broker.colorConfig;
    return this.instance.activeChart().createOrderLine().setCancelTooltip(e2.t("orders.cancelOrder")).setQuantityTextColor(e$1.qtyTextColor).setQuantityBackgroundColor(e$1.chartBG).setBodyBackgroundColor(e$1.chartBG).setCancelButtonBackgroundColor(e$1.chartBG).setLineStyle(1).setBodyFont(e$1.font).setQuantityFont(e$1.font);
  }
  static getCombinationType(e3) {
    let { algo_type: t, type: o } = e3;
    if ((t === "STOP_LOSS" || t === "TAKE_PROFIT" || t === "STOP") && o === "LIMIT") return "STOP_LIMIT";
    if ((t === "STOP_LOSS" || t === "TAKE_PROFIT" || t === "STOP") && o === "MARKET") return "STOP_MARKET";
    if (t === "BRACKET") {
      if (o === "LIMIT") return "BRACKET_LIMIT";
      if (o === "MARKET") return "BRACKET_MARKET";
    }
    return "LIMIT";
  }
  static getText(e$1) {
    let t = w4.getCombinationType(e$1);
    return t === "STOP_LIMIT" || t === "STOP_MARKET" || t === "STOP_BRACKET_LIMIT" || t === "STOP_BRACKET_MARKET" ? e$1.type === "LIMIT" ? `${e2.t("orderEntry.orderType.stopLimit")} ${d$3(e$1.price)}` : e2.t("orderEntry.orderType.stopMarket") : e2.t("orderEntry.orderType.limit");
  }
  static getOrderPrice(e3) {
    return e3.trigger_price || e3.price;
  }
  getTPSLTextWithTpsl(e3, t) {
    return $(t), e3;
  }
  getTPSLText(e3) {
    let t = Gt(e3, this.tpslCalService.getQuantityTpslNoMap());
    return t ? this.getTPSLTextWithTpsl(t, e3) : null;
  }
  getOrderQuantity(e3) {
    if (e3.algo_order_id) {
      if (qt$1(e3) || He$3(e3)) return "100%";
      if (Ue$1(e3)) {
        let o = new g$6(e3.quantity).minus(e3.executed ?? 0).div(new g$6(e3.position_qty)).mul(100).todp(2).toNumber();
        return `${Math.min(Math.abs(o), 100).toString()}%`;
      }
    }
    return d$3(new g$6(e3.quantity).toString());
  }
  drawOrderLine(e3, t) {
    let o = Ne(t) ? this.getTPSLText(t) : w4.getText(t);
    if (o === null) return null;
    let i = this.broker.colorConfig, s = this.pendingOrderLineMap.get(e3) ?? this.getBaseOrderLine(), n4 = t.side === "BUY" ? i.upColor : i.downColor;
    t.side === "BUY" ? i.pnlUpColor : i.pnlDownColor;
    let c2 = w4.getOrderPrice(t), l2 = 100, u2 = this.getOrderQuantity(t), m2 = i.textColor;
    return s.setText(o).setCancelButtonIconColor(i.closeIcon).setCancelButtonBorderColor(n4).setBodyTextColor(m2).setBodyBorderColor(n4).setQuantityBorderColor(n4).setQuantityTextColor(n4).setLineColor(n4).setLineLength(l2).setQuantity(u2 ?? "").setPrice(c2), this.broker.mode !== 3 ? (s.onCancel(null, () => this.broker.cancelOrder(t)), this.applyEditOnMove(s, t)) : s.setEditable(false).setCancellable(false), s;
  }
  static getOrderEditKey(e3) {
    let t = this.getCombinationType(e3);
    if (["LIMIT", "BRACKET_LIMIT"].includes(t)) return "price";
    if (t === "STOP_LIMIT" || t === "STOP_MARKET" || e3.rootAlgoOrderAlgoType === "POSITIONAL_TP_SL" || e3.rootAlgoOrderAlgoType === "TP_SL" || e3.rootAlgoOrderAlgoType === "BRACKET" || e3.rootAlgoOrderAlgoType === "STOP_BRACKET") return "trigger_price";
  }
  applyEditOnMove(e3, t) {
    let o = w4.getOrderEditKey(t);
    e3.onMove(() => {
      this.broker.editOrder(t, { type: o, value: `${e3.getPrice()}` }).then((i) => {
        i.success || this.renderPendingOrder(t);
      }).catch(() => this.renderPendingOrder(t));
    });
  }
  removeAll() {
    this.pendingOrderLineMap.forEach((e3) => e3.remove()), this.pendingOrderLineMap.clear(), this.pendingOrders = [], this.tpslCalService.clear();
  }
};
w3.getOrderId = (e3) => {
  if (e3 != null) return e3.algo_order_id || e3.order_id;
};
var le = w3;
var rr = { 1: { startOf: "minute", period: 0 }, 3: { startOf: "hour", period: 3 * 60 * 1e3 }, 5: { startOf: "hour", period: 5 * 60 * 1e3 }, 15: { startOf: "hour", period: 15 * 60 * 1e3 }, 30: { startOf: "hour", period: 30 * 60 * 1e3 }, 60: { startOf: "hour", period: 0 }, 120: { startOf: "day", period: 2 * 60 * 60 * 1e3 }, 240: { startOf: "day", period: 4 * 60 * 60 * 1e3 }, 480: { startOf: "day", period: 8 * 60 * 60 * 1e3 }, 720: { startOf: "day", period: 12 * 60 * 60 * 1e3 }, D: { startOf: "day", period: 0 }, "1D": { startOf: "day", period: 0 }, "3D": { startOf: "year", period: 3 * 24 * 60 * 60 * 1e3 }, "5D": { startOf: "year", period: 5 * 24 * 60 * 60 * 1e3 }, "1W": { startOf: "week", period: 0 }, "1M": { startOf: "month", period: 0 } };
function tr(r3, e3, t, o) {
  let { startOf: i, period: s } = rr[t], n4 = new Date(r3.updated_time).getTime(), a2 = startOfSecond(n4).getTime();
  i === "minute" ? a2 = startOfMinute(n4).getTime() : i === "hour" ? a2 = startOfHour(n4).getTime() : i === "day" ? a2 = startOfDay(n4).getTime() : i === "month" ? a2 = startOfMonth(n4).getTime() : i === "year" ? a2 = startOfYear(n4).getTime() : i === "week" ? a2 = startOfWeek(n4).getTime() : i === "month" && (a2 = startOfMonth(n4).getTime());
  let c2 = s === 0 ? a2 : Math.floor((n4 - a2) / s) * s + a2;
  e3[c2] || (e3[c2] = { BUY: [], SELL: [] }), e3[c2][r3.side].length < 5 && (e3[c2][r3.side].push(r3), o.push(r3));
}
var or = (r3, e3) => {
  let t = [], o = {};
  return rr[e3] ? (r3.forEach((i) => {
    if (i.child_orders) for (let s of i.child_orders) s.is_activated && s.algo_status === OrderStatus.FILLED && tr(s, o, e3, t);
    else tr(i, o, e3, t);
  }), t) : [];
};
var ce$1 = class r2 {
  constructor(e3, t) {
    this.interval = "1D";
    this.changeInterval = (e4) => {
      let t2 = () => {
        this.renderExecutions(this.filledOrders, this.basePriceDecimal), this.instance.activeChart().onDataLoaded().unsubscribe(null, t2);
      };
      this.interval = e4, this.instance.activeChart().onDataLoaded().subscribe(null, t2);
    };
    this.instance = e3, this.executions = [], this.filledOrders = [], this.basePriceDecimal = 0, this.broker = t, this.subscribeIntervalChange();
  }
  async subscribeIntervalChange() {
    this.interval = this.instance.symbolInterval().interval;
    let e3 = this.changeInterval;
    this.instance.activeChart().onIntervalChanged().subscribe(null, e3);
  }
  renderExecutions(e3, t) {
    this.filledOrders = e3, this.basePriceDecimal = t, this.interval && (this.removeAll(), or(e3, this.interval).forEach((o) => {
      this.executions.push(this.drawExecution(o, t));
    }));
  }
  removeAll() {
    this.executions.forEach((e3) => e3.remove()), this.executions = [];
  }
  static getExecutionInfo(e$1, t) {
    var _a2, _b2;
    let o = e$1.side, i = e$1.average_executed_price || ((_b2 = (_a2 = e$1.child_orders) == null ? void 0 : _a2.find((n4) => !!n4.average_executed_price)) == null ? void 0 : _b2.average_executed_price) || 0, s = new g$6(i).todp(t, g$6.ROUND_FLOOR).toString();
    return `${o === "BUY" ? e2.t("common.buy") : e2.t("common.sell")} ${e$1.total_executed_quantity} @${d$3(s)}`;
  }
  drawExecution(e3, t) {
    var _a2, _b2;
    let o = e3.side, i = e3.average_executed_price || ((_b2 = (_a2 = e3.child_orders) == null ? void 0 : _a2.find((a2) => !!a2.average_executed_price)) == null ? void 0 : _b2.average_executed_price) || 0, s = new Date(e3.updated_time).getTime() / 1e3, n4 = this.broker.colorConfig;
    return this.instance.activeChart().createExecutionShape().setArrowHeight(9).setTooltip(r2.getExecutionInfo(e3, t)).setTime(s).setPrice(i).setArrowColor(o === "BUY" ? n4.upColor : n4.downColor).setDirection(o === "BUY" ? "buy" : "sell");
  }
  unsubscribeIntervalChange() {
    let e3 = this.changeInterval;
    try {
      this.instance.activeChart().onIntervalChanged().unsubscribe(null, e3);
    } catch (t) {
      t instanceof Error && t.message;
    }
  }
  destroy() {
    this.removeAll(), this.unsubscribeIntervalChange();
  }
};
var ue$1 = class ue {
  constructor(e3, t, o) {
    this.instance = e3, this.positionLineService = new se$1(e3, o), this.orderLineService = new le(e3, o), this.executionService = new ce$1(e3, o);
  }
  async renderPositions(e3) {
    await this.chartReady(), await this.onDataLoaded(), this.positionLineService.renderPositions(e3), this.orderLineService.updatePositions(e3);
  }
  async renderPendingOrders(e3) {
    await this.chartReady(), this.orderLineService.renderPendingOrders(e3);
  }
  async renderFilledOrders(e3, t) {
    await this.chartReady(), await this.onDataLoaded(), this.executionService.renderExecutions(e3, t);
  }
  remove() {
    this.orderLineService.removeAll(), this.positionLineService.removePositions(), this.executionService.destroy();
  }
  onDataLoaded() {
    return this.instance.activeChart().symbolExt() ? Promise.resolve() : new Promise((e3) => this.instance.activeChart().onDataLoaded().subscribe(null, () => {
      e3();
    }, true));
  }
  chartReady() {
    return new Promise((e3) => this.instance.onChartReady(() => {
      try {
        this.instance.activeChart().dataReady(() => e3());
      } catch (t) {
        t.toString().includes("tradingViewApi");
      }
    }));
  }
};
function Ze(r3, e3) {
  var _a2;
  let [t, o] = useState(), i = useRef(), { state: s } = useAccount(), [n4] = useLocalStorage("unPnlPriceBasis", "markPrice"), [{ rows: a2 }, c2] = usePositionStream(r3, { calcMode: n4 }), [l2] = useOrderStream({ status: OrderStatus.INCOMPLETE, symbol: r3 }), m2 = (_a2 = useSymbolsInfo()) == null ? void 0 : _a2[r3], b2 = m2("base_dp"), [f2] = useOrderStream({ symbol: r3, status: OrderStatus.FILLED, size: 500 }), h2 = useRef((x2, S2, M2) => {
    i.current && i.current.remove(), i.current = new ue$1(x2, S2, M2), o(i.current);
  }), K2 = useRef(() => {
    var _a3;
    (_a3 = i.current) == null ? void 0 : _a3.remove(), i.current = void 0;
  });
  return useEffect(() => {
    if (s.status < AccountStatusEnum.EnableTrading && s.status !== AccountStatusEnum.EnableTradingWithoutConnected) {
      t == null ? void 0 : t.renderPositions([]);
      return;
    }
    if (!e3 || !e3.position) {
      t == null ? void 0 : t.renderPositions([]);
      return;
    }
    let x2 = (a2 ?? []).filter((S2) => S2.symbol === r3).map((S2) => ({ symbol: S2.symbol, open: S2.average_open_price, balance: S2.position_qty, closablePosition: 9999, unrealPnl: S2.unrealized_pnl ?? 0, interest: 0, unrealPnlDecimal: 2, basePriceDecimal: 4 }));
    t == null ? void 0 : t.renderPositions(x2);
  }, [t, a2, r3, e3, s]), useEffect(() => {
    if (!e3 || !e3.buySell) {
      t == null ? void 0 : t.renderFilledOrders([], 6);
      return;
    }
    t == null ? void 0 : t.renderFilledOrders(f2 ?? [], b2 ?? 6);
  }, [t, f2, b2, e3]), useEffect(() => {
    let x2 = [], S2 = [], M2 = [], q2 = [], W2 = [];
    if (s.status < AccountStatusEnum.EnableTrading && s.status !== AccountStatusEnum.EnableTradingWithoutConnected) {
      t == null ? void 0 : t.renderPendingOrders([]);
      return;
    }
    let j2 = (a2 ?? []).find((y2) => y2.symbol === r3);
    l2 == null ? void 0 : l2.forEach((y2) => {
      if (r3 === y2.symbol) {
        if (!y2.algo_order_id) M2.push(y2);
        else if (y2.algo_order_id) if (y2.algo_type === "POSITIONAL_TP_SL") for (let I2 of y2.child_orders) I2.root_algo_order_algo_type = y2.algo_type, I2.trigger_price && I2.status !== OrderStatus.FILLED && S2.push(I2);
        else if (y2.algo_type === "TP_SL") {
          if (j2) for (let I2 of y2.child_orders) I2.root_algo_order_algo_type = y2.algo_type, I2.position_qty = j2.position_qty, I2.trigger_price && I2.status !== OrderStatus.FILLED && x2.push(I2);
        } else y2.algo_type === "STOP_LOSS" || y2.algo_type === "TAKE_PROFIT" ? q2.push(y2) : y2.algo_type === "BRACKET" && W2.push(y2);
      }
    }), e3 && (e3.positionTpsl || (S2 = []), e3.tpsl || (x2 = []), e3.limitOrders || (M2 = [], W2 = []), e3.stopOrders || (q2 = [])), t == null ? void 0 : t.renderPendingOrders(x2.concat(S2).concat(M2).concat(q2).concat(W2));
  }, [t, l2, r3, e3, a2, s.status]), [h2.current, K2.current];
}
function B(r3) {
  return r3 === void 0 ? "" : typeof r3 == "string" ? r3 : r3.message;
}
var me = class {
  constructor(e3, t, o) {
    this._datafeedUrl = e3, this._requester = t, this._limitedServerResponse = o;
  }
  getBars(e3, t, o) {
    let i = { symbol: e3.ticker || "", resolution: t, from: o.from, to: o.to };
    return o.countBack !== void 0 && (i.countback = o.countBack), e3.currency_code !== void 0 && (i.currencyCode = e3.currency_code), e3.unit_id !== void 0 && (i.unitId = e3.unit_id), new Promise(async (s, n4) => {
      try {
        let a2 = await this._requester.sendRequest(this._datafeedUrl, "history", i), c2 = this._processHistoryResponse(a2);
        this._limitedServerResponse && await this._processTruncatedResponse(c2, i), s(c2);
      } catch (a2) {
        if (a2 instanceof Error || typeof a2 == "string") {
          let c2 = B(a2);
          n4(c2);
        }
      }
    });
  }
  async _processTruncatedResponse(e3, t) {
    let o = e3.bars.length;
    try {
      for (; this._limitedServerResponse && this._limitedServerResponse.maxResponseLength > 0 && this._limitedServerResponse.maxResponseLength === o && t.from < t.to; ) {
        t.countback && (t.countback = t.countback - o), this._limitedServerResponse.expectedOrder === "earliestFirst" ? t.from = Math.round(e3.bars[e3.bars.length - 1].time / 1e3) : t.to = Math.round(e3.bars[0].time / 1e3);
        let i = await this._requester.sendRequest(this._datafeedUrl, "history", t), s = this._processHistoryResponse(i);
        o = s.bars.length, this._limitedServerResponse.expectedOrder === "earliestFirst" ? (s.bars[0].time === e3.bars[e3.bars.length - 1].time && s.bars.shift(), e3.bars.push(...s.bars)) : (s.bars[s.bars.length - 1].time === e3.bars[0].time && s.bars.pop(), e3.bars.unshift(...s.bars));
      }
    } catch (i) {
      if (i instanceof Error || typeof i == "string") {
        B(i);
      }
    }
  }
  _processHistoryResponse(e3) {
    if (e3.s !== "ok" && e3.s !== "no_data") throw new Error(e3.errmsg);
    let t = [], o = { noData: false };
    if (e3.s === "no_data") o.noData = true, o.nextTime = e3.nextTime;
    else {
      let i = e3.v !== void 0, s = e3.o !== void 0;
      for (let n4 = 0; n4 < e3.t.length; ++n4) {
        let a2 = { time: e3.t[n4] * 1e3, close: parseFloat(e3.c[n4]), open: parseFloat(e3.c[n4]), high: parseFloat(e3.c[n4]), low: parseFloat(e3.c[n4]) };
        s && (a2.open = parseFloat(e3.o[n4]), a2.high = parseFloat(e3.h[n4]), a2.low = parseFloat(e3.l[n4])), i && (a2.volume = parseFloat(e3.v[n4])), t.push(a2);
      }
    }
    return { bars: t, meta: o };
  }
};
var ge$1 = class ge {
  constructor(e3) {
    e3 && (this._headers = e3);
  }
  sendRequest(e3, t, o) {
    if (o !== void 0) {
      let s = Object.keys(o);
      s.length !== 0 && (t += "?"), t += s.map((n4) => `${encodeURIComponent(n4)}=${encodeURIComponent(o[n4].toString())}`).join("&");
    }
    "" + t;
    let i = { credentials: "same-origin" };
    return this._headers !== void 0 && (i.headers = this._headers), fetch(`${e3}/${t}`, i).then((s) => s.text()).then((s) => JSON.parse(s));
  }
};
function g(r3, e3, t, o) {
  let i = r3[e3];
  return Array.isArray(i) && (!o || Array.isArray(i[0])) ? i[t] : i;
}
function fe$1(r3, e3, t) {
  return r3 + (e3 !== void 0 ? "_%|#|%_" + e3 : "") + (t !== void 0 ? "_%|#|%_" + t : "");
}
var be$1 = class be2 {
  constructor(e3, t, o) {
    this._exchangesList = ["Orderly"];
    this._symbolsInfo = {};
    this._symbolsList = [];
    this._datafeedUrl = e3, this._datafeedSupportedResolutions = t, this._requester = o, this._readyPromise = this._init(), this._readyPromise.catch((i) => {
    });
  }
  resolveSymbol(e3, t, o) {
    return this._readyPromise.then(() => {
      let i = this._symbolsInfo[fe$1(e3, t, o)];
      return i === void 0 ? Promise.reject("invalid symbol") : Promise.resolve(i);
    });
  }
  searchSymbols(e3, t, o, i) {
    return this._readyPromise.then(() => {
      let s = [], n4 = e3.length === 0;
      e3 = e3.toUpperCase();
      for (let c2 of this._symbolsList) {
        let l2 = this._symbolsInfo[c2];
        if (l2 === void 0 || o.length > 0 && l2.type !== o || t && t.length > 0 && l2.exchange !== t) continue;
        let u2 = l2.name.toUpperCase().indexOf(e3), m2 = l2.description.toUpperCase().indexOf(e3);
        if ((n4 || u2 >= 0 || m2 >= 0) && !s.some((f2) => f2.symbolInfo === l2)) {
          let f2 = u2 >= 0 ? u2 : 8e3 + m2;
          s.push({ symbolInfo: l2, weight: f2 });
        }
      }
      let a2 = s.sort((c2, l2) => c2.weight - l2.weight).slice(0, i).map((c2) => {
        let l2 = c2.symbolInfo;
        return { symbol: l2.name, full_name: `${l2.exchange}:${l2.name}`, description: l2.description, exchange: l2.exchange, params: [], type: l2.type, ticker: l2.name };
      });
      return Promise.resolve(a2);
    });
  }
  _init() {
    let e3 = [], t = {};
    for (let o of this._exchangesList) t[o] || (t[o] = true, e3.push(this._requestExchangeData(o)));
    return Promise.all(e3).then(() => {
      this._symbolsList.sort();
    });
  }
  _requestExchangeData(e3) {
    return new Promise((t, o) => {
      this._requester.sendRequest(this._datafeedUrl, "symbol_info", { group: e3 }).then((i) => {
        try {
          this._onExchangeDataReceived(e3, i);
        } catch (s) {
          o(s instanceof Error ? s : new Error(`SymbolsStorage: Unexpected exception ${s}`));
          return;
        }
        t();
      }).catch((i) => {
        `${e3}${B(i)}`, t();
      });
    });
  }
  _onExchangeDataReceived(e3, t) {
    let o = 0;
    try {
      let i = t.symbol.length, s = t.ticker !== void 0;
      for (; o < i; ++o) {
        let n4 = t.symbol[o], a2 = g(t, "exchange-listed", o), c2 = g(t, "exchange-traded", o), l2 = c2 + ":" + n4, u2 = g(t, "currency-code", o), m2 = g(t, "unit-id", o), b2 = s ? g(t, "ticker", o) : n4, f2 = { ticker: b2, name: n4, base_name: [a2 + ":" + n4], listed_exchange: a2, exchange: c2, currency_code: u2, original_currency_code: g(t, "original-currency-code", o), unit_id: m2, original_unit_id: g(t, "original-unit-id", o), unit_conversion_types: g(t, "unit-conversion-types", o, true), description: g(t, "description", o), has_intraday: U2(g(t, "has-intraday", o), false), visible_plots_set: U2(g(t, "visible-plots-set", o), "ohlcv"), minmov: g(t, "minmovement", o) || g(t, "minmov", o) || 0, minmove2: g(t, "minmove2", o) || g(t, "minmov2", o), fractional: g(t, "fractional", o), pricescale: g(t, "pricescale", o), type: g(t, "type", o), session: g(t, "session-regular", o), session_holidays: g(t, "session-holidays", o), corrections: g(t, "corrections", o), timezone: g(t, "timezone", o), supported_resolutions: U2(g(t, "supported-resolutions", o, true), this._datafeedSupportedResolutions), has_daily: U2(g(t, "has-daily", o), true), intraday_multipliers: U2(g(t, "intraday-multipliers", o, true), ["1", "5", "15", "30", "60"]), has_weekly_and_monthly: g(t, "has-weekly-and-monthly", o), has_empty_bars: g(t, "has-empty-bars", o), volume_precision: U2(g(t, "volume-precision", o), 0), format: "price" };
        this._symbolsInfo[b2] = f2, this._symbolsInfo[n4] = f2, this._symbolsInfo[l2] = f2, (u2 !== void 0 || m2 !== void 0) && (this._symbolsInfo[fe$1(b2, u2, m2)] = f2, this._symbolsInfo[fe$1(n4, u2, m2)] = f2, this._symbolsInfo[fe$1(l2, u2, m2)] = f2), this._symbolsList.push(n4);
      }
    } catch (i) {
      throw new Error(`SymbolsStorage: API error when processing exchange ${e3} symbol #${o} (${t.symbol[o]}): ${Object(i).message}`);
    }
  }
};
function U2(r3, e3) {
  return r3 !== void 0 ? r3 : e3;
}
var he = class {
  constructor(e3) {
    this._configuration = lr$1();
    this._symbolsStorage = null;
    this._datafeedURL = e3, this._requester = new ge$1(), this._historyProvider = new me(e3, this._requester), this._configurationReadyPromise = this._requestConfiguration().then((t) => {
      t === null && (t = lr$1()), this._setupWithConfiguration(t);
    });
  }
  getBars(e3, t, o, i, s) {
    this._historyProvider.getBars(e3, t, o).then((n4) => {
      i(n4.bars, n4.meta);
    }).catch(s);
  }
  onReady(e3) {
    this._configurationReadyPromise.then(() => {
      e3(this._configuration);
    });
  }
  searchSymbols(e3, t, o, i) {
    if (this._symbolsStorage === null) throw new Error("Datafeed: inconsistent configuration (symbols storage)");
    this._symbolsStorage.searchSymbols(e3, t, o, 30).then(i).catch(i.bind(null, []));
  }
  resolveSymbol(e3, t, o, i) {
    let s = i && i.currencyCode, n4 = i && i.unitId;
    function c2(l2) {
      t(l2);
    }
    if (this._symbolsStorage === null) throw new Error("Datafeed: inconsistent configuration (symbols storage)");
    this._symbolsStorage.resolveSymbol(e3, s, n4).then(c2).catch(o);
  }
  getMarks() {
  }
  getTimescaleMarks() {
  }
  getServerTime() {
  }
  _requestConfiguration() {
    return this._send("config").catch((e3) => (`${B(e3)}`, null));
  }
  _send(e3, t) {
    return this._requester.sendRequest(this._datafeedURL, e3, t);
  }
  _setupWithConfiguration(e3) {
    if (this._configuration = e3, e3.exchanges === void 0 && (e3.exchanges = []), !e3.supports_search && !e3.supports_group_request) throw new Error("Unsupported datafeed configuration. Must either support search, or support group request");
    (e3.supports_group_request || !e3.supports_search) && (this._symbolsStorage = new be$1(this._datafeedURL, e3.supported_resolutions || [], this._requester)), `${JSON.stringify(e3)}`;
  }
};
function lr$1() {
  return { supports_search: false, supports_group_request: true, supported_resolutions: ["1", "3", "5", "15", "30", "60", "120", "240", "480", "720", "1D", "3D", "1W", "1M"], supports_marks: false, supports_timescale_marks: false };
}
var ye$2 = class ye {
  constructor() {
    this.subscribers = /* @__PURE__ */ new Map();
  }
  subscribe(e3, t) {
    return this.subscribers.has(e3) || this.subscribers.set(e3, []), this.subscribers.get(e3).push(t), () => {
      this.unsubscribe(e3, t);
    };
  }
  unsubscribe(e3, t) {
    if (this.subscribers.has(e3)) {
      let o = this.subscribers.get(e3);
      this.subscribers.set(e3, o.filter((i) => i !== t)), this.subscribers.get(e3).length === 0 && this.subscribers.delete(e3);
    }
  }
  publish(e3, t) {
    this.subscribers.has(e3) && this.subscribers.get(e3).forEach((i) => {
      i(t);
    });
  }
};
var ze$1 = (r3) => {
  let e3 = "1d";
  switch (r3) {
    case "1":
      e3 = "1m";
      break;
    case "3":
      e3 = "3m";
      break;
    case "5":
      e3 = "5m";
      break;
    case "15":
      e3 = "15m";
      break;
    case "30":
      e3 = "30m";
      break;
    case "60":
      e3 = "1h";
      break;
    case "120":
      e3 = "2h";
      break;
    case "240":
      e3 = "4h";
      break;
    case "480":
      e3 = "8h";
      break;
    case "720":
      e3 = "12h";
      break;
    case "D":
    case "1D":
      e3 = "1d";
      break;
    case "3D":
      e3 = "3d";
      break;
    case "1W":
      e3 = "1w";
      break;
    case "1M":
      e3 = "1M ";
      break;
  }
  return e3;
}, V = { interval: "TradingviewSDK.lastUsedTimeBasedResolution", lineType: "TradingviewSDK.lastUsedStyle", displayControlSetting: "TradingviewSDK.displaySetting" };
var je$1 = (r3, e3) => `${r3}kline_${e3}`, Xo$2 = (r3) => ["trade"].map((t) => `${r3}@${t}`), E = class E2 {
  constructor(e3) {
    this.klineSubscribeIdMap = /* @__PURE__ */ new Map();
    this.klineOnTickCallback = /* @__PURE__ */ new Map();
    this.subscribeCachedTopics = /* @__PURE__ */ new Map();
    this.wsInstance = null;
    this.klineData = /* @__PURE__ */ new Map();
    return E2._created || (this.wsInstance = e3, E2._instance = this, E2._created = true), E2._instance;
  }
  subscribeKline(e3, t, o, i) {
    var _a2;
    let s = ze$1(o);
    this.klineSubscribeIdMap.set(e3, { symbol: t, resolution: o });
    let n4 = je$1(t, s);
    if (this.klineOnTickCallback.has(n4)) {
      let a2 = this.klineOnTickCallback.get(n4);
      a2[e3] = i;
    } else {
      this.klineOnTickCallback.set(n4, { [e3]: i });
      let a2 = (_a2 = this.wsInstance) == null ? void 0 : _a2.subscribe({ event: "subscribe", topic: `${t}@kline_${s}`, id: `${t}@kline_${s}`, ts: (/* @__PURE__ */ new Date()).getTime() }, { onMessage: (c2) => {
        let { open: l2, close: u2, high: m2, low: b2, volume: f2, startTime: h2 } = c2, K2 = je$1(c2.symbol, c2.type);
        this.updateKline(K2, { time: h2, close: u2, open: l2, high: m2, low: b2, volume: f2 });
      } });
      this.subscribeCachedTopics.set(`${t}@kline_${s}`, a2);
    }
  }
  unsubscribeKline(e3) {
    if (!this.klineSubscribeIdMap.has(e3)) return;
    let { symbol: t, resolution: o } = this.klineSubscribeIdMap.get(e3), i = ze$1(o), s = je$1(t, i);
    if (this.klineOnTickCallback.has(s)) {
      let n4 = this.klineOnTickCallback.get(s);
      delete n4[e3], Object.keys(n4).length === 0 && (this.klineOnTickCallback.delete(s), this.subscribeCachedTopics.get(`${t}@kline_${i}`)());
    }
    delete this.klineSubscribeIdMap[e3];
  }
  subscribeSymbol(e3) {
    Xo$2(e3).forEach((o) => {
      var _a2;
      if (!this.subscribeCachedTopics.has(o)) {
        let i = (_a2 = this.wsInstance) == null ? void 0 : _a2.subscribe({ event: "subscribe", topic: o, id: o, ts: (/* @__PURE__ */ new Date()).getTime() }, { onMessage: (s) => {
          this.updateKlineByLastPrice(s.symbol, s.price);
        } });
        this.subscribeCachedTopics.set(o, i);
      }
    });
  }
  updateKlineByLastPrice(e3, t) {
    this.klineOnTickCallback.forEach((o, i) => {
      if (i.startsWith(e3)) {
        let s = this.klineData.get(i);
        s && this.updateKline(i, { ...s, close: t });
      }
    });
  }
  updateKline(e3, t) {
    let o = this.klineOnTickCallback.get(e3);
    o && t && (this.klineData.set(e3, t), Object.keys(o).forEach((i) => {
      let s = o[i];
      s && typeof s == "function" && s(t);
    }));
  }
};
E._created = false, E._instance = null;
var F = E;
var ei$1 = /* @__PURE__ */ (() => {
  let r3 = 0;
  return () => r3++;
})(), Ce = class extends he {
  constructor(t, o) {
    let i = `${t}/tv`;
    super(i);
    this.bbosMap = /* @__PURE__ */ new Map();
    this.tickersMap = /* @__PURE__ */ new Map();
    this.eventBus = new ye$2();
    this._subscribeQuoteMap = /* @__PURE__ */ new Map(), this._prefixId = ei$1(), this._publicWs = new F(o), this.bbosMap = /* @__PURE__ */ new Map(), o.on("tickers", (s) => {
      for (let n4 of s.data) n4.change = n4.close - n4.open, n4.perChange = n4.open ? +(100 * n4.change / n4.open).toFixed(2) : 0, this.tickersMap.set(n4.symbol, n4);
      this.eventBus.publish("tickerUpdate", { message: "ticker" });
    }), o.subscribe({ event: "subscribe", topic: "bbos" }, { formatter: (s) => s, onMessage: (s) => {
      for (let n4 of s.data) this.bbosMap.set(n4.symbol, { ask: n4.ask, bid: n4.bid, askSize: n4.askSize, bidSize: n4.bidSize });
      this.eventBus.publish("tickerUpdate", { message: "bbos" });
    } });
  }
  remove() {
    Array.from(this._subscribeQuoteMap.values()).forEach((t) => t == null ? void 0 : t());
  }
  getSubscriptionId(t) {
    return `${this._prefixId}${t}`;
  }
  subscribeBars(t, o, i, s) {
    this._publicWs.subscribeKline(`${this._prefixId}${s}`, t.ticker, o, i);
  }
  unsubscribeBars(t) {
    this._publicWs.unsubscribeKline(`${this._prefixId}${t}`);
  }
  getQuotes(t, o) {
    let i = this.getSubscriptionId("getQuotes");
    this.unsubscribeQuotes("getQuotes");
    let s = this.eventBus.subscribe("tickerUpdate", (n4) => {
      let a2 = /* @__PURE__ */ new Map();
      t.forEach((c2) => {
        let l2 = this.bbosMap.get(O(c2)), u2 = this.tickersMap.get(O(c2));
        if (!l2 || !u2) return;
        let m2 = { ...u2, ask: l2.ask, bid: l2.bid };
        a2.set(O(c2), m2);
      }), a2.size && o(Array.from(a2.values()).map((c2) => this._toUDFTicker(c2)));
    });
    this._subscribeQuoteMap.set(i, s);
  }
  subscribeQuotes(t, o, i, s) {
    let n4 = `${this._prefixId}${s}`;
    if (t.length > 0) {
      this.unsubscribeQuotes(n4);
      let a2 = this.eventBus.subscribe("tickerUpdate", (c2) => {
        let l2 = /* @__PURE__ */ new Map();
        t.forEach((u2) => {
          let m2 = this.bbosMap.get(O(u2)), b2 = this.tickersMap.get(O(u2));
          if (!m2 || !b2) return;
          let f2 = { ...b2, ask: m2.ask, bid: m2.bid };
          l2.set(O(u2), f2);
        }), l2.size && i(Array.from(l2.values()).map((u2) => this._toUDFTicker(u2)));
      });
      this._subscribeQuoteMap.set(n4, a2);
    }
  }
  unsubscribeQuotes(t) {
    let o = this.getSubscriptionId(t), i = this._subscribeQuoteMap.get(o);
    i && (i(), this._subscribeQuoteMap.delete(o));
  }
  _toUDFTicker(t) {
    return { n: re$1(t.symbol), s: "ok", v: { ask: t.ask, bid: t.bid, ch: t.change, chp: t.perChange / 100, description: "", exchange: te$1, hight_price: t.high, low_price: t.low, lp: t.close, open_price: t.open, prev_close_price: 0, volume: t.volume } };
  }
};
var cr$1 = (r3, e3) => new Promise((t) => {
  let o = r3.querySelector(e3);
  o && t(o);
  let i = new MutationObserver(() => {
    let s = r3.querySelector(e3);
    s && (t(s), i.disconnect());
  });
  i.observe(r3, { childList: true, subtree: true });
});
var _e$1 = class _e {
  constructor({ iframeDocument: e3 }) {
    this.iframeDocument = e3;
  }
  defaultHack() {
    this.showFavoriteStarByDefault();
  }
  showFavoriteStarByDefault() {
    cr$1(this.iframeDocument, ".dropdown-2R6OKuTS").then(() => {
      this.iframeDocument.querySelectorAll(".toolbox-2IihgTnv.showOnHover-2IihgTnv").forEach((t) => {
        t.style.opacity = "1";
      });
    });
  }
};
var ti = (r3) => {
  let e3 = ["header_symbol_search", "volume_force_overlay", "trading_account_manager", "drawing_templates", "open_account_manager", "right_toolbar", "support_multicharts", "header_layouttoggle", "order_panel", "order_info", "trading_notifications", "display_market_status", "broker_button", "add_to_watchlist", "chart_crosshair_menu", "header_fullscreen_button", "header_widget"];
  return r3 === 3 && (e3 = [...e3, "left_toolbar", "timeframes_toolbar", "go_to_date", "timezone_menu", "create_volume_indicator_by_default", "buy_sell_buttons"]), r3 === 0 ? e3 = [...e3, "header_widget", "left_toolbar", "timeframes_toolbar", "buy_sell_buttons"] : r3 === 1 && (e3 = [...e3, "left_toolbar", "timeframes_toolbar", "buy_sell_buttons"]), e3;
};
function Ye$2(r3, e3) {
  return { ...r3, disabled_features: ti(e3), enabled_features: ["hide_left_toolbar_by_default", "order_panel_close_button", "iframe_loading_compatibility_mode"], auto_save_delay: 0.1, broker_config: { configFlags: { supportStopLimitOrders: true, supportReversePosition: false } } };
}
var Je$1 = (r3) => `${r3}_adapter`, ve$1 = { "trading.chart.proterty": JSON.stringify({ showSellBuyButtons: 0, noConfirmEnabled: 1, qweqrq: 0, showPricesWithZeroVolume: 1, showSpread: 1, orderExecutedSoundParams: '{"enabled":0,"name":"alert/alarm_clock"}' }), "hint.startFocusedZoom": "true" }, k = /* @__PURE__ */ new Map();
var ri$1 = (r3, e3, t) => {
  let o = Je$1(r3);
  try {
    let i = e3, s = i ? JSON.parse(i) : void 0, n4 = t ? JSON.parse(t) : ve$1;
    return i && k.set(r3, i), t && k.set(o, t), { savedData: s, adapterSetting: n4 };
  } catch {
  }
  return { savedData: void 0, adapterSetting: ve$1 };
}, ur$1 = async (r3, e3) => {
  let t = Je$1(r3), o = localStorage.getItem(r3) || "", i = localStorage.getItem(t) || "";
  try {
    if (k.has(r3) && k.has(t)) return { savedData: JSON.parse(k.get(r3)), adapterSetting: JSON.parse(k.get(t)) };
  } catch {
  }
  return ri$1(r3, o, i);
}, dr$1 = async (r3, e3, t) => {
  e3 && (localStorage.setItem(r3, e3), k.set(r3, e3));
}, pr$1 = async (r3, e3, t) => {
  let o = Je$1(r3);
  e3 && (localStorage.setItem(o, e3), k.set(o, e3));
};
var mr$1 = (r3, e3) => {
  let t = null, o = (...i) => {
    t && window.clearTimeout(t), t = setTimeout(() => {
      r3(...i);
    }, e3);
  };
  return o.cancel = () => {
    t && window.clearTimeout(t), t = null;
  }, o;
}, oi$1 = "chartProp_default", gr$1 = 300, Se$2 = class Se {
  constructor(e3) {
    this._instance = null;
    this._onClick = null;
    this._datafeed = null;
    this._chartKey = oi$1;
    this._adapterSetting = ve$1;
    this._savedData = null;
    this._isLoggedIn = false;
    this.debounceSaveChart = mr$1(() => {
      var _a2;
      try {
        (_a2 = this._instance) == null ? void 0 : _a2.save((e4) => {
          Object.is(this._savedData, e4) || (this._savedData = e4, dr$1(this._chartKey, JSON.stringify(e4), this._isLoggedIn));
        });
      } catch {
      }
    }, gr$1 * 2);
    this.debounceSaveChartAdapterSetting = mr$1(() => {
      pr$1(this._chartKey, JSON.stringify(this._adapterSetting), this._isLoggedIn);
    }, gr$1);
    this._create(e3);
  }
  remove() {
    var _a2, _b2, _c2;
    this.unsubscribeClick(), (_a2 = this._datafeed) == null ? void 0 : _a2.remove(), (_b2 = this._broker) == null ? void 0 : _b2.remove(), (_c2 = this._instance) == null ? void 0 : _c2.remove(), this.debounceSaveChart.cancel(), this.debounceSaveChartAdapterSetting.cancel();
  }
  updateOverrides(e3) {
    this.instance && this.instance.applyOverrides(e3);
  }
  setSymbol(e3, t, o) {
    var _a2;
    try {
      (_a2 = this._instance) == null ? void 0 : _a2.onChartReady(() => {
        var _a3, _b2, _c2;
        let i = t ?? ((_b2 = (_a3 = this._instance) == null ? void 0 : _a3.symbolInterval()) == null ? void 0 : _b2.interval);
        i || (i = 1), (_c2 = this._instance) == null ? void 0 : _c2.setSymbol(e3, i, o);
      });
    } catch {
    }
  }
  executeActionById(e3) {
    var _a2;
    try {
      (_a2 = this._instance) == null ? void 0 : _a2.onChartReady(() => {
        var _a3;
        (_a3 = this._instance) == null ? void 0 : _a3.activeChart().executeActionById(e3);
      });
    } catch {
    }
  }
  changeLineType(e3) {
    var _a2;
    try {
      (_a2 = this._instance) == null ? void 0 : _a2.onChartReady(() => {
        var _a3;
        (_a3 = this._instance) == null ? void 0 : _a3.activeChart().setChartType(e3);
      });
    } catch {
    }
  }
  subscribeClick(e3) {
    var _a2;
    this._onClick = e3, (_a2 = this._instance) == null ? void 0 : _a2.onChartReady(() => {
      var _a3, _b2;
      (_b2 = (_a3 = this._instance) == null ? void 0 : _a3._iFrame.contentDocument) == null ? void 0 : _b2.addEventListener("click", this._onClick);
    });
  }
  unsubscribeClick() {
    var _a2, _b2;
    (_b2 = (_a2 = this._instance) == null ? void 0 : _a2._iFrame.contentDocument) == null ? void 0 : _b2.removeEventListener("click", this._onClick);
  }
  get instance() {
    return this._instance;
  }
  chartHack() {
    var _a2;
    (_a2 = this._instance) == null ? void 0 : _a2.onChartReady(() => {
      let e3 = this._instance._iFrame.contentWindow.document;
      new _e$1({ iframeDocument: e3 }).defaultHack();
    });
  }
  subscribeAutoSave() {
    var _a2;
    (_a2 = this._instance) == null ? void 0 : _a2.onChartReady(() => {
      var _a3, _b2;
      (_a3 = this._instance) == null ? void 0 : _a3.subscribe("onAutoSaveNeeded", () => {
        this.debounceSaveChart();
      }), (_b2 = this._instance) == null ? void 0 : _b2.activeChart().onVisibleRangeChanged().subscribe(null, () => {
        this.debounceSaveChart();
      });
    });
  }
  async _create({ options: e3, chartKey: t, mode: o, onClick: i }) {
    let s = e3.getBroker, n4 = { fullscreen: e3.fullscreen ?? true, autosize: e3.autosize ?? false, timezone: e3.timezone, symbol: e3.symbol, library_path: e3.libraryPath, interval: e3.interval ?? "1", custom_css_url: e3.customCssUrl, custom_font_family: e3.customFontFamily, datafeed: e3.datafeed, studies_overrides: e3.studiesOverrides, locale: e3.locale, theme: e3.theme, loading_screen: e3.loadingScreen, overrides: e3.overrides, container: e3.container, favorites: { intervals: ["1", "3", "5", "15", "30", "60", "240", "1D", "1W", "1M"], chartTypes: ["Area", "Line"] }, broker_factory: s ? (l2) => (this._broker && this._broker.remove(), this._broker = s(this._instance, l2), this._broker) : void 0 };
    this._datafeed = e3.datafeed, t && (this._chartKey = t);
    let { savedData: a2, adapterSetting: c2 } = await ur$1(this._chartKey, this._isLoggedIn);
    this._adapterSetting = c2, this._savedData = a2, this._instance = new TradingView.widget({ ...Ye$2(n4, o), interval: c2["chart.lastUsedTimeBasedResolution"] ?? n4.interval, saved_data: a2, settings_adapter: { initialSettings: c2, setValue: (l2, u2) => {
      this._adapterSetting = { ...this._adapterSetting, [l2]: u2 }, this.debounceSaveChartAdapterSetting();
    }, removeValue: () => {
    } } }), this._instance.onChartReady(() => {
      var _a2;
      e3.symbol && ((_a2 = this._instance) == null ? void 0 : _a2.activeChart().symbol()) !== O(e3.symbol) && this.setSymbol(e3.symbol);
    }), this.subscribeAutoSave(), this.subscribeClick(i), this.chartHack();
  }
};
function ii$2(r3) {
  r3.setBrokerConnectionAdapter = function(e3) {
    let t = { subscribe: () => {
    }, unsubscribe: () => {
    }, unsubscribeAll: () => {
    } };
    Object.defineProperty(e3, "_ordersCache", { get: function() {
      return { start: () => {
      }, stop: () => {
      }, update: () => {
      }, partialUpdate: () => {
      }, fullUpdate: () => {
      }, getObjects: async () => [], updateDelegate: t, partialUpdateDelegate: t };
    }, set: () => {
    } }), e3._waitForOrderModification = async () => true, this._adapter = e3;
  };
}
function ni$2(r3, e3) {
  r3.onChartReady(() => {
    e3.silentOrdersPlacement().subscribe((t) => {
      var _a2;
      t || (e3.silentOrdersPlacement().setValue(true), r3 && (r3._iFrame.contentDocument.querySelector(".wrapper-3X2QgaDd").className = "wrapper-3X2QgaDd highButtons-3X2QgaDd"), (_a2 = e3.sellBuyButtonsVisibility()) == null ? void 0 : _a2.setValue(false));
    });
  });
}
function Xe$1(r3, e3) {
  ii$2(e3), ni$2(r3, e3);
}
var ai$1 = (r3, e3) => {
  let o, i = (s) => [null, "limit", "MARKET", "STOP_MARKET", "STOP_LIMIT"][s];
  return { symbolInfo: async (s) => (o = e3.getSymbolInfo(O(s)), { qty: { min: (o == null ? void 0 : o.baseMin) ?? 0, max: (o == null ? void 0 : o.baseMax) ?? 0, step: (o == null ? void 0 : o.baseTick) ?? 0 }, pipValue: 0, pipSize: (o == null ? void 0 : o.quoteTick) ?? 0, minTick: (o == null ? void 0 : o.quoteTick) ?? 0, description: "" }), placeOrder: async (s) => {
    let n4 = ["SELL", "BUY"][+(s.side > 0)], a2 = s.qty.toString();
    (s.limitPrice ?? 0).toString();
    (s.stopPrice ?? 0).toString();
    let u2 = O(s.symbol), m2 = i(s.type);
    m2 === "MARKET" ? e3.sendMarketOrder({ side: n4, order_quantity: a2, symbol: u2, order_type: OrderType.MARKET }) : "LIMIT";
  }, orders: () => [], positions: () => [], executions: () => [], connectionStatus: () => 1, chartContextMenuActions: (s) => r3.defaultContextMenuActions(s), isTradable: async () => true, accountManagerInfo: () => ({}), currentAccount: () => "1", accountsMetainfo: async () => [{ id: "1" }], remove: () => r3 == null ? void 0 : r3.silentOrdersPlacement().unsubscribe() };
}, fr$2 = ai$1;
var yi$2 = "SDK_Tradingview", Ci$1 = "SDK_Moblie_Tradingview", _i$1 = (r3) => r3 ? Ci$1 : yi$2, vi$1 = (r3) => r3 === "id" ? "id_ID" : r3;
function rt$2(r3) {
  let { scriptSRC: e3, libraryPath: t, customCssUrl: o, overrides: i, studiesOverrides: s, fullscreen: n4, symbol: a2, theme: c2, loadingScreen: l2, mode: u2, colorConfig: m2, locale: b2 = vi$1 } = r3, f2 = oe$4(), h2 = useRef(), K2 = useConfig("apiBaseUrl"), { state: x2 } = useAccount(), [S2, M2] = useState(OrderSide.SELL), q2 = useSymbolsInfo(), { onSubmit: W2, submitting: j2 } = useOrderEntry({ symbol: a2 ?? "", side: S2, order_type: OrderType.MARKET }, { watchOrderbook: true }), [y2, I2] = useState(() => {
    let d2 = localStorage.getItem(V.displayControlSetting);
    return d2 ? JSON.parse(d2) : { position: true, buySell: true, limitOrders: true, stopOrders: true, tpsl: true, positionTpsl: true };
  }), [ot2, _r3] = useState(() => {
    let d2 = localStorage.getItem(V.interval);
    return d2 || "1";
  }), [vr2, Sr2] = useState(() => {
    let d2 = localStorage.getItem(V.lineType);
    return d2 || "1";
  }), Te2 = useMediaQuery(MEDIA_TABLET), Oe2 = useMemo(() => Object.assign({}, Ht$2, m2 ?? {}), [m2]), Ir2 = useMemo(() => typeof l2 == "object" ? l2 : { backgroundColor: Ae }, [l2]), it2 = useWS(), [G2, Tr2] = useState(false), Or = (d2) => {
    let Y2 = q2[a2];
    if (!Y2) return;
    let J2 = new g$6(d2.balance).greaterThan(0) ? OrderSide.SELL : OrderSide.BUY, at2 = { order_quantity: new g$6(d2.balance).abs().toNumber(), symbol: a2, order_type: OrderType.MARKET, side: J2, reduce_only: true };
    M2(J2), uo$3.show("MarketCloseConfirmID", { base: Y2("base"), quantity: d2.balance, onConfirm: async () => W2(at2), submitting: j2 });
  }, D2 = useRef(null), nt2 = useMemo(() => !(x2.status < AccountStatusEnum.EnableTrading && x2.status !== AccountStatusEnum.EnableTradingWithoutConnected), [x2]), st2 = jt$1({ closeConfirm: Or, colorConfig: Oe2, onToast: toast$2, symbol: a2 ?? "", mode: u2 }), [xr2, Lr2] = Ze(a2, y2), wr2 = (d2) => {
    h2.current && (localStorage.setItem(V.interval, d2), _r3(d2), h2.current.setSymbol(a2, d2));
  }, Rr2 = (d2) => {
    h2.current && (localStorage.setItem(V.lineType, d2), Sr2(d2), h2.current.changeLineType(Number(d2)));
  }, Pr2 = (d2) => {
    localStorage.setItem(V.displayControlSetting, JSON.stringify(d2)), I2(d2);
  }, Er2 = () => {
    h2.current && h2.current.executeActionById("chartProperties");
  }, kr2 = () => {
    h2.current && h2.current.executeActionById("insertIndicator");
  };
  return useEffect(() => {
    if (e3 && D2.current && !G2) {
      let d2 = document.createElement("script");
      d2.setAttribute("data-nscript", "afterInteractive"), d2.src = e3, d2.async = true, d2.type = "text/javascript", d2.onload = () => {
        Tr2(true);
      }, d2.onerror = () => {
      }, D2.current.appendChild(d2);
    }
  }, [D2, G2, e3]), useEffect(() => {
    if (!a2 || !G2 || !e3) return;
    let d2 = Ut(Oe2, Te2), Y2 = i ? Object.assign({}, d2.overrides, i) : d2.overrides, J2 = s ? Object.assign({}, d2.studiesOverrides, s) : d2.studiesOverrides;
    if (D2.current) {
      let Mr2 = { options: { fullscreen: n4 ?? false, autosize: true, symbol: re$1(a2), locale: typeof b2 == "function" ? b2(f2) : b2, timezone: Intl.DateTimeFormat().resolvedOptions().timeZone, container: D2.current, libraryPath: t, customCssUrl: o, interval: ot2 ?? "1", theme: c2 ?? "dark", loadingScreen: Ir2 ?? {}, overrides: Y2, studiesOverrides: J2, datafeed: new Ce(K2, it2), contextMenu: { items_processor: async (xe2) => xe2 }, getBroker: (xe2, lt2) => (Xe$1(xe2, lt2), fr$2(lt2, st2)) }, chartKey: _i$1(Te2), mode: u2, onClick: () => {
      } };
      h2.current = new Se$2(Mr2);
    }
    return () => {
      var _a2;
      (_a2 = h2.current) == null ? void 0 : _a2.remove();
    };
  }, [G2, Te2, u2, h2, D2, G2, e3, Oe2, b2, f2]), useEffect(() => (h2.current && h2.current.instance && h2.current.instance.onChartReady(() => {
    nt2 && h2.current.instance && xr2(h2.current.instance, void 0, st2);
  }), () => {
    Lr2();
  }), [h2.current, nt2]), useEffect(() => {
    var _a2;
    if (!a2 || !h2.current) return;
    (_a2 = h2.current) == null ? void 0 : _a2.setSymbol(a2);
    let d2 = new F(it2);
    return d2.subscribeSymbol(a2), () => {
      d2.unsubscribeKline(a2);
    };
  }, [a2]), { tradingViewScriptSrc: e3, chartRef: D2, changeDisplaySetting: Pr2, displayControlState: y2, interval: ot2, changeInterval: wr2, lineType: vr2, changeLineType: Rr2, openChartSetting: Er2, openChartIndicators: kr2, symbol: a2 };
}
function Si$1(r3) {
  let e3 = rt$2(r3);
  return jsx(De$1, { ...e3 });
}
var De = createContext({}), ce = () => useContext(De), Pe = (e3) => {
  let { type: t, values: r3 } = e3, [o, s] = useLocalStorage("TP/SL_Mode", "Offset%"), { t: n4 } = Z$2(), p2 = useMemo(() => !r3.PnL || !e3.values.trigger_price ? null : jsxs(z$1, { children: [jsx("span", { className: "oui-text-xs oui-text-base-contrast-54", children: o === "PnL" ? n4("orderEntry.estRoi") : n4("orderEntry.estPnL") }), o === "PnL" ? jsx($$4.numeral, { rule: "percentages", className: cnBase("oui-text-xs oui-ml-1", t === "TP" ? "oui-text-trade-profit" : "oui-text-trade-loss"), children: r3.ROI }) : jsx($$4.numeral, { rule: "price", className: cnBase("oui-text-xs oui-ml-1", t === "TP" ? "oui-text-trade-profit" : "oui-text-trade-loss"), children: r3.PnL })] }), [o, e3.values.PnL, e3.values.trigger_price]);
  return jsx(De.Provider, { value: { mode: o, setMode: s, tipsEle: p2 }, children: e3.children });
};
var Qe$1 = (e3) => {
  let { type: t, values: r3, quote_dp: o } = e3, { t: s } = Z$2(), { mode: n4, setMode: p2, tipsEle: c2 } = ce(), [a2, f2] = useState(false), d2 = useMemo(() => {
    switch (n4) {
      case "Offset":
        return `${t.toLowerCase()}_offset`;
      case "Offset%":
        return `${t.toLowerCase()}_offset_percentage`;
      default:
        return `${t.toLowerCase()}_pnl`;
    }
  }, [n4]), _2 = useMemo(() => r3[n4], [r3, n4]), g2 = useMemo(() => [{ label: s("tpsl.pnl"), value: "PnL", testId: "PnL_menu_item" }, { label: s("tpsl.offset"), value: "Offset", testId: "Offset_mneu_item" }, { label: `${s("tpsl.offset")}%`, value: "Offset%", testId: "Offset%_menu_item" }], [s]), v2 = useMemo(() => ({ PnL: s("tpsl.pnl"), Offset: s("tpsl.offset"), "Offset%": `${s("tpsl.offset")}%` }), [s]), T2 = useRef("");
  return { mode: n4, modes: g2, modeLabelMap: v2, formatter: (R2) => {
    let { dp: U3 = 2 } = R2;
    return { onRenderBefore: (l2, w5) => (l2 = `${l2}`, t === "SL" && n4 === "PnL" && (l2 = l2.startsWith("-") ? l2 : "-" + l2), l2 === "" || l2 === "-" ? "" : n4 === "Offset%" ? `${new g$6(l2.replace(new RegExp(T2.current.replace(".", "\\.") + "$"), "")).mul(100).todp(2, 4).toString()}${T2.current}` : (n4 === "Offset" && (l2 = A$7(l2, U3)), `${l2}`)), onSendBefore: (l2) => {
      if (/^\-?0{2,}$/.test(l2)) return "0";
      if (n4 === "Offset%") {
        if (l2 !== "") {
          l2 = A$7(l2, 2);
          let w5 = l2.match(/\.0{0,2}$/);
          w5 ? T2.current = w5[0] : T2.current = "", l2 = new g$6(l2).div(100).toString(), l2 = `${l2}${T2.current}`;
        }
      } else l2 = A$7(l2, U3);
      return l2 === "" || l2 === "-" ? "" : l2;
    } };
  }, onModeChange: (R2) => {
    p2(R2);
  }, onFocus: () => {
    f2(true);
  }, onBlur: () => {
    f2(false);
  }, value: _2, onValueChange: (R2) => {
    e3.onChange(d2, R2);
  }, quote_dp: o, tips: a2 ? c2 : void 0 };
};
var Ge$1 = (e3) => {
  var _a2, _b2;
  let { mode: t, modes: r3, modeLabelMap: o, onModeChange: s, onValueChange: n4, quote: p2, quote_dp: c2, value: a2, type: f2, tips: d2, onFocus: _2, onBlur: g2 } = e3, [v2, T2] = useState(t), [h2, A2] = useState(t === "Offset%" ? "%" : p2);
  useEffect(() => {
    T2(t), A2(t === "Offset%" ? "%" : p2);
  }, [t]), useEffect(() => {
    T2(a2 ? "" : t);
  }, [a2]);
  let V2 = useMemo(() => `${f2.toLowerCase()}_${t.toLowerCase()}`, []);
  return jsx(So$4.tooltip, { prefix: o[v2] || v2, size: "md", placeholder: h2, id: V2, align: "right", value: a2, tooltip: d2, tooltipProps: { content: { side: e3.type === "TP" ? "top" : "bottom" } }, "data-testid": (_a2 = e3.testIds) == null ? void 0 : _a2.input, autoComplete: "off", onValueChange: n4, formatters: [e3.formatter({ dp: c2, mode: t, type: f2 }), Xr$1.currencyFormatter], classNames: { root: f2 === "TP" ? "oui-text-trade-profit" : "oui-text-trade-loss", additional: "oui-text-base-contrast-54", input: "oui-text-inherit" }, onFocus: () => {
    T2(""), A2(""), _2();
  }, onBlur: () => {
    T2(a2 ? "" : t), A2(t === "Offset%" ? "%" : p2), g2();
  }, suffix: jsxs(Fragment$1, { children: [t === "Offset%" && !!a2 && jsx($$4, { size: "2xs", color: "inherit", className: "oui-ml-[2px]", children: "%" }), jsx(Qt$1, { mode: t, modes: r3, onModeChange: (Q2) => s(Q2.value), testId: (_b2 = e3.testIds) == null ? void 0 : _b2.dropDown })] }) });
}, Qt$1 = (e3) => jsx(If, { currentValue: e3.mode, menu: e3.modes, align: "end", size: "xs", className: "oui-min-w-[80px]", onCloseAutoFocus: (t) => t.preventDefault(), onSelect: (t) => e3.onModeChange(t), children: jsx("button", { className: "oui-p-2", "data-testid": e3.testId, children: jsx(Q$4, { size: 12, color: "white" }) }) });
var He$2 = (e3) => {
  let { testIds: t, quote: r3, ...o } = e3, s = Qe$1(o);
  return jsx(Ge$1, { ...s, testIds: t, quote: r3, type: e3.type });
};
var ne = createContext({}), We$2 = ne.Provider;
var Je = (e3) => {
  let t = Ce__default__default.useRef(null), { t: r3 } = Z$2();
  return useEffect(() => {
    e3.orderType !== OrderType.LIMIT && e3.orderType !== OrderType.MARKET && e3.onSwitchChanged(false);
  }, [e3.orderType]), e3.orderType !== OrderType.LIMIT && e3.orderType !== OrderType.MARKET || e3.isReduceOnly ? null : jsxs("div", { children: [jsxs(z$1, { itemAlign: "center", gapX: 1, children: [jsx(Zr$2, { id: "order_entry_tpsl", className: "oui-h-[14px]", checked: e3.switchState, disabled: e3.orderType !== OrderType.LIMIT && e3.orderType !== OrderType.MARKET || e3.isReduceOnly, onCheckedChange: (o) => {
    e3.onSwitchChanged(o);
  } }), jsx("label", { htmlFor: "order_entry_tpsl", className: "oui-text-xs", children: r3("common.tpsl") }), jsx(Ga, { color: "white", size: 14, opacity: 1, className: "oui-text-white/[.36] hover:oui-text-white/80 oui-cursor-pointer", onClick: () => {
    uo$3.dialog({ title: r3("common.tips"), size: "xs", content: jsx($$4, { intensity: 54, children: r3("orderEntry.tpsl.tips") }) });
  } })] }), jsx("div", { className: cnBase("oui-max-h-0 oui-overflow-hidden oui-transition-all", e3.switchState && "oui-max-h-[100px]"), onTransitionEnd: () => {
    var _a2;
    (_a2 = t.current) == null ? void 0 : _a2.style.setProperty("opacity", e3.switchState ? "1" : "0");
  }, children: jsx(et, { ref: t, onChange: e3.onChange, values: e3.values, errors: e3.errors, quote_dp: e3.quote_dp }) })] });
}, et = Ce__default__default.forwardRef((e3, t) => {
  let { parseErrorMsg: r3 } = Tr$1(e3.errors);
  return jsxs("div", { ref: t, className: "oui-transition-all oui-pt-2 oui-pb-2 oui-px-[1px] oui-space-y-1", children: [jsx(Pe, { values: e3.values.tp, type: "TP", children: jsx($e$1, { type: "TP", error: r3("tp_trigger_price"), onChange: e3.onChange, values: e3.values.tp, quote_dp: e3.quote_dp, testIds: { first: "oui-testid-orderEntry-tpsl-tpPrice-input", second: "oui-testid-orderEntry-tpsl-tpPnl-input", dropDown: "oui-testid-orderEntry-tpsl-tp-dropDown-trigger-button" } }) }), jsx(Pe, { values: e3.values.sl, type: "SL", children: jsx($e$1, { type: "SL", error: r3("sl_trigger_price"), onChange: e3.onChange, values: e3.values.sl, quote_dp: e3.quote_dp, testIds: { first: "oui-testid-orderEntry-tpsl-slPrice-input", second: "oui-testid-orderEntry-tpsl-slPnl-input", dropDown: "oui-testid-orderEntry-tpsl-sl-dropDown-trigger-button" } }) })] });
});
et.displayName = "TPSLInputForm";
var ir$1 = (e3) => {
  let { t } = Z$2(), { errorMsgVisible: r3 } = useContext(ne), { tipsEle: o } = ce(), [s, n4] = useState(`${e3.type} Price`), [p2, c2] = useState("USDC"), [a2, f2] = useState(false), d2 = useMemo(() => e3.error && r3 ? e3.error : a2 ? o : null, [e3.error, r3, a2, o]), _2 = (g2) => {
    let v2 = e3.type === "TP" ? t("tpsl.tpPrice") : t("tpsl.slPrice");
    return g2 && (v2 = e3.type === "TP" ? t("tpsl.tp") : t("tpsl.sl")), v2;
  };
  return useEffect(() => {
    n4(_2(e3.values.trigger_price));
  }, [e3.type, e3.values.trigger_price]), jsx(So$4.tooltip, { "data-testid": e3.testId, prefix: s, size: "md", placeholder: p2, align: "right", onFocus: () => {
    n4(e3.type === "TP" ? t("tpsl.tp") : t("tpsl.sl")), c2(""), f2(true);
  }, onBlur: () => {
    n4(_2(e3.values.trigger_price)), c2("USDC"), f2(false);
  }, tooltip: d2, tooltipProps: { content: { side: e3.type === "TP" ? "top" : "bottom" } }, color: e3.error ? "danger" : void 0, autoComplete: "off", value: e3.values.trigger_price, classNames: { additional: "oui-text-base-contrast-54", root: "oui-pr-2 md:oui-pr-3", prefix: "oui-pr-1 md:oui-pr-2" }, onValueChange: e3.onChange, formatters: [Xr$1.numberFormatter, Xr$1.dpFormatter(e3.quote_dp ?? 2), Xr$1.currencyFormatter] });
}, $e$1 = (e3) => {
  var _a2, _b2, _c2;
  let t = e3.type === "SL" ? "sl_trigger_price" : "tp_trigger_price";
  return jsxs(ia$1, { cols: 2, gapX: 1, children: [jsx(ir$1, { testId: (_a2 = e3.testIds) == null ? void 0 : _a2.first, type: e3.type, error: e3.error, values: e3.values ?? "", onChange: (r3) => {
    e3.onChange(t, r3);
  }, quote_dp: e3.quote_dp }), jsx(He$2, { testIds: { input: (_b2 = e3.testIds) == null ? void 0 : _b2.second, dropDown: (_c2 = e3.testIds) == null ? void 0 : _c2.dropDown }, onChange: e3.onChange, quote: "USDC", quote_dp: e3.quote_dp, type: e3.type, values: { PnL: e3.values.PnL, Offset: e3.values.Offset, "Offset%": e3.values["Offset%"], ROI: e3.values.ROI } })] });
};
function ye$1(e3) {
  let { order_type: t, order_type_ext: r3 } = e3, o = [OrderType.ASK, OrderType.BID].includes(r3);
  return t ? t === OrderType.LIMIT && o : o;
}
function tt(e3, t) {
  if ([BBOOrderType.COUNTERPARTY1, BBOOrderType.COUNTERPARTY5].includes(e3)) return t === OrderSide.BUY ? OrderType.ASK : OrderType.BID;
  if ([BBOOrderType.QUEUE1, BBOOrderType.QUEUE5].includes(e3)) return t === OrderSide.BUY ? OrderType.BID : OrderType.ASK;
}
function rt$1(e3) {
  if ([BBOOrderType.COUNTERPARTY1, BBOOrderType.QUEUE1].includes(e3)) return OrderLevel.ONE;
  if ([BBOOrderType.COUNTERPARTY5, BBOOrderType.QUEUE5].includes(e3)) return OrderLevel.FIVE;
}
function ot(e3) {
  let { type: t, side: r3, level: o } = e3;
  if (t === OrderType.ASK) {
    if (o === OrderLevel.ONE) return r3 === OrderSide.BUY ? BBOOrderType.COUNTERPARTY1 : BBOOrderType.QUEUE1;
    if (o === OrderLevel.FIVE) return r3 === OrderSide.BUY ? BBOOrderType.COUNTERPARTY5 : BBOOrderType.QUEUE5;
  }
  if (t === OrderType.BID) {
    if (o === OrderLevel.ONE) return r3 === OrderSide.BUY ? BBOOrderType.QUEUE1 : BBOOrderType.COUNTERPARTY1;
    if (o === OrderLevel.FIVE) return r3 === OrderSide.BUY ? BBOOrderType.QUEUE5 : BBOOrderType.COUNTERPARTY5;
  }
}
var Se$1 = (e3) => {
  let { baseDP: t, quoteDP: r3, order: o, onConfirm: s, onCancel: n4 } = e3, { side: p2, order_type: c2, order_type_ext: a2, level: f2 } = o, { t: d2 } = Z$2(), [_2, g2] = useLocalStorage("orderly_order_confirm", true), v2 = () => {
    if (c2 === OrderType.MARKET || c2 === OrderType.STOP_MARKET) return jsx($$4, { intensity: 80, children: d2("common.marketPrice") });
    if (ye$1({ order_type: c2, order_type_ext: a2 })) {
      let T2 = ot({ type: a2, side: p2, level: f2 }), h2 = { [BBOOrderType.COUNTERPARTY1]: d2("orderEntry.bbo.counterparty1"), [BBOOrderType.COUNTERPARTY5]: d2("orderEntry.bbo.counterparty5"), [BBOOrderType.QUEUE1]: d2("orderEntry.bbo.queue1"), [BBOOrderType.QUEUE5]: d2("orderEntry.bbo.queue5") }[T2];
      return jsx($$4, { intensity: 80, children: h2 });
    }
    return jsx($$4.numeral, { unit: "USDC", rule: "price", className: "oui-text-base-contrast", unitClassName: "oui-text-base-contrast-36 oui-ml-1", dp: r3, padding: false, children: o.order_price });
  };
  return jsxs(Fragment$1, { children: [jsxs(z$1, { justify: "between", children: [jsx($$4.formatted, { rule: "symbol", showIcon: true, children: o.symbol }), jsxs(z$1, { justify: "end", gapX: 1, children: [jsx(yr, { type: c2 }), p2 === OrderSide.BUY ? jsx(od, { color: "buy", size: "sm", children: d2("common.buy") }) : jsx(od, { color: "sell", size: "sm", children: d2("common.sell") })] })] }), jsx(te$6, { className: "oui-my-4" }), jsxs("div", { className: na$1({ size: "sm", intensity: 54, className: "oui-space-y-1" }), children: [jsxs(z$1, { justify: "between", children: [jsx($$4, { children: d2("common.qty") }), jsx($$4.numeral, { rule: "price", dp: t, padding: false, className: "oui-text-base-contrast", children: o.order_quantity })] }), o.trigger_price ? jsxs(z$1, { justify: "between", children: [jsx($$4, { children: d2("common.trigger") }), jsx($$4.numeral, { unit: "USDC", rule: "price", className: "oui-text-base-contrast", unitClassName: "oui-text-base-contrast-36 oui-ml-1", dp: r3, padding: false, children: o.trigger_price })] }) : null, jsxs(z$1, { justify: "between", children: [jsx($$4, { children: d2("common.price") }), v2()] }), jsxs(z$1, { justify: "between", children: [jsx($$4, { children: d2("common.notional") }), jsx($$4.numeral, { unit: "USDC", rule: "price", dp: r3, padding: false, className: "oui-text-base-contrast", unitClassName: "oui-text-base-contrast-36 oui-ml-1", children: o.total })] })] }), o.tp_trigger_price || o.sl_trigger_price ? jsxs(Fragment$1, { children: [jsx(te$6, { className: "oui-my-4" }), jsxs("div", { className: na$1({ size: "sm", intensity: 54, className: "oui-space-y-1" }), children: [o.tp_trigger_price && jsxs(z$1, { justify: "between", children: [jsx($$4, { children: d2("orderEntry.tpMarkPrice") }), jsx($$4.numeral, { unit: "USDC", rule: "price", coloring: true, dp: r3, padding: false, unitClassName: "oui-text-base-contrast-36 oui-ml-1", children: o.tp_trigger_price })] }), o.sl_trigger_price && jsxs(z$1, { justify: "between", children: [jsx($$4, { children: d2("orderEntry.slMarkPrice") }), jsx($$4.numeral, { unit: "USDC", rule: "price", coloring: true, className: "oui-text-trade-loss", unitClassName: "oui-text-base-contrast-36 oui-ml-1", dp: r3, padding: false, children: o.sl_trigger_price })] })] })] }) : null, jsxs(z$1, { gapX: 1, pt: 4, pb: 5, children: [jsx($r$1, { id: "orderConfirm", color: "white", onCheckedChange: (T2) => {
    g2(!T2);
  } }), jsx("label", { htmlFor: "orderConfirm", className: na$1({ size: "xs", intensity: 54 }), children: d2("orderEntry.disableOrderConfirm") })] }), o.tp_trigger_price || o.sl_trigger_price ? jsx(_$1, { py: 3, px: 3, className: "oui-text-center", children: jsx($$4, { color: "warning", size: "xs", children: d2("orderEntry.tpsl.trigger.description") }) }) : null, jsxs(ia$1, { cols: 2, gapX: 3, children: [jsx(_e$5, { color: "secondary", size: "md", onClick: () => n4(), children: d2("common.cancel") }), jsx(_e$5, { size: "md", onClick: () => s(), children: d2("common.confirm") })] })] });
};
Se$1.displayName = "OrderConfirmDialog";
var yr = (e3) => {
  let { t } = Z$2(), r3 = useMemo(() => {
    switch (e3.type) {
      case OrderType.LIMIT:
        return t("orderEntry.orderType.limit");
      case OrderType.MARKET:
        return t("common.marketPrice");
      case OrderType.STOP_LIMIT:
        return t("orderEntry.orderType.stopLimit");
      case OrderType.STOP_MARKET:
        return t("orderEntry.orderType.stopMarket");
      default:
        return "";
    }
  }, [e3.type]);
  return jsx(od, { color: "neutral", size: "sm", children: r3 });
}, fr$1 = (e3) => {
  let { close: t, resolve: r3, reject: o, ...s } = e3;
  return jsx(Se$1, { ...s, onCancel: t, onConfirm: () => {
    r3(), t();
  } });
}, Be$2 = "orderConfirm";
Pg(Be$2, fr$1, { size: "sm", title: () => e2.t("orderEntry.orderConfirm") });
var dt = (e3) => {
  let { pinned: t, orderTypeExtra: r3 } = e3, { t: o } = Z$2(), s = (n4) => (p2) => {
    e3.onValueChange && e3.onValueChange("order_type_ext", p2 ? n4 : "");
  };
  return useEffect(() => {
    var _a2;
    (_a2 = e3.onValueChange) == null ? void 0 : _a2.call(e3, "visible_quantity", e3.hidden ? 0 : 1);
  }, [e3.hidden]), jsxs("div", { className: "oui-text-base-contrast-54", children: [jsxs(z$1, { justify: t ? "start" : "between", mb: 3, width: t ? "unset" : "100%", className: "oui-gap-x-2 md:oui-gap-x-3", wrap: "wrap", gapY: 1, children: [jsxs(z$1, { itemAlign: "center", children: [jsx($r$1, { "data-testid": "oui-testid-orderEntry-postOnly-checkBox", id: "toggle_order_post_only", className: "oui-peer", color: "white", variant: "radio", disabled: !e3.showExtra, checked: r3 === OrderType.POST_ONLY, onCheckedChange: s(OrderType.POST_ONLY) }), jsx("label", { htmlFor: "toggle_order_post_only", className: cnBase("oui-text-2xs oui-ml-1 peer-data-[disabled]:oui-text-base-contrast-20", "oui-break-normal oui-whitespace-nowrap"), children: o("orderEntry.orderType.postOnly") })] }), jsxs(z$1, { itemAlign: "center", children: [jsx($r$1, { "data-testid": "oui-testid-orderEntry-ioc-checkBox", id: "toggle_order_iov", color: "white", className: "oui-peer", variant: "radio", checked: r3 === OrderType.IOC, onCheckedChange: s(OrderType.IOC), disabled: !e3.showExtra }), jsx("label", { htmlFor: "toggle_order_iov", className: cnBase("oui-text-2xs oui-ml-1 peer-data-[disabled]:oui-text-base-contrast-20", "oui-break-normal oui-whitespace-nowrap"), children: o("orderEntry.orderType.ioc") })] }), jsxs(z$1, { itemAlign: "center", children: [jsx($r$1, { "data-testid": "oui-testid-orderEntry-fox-checkBox", id: "toggle_order_fok", color: "white", variant: "radio", className: "oui-peer", checked: r3 === OrderType.FOK, onCheckedChange: s(OrderType.FOK), disabled: !e3.showExtra }), jsx("label", { htmlFor: "toggle_order_fok", className: cnBase("oui-text-2xs oui-ml-1 peer-data-[disabled]:oui-text-base-contrast-20", "oui-break-normal oui-whitespace-nowrap"), children: o("orderEntry.orderType.fok") })] })] }), jsxs(z$1, { gapX: 6, children: [jsxs(z$1, { children: [jsx($r$1, { "data-testid": "oui-testid-orderEntry-orderConfirm-checkBox", id: "toggle_order_confirm", color: "white", checked: e3.needConfirm, onCheckedChange: (n4) => {
    e3.setNeedConfirm(!!n4);
  } }), jsx("label", { htmlFor: "toggle_order_confirm", className: "oui-text-2xs oui-ml-1", children: o("orderEntry.orderConfirm") })] }), jsxs(z$1, { children: [jsx($r$1, { "data-testid": "oui-testid-orderEntry-hidden-checkBox", id: "toggle_order_hidden", color: "white", checked: e3.hidden, onCheckedChange: (n4) => {
    e3.setHidden(n4);
  } }), jsx("label", { htmlFor: "toggle_order_hidden", className: "oui-text-2xs oui-ml-1", children: o("orderEntry.hidden") })] })] }), !t && jsxs(Fragment$1, { children: [jsx(te$6, { className: "oui-my-3" }), jsxs(z$1, { children: [jsx(Zr$2, { "data-testid": "oui-testid-orderEntry-additional-keepVisible-switch", id: "toggle_order_keep_visible", onCheckedChange: (n4) => {
    e3.setPinned(n4);
  } }), jsx("label", { htmlFor: "toggle_order_keep_visible", className: "oui-text-2xs oui-ml-1", children: o("orderEntry.keepVisible") })] })] })] });
};
var lt = () => ({});
var ge2 = (e3) => {
  let t = lt();
  return jsx(dt, { ...t, ...e3 });
};
var Re$1 = (e3) => {
  let { side: t, formattedOrder: r3, setOrderValue: o, setOrderValues: s, symbolInfo: n4, maxQty: p2, freeCollateral: c2, helper: a2, submit: f2, metaState: d2, bboStatus: _2, bboType: g2, onBBOChange: v2, toggleBBO: T2 } = e3, { t: h2 } = Z$2(), { errors: A2, validated: V2 } = d2, [Q2, R2] = useState(false), [U3, l2] = useLocalStorage("orderly_order_confirm", true), [w5, G2] = useLocalStorage("orderly-order-additional-pinned", true), [$2, de2] = useLocalStorage("orderly-order-hidden", false), Oe2 = useMemo(() => t === OrderSide.BUY ? h2("orderEntry.buyLong") : h2("orderEntry.sellShort"), [t, h2]);
  useEffect(() => {
    V2 && R2(true);
  }, [V2]), useEffect(() => {
    let m2 = (H2) => {
      H2.target.closest("#order-entry-submit-button") || R2((le2) => le2 && false);
    };
    return Q2 ? document.addEventListener("click", m2) : document.removeEventListener("click", m2), () => {
      document.removeEventListener("click", m2);
    };
  }, [Q2]);
  let Ee2 = () => {
    a2.validate().then((m2) => U3 ? uo$3.show(Be$2, { order: r3, quote: n4.quote, base: n4.base, quoteDP: n4.quote_dp, baseDP: n4.base_dp }) : true, (m2) => {
      if (R2(true), typeof m2 == "object" && (m2.total != null || m2.order_quantity != null || m2.order_price != null || m2.trigger_price != null)) return Promise.reject();
    }).then(() => f2().then((m2) => {
      m2.success || toast$2.error(m2.message);
    })).catch((m2) => {
      m2 !== "cancel" && typeof m2 == "object" && m2.message && toast$2.error(m2.message);
    });
  };
  return jsx(We$2, { value: { errorMsgVisible: Q2 }, children: jsxs("div", { className: "oui-space-y-2 xl:oui-space-y-3 oui-text-base-contrast-54", ref: e3.containerRef, children: [jsxs(z$1, { gapX: 2, className: "oui-flex-col lg:oui-flex-row oui-gap-y-3", children: [jsxs("div", { className: "oui-grid oui-grid-cols-2 oui-w-full oui-flex-1 oui-gap-x-2 lg:oui-flex lg:oui-gap-x-[6px]", children: [jsx(_e$5, { onClick: () => {
    e3.setOrderValue("side", OrderSide.BUY);
  }, size: "md", fullWidth: true, "data-type": OrderSide.BUY, className: cnBase(t === OrderSide.BUY && e3.canTrade ? "oui-bg-success-darken hover:oui-bg-success-darken/80 active:oui-bg-success-darken/80" : "oui-bg-base-7 hover:oui-bg-base-6 active:oui-bg-base-6 oui-text-base-contrast-36"), "data-testid": "oui-testid-orderEntry-side-buy-button", children: h2("common.buy") }), jsx(_e$5, { onClick: () => {
    e3.setOrderValue("side", OrderSide.SELL);
  }, "data-type": OrderSide.SELL, fullWidth: true, size: "md", className: cnBase(t === OrderSide.SELL && e3.canTrade ? "oui-bg-danger-darken hover:oui-bg-danger-darken/80 active:oui-bg-danger-darken/80" : "oui-bg-base-7 hover:oui-bg-base-6 active:oui-bg-base-6 oui-text-base-contrast-36"), "data-testid": "oui-testid-orderEntry-side-sell-button", children: h2("common.sell") })] }), jsx("div", { className: "oui-w-full lg:oui-flex-1", children: jsx(Ur$1, { type: r3.order_type, side: t, canTrade: e3.canTrade, onChange: (m2) => {
    o("order_type", m2);
  } }) })] }), jsxs(z$1, { justify: "between", children: [jsx($$4, { size: "2xs", children: h2("common.available") }), jsx($$4.numeral, { unit: n4.quote, size: "2xs", className: "oui-text-base-contrast-80", unitClassName: "oui-ml-1 oui-text-base-contrast-54", dp: 2, padding: false, children: e3.canTrade ? c2 : 0 })] }), jsx(Ar, { type: e3.type, symbolInfo: n4, values: { quantity: r3.order_quantity, price: r3.order_price, trigger_price: r3.trigger_price, total: r3.total, level: r3.level, side: r3.side, order_type_ext: r3.order_type_ext }, errors: V2 ? A2 : null, onChange: (m2, H2) => {
    e3.setOrderValue(m2, H2);
  }, onValuesChange: e3.setOrderValues, refs: e3.refs, onBlur: e3.onBlur, onFocus: e3.onFocus, bbo: { bboStatus: _2, bboType: g2, onBBOChange: v2, toggleBBO: T2 }, priceInputContainerWidth: e3.priceInputContainerWidth }), jsx(qr$1, { canTrade: e3.canTrade, maxQty: p2, currentQtyPercentage: e3.currentQtyPercentage, value: r3.order_quantity ? Number(r3.order_quantity) : 0, tick: n4.base_tick, dp: n4.base_dp, setMaxQty: e3.setMaxQty, onValueChange: (m2) => {
    o("order_quantity", m2);
  }, side: e3.side }), jsx(dr$3, { fullWidth: true, id: "order-entry-submit-button", "data-type": OrderSide.BUY, className: cnBase(t === OrderSide.BUY ? "orderly-order-entry-submit-button-buy oui-bg-success-darken hover:oui-bg-success-darken/80 active:oui-bg-success-darken/80" : "orderly-order-entry-submit-button-sell oui-bg-danger-darken hover:oui-bg-danger-darken/80 active:oui-bg-danger-darken/80"), onClick: () => {
    Ee2();
  }, loading: e3.isMutating, disabled: !e3.canTrade, children: Oe2 }), jsx(Dr$1, { canTrade: e3.canTrade, quote: n4.quote, estLiqPrice: e3.estLiqPrice, estLeverage: e3.estLeverage, currentLeverage: e3.currentLeverage }), jsx(te$6, { className: "oui-w-full" }), jsx(Je, { quote_dp: e3.symbolInfo.quote_dp, switchState: e3.tpslSwitch, onSwitchChanged: e3.setTpslSwitch, orderType: r3.order_type, errors: V2 ? A2 : null, isReduceOnly: r3.reduce_only, values: { tp: { trigger_price: r3.tp_trigger_price ?? "", PnL: r3.tp_pnl ?? "", Offset: r3.tp_offset ?? "", "Offset%": r3.tp_offset_percentage ?? "", ROI: r3.tp_ROI ?? "" }, sl: { trigger_price: r3.sl_trigger_price ?? "", PnL: r3.sl_pnl ?? "", Offset: r3.sl_offset ?? "", "Offset%": r3.sl_offset_percentage ?? "", ROI: r3.sl_ROI ?? "" } }, onChange: (m2, H2) => {
    e3.setOrderValue(m2, H2);
  } }), jsxs(z$1, { justify: "between", itemAlign: "center", className: "!oui-mt-[0px] xl:!oui-mt-3", children: [jsxs(z$1, { itemAlign: "center", gapX: 1, children: [jsx(Zr$2, { "data-testid": "oui-testid-orderEntry-reduceOnly-switch", className: "oui-h-[14px]", id: "reduceOnly", checked: e3.formattedOrder.reduce_only, onCheckedChange: (m2) => {
    e3.setOrderValue("reduce_only", m2);
  } }), jsx("label", { htmlFor: "reduceOnly", className: "oui-text-xs", children: h2("orderEntry.reduceOnly") })] }), !w5 && jsx(zr, { pinned: w5, setPinned: G2, needConfirm: U3, setNeedConfirm: l2, onValueChange: o, orderTypeExtra: r3.order_type_ext, showExtra: r3.order_type === OrderType.LIMIT && !e3.tpslSwitch, hidden: $2, setHidden: de2 })] }), w5 && jsxs(_$1, { p: 2, r: "md", intensity: 700, position: "relative", children: [jsx(ge2, { pinned: w5, setPinned: G2, needConfirm: U3, setNeedConfirm: l2, onValueChange: o, orderTypeExtra: r3.order_type_ext, showExtra: r3.order_type === OrderType.LIMIT && !e3.tpslSwitch, hidden: $2, setHidden: de2 }), jsx(kr$1, { onClick: () => {
    G2(false);
  }, className: "oui-absolute oui-top-2 oui-right-2 oui-group", "data-testid": "oui-testid-orderEntry-pinned-button" })] })] }) });
}, pt = "M10.007 1.302a.74.74 0 0 0-.486.214c-1.033.989-1.349 1.815-.972 2.948-.88.675-1.437.84-2.536.84-1.503 0-2.484.182-3.152.85v.02a1.583 1.583 0 0 0 0 2.248l1.867 1.882-3.181 3.18c-.26.26-.28.696-.02.956.261.26.699.26.959 0l3.193-3.194 1.87 1.861a1.585 1.585 0 0 0 2.25 0h.02c.668-.667.854-1.523.854-3.144 0-1.03.212-1.758.852-2.523 1.233.361 1.95.015 2.961-.995a.68.68 0 0 0 .188-.48c0-.234-.06-.593-.209-1.04a5.34 5.34 0 0 0-1.312-2.103 5.35 5.35 0 0 0-2.104-1.312c-.448-.15-.808-.208-1.042-.208", kr$1 = (e3) => {
  let [t, r3] = useState(pt);
  return jsx("button", { ...e3, children: jsx("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", onMouseEnter: () => {
    r3('M10.008 1.302a.74.74 0 0 0-.486.214c-1.033.989-1.349 1.815-.972 2.948-.88.675-1.437.84-2.536.84-1.503 0-2.484.182-3.152.85v.02a1.583 1.583 0 0 0 0 2.248l1.867 1.882-3.181 3.18c-.26.26-.28.696-.02.956.261.26.699.26.959 0l3.193-3.194 1.87 1.861a1.585 1.585 0 0 0 2.25 0h.02c.668-.667.854-1.523.854-3.144 0-1.03.212-1.758.853-2.523 1.232.361 1.95.015 2.96-.995a.68.68 0 0 0 .188-.48c0-.234-.06-.593-.209-1.04a5.34 5.34 0 0 0-1.312-2.103A5.35 5.35 0 0 0 11.05 1.51c-.448-.15-.808-.208-1.042-.208m.258 1.37c.708.131 1.421.6 1.93 1.107.507.508.94 1.13 1.119 1.945-.636.61-1.026.658-1.662.323a.67.67 0 0 0-.779.117c-1.214 1.213-1.533 2.314-1.533 3.8 0 1.292-.076 1.773-.48 2.206-.113.123-.27.104-.374 0L3.799 7.486a.24.24 0 0 1-.017-.34c.239-.29.769-.515 2.226-.514 1.742.001 2.668-.448 3.812-1.52a.67.67 0 0 0 .125-.77c-.343-.686-.29-1.047.321-1.67"');
  }, onMouseLeave: () => {
    r3(pt);
  }, className: "oui-text-primary-darken ", children: jsx("path", { d: t }) }) });
}, Ar = (e3) => {
  let { type: t, symbolInfo: r3, errors: o, values: s, onFocus: n4, onBlur: p2, bbo: c2 } = e3, { t: a2 } = Z$2(), { parseErrorMsg: f2 } = Tr$1(o), d2 = c2.bboStatus === "on", _2 = t === OrderType.LIMIT ? jsxs(z$1, { direction: "column", itemAlign: "end", className: "oui-text-2xs", children: [r3.quote, jsx(z$1, { height: 20, px: 3, justify: "center", itemAlign: "center", r: "base", className: cnBase("oui-border oui-cursor-pointer oui-mt-[2px] oui-select-none", c2.bboStatus === "on" ? "oui-border-primary" : "oui-border-line-12", c2.bboStatus === "disabled" && "oui-cursor-not-allowed"), onClick: () => {
    c2.bboStatus === "disabled" ? uo$3.dialog({ title: a2("common.tips"), size: "xs", content: jsx($$4, { intensity: 54, children: a2("orderEntry.bbo.disabled.tips") }) }) : c2.toggleBBO();
  }, children: jsx($$4, { className: cnBase(c2.bboStatus === "on" && "oui-text-primary", c2.bboStatus === "off" && "oui-text-base-contrast-54", c2.bboStatus === "disabled" && "oui-text-base-contrast-20"), children: a2("orderEntry.bbo") }) })] }) : r3.quote;
  return jsxs("div", { className: "oui-space-y-1", children: [t === OrderType.STOP_LIMIT || t === OrderType.STOP_MARKET ? jsx("div", { className: "oui-group", children: jsx(ae$1, { label: a2("common.trigger"), suffix: r3.quote, error: f2("trigger_price"), id: "trigger", ref: e3.refs.triggerPriceInputRef, value: s.trigger_price, onChange: (g2) => {
    e3.onChange("trigger_price", g2);
  }, formatters: [Xr$1.dpFormatter(r3.quote_dp)], onFocus: n4(1), onBlur: p2(1) }) }) : null, t === OrderType.LIMIT || t === OrderType.STOP_LIMIT ? jsxs("div", { ref: e3.refs.priceInputContainerRef, className: "oui-relative oui-group oui-w-full", children: [jsx(ae$1, { label: a2("common.price"), suffix: _2, id: "price", value: s.price, error: f2("order_price"), ref: e3.refs.priceInputRef, onChange: (g2) => {
    e3.onChange("order_price", g2);
  }, formatters: [Xr$1.dpFormatter(r3.quote_dp)], onFocus: n4(0), onBlur: p2(0), readonly: d2, classNames: { root: cnBase(d2 && "focus-within:oui-outline-transparent "), input: cnBase(d2 && "oui-cursor-auto") } }), c2.bboStatus === "on" && jsx("div", { className: cnBase("oui-absolute oui-left-0 oui-bottom-1"), children: jsx(Qr$1, { value: c2.bboType, onChange: c2.onBBOChange, contentStyle: { width: e3.priceInputContainerWidth } }) })] }) : null, jsxs(ia$1, { cols: 2, className: "oui-space-x-1 oui-group", children: [jsx(ae$1, { label: a2("common.qty"), suffix: r3.base, id: "order_quantity_input", name: "order_quantity_input", className: "!oui-rounded-br !oui-rounded-tr", value: s.quantity, error: f2("order_quantity"), onChange: (g2) => {
    e3.onChange("order_quantity", g2);
  }, formatters: [Xr$1.dpFormatter(r3.base_dp)], onFocus: n4(2), onBlur: p2(2) }), jsx(ae$1, { label: `${a2("common.total")}`, suffix: r3.quote, id: "total", className: "!oui-rounded-bl !oui-rounded-tl", value: s.total, error: f2("total"), onChange: (g2) => {
    e3.onChange("total", g2);
  }, onFocus: n4(3), onBlur: p2(3), formatters: [Xr$1.dpFormatter(r3.quote_dp)] })] })] });
}, ae$1 = forwardRef((e3, t) => {
  var _a2, _b2, _c2, _d2;
  let { errorMsgVisible: r3 } = useContext(ne), [o, s] = useState("0");
  return jsx(So$4.tooltip, { ref: t, tooltip: r3 ? e3.error : void 0, autoComplete: "off", autoFocus: e3.autoFocus, size: "lg", placeholder: e3.readonly ? "" : o, id: e3.id, name: e3.name, color: e3.error ? "danger" : void 0, prefix: jsx(Vr$1, { id: e3.id, children: e3.label }), suffix: e3.suffix, value: e3.readonly ? "" : e3.value || "", onValueChange: e3.onChange, onFocus: (n4) => {
    var _a3;
    s(""), (_a3 = e3.onFocus) == null ? void 0 : _a3.call(e3, n4);
  }, onBlur: (n4) => {
    var _a3;
    s("0"), (_a3 = e3.onBlur) == null ? void 0 : _a3.call(e3, n4);
  }, formatters: [...e3.formatters ?? [], Xr$1.numberFormatter, Xr$1.currencyFormatter, Xr$1.decimalPointFormatter], classNames: { root: cnBase("orderly-order-entry oui-relative oui-pt-8 oui-h-[54px] oui-px-2 oui-py-1 oui-pr-2 oui-border oui-border-solid oui-border-line oui-rounded group-first:oui-rounded-t-xl group-last:oui-rounded-b-xl", e3.className, (_a2 = e3.classNames) == null ? void 0 : _a2.root), input: cnBase("oui-mt-5 oui-mb-1 oui-h-5", (_b2 = e3 == null ? void 0 : e3.classNames) == null ? void 0 : _b2.input), prefix: cnBase("oui-absolute oui-left-2 oui-top-[7px] oui-text-base-contrast-36", (_c2 = e3.classNames) == null ? void 0 : _c2.prefix), suffix: cnBase("oui-absolute oui-right-0 oui-top-0 oui-text-base-contrast-36 oui-text-2xs oui-justify-start oui-py-2", (_d2 = e3.classNames) == null ? void 0 : _d2.suffix) }, readOnly: e3.readonly });
});
ae$1.displayName = "CustomInput";
var Vr$1 = (e3) => jsx("label", { htmlFor: e3.id, className: "oui-absolute oui-left-2 oui-top-[7px] oui-text-base-contrast-36 oui-text-2xs", children: e3.children }), qr$1 = (e3) => {
  let { canTrade: t } = e3, { t: r3 } = Z$2(), o = useMemo(() => t ? e3.side === OrderSide.BUY ? "buy" : "sell" : void 0, [e3.side, t]), s = useMemo(() => e3.side === OrderSide.BUY ? r3("orderEntry.maxBuy") : r3("orderEntry.maxSell"), [e3.side, r3]);
  return jsxs("div", { children: [jsx(Bl.single, { disabled: e3.maxQty === 0 || !t, value: e3.value, color: o, markCount: 4, showTip: true, max: e3.maxQty, step: e3.tick, onValueChange: e3.onValueChange }), jsxs(z$1, { justify: "between", className: "oui-pt-1 xl:oui-pt-2", children: [jsx($$4.numeral, { rule: "percentages", size: "2xs", color: o, dp: 2, padding: false, children: t ? e3.currentQtyPercentage : 0 }), jsxs(z$1, { children: [jsx("button", { className: na$1({ size: "2xs", className: "oui-mr-1" }), onClick: () => e3.setMaxQty(), "data-testid": "oui-testid-orderEntry-maxQty-value-button", children: s }), jsx($$4.numeral, { size: "2xs", color: o, dp: e3.dp, padding: false, "data-testid": "oui-testid-orderEntry-maxQty-value", children: t ? e3.maxQty : 0 })] })] })] });
}, Ur$1 = (e3) => {
  let { t } = Z$2(), r3 = [{ label: t("orderEntry.orderType.limitOrder"), value: OrderType.LIMIT }, { label: t("orderEntry.orderType.marketOrder"), value: OrderType.MARKET }, { label: t("orderEntry.orderType.stopLimit"), value: OrderType.STOP_LIMIT }, { label: t("orderEntry.orderType.stopMarket"), value: OrderType.STOP_MARKET }];
  return jsx(ke$2.options, { testid: "oui-testid-orderEntry-orderType-button", currentValue: e3.type, value: e3.type, options: r3, onValueChange: e3.onChange, contentProps: { className: "oui-bg-base-8 oui-w-full" }, valueFormatter: (o, s) => {
    if (!r3.find((c2) => c2.value === o)) return jsx($$4, { size: "xs", children: s.placeholder });
    let p2 = { [OrderType.LIMIT]: t("orderEntry.orderType.limit"), [OrderType.MARKET]: t("common.marketPrice"), [OrderType.STOP_LIMIT]: t("orderEntry.orderType.stopLimit"), [OrderType.STOP_MARKET]: t("orderEntry.orderType.stopMarket") }[o];
    return jsx($$4, { size: "xs", color: e3.canTrade ? e3.side === OrderSide.BUY ? "buy" : "sell" : void 0, children: p2 });
  }, size: "md" });
};
function Dr$1(e3) {
  let { canTrade: t } = e3, { t: r3 } = Z$2();
  return jsxs("div", { className: "oui-space-y-[2px] xl:oui-space-y-1", children: [jsxs(z$1, { justify: "between", children: [jsx($$4, { size: "2xs", children: r3("orderEntry.estLiqPrice") }), jsx($$4.numeral, { unit: e3.quote, size: "2xs", className: "oui-text-base-contrast-80", unitClassName: "oui-ml-1 oui-text-base-contrast-36", children: t ? e3.estLiqPrice ?? "--" : "--" })] }), jsxs(z$1, { justify: "between", children: [jsx($$4, { size: "2xs", children: r3("leverage.accountLeverage") }), jsxs(z$1, { gapX: 1, className: na$1({ size: "2xs", intensity: 80 }), children: [jsx($$4.numeral, { unit: t ? "x" : void 0, children: t ? e3.currentLeverage ?? "--" : "--" }), e3.estLeverage && jsxs(Fragment$1, { children: [jsx("svg", { width: "10", height: "10", viewBox: "0 0 10 10", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: jsx("path", { d: "M2.505 4.997c0-.23.186-.416.416-.416H6.07L4.833 3.332l.586-.585 1.964 1.95a.42.42 0 0 1 .122.3.42.42 0 0 1-.122.3l-1.964 1.95-.586-.585L6.07 5.413H2.921a.416.416 0 0 1-.416-.416", fill: "#fff", fillOpacity: ".54" }) }), jsx("span", { children: `${e3.estLeverage}x` })] })] })] })] });
}
function zr(e3) {
  let [t, r3] = useState(false);
  return jsxs(gt$2, { open: t, onOpenChange: r3, children: [jsx(En$2, { asChild: true, children: jsx("button", { "data-testid": "oui-testid-orderEntry-additional-button", onClick: () => {
    r3(true);
  }, children: jsx("svg", { width: "16", height: "16", viewBox: "0 0 16 16", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", className: "oui-fill-white/[.36] hover:oui-fill-white/80", children: jsx("path", { d: "M3.332 2.665a.667.667 0 0 0-.667.667v1.333c0 .368.299.667.667.667h1.333a.667.667 0 0 0 .667-.667V3.332a.667.667 0 0 0-.667-.667zm4 0a.667.667 0 0 0-.667.667v1.333c0 .368.299.667.667.667h1.333a.667.667 0 0 0 .667-.667V3.332a.667.667 0 0 0-.667-.667zm4 0a.667.667 0 0 0-.667.667v1.333c0 .368.299.667.667.667h1.333a.667.667 0 0 0 .667-.667V3.332a.667.667 0 0 0-.667-.667zm-8 4a.667.667 0 0 0-.667.667v1.333c0 .368.299.667.667.667h1.333a.667.667 0 0 0 .667-.667V7.332a.667.667 0 0 0-.667-.667zm4 0a.667.667 0 0 0-.667.667v1.333c0 .368.299.667.667.667h1.333a.667.667 0 0 0 .667-.667V7.332a.667.667 0 0 0-.667-.667zm4 0a.667.667 0 0 0-.667.667v1.333c0 .368.299.667.667.667h1.333a.667.667 0 0 0 .667-.667V7.332a.667.667 0 0 0-.667-.667zm-8 4a.667.667 0 0 0-.667.667v1.333c0 .368.299.667.667.667h1.333a.667.667 0 0 0 .667-.667v-1.333a.667.667 0 0 0-.667-.667zm4 0a.667.667 0 0 0-.667.667v1.333c0 .368.299.667.667.667h1.333a.667.667 0 0 0 .667-.667v-1.333a.667.667 0 0 0-.667-.667zm4 0a.667.667 0 0 0-.667.667v1.333c0 .368.299.667.667.667h1.333a.667.667 0 0 0 .667-.667v-1.333a.667.667 0 0 0-.667-.667z" }) }) }) }), jsx(vo$6, { side: "top", align: "end", className: "oui-w-[230px]", children: jsx(ge2, { ...e3 }) })] });
}
var Qr$1 = (e3) => {
  let { t } = Z$2(), r3 = [{ label: t("orderEntry.bbo.counterparty1"), value: BBOOrderType.COUNTERPARTY1 }, { label: t("orderEntry.bbo.counterparty5"), value: BBOOrderType.COUNTERPARTY5 }, { label: t("orderEntry.bbo.queue1"), value: BBOOrderType.QUEUE1 }, { label: t("orderEntry.bbo.queue5"), value: BBOOrderType.QUEUE5 }];
  return jsx(ke$2.options, { testid: "oui-testid-orderEntry-bbo-orderType-button", currentValue: e3.value, value: e3.value, options: r3, onValueChange: e3.onChange, contentProps: { className: "oui-bg-base-8 oui-w-full", style: e3.contentStyle }, size: "sm", classNames: { trigger: "oui-border-none oui-bg-transparent" }, valueFormatter: (o, s) => {
    let n4 = r3.find((p2) => p2.value === o);
    return jsx(_$1, { children: jsx($$4, { size: "sm", children: n4 == null ? void 0 : n4.label }) });
  } });
};
var Tt$2 = (e3) => {
  let [t, r3] = useLocalStorage("orderly-order-entry-order-type", OrderType.LIMIT), [o, s] = useLocalStorage("orderly-order-entry-order-side", OrderSide.BUY), [n4, p2] = useLocalStorage("orderly_order_bbo_type", void 0), c2 = useRef(n4), { formattedOrder: a2, setValue: f2, setValues: d2, symbolInfo: _2, ...g2 } = useOrderEntry2(e3.symbol, { initialOrder: { symbol: e3.symbol, order_type: t, side: o } }), [v2, T2] = useLocalStorage("orderly-order-entry-tp_sl-switch", false), { state: h2 } = useAccount(), { wrongNetwork: A2, disabledConnect: V2 } = L$4(), Q2 = useMemo(() => !A2 && !V2 && (h2.status === AccountStatusEnum.EnableTrading || h2.status === AccountStatusEnum.EnableTradingWithoutConnected), [h2.status, A2, V2]), { currentLeverage: R2 } = useMarginRatio(), U3 = useEventEmitter(), l2 = useRef(4), w5 = useRef(null), G2 = useRef(null), $2 = useRef(null), [de2, Oe2] = useState(0), Ee2 = useMemo(() => Number(a2.order_quantity) >= Number(g2.maxQty) ? 1 : or$2(Number(a2.order_quantity ?? 0), 0, g2.maxQty) / 100, [a2.order_quantity, g2.maxQty]), m2 = () => {
    if (_2.base_tick < 1) return;
    let u2 = utils_exports.formatNumber(a2 == null ? void 0 : a2.order_quantity, new g$6((_2 == null ? void 0 : _2.base_tick) || "0").toNumber());
    f2("order_quantity", u2, { shouldUpdateLastChangedField: false });
  }, H2 = (u2) => (b2) => {
    l2.current = u2;
  }, Ae2 = (u2) => (b2) => {
    setTimeout(() => {
      l2.current === u2 && (l2.current = 4);
    }, 300), u2 === 2 && m2();
  };
  useEffect(() => {
    let u2 = (b2) => {
      if (l2.current === 1) (a2.order_type === OrderType.STOP_LIMIT || a2.order_type === OrderType.STOP_MARKET) && (f2("trigger_price", O$9(b2[0])), Y2(w5.current));
      else if (a2.order_type === OrderType.STOP_LIMIT || a2.order_type === OrderType.LIMIT) f2("order_price", O$9(b2[0])), Y2(G2.current);
      else {
        let L2;
        a2.order_type === OrderType.STOP_MARKET ? (f2("trigger_price", O$9(b2[0])), Y2(w5.current), L2 = OrderType.STOP_LIMIT) : a2.order_type === OrderType.MARKET && (L2 = OrderType.LIMIT), typeof L2 < "u" && f2("order_type", L2), f2("order_price", O$9(b2[0])), Y2(G2.current);
      }
      function Y2(L2) {
        setTimeout(() => {
          L2 == null ? void 0 : L2.focus();
        }, 0);
      }
    };
    return U3.on("orderbook:item:click", u2), () => {
      U3.off("orderbook:item:click", u2);
    };
  }, [a2, _2]);
  let le2 = () => {
    d2({ tp_trigger_price: "", sl_trigger_price: "" });
  }, _t2 = () => {
    d2({ order_type_ext: void 0 });
  }, ht2 = () => {
    f2("order_quantity", g2.maxQty);
  }, Ot2 = (u2, b2, Y2) => {
    if (u2 === "order_type" && r3(b2), u2 === "side" && s(b2), u2 === "reduce_only" && b2 || u2 === "order_type" && (b2 === OrderType.STOP_LIMIT || b2 === OrderType.STOP_MARKET)) {
      let L2 = { tp_trigger_price: "", sl_trigger_price: "", [u2]: b2 };
      u2 === "order_type" && (L2.order_type_ext = ""), d2(L2);
      return;
    }
    if (u2 === "order_type" && b2 !== OrderType.LIMIT) {
      let L2 = { level: void 0, order_type_ext: void 0, [u2]: b2 };
      d2(L2);
      return;
    }
    f2(u2, b2, Y2);
  }, Et2 = (u2) => {
    T2(u2), u2 ? _t2() : le2();
  }, oe2 = useMemo(() => v2 || [OrderType.POST_ONLY, OrderType.IOC, OrderType.FOK].includes(a2.order_type_ext) ? "disabled" : n4 && a2.order_type === OrderType.LIMIT ? "on" : "off", [n4, v2, a2.order_type, a2.order_type_ext]), Pt2 = () => {
    n4 ? (p2(void 0), d2({ order_type_ext: void 0, level: void 0 })) : p2(c2.current || BBOOrderType.COUNTERPARTY1);
  }, vt2 = (u2) => {
    p2(u2), c2.current = u2;
  };
  return useEffect(() => {
    if (oe2 === "disabled") {
      let { order_type_ext: u2 } = a2;
      d2({ order_type_ext: ye$1({ order_type_ext: u2 }) ? void 0 : u2, level: void 0 });
    }
  }, [oe2, a2.order_type_ext]), useEffect(() => {
    if (oe2 === "on") {
      let u2 = tt(n4, a2.side), b2 = rt$1(n4);
      d2({ order_type_ext: u2, level: b2 });
    }
  }, [n4, oe2, a2.side]), useEffect(() => {
    let u2 = $2.current;
    if (!u2) return;
    let b2 = new ResizeObserver((Y2) => {
      for (let L2 of Y2) {
        let Ve3 = L2.contentRect.width;
        Ve3 && Oe2(Ve3);
      }
    });
    return b2.observe(u2), () => {
      b2.unobserve(u2);
    };
  }, [$2, a2.order_type_ext]), { ...g2, currentQtyPercentage: Ee2, side: a2.side, type: a2.order_type, level: a2.level, setOrderValue: Ot2, setOrderValues: d2, currentLeverage: R2, formattedOrder: a2, tpslSwitch: v2, setTpslSwitch: Et2, setMaxQty: ht2, symbolInfo: _2, onFocus: H2, onBlur: Ae2, refs: { triggerPriceInputRef: w5, priceInputRef: G2, priceInputContainerRef: $2 }, canTrade: Q2, bboStatus: oe2, bboType: n4, onBBOChange: vt2, toggleBBO: Pt2, priceInputContainerWidth: de2 };
};
var ro$2 = (e3) => {
  let t = Tt$2(e3);
  return jsx(Re$1, { ...t, containerRef: e3.containerRef });
};
var No = createContext({}), A = (e3) => {
  let [t, o] = useState(""), s = useCallback(() => {
    o("");
  }, []);
  return jsx(No.Provider, { value: { searchValue: t, onSearchValueChange: o, clearSearchValue: s, symbol: e3.symbol, onSymbolChange: e3.onSymbolChange }, children: e3.children });
};
function d() {
  return useContext(No);
}
var Po = (e3) => jsxs("svg", { width: "16", height: "16", viewBox: "0 0 16 16", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...e3, children: [jsx("mask", { id: "a", style: { maskType: "alpha" }, maskUnits: "userSpaceOnUse", x: "0", y: "0", width: "16", height: "16", children: jsx("path", { fill: "#D9D9D9", d: "M0 0h16v16H0z" }) }), jsx("g", { mask: "url(#a)", children: jsx("path", { d: "M3.333 12.667h.95L10.8 6.15l-.95-.95-6.517 6.517zM2.667 14a.65.65 0 0 1-.475-.192.65.65 0 0 1-.192-.475v-1.616a1.32 1.32 0 0 1 .383-.934l8.417-8.4q.2-.183.442-.283.24-.1.508-.1.267 0 .517.1.249.1.433.3l.917.933q.2.184.291.434a1.44 1.44 0 0 1 0 1.008 1.25 1.25 0 0 1-.291.442l-8.4 8.4a1.32 1.32 0 0 1-.933.383zm7.65-8.317L9.85 5.2l.95.95z" }) })] }), Io$1 = (e3) => jsx("svg", { width: "16", height: "16", viewBox: "0 0 16 16", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...e3, children: jsx("path", { d: "M7.205 1.334c-.345 0-.674.136-.918.38L6.001 2H2.667a.667.667 0 1 0 0 1.334h10.667a.667.667 0 1 0 0-1.334h-3.333l-.287-.286a1.3 1.3 0 0 0-.918-.38zM2.911 4.667l1.018 8.842c.088.66.656 1.158 1.322 1.158h5.498c.666 0 1.235-.497 1.323-1.163l1.019-8.837z" }) }), Lo = (e3) => jsxs("svg", { width: "12", height: "12", viewBox: "0 0 12 12", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...e3, children: [jsx("mask", { id: "a", style: { maskType: "alpha" }, maskUnits: "userSpaceOnUse", x: "0", y: "0", width: "12", height: "12", children: jsx("path", { fill: "#D9D9D9", d: "M0 0h12v12H0z" }) }), jsx("g", { mask: "url(#a)", children: jsx("path", { d: "M8.5 10a.48.48 0 0 1-.356-.144A.48.48 0 0 1 8 9.5V7q0-.213.144-.356A.48.48 0 0 1 8.5 6.5h1q.212 0 .356.144A.48.48 0 0 1 10 7v2.5q0 .212-.144.356A.48.48 0 0 1 9.5 10zm-3 0a.48.48 0 0 1-.356-.144A.48.48 0 0 1 5 9.5v-7q0-.212.144-.356A.48.48 0 0 1 5.5 2h1q.213 0 .356.144A.48.48 0 0 1 7 2.5v7q0 .212-.144.356A.48.48 0 0 1 6.5 10zm-3 0a.48.48 0 0 1-.356-.144A.48.48 0 0 1 2 9.5V5q0-.213.144-.356A.48.48 0 0 1 2.5 4.5h1q.212 0 .356.144A.48.48 0 0 1 4 5v4.5q0 .212-.144.356A.48.48 0 0 1 3.5 10z" }) })] }), Do = (e3) => jsx("svg", { width: "12", height: "12", viewBox: "0 0 12 12", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...e3, children: jsx("path", { d: "M5.993.958a.416.416 0 0 0-.41.422v.416a.416.416 0 1 0 .832 0V1.38a.416.416 0 0 0-.422-.422M2.749 2.29a.416.416 0 0 0-.29.714l.291.292a.416.416 0 1 0 .589-.588l-.292-.292a.42.42 0 0 0-.298-.126m6.489 0a.42.42 0 0 0-.286.126l-.292.292a.416.416 0 1 0 .588.588l.292-.292a.416.416 0 0 0-.302-.714m-3.239.753a2.895 2.895 0 0 0-2.913 2.914A2.86 2.86 0 0 0 4.751 8.58v1.123c0 .458.374.833.832.833h.832a.835.835 0 0 0 .833-.833V8.58a2.86 2.86 0 0 0 1.665-2.622 2.895 2.895 0 0 0-2.914-2.914M1.421 5.541a.416.416 0 1 0 0 .833h.417a.416.416 0 1 0 0-.833zm8.74 0a.416.416 0 1 0 0 .833h.416a.417.417 0 1 0 0-.833zM3.037 8.492a.42.42 0 0 0-.287.126l-.291.292a.416.416 0 1 0 .588.588l.292-.292a.416.416 0 0 0-.302-.714m5.913 0a.416.416 0 0 0-.29.714l.292.292a.416.416 0 1 0 .588-.588l-.292-.292a.42.42 0 0 0-.298-.126" }) }), te = (e3) => jsxs("svg", { width: "20", height: "21", viewBox: "0 0 20 21", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...e3, children: [jsx("mask", { id: "a", style: { maskType: "alpha" }, maskUnits: "userSpaceOnUse", x: "0", y: "0", width: "20", height: "21", children: jsx("path", { fill: "#D9D9D9", d: "M0 .5h20v20H0z" }) }), jsx("g", { mask: "url(#a)", children: jsx("path", { d: "m10 14.074-3.2 1.913a.6.6 0 0 1-.332.068.6.6 0 0 1-.277-.101.5.5 0 0 1-.186-.256.5.5 0 0 1-.005-.336l.84-3.556-2.82-2.394a.5.5 0 0 1-.174-.281.6.6 0 0 1 .013-.315.5.5 0 0 1 .173-.252.55.55 0 0 1 .305-.112l3.693-.33 1.467-3.393a.57.57 0 0 1 .211-.255A.54.54 0 0 1 10 4.39q.16 0 .292.083.131.082.211.255l1.467 3.414 3.693.309q.178.014.305.123.126.11.173.262t.002.304a.56.56 0 0 1-.183.27l-2.8 2.395.84 3.556a.5.5 0 0 1-.005.336.5.5 0 0 1-.186.256.6.6 0 0 1-.277.101.6.6 0 0 1-.332-.068z" }) })] }), Be$1 = (e3) => jsxs("svg", { width: "20", height: "21", viewBox: "0 0 20 21", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...e3, children: [jsx("mask", { id: "a", style: { maskType: "alpha" }, maskUnits: "userSpaceOnUse", x: "0", y: "0", width: "20", height: "21", children: jsx("path", { fill: "#D9D9D9", d: "M0 .5h20v20H0z" }) }), jsx("g", { mask: "url(#a)", children: jsx("path", { d: "M7.333 14.396 10 12.813l2.688 1.583-.709-3 2.313-1.98-3.063-.27L10 6.292 8.77 9.146l-3.062.27 2.334 1.98zM10 14.074l-3.2 1.913a.6.6 0 0 1-.332.068.6.6 0 0 1-.277-.101.5.5 0 0 1-.186-.256.5.5 0 0 1-.005-.336l.84-3.556-2.82-2.394a.5.5 0 0 1-.174-.281.6.6 0 0 1 .013-.315.5.5 0 0 1 .173-.252.55.55 0 0 1 .305-.112l3.693-.33 1.467-3.393a.57.57 0 0 1 .211-.255A.54.54 0 0 1 10 4.39q.16 0 .292.083.131.082.211.255l1.467 3.414 3.693.309q.178.014.305.123.126.11.173.262t.002.304a.56.56 0 0 1-.183.27l-2.8 2.395.84 3.556a.5.5 0 0 1-.005.336.5.5 0 0 1-.186.256.6.6 0 0 1-.277.101.6.6 0 0 1-.332-.068z" }) })] });
var K = (e3) => jsx("svg", { width: "14", height: "14", viewBox: "0 0 14 14", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...e3, children: jsx("path", { d: "M5.841 1.14a4.667 4.667 0 0 0 0 9.333 4.74 4.74 0 0 0 2.875-.975l2.54 2.56a.6.6 0 0 0 .838 0 .6.6 0 0 0 0-.838L9.537 8.677a4.72 4.72 0 0 0 .971-2.871 4.667 4.667 0 0 0-4.667-4.667m0 1.166a3.5 3.5 0 1 1 0 7 3.5 3.5 0 0 1 0-7" }) }), Ro$1 = (e3) => jsx("svg", { width: "20", height: "21", viewBox: "0 0 20 21", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...e3, children: jsx("path", { d: "M10 5.5a.76.76 0 0 0-.583.25l-4.334 4c0 .083-.083.25-.083.333 0 .25.167.417.417.417h2.916v6.667c0 .416.334.833.834.833h1.666c.5 0 .834-.417.834-.833V10.5h2.916c.25 0 .417-.167.417-.417 0-.083-.083-.25-.083-.333l-4.25-4.084c-.25-.083-.417-.166-.667-.166M2.177 3.06A.8.8 0 0 1 2.5 3h15a.834.834 0 1 1 0 1.667h-15a.833.833 0 0 1-.323-1.607" }) }), ue2 = (e3) => jsx("svg", { width: "12", height: "13", viewBox: "0 0 12 13", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...e3, children: jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M6.015.34h-.029a5.98 5.98 0 0 0-3.93 1.477c-.074.065-.027.184.072.184h7.745c.099 0 .146-.119.072-.184A5.98 5.98 0 0 0 6.015.341M3.48 7.866a.23.23 0 0 1 .187.1A2.85 2.85 0 0 0 6 9.178a2.85 2.85 0 0 0 2.334-1.213.23.23 0 0 1 .186-.1h3.104c.09 0 .155.086.13.172A6 6 0 0 1 6 12.327a6 6 0 0 1-5.755-4.29.134.134 0 0 1 .13-.172zM8.26 4.6a.29.29 0 0 0 .229.116h3.11c.09 0 .156-.086.13-.173a6 6 0 0 0-1.106-2.03.22.22 0 0 0-.165-.077H1.543a.22.22 0 0 0-.165.077 6 6 0 0 0-1.105 2.03.134.134 0 0 0 .13.173h3.11A.29.29 0 0 0 3.74 4.6 2.85 2.85 0 0 1 6 3.488c.92 0 1.738.436 2.26 1.112m.414 2.717c-.02.055.02.115.079.115h3.033a.135.135 0 0 0 .133-.112 6 6 0 0 0-.015-2.058.135.135 0 0 0-.133-.11H8.72c-.06 0-.1.061-.078.117a2.83 2.83 0 0 1 .032 2.048m-5.427.115c.06 0 .1-.06.079-.115a2.84 2.84 0 0 1 .032-2.048.085.085 0 0 0-.078-.118H.23a.135.135 0 0 0-.134.11A6 6 0 0 0 .08 7.32c.01.065.067.112.133.112z" }) }), ve3 = (e3) => jsx("svg", { width: "12", height: "13", viewBox: "0 0 12 13", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...e3, children: jsx("path", { d: "M6.012 1.72c-.286 0-.577.178-.75.532L4.2 4.438l-2.42.344c-.78.108-1.03.872-.47 1.42l1.75 1.703-.407 2.39c-.133.773.508 1.24 1.203.874.268-.142 1.648-.857 2.155-1.124l2.155 1.124c.695.367 1.339-.1 1.202-.874l-.421-2.39 1.749-1.702c.565-.547.326-1.31-.453-1.421l-2.436-.344L6.76 2.252c-.172-.354-.464-.531-.75-.531" }) }), Se2 = (e3) => jsx("svg", { width: "12", height: "13", viewBox: "0 0 12 13", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...e3, children: jsx("path", { d: "M6.012 1.72c-.286 0-.577.178-.75.532L4.2 4.438l-2.42.344c-.78.108-1.03.872-.47 1.42l1.75 1.703-.407 2.39c-.133.773.508 1.24 1.203.874.268-.142 1.648-.857 2.155-1.124l2.155 1.124c.695.367 1.339-.1 1.202-.874l-.421-2.39 1.749-1.702c.565-.547.326-1.31-.453-1.421l-2.436-.344L6.76 2.252c-.172-.354-.464-.531-.75-.531m0 1.297 1.03 2.108c.073.15.211.242.375.266l2.343.343-1.702 1.64a.48.48 0 0 0-.14.437l.405 2.312L6.246 9.03a.5.5 0 0 0-.468 0L3.7 10.123l.39-2.296a.52.52 0 0 0-.14-.453l-1.687-1.64 2.327-.328a.52.52 0 0 0 .39-.28z" }) }), ye2 = (e3) => jsx("svg", { width: "16", height: "17", viewBox: "0 0 16 17", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...e3, children: jsx("path", { d: "M2.01 2.915a.667.667 0 1 0 0 1.334h12a.667.667 0 0 0 0-1.334zM7.343 13.59a.667.667 0 0 0 1.333 0V7.88l2 1.98.937-.938L8.49 5.777a.686.686 0 0 0-.959 0L4.405 8.923l.938.937 2-1.979z" }) }), we = (e3) => jsx("svg", { width: "16", height: "17", viewBox: "0 0 16 17", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...e3, children: jsx("path", { d: "M4.67 2.203A2.667 2.667 0 0 0 2.005 4.87v6.667a2.667 2.667 0 0 0 2.667 2.666h6.666a2.667 2.667 0 0 0 2.667-2.666V4.87a2.667 2.667 0 0 0-2.667-2.667zm1.334 3.334c.17 0 .349.057.48.187l1.52 1.52 1.52-1.52a.68.68 0 0 1 .48-.187c.17 0 .349.057.48.187.26.26.26.698 0 .959l-1.521 1.52 1.52 1.52c.26.262.26.699 0 .96a.687.687 0 0 1-.958 0L8.004 9.162l-1.52 1.52a.687.687 0 0 1-.96 0 .687.687 0 0 1 0-.958l1.521-1.52-1.52-1.521a.687.687 0 0 1 0-.96.68.68 0 0 1 .479-.186" }) }), Oo = (e3) => jsxs("svg", { width: "16", height: "16", viewBox: "0 0 16 16", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...e3, children: [jsx("mask", { id: "a", style: { maskType: "alpha" }, maskUnits: "userSpaceOnUse", x: "0", y: "0", width: "16", height: "16", children: jsx("path", { d: "M0 0h16v16H0z" }) }), jsx("g", { mask: "url(#a)", children: jsx("path", { d: "M7.333 8.667h-4V7.333h4v-4h1.333v4h4v1.334h-4v4H7.333z" }) })] }), Bo = (e3) => jsxs("svg", { xmlns: "http://www.w3.org/2000/svg", width: "12", height: "12", viewBox: "0 0 12 12", fill: "none", children: [jsx("path", { d: "M5.99536 1.46487C5.71936 1.46487 5.49536 1.68887 5.49536 1.96487V5.46487H1.99536C1.71936 5.46487 1.49536 5.68887 1.49536 5.96487C1.49536 6.24087 1.71936 6.46487 1.99536 6.46487H5.49536V9.96487C5.49536 10.2409 5.71936 10.4649 5.99536 10.4649C6.27136 10.4649 6.49536 10.2409 6.49536 9.96487V6.46487H9.99536C10.2714 6.46487 10.4954 6.24087 10.4954 5.96487C10.4954 5.68887 10.2714 5.46487 9.99536 5.46487H6.49536V1.96487C6.49536 1.68887 6.27136 1.46487 5.99536 1.46487Z", fill: "url(#paint0_linear_1951_55156)" }), jsx("defs", { children: jsxs("linearGradient", { id: "paint0_linear_1951_55156", x1: "10.4954", y1: "5.96487", x2: "1.49536", y2: "5.96487", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "rgb(var(--oui-gradient-brand-end))" }), jsx("stop", { offset: "1", stopColor: "rgb(var(--oui-gradient-brand-start))" })] }) })] }), Vo$1 = (e3) => jsx("svg", { width: "16", height: "16", viewBox: "0 0 16 16", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...e3, children: jsx("path", { d: "M6.326 8.826a.84.84 0 0 0-.6.234L2.16 12.627v-2.135H.492v4.167c0 .46.373.833.834.833h4.166v-1.667H3.357l3.567-3.567a.857.857 0 0 0 0-1.198.84.84 0 0 0-.598-.234M10.502.492V2.16h2.135L9.07 5.726a.857.857 0 0 0 0 1.199.86.86 0 0 0 1.197 0l3.568-3.568v2.135h1.667V1.326a.834.834 0 0 0-.834-.834z" }) }), Wo = (e3) => jsx("svg", { width: "16", height: "16", viewBox: "0 0 16 16", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...e3, children: jsx("path", { d: "M14.668.492a.85.85 0 0 0-.599.234l-3.567 3.568V2.159H8.835v4.167c0 .46.373.833.833.833h4.167V5.492H11.7l3.569-3.567a.86.86 0 0 0 0-1.199.85.85 0 0 0-.6-.234m-12.5 8.334v1.666h2.135L.736 14.06a.86.86 0 0 0 0 1.198.86.86 0 0 0 1.198 0l3.568-3.567v2.134h1.666V9.66a.834.834 0 0 0-.833-.833z" }) }), He$1 = (e3) => jsx("svg", { width: "12", height: "12", viewBox: "0 0 12 12", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...e3, children: jsx("path", { d: "M3.003 3.998a.494.494 0 0 0-.39.797l3 4c.2.266.597.266.797 0l3-4a.5.5 0 0 0-.407-.797z" }) }), Uo$1 = (e3) => jsx("svg", { width: "16", height: "16", viewBox: "0 0 16 16", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...e3, children: jsx("path", { d: "M9.186 3.348a.67.67 0 0 0-.436.27l-2.657 4a.69.69 0 0 0 0 .75l2.657 4a.68.68 0 0 0 .934.188.685.685 0 0 0 .187-.937L7.463 7.993 9.87 4.37a.685.685 0 0 0-.187-.938.65.65 0 0 0-.498-.083" }) });
var yt = (e3) => {
  let { emblaRef: t, emblaApi: o, scrollIndex: s, enableScroll: r3, news: a2, gainers: i, losers: n4, total24Amount: l2, totalOpenInterest: u2, tvl: m2, favorite: c2 } = e3, { onSymbolChange: f2 } = d(), { t: b2 } = Z$2(), p2 = cnBase("oui-flex-[0_0_calc((100%_-_32px)_/_3)] 3xl:oui-flex-[0_0_calc((100%_-_48px)_/_4)] oui-min-w-0", r3 && "oui-select-none oui-cursor-pointer"), x2 = (y2) => {
    f2 == null ? void 0 : f2(y2), c2.addToHistory(y2);
  };
  return jsxs("div", { id: "oui-markets-header", className: "oui-overflow-hidden", ref: r3 ? t : void 0, children: [jsxs(z$1, { width: "100%", gapX: 4, mt: 4, children: [jsx(Yr, { total24Amount: l2, totalOpenInterest: u2, tvl: m2, className: p2 }), jsx(vt, { data: a2, title: jsx($$4.gradient, { color: "brand", children: b2("markets.newListings") }), className: p2, onSymbol: x2 }), jsx(vt, { data: i, title: jsx($$4, { className: "oui-text-success-light", children: b2("markets.topGainers") }), className: p2, onSymbol: x2 }), jsx(vt, { data: n4, title: jsx($$4, { className: "oui-text-danger-light", children: b2("markets.topLosers") }), className: p2, onSymbol: x2 })] }), jsx("div", { className: "oui-mt-1 oui-mb-3  3xl:oui-mt-4 3xl:oui-mb-0", children: jsx(Jr$1, { scrollIndex: s, scrollPrev: o == null ? void 0 : o.scrollPrev, scrollNext: o == null ? void 0 : o.scrollNext }) })] });
}, Yr = (e3) => {
  let { total24Amount: t, totalOpenInterest: o, tvl: s } = e3, { t: r3 } = Z$2(), a2 = useMemo(() => [{ label: jsxs(z$1, { gapX: 1, children: [jsx(ue2, {}), " ", r3("markets.column.24hVolume")] }), value: t }, { label: jsxs(z$1, { gapX: 1, children: [jsx(ue2, {}), " ", r3("markets.openInterest")] }), value: o }, { label: jsxs(z$1, { gapX: 1, children: [jsx(ue2, {}), " ", `${r3("common.assets")} (TVL)`] }), value: s }], [t, o, s]);
  return jsx(z$1, { direction: "column", justify: "between", width: "100%", height: 236, className: e3.className, children: a2 == null ? void 0 : a2.map((i, n4) => jsx(Qr, { ...i }, n4)) });
}, Qr = (e3) => jsxs(_$1, { intensity: 900, r: "lg", px: 4, py: 3, width: "100%", children: [jsx($$4, { as: "div", intensity: 36, size: "xs", weight: "semibold", children: e3.label }), jsx($$4.numeral, { size: "base", currency: "$", dp: e3.dp || 0, rm: g$6.ROUND_DOWN, rule: e3.rule, children: e3.value })] }), vt = (e3) => {
  var _a2;
  return jsxs(_$1, { intensity: 900, r: "lg", py: 4, pb: 2, height: 236, className: e3.className, children: [jsx(_$1, { px: 4, children: jsx($$4.gradient, { color: "brand", size: "sm", weight: "semibold", children: e3.title }) }), jsx(z$1, { direction: "column", itemAlign: "start", mt: 2, children: (_a2 = e3.data) == null ? void 0 : _a2.map((t, o) => jsx(Zr, { item: t, onSymbol: e3.onSymbol }, t.symbol)) })] });
}, Zr = (e3) => {
  let { item: t } = e3;
  return jsxs(z$1, { width: "100%", gapX: 3, py: 2, px: 4, className: cnBase("hover:oui-bg-base-8 oui-cursor-pointer", e3.className), onClick: () => {
    e3.onSymbol(t);
  }, children: [jsx(z$1, { width: "100%", gapX: 1, children: jsx($$4.formatted, { rule: "symbol", formatString: "base", size: "xs", weight: "semibold", showIcon: true, children: t.symbol }) }), jsx(z$1, { width: "100%", justify: "end", children: jsx($$4.numeral, { currency: "$", size: "xs", weight: "semibold", dp: t.quote_dp, children: t["24h_close"] }) }), jsx(z$1, { width: "100%", justify: "end", children: jsx($$4.numeral, { rule: "percentages", coloring: true, size: "xs", weight: "semibold", showIdentifier: true, children: t.change }) })] });
}, Jr$1 = (e3) => {
  let { scrollIndex: t, scrollPrev: o, scrollNext: s } = e3;
  return jsx(z$1, { gapX: 1, justify: "center", className: "3xl:oui-hidden", children: [0, 1].map((r3) => jsx(_$1, { py: 1, pl: r3 === 0 ? 1 : 0, pr: r3 === 1 ? 1 : 0, onClick: () => {
    t === 0 && r3 === 1 ? s == null ? void 0 : s() : t === 1 && r3 === 0 && (o == null ? void 0 : o());
  }, className: "oui-cursor-pointer", children: jsx(_$1, { width: 8, height: 4, r: "full", className: cnBase("oui-transition-all oui-duration-300", t === r3 ? "oui-bg-base-contrast-36 oui-w-4" : "oui-bg-base-contrast-20") }, r3) }, r3)) });
};
function We$1(e3, t, o) {
  let s = [...e3 || []], r3 = (a2) => a2 == null;
  return t && o && s.sort((a2, i) => {
    let n4 = a2[t], l2 = i[t];
    return r3(n4) ? 1 : r3(l2) ? -1 : o === "desc" ? l2 - n4 : n4 - l2;
  }), s;
}
function I$1(e3, t, o) {
  let [s, r3] = useState(), [a2, i] = useState(), n4 = useCallback((c2) => {
    r3(c2 == null ? void 0 : c2.sortKey), i(c2 == null ? void 0 : c2.sort), o == null ? void 0 : o(c2 == null ? void 0 : c2.sortKey, c2 == null ? void 0 : c2.sort);
  }, [o]), l2 = s || e3, u2 = a2 || t, m2 = useCallback((c2) => We$1(c2, l2, u2), [l2, u2]);
  return { onSort: n4, getSortedList: m2, sortKey: l2, sortOrder: u2 };
}
function L(e3, t = "", o) {
  let s = new RegExp(t, "i");
  return e3 == null ? void 0 : e3.filter((r3) => s.test(es(r3.symbol, o)));
}
function es(e3, t = "base") {
  let o = e3.split("_"), s = o[0], r3 = o[1], a2 = o[2];
  return t.replace("type", s).replace("base", r3).replace("quote", a2);
}
function Ao$1() {
  let [e3, t] = useState(0), [o, s] = useState(0);
  return useEffect(() => {
    t(window.innerWidth), s(window.innerHeight);
    let r3 = () => {
      s(window.innerHeight), t(window.innerWidth);
    };
    return window == null ? void 0 : window.addEventListener("resize", r3), () => {
      window == null ? void 0 : window.removeEventListener("resize", r3);
    };
  }, []), { width: e3, height: o };
}
var wt$1 = () => {
  let [e3, t] = useState(0), o = is(), { width: s } = Ao$1(), [r3, a2] = nt$4({ loop: true, slidesToScroll: "auto" });
  return useEffect(() => {
    a2 == null ? void 0 : a2.on("select", () => {
      t(a2 == null ? void 0 : a2.selectedScrollSnap());
    });
  }, [a2]), { scrollIndex: e3, setScrollIndex: t, emblaRef: r3, emblaApi: a2, enableScroll: s < 1440, ...o };
};
function is() {
  let [e3, t] = useMarkets(MarketsType.ALL), { data: o } = useQuery("/v1/public/balance/stats"), s = useMemo(() => We$1(e3, "created_time", "desc").slice(0, 5), [e3]), r3 = useMemo(() => We$1(e3, "change", "desc").slice(0, 5), [e3]), a2 = useMemo(() => We$1(e3, "change", "asc").slice(0, 5), [e3]), i = useMemo(() => (e3 == null ? void 0 : e3.reduce((u2, m2) => u2.add(m2["24h_amount"] || 0), new g$6(0))) || new g$6(0), [e3]), n4 = useMemo(() => (e3 == null ? void 0 : e3.reduce((u2, m2) => u2.add(m2.openInterest || 0), new g$6(0))) || new g$6(0), [e3]), l2 = useMemo(() => {
    if (!o) return 0;
    let { total_holding: u2 = 0 } = o;
    return new g$6(u2).toNumber();
  }, [o]);
  return { markets: e3, news: s, gainers: r3, losers: a2, total24Amount: i.toNumber(), totalOpenInterest: n4.toNumber(), tvl: l2, favorite: t };
}
var kt = () => {
  let e3 = wt$1();
  return jsx(yt, { ...e3 });
};
var Ft = (e3) => {
  var _a2;
  let { symbol: t, favoriteTabs: o, open: s, onOpenChange: r3, inputVisible: a2, selectedTabs: i, value: n4, onValueChange: l2, hide: u2, hideInput: m2, showInput: c2, onCheck: f2, addTab: b2, confirm: p2 } = e3, { t: x2 } = Z$2(), y2 = (n4 == null ? void 0 : n4.length) > 15, w5 = () => {
    if (a2) return jsxs(_$1, { children: [jsxs(z$1, { gapX: 2, children: [jsx(So$4, { autoFocus: true, value: n4, onValueChange: l2, classNames: { root: cnBase("oui-bg-base-6 oui-h-7 oui-w-full oui-ml-[1px] oui-rounded-sm", y2 && "focus-visible:oui-outline-danger focus-within:oui-outline-danger") }, autoComplete: "off", suffix: n4 && jsx(_$1, { mr: 2, children: jsx(za, { opacity: 1, size: 14, className: "oui-text-base-contrast-20 oui-cursor-pointer", onClick: () => {
      l2("");
    } }) }) }), jsx(_e$5, { className: "oui-rounded-sm", size: "sm", onClick: b2, disabled: !n4 || y2, children: x2("common.add") })] }), y2 && jsxs(z$1, { itemAlign: "center", gapX: 1, mt: 1, children: [jsx("div", { className: "oui-h-1 oui-w-1 oui-bg-danger oui-rounded-full" }), jsx($$4, { color: "danger", children: x2("markets.favorites.tabs.maxName") })] })] });
    let k2 = o.length >= 10;
    return jsx(Xn$2, { open: k2 ? void 0 : false, content: jsx($$4, { size: "2xs", intensity: 80, children: x2("markets.favorites.tabs.maxList") }), className: "oui-bg-base-6", delayDuration: 0, arrow: { className: "oui-fill-base-6" }, children: jsx("div", { children: jsxs(z$1, { className: cnBase(k2 ? "oui-cursor-not-allowed" : "oui-cursor-pointer"), itemAlign: "center", gapX: 2, p: 2, intensity: k2 ? 500 : 600, onClick: k2 ? void 0 : c2, height: 28, r: "base", children: [jsx(ac, { size: 14, className: "oui-text-base-contrast-36", opacity: 1 }), jsx($$4, { className: "", intensity: 20, children: x2("markets.favorites.dropdown.addPlaceholder") })] }) }) });
  }, M2 = jsxs(z$1, { justify: "between", className: "oui-mt-3 oui-mb-[10px]", children: [jsxs(z$1, { gapX: 1, children: [x2("markets.favorites.dropdown.title"), jsx($$4.formatted, { rule: "symbol", formatString: "base-type", size: "base", showIcon: true, children: t })] }), jsx(ye$7, { size: 16, className: "oui-text-base-contrast oui-cursor-pointer", onClick: u2 })] }), U3 = jsxs(_$1, { children: [jsx(_$1, { my: 2, className: "oui-max-h-[288px] oui-overflow-y-auto oui-custom-scrollbar", children: (_a2 = o == null ? void 0 : o.slice(0, 10)) == null ? void 0 : _a2.map((k2) => {
    let N2 = !!i.find((Y2) => Y2.id === k2.id);
    return jsx(_$1, { className: "oui-cursor-pointer", children: jsxs(z$1, { className: "oui-gap-x-[6px] hover:oui-bg-base-6", p: 2, r: "md", onClick: () => {
      f2(k2, N2);
    }, children: [N2 ? jsx(Ea, { size: 18, className: "oui-text-base-contrast-80" }) : jsx(Va$1, { size: 18, className: "oui-text-base-contrast-80" }), jsx($$4, { intensity: 54, children: k2.name })] }) }, k2.id);
  }) }), jsx(_$1, { mt: 3, pb: 5, children: w5() })] }), W2 = jsxs(z$1, { gapX: 3, mt: 3, children: [jsx(_e$5, { color: "gray", onClick: u2, fullWidth: true, className: "oui-text-sm", size: "md", children: x2("common.cancel") }, "secondary"), jsx(_e$5, { onClick: p2, fullWidth: true, className: "oui-text-sm", size: "md", children: x2("common.confirm") }, "primary")] });
  return jsxs(Yi, { open: s, onOpenChange: r3, children: [jsx(Xi$1, { asChild: true, children: e3.children }), jsx(ji, { children: jsx(rr$2, { onCloseAutoFocus: (k2) => k2.preventDefault(), onClick: (k2) => k2.stopPropagation(), align: "start", alignOffset: -12, sideOffset: 24, className: "oui-markets-favorite-dropdown-menu-content oui-bg-base-8", children: jsx(_$1, { px: 5, pb: 5, width: 360, children: jsxs($$4, { as: "div", size: "sm", weight: "semibold", children: [M2, jsx(te$6, {}), U3, W2] }) }) }) })] });
};
function Mt(e3) {
  let { symbol: t } = e3.row || {}, { favorites: o, favoriteTabs: s, updateFavoriteTabs: r3, updateSymbolFavoriteState: a2 } = e3.favorite, [i, n4] = useState(false), [l2, u2] = useState(false), [m2, c2] = useState(""), [f2, b2] = useState([]), p2 = () => {
    n4(false);
  }, x2 = () => {
    u2(true);
  }, y2 = () => {
    u2(false);
  }, w5 = () => {
    c2(""), y2(), b2([]);
  }, M2 = () => {
    let k2 = { name: m2 || `WatchList_${s.length}`, id: Date.now() };
    r3(k2, { add: true }), w5();
  }, U3 = (k2, N2) => {
    b2(N2 ? f2 == null ? void 0 : f2.filter((Y2) => Y2.id !== k2.id) : [...f2, k2]), y2();
  }, W2 = () => {
    a2(e3.row, f2, false), n4(false);
  };
  return useEffect(() => {
    var _a2;
    if (!i) return;
    let k2 = o == null ? void 0 : o.find((N2) => N2.name === t);
    ((_a2 = k2 == null ? void 0 : k2.tabs) == null ? void 0 : _a2.length) && b2(k2 == null ? void 0 : k2.tabs);
  }, [i, o, s, t]), useEffect(() => {
    i || w5();
  }, [i]), { symbol: t, favoriteTabs: s, open: i, onOpenChange: n4, inputVisible: l2, selectedTabs: f2, value: m2, onValueChange: c2, hide: p2, hideInput: y2, showInput: x2, onCheck: U3, addTab: M2, confirm: W2 };
}
var J = (e3) => {
  let t = Mt(e3);
  return jsx(Ft, { ...t, children: e3.children });
};
var Ye$1 = (e3, t = false) => {
  let { t: o } = Z$2();
  return useMemo(() => [{ title: jsx(Be$1, { className: "oui-mt-1" }), dataIndex: "isFavorite", align: "center", width: 30, render: (r3, a2) => {
    let n4 = jsx(z$1, { width: "100%", height: "100%", mr: 3, justify: "center", itemAlign: "center", onClick: t ? (l2) => {
      e3.updateSymbolFavoriteState(a2, e3.selectedFavoriteTab, true), l2.stopPropagation();
    } : void 0, "data-testid": "oui-testid-markets-table-row-favorite-icon", children: r3 ? jsx(te, { className: "oui-text-[rgba(255,154,46,1)]" }) : jsx(Be$1, { className: "oui-text-base-contrast-36 hover:oui-text-[rgba(255,154,46,1)]" }) });
    return t ? n4 : jsx(J, { row: a2, favorite: e3, children: n4 });
  } }, { title: o("markets.column.market"), dataIndex: "symbol", width: 90, render: (r3) => jsx($$4.formatted, { rule: "symbol", formatString: "base-type", size: "xs", weight: "semibold", showIcon: true, children: r3 }) }, { title: o("common.price"), dataIndex: "24h_close", width: 100, align: "right", onSort: true, render: (r3, a2) => jsx($$4.numeral, { dp: a2.quote_dp || 2, currency: "$", children: r3 }) }, { title: o("markets.column.24hChange"), dataIndex: "change", width: 100, align: "right", onSort: true, render: (r3) => jsx($$4.numeral, { rule: "percentages", coloring: true, rm: g$6.ROUND_DOWN, showIdentifier: true, children: r3 }) }, { title: jsxs(z$1, { gapX: 1, children: [jsx(ue2, {}), " ", o("markets.column.24hVolume")] }), dataIndex: "24h_amount", width: 100, align: "right", onSort: true, render: (r3) => jsx($$4.numeral, { currency: "$", dp: 0, rm: g$6.ROUND_DOWN, children: r3 }) }, { title: jsxs(z$1, { gapX: 1, children: [jsx(ue2, {}), " ", o("markets.openInterest")] }), dataIndex: "openInterest", width: 100, align: "right", onSort: true, render: (r3) => jsx($$4.numeral, { currency: "$", dp: 0, rm: g$6.ROUND_DOWN, children: r3 }) }, { title: o("markets.dataList.column.8hFunding"), dataIndex: "8h_funding", width: 100, align: "right", onSort: true, render: (r3) => r3 === null ? "--" : jsx($$4.numeral, { rule: "percentages", coloring: true, dp: 4, rm: g$6.ROUND_DOWN, showIdentifier: true, children: r3 }) }, { dataIndex: "action", type: "action", width: 40, render: (r3, a2) => t ? jsx(z$1, { justify: "end", mr: 4, children: jsx(Xn$2, { content: o("markets.dataList.column.moveTop"), align: "center", delayDuration: 0, children: jsx(_$1, { className: "oui-hidden group-hover:oui-block oui-cursor-pointer", onClick: (i) => {
    i.stopPropagation(), e3.pinToTop(a2);
  }, "data-testid": "oui-markets-favorites-pinned-icon", children: jsx(Ro$1, { className: "oui-text-base-contrast-20 hover:oui-text-base-contrast" }) }) }) }) : null }], [e3, t, o]);
};
var Tt$1 = (e3) => {
  let { loading: t, dataSource: o, favorite: s, onSort: r3, initialSort: a2, type: i, pagination: n4 } = e3, { symbol: l2, onSymbolChange: u2 } = d(), m2 = Ye$1(s, false);
  return jsx(jd, { bordered: true, columns: m2, loading: t, dataSource: o, onRow: (c2, f2) => ({ className: cnBase("oui-h-[55px] oui-cursor-pointer"), onClick: () => {
    u2 == null ? void 0 : u2(c2), s.addToHistory(c2);
  }, "data-testid": `oui-testid-markets-${i === "new" ? "newListing" : "all"}-tr-${c2.symbol}` }), generatedRowKey: (c2) => c2.symbol, rowSelection: { [l2]: true }, onSort: r3, initialSort: a2, pagination: n4, classNames: { header: "oui-h-12" }, manualSorting: true });
};
var Pt$1 = (e3) => {
  let [t, o] = useState(true), { setPage: r3, pagination: a2 } = mm({ pageSize: 10 }), [i, n4] = useMarkets(MarketsType.ALL), { searchValue: l2 } = d(), { onSort: u2, getSortedList: m2, sortKey: c2, sortOrder: f2 } = I$1(e3 == null ? void 0 : e3.sortKey, e3 == null ? void 0 : e3.sortOrder), b2 = useMemo(() => {
    let p2 = m2(i);
    return L(p2, l2, "base-type");
  }, [i, m2, l2]);
  return useEffect(() => {
    o(false);
  }, [i]), useEffect(() => {
    r3(1);
  }, [l2]), useEffect(() => {
    e3.type === "all" && n4.updateTabsSortState("all", c2, f2);
  }, [c2, f2, e3.type]), { loading: t, dataSource: b2, favorite: n4, onSort: u2, pagination: a2 };
};
var Qe = (e3) => {
  var _a2;
  let t = Pt$1(e3), o = e3.type === "all" ? (_a2 = t.favorite.tabSort) == null ? void 0 : _a2.all : void 0;
  return jsx(Tt$1, { ...t, type: e3.type, initialSort: { sortKey: (o == null ? void 0 : o.sortKey) || e3.sortKey, sort: (o == null ? void 0 : o.sortOrder) || e3.sortOrder } });
};
var Dt$1 = (e3) => {
  var _a2;
  let { open: t, setOpen: o, container: s, inputRef: r3, inputWidth: a2, spanRef: i, editing: n4, value: l2, onValueChange: u2, updateCurTab: m2, onEdit: c2, addTab: f2, delTab: b2, size: p2 = "default", scrollable: x2 } = e3, { t: y2 } = Z$2(), { selectedFavoriteTab: w5, favoriteTabs: M2, updateSelectedFavoriteTab: U3 } = e3.favorite, W2 = p2 === "sm" ? 28 : 36, k2 = p2 === "sm" ? 18 : 24, N2 = (l2 == null ? void 0 : l2.length) > 15, Y2 = "oui-bg-gradient-to-r oui-from-[rgb(var(--oui-gradient-brand-start)_/_0.12)] oui-to-[rgb(var(--oui-gradient-brand-end)_/_0.12)]", ft2 = (v2) => {
    uo$3.confirm({ title: y2("markets.favorites.tabs.delete.dialog.title"), content: jsx($$4, { size: "sm", children: y2("markets.favorites.tabs.delete.dialog.description", { name: v2.name }) }), onOk() {
      return b2(v2), Promise.resolve();
    } });
  }, bt2 = (v2) => {
    v2.key === "Enter" && m2(N2);
  }, xt2 = (v2) => jsxs(z$1, { gapX: 2, itemAlign: "center", px: 2, py: 1, children: [jsx(Po, { className: "oui-text-base-contrast-36 hover:oui-text-base-contrast oui-cursor-pointer", onClick: () => {
    c2(v2);
  } }), jsx(Io$1, { className: "oui-text-base-contrast-36 hover:oui-text-base-contrast oui-cursor-pointer", onClick: () => {
    ft2(v2);
  } })] }), Ge2 = () => {
    let v2 = M2.length >= 10, O2 = jsx(z$1, { className: cnBase("oui-inline-flex", v2 ? "oui-cursor-not-allowed" : "oui-cursor-pointer", v2 ? "oui-bg-base-3" : Y2), width: W2, height: k2, r: "base", justify: "center", itemAlign: "center", onClick: v2 ? void 0 : f2, children: v2 ? jsx(Oo, { className: "oui-text-base-contrast-54 oui-w-3 oui-h-3 oui-z-[1]" }) : jsx(Bo, { className: "oui-w-3 oui-h-3" }) });
    return v2 ? jsx(Xn$2, { content: jsx($$4, { size: "2xs", intensity: 80, children: "Maximum 10 groups in the favorite list" }), className: "oui-bg-base-6", delayDuration: 0, arrow: { className: "oui-fill-base-6" }, children: O2 }) : O2;
  }, R2 = (v2) => jsx(Xn$2, { open: N2, content: jsx($$4, { size: "2xs", intensity: 80, children: "List name cannot exceed 15 characters" }), className: "oui-bg-base-6", delayDuration: 0, sideOffset: 0, children: jsx(So$4, { ref: r3, style: N2 ? { width: a2 } : { "--oui-gradient-angle": "270deg", backgroundClip: "text", WebkitTextFillColor: "transparent", WebkitBackgroundClip: "text", width: a2 }, classNames: { root: cnBase("oui-p-0 oui-rounded oui-px-2 oui-my-[1px]", "focus-visible:oui-outline-none focus-within:oui-outline-transparent", p2 === "sm" ? "oui-h-[18px]" : "oui-h-[24px]", v2 && cnBase(N2 ? "oui-bg-danger/15" : Y2)), input: cnBase("oui-font-semibold oui-caret-[rgba(217,217,217,1)]", N2 ? "oui-text-danger" : "oui-text-transparent oui-gradient-brand ", p2 === "sm" ? "oui-text-2xs" : "oui-text-sm") }, value: l2, onValueChange: u2, onBlur: () => {
    m2(N2);
  }, onKeyUp: bt2, autoComplete: "off" }) }), le2 = (v2, O2) => {
    if (n4 && O2) return R2(O2);
    let Q2 = { weight: "semibold", size: p2 === "sm" ? "2xs" : "sm", className: p2 === "sm" ? "oui-leading-[18px]" : "oui-leading-[24px]", as: "div" }, ht2 = O2 ? jsx($$4.gradient, { color: "brand", angle: 270, ...Q2, children: v2.name }) : jsx($$4, { ...Q2, children: v2.name });
    return jsx(_$1, { r: "base", px: 2, height: k2, className: cnBase("oui-cursor-pointer oui-select-none", O2 ? "oui-markets-favorites-active-tab-item" : "oui-markets-favorites-tab-item", O2 ? Y2 : "oui-bg-line-6 oui-text-base-contrast-36 hover:oui-text-base-contrast"), onClick: () => {
      U3(v2), O2 && o(true);
    }, children: ht2 });
  };
  return jsxs(z$1, { width: "100%", gapX: 3, className: e3.className, children: [jsxs(z$1, { ref: s, id: "oui-markets-favorites-tabs-container", className: cnBase("oui-relative oui-cursor-pointer oui-hide-scrollbar", "oui-overflow-hidden oui-overflow-x-auto"), gapX: p2 === "sm" ? 2 : 3, width: "100%", children: [(_a2 = M2 == null ? void 0 : M2.slice(0, 10)) == null ? void 0 : _a2.map((v2) => {
    let O2 = w5.id === v2.id;
    return jsx(Xn$2, { open: O2 && !n4 ? t : false, onOpenChange: (Q2) => {
      O2 && o(Q2);
    }, content: xt2(v2), delayDuration: 0, className: cnBase("oui-bg-base-5"), arrow: { className: "oui-fill-base-5" }, children: le2(v2, O2) }, v2.id);
  }), !x2 && Ge2(), jsx($$4, { size: "xs", ref: i, className: "oui-invisible", children: l2 })] }), x2 && Ge2()] });
};
function Ot$1(e3) {
  let { favorite: t, size: o = "default" } = e3, { favorites: s, favoriteTabs: r3, selectedFavoriteTab: a2, updateFavoriteTabs: i, updateSelectedFavoriteTab: n4, updateFavorites: l2 } = t, [u2, m2] = useState(false), [c2, f2] = useState(false), [b2, p2] = useState(""), [x2, y2] = useState(false), w5 = useRef(null), M2 = useRef(null), U3 = useRef(null), [W2, k2] = useState(50), N2 = () => {
    setTimeout(() => {
      let { scrollWidth: le2, clientWidth: v2 } = w5.current || {};
      le2 > v2 && y2(true);
    }, 0);
  }, Y2 = () => {
    setTimeout(() => {
      w5.current && (w5.current.scrollLeft = w5.current.scrollWidth - w5.current.clientWidth);
    }, 0);
  }, ft2 = (R2) => {
    f2(true), p2(R2.name), setTimeout(() => {
      var _a2, _b2;
      (_a2 = M2.current) == null ? void 0 : _a2.focus(), (_b2 = M2.current) == null ? void 0 : _b2.setSelectionRange(-1, -1);
    }, 0);
  }, bt2 = (R2) => {
    i({ ...a2, name: R2 ? a2.name : b2 }, { update: true }), f2(false), m2(false), N2();
  }, xt2 = () => {
    let R2 = { name: `WatchList_${r3.length}`, id: Date.now() };
    i(R2, { add: true }), n4(R2), N2(), Y2();
  }, Ge2 = (R2) => {
    i(R2, { delete: true }), setTimeout(() => {
      let le2 = s.map((Q2) => {
        var _a2;
        return { ...Q2, tabs: (_a2 = Q2.tabs) == null ? void 0 : _a2.filter((ht2) => ht2.id !== R2.id) };
      });
      l2(le2);
      let v2 = r3.filter((Q2) => Q2.id !== R2.id), O2 = (v2 == null ? void 0 : v2[(v2 == null ? void 0 : v2.length) - 1]) || (v2 == null ? void 0 : v2[0]);
      n4(O2);
    }, 0);
  };
  return useEffect(() => {
    var _a2;
    if (b2) {
      let R2 = (_a2 = U3.current) == null ? void 0 : _a2.getBoundingClientRect(), le2 = o === "sm" ? 0 : 14;
      k2(Math.max(((R2 == null ? void 0 : R2.width) || 0) + le2, 50));
    }
  }, [b2]), useEffect(() => {
    N2();
  }, []), { favorite: t, open: u2, setOpen: m2, container: w5, inputRef: M2, inputWidth: W2, spanRef: U3, editing: c2, value: b2, onValueChange: p2, onEdit: ft2, updateCurTab: bt2, addTab: xt2, delTab: Ge2, scrollable: x2 };
}
var ze = (e3) => {
  let { className: t, ...o } = e3, s = Ot$1(o);
  return jsx(Dt$1, { ...s, size: e3.size, className: t });
};
var Xo$1 = Ye$1;
var Bt = (e3) => {
  let { dataSource: t, favorite: o, onSort: s, loading: r3, pagination: a2 } = e3, { symbol: i, onSymbolChange: n4 } = d(), l2 = Xo$1(o, true);
  return jsxs("div", { children: [jsx(ze, { favorite: o, className: "oui-my-3" }), jsx(jd, { bordered: true, columns: l2, dataSource: t, emptyView: jsx(z$1, { className: "oui-text-xs oui-text-base-contrast-36", children: jsx(Trans, { i18nKey: "markets.dataList.favorites.empty", components: [jsx(Be$1, { className: "oui-text-base-contrast-36" })] }) }), loading: r3, onRow: (m2, c2) => ({ className: cnBase("oui-h-[55px] oui-cursor-pointer"), onClick: () => {
    n4 == null ? void 0 : n4(m2), o.addToHistory(m2);
  } }), generatedRowKey: (m2) => m2.symbol, rowSelection: { [i]: true }, onSort: s, pagination: a2, manualSorting: true })] });
};
var Vt = () => {
  let { setPage: t, pagination: o } = mm({ pageSize: 10 }), [s, r3] = useMarkets(MarketsType.FAVORITES), [a2, i] = useState(true), { favorites: n4, selectedFavoriteTab: l2 } = r3, { searchValue: u2 } = d(), { onSort: m2, getSortedList: c2 } = I$1(), f2 = useMemo(() => {
    var _a2, _b2;
    let p2 = (_b2 = (_a2 = n4 == null ? void 0 : n4.filter((x2) => {
      var _a3;
      return ((_a3 = x2.tabs) == null ? void 0 : _a3.findIndex((y2) => y2.id === l2.id)) !== -1;
    })) == null ? void 0 : _a2.map((x2) => {
      let y2 = s == null ? void 0 : s.findIndex((w5) => w5.symbol === x2.name);
      return y2 !== -1 ? s[y2] : null;
    })) == null ? void 0 : _b2.filter((x2) => x2);
    return L(p2, u2, "base-type");
  }, [s, l2, n4, u2]), b2 = useMemo(() => c2(f2), [f2, c2]);
  return useEffect(() => {
    i(false);
  }, [n4]), useEffect(() => {
    t(1);
  }, [u2]), { loading: a2, dataSource: b2, favorite: r3, onSort: m2, pagination: o };
};
var Wt = () => {
  let e3 = Vt();
  return jsx(Bt, { ...e3 });
};
var zt$1 = (e3) => {
  let { activeTab: t, onTabChange: o } = e3, { t: s } = Z$2(), { searchValue: r3, onSearchValueChange: a2, clearSearchValue: i } = d(), n4 = jsx(So$4, { value: r3, onValueChange: a2, placeholder: s("markets.search.placeholder"), className: "oui-w-[240px] oui-my-1", size: "sm", "data-testid": "oui-testid-markets-searchMarket-input", prefix: jsx(_$1, { pl: 3, pr: 1, children: jsx(K, { className: "oui-text-base-contrast-36" }) }), suffix: r3 && jsx(_$1, { mr: 2, children: jsx(za, { size: 14, className: "oui-text-base-contrast-36 oui-cursor-pointer", onClick: i }) }), autoComplete: "off" });
  return jsx(_$1, { id: "oui-markets-list", intensity: 900, p: 6, r: "2xl", children: jsxs(Cl, { variant: "contained", size: "xl", value: t, onValueChange: o, trailing: n4, children: [jsx(Sl, { title: s("markets.favorites"), icon: jsx(te, {}), value: "favorites", testid: "oui-testid-markets-favorites-tab", children: jsx(Wt, {}) }), jsx(Sl, { title: s("markets.allMarkets"), icon: jsx(Lo, {}), value: "all", testid: "oui-testid-markets-all-tab", children: jsx(Qe, { type: "all", sortKey: "24h_amount", sortOrder: "desc" }) }), jsx(Sl, { title: s("markets.newListings"), icon: jsx(Do, {}), value: "new", testid: "oui-testid-markets-newListings-tab", children: jsx(Qe, { type: "new", sortKey: "created_time", sortOrder: "desc" }) })] }) });
};
function At2() {
  let [e3, t] = useState("all"), { clearSearchValue: o } = d();
  return useEffect(() => {
    o == null ? void 0 : o();
  }, [e3]), { activeTab: e3, onTabChange: (s) => t(s) };
}
var Et$1 = () => {
  let e3 = At2();
  return jsx(zt$1, { ...e3 });
};
var re = (e3, t = false) => {
  let { t: o } = Z$2();
  return [{ title: o("markets.column.market&Volume"), dataIndex: "24h_amount", onSort: true, className: "oui-h-[36px]", render: (s, r3) => {
    let a2;
    return t || (a2 = jsx(J, { row: r3, favorite: e3, children: jsx(z$1, { width: 12, height: 12, justify: "center", itemAlign: "center", className: "oui-cursor-pointer oui-mr-1", children: r3.isFavorite ? jsx(ve3, { className: "oui-w-3 oui-h-3 oui-text-[rgba(255,154,46,1)]" }) : jsx(Se2, { className: "oui-w-3 oui-h-3 oui-text-base-contrast-36 hover:oui-text-[rgba(255,154,46,1)]" }) }) })), jsxs(z$1, { children: [a2, jsxs(z$1, { direction: "column", itemAlign: "start", gapY: 1, children: [jsxs(z$1, { gapX: 1, children: [jsx(Pe$5, { symbol: r3.symbol, className: "oui-w-[18px] oui-h-[18px]" }), jsx($$4.formatted, { rule: "symbol", formatString: "base", size: "2xs", weight: "semibold", children: r3.symbol }), jsxs(od, { size: "xs", color: "primary", children: [r3.leverage, "x"] })] }), jsx($$4.numeral, { intensity: 54, size: "2xs", rule: "human", dp: 2, rm: g$6.ROUND_DOWN, children: s })] })] });
  } }, { title: o("markets.column.price&Change"), dataIndex: "change", align: "right", onSort: true, className: "oui-h-[36px]", render: (s, r3) => {
    let a2 = (l2) => {
      e3.updateSymbolFavoriteState(r3, e3.selectedFavoriteTab, true), l2.stopPropagation();
    }, i = "oui-w-4 oui-h-4 oui-text-base-contrast-54 hover:oui-text-base-contrast", n4 = jsx("div", { className: cnBase("oui-absolute oui-right-0 oui-top-[6.5px]", "oui-hidden group-hover:oui-block"), children: jsxs(z$1, { className: cnBase("oui-inline-flex", "oui-bg-primary-darken oui-py-[6px]"), r: "base", width: 52, justify: "center", itemAlign: "end", gapX: 2, children: [jsx(ye2, { className: i, onClick: (l2) => {
      l2.stopPropagation(), e3.pinToTop(r3);
    } }), jsx(we, { className: i, onClick: a2 })] }) });
    return jsxs("div", { className: "oui-relative", children: [t && n4, jsxs(z$1, { direction: "column", justify: "end", itemAlign: "end", gapY: 1, className: cnBase(t && "group-hover:oui-invisible"), children: [jsx($$4.numeral, { dp: r3.quote_dp || 2, size: "2xs", children: r3["24h_close"] }), jsx($$4.numeral, { rule: "percentages", coloring: true, rm: g$6.ROUND_DOWN, showIdentifier: true, size: "2xs", children: s })] })] });
  } }];
};
var se = (e3) => {
  var _a2;
  let { symbol: t, onSymbolChange: o } = d(), { t: s } = Z$2();
  return jsx("div", { className: "oui-overflow-y-auto oui-custom-scrollbar oui-h-full", children: jsx(z$1, { direction: "column", px: 2, gapY: 1, children: (_a2 = e3.dataSource) == null ? void 0 : _a2.map((r3) => {
    let a2 = jsxs(z$1, { intensity: 800, p: 2, className: "oui-gap-x-7", r: "base", children: [jsxs(z$1, { direction: "column", itemAlign: "start", gapY: 1, children: [jsxs(z$1, { gapX: 1, children: [jsx(Pe$5, { symbol: r3.symbol, className: "oui-w-[18px] oui-h-[18px]" }), jsx($$4.formatted, { rule: "symbol", formatString: "base", size: "2xs", weight: "semibold", children: r3.symbol })] }), jsx($$4, { size: "2xs", intensity: 36, children: s("markets.column.last") }), jsx($$4, { size: "2xs", intensity: 36, children: s("markets.column.24hPercentage") })] }), jsxs(z$1, { direction: "column", itemAlign: "end", gapY: 1, children: [jsxs(od, { size: "xs", color: "primary", children: [r3.leverage, "x"] }), jsx($$4.numeral, { dp: r3.quote_dp || 2, currency: "$", size: "2xs", intensity: 80, children: r3["24h_close"] }), jsx($$4.numeral, { rule: "percentages", coloring: true, rm: g$6.ROUND_DOWN, showIdentifier: true, size: "2xs", children: r3.change })] })] });
    return jsx(Xn$2, { side: "right", sideOffset: 6, content: a2, delayDuration: 0, children: jsxs(z$1, { direction: "column", justify: "center", itemAlign: "center", gapY: 1, width: 54, height: 54, r: "lg", className: cnBase("oui-cursor-pointer", "hover:oui-bg-base-7", t === r3.symbol && "oui-bg-base-6 hover:oui-bg-base-6"), onClick: () => {
      o == null ? void 0 : o(r3);
    }, children: [jsx(Pe$5, { symbol: r3.symbol, className: "oui-w-[18px] oui-h-[18px]" }), jsx($$4.numeral, { rule: "percentages", coloring: true, rm: g$6.ROUND_DOWN, showIdentifier: true, size: "2xs", children: r3.change })] }) }, r3.symbol);
  }) }) });
};
var Ht$1 = (e3) => {
  var _a2, _b2, _c2, _d2;
  let { dataSource: t, favorite: o, onSort: s, loading: r3, getColumns: a2, collapsed: i } = e3, { symbol: n4, onSymbolChange: l2 } = d(), u2 = re(o, true), m2 = typeof a2 == "function" ? a2(o, true) : u2;
  return i ? jsx(se, { dataSource: t }) : jsxs(Fragment$1, { children: [jsx(_$1, { px: 3, className: "oui-my-[6px]", children: jsx(ze, { favorite: o, size: "sm" }) }), jsx(jd, { classNames: { root: (_a2 = e3.tableClassNames) == null ? void 0 : _a2.root, body: (_b2 = e3.tableClassNames) == null ? void 0 : _b2.body, header: cnBase("oui-h-9", (_c2 = e3.tableClassNames) == null ? void 0 : _c2.header), scroll: (_d2 = e3.tableClassNames) == null ? void 0 : _d2.scroll }, columns: m2, dataSource: t, loading: r3, onRow: (c2, f2) => ({ className: cnBase("oui-h-[53px]", e3.rowClassName), onClick: () => {
    l2 == null ? void 0 : l2(c2), o.addToHistory(c2);
  } }), generatedRowKey: (c2) => c2.symbol, rowSelection: { [n4]: true }, onSort: s, manualSorting: true })] });
};
var Kt = () => {
  let [e3, t] = useMarkets(MarketsType.FAVORITES), [o, s] = useState(true), { favorites: r3, selectedFavoriteTab: a2 } = t, { searchValue: i } = d(), { onSort: n4, getSortedList: l2 } = I$1(), u2 = useMemo(() => {
    var _a2, _b2;
    let m2 = (_b2 = (_a2 = r3 == null ? void 0 : r3.filter((f2) => {
      var _a3;
      return ((_a3 = f2.tabs) == null ? void 0 : _a3.findIndex((b2) => b2.id === a2.id)) !== -1;
    })) == null ? void 0 : _a2.map((f2) => {
      let b2 = e3 == null ? void 0 : e3.findIndex((p2) => p2.symbol === f2.name);
      return b2 !== -1 ? e3[b2] : null;
    })) == null ? void 0 : _b2.filter((f2) => f2), c2 = L(m2, i, "base");
    return l2(c2);
  }, [e3, a2, r3, i, l2]);
  return useEffect(() => {
    s(false);
  }, [e3]), { loading: o, dataSource: u2, favorite: t, onSort: n4 };
};
var fe = (e3) => {
  let t = Kt();
  return jsx(Ht$1, { ...t, ...e3 });
};
var Xt = (e3) => {
  var _a2, _b2, _c2, _d2;
  let { loading: t, dataSource: o, favorite: s, onSort: r3, initialSort: a2, getColumns: i, collapsed: n4 } = e3, { symbol: l2, onSymbolChange: u2 } = d(), m2 = re(s, false), c2 = typeof i == "function" ? i(s, false) : m2;
  return n4 ? jsx(se, { dataSource: o }) : jsx(jd, { classNames: { root: (_a2 = e3.tableClassNames) == null ? void 0 : _a2.root, body: (_b2 = e3.tableClassNames) == null ? void 0 : _b2.body, header: cnBase("oui-h-9", (_c2 = e3.tableClassNames) == null ? void 0 : _c2.header), scroll: (_d2 = e3.tableClassNames) == null ? void 0 : _d2.scroll }, columns: c2, loading: t, dataSource: o, onRow: (f2, b2) => ({ className: cnBase("oui-h-[53px]", e3.rowClassName), onClick: () => {
    u2 == null ? void 0 : u2(f2), s.addToHistory(f2);
  } }), generatedRowKey: (f2) => f2.symbol, rowSelection: { [l2]: true }, onSort: r3, initialSort: a2, manualSorting: true });
};
var qt = (e3) => {
  let [t, o] = useState(true), [s, r3] = useMarkets(MarketsType.ALL), { searchValue: a2 } = d(), { onSort: i, getSortedList: n4 } = I$1(e3 == null ? void 0 : e3.sortKey, e3 == null ? void 0 : e3.sortOrder, e3.onSort), l2 = useMemo(() => {
    let u2 = L(s, a2, "base");
    return n4(u2);
  }, [s, n4, a2]);
  return useEffect(() => {
    o(false);
  }, [s]), { loading: t, dataSource: l2, favorite: r3, onSort: i };
};
var j = (e3) => {
  let t = qt(e3);
  return jsx(Xt, { ...t, initialSort: { sortKey: e3.sortKey, sort: e3.sortOrder }, getColumns: e3.getColumns, collapsed: e3.collapsed, tableClassNames: e3.tableClassNames, rowClassName: e3.rowClassName });
};
var $t = (e3) => {
  var _a2, _b2, _c2, _d2;
  let { dataSource: t, favorite: o, onSort: s, loading: r3, getColumns: a2, collapsed: i } = e3, { symbol: n4, onSymbolChange: l2 } = d(), u2 = re(o, false), m2 = typeof a2 == "function" ? a2(o, false) : u2;
  return i ? jsx(se, { dataSource: t }) : jsx(jd, { classNames: { root: (_a2 = e3.tableClassNames) == null ? void 0 : _a2.root, body: (_b2 = e3.tableClassNames) == null ? void 0 : _b2.body, header: cnBase("oui-h-9", (_c2 = e3.tableClassNames) == null ? void 0 : _c2.header), scroll: (_d2 = e3.tableClassNames) == null ? void 0 : _d2.scroll }, columns: m2, dataSource: t, loading: r3, onRow: (c2, f2) => ({ className: cnBase("oui-h-[53px]", e3.rowClassName), onClick: () => {
    l2 == null ? void 0 : l2(c2), o.addToHistory(c2);
  } }), generatedRowKey: (c2) => c2.symbol, rowSelection: { [n4]: true }, onSort: s, manualSorting: true });
};
var Yt$1 = () => {
  let [e3, t] = useMarkets(MarketsType.RECENT), [o, s] = useState(true), { searchValue: r3 } = d(), { onSort: a2, getSortedList: i } = I$1(), n4 = useMemo(() => {
    let l2 = L(e3, r3, "base");
    return i(l2);
  }, [e3, r3, i]);
  return useEffect(() => {
    s(false);
  }, [e3]), { loading: o, dataSource: n4, favorite: t, onSort: a2 };
};
var be3 = (e3) => {
  let t = Yt$1();
  return jsx($t, { ...t, ...e3 });
};
var Qt = (e3) => {
  var _a2, _b2, _c2, _d2;
  let { dataSource: t, favorite: o, onSort: s, loading: r3, getColumns: a2, collapsed: i } = e3, { symbol: n4, onSymbolChange: l2 } = d(), u2 = re(o, false), m2 = typeof a2 == "function" ? a2(o, false) : u2;
  return i ? jsx(se, { dataSource: t }) : jsx(jd, { classNames: { root: (_a2 = e3.tableClassNames) == null ? void 0 : _a2.root, body: (_b2 = e3.tableClassNames) == null ? void 0 : _b2.body, header: cnBase("oui-h-9", (_c2 = e3.tableClassNames) == null ? void 0 : _c2.header), scroll: (_d2 = e3.tableClassNames) == null ? void 0 : _d2.scroll }, columns: m2, dataSource: t, loading: r3, onRow: (c2, f2) => ({ className: cnBase("oui-h-[53px]", e3.rowClassName), onClick: () => {
    l2 == null ? void 0 : l2(c2), o.addToHistory(c2);
  } }), generatedRowKey: (c2) => c2.symbol, rowSelection: { [n4]: true }, onSort: s, manualSorting: true });
};
var Zt = () => {
  let [e3, t] = useMarkets(MarketsType.NEW_LISTING), [o, s] = useState(true), { searchValue: r3 } = d(), { onSort: a2, getSortedList: i } = I$1(), n4 = useMemo(() => {
    let l2 = L(e3, r3, "base");
    return i(l2);
  }, [e3, r3, i]);
  return useEffect(() => {
    s(false);
  }, [e3]), { loading: o, dataSource: n4, favorite: t, onSort: a2 };
};
var xe = (e3) => {
  let t = Zt();
  return jsx(Qt, { ...t, ...e3 });
};
var Jt = (e3) => {
  let { activeTab: t, onTabChange: o, tabSort: s, onTabSort: r3 } = e3, { searchValue: a2, onSearchValueChange: i, clearSearchValue: n4 } = d(), { t: l2 } = Z$2(), u2 = jsx(So$4, { value: a2, onValueChange: i, placeholder: l2("markets.search.placeholder"), classNames: { root: "oui-border oui-mt-[1px] oui-border-line" }, size: "sm", prefix: jsx(_$1, { pl: 3, pr: 1, children: jsx(K, { className: "oui-text-base-contrast-36" }) }), suffix: a2 && jsx(_$1, { mr: 2, children: jsx(za, { size: 14, className: "oui-text-base-contrast-36 oui-cursor-pointer", onClick: n4 }) }), autoComplete: "off" }), m2 = "oui-h-[calc(100%_-_36px)]";
  return jsxs(_$1, { className: cnBase("oui-font-semibold oui-overflow-hidden"), height: "100%", children: [jsx(_$1, { px: 3, pb: 2, children: u2 }), jsxs(Cl, { variant: "contained", size: "md", value: t, onValueChange: o, classNames: { tabsList: cnBase("oui-my-[6px]"), tabsContent: "oui-h-full", scrollIndicator: "oui-mx-3" }, className: m2, showScrollIndicator: true, children: [jsx(Sl, { title: l2("markets.favorites"), icon: jsx(te, {}), value: "favorites", children: jsx("div", { className: m2, children: jsx(fe, { tableClassNames: { scroll: "oui-px-1" } }) }) }), jsx(Sl, { title: l2("markets.recent"), value: "recent", children: jsx("div", { className: m2, children: jsx(be3, { tableClassNames: { scroll: "oui-px-1" } }) }) }), jsx(Sl, { title: l2("common.all"), value: "all", children: jsx("div", { className: m2, children: jsx(j, { type: "all", sortKey: s == null ? void 0 : s.sortKey, sortOrder: s == null ? void 0 : s.sortOrder, onSort: r3, tableClassNames: { scroll: "oui-px-1" } }) }) }), jsx(Sl, { title: l2("markets.newListings"), value: "newListing", children: jsx("div", { className: m2, children: jsx(xe, { tableClassNames: { scroll: "oui-px-1" } }) }) })] })] });
};
var ir = "24h_amount", lr = "desc";
function Le2(e3) {
  let { storageKey: t, type: o = "all", initialSort: s } = e3, [r3, a2] = useSessionStorage(t, { [o]: { sortKey: (s == null ? void 0 : s.sortKey) || ir, sortOrder: (s == null ? void 0 : s.sortOrder) || lr } }), i = useCallback((n4 = ir, l2 = lr) => {
    a2({ ...r3, all: { sortKey: n4, sortOrder: l2 } });
  }, []);
  return { tabSort: r3[o], onTabSort: i };
}
function jt(e3) {
  let [t, o] = useState(e3 == null ? void 0 : e3.activeTab), { tabSort: s, onTabSort: r3 } = Le2({ storageKey: "orderly_side_markets_tab_sort" }), { clearSearchValue: a2 } = d(), i = useCallback((n4) => {
    typeof (e3 == null ? void 0 : e3.onTabChange) == "function" ? e3.onTabChange(n4) : o(n4);
  }, [e3 == null ? void 0 : e3.onTabChange]);
  return useEffect(() => {
    o((e3 == null ? void 0 : e3.activeTab) || "favorites");
  }, [e3 == null ? void 0 : e3.activeTab]), useEffect(() => {
    a2 == null ? void 0 : a2();
  }, [t]), { activeTab: t, onTabChange: i, tabSort: s, onTabSort: r3 };
}
var eo = (e3) => {
  let t = jt({ activeTab: e3.activeTab, onTabChange: e3.onTabChange });
  return jsx(A, { symbol: e3.symbol, onSymbolChange: e3.onSymbolChange, children: jsx(Jt, { ...t }) });
};
var ae2 = (e3 = 5) => (t) => t === 0 ? jsx($$4, { children: " - " }) : jsx($$4.numeral, { rule: "percentages", dp: e3, coloring: true, rm: g$6.ROUND_DOWN, showIdentifier: true, children: t }), dr = (e3, t) => {
  let { t: o } = Z$2();
  return [{ title: o("markets.column.market"), dataIndex: "symbol", width: 120, render: (s) => jsx($$4.formatted, { rule: "symbol", formatString: "base-type", size: "xs", weight: "semibold", showIcon: true, children: s }) }, { title: o("markets.funding.column.estFunding"), dataIndex: "estFunding", width: 120, onSort: true, render: (s) => jsxs("div", { children: [jsx($$4.numeral, { rule: "percentages", dp: 5, coloring: true, rm: g$6.ROUND_DOWN, showIdentifier: true, children: s }), jsx("span", { className: "oui-text-base-contrast-54", children: " / 4h " })] }) }, { title: o("markets.funding.column.lastFunding"), dataIndex: "lastFunding", width: 90, onSort: true, render: ae2() }, { title: o("markets.funding.column.1dAvg"), dataIndex: "funding1d", width: 90, onSort: true, render: ae2() }, { title: o("markets.funding.column.3dAvg"), dataIndex: "funding3d", width: 90, onSort: true, render: ae2() }, { title: o("markets.funding.column.7dAvg"), dataIndex: "funding7d", width: 90, onSort: true, render: ae2() }, { title: o("markets.funding.column.14dAvg"), dataIndex: "funding14d", width: 90, onSort: true, render: ae2() }, { title: o("markets.funding.column.30dAvg"), dataIndex: "funding30d", width: 90, onSort: true, render: ae2() }, { title: o("markets.funding.column.90dAvg"), dataIndex: "funding90d", width: 90, onSort: true, render: ae2() }, { title: jsxs("div", { className: "oui-flex oui-gap-1", children: [jsx("select", { value: e3, onChange: (s) => t(s.target.value), onClick: (s) => s.stopPropagation(), className: "oui-w-12 oui-rounded-md oui-border oui-border-line oui-bg-[var(--oui-table-background-color)]", children: [{ label: o("common.select.1d"), value: "1dPositive" }, { label: o("common.select.3d"), value: "3dPositive" }, { label: o("common.select.7d"), value: "7dPositive" }, { label: o("common.select.14d"), value: "14dPositive" }, { label: o("common.select.30d"), value: "30dPositive" }, { label: o("common.select.90d"), value: "90dPositive" }].map((s) => jsx("option", { value: s.value, children: s.label }, s.value)) }), jsx("span", { children: o("markets.funding.column.positiveRate") })] }), dataIndex: e3, width: 130, align: "right", onSort: true, render: ae2(2) }];
};
var to = (e3) => {
  let { dataSource: t, isLoading: o, pagination: s, onSort: r3 } = e3, [a2, i] = useState("1dPositive"), n4 = dr(a2, i);
  return jsx("div", { className: "w-full", children: jsx(jd, { columns: n4, dataSource: t, loading: o, bordered: true, onRow: () => ({ className: cnBase("oui-h-[48px] oui-cursor-pointer") }), classNames: { header: "oui-h-12" }, pagination: s, onSort: r3, manualSorting: true, generatedRowKey: (l2) => l2.symbol }) });
};
var ro$1 = () => {
  let { pagination: t } = mm({ pageSize: 10 }), [o] = useMarkets(MarketsType.ALL), { data: s, isLoading: r3, getPositiveRates: a2 } = useFundingRateHistory(), { onSort: i, getSortedList: n4 } = I$1(), { searchValue: l2 } = d(), u2 = useMemo(() => {
    if (!(o == null ? void 0 : o.length)) return [];
    let b2 = ["1d", "3d", "7d", "14d", "30d", "90d"].reduce((p2, x2) => (p2[x2] = a2(s, x2), p2), {});
    return o.map((p2) => {
      var _a2, _b2, _c2, _d2, _e4, _f2, _g3, _h2, _i3, _j2, _k2, _l2;
      let x2 = s == null ? void 0 : s.find((y2) => y2.symbol === p2.symbol);
      return { symbol: p2.symbol, estFunding: p2.est_funding_rate, lastFunding: p2.last_funding_rate, funding1d: ((_b2 = (_a2 = x2 == null ? void 0 : x2.funding) == null ? void 0 : _a2["1d"]) == null ? void 0 : _b2.rate) ?? 0, funding3d: ((_d2 = (_c2 = x2 == null ? void 0 : x2.funding) == null ? void 0 : _c2["3d"]) == null ? void 0 : _d2.rate) ?? 0, funding7d: ((_f2 = (_e4 = x2 == null ? void 0 : x2.funding) == null ? void 0 : _e4["7d"]) == null ? void 0 : _f2.rate) ?? 0, funding14d: ((_h2 = (_g3 = x2 == null ? void 0 : x2.funding) == null ? void 0 : _g3["14d"]) == null ? void 0 : _h2.rate) ?? 0, funding30d: ((_j2 = (_i3 = x2 == null ? void 0 : x2.funding) == null ? void 0 : _i3["30d"]) == null ? void 0 : _j2.rate) ?? 0, funding90d: ((_l2 = (_k2 = x2 == null ? void 0 : x2.funding) == null ? void 0 : _k2["90d"]) == null ? void 0 : _l2.rate) ?? 0, "1dPositive": b2["1d"][p2.symbol] ?? "-", "3dPositive": b2["3d"][p2.symbol] ?? "-", "7dPositive": b2["7d"][p2.symbol] ?? "-", "14dPositive": b2["14d"][p2.symbol] ?? "-", "30dPositive": b2["30d"][p2.symbol] ?? "-", "90dPositive": b2["90d"][p2.symbol] ?? "-" };
    });
  }, [o, s, a2]), m2 = useMemo(() => L(u2, l2, "base-type"), [u2, l2, t]);
  return { dataSource: useMemo(() => n4(m2), [m2, n4]), isLoading: r3, pagination: t, onSort: i };
};
var so$1 = () => {
  let e3 = ro$1();
  return jsx(to, { ...e3 });
};
var rt = ["WOOFi Pro", "Binance", "OKX", "Bybit", "dYdX", "Bitget", "Kucoin"], no = () => {
  let { pagination: o } = mm({ pageSize: 10 }), { onSort: s, getSortedList: r3 } = I$1(), { searchValue: a2 } = d(), i = useFundingRates(), { data: n4, isLoading: l2 } = useQuery("/v1/public/market_info/funding_comparison"), u2 = useMemo(() => (n4 == null ? void 0 : n4.length) ? n4.map((f2) => {
    let b2 = { symbol: f2.symbol };
    return rt.forEach((p2, x2) => {
      let y2 = p2.toLowerCase();
      if (y2 === "woofi pro") {
        let M2 = i[f2.symbol];
        b2[`exchange_${x2}`] = M2("last_funding_rate") ?? null;
        return;
      }
      let w5 = f2.exchanges.find((M2) => M2.name.toLowerCase() === y2);
      b2[`exchange_${x2}`] = (w5 == null ? void 0 : w5.last) ?? null;
    }), b2;
  }) : [], [n4, rt, i]), m2 = useMemo(() => L(u2, a2, "base-type"), [u2, a2, o]);
  return { data: useMemo(() => r3(m2), [m2, r3]), isLoading: l2, pagination: o, onSort: s };
};
var br = () => {
  let { t: e3 } = Z$2();
  return [{ title: e3("markets.column.market"), dataIndex: "symbol", width: 150, onSort: true, render: (t) => jsx($$4.formatted, { rule: "symbol", formatString: "base-type", size: "xs", weight: "semibold", showIcon: true, children: t }) }, ...rt.map((t, o) => ({ title: jsxs("div", { style: { display: "flex", alignItems: "center", gap: "4px" }, children: [jsx("img", { src: `https://oss.orderly.network/static/exchange_logo/${t.toLowerCase().replace(" ", "_")}.png`, style: { width: "24px", height: "24px", objectFit: "cover", borderRadius: "50%" } }), jsx("span", { children: t })] }), dataIndex: `exchange_${o}`, width: 100, render: (s) => s === null ? "-" : jsx($$4.numeral, { rule: "percentages", dp: 5, coloring: true, rm: g$6.ROUND_DOWN, showIdentifier: true, children: s }) }))];
};
var io$1 = ({ data: e3, isLoading: t, pagination: o }) => {
  let s = br();
  return jsx(jd, { columns: s, dataSource: e3, loading: t, onRow: () => ({ className: cnBase("oui-h-[48px] oui-cursor-pointer") }), classNames: { header: "oui-h-12" }, bordered: true, pagination: o });
};
var lo$1 = () => {
  let e3 = no();
  return jsx(io$1, { ...e3 });
};
var uo = (e3) => {
  let { collapsable: t, collapsed: o, onCollapse: s, activeTab: r3, onTabChange: a2, className: i } = e3, { symbol: n4, onSymbolChange: l2 } = d(), u2 = () => o ? r3 === "favorites" ? jsx(fe, { collapsed: o }) : r3 === "recent" ? jsx(be3, { collapsed: o }) : r3 === "newListing" ? jsx(xe, { collapsed: o }) : jsx(j, { type: "all", sortKey: "24h_amount", sortOrder: "desc", collapsed: o }) : jsx(eo, { activeTab: r3, onTabChange: a2, symbol: n4, onSymbolChange: l2 });
  return jsxs(z$1, { id: "oui-side-markets", className: cnBase("oui-font-semibold", i), direction: "column", gapY: 5, height: "100%", width: "100%", children: [jsx(Sn, { collapsable: t, collapsed: o, onCollapse: s }), jsx(_$1, { width: "100%", className: cnBase(o ? "oui-h-[calc(100%_-_52px)]" : "oui-h-[calc(100%_-_56px)]"), children: u2() })] });
}, Sn = (e3) => {
  let { collapsable: t, collapsed: o, onCollapse: s } = e3, { t: r3 } = Z$2(), a2 = cnBase("oui-text-base-contrast-36", t ? "oui-cursor-pointer hover:oui-text-base-contrast-80" : "oui-cursor-not-allowed");
  return o ? jsx(Vo$1, { className: a2, onClick: () => {
    t && (s == null ? void 0 : s(false));
  } }) : jsxs(z$1, { justify: "between", px: 3, width: "100%", children: [jsx($$4, { size: "base", intensity: 80, children: r3("common.markets") }), jsx(Wo, { className: a2, onClick: () => {
    t && (s == null ? void 0 : s(true));
  } })] });
};
function co$1(e3) {
  let [t, o] = useState(e3 == null ? void 0 : e3.collapsed), [s, r3] = useLocalStorage("orderly_side_markets_sel_tab_key", "all"), a2 = useMemo(() => (e3 == null ? void 0 : e3.collapsable) ?? true, [e3 == null ? void 0 : e3.collapsable]), i = useCallback((n4) => {
    typeof (e3 == null ? void 0 : e3.onCollapse) == "function" ? e3.onCollapse(n4) : o(n4);
  }, [e3 == null ? void 0 : e3.onCollapse]);
  return useEffect(() => {
    o(e3 == null ? void 0 : e3.collapsed);
  }, [e3 == null ? void 0 : e3.collapsed]), { collapsable: a2, collapsed: t, onCollapse: i, activeTab: s, onTabChange: r3 };
}
var Mn = (e3) => {
  let t = co$1({ collapsable: e3.collapsable, collapsed: e3.collapsed, onCollapse: e3.onCollapse });
  return jsx(A, { symbol: e3.symbol, onSymbolChange: e3.onSymbolChange, children: jsx(uo, { ...t, className: e3.className }) });
};
var fo$1 = () => {
  let { t: e3 } = Z$2();
  return useCallback((t, o = false) => [{ title: e3("common.symbol"), dataIndex: "symbol", width: 150, render: (s, r3) => {
    let a2;
    return o || (a2 = jsx(J, { row: r3, favorite: t, children: jsx(z$1, { width: 12, height: 12, justify: "center", itemAlign: "center", className: "oui-cursor-pointer oui-mr-1", children: r3.isFavorite ? jsx(ve3, { className: "oui-w-3 oui-h-3 oui-text-[rgba(255,154,46,1)]" }) : jsx(Se2, { className: "oui-w-3 oui-h-3 oui-text-base-contrast-36 hover:oui-text-[rgba(255,154,46,1)]" }) }) })), jsxs(z$1, { gapX: 1, children: [a2, jsx(Pe$5, { symbol: s, className: "oui-w-[18px] oui-h-[18px]" }), jsx($$4.formatted, { rule: "symbol", formatString: "base", size: "2xs", weight: "semibold", children: s }), jsxs(od, { size: "xs", color: "primary", children: [r3.leverage, "x"] })] });
  } }, { title: e3("markets.column.last"), dataIndex: "24h_close", align: "right", onSort: true, width: 100, render: (s, r3) => jsx($$4.numeral, { dp: r3.quote_dp || 2, size: "2xs", children: s }) }, { title: e3("markets.column.24hPercentage"), dataIndex: "change", align: "right", onSort: true, width: 80, render: (s) => jsx($$4.numeral, { rule: "percentages", coloring: true, rm: g$6.ROUND_DOWN, showIdentifier: true, size: "2xs", children: s }) }, { title: e3("common.volume"), dataIndex: "24h_amount", align: "right", onSort: true, className: "oui-relative", width: 80, render: (s, r3) => {
    let a2 = (l2) => {
      t.updateSymbolFavoriteState(r3, t.selectedFavoriteTab, true), l2.stopPropagation();
    }, i = "oui-w-4 oui-h-4 oui-text-base-contrast-54 hover:oui-text-base-contrast", n4 = jsx("div", { className: cnBase("oui-absolute oui-right-1 oui-top-[3px]"), children: jsxs(z$1, { className: cnBase("oui-bg-primary-darken oui-py-[6px]", "oui-hidden group-hover:oui-inline-flex"), r: "base", width: 52, justify: "center", itemAlign: "end", gapX: 2, children: [jsx(ye2, { className: i, onClick: (l2) => {
      l2.stopPropagation(), t.pinToTop(r3);
    } }), jsx(we, { className: i, onClick: a2 })] }) });
    return jsxs(Fragment$1, { children: [o && n4, jsx($$4.numeral, { rule: "human", dp: 2, rm: g$6.ROUND_DOWN, className: cnBase(o && "group-hover:oui-invisible"), children: s })] });
  } }], [e3]);
};
var bo$1 = (e3) => jsxs(Yi, { open: e3.open, onOpenChange: e3.onOpenChange, children: [jsx(Xi$1, { asChild: true, children: e3.children }), jsx(ji, { children: jsx(rr$2, { onCloseAutoFocus: (t) => t.preventDefault(), onClick: (t) => t.stopPropagation(), align: "start", alignOffset: -32, sideOffset: 20, className: cnBase("oui-markets-dropdown-menu-content oui-bg-base-8 oui-p-0", e3.contentClassName), children: jsx(kr, { ...e3, hide: e3.hide }) }) })] }), kr = (e3) => {
  let { activeTab: t, onTabChange: o, tabSort: s, onTabSort: r3 } = e3, { searchValue: a2, onSearchValueChange: i } = d(), { t: n4 } = Z$2(), l2 = fo$1(), u2 = jsxs(z$1, { mx: 3, gapX: 3, pt: 3, pb: 2, children: [jsx(So$4, { value: a2, onValueChange: i, placeholder: n4("markets.search.placeholder"), classNames: { root: "oui-border oui-mt-[1px] oui-border-line oui-flex-1" }, size: "sm", prefix: jsx(_$1, { pl: 3, pr: 1, children: jsx(K, { className: "oui-text-base-contrast-36" }) }), autoComplete: "off" }), jsx(ye$7, { size: 12, className: "oui-text-base-contrast-80 oui-cursor-pointer", onClick: e3.hide, opacity: 1 })] }), m2 = "oui-h-[calc(100%_-_36px)]";
  return jsxs(_$1, { className: cnBase("oui-font-semibold oui-overflow-hidden"), height: "100%", intensity: 800, children: [u2, jsxs(Cl, { variant: "contained", size: "md", value: t, onValueChange: o, classNames: { tabsList: "oui-my-[6px] oui-px-3", tabsContent: "oui-h-full" }, className: m2, children: [jsx(Sl, { title: n4("markets.favorites"), icon: jsx(te, {}), value: "favorites", children: jsx("div", { className: m2, children: jsx(fe, { getColumns: l2, tableClassNames: { root: "!oui-bg-base-8", scroll: "oui-pb-5 oui-px-1" }, rowClassName: "!oui-h-[34px]" }) }) }), jsx(Sl, { title: n4("markets.recent"), value: "recent", children: jsx("div", { className: m2, children: jsx(be3, { getColumns: l2, tableClassNames: { root: "!oui-bg-base-8", scroll: "oui-pb-5 oui-px-1" }, rowClassName: "!oui-h-[34px]" }) }) }), jsx(Sl, { title: n4("common.all"), value: "all", children: jsx("div", { className: m2, children: jsx(j, { type: "all", sortKey: s == null ? void 0 : s.sortKey, sortOrder: s == null ? void 0 : s.sortOrder, onSort: r3, getColumns: l2, tableClassNames: { root: "!oui-bg-base-8", scroll: "oui-pb-5 oui-px-1" }, rowClassName: "!oui-h-[34px]" }) }) }), jsx(Sl, { title: n4("markets.newListings"), value: "newListing", children: jsx("div", { className: m2, children: jsx(xe, { getColumns: l2, tableClassNames: { root: "!oui-bg-base-8", scroll: "oui-pb-5 oui-px-1" }, rowClassName: "!oui-h-[34px]" }) }) })] })] });
};
function xo(e3) {
  let [t, o] = useState(false), [s, r3] = useLocalStorage("orderly_dropdown_markets_sel_tab_key", "all"), { tabSort: a2, onTabSort: i } = Le2({ storageKey: "orderly_dropdown_markets_tab_sort" }), { clearSearchValue: n4 } = d(), l2 = () => {
    o(false);
  };
  return useEffect(() => {
    n4 == null ? void 0 : n4();
  }, [s]), { activeTab: s, onTabChange: (u2) => r3(u2), open: t, onOpenChange: o, hide: l2, tabSort: a2, onTabSort: i };
}
var ho$1 = (e3) => {
  let t = xo();
  return jsx(A, { symbol: e3.symbol, onSymbolChange: e3.onSymbolChange, children: jsx(bo$1, { ...t, contentClassName: e3.contentClassName, children: e3.children }) });
};
var Tr = (e$1, t = false) => [{ title: e2.t("markets.column.market&Volume"), dataIndex: "24h_amount", onSort: true, className: "oui-h-[36px]", render: (o, s) => jsxs(z$1, { direction: "column", itemAlign: "start", gapY: 1, children: [jsxs(z$1, { gapX: 1, children: [jsx(Pe$5, { symbol: s.symbol, className: "oui-w-[18px] oui-h-[18px]" }), jsx($$4.formatted, { rule: "symbol", formatString: "base", size: "2xs", weight: "semibold", children: s.symbol }), jsxs(od, { size: "xs", color: "primary", children: [s.leverage, "x"] })] }), jsx($$4.numeral, { intensity: 54, rule: "human", dp: 2, rm: g$6.ROUND_DOWN, children: o })] }) }, { title: e2.t("markets.column.price&Change"), dataIndex: "change", align: "right", onSort: true, className: "oui-h-[36px]", render: (o, s) => {
  let r3 = (n4) => {
    e$1.updateSymbolFavoriteState(s, e$1.selectedFavoriteTab, true), n4.stopPropagation();
  }, a2 = "oui-w-4 oui-h-4 oui-text-base-contrast-54 hover:oui-text-base-contrast", i = jsx("div", { className: cnBase("oui-absolute oui-right-0 oui-top-[6.5px]", "oui-hidden group-hover:oui-block"), children: jsxs(z$1, { className: cnBase("oui-inline-flex", "oui-bg-primary-darken oui-py-[6px]"), r: "base", width: 52, justify: "center", itemAlign: "end", gapX: 2, children: [jsx(ye2, { className: a2, onClick: (n4) => {
    n4.stopPropagation(), e$1.pinToTop(s);
  } }), jsx(we, { className: a2, onClick: r3 })] }) });
  return jsxs("div", { className: "oui-relative", children: [t && i, jsxs(z$1, { direction: "column", justify: "end", itemAlign: "end", gapY: 1, className: cnBase(t && "group-hover:oui-invisible"), children: [jsx($$4.numeral, { dp: s.quote_dp || 2, size: "2xs", children: s["24h_close"] }), jsx($$4.numeral, { rule: "percentages", coloring: true, rm: g$6.ROUND_DOWN, showIdentifier: true, size: "2xs", children: o })] })] });
} }];
var So$1 = (e3) => {
  let { className: t, tabSort: o, onTabSort: s } = e3, { searchValue: r3, onSearchValueChange: a2, clearSearchValue: i } = d(), { t: n4 } = Z$2(), l2 = jsx(So$4, { value: r3, onValueChange: a2, placeholder: n4("markets.search.placeholder"), classNames: { root: "oui-border oui-border-line oui-mt-4" }, size: "sm", prefix: jsx(_$1, { pl: 3, pr: 1, children: jsx(K, { className: "oui-text-base-contrast-36" }) }), suffix: r3 && jsx(_$1, { mr: 2, children: jsx(za, { size: 14, className: "oui-text-base-contrast-36 oui-cursor-pointer", onClick: i }) }), autoComplete: "off" });
  return jsxs(ia$1, { cols: 1, className: cnBase("oui-font-semibold oui-grid-rows-[auto,1fr]", t), height: "100%", width: "100%", children: [jsxs(_$1, { px: 3, mt: 3, children: [jsx($$4, { size: "base", intensity: 80, children: n4("common.markets") }), l2] }), jsx("div", { className: "oui-relative", children: jsx(_$1, { width: "100%", mt: 2, className: "oui-absolute oui-left-0 oui-right-9 oui-top-0 oui-bottom-0", children: jsx(j, { type: "all", sortKey: o == null ? void 0 : o.sortKey, sortOrder: o == null ? void 0 : o.sortOrder, onSort: s, getColumns: Tr, tableClassNames: { root: "!oui-bg-base-8", scroll: "oui-pb-[calc(env(safe-area-inset-bottom))]" } }) }) })] });
};
function yo(e3) {
  let { tabSort: t, onTabSort: o } = Le2({ storageKey: "orderly_side_markets_tab_sort" });
  return { tabSort: t, onTabSort: o };
}
var Jn$1 = (e3) => {
  let t = yo();
  return jsx(A, { symbol: e3.symbol, onSymbolChange: e3.onSymbolChange, children: jsx(So$1, { ...t, className: e3.className }) });
};
var wo = (e3) => {
  let { symbol: t, data: o, leverage: s, onSymbol: r3 } = e3, a2 = jsxs(z$1, { className: "oui-cursor-pointer oui-gap-x-[6px]", onClick: r3, children: [jsx($$4.formatted, { className: "oui-break-normal oui-whitespace-nowrap", rule: "symbol", formatString: "base-type", size: "sm", weight: "semibold", showIcon: true, children: t }), jsx(He$1, { className: "oui-text-base-contrast-54 oui-w-[14px] oui-h-[14px]" })] });
  return jsxs(z$1, { className: cnBase("oui-symbol-info-bar-mobile", "oui-font-semibold oui-h-full", e3.className), children: [jsxs(z$1, { gapX: 3, className: "oui-flex-1 oui-overflow-hidden oui-h-full", children: [jsxs(z$1, { gapX: 3, children: [a2, jsxs(od, { size: "xs", color: "primary", children: [s, "x"] })] }), jsx(te$6, { className: "oui-h-6", direction: "vertical", intensity: 8 }), jsx($$4.numeral, { size: "2xs", rule: "percentages", coloring: true, rm: g$6.ROUND_DOWN, showIdentifier: true, children: o == null ? void 0 : o.change })] }), e3.trailing] });
};
function ko(e3) {
  let { symbol: t } = e3, o = useTickerStream(t), s = useSymbolsInfo(), r3 = useMemo(() => {
    let a2 = s[t], i = a2("base_imr");
    return ni$1(i);
  }, [t, s]);
  return { symbol: t, data: o, leverage: r3 };
}
function ni$1(e3) {
  return e3 ? 1 / e3 : void 0;
}
var ii$1 = (e3) => {
  let { symbol: t, ...o } = e3, s = ko({ symbol: t });
  return jsx(wo, { ...s, ...o });
};
var Co$1 = (e3) => {
  let { symbol: t, isFavorite: o, favorite: s, data: r3, quotoDp: a2, openInterest: i, fundingRate: n4, containerRef: l2, leadingElementRef: u2, tailingElementRef: m2, leadingVisible: c2, tailingVisible: f2, onScoll: b2 } = e3, { t: p2 } = Z$2(), x2 = jsx(J, { row: { symbol: t }, favorite: s, children: jsx(z$1, { width: 12, height: 12, justify: "center", itemAlign: "center", className: "oui-cursor-pointer oui-mr-1", children: o ? jsx(ve3, { className: "oui-w-3 oui-h-3 oui-text-[rgba(255,154,46,1)]" }) : jsx(Se2, { className: "oui-w-3 oui-h-3 oui-text-base-contrast-36 hover:oui-text-[rgba(255,154,46,1)]" }) }) }), y2 = jsx(ho$1, { contentClassName: "oui-w-[429px] oui-h-[496px]", symbol: e3.symbol, onSymbolChange: e3.onSymbolChange, children: jsxs(z$1, { gapX: 1, className: "oui-cursor-pointer", children: [jsx(Pe$5, { symbol: t, className: "oui-w-4 oui-h-4" }), jsx($$4.formatted, { className: "oui-break-normal oui-whitespace-nowrap", rule: "symbol", formatString: "base-type", size: "xs", weight: "semibold", intensity: 98, children: t }), jsx(He$1, { className: "oui-text-base-contrast-54" })] }) }), w5 = jsx($$4.numeral, { dp: a2 || 2, currency: "$", size: "sm", intensity: 98, className: "oui-data-value", children: r3 == null ? void 0 : r3["24h_close"] }), M2 = jsxs(Fragment$1, { children: [jsx($$4.numeral, { coloring: true, rm: g$6.ROUND_DOWN, showIdentifier: true, children: r3 == null ? void 0 : r3["24h_change"] }), jsx($$4, { intensity: 36, children: "/" }), jsx($$4.numeral, { rule: "percentages", coloring: true, rm: g$6.ROUND_DOWN, showIdentifier: true, children: r3 == null ? void 0 : r3.change })] });
  return jsxs(z$1, { className: cnBase("oui-symbol-info-bar-desktop", "oui-font-semibold oui-h-[54px]", e3.className), style: { transform: "translateZ(0)", willChange: "transform" }, children: [jsxs(z$1, { gapX: 6, className: "oui-flex-1 oui-overflow-hidden oui-h-full", children: [jsxs(z$1, { gapX: 1, children: [x2, y2] }), jsx(te$6, { className: "oui-h-[26px]", direction: "vertical", intensity: 8 }), w5, jsxs("div", { className: "oui-relative oui-overflow-hidden oui-h-full", children: [jsx("div", { ref: l2, className: "oui-overflow-x-auto oui-hide-scrollbar oui-h-full", children: jsxs(z$1, { gapX: 8, height: "100%", children: [jsx("div", { ref: u2, children: jsx(Re, { label: p2("markets.column.24hChange"), value: M2 }) }), jsx(Re, { label: p2("markets.symbolInfoBar.Mark"), value: jsx($$4.numeral, { dp: a2, "data-testid": "oui-testid-tokenInfo-markPrice-value", children: r3 == null ? void 0 : r3.mark_price }), hint: p2("markets.symbolInfoBar.Mark.tooltip") }), jsx(Re, { label: p2("markets.symbolInfoBar.Index"), value: jsx($$4.numeral, { dp: a2, children: r3 == null ? void 0 : r3.index_price }), hint: p2("markets.symbolInfoBar.Index.tooltip") }), jsx(Re, { label: p2("markets.symbolInfoBar.24hVolume"), value: jsx($$4.numeral, { rule: "human", dp: 2, children: r3 == null ? void 0 : r3["24h_amount"] }), hint: p2("markets.symbolInfoBar.24hVolume.tooltip") }), jsx(Re, { label: p2("markets.symbolInfoBar.predFundingRate"), value: jsx(gi, { symbol: t }), hint: p2("markets.symbolInfoBar.predFundingRate.tooltip") }), jsx("div", { ref: m2, children: jsx(Re, { label: p2("markets.openInterest"), value: jsxs(Fragment$1, { children: [jsx($$4.numeral, { rule: "human", dp: 2, children: i }), jsx($$4, { intensity: 36, children: " USDC" })] }), hint: p2("markets.openInterest.tooltip") }) })] }) }), jsx(Dr, { leading: true, onClick: b2, visible: c2 }), jsx(Dr, { tailing: true, onClick: b2, visible: f2 })] })] }), e3.trailing] });
}, Re = (e3) => jsxs(z$1, { direction: "column", itemAlign: "start", children: [jsx(Xn$2, { open: e3.hint ? void 0 : false, content: e3.hint, className: "oui-max-w-[240px] oui-bg-base-6 ", arrow: { className: "oui-fill-base-6" }, delayDuration: 300, children: jsx($$4, { size: "2xs", intensity: 36, className: cnBase("oui-data-label", "oui-break-normal oui-whitespace-nowrap", e3.hint && "oui-cursor-pointer oui-border-b oui-border-dashed oui-border-line-12"), children: e3.label }) }), jsx($$4, { size: "2xs", intensity: 98, className: cnBase("oui-data-value", "oui-leading-[20px] oui-break-normal oui-whitespace-nowrap"), children: e3.value })] }), Dr = (e3) => {
  let { visible: t, leading: o, tailing: s, onClick: r3 } = e3;
  return t ? jsx("button", { onClick: () => {
    r3 == null ? void 0 : r3(o ? "left" : "right");
  }, style: { background: "linear-gradient(90deg, #07080A 0%, rgba(7, 8, 10, 0.60) 65%, rgba(7, 8, 10, 0.00) 100%)" }, className: cnBase("oui-flex oui-items-center oui-w-[80px]", "oui-absolute oui-top-0 oui-bottom-0 oui-rounded-l", o && "oui-left-0 oui-pl-1", s && "oui-right-0 oui-pr-1 oui-rotate-180"), children: jsx(Uo$1, { className: "oui-text-base-contrast-54 hover:oui-text-base-contrast-80" }) }) : null;
}, gi = ({ symbol: e3 }) => {
  let t = useFundingRate(e3);
  return (t == null ? void 0 : t.est_funding_rate) === null ? "--" : jsxs("div", { children: [jsx($$4.numeral, { unit: "%", dp: 4, className: "oui-text-[#FF9A2E]", children: t.est_funding_rate }), jsx($$4, { intensity: 36, className: "oui-tabular-nums", children: ` in ${t.countDown}` })] });
};
function Mo(e3) {
  let { symbol: t } = e3, o = useTickerStream(t), s = useFundingRate(t), r3 = useMarketsStore(), i = useSymbolsInfo()[t]("quote_dp"), [n4, l2] = useState(false), [u2, m2] = useState(false), c2 = useRef(null), f2 = useRef(null), b2 = useRef(null), p2 = useMemo(() => !!r3.favorites.find((w5) => w5.name === t), [r3.favorites, t]), x2 = useMemo(() => new g$6((o == null ? void 0 : o.open_interest) ?? 0).mul((o == null ? void 0 : o.index_price) ?? 0).toDecimalPlaces(2).valueOf(), [o]);
  return useEffect(() => {
    let w5 = new IntersectionObserver((M2) => {
      for (let U3 = 0; U3 < M2.length; U3++) {
        let W2 = M2[U3];
        W2 && (W2.target === f2.current && l2(!W2.isIntersecting), W2.target === b2.current && m2(!W2.isIntersecting));
      }
    });
    return f2.current && w5.observe(f2.current), b2.current && w5.observe(b2.current), () => {
      w5.disconnect();
    };
  }, []), { symbol: t, isFavorite: p2, favorite: r3, data: o, quotoDp: i, openInterest: x2, fundingRate: s, containerRef: c2, leadingElementRef: f2, tailingElementRef: b2, leadingVisible: n4, tailingVisible: u2, onScoll: (w5) => {
    var _a2, _b2;
    w5 === "left" ? (_a2 = c2.current) == null ? void 0 : _a2.scrollBy({ left: -100, behavior: "smooth" }) : (_b2 = c2.current) == null ? void 0 : _b2.scrollBy({ left: 100, behavior: "smooth" });
  } };
}
var yi$1 = (e3) => {
  let { symbol: t, ...o } = e3, s = Mo({ symbol: t });
  return jsx(Co$1, { ...s, ...o });
};
var Wr = ({ activeFundingTab: e3, onFundingTabChange: t }) => {
  let { searchValue: o, onSearchValueChange: s, clearSearchValue: r3 } = d(), { t: a2 } = Z$2(), i = jsx(So$4, { value: o, onValueChange: s, placeholder: a2("markets.search.placeholder"), className: "oui-w-[240px] oui-my-1", size: "sm", "data-testid": "oui-testid-markets-searchMarket-input", prefix: jsx(_$1, { pl: 3, pr: 1, children: jsx(K, { className: "oui-text-base-contrast-36" }) }), suffix: o && jsx(_$1, { mr: 2, children: jsx(za, { size: 14, className: "oui-text-base-contrast-36 oui-cursor-pointer", onClick: r3 }) }), autoComplete: "off" });
  return jsx(_$1, { id: "oui-funding-list", intensity: 900, p: 6, mt: 4, r: "2xl", children: jsxs(Cl, { variant: "contained", size: "lg", value: e3, onValueChange: t, trailing: i, children: [jsx(Sl, { title: a2("common.overview"), value: "overview", testid: "oui-testid-funding-overview-tab", children: jsx(so$1, {}) }), jsx(Sl, { title: a2("markets.funding.comparison"), value: "comparison", testid: "oui-testid-funding-comparison-tab", children: jsx(lo$1, {}) })] }) });
};
function Ur() {
  let [e3, t] = useState("overview");
  return { activeFundingTab: e3, onFundingTabChange: (o) => t(o) };
}
var _r = () => {
  let e3 = Ur();
  return jsx(Wr, { ...e3 });
};
var Bi = (e3) => {
  let [t, o] = useState("markets"), { t: s } = Z$2();
  return jsx(A, { onSymbolChange: e3.onSymbolChange, children: jsx(_$1, { id: "oui-markets-home-page", className: cnBase("oui-font-semibold", e3.className), p: 6, children: jsxs(Cl, { variant: "text", size: "xl", value: t, onValueChange: o, children: [jsxs(Sl, { title: s("common.markets"), value: "markets", testid: "oui-testid-markets-tab", children: [jsx(kt, {}), jsx(Et$1, {})] }), jsx(Sl, { title: s("common.funding"), value: "funding", testid: "oui-testid-funding-tab", children: jsx(_r, {}) })] }) }) });
};
var W = (e3) => {
  let [t, o] = useLocalStorage("unPnlPriceBasis", "markPrice"), [i, r3] = useLocalStorage("pnlNotionalDecimalPrecision", (e3 == null ? void 0 : e3.pnlNotionalDecimalPrecision) ?? 2), [n4, a2] = useLocalStorage("showAllSymbol", true), [s, m2] = useLocalStorage("hideAssets", false);
  return { unPnlPriceBasis: t, setUnPnlPriceBasic: o, pnlNotionalDecimalPrecision: i, setPnlNotionalDecimalPrecision: r3, showAllSymbol: n4, setShowAllSymbol: a2, hideAssets: s, setHideAssets: m2 };
};
var Ge = (e3) => {
  var _a2;
  let { showAllSymbol: t } = W(), [o] = usePositionStream(t ? void 0 : e3), i = useMemo(() => {
    var _a3;
    return (_a3 = o.rows) == null ? void 0 : _a3.length;
  }, [(_a2 = o.rows) == null ? void 0 : _a2.length]);
  return { positionCount: xr$2(i) ?? 0 };
};
var Ue = (e3) => {
  let { showAllSymbol: t } = W();
  `orderly_${Pe$2.pending}_pageSize`;
  `orderly_${Pe$2.tp_sl}_pageSize`;
  let [r3, { total: n4 }] = useOrderStream({ symbol: t ? void 0 : e3, status: OrderStatus.INCOMPLETE, excludes: [AlgoOrderRootType.POSITIONAL_TP_SL, AlgoOrderRootType.TP_SL], size: 500 }, { keeplive: true }), [a2, { total: s }] = useOrderStream({ symbol: t ? void 0 : e3, status: OrderStatus.INCOMPLETE, includes: [AlgoOrderRootType.POSITIONAL_TP_SL, AlgoOrderRootType.TP_SL], size: 500 }, { keeplive: true }), m2 = xr$2(n4) ?? 0, l2 = xr$2(s) ?? 0;
  return { pendingOrderCount: m2, tpSlOrderCount: l2 };
};
var $e = (e3) => ({ base_dp: e3("base_dp"), quote_dp: e3("quote_dp"), base_tick: e3("base_tick"), base: e3("base"), quote: e3("quote") });
var cr = createContext({}), I = () => useContext(cr), ur = (e3) => {
  let t = useSymbolsInfo()[e3.symbol];
  return jsx(cr.Provider, { value: { ...e3, symbolInfo: { ...$e(t), symbol: e3.symbol } }, children: e3.children });
};
var mr = (e3) => {
  let { current: t, pnlNotionalDecimalPrecision: o, sharePnLConfig: i, symbol: r3, includedPendingOrder: n4 } = e3, a2 = W({ pnlNotionalDecimalPrecision: o }), { onSymbolChange: s } = I(), { positionCount: m2 } = Ge(e3.symbol), { pendingOrderCount: l2, tpSlOrderCount: c2 } = Ue(e3.symbol);
  return { current: t, sharePnLConfig: i, symbol: r3, calcMode: a2.unPnlPriceBasis, includedPendingOrder: n4, ...a2, positionCount: m2, pendingOrderCount: l2, tpSlOrderCount: c2, onSymbolChange: s };
};
var oo = (e3) => {
  let { isMobile: t } = Ao$6();
  return t ? jsx(rs, { ...e3 }) : jsx(ns, { ...e3 });
}, rs = (e3) => {
  let { t } = Z$2();
  return jsxs(z$1, { direction: "column", gap: 2, width: "100%", itemAlign: "start", p: 2, className: "oui-bg-base-9 oui-rounded-b-xl", children: [jsxs(z$1, { width: "100%", justify: "between", children: [jsx(gr, { classNames: { label: "oui-text-2xs oui-text-base-contrast-54", root: "oui-text-sm" }, ...e3 }), jsx(fr, { classNames: { label: "oui-text-2xs oui-text-base-contrast-54", root: "oui-text-sm" }, ...e3 })] }), jsx(te$6, { className: "oui-w-full" }), jsxs(z$1, { className: "oui-gap-[2px] oui-cursor-pointer", children: [jsx($r$1, { id: "oui-checkbox-hideOtherSymbols", color: "white", checked: !e3.showAllSymbol, onCheckedChange: (o) => {
    e3.setShowAllSymbol(!o);
  } }), jsx("label", { className: "oui-text-2xs oui-text-base-contrast-54 oui-cursor-pointer", htmlFor: "oui-checkbox-hideOtherSymbols", children: t("trading.hideOtherSymbols") })] })] });
}, ns = (e3) => jsxs(z$1, { py: 2, px: 3, gap: 6, width: "100%", justify: "start", children: [jsx(gr, { ...e3, classNames: { label: "oui-text-base-contrast-54" } }), jsx(fr, { ...e3, classNames: { label: "oui-text-base-contrast-54" } })] }), gr = (e3) => {
  let { t } = Z$2(), o = typeof e3.unrealPnL == "number" ? e3.unrealPnL >= 0 ? "oui-text-trade-profit" : "oui-text-trade-loss" : "oui-text-base-contrast-80", i = typeof e3.unrealPnL == "number" && e3.unrealPnlROI ? e3.unrealPnlROI >= 0 ? "oui-text-success-darken" : "oui-text-danger-darken" : "oui-text-base-contrast-80";
  return jsx(da$2, { label: t("common.unrealizedPnl"), classNames: e3.classNames, children: jsxs(z$1, { gap: 1, children: [jsx($$4.numeral, { dp: e3.pnlNotionalDecimalPrecision, rm: g$6.ROUND_DOWN, intensity: 80, className: o, children: e3.unrealPnL ?? "--" }), typeof e3.unrealPnlROI < "u" && jsx($$4.numeral, { prefix: "(", suffix: ")", rule: "percentages", size: "2xs", dp: e3.pnlNotionalDecimalPrecision, rm: g$6.ROUND_DOWN, className: i, children: e3.unrealPnlROI })] }) });
}, fr = (e3) => {
  let { t } = Z$2();
  return jsx(da$2, { label: t("common.notional"), classNames: e3.classNames, children: jsx($$4.numeral, { dp: e3.pnlNotionalDecimalPrecision, rm: g$6.ROUND_DOWN, intensity: 80, children: e3.notional ?? "--" }) });
};
var pr = (e3) => {
  let { pnlNotionalDecimalPrecision: t, unPnlPriceBasis: o, symbol: i } = e3, r3 = o, [n4] = usePositionStream(i, { calcMode: r3 }), a2 = xr$2(n4.aggregated), s = a2 == null ? void 0 : a2.total_unreal_pnl, m2 = a2 == null ? void 0 : a2.unrealPnlROI, l2 = a2 == null ? void 0 : a2.notional, { showAllSymbol: c2, setShowAllSymbol: u2 } = W();
  return { pnlNotionalDecimalPrecision: t, unrealPnL: s, unrealPnlROI: m2, notional: l2, showAllSymbol: c2, setShowAllSymbol: u2 };
};
var Xe = (e3) => {
  let t = pr(e3);
  return jsx(oo, { ...t });
};
var io = (e3) => {
  let [t, o] = useState(false), { t: i } = Z$2();
  return jsxs(z$1, { gap: 0, children: [jsxs(z$1, { gap: 1, children: [jsx($r$1, { id: "oui-checkbox-hideOtherSymbols", color: "white", checked: e3.hideOtherSymbols, onCheckedChange: (r3) => {
    e3.setHideOtherSymbols(r3);
  } }), jsx("label", { className: "oui-text-xs oui-text-base-contrast-54 oui-cursor-pointer", htmlFor: "oui-checkbox-hideOtherSymbols", children: i("trading.hideOtherSymbols") })] }), jsxs(Yi, { open: t, onOpenChange: o, children: [jsx(Xi$1, { asChild: true, children: jsx(_e$5, { size: "xs", type: "button", variant: "contained", className: "oui-bg-transparent hover:oui-bg-transparent", children: jsx(Na, { size: 16, color: "white", opacity: 1, className: "oui-text-white/[.36] hover:oui-text-white/80" }) }) }), jsx(rr$2, { className: "oui-px-5 oui-py-3 oui-w-[360px]", alignOffset: 2, align: "end", children: jsxs("div", { className: "oui-flex oui-flex-col oui-text-sm", children: [jsx($$4, { className: "oui-text-base oui-pb-3", children: i("trading.portfolioSettings") }), jsx(te$6, {}), jsx($$4, { className: "oui-pb-3 oui-text-base-contrast-54 oui-mt-2", children: i("trading.portfolioSettings.decimalPrecision") }), jsx(bs, { value: e3.pnlNotionalDecimalPrecision, onValueChange: (r3) => {
    e3.setPnlNotionalDecimalPrecision(r3), o(false);
  } }), jsx(te$6, { className: "oui-my-3" }), jsx($$4, { className: "oui-pb-3 oui-text-base-contrast-54 oui-mt-2", children: i("trading.portfolioSettings.unrealPnlPriceBasis") }), jsx(hs, { value: e3.unPnlPriceBasis, onValueChange: (r3) => {
    e3.setUnPnlPriceBasic(r3), o(false);
  } })] }) })] })] });
}, hs = (e3) => {
  let { value: t, onValueChange: o } = e3, { t: i } = Z$2();
  return jsxs(z$1, { gap: 2, children: [jsx(Ye, { sel: t === "markPrice", label: i("common.markPrice"), value: "markPrice", onCheckChange: o }), jsx(Ye, { sel: t === "lastPrice", label: i("common.lastPrice"), value: "lastPrice", onCheckChange: o })] });
}, bs = (e3) => {
  let { value: t, onValueChange: o } = e3;
  return jsxs(z$1, { gap: 2, children: [jsx(Ye, { sel: t === 0, label: 1, value: 0, onCheckChange: o }), jsx(Ye, { sel: t === 1, label: 0.1, value: 1, onCheckChange: o }), jsx(Ye, { sel: t === 2, label: 0.01, value: 2, onCheckChange: o })] });
}, Ye = (e3) => {
  let { sel: t, label: o, value: i, onCheckChange: r3 } = e3;
  return jsxs(z$1, { onClick: (n4) => {
    r3(i), n4.stopPropagation();
  }, gap: 1, className: "oui-cursor-pointer", children: [t ? jsx(xs, {}) : jsx(ys, {}), jsx($$4, { size: "2xs", intensity: t ? 98 : 54, children: o })] });
}, xs = () => jsxs("svg", { width: "16", height: "16", viewBox: "0 0 16 16", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", className: "oui-fill-white", children: [jsx("path", { d: "M8.01 1.333a6.667 6.667 0 1 0 0 13.333 6.667 6.667 0 0 0 0-13.333m0 1.333a5.334 5.334 0 1 1-.001 10.667 5.334 5.334 0 0 1 0-10.667", fill: "#fff", fillOpacity: ".36" }), jsx("circle", { cx: "8", cy: "8", r: "3.333" })] }), ys = () => jsx("svg", { width: "16", height: "16", viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: jsx("path", { d: "M8.01 1.333a6.667 6.667 0 1 0 0 13.333 6.667 6.667 0 0 0 0-13.333m0 1.333a5.334 5.334 0 1 1-.001 10.667 5.334 5.334 0 0 1 0-10.667", fill: "#fff", fillOpacity: ".54" }) });
var xr = (e3) => ({ ...e3 });
var ro = (e3) => {
  let t = xr(e3);
  return jsx(io, { ...t });
};
var ao = (e3) => {
  let { t } = Z$2();
  return jsxs(Cl, { defaultValue: e3.current || "Positions", variant: "contained", trailing: jsx(ro, { pnlNotionalDecimalPrecision: e3.pnlNotionalDecimalPrecision, setPnlNotionalDecimalPrecision: e3.setPnlNotionalDecimalPrecision, unPnlPriceBasis: e3.unPnlPriceBasis, setUnPnlPriceBasic: e3.setUnPnlPriceBasic, hideOtherSymbols: !e3.showAllSymbol, setHideOtherSymbols: (o) => e3.setShowAllSymbol(!o) }), size: "lg", className: "oui-h-full", classNames: { tabsContent: "oui-h-[calc(100%_-_32px)]" }, children: [jsx(Sl, { testid: "oui-testid-dataList-position-tab", value: "Positions", title: `${t("common.positions")}${(e3.positionCount ?? 0) > 0 ? `(${e3.positionCount})` : ""}`, children: jsx(Fs, { ...e3 }) }), jsx(Sl, { testid: "oui-testid-dataList-pending-tab", value: "Pending", title: `${t("orders.status.pending")}${(e3.pendingOrderCount ?? 0) > 0 ? `(${e3.pendingOrderCount})` : ""}`, children: jsx(he$2, { type: Pe$2.pending, ordersStatus: OrderStatus.INCOMPLETE, symbol: e3.showAllSymbol ? void 0 : e3.symbol, onSymbolChange: e3.onSymbolChange, testIds: { tableBody: "oui-testid-dataList-pending-table-body" } }) }), jsx(Sl, { testid: "oui-testid-dataList-tpsl-tab", value: "TP/SL", title: `${t("common.tpsl")}${(e3.tpSlOrderCount ?? 0) > 0 ? `(${e3.tpSlOrderCount})` : ""}`, children: jsx(he$2, { type: Pe$2.tp_sl, ordersStatus: OrderStatus.INCOMPLETE, symbol: e3.showAllSymbol ? void 0 : e3.symbol, onSymbolChange: e3.onSymbolChange, testIds: { tableBody: "oui-testid-dataList-tpsl-table-body" } }) }), jsx(Sl, { testid: "oui-testid-dataList-filled-tab", value: "Filled", title: t("orders.status.filled"), children: jsx(he$2, { type: Pe$2.filled, symbol: e3.showAllSymbol ? void 0 : e3.symbol, pnlNotionalDecimalPrecision: e3.pnlNotionalDecimalPrecision, ordersStatus: OrderStatus.FILLED, onSymbolChange: e3.onSymbolChange, testIds: { tableBody: "oui-testid-dataList-filled-table-body" }, sharePnLConfig: e3.sharePnLConfig }) }), jsx(Sl, { testid: "oui-testid-dataList-positionHistory-tab", value: "Position history", title: t("positions.positionHistory"), children: jsx(Ls, { pnlNotionalDecimalPrecision: e3.pnlNotionalDecimalPrecision, symbol: e3.showAllSymbol ? void 0 : e3.symbol, onSymbolChange: e3.onSymbolChange, sharePnLConfig: e3.sharePnLConfig }) }), jsx(Sl, { testid: "oui-testid-dataList-orderHistory-tab", value: "Order history", title: t("orders.orderHistory"), children: jsx(he$2, { type: Pe$2.orderHistory, pnlNotionalDecimalPrecision: e3.pnlNotionalDecimalPrecision, symbol: e3.showAllSymbol ? void 0 : e3.symbol, onSymbolChange: e3.onSymbolChange, testIds: { tableBody: "oui-testid-dataList-orderHistory-table-body" }, sharePnLConfig: e3.sharePnLConfig }) }), jsx(Sl, { testid: "oui-testid-dataList-liquidation-tab", value: "Liquidation", title: t("positions.liquidation"), children: jsx(js, { symbol: e3.showAllSymbol ? void 0 : e3.symbol }) })] });
}, Fs = (e3) => jsxs(z$1, { direction: "column", width: "100%", height: "100%", children: [jsx(Xe, { pnlNotionalDecimalPrecision: e3.pnlNotionalDecimalPrecision, symbol: e3.showAllSymbol ? void 0 : e3.symbol, unPnlPriceBasis: e3.unPnlPriceBasis }), jsx(te$6, { className: "oui-w-full" }), jsx(_$1, { className: "oui-h-[calc(100%_-_60px)]", width: "100%", children: jsx(Gr$2, { symbol: e3.showAllSymbol ? void 0 : e3.symbol, pnlNotionalDecimalPrecision: e3.pnlNotionalDecimalPrecision, sharePnLConfig: e3.sharePnLConfig, calcMode: e3.calcMode, includedPendingOrder: e3.includedPendingOrder, onSymbolChange: e3.onSymbolChange }) })] });
var so = (e3) => {
  let t = mr({ ...e3 });
  return jsx(ao, { ...t });
};
var lo = (e3) => {
  var _a2, _b2, _c2, _d2;
  return jsxs(_$1, { className: cnBase("oui-grid oui-grid-rows=[auto,1fr] oui-h-full oui-w-full", (_a2 = e3.classNames) == null ? void 0 : _a2.root), style: e3.style, children: [jsx(_$1, { className: "oui-pr-1", children: jsx(Is, { base: e3.base, quote: e3.quote, className: (_b2 = e3.classNames) == null ? void 0 : _b2.listHeader }) }), jsx(Ms, { data: e3.data, isLoading: e3.isLoading, baseDp: e3.baseDp, quoteDp: e3.quoteDp, classNames: (_c2 = e3.classNames) == null ? void 0 : _c2.listItem, className: (_d2 = e3.classNames) == null ? void 0 : _d2.list })] });
}, vr = (e3) => {
  let { key: t, left: o, mid: i, right: r3, classNames: n4 } = e3;
  return jsxs(ia$1, { cols: 3, gapX: 2, width: "100%", className: cnBase("oui-text-xs oui-tabular-nums", n4 == null ? void 0 : n4.root), children: [jsx("div", { className: cnBase("oui-flex-1", n4 == null ? void 0 : n4.left), children: o }), jsx("div", { className: cnBase("oui-flex-1", n4 == null ? void 0 : n4.mid), children: i }), jsx("div", { className: cnBase("oui-flex-1 oui-text-right", n4 == null ? void 0 : n4.right), children: r3 })] }, t);
}, Is = (e3) => {
  let { t } = Z$2();
  return jsx(vr, { left: t("common.time"), mid: `${t("common.price")}(${e3.quote})`, right: `${t("common.qty")}(${e3.base})`, classNames: { root: cnBase("oui-text-base-contrast-54 oui-h-[32px] oui-sticky", e3.className) } });
}, Ms = (e3) => jsx(gf, { dataSource: e3.data, className: cnBase("oui-last-trades-list", "oui-w-full oui-h-full", e3.className, "oui-overflow-auto"), contentClassName: "!oui-space-y-0 oui-pr-[-4px]", renderItem: (t, o) => {
  var _a2, _b2, _c2;
  return jsx(vr, { left: jsx($$4.formatted, { rule: "date", formatString: "HH:mm:ss", children: t == null ? void 0 : t.ts }), mid: $$5(t == null ? void 0 : t.price, { fix: e3.quoteDp }), right: $$5(t == null ? void 0 : t.size, { fix: e3.baseDp }), classNames: { left: cnBase("oui-text-base-contrast-80", (_a2 = e3.classNames) == null ? void 0 : _a2.left), right: cnBase(t.side === OrderSide.BUY ? "oui-text-trade-profit" : "oui-text-trade-loss", (_b2 = e3.classNames) == null ? void 0 : _b2.mid), mid: cnBase(t.side === OrderSide.BUY ? "oui-text-trade-profit" : "oui-text-trade-loss", (_c2 = e3.classNames) == null ? void 0 : _c2.right) } }, o);
} });
var Pr = (e3) => {
  var _a2;
  let { data: t, isLoading: o } = useMarketTradeStream(e3), i = (_a2 = useSymbolsInfo()) == null ? void 0 : _a2[e3], r3 = i == null ? void 0 : i("base"), n4 = i == null ? void 0 : i("quote"), a2 = i == null ? void 0 : i("base_dp"), s = i == null ? void 0 : i("quote_dp");
  return { base: r3, quote: n4, data: t, isLoading: o, baseDp: a2, quoteDp: s };
};
var Be2 = (e3) => {
  let t = Pr(e3.symbol);
  return jsx(lo, { ...t, classNames: e3.classNames, style: e3.style });
};
function Nr(e3) {
  let { t } = Z$2();
  return e3.showFaucet ? jsx(_e$5, { variant: "outlined", fullWidth: true, size: "md", onClick: e3.getFaucet, loading: e3.loading, className: "oui-text-primary-light oui-border-primary-light oui-rounded", "data-testid": "oui-testid-assetView-getFaucet-button", children: t("trading.faucet.getTestUSDC") }) : null;
}
function Fr() {
  let { t: e3 } = Z$2(), { connectedChain: t, namespace: o } = useWalletConnector(), { state: i, account: r3 } = useAccount(), n4 = useConfig(), a2 = n4.get("operatorUrl"), [s, { isMutating: m2 }] = useMutation(`${a2}/v1/faucet/usdc`), [l2, c2] = useState(false), u2 = useMemo(() => !t || !t.id ? false : (i.status === AccountStatusEnum.EnableTrading || i.status === AccountStatusEnum.EnableTradingWithoutConnected) && B$7(parseInt(t.id)), [i, t]);
  return { getFaucet: () => {
    var _a2;
    if (l2) return;
    c2(true);
    let d2 = e3("trading.faucet.getTestUSDC.success", { quantity: o === ChainNamespace.solana ? "100" : "1,000" });
    return s({ chain_id: (_a2 = r3.walletAdapter) == null ? void 0 : _a2.chainId.toString(), user_address: i.address, broker_id: n4.get("brokerId") }).then((h2) => {
      if (c2(false), h2.success) return uo$3.alert({ title: e3("trading.faucet.getTestUSDC"), message: d2, onOk: () => new Promise((f2) => f2(true)) });
      h2.message && toast$2.error(h2.message);
    }, (h2) => {
      toast$2.error(h2.message);
    });
  }, showFaucet: u2, loading: l2 };
}
function co() {
  let e3 = Fr();
  return jsx(Nr, { ...e3 });
}
var dl = () => {
  let { state: e3 } = useAccount(), { wrongNetwork: t, disabledConnect: o } = L$4(), { t: i } = Z$2();
  return useMemo(() => {
    let r3 = { wrongNetwork: { title: i("connector.wrongNetwork"), description: i("connector.wrongNetwork.tooltip"), titleColor: "warning" }, connectWallet: { title: i("connector.connectWallet"), description: i("connector.trade.connectWallet.tooltip"), titleClsName: "oui-text-transparent oui-bg-clip-text oui-gradient-brand" }, notSignedIn: { title: i("connector.signIn"), description: i("connector.trade.signIn.tooltip"), titleColor: "primary" }, disabledTrading: { title: i("connector.enableTrading"), description: i("connector.trade.enableTrading.tooltip"), titleColor: "primary" }, default: { title: "", description: "" } };
    if (o) return r3.connectWallet;
    if (t) return r3.wrongNetwork;
    switch (e3.status) {
      case AccountStatusEnum.NotConnected:
        return r3.connectWallet;
      case AccountStatusEnum.NotSignedIn:
        return r3.notSignedIn;
      case AccountStatusEnum.DisabledTrading:
        return r3.disabledTrading;
      default:
        return r3.default;
    }
  }, [e3.status, t, i]);
}, ho = ({ description: e3, formula: t }) => jsxs("div", { className: "oui-leading-[1.5] oui-text-2xs oui-text-base-contrast-80 oui-min-w-[204px] oui-max-w-[240px]", children: [jsx("span", { children: e3 }), jsx(te$6, { className: "oui-border-white/10", my: 2 }), jsx("span", { children: t })] }), gl = ({ totalValue: e3, visible: t = true, onToggleVisibility: o }) => {
  let { t: i } = Z$2();
  return jsxs(z$1, { direction: "column", gap: 1, className: "oui-text-2xs", itemAlign: "center", children: [jsx($$4.numeral, { visible: t, weight: "bold", size: "2xl", className: Cn$3({ color: "brand" }), as: "div", padding: false, dp: 2, children: e3 ?? "--" }), jsxs(z$1, { gap: 1, itemAlign: "center", children: [jsx($$4, { size: "2xs", color: "neutral", weight: "semibold", children: `${i("trading.asset.myAssets")} (USDC)` }), jsx("button", { onClick: o, children: t ? jsx(on$1, { size: 18, className: "oui-text-base-contrast-54" }) : jsx(nn$1, { size: 18, className: "oui-text-base-contrast-54" }) })] })] });
}, fo = ({ label: e3, description: t, formula: o, visible: i, value: r3, unit: n4, rule: a2, isConnected: s, showPercentage: m2 = false, placeholder: l2 }) => jsxs(z$1, { justify: "between", children: [jsx(Xn$2, { content: jsx(ho, { description: t, formula: o }), children: jsx($$4, { size: "2xs", color: "neutral", weight: "semibold", className: "oui-cursor-pointer oui-border-b oui-border-dashed oui-border-line-12", children: e3 }) }), jsx($$4.numeral, { visible: i, size: "2xs", unit: n4, unitClassName: "oui-text-base-contrast-36 oui-ml-0.5", as: "div", rule: a2, padding: false, dp: 2, placeholder: l2, children: r3 || "--" })] }), fl = ({ visible: e3 = true, freeCollateral: t, marginRatioVal: o, renderMMR: i, isConnected: r3 }) => {
  let [n4, a2] = useLocalStorage("orderly_entry_asset_list_open", false), [s, m2] = useState(n4), { t: l2 } = Z$2(), c2 = useCallback(() => {
    m2((u2) => !u2), setTimeout(() => {
      a2(!s);
    }, 0);
  }, []);
  return jsxs(_$1, { className: "oui-group", children: [jsxs(z$1, { justify: "center", gap: 1, itemAlign: "center", className: "oui-cursor-pointer", onClick: c2, children: [jsx(te$6, { className: "oui-flex-1" }), jsx(nt$3, { size: 12, color: "white", className: cnBase("oui-transition-transform", s && "oui-rotate-180") }), jsx(te$6, { className: "oui-flex-1" })] }), jsxs(_$1, { style: { transform: "translateZ(0)" }, className: cnBase("oui-space-y-1.5 oui-select-none oui-overflow-hidden", "oui-transition-[max-height] oui-duration-150", "group-hover:oui-will-change-[max-height]", s ? "oui-max-h-[69px]" : "oui-max-h-0"), children: [jsx(fo, { label: l2("trading.asset.freeCollateral"), description: l2("trading.asset.freeCollateral.tooltip"), formula: l2("trading.asset.freeCollateral.formula"), visible: e3, value: t === 0 ? "0" : t, unit: "USDC" }), jsx(fo, { label: l2("trading.asset.marginRatio"), description: l2("trading.asset.marginRatio.tooltip"), formula: l2("trading.asset.marginRatio.formula"), visible: e3, value: o, isConnected: r3, rule: "percentages", showPercentage: true, placeholder: "--%" }), jsx(fo, { label: l2("trading.asset.maintenanceMarginRatio"), description: l2("trading.asset.maintenanceMarginRatio.tooltip"), formula: l2("trading.asset.maintenanceMarginRatio.formula"), visible: e3, value: i, rule: "percentages", showPercentage: true, placeholder: "--%" })] })] });
}, bo = ({ networkId: e3, isFirstTimeDeposit: t, totalValue: o, onDeposit: i, onWithdraw: r3, toggleVisible: n4, visible: a2, freeCollateral: s, marginRatioVal: m2, renderMMR: l2, isConnected: c2 }) => {
  let { title: u2, description: g2, titleColor: d2, titleClsName: h2 } = dl(), { t: f2 } = Z$2();
  return jsxs(_$1, { className: "oui-relative", children: [u2 && g2 && jsxs(z$1, { direction: "column", gap: 1, className: "oui-mb-[32px]", children: [jsx($$4, { size: "lg", weight: "bold", color: d2 || "inherit", className: h2, children: u2 }), jsx($$4, { size: "2xs", color: "neutral", weight: "semibold", className: "oui-text-center", children: g2 })] }), jsx(S$1, { networkId: e3, buttonProps: { size: "md", fullWidth: true }, children: t ? jsxs(Fragment$1, { children: [jsx(_$1, { children: jsxs(z$1, { direction: "column", gap: 1, className: "oui-mb-[32px]", children: [jsx($$4.gradient, { size: "lg", weight: "bold", color: "brand", children: f2("trading.asset.startTrading") }), jsx($$4, { size: "2xs", color: "neutral", weight: "semibold", children: f2("trading.asset.startTrading.description") })] }) }), jsxs(_e$5, { "data-testid": "oui-testid-assetView-deposit-button", fullWidth: true, size: "md", onClick: i, children: [jsx(xn$2, { color: "white", opacity: 1 }), jsx($$4, { children: f2("common.deposit") })] }), jsx(_$1, { className: "oui-mt-3", children: jsx(co, {}) })] }) : jsxs(_$1, { className: "oui-space-y-4", children: [jsx(gl, { totalValue: o, visible: a2, onToggleVisibility: n4 }), jsx(fl, { visible: a2, freeCollateral: s, marginRatioVal: m2, renderMMR: l2, isConnected: c2 }), jsxs(z$1, { gap: 3, itemAlign: "center", children: [jsxs(_e$5, { fullWidth: true, color: "secondary", size: "md", onClick: r3, "data-testid": "oui-testid-assetView-withdraw-button", children: [jsx(xn$2, { color: "white", opacity: 1, className: "oui-rotate-180" }), jsx($$4, { children: f2("common.withdraw") })] }), jsxs(_e$5, { "data-testid": "oui-testid-assetView-deposit-button", fullWidth: true, size: "md", onClick: i, children: [jsx(xn$2, { color: "white", opacity: 1 }), jsx($$4, { children: f2("common.deposit") })] })] }), jsx(co, {})] }) }), jsx("div", { className: "oui-pointer-events-none oui-rotate-180 oui-rounded-2xl oui-blur-[200px] oui-top-0 oui-bottom-0 oui-left-0 oui-right-0 oui-absolute", style: { background: "conic-gradient(from -40.91deg at 40.63% 50.41%, rgba(159, 115, 241, 0) -48.92deg, rgba(242, 98, 181, 0) 125.18deg, #5FC5FF 193.41deg, #FFAC89 216.02deg, #8155FF 236.07deg, #789DFF 259.95deg, rgba(159, 115, 241, 0) 311.08deg, rgba(242, 98, 181, 0) 485.18deg)" } })] });
};
var So = () => {
  var _a2;
  let { state: e3 } = useAccount(), { wrongNetwork: t, disabledConnect: o } = L$4(), { totalValue: i } = useCollateral({ dp: 2 }), r3 = t || o || e3.status < AccountStatusEnum.EnableTrading && e3.status !== AccountStatusEnum.EnableTradingWithoutConnected, n4 = useMemo(() => {
    let s = /* @__PURE__ */ new Date(), m2 = /* @__PURE__ */ new Date();
    m2.setDate(s.getDate() - 90);
    let l2 = m2.getTime(), c2 = s.getTime(), u2 = new URLSearchParams();
    return u2.set("page", "1"), u2.set("size", "5"), u2.set("side", "DEPOSIT"), u2.set("status", "COMPLETED"), u2.set("startTime", l2.toString()), u2.set("endTime", c2.toString()), `/v1/asset/history?${u2.toString()}`;
  }, []), { data: a2 } = usePrivateQuery(n4, { formatter: (s) => s });
  return { isFirstTimeDeposit: !r3 && i === 0 && ((_a2 = a2 == null ? void 0 : a2.meta) == null ? void 0 : _a2.total) === 0, totalValue: i };
}, Ir = () => {
  let { t: e3 } = Z$2(), t = useAccountInstance(), o = useMediaQuery(MEDIA_TABLET), { isFirstTimeDeposit: i, totalValue: r3 } = So(), n4 = useConfig("networkId"), { state: a2 } = useAccount(), { freeCollateral: s } = useCollateral({ dp: 2 }), { marginRatio: m2, mmr: l2 } = useMarginRatio(), c2 = a2.status >= AccountStatusEnum.Connected, [{ aggregated: u2, totalUnrealizedROI: g2 }, d2] = usePositionStream(), h2 = useMemo(() => Math.min(10, u2.notional === 0 ? d2.margin_ratio(10) : m2), [m2, u2]);
  useMemo(() => l2 ? new g$6(l2).mul(100).todp(2, 0).toFixed(2) : "", [l2]);
  let v2 = useCallback(async (y2) => {
    let R2;
    return o ? R2 = await uo$3.show($r, { activeTab: y2 }) : R2 = await uo$3.show(Lr$1, { activeTab: y2 }), R2;
  }, [o]), P2 = useCallback(async () => v2("deposit"), [o]), N2 = useEventEmitter(), O2 = useCallback(async () => v2("withdraw"), [o]), x2 = useCallback(async () => t.settle().catch((y2) => {
    if (y2.code === -1104) return toast$2.error(e3("settle.settlement.error")), Promise.reject(y2);
    y2.message.indexOf("Signing off chain messages with Ledger is not yet supported") !== -1 && N2.emit("wallet:sign-message-with-ledger-error", { message: y2.message, userAddress: t.address });
  }).then((y2) => (toast$2.success(e3("settle.settlement.requested")), Promise.resolve(y2))), [t, e3]), [L2, Se3] = useLocalStorage("orderly_assets_visible", true), ie2 = useCallback(() => {
    Se3((y2) => !y2);
  }, [L2]);
  useWalletSubscription({ onMessage: (y2) => {
    let { side: R2, transStatus: E3 } = y2;
    if (E3 === "COMPLETED") {
      let Ce2 = { DEPOSIT: e3("transfer.deposit.completed"), WITHDRAW: e3("transfer.withdraw.completed") }, Ve3 = `${U$5(R2)} completed`;
      toast$2.success(Ce2[R2] || Ve3);
    } else if (E3 === "FAILED") {
      let Ce2 = { DEPOSIT: e3("transfer.deposit.failed"), WITHDRAW: e3("transfer.withdraw.failed") }, Ve3 = `${U$5(R2)} failed`;
      toast$2.error(Ce2[R2] || Ve3);
    }
    N2.emit("wallet:changed", y2);
  } }), useSettleSubscription({ onMessage: (y2) => {
    let { status: R2 } = y2;
    switch (R2) {
      case "COMPLETED":
        toast$2.success(e3("settle.settlement.completed"));
        break;
      case "FAILED":
        toast$2.error(e3("settle.settlement.failed"));
        break;
    }
  } });
  let fe2 = xr$2(s) ?? void 0, De2 = xr$2(h2) ?? void 0, Fe2 = xr$2(l2) ?? void 0, Le3 = xr$2(r3) ?? void 0;
  return { onDeposit: P2, onWithdraw: O2, onSettle: x2, visible: L2, toggleVisible: ie2, networkId: n4, isFirstTimeDeposit: i, totalValue: Le3, status: a2.status, freeCollateral: fe2, marginRatioVal: De2, renderMMR: Fe2, isConnected: c2 };
};
var Co = () => {
  let e3 = Ir();
  return jsx(bo, { ...e3 });
};
var St = createContext({ cellHeight: 22 }), G = () => useContext(St), Ct = (e3) => {
  let [t, o] = useState("quantity"), [i, r3] = useState("quantity");
  return jsx(St.Provider, { value: { cellHeight: e3.cellHeight, onItemClick: e3.onItemClick, mode: t, totalMode: i || "quantity", depth: e3.depth, onModeChange: o, onTotalModeChange: r3, showTotal: e3.showTotal || false, pendingOrders: e3.pendingOrders, symbolInfo: e3.symbolInfo }, children: e3.children });
};
var wt2 = (e3) => {
  let { direction: t = 1 } = e3, o = useMemo(() => {
    let i = Math.max(e3.width, 0);
    return t === 0 ? { transform: `translateX(${i}%)` } : { transform: `translateX(-${i}%)` };
  }, [e3.width]);
  return jsx("div", { className: cnBase("oui-absolute oui-right-[-100%] oui-top-0 oui-h-full oui-w-full oui-transition-transform oui-pointer-events-none", t === 0 && "oui-left-[-100%]", e3.className), style: o });
};
var Hr = (e3) => {
  var _a2;
  let { cellHeight: t, showTotal: o, onItemClick: i, depth: r3, pendingOrders: n4 } = G(), { symbolInfo: a2, currentHover: s } = e3, { base_dp: m2, quote_dp: l2 } = a2, c2 = Number.isNaN(e3.price) ? 0 : e3.accumulated / e3.count * 100, u2 = useMemo(() => E$3(r3 || `${l2}`), [r3, l2]), g2 = Number.isNaN(e3.accumulated) ? "-" : (_a2 = e3.accumulatedAmount) == null ? void 0 : _a2.toString(), d2 = useMemo(() => {
    let h2 = fr$5(e3.price, { dp: u2, padding: true });
    return n4.findIndex((v2) => h2 === fr$5(v2, { dp: u2, padding: true })) !== -1;
  }, [n4, e3.price, r3]);
  return jsxs("div", { className: "oui-flex oui-flex-row oui-pl-3 oui-tabular-nums oui-justify-between oui-text-base-contrast-80 oui-text-xs oui-relative oui-cursor-pointer", style: { height: `${t}px` }, onClick: () => {
    Number.isNaN(e3.price) || Number.isNaN(e3.quantity) || (i == null ? void 0 : i([e3.price, e3.quantity]));
  }, onMouseEnter: e3.onMouseEnter, onMouseLeave: e3.onMouseLeave, children: [jsxs("div", { className: cnBase("oui-basis-7/12 oui-flex oui-flex-row oui-items-center oui-mr-2", o && "oui-basis-5/12"), children: [jsx("div", { className: cnBase("oui-flex-1 oui-text-left", e3.type === "ask" ? "oui-text-trade-loss" : "oui-text-trade-profit"), children: jsx($$4.numeral, { dp: u2, children: e3.price }) }), jsx("div", { className: "oui-flex-1 oui-text-right oui-text-base-contrast-80", children: jsx($$4.numeral, { dp: m2, children: e3.quantity }) })] }), jsxs("div", { className: cnBase("oui-basis-5/12 oui-flex oui-items-center oui-fex-row oui-overflow-hidden oui-relative oui-justify-end", o && "oui-basis-7/12"), children: [jsx("div", { className: cnBase("oui-flex-1 oui-pr-3 oui-text-right", o && "oui-pr-3"), children: jsx($$4.numeral, { dp: m2, className: "oui-z-10", children: e3.accumulated }) }), o && jsx("div", { className: "oui-flex-1 oui-text-right oui-pr-3", children: jsx($$4.numeral, { dp: 2, className: "oui-z-10", children: g2 }) }), jsx(wt2, { width: c2, direction: 0, className: e3.type === "ask" ? "oui-bg-trade-loss/10" : "oui-bg-trade-profit/10" })] }), d2 && jsx("div", { className: cnBase("oui-absolute oui-rounded-full oui-left-[4px] oui-h-[4px] oui-w-[4px] oui-pointer-events-none", e3.type === "ask" && "oui-bg-trade-loss", e3.type === "bid" && "oui-bg-trade-profit"), style: { top: `${t / 2 - 2}px` } }), e3.isHover && jsx("div", { className: "oui-absolute oui-bg-white oui-left-0 oui-right-0 oui-top-0 oui-bottom-0 oui-opacity-[.12]" }), s && jsx("div", { className: cnBase("oui-absolute oui-left-0 oui-right-0", e3.type === "ask" && "oui-top-0", e3.type === "bid" && "oui-bottom-0"), children: jsx(te$6, { lineStyle: "dashed", className: cnBase("oui-w-full", e3.type === "bid" && "oui-border-trade-profit", e3.type === "ask" && "oui-border-trade-loss") }) })] });
};
var Tt2 = (e3) => {
  let { data: t, type: o } = e3, { symbolInfo: i, depth: r3 } = G(), n4 = useCallback(() => {
    if (((t == null ? void 0 : t.length) || 0) === 0) return null;
    if (o === "ask") {
      let c2 = t.findIndex((u2) => !Number.isNaN(u2[0]));
      return c2 != -1 ? t[c2] : null;
    } else {
      for (let c2 = t.length - 1; c2 >= 0; c2--) {
        let u2 = t[c2];
        if (!Number.isNaN(u2[0])) return u2;
      }
      return null;
    }
  }, [t, o]), a2 = useMemo(() => (r3 == null ? void 0 : r3.toString().includes(".")) ? r3.toString().split(".")[1].length : 0, [r3]), s = useMemo(() => t.reduce((c2, u2) => Math.max(c2, u2[1]), 0), [t]), [m2, l2] = useState(-1);
  return jsx("div", { className: "oui-order-book-list oui-flex oui-flex-col oui-gap-[1px]", children: t.map((c2, u2) => jsx(Xl, { index: u2, item: c2, countQty: e3.countQty, setHoverIndex: l2, hoverIndex: m2, type: o, maxQty: s, priceDp: a2, symbolInfo: i, findMaxItem: n4 }, u2)) });
}, Xl = (e3) => {
  let { index: t, item: o, setHoverIndex: i, type: r3, maxQty: n4, hoverIndex: a2, priceDp: s, symbolInfo: m2 } = e3, { base: l2, quote: c2, base_dp: u2, quote_dp: g2 } = m2, { t: d2 } = Z$2(), h2 = a2 !== -1 ? r3 === "ask" ? t >= a2 : t <= a2 : false, [f2, v2] = useState(false), P2 = (O2) => {
    if (O2 === null) return { sumQty: 0, sumQtyAmount: 0, avgPrice: 0 };
    let x2 = { sumQty: 0, sumQtyAmount: 0 };
    return Number.isNaN(O2[2]) || (x2 = { sumQty: O2[2], sumQtyAmount: O2[3] }), { ...x2, avgPrice: x2.sumQtyAmount == 0 ? 0 : x2.sumQtyAmount / x2.sumQty };
  }, N2 = P2(o);
  return N2.avgPrice === 0 && (N2 = P2(e3.findMaxItem())), jsxs(Wr$2, { open: f2, onOpenChange: v2, children: [jsx(Gr$3, { children: jsx(Hr, { background: "", price: o[0], quantity: o[1], accumulated: o[2], count: e3.countQty, type: e3.type, accumulatedAmount: o[3], maxQty: n4, isHover: h2, currentHover: a2 === t, symbolInfo: m2, onMouseEnter: () => {
    i(t), v2(true);
  }, onMouseLeave: () => {
    i(-1), v2(false);
  } }) }), jsxs(Ro$4, { className: cnBase("oui-max-w-[400px] oui-w-full oui-text-2xs oui-shadow-md oui-rounded-base oui-p-3 oui-bg-base-6 oui-flex oui-flex-col oui-gap-2"), align: r3 === "ask" ? "end" : "start", alignOffset: -25.4, side: "left", sideOffset: 2, onPointerEnter: (O2) => O2.preventDefault(), children: [jsx(vo, { title: `${d2("common.avgPrice")}`, content: N2.avgPrice, contentDp: s }), jsx(vo, { title: `${d2("trading.orderBook.sum")} (${l2})`, content: N2.sumQty, contentDp: u2 }), jsx(vo, { title: `${d2("trading.orderBook.sum")} (${c2})`, content: N2.sumQtyAmount, contentDp: g2 }), jsx(Pt$3, { className: "oui-fill-base-6", style: { transform: r3 === "ask" ? "translateX(80%)" : "translateX(-80%)" } })] })] });
}, vo = (e3) => {
  let { title: t, content: o, contentDp: i } = e3;
  return jsxs("div", { className: "oui-flex oui-flex-row oui-justify-between oui-gap-4", children: [jsx("div", { className: "oui-text-base-contrast-36", children: t }), jsx("div", { className: "oui-text-right", children: jsx($$4.numeral, { dp: i, children: o }) })] });
};
var Vr = (e3) => {
  let { data: t } = e3, o = useMemo(() => {
    let i = Number.NaN, r3 = t.length - 1;
    for (; Number.isNaN(i) && r3 > 0; ) i = t[r3][2], r3--;
    return i;
  }, [t]);
  return jsx(Tt2, { type: "bid", data: t, countQty: o });
};
var qr = (e3) => {
  let { data: t } = e3, o = useMemo(() => {
    let i = Number.NaN, r3 = t.length, n4 = 0;
    for (; Number.isNaN(i) && n4 < r3; ) i = t[n4][2], n4++;
    return i;
  }, [t]);
  return jsx(Tt2, { type: "ask", data: t, countQty: o });
};
var Pt = (e3) => {
  let { markPrice: t = 0, lastPrice: o, quote_dp: i, className: r3, iconSize: n4 = 18 } = e3, [a2, s] = o, m2 = s < a2, l2 = s > a2;
  return jsxs(z$1, { gap: 1, className: cnBase(l2 ? "oui-text-trade-profit" : m2 ? "oui-text-trade-loss" : "", r3), children: [jsx($$4.numeral, { dp: i, intensity: 98, children: s }), jsxs(_$1, { width: 19, children: [m2 && jsx(xn$2, { size: n4, color: "danger", opacity: 1 }), l2 && jsx(fn$1, { size: n4, color: "success", opacity: 1 })] })] });
};
var Nt = (e3) => {
  let { isMobile: t } = Ao$6();
  return t ? jsx(mc, { ...e3 }) : jsx(uc, { ...e3 });
}, uc = (e3) => {
  let { quote_dp: t, className: o, iconSize: i = 18 } = e3, { t: r3 } = Z$2();
  return jsx(Xn$2, { content: r3("trading.orderBook.markPrice.tooltip"), className: "oui-max-w-[270px]", children: jsxs(z$1, { gap: 1, className: cnBase("oui-cursor-pointer oui-text-2xs", o), children: [jsx(Kr, { size: i }), jsx($$4.numeral, { dp: t, color: "warning", className: "oui-underline oui-text-base oui-decoration-dashed oui-decoration-1 oui-underline-offset-4 oui-decoration-warning-darken", children: e3.markPrice })] }) });
}, mc = (e3) => {
  let { quote_dp: t, className: o, iconSize: i = 18 } = e3, [r3, n4] = useState(false), { t: a2 } = Z$2();
  return jsxs(Fragment$1, { children: [jsxs(z$1, { gap: 1, className: cnBase("oui-cursor-pointer oui-text-2xs", o), onClick: () => {
    n4(true);
  }, children: [jsx(Kr, { size: i }), jsx($$4.numeral, { dp: t, color: "warning", className: "oui-underline oui-decoration-dashed oui-decoration-1 oui-underline-offset-4 oui-decoration-warning-darken", children: e3.markPrice })] }), jsx(me$4, { size: "xs", open: r3, onOpenChange: n4, title: a2("common.tips"), actions: { primary: { label: a2("common.ok"), onClick: () => n4(false) } }, children: jsx($$4, { children: a2("trading.orderBook.markPrice.tooltip") }) })] });
}, Kr = (e3) => jsx("svg", { width: e3.size, height: e3.size, viewBox: "0 0 18 18", fill: "currenColor", xmlns: "http://www.w3.org/2000/svg", className: "oui-fill-warning-darken", children: jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M3.75 1.5a.75.75 0 0 1 .75.75h6a.75.75 0 0 1 .75.75v1.5h3a.75.75 0 0 1 .75.75V12a.75.75 0 0 1-.75.75H7.5a.75.75 0 0 1-.75-.75v-1.5H4.5v5.25a.75.75 0 0 1-1.5 0V2.25a.75.75 0 0 1 .75-.75M4.5 9h5.25V3.75H4.5zm6.75-3v3.75a.75.75 0 0 1-.75.75H8.25v.75h5.25V6z" }) });
var Jr = (e3) => {
  let { markPrice: t = 0, lastPrice: o, asks: i, bids: r3, symbolInfo: n4 } = e3, { showTotal: a2 } = G();
  return jsxs("div", { className: "oui-flex oui-flex-row oui-pl-3 oui-tabular-nums oui-justify-between oui-text-base-contrast-80 oui-text-xs oui-relative oui-cursor-pointer oui-py-[6px]", children: [jsxs("div", { className: cnBase("oui-basis-7/12 oui-flex oui-flex-row oui-items-center oui-mr-2 oui-justify-between", a2 && "oui-basis-5/12"), children: [jsx(Pt, { markPrice: t, lastPrice: o, quote_dp: n4.quote_dp, className: "oui-text-base" }), jsx(Nt, { markPrice: t, quote_dp: n4.quote_dp })] }), jsx("div", { className: cnBase("oui-basis-5/12 oui-flex oui-items-center oui-fex-row oui-overflow-hidden oui-relative oui-justify-end", a2 && "oui-basis-7/12", "oui-pr-3"), children: jsx(bc, { asks: i, bids: r3 }) })] });
}, bc = (e3) => {
  let { asks: t, bids: o } = e3, { t: i } = Z$2(), r3 = useMemo(() => {
    if (o.length === 0 && t.length === 0) return 0;
    let n4 = Number.isNaN(o[0][0]) ? 0 : o[0][0], a2 = t.reverse().findIndex((l2) => !Number.isNaN(l2[0])), s = 0;
    a2 !== -1 && (s = Number.isNaN(t[a2][0]) ? 0 : t[a2][0]);
    let m2 = new g$6(s).sub(n4).div(new g$6(s).add(n4).div(2));
    return Math.ceil(m2.toNumber() * 1e6 + 0.1) / 1e4;
  }, [t, o]);
  return jsx("div", { children: jsx(Xn$2, { content: i("trading.orderBook.spreadRatio.tooltip"), className: "oui-max-w-[240px]", children: jsx($$4, { size: "2xs", intensity: 36, className: "oui-cursor-pointer oui-underline oui-decoration-dashed oui-decoration-1 oui-underline-offset-4 oui-decoration-base-contrast-36", children: `${r3}%` }) }) });
};
var jr = (e3) => {
  let { showTotal: t } = G(), { t: o } = Z$2();
  return jsxs(z$1, { pl: 3, justify: "between", className: "oui-py-[6px]", children: [jsxs(z$1, { gap: 1, className: cnBase("oui-basis-7/12", t && "oui-basis-1/2"), children: [jsx(_$1, { width: "100%", children: jsx(Dt, { id: "oui-order-book-header-price", children: `${o("common.price")}(${e3.quote})` }) }), jsx(_$1, { width: "100%", children: jsx(Dt, { id: "oui-order-book-header-qty", justifyEnd: true, children: `${o("common.qty")}(${e3.base})` }) })] }), jsxs(z$1, { gap: 1, pr: 3, className: cnBase("oui-basis-5/12", t && "oui-basis-1/2"), children: [jsx(_$1, { width: "100%", children: jsx(Dt, { id: "oui-order-book-header-total-base", justifyEnd: true, children: `${o("common.total")}(${e3.base})` }) }), t && jsx(_$1, { width: "100%", children: jsx(Dt, { id: "oui-order-book-header-total-quote", justifyEnd: true, children: `${o("common.total")}(${e3.quote})` }) })] })] });
}, Dt = (e3) => {
  let { children: t, justifyEnd: o = false } = e3;
  return jsx(z$1, { id: e3.id, className: cnBase("oui-text-base-contrast-36 oui-text-xs oui-items-end", o && "oui-justify-end"), children: t });
};
var tn = (e3) => {
  let t = useMemo(() => e3.depths.map((o) => ({ value: o, label: `${o}` })), [e3.depths]);
  return jsx(_$1, { pl: 3, width: 97, className: "oui-py-[10px]", children: jsx(ke$2.options, { options: t, size: "xs", value: e3.value, onValueChange: (o) => {
    var _a2;
    (_a2 = e3.onChange) == null ? void 0 : _a2.call(e3, o);
  } }) });
};
var on = (e3) => {
  let { lastPrice: t, markPrice: o, quote: i, base: r3, isLoading: n4, onDepthChange: a2 } = e3, s = useRef(null), [m2, l2] = useState(false), c2 = [{ left: 370, right: 600 }, { left: 740, right: 800 }];
  return useEffect(() => {
    let u2 = new ResizeObserver((d2) => {
      for (let h2 of d2) {
        let { inlineSize: f2 } = h2.borderBoxSize[0];
        c2.reduce((P2, N2) => P2 + (f2 >= N2.left && f2 < N2.right ? 1 : 0), 0);
        l2(f2 >= 360);
      }
    }), g2 = s.current;
    return g2 && u2.observe(g2), () => {
      g2 && u2.unobserve(g2);
    };
  }, []), jsx(Ct, { cellHeight: e3.cellHeight ?? 20, onItemClick: e3.onItemClick, depth: e3.activeDepth, showTotal: m2, pendingOrders: e3.pendingOrders || [], symbolInfo: e3.symbolInfo, children: jsxs(ia$1, { cols: 1, rows: 5, id: "oui-orderbook-desktop", ref: s, className: "oui-grid-rows-[auto,auto,1fr,auto,1fr] oui-relative oui-h-full oui-w-full", children: [jsx(tn, { depths: e3.depths, value: e3.activeDepth, onChange: a2 }), jsx(jr, { quote: i, base: r3 }), jsx(qr, { data: [...e3.asks] }), jsx(Jr, { lastPrice: t, markPrice: o, asks: [...e3.asks], bids: [...e3.bids], symbolInfo: e3.symbolInfo }), jsx(Vr, { data: [...e3.bids] }), n4 && jsx("div", { className: "oui-absolute oui-left-0 oui-top-0 oui-right-0 oui-bottom-0 oui-z-10 oui-flex oui-items-center oui-justify-center oui-bg-bg-8/70", children: jsx(we$5, {}) })] }) });
};
var nn = (e3) => {
  let { t } = Z$2(), { mode: o, onModeChange: i } = G(), r3 = useMemo(() => o === "amount" ? e3.quote : e3.base, [o, e3.quote, e3.base]), n4 = useMemo(() => t(o === "amount" ? "trading.orderBook.column.value" : "common.qty"), [o, t]);
  return jsxs(z$1, { justify: "between", width: "100%", className: "oui-text-base-contrast-36 oui-text-2xs oui-py-[5px]", children: [jsxs(z$1, { direction: "column", itemAlign: "start", id: "oui-order-book-header-price", children: [jsx($$4, { children: t("common.price") }), jsx($$4, { children: `(${e3.quote})` })] }), jsxs(z$1, { direction: "column", itemAlign: "end", className: "oui-cursor-pointer", onClick: () => i == null ? void 0 : i(o === "amount" ? "quantity" : "amount"), children: [jsx($$4, { children: n4 }), jsx($$4, { children: `(${r3})` })] })] });
};
var ln = (e3) => {
  let t = e3.accumulated / e3.count * 100, { cellHeight: o, onItemClick: i, depth: r3, showTotal: n4, symbolInfo: a2 } = useContext(St), { base_dp: s, quote_dp: m2 } = a2, l2 = Number.isNaN(e3.quantity) ? "-" : e3.mode === "amount" ? new g$6(e3.quantity).mul(e3.price).toString() : e3.quantity;
  n4 && (l2 = e3.quantity);
  let c2 = useMemo(() => E$3(r3 || `${m2}`), [r3, m2]);
  return jsxs(_$1, { className: cnBase("oui-overflow-hidden oui-relative oui-cursor-pointer oui-tabular-nums oui-text-2xs oui-w-full", n4 && "oui-flex-1"), style: { height: `${o}px` }, onClick: (u2) => {
    Number.isNaN(e3.price) || Number.isNaN(e3.quantity) || (i == null ? void 0 : i([e3.price, e3.quantity]));
  }, children: [jsxs(z$1, { justify: "between", children: [jsx($$4.numeral, { color: e3.type === "bid" ? "buy" : "sell", dp: c2, children: e3.price }), jsx($$4.numeral, { dp: e3.mode === "amount" ? 2 : s, className: "oui-text-base-contrast-80", children: l2 })] }), Number.isNaN(t) || n4 ? null : jsx(wt2, { width: t, className: e3.type === "ask" ? "oui-bg-trade-loss/20" : "oui-bg-trade-profit/20" })] });
};
var Ot = (e3) => {
  let { data: t } = e3, { mode: o } = G();
  return jsx(_$1, { className: "oui-order-book-list oui-flex oui-flex-col oui-gap-[1px] oui-w-full", children: t.map((i, r3) => jsx(ln, { background: "", price: i[0], quantity: i[1], accumulated: i[2], count: e3.countQty, type: e3.type, mode: o }, r3)) });
};
var un = (e3) => {
  let { data: t } = e3, o = useMemo(() => {
    let i = Number.NaN, r3 = t.length - 1;
    for (; Number.isNaN(i) && r3 > 0; ) i = t[r3][2], r3--;
    return i;
  }, [t]);
  return jsx(Ot, { type: "bid", data: t, countQty: o });
};
var mn = (e3) => {
  let { data: t } = e3, o = useMemo(() => {
    let i = Number.NaN, r3 = t.length, n4 = 0;
    for (; Number.isNaN(i) && n4 < r3; ) i = t[n4][2], n4++;
    return i;
  }, [t]);
  return jsx(Ot, { type: "ask", data: t, countQty: o });
};
var gn = (e3) => {
  let { symbolInfo: t } = G(), { quote_dp: o } = t;
  return jsxs(z$1, { id: "oui-order-book-mark-price", className: "oui-py-[6px]", width: "100%", justify: "between", children: [jsx(Pt, { markPrice: e3.markPrice, lastPrice: e3.lastPrice, quote_dp: o, className: "oui-text-sm", iconSize: 14 }), jsx(Nt, { markPrice: e3.markPrice, quote_dp: o, className: "oui-text-2xs", iconSize: 12 })] });
};
var pn = (e3) => {
  let t = useMemo(() => e3.depth.map((o) => ({ value: o, label: `${o}` })), [e3.depth]);
  return jsx(_$1, { id: "oui-order-book-depth", className: "oui-pt-2  oui-w-full", children: jsx(jg$1, { options: t, fullWidth: true, size: "sm", value: e3.value, className: "oui-text-2xs oui-text-base-contrast-54", onValueChange: (o) => {
    var _a2;
    (_a2 = e3.onChange) == null ? void 0 : _a2.call(e3, o);
  } }) });
};
var Ro = (e3) => {
  let t = e3.data.est_funding_rate, o = e3.data.countDown, { t: i } = Z$2();
  return jsxs(z$1, { direction: "column", itemAlign: "start", pb: 2, children: [jsx($$4, { intensity: 36, size: "2xs", children: i("trading.fundingRate.predFundingRate") }), t === null ? "--" : jsxs("div", { className: "orderly-flex orderly-gap-1 oui-text-2xs oui-text-base-contrast-36", children: [jsx($$4.numeral, { coloring: true, suffix: "%", dp: 4, children: t ?? "--" }), jsx("span", { children: " in" }), jsx("span", { children: " " + o })] })] });
};
var Ao = (e3) => ({ data: useFundingRate(e3) });
var Io = (e3) => {
  let t = Ao(e3.symbol);
  return jsx(Ro, { ...t });
};
var xn = (e3) => {
  let { lastPrice: t, markPrice: o, quote: i, base: r3, isLoading: n4, onDepthChange: a2 } = e3, s = `PERP_${e3.symbolInfo.base}_${e3.symbolInfo.quote}`;
  return jsx(Ct, { cellHeight: e3.cellHeight ?? 20, onItemClick: e3.onItemClick, depth: e3.activeDepth, pendingOrders: [], showTotal: false, symbolInfo: e3.symbolInfo, children: jsxs(z$1, { direction: "column", p: 2, id: "oui-orderbook-mobile", className: cnBase("oui-h-full oui-wfull oui-relative", e3.className), justify: "start", itemAlign: "start", children: [jsx(Io, { symbol: s }), jsx(nn, { quote: i, base: r3 }), jsx(mn, { data: e3.asks }), jsx(gn, { lastPrice: t, markPrice: o }), jsx(un, { data: e3.bids }), jsx(pn, { depth: e3.depths || [], value: e3.activeDepth, onChange: a2 }), n4 && jsx("div", { className: "oui-absolute oui-left-0 oui-top-0 oui-right-0 oui-bottom-0 oui-z-10 oui-flex oui-items-center oui-justify-center oui-bg-base-800/70 oui-h-full oui-min-h-[420px]", children: jsx(we$5, {}) })] }) });
};
var _o = (e3) => jsx(_$1, { className: "oui-font-semibold", width: "100%", height: "100%", children: e3.isMobile ? jsx(xn, { level: e3.level, asks: e3.asks, bids: e3.bids, markPrice: e3.markPrice, lastPrice: e3.lastPrice, depths: e3.depths, activeDepth: e3.selDepth, base: e3.base, quote: e3.quote, isLoading: e3.isLoading, onItemClick: e3.onItemClick, cellHeight: e3.cellHeight, onDepthChange: e3.onDepthChange, className: e3.className, symbolInfo: e3.symbolInfo }) : jsx(on, { level: e3.level, asks: e3.asks, bids: e3.bids, markPrice: e3.markPrice, lastPrice: e3.lastPrice, depths: e3.depths, activeDepth: e3.selDepth, base: e3.base, quote: e3.quote, isLoading: e3.isLoading, onItemClick: e3.onItemClick, cellHeight: e3.cellHeight, onDepthChange: e3.onDepthChange, className: e3.className, pendingOrders: e3.pendingOrders, symbolInfo: e3.symbolInfo }) });
var je = 20, Cn = 104, Ho = (e3) => {
  let { symbol: t, height: o } = e3, i = useSymbolsInfo()[e3.symbol], [r3, n4] = useState(je), [a2, s] = useState(10), { base: m2, quote: l2, quote_dp: c2 } = $e(i), [u2, { onDepthChange: g2, isLoading: d2, onItemClick: h2, depth: f2, allDepths: v2 }] = useOrderbookStream(t, void 0, { level: a2 }), P2 = su(t);
  useEffect(() => {
    if (o) {
      let L2 = Math.floor((o - Cn) / ((je + 1) * 2)), Se3 = (je + 1) * 2 * L2, ie2 = o - Cn - Se3;
      ie2 > 10 ? n4(je + ie2 / L2 / 2) : n4(je), s(L2);
    }
  }, [o]);
  let N2 = useMemo(() => typeof f2 > "u" || typeof c2 > "u" ? void 0 : O$9(f2), [f2, c2]), O2 = useMemo(() => (v2 == null ? void 0 : v2.map((L2) => O$9(L2))) || [], [v2, c2]), { isMobile: x2 } = Ao$6();
  return { level: a2, asks: u2 == null ? void 0 : u2.asks, bids: u2 == null ? void 0 : u2.bids, markPrice: u2 == null ? void 0 : u2.markPrice, lastPrice: u2 == null ? void 0 : u2.middlePrice, depths: O2, selDepth: N2, base: m2, quote: l2, isLoading: d2, onItemClick: h2, cellHeight: r3, onDepthChange: g2, pendingOrders: P2, symbolInfo: $e(i), isMobile: x2 };
}, su = (e3) => {
  let [t] = useOrderStream({ status: OrderStatus.INCOMPLETE, symbol: e3 });
  return useMemo(() => t == null ? void 0 : t.filter((r3) => r3.symbol === e3).reduce((r3, n4) => {
    let a2 = n4.price || n4.trigger_price || 0;
    return [...r3, a2];
  }, []), [t, e3]);
};
var Ie = (e3) => {
  let t = Ho({ symbol: e3.symbol, height: e3.height });
  return jsx(_o, { ...t, className: e3.className });
};
var Eo = (e3) => {
  let { riskRate: t, riskRateColor: o, isConnected: i, currentLeverage: r3, maxLeverage: n4 } = e3, { isHigh: a2, isMedium: s, isLow: m2, isDefault: l2 } = o, { wrongNetwork: c2 } = L$4(), { t: u2 } = Z$2(), g2 = c2 ? "" : a2 ? "oui-text-danger" : s ? "oui-text-warning-darken" : m2 ? Cn$3({ color: "brand" }) : "";
  return jsxs(_$1, { "data-risk": "", className: "oui-space-y-2", children: [jsx(z$1, { itemAlign: "center", justify: "start", className: "oui-w-full oui-bg-base-6 oui-rounded-full oui-h-2 oui-px-[1px]", children: jsx(_$1, { className: c2 ? "oui-bg-gradient-to-r oui-opacity-20 oui-from-[#26fefe]  oui-via-[#ff7d00] oui-to-[#d92d6b] oui-h-1.5 oui-rounded-full" : a2 ? "oui-bg-gradient-to-tr oui-from-[#791438] oui-to-[#ff447c] oui-h-1.5 oui-rounded-full" : s ? "oui-bg-gradient-to-tr oui-from-[#792e00] oui-to-[#ffb65d] oui-h-1.5 oui-rounded-full" : m2 ? "oui-bg-gradient-to-tr oui-from-[#59b0fe] oui-to-[#26fefe] oui-h-1.5 oui-rounded-full" : "oui-bg-gradient-to-r oui-opacity-20 oui-from-[#26fefe]  oui-via-[#ff7d00] oui-to-[#d92d6b] oui-h-1.5 oui-rounded-full", style: t && t !== "--" ? { width: t } : { width: "100%" } }) }), jsxs(z$1, { className: "oui-gap-2", children: [jsxs(z$1, { direction: "column", itemAlign: "start", className: "oui-flex-1", children: [jsx(Xn$2, { content: jsx(ho, { description: u2("trading.riskRate.tooltip"), formula: u2("trading.riskRate.formula") }), children: jsx($$4, { size: "2xs", color: "neutral", weight: "semibold", className: "oui-cursor-pointer oui-border-b oui-border-dashed oui-border-b-white/10", children: u2("trading.riskRate") }) }), jsx($$4, { size: "xs", color: "neutral", weight: "semibold", className: cnBase(g2), children: t ?? "--" })] }), jsxs(z$1, { direction: "column", itemAlign: "end", className: "oui-flex-1", children: [jsx($$4, { size: "2xs", color: "neutral", weight: "semibold", className: "oui-cursor-pointer", children: u2("leverage.maxAccountLeverage") }), jsxs(z$1, { className: "oui-gap-1", children: [jsx($$4.numeral, { dp: 2, padding: false, suffix: r3 ? "x" : void 0, children: r3 ?? "--" }), jsx("span", { className: "oui-text-base-contrast-54", children: "/" }), jsxs("button", { className: "oui-flex oui-items-center oui-gap-1", onClick: () => {
    uo$3.show(U$2, { currentLeverage: 5 });
  }, "data-testid": "oui-testid-riskRate-leverage-button", children: [jsx($$4.numeral, { dp: 2, padding: false, suffix: n4 ? "x" : void 0, "data-testid": "oui-testid-riskRate-leverage-value", children: n4 ?? "--" }), typeof n4 < "u" && n4 !== null && jsx(Ja, { size: 12, color: "white" })] })] })] })] })] });
};
var Su = (e3) => {
  if (e3 === null) return { isHigh: false, isMedium: false, isLow: false, isDefault: true };
  let t = e3 < 40, o = e3 >= 40 && e3 < 80, i = e3 >= 80;
  return { isHigh: i, isMedium: o, isLow: t, isDefault: !t && !o && !i };
}, Nn = () => {
  let { state: e3 } = useAccount(), t = e3.status >= AccountStatusEnum.EnableTrading || e3.status === AccountStatusEnum.EnableTradingWithoutConnected, { marginRatio: o, currentLeverage: i, mmr: r3 } = useMarginRatio(), [n4] = useLeverage(), a2 = useMemo(() => !t || o === null || r3 === null ? "--" : o === 0 || r3 === 0 ? "0%" : `${new g$6(r3).div(o).mul(100).todp(2, g$6.ROUND_UP).toString().replace(/\.?0+$/, "")}%`, [t, o, r3]), s = a2 === "--" ? null : parseFloat(a2), m2 = useMemo(() => Su(s), [s]), l2 = xr$2(i), c2 = xr$2(n4);
  return { riskRate: xr$2(a2), riskRateColor: m2, isConnected: t, currentLeverage: l2, maxLeverage: c2 };
};
var Vo = () => {
  let e3 = Nn();
  return jsx(Eo, { ...e3 });
};
var qo = (e3) => {
  var _a2;
  return jsx("div", { ref: e3.containerRef, className: "oui-h-full", children: (((_a2 = e3.containerSize) == null ? void 0 : _a2.width) || 0) >= 572 ? jsx(ku, { ...e3 }) : jsx(Du, { ...e3 }) });
}, ku = (e3) => {
  var _a2;
  let { t } = Z$2();
  return jsxs(ia$1, { cols: 2, width: "100%", gap: 3, className: "oui-auto-rows-fr", style: { height: (_a2 = e3.containerSize) == null ? void 0 : _a2.height }, children: [jsxs(z$1, { direction: "column", itemAlign: "start", pt: 3, pb: 3, r: "2xl", className: "oui-bg-base-9", children: [jsx(Fn, { title: t("trading.orderBook"), className: "oui-pl-3 oui-text-sm" }), jsx(Ie, { symbol: e3.symbol, height: e3.containerSize ? e3.containerSize.height - 29 - 24 : void 0 })] }), jsxs(z$1, { direction: "column", itemAlign: "start", py: 3, r: "2xl", className: "oui-bg-base-9 oui-h-full", children: [jsx(Fn, { title: t("trading.lastTrades"), className: "oui-text-sm oui-px-3" }), jsx(Be2, { symbol: e3.symbol, style: { height: e3.containerSize && e3.containerSize.height - 29 - 24 }, classNames: { listHeader: "oui-px-3", list: "oui-px-3" } })] })] });
}, Du = (e3) => {
  var _a2;
  let { t } = Z$2();
  return jsx(_$1, { pt: 3, pb: 3, pr: 0, r: "2xl", className: "oui-bg-base-9", style: { maxHeight: (_a2 = e3.containerSize) == null ? void 0 : _a2.height }, children: jsxs(Cl, { value: e3.tab, variant: "contained", onValueChange: (o) => {
    e3.setTab(o);
  }, classNames: { tabsList: "oui-pl-3" }, size: "lg", children: [jsx(Sl, { value: "orderBook", title: t("trading.orderBook"), children: jsx(Ie, { symbol: e3.symbol, height: e3.containerSize ? e3.containerSize.height - 29 - 18 : void 0 }) }), jsx(Sl, { value: "lastTrades", title: t("trading.lastTrades"), children: jsx(Be2, { symbol: e3.symbol, style: { height: e3.containerSize && e3.containerSize.height - 29 - 18 }, classNames: { root: "oui-pt-[6px]", listHeader: "oui-px-3", list: "oui-px-3" } }) })] }) });
}, Fn = (e3) => jsx($$4, { size: "base", intensity: 80, className: cnBase("oui-pb-[5px]", e3.className), children: e3.title });
var Go = (e3) => {
  let [t, o] = useState(void 0), [i, r3] = useState("orderBook"), n4 = useRef();
  return useEffect(() => {
    let a2 = new ResizeObserver((m2) => {
      for (let l2 of m2) {
        let { width: c2, height: u2 } = l2.contentRect;
        o({ width: c2, height: u2 });
      }
    }), s = n4.current;
    return s && a2.observe(s), () => {
      s && a2.unobserve(s);
    };
  }, []), { symbol: e3, containerSize: t, containerRef: n4, tab: i, setTab: r3 };
};
var Uo = (e3) => {
  let t = Go(e3.symbol);
  return jsx(qo, { ...t });
};
var In = (e3) => {
  let { onMouseDown: t, mode: o = "horizontal", ...i } = e3, r3 = useMemo(() => {
    var _a2;
    return (_a2 = e3.className) == null ? void 0 : _a2.split(" ").includes("disable");
  }, [e3.className]), n4 = useMemo(() => {
    var _a2;
    return (_a2 = e3.className) == null ? void 0 : _a2.split(" ").filter((a2) => a2 !== "disable");
  }, [e3.className]);
  return jsx("div", { ...i, className: cnBase(n4, "!oui-transition-none", "!oui-shadow-none !oui-bg-transparent", "hover:!oui-bg-primary-light hover:!oui-shadow-[0px_0px_4px_0px] hover:!oui-shadow-primary-light/80", "active:!oui-bg-primary-light active:!oui-shadow-[0px_0px_4px_0px] active:!oui-shadow-primary-light/80", "focus:!oui-bg-primary-light focus:!oui-shadow-[0px_0px_4px_0px] focus:!oui-shadow-primary-light/80", o === "horizontal" ? "!oui-w-[2px] !oui-min-w-[2px]  !oui-mx-1" : "!oui-h-[2px] !oui-min-h-[2px]  !oui-my-1", r3 && "oui-pointer-events-none"), children: jsx("div", { onMouseDown: t, className: cnBase("!oui-transition-none", o === "horizontal" ? "after:!oui-w-[2px]" : "after:!oui-h-[2px]", "after:!oui-bg-transparent after:!oui-shadow-transparent") }) });
};
var _e2 = (e3) => {
  let { onSizeChange: t, ...o } = e3;
  return jsx(Split, { ...o, lineBar: true, renderBar: (i) => jsx(In, { ...i, mode: e3.mode }), onDragEnd: (i, r3, n4) => {
    t == null ? void 0 : t(`${r3}`);
  } });
};
var Qo = (e3) => {
  let { t } = Z$2();
  return jsx("button", { onClick: (o) => {
    uo$3.show(A$3, { bridgeLessOnly: false, isWrongNetwork: e3.wrongNetwork }).then((i) => {
      (i == null ? void 0 : i.chainId) && e3.setCurrentChainId(i == null ? void 0 : i.chainId), toast$2.success(t("connector.networkSwitched"));
    }, (i) => {
    });
  }, children: jsxs(_$1, { className: "oui-relative oui-rounded-t-[6px] oui-rounded-bl-[6px] oui-rounded-br-[3px] oui-bg-base-5 oui-px-2 oui-h-7 oui-flex oui-items-center", children: [jsx(kr$2, { chainId: e3.currentChainId, size: "2xs" }), jsx("div", { className: "oui-absolute oui-right-0 oui-bottom-0", children: jsxs("svg", { width: "9", height: "9", viewBox: "0 0 9 9", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsx("path", { d: "M9 6V0L0 9h6a3 3 0 0 0 3-3", fill: "url(#a)" }), jsx("defs", { children: jsxs("linearGradient", { id: "a", x1: "9", y1: "4.5", x2: "0", y2: "4.5", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "rgb(var(--oui-gradient-brand-end))" }), jsx("stop", { offset: "1", stopColor: "rgb(var(--oui-gradient-brand-start))" })] }) })] }) })] }) });
};
var Ko = () => {
  let e3 = useConfig(), { wrongNetwork: t, currentChainId: o, setCurrentChainId: i } = L$4(), r3 = e3.get("networkId");
  return { currentChainId: o, setCurrentChainId: i, networkId: r3, wrongNetwork: t };
};
var Xo = () => {
  let e3 = Ko();
  return jsx(Qo, { ...e3 });
};
var jo = (e3) => {
  let { t } = Z$2();
  return jsxs(z$1, { gap: 3, children: [jsxs(z$1, { direction: "column", itemAlign: "start", className: "oui-text-[11px] oui-cursor-pointer", onClick: (o) => {
    e3.onShowPortfolioSheet();
  }, children: [jsxs(z$1, { children: [jsx($$4, { intensity: 54, children: t("common.totalValue") }), jsx("button", { onClick: (o) => {
    o.stopPropagation(), o.preventDefault(), e3.setHideAssets(!e3.hideAssets);
  }, className: "oui-px-1", children: e3.hideAssets ? jsx(on$1, { color: "primary", opacity: 1, size: 16, className: "oui-text-primary-light" }) : jsx(nn$1, { color: "primary", opacity: 1, size: 16, className: "oui-text-primary-light" }) }), jsx(Ku, {})] }), jsx($$4.numeral, { suffix: jsx($$4, { intensity: 20, children: "USDC" }), dp: 2, visible: !e3.hideAssets, children: e3.canTrade ? e3.total ?? "--" : "--" })] }), e3.canTrade && jsx(te$6, { direction: "vertical", className: "oui-h-[26px]" }), e3.canTrade && jsx(_e$5, { variant: "outlined", onClick: (o) => {
    e3.onShowPortfolioSheet();
  }, className: "oui-h-[28px] oui-text-2xs oui-text-primary-light oui-border-primary-light", children: $$5(e3.currentLeverage, { fix: 2 }) + "x" })] });
}, Ku = () => jsx("svg", { width: "8", height: "8", viewBox: "0 0 8 8", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: jsx("path", { d: "M6.456 3.48a3.5 3.5 0 0 0 .431-.567 9 9 0 0 0 .361-.654l-.648-.66-.107.185q-.071.12-.142.244a3 3 0 0 1-.27.396 1.4 1.4 0 0 1-.318.29.67.67 0 0 1-.38.114q-.307 0-.666-.194t-.742-.42q-.383-.227-.777-.42a1.7 1.7 0 0 0-.771-.194q-.401.001-.72.154a2.1 2.1 0 0 0-.57.404 2.6 2.6 0 0 0-.43.574 5 5 0 0 0-.307.646l.649.66q.165-.437.464-.833.298-.395.742-.396.347 0 .7.194.354.193.721.42.37.227.763.42.396.195.826.195.374.001.665-.155.29-.151.526-.404m.352 2.941a3.5 3.5 0 0 0 .431-.566q.196-.315.361-.654l-.648-.66-.107.184-.142.244a3 3 0 0 1-.27.396 1.4 1.4 0 0 1-.318.29.67.67 0 0 1-.38.115q-.307 0-.666-.195-.36-.193-.742-.42-.383-.226-.778-.42a1.7 1.7 0 0 0-.77-.194q-.401.001-.72.154a2.1 2.1 0 0 0-.57.405 2.6 2.6 0 0 0-.43.574 5 5 0 0 0-.307.646l.649.66q.165-.437.464-.833.297-.395.742-.396.347 0 .7.194.354.193.721.42.369.226.763.42.396.194.826.194.374.001.665-.154.29-.152.526-.404", fill: "#fff", fillOpacity: ".54" }) });
var ei = () => {
  let { account: e3 } = useAccount(), t = tm(), o = om(), i = useEventEmitter(), { t: r3 } = Z$2(), [n4, a2] = useState(false), s = useCallback(async () => e3.settle().catch((c2) => {
    if (c2.code == -1104) return toast$2.error(r3("settle.settlement.error")), Promise.reject(c2);
    if (c2.message.indexOf("Signing off chain messages with Ledger is not yet supported") !== -1) return i.emit("wallet:sign-message-with-ledger-error", { message: c2.message, userAddress: e3.address }), Promise.reject(c2);
    if ((c2 == null ? void 0 : c2.code) === "ACTION_REJECTED") return toast$2.error(r3("connector.userRejected")), Promise.reject(c2);
  }).then((c2) => (toast$2.success(r3("settle.settlement.requested")), Promise.resolve(c2))), [e3, r3]), m2 = useCallback(() => {
    uo$3.show($r, { activeTab: "deposit" });
  }, []), l2 = useCallback(() => {
    uo$3.show($r, { activeTab: "withdraw" });
  }, []);
  return { ...t, ...o, onSettlePnL: s, onDeposit: m2, onWithdraw: l2, showSliderTip: n4, setShowSliderTip: a2 };
}, tm = () => {
  let { hideAssets: e3, setHideAssets: t } = W(), o = () => {
    t(!e3);
  }, { totalCollateral: i, freeCollateral: r3, totalValue: n4, availableBalance: a2 } = useCollateral({ dp: 2 });
  return { hideAssets: e3, toggleHideAssets: o, totalCollateral: i, freeCollateral: r3, totalValue: n4, availableBalance: a2 };
}, om = () => {
  let { t: e3 } = Z$2(), [{ aggregated: t, totalUnrealizedROI: o }, i] = usePositionStream(), { marginRatio: r3, currentLeverage: n4, mmr: a2 } = useMarginRatio(), s = useMemo(() => Math.min(10, t.notional === 0 ? i.margin_ratio(10) : r3), [r3, t]), [m2, { update: l2, config: c2, isMutating: u2 }] = useLeverage(), g2 = useMemo(() => (c2 == null ? void 0 : c2.map((x2) => ({ label: `${x2}x`, value: x2 }))) || [], [c2]), [d2, h2] = useState(m2 ?? 0), f2 = c2 == null ? void 0 : c2.reduce((x2, L2) => Math.max(x2, Number(L2), 0)), v2 = 100 / (((g2 == null ? void 0 : g2.length) || 0) - 1), P2 = (x2) => {
    h2(x2);
  }, N2 = async (x2) => {
    try {
      l2({ leverage: x2 }).then((L2) => {
        toast$2.success(e3("leverage.updated"));
      }, (L2) => {
        toast$2.error(L2.message);
      });
    } catch {
    }
  }, O2 = useCallback((x2) => {
    N2(x2[0]);
  }, []);
  return { aggregated: t, totalUnrealizedROI: o, positionsInfo: i, marginRatio: r3, marginRatioVal: s, mmr: a2, currentLeverage: n4, step: v2, marks: g2, onLeverageChange: P2, onValueCommit: O2, value: d2, maxLeverage: f2, onSaveLeverage: N2 };
};
function Vn(e3, t) {
  if (t === null) return { isRed: false, isYellow: false, isGreen: true };
  let o = t * 2, i = e3 <= o, r3 = e3 > o && e3 < 1, n4 = e3 >= 1;
  return { high: i, mid: r3, low: n4 };
}
var Gn = (e3) => {
  let { size: t = 20, className: o } = e3;
  return jsx("div", { className: "oui-flex oui-justify-center oui-items-end", style: { background: "url(/images/riskLevelBg.png)", backgroundSize: "contain", backgroundRepeat: "no-repeat", backgroundPosition: "center bottom", width: `${t}px`, height: "14px" }, children: jsx("div", { className: cnBase("oui-relative oui-w-[2px] oui-h-[2px] oui-rounded-full oui-bg-white after:oui-block after:oui-content-[''] after:oui-absolute after:oui-right-0 after:oui-w-[10px] after:oui-h-[2px] after:oui-bg-white/50", o) }) });
};
var oi = (e3) => jsxs(z$1, { direction: "column", gap: 4, width: "100%", children: [jsx(fm, { ...e3 }), jsx(te$6, { className: "oui-w-full" }), jsx(pm, { ...e3 }), jsx(hm, { ...e3 }), jsx(bm, { ...e3 })] }), fm = (e3) => {
  let { t } = Z$2(), o = useCallback(() => uo$3.confirm({ title: t("settle.settlePnl"), content: jsx($$4, { intensity: 54, size: "xs", children: jsx(Trans, { i18nKey: "settle.settlePnl.description" }) }), onCancel: () => Promise.reject(), onOk: () => typeof e3.onSettlePnL != "function" ? Promise.resolve() : e3.onSettlePnL().catch((r3) => {
  }) }), [t]), i = e3.totalUnrealizedROI > 0 ? "oui-text-success-darken" : "oui-text-danger-darken";
  return jsxs(z$1, { direction: "column", gap: 3, width: "100%", children: [jsxs(z$1, { direction: "column", itemAlign: "start", width: "100%", children: [jsx($$4.formatted, { size: "2xs", intensity: 36, suffix: e3.hideAssets ? jsx(on$1, { opacity: 1, size: 16, className: "oui-text-primary-light" }) : jsx(nn$1, { opacity: 1, size: 16, className: "oui-text-primary-light" }), onClick: (r3) => {
    e3.toggleHideAssets();
  }, className: "oui-cursor-pointer", children: `${t("common.totalValue")} (USDC)` }), jsx($$4.numeral, { size: "base", dp: 2, padding: false, visible: !e3.hideAssets, children: e3.totalValue ?? "--" })] }), jsxs(ia$1, { cols: 2, rows: 1, width: "100%", children: [jsx(da$2, { label: `${t("common.unrealizedPnl")} (USDC)`, classNames: { label: "oui-text-2xs oui-text-base-contrast-36" }, children: jsxs(z$1, { gap: 1, children: [jsx($$4.numeral, { size: "xs", coloring: true, dp: 2, padding: false, visible: !e3.hideAssets, children: e3.aggregated.unrealPnL }), !e3.hideAssets && jsx($$4.numeral, { size: "xs", dp: 2, padding: false, rule: "percentages", prefix: "(", suffix: ")", className: i, children: e3.totalUnrealizedROI })] }) }), jsx(da$2, { label: `${t("trading.asset.unsettledPnl")} (USDC)`, classNames: { label: "oui-text-2xs oui-text-base-contrast-36" }, children: jsxs(z$1, { justify: "between", width: "100%", children: [jsx($$4.numeral, { size: "xs", coloring: true, dp: 2, padding: false, visible: !e3.hideAssets, children: e3.aggregated.unsettledPnL }), jsxs("button", { className: "oui-flex oui-gap-1 oui-items-center", onClick: o, children: [jsx(ln$2, { opacity: 1, size: 12, className: "oui-text-primary-light" }), jsx($$4, { size: "2xs", color: "primary", children: t("settle.settlePnl") })] })] }) })] })] });
}, pm = (e3) => {
  let { t } = Z$2(), { high: o, mid: i, low: r3 } = Vn(e3.marginRatioVal, e3.mmr);
  return jsxs(ia$1, { cols: 2, rows: 1, width: "100%", children: [jsx(da$2, { label: t("trading.asset.marginRatio"), classNames: { label: "oui-text-2xs oui-text-base-contrast-36" }, children: jsxs(z$1, { gap: 2, children: [jsx($$4.numeral, { size: "xs", rule: "percentages", color: "primary", dp: 2, padding: false, visible: !e3.hideAssets, children: e3.marginRatioVal }), !e3.hideAssets && jsx(Gn, { className: r3 ? "oui-rotate-0" : i ? "oui-rotate-90" : o ? "oui-rotate-180" : "" })] }) }), jsx(da$2, { label: `${t("trading.asset.free&TotalCollateral")} (USDC)`, classNames: { label: "oui-text-2xs oui-text-base-contrast-36" }, children: jsxs(z$1, { justify: "start", width: "100%", gap: 1, children: [jsx($$4.numeral, { size: "xs", dp: 2, padding: false, visible: !e3.hideAssets, children: e3.freeCollateral }), jsx($$4, { size: "xs", children: "/" }), jsx($$4.numeral, { size: "xs", dp: 2, padding: false, visible: !e3.hideAssets, children: e3.totalCollateral })] }) })] });
}, hm = (e3) => {
  let { t } = Z$2();
  return jsxs(z$1, { direction: "column", gap: 2, width: "100%", children: [jsxs(z$1, { width: "100%", justify: "between", children: [jsx($$4, { size: "2xs", intensity: 54, children: t("leverage.maxAccountLeverage") }), jsxs(z$1, { gap: 1, children: [jsx($$4, { size: "2xs", intensity: 54, children: `${t("common.current")}:` }), jsx($$4.numeral, { size: "2xs", unit: "x", intensity: 98, children: e3.currentLeverage ?? "--" })] })] }), jsx(f$1, { value: e3.value, maxLeverage: e3.maxLeverage, onLeverageChange: e3.onLeverageChange, setShowSliderTip: e3.setShowSliderTip, showSliderTip: e3.showSliderTip, onValueCommit: e3.onValueCommit })] });
}, bm = (e3) => {
  let { t } = Z$2();
  return jsxs(ia$1, { cols: 2, rows: 1, gap: 3, className: "oui-grid-row-[1fr,1fr]", width: "100%", pt: 2, pb: 4, children: [jsx(_e$5, { icon: jsx(fn$1, { color: "white", opacity: 0.8 }), size: "md", fullWidth: true, className: "oui-bg-base-2 hover:oui-bg-base-2/50", onClick: e3.onWithdraw, children: t("common.withdraw") }), jsx(_e$5, { icon: jsx(xn$2, { color: "white", opacity: 0.8 }), size: "md", fullWidth: true, onClick: e3.onDeposit, children: t("common.deposit") })] });
};
var ii = () => {
  let e3 = ei();
  return jsx(oi, { ...e3 });
};
var ri = () => {
  let { t: e3 } = Z$2(), { bottomSheetLeading: t } = I(), { hideAssets: o, setHideAssets: i } = W(), { wrongNetwork: r3, disabledConnect: n4 } = L$4(), { state: a2 } = useAccount(), { currentLeverage: s } = useMarginRatio(), { totalValue: m2 } = useCollateral(), l2 = !r3 && !n4 && (a2.status >= AccountStatusEnum.EnableTrading || a2.status === AccountStatusEnum.EnableTradingWithoutConnected), c2 = () => {
    l2 && uo$3.sheet({ title: e3("trading.asset&Margin"), leading: t, content: jsx(ii, {}) });
  }, u2 = xr$2(m2);
  return { currentLeverage: s, total: u2, hideAssets: o, setHideAssets: i, onShowPortfolioSheet: c2, wrongNetwork: r3, canTrade: l2 };
};
var ni = () => {
  let e3 = ri();
  return jsx(jo, { ...e3 });
};
function ai() {
  let [e3, t] = useState(false), [o, i] = useLocalStorage("orderly_qr_code_scan_tooltip_open", true), r3 = () => {
    t(true);
  }, n4 = () => {
    t(false);
  }, a2 = (s) => {
    Bm(s) && (window.location.href = s);
  };
  return useEffect(() => {
    o && setTimeout(() => {
      i(false);
    }, 8e3);
  }, [o]), { open: e3, onOpenChange: t, showDialog: r3, hideDialog: n4, onScanSuccess: a2, showScanTooltip: o };
}
function Bm(e3) {
  try {
    let t = new URL(e3);
    return ["http:", "https:"].includes(t.protocol);
  } catch {
    return false;
  }
}
var zt = 320, Ht = 320, Et = 2, Xn = (e3) => {
  let t = useRef(null), o = useRef(null), i = () => {
    var _a2;
    let r3 = t.current, n4 = o.current;
    if (!r3 || !n4) return;
    let a2 = n4.getContext("2d");
    if (r3.readyState === r3.HAVE_ENOUGH_DATA) {
      let s = r3.videoWidth, m2 = r3.videoHeight, l2 = n4.width / n4.height, c2 = s / m2, u2, g2, d2, h2;
      c2 > l2 ? (h2 = m2, d2 = m2 * l2, u2 = (s - d2) / 2, g2 = 0) : (d2 = s, h2 = s / l2, u2 = 0, g2 = (m2 - h2) / 2), a2.drawImage(r3, u2, g2, d2, h2, 0, 0, n4.width, n4.height);
      let f2 = a2.getImageData(0, 0, n4.width, n4.height), v2 = Rm(f2.data, f2.width, f2.height, { inversionAttempts: "dontInvert" });
      (v2 == null ? void 0 : v2.data) && ((_a2 = e3.onSuccess) == null ? void 0 : _a2.call(e3, v2.data));
    }
    requestAnimationFrame(i);
  };
  return useEffect(() => {
    let r3 = t.current;
    if (!(!open || !r3)) return navigator == null ? void 0 : navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment", width: { ideal: zt * Et }, height: { ideal: Ht * Et } } }).then((n4) => {
      r3.srcObject = n4, r3.setAttribute("playsinline", "true"), r3.play(), r3.onloadeddata = () => {
        requestAnimationFrame(i);
      };
    }).catch((n4) => {
    }), () => {
      let n4 = r3.srcObject;
      n4 && n4.getTracks().forEach((s) => s.stop()), r3.srcObject = null;
    };
  }, [t, o]), jsxs(Fragment$1, { children: [jsx("video", { ref: t, width: zt, height: Ht, className: "oui-bg-base-10 oui-rounded-2xl oui-hidden" }), jsx("canvas", { ref: o, width: zt * Et, height: Ht * Et, style: { width: zt, height: Ht }, className: "oui-bg-base-10 oui-rounded-2xl" })] });
};
var li = (e3) => {
  let { t } = Z$2();
  return jsxs(Fragment$1, { children: [jsx(Xn$2, { open: e3.showScanTooltip, content: t("linkDevice.scanQRCode.tooltip"), className: "oui-bg-base-6 oui-text-warning-darken oui-text-2xs oui-font-semibold", arrow: { className: "!oui-fill-base-6" }, children: jsx(z$1, { className: "oui-rounded-md oui-bg-base-5 oui-px-[6px] oui-h-7 oui-cursor-pointer", onClick: e3.showDialog, children: jsx(Wm, { className: "oui-text-base-contrast-80" }) }) }), jsx(me$4, { title: jsx($$4, { weight: "semibold", children: t("common.confirm") }), open: e3.open, onOpenChange: e3.onOpenChange, size: "sm", children: jsx(Em, { ...e3 }) })] });
}, Em = (e3) => {
  let { t } = Z$2();
  return jsxs(z$1, { justify: "center", direction: "column", gapY: 5, children: [jsx(ue$6, {}), jsx(Xn, { onSuccess: e3.onScanSuccess }), jsx($$4, { size: "sm", intensity: 98, weight: "semibold", children: t("linkDevice.scanQRCode") }), jsx("span", { className: "oui-px-3 oui-text-center", children: jsx($$4, { size: "2xs", intensity: 54, weight: "regular", className: "oui-break-words", children: jsx(Trans, { i18nKey: "linkDevice.scanQRCode.description", components: [jsx(Vm, { className: "oui-inline-block oui-text-base-contrast-80 oui-mx-1" })] }) }) })] });
}, Wm = (e3) => jsx("svg", { width: "18", height: "18", viewBox: "0 0 18 18", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...e3, children: jsx("path", { d: "M5.249 2.243a3 3 0 0 0-3 3v.75a.75.75 0 0 0 1.5 0v-.75a1.5 1.5 0 0 1 1.5-1.5h2.25a.75.75 0 0 0 0-1.5zm5.25 0a.75.75 0 0 0 0 1.5h2.25a1.5 1.5 0 0 1 1.5 1.5v.75a.75.75 0 0 0 1.5 0v-.75a3 3 0 0 0-3-3zm-7.5 9a.75.75 0 0 0-.75.75v.75a3 3 0 0 0 3 3h2.25a.75.75 0 0 0 0-1.5h-2.25a1.5 1.5 0 0 1-1.5-1.5v-.75a.75.75 0 0 0-.75-.75m12 0a.75.75 0 0 0-.75.75v.75a1.5 1.5 0 0 1-1.5 1.5h-2.25a.75.75 0 0 0 0 1.5h2.25a3 3 0 0 0 3-3v-.75a.75.75 0 0 0-.75-.75M5.25 8.999a.75.75 0 0 1 .75-.75h6a.75.75 0 0 1 0 1.5H6a.75.75 0 0 1-.75-.75" }) }), Vm = (e3) => {
  let { size: t = 20, viewBox: o, ...i } = e3;
  return jsxs("svg", { width: t, height: t, viewBox: "0 0 20 20", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...i, children: [jsx("path", { d: "M19.167 7.583a1.74 1.74 0 0 0-1.731-1.75h-4.038a1.74 1.74 0 0 0-1.731 1.75v8.167c0 .967.775 1.75 1.73 1.75h4.039a1.74 1.74 0 0 0 1.73-1.75zm-1.154 0v7.584H12.82V7.583A.58.58 0 0 1 13.398 7h4.038a.58.58 0 0 1 .577.583m-2.02 8.75a.58.58 0 0 1-.576.584.58.58 0 0 1-.577-.584.58.58 0 0 1 .577-.583.58.58 0 0 1 .577.583" }), jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M1.666 5a2.5 2.5 0 0 1 2.5-2.5h10a2.5 2.5 0 0 1 2.5 2.5.08.08 0 0 1-.078.078h-1.51a.08.08 0 0 1-.08-.078.834.834 0 0 0-.833-.833h-10A.834.834 0 0 0 3.333 5v5.633c0 .11.09.2.2.2h7.1c.11 0 .2.09.2.2V12.3a.2.2 0 0 1-.2.2H2.7a.2.2 0 0 0-.2.2v.633c0 .511.308.834.834.834h7.3c.11 0 .2.09.2.2v1.266a.2.2 0 0 1-.2.2h-7.3c-1.465 0-2.5-1.086-2.5-2.5v-1.666c0-.392.27-.72.635-.81.107-.026.198-.113.198-.224z" })] });
};
var ui = () => {
  let e3 = ai();
  return jsx(li, { ...e3 });
};
var Jn = () => jsxs("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", className: "oui-rounded-full", children: [jsxs("g", { clipPath: "url(#a)", children: [jsx("path", { d: "m31.002 14.493-8.326-22.51L.166.31l8.327 22.51z", fill: "#03435D" }), jsx("path", { d: "m4.456-8.716-18.03 15.84 15.84 18.03 18.03-15.84z", fill: "#157CF2" }), jsx("path", { d: "m17.548 38.67 22.825-7.416-7.416-22.825-22.826 7.416z", fill: "#F3E200" })] }), jsx("defs", { children: jsx("clipPath", { id: "a", children: jsx("rect", { width: "24", height: "24", rx: "12", fill: "#fff" }) }) })] }), jn = () => jsx("svg", { width: "20", height: "20", viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: jsx("path", { d: "M5.832 2.492A3.333 3.333 0 0 0 2.5 5.826v5a3.333 3.333 0 0 0 3.333 3.333 3.333 3.333 0 0 0 3.334 3.333h5a3.333 3.333 0 0 0 3.333-3.333v-5a3.333 3.333 0 0 0-3.333-3.333 3.333 3.333 0 0 0-3.334-3.334zm8.334 5c.92 0 1.666.746 1.666 1.667v5c0 .92-.746 1.666-1.666 1.666h-5c-.92 0-1.667-.745-1.667-1.666h3.333a3.333 3.333 0 0 0 3.334-3.334z", fill: "rgb(var(--oui-color-primary))" }) }), mi = (e3) => {
  let { size: t = 20 } = e3;
  return jsxs("svg", { width: t, height: t, viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsxs("g", { clipPath: "url(#a)", children: [jsx("path", { d: "M10 20c5.542 0 10-4.458 10-10S15.542 0 10 0 0 4.458 0 10s4.458 10 10 10", fill: "#2775CA" }), jsx("path", { d: "M13 11.473c0-1.452-.94-1.95-2.82-2.158-1.344-.166-1.613-.498-1.613-1.078s.448-.955 1.343-.955c.806 0 1.254.25 1.478.872.045.124.18.207.313.207h.717c.179 0 .313-.125.313-.29v-.042c-.179-.913-.985-1.618-2.015-1.701v-.996c0-.166-.134-.29-.358-.332h-.671c-.18 0-.314.124-.359.332v.954c-1.343.166-2.194.996-2.194 2.034 0 1.369.896 1.908 2.776 2.116 1.254.207 1.657.456 1.657 1.12s-.627 1.12-1.477 1.12c-1.165 0-1.568-.456-1.702-1.078a.32.32 0 0 0-.313-.25h-.762c-.179 0-.313.125-.313.291v.042c.179 1.037.895 1.784 2.373 1.991v.996c0 .166.134.29.358.332h.672c.18 0 .313-.124.358-.332v-.996C12.105 13.465 13 12.593 13 11.473", fill: "#fff", fillOpacity: ".98" }), jsx("path", { d: "M7.74 16.57c-3.458-1.215-5.23-4.986-3.945-8.324.665-1.821 2.127-3.208 3.944-3.859.178-.086.266-.216.266-.433v-.607c0-.174-.088-.304-.266-.347-.044 0-.133 0-.177.043-4.21 1.3-6.516 5.68-5.186 9.798.798 2.428 2.704 4.292 5.186 5.072.177.087.355 0 .399-.173.044-.043.044-.087.044-.173v-.608c0-.13-.133-.303-.266-.39m4.698-13.527c-.178-.086-.355 0-.4.174-.043.043-.043.086-.043.173v.607c0 .174.133.347.266.434 3.457 1.213 5.23 4.985 3.944 8.323-.664 1.821-2.127 3.209-3.944 3.859-.178.086-.266.216-.266.433v.607c0 .174.088.304.266.347.044 0 .133 0 .177-.043 4.21-1.3 6.515-5.68 5.186-9.798-.798-2.471-2.748-4.335-5.186-5.116", fill: "#fff" })] }), jsx("defs", { children: jsx("clipPath", { id: "a", children: jsx("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })] });
}, ea = (e3) => {
  let { size: t = 20 } = e3;
  return jsxs("svg", { width: "20", height: "20", viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsxs("g", { clipPath: "url(#clip0_6403_64483)", children: [jsx("path", { d: "M10.0245 19.9493C15.5198 19.9493 19.9747 15.4944 19.9747 9.99908C19.9747 4.50371 15.5198 0.0488281 10.0245 0.0488281C4.5291 0.0488281 0.0742188 4.50371 0.0742188 9.99908C0.0742188 15.4944 4.5291 19.9493 10.0245 19.9493Z", fill: "url(#paint0_linear_6403_64483)" }), jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M14.1553 4.89304C14.2199 4.94541 14.1821 5.04758 14.0989 5.04758H5.95035C5.86716 5.04758 5.82936 4.94541 5.894 4.89304C7.0223 3.97912 8.45953 3.43164 10.0246 3.43164C11.5898 3.43164 13.0269 3.97912 14.1553 4.89304Z", fill: "white" }), jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M7.47013 11.7869C7.42315 11.7199 7.34748 11.6777 7.26565 11.6777H3.82985C3.75113 11.6777 3.69375 11.7525 3.71563 11.8281C4.5078 14.565 7.0326 16.566 10.0247 16.566C13.017 16.566 15.5417 14.565 16.3339 11.8281C16.3558 11.7525 16.2984 11.6777 16.2197 11.6777H12.7839C12.702 11.6777 12.6264 11.7199 12.5795 11.7869C12.0155 12.5911 11.0815 13.1167 10.0248 13.1167C8.96803 13.1167 8.03406 12.5911 7.47013 11.7869Z", fill: "white" }), jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12.3347 7.90519C12.3822 7.95756 12.449 7.9891 12.5196 7.9891H16.1137C16.1952 7.9891 16.253 7.90983 16.2261 7.83301C15.9724 7.10689 15.5948 6.43893 15.1187 5.85447C15.074 5.79961 15.0067 5.76855 14.9358 5.76855H5.11323C5.04247 5.76855 4.97512 5.79961 4.93044 5.85447C4.45429 6.43893 4.0767 7.10689 3.82306 7.83301C3.79622 7.90983 3.85398 7.9891 3.93536 7.9891H7.52952C7.60022 7.9891 7.66694 7.95756 7.71445 7.90519C8.28491 7.2763 9.10861 6.88136 10.0246 6.88136C10.9405 6.88136 11.7643 7.2763 12.3347 7.90519Z", fill: "white" }), jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M13.1164 10.9586C13.0553 10.9586 13.0118 10.899 13.0284 10.8401C13.1033 10.5722 13.1433 10.2898 13.1433 9.9981C13.1433 9.58758 13.064 9.19556 12.9199 8.83657C12.8954 8.77581 12.9392 8.70801 13.0046 8.70801H16.392C16.4349 8.70801 16.472 8.73831 16.4799 8.78052C16.5538 9.17511 16.5925 9.58216 16.5925 9.9982C16.5925 10.2978 16.5724 10.5926 16.5337 10.8815C16.5277 10.9258 16.4897 10.9586 16.4451 10.9586H13.1164ZM7.02223 10.8401C7.03868 10.899 6.99532 10.9586 6.93421 10.9586H3.60551C3.56084 10.9586 3.52285 10.9258 3.5169 10.8815C3.47807 10.5926 3.45801 10.2978 3.45801 9.9982C3.45801 9.58216 3.4967 9.17511 3.57069 8.78052C3.57859 8.73831 3.61563 8.70801 3.65856 8.70801H7.04593C7.11141 8.70801 7.15516 8.77581 7.13076 8.83657C6.98657 9.19556 6.90722 9.58758 6.90722 9.9981C6.90722 10.2898 6.94728 10.5722 7.02223 10.8401Z", fill: "white" })] }), jsxs("defs", { children: [jsxs("linearGradient", { id: "paint0_linear_6403_64483", x1: "10.0245", y1: "0.0488561", x2: "10.0245", y2: "19.9493", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "#C750FF" }), jsx("stop", { offset: "1", stopColor: "#5800E8" })] }), jsx("clipPath", { id: "clip0_6403_64483", children: jsx("rect", { width: "20", height: "20", fill: "white" }) })] })] });
};
var fi = (e3) => {
  let { t } = Z$2();
  return jsxs(z$1, { direction: "column", gap: 4, children: [jsx(Um, { ...e3 }), jsx($m, { ...e3 }), jsx(Qm, { ...e3 }), jsxs(z$1, { gap: 3, width: "100%", justify: "center", children: [e3.showGetTestUSDC && jsx(_e$5, { variant: "outlined", size: "md", onClick: e3.onGetTestUSDC, fullWidth: true, loading: e3.gettingTestUSDC, className: "oui-border-primary-light oui-text-primary-light", children: t("trading.faucet.getTestUSDC") }), jsx(_e$5, { variant: "outlined", color: "danger", size: "md", onClick: e3.onDisconnect, className: e3.showGetTestUSDC ? "oui-w-full" : "oui-w-[50%]", children: t("connector.disconnect") })] })] });
}, Um = (e3) => jsxs(z$1, { width: "100%", justify: "between", children: [jsxs(z$1, { gap: 3, children: [jsx(Jn, {}), jsxs(z$1, { direction: "column", justify: "start", itemAlign: "start", className: "oui-gap-[2px]", children: [jsx($$4.formatted, { rule: "address", children: e3.address }), jsx($$4.formatted, { size: "2xs", intensity: 80, prefix: jsx("div", { className: "oui-h-1 oui-w-1 oui-rounded-full oui-bg-success oui-pr-1" }), children: e3.chainName })] })] }), jsx("button", { className: "oui-cursor-pointer", onClick: () => {
  e3.onCopyAddress();
}, children: jsx(jn, {}) })] }), $m = (e3) => {
  let { t } = Z$2();
  return jsxs(z$1, { direction: "column", gap: 3, r: "lg", p: 3, className: "oui-bg-base-6", width: "100%", children: [jsx("button", { onClick: e3.onClickReferral, className: "oui-cursor-pointer oui-w-full", children: jsxs(z$1, { justify: "between", width: "100%", children: [jsx($$4, { size: "2xs", children: t("affiliate.referral") }), jsx(hn$2, { color: "white", opacity: 0.98, size: 16 })] }) }), e3.isAffiliate && jsxs(z$1, { gradient: "primary", p: 4, r: "lg", width: "100%", angle: 180, justify: "between", children: [jsxs(z$1, { direction: "column", itemAlign: "start", children: [jsx($$4, { size: "xs", children: t("common.affiliate") }), jsxs($$4, { size: "2xs", intensity: 54, children: ["(", t("affiliate.commission.30d"), ")"] })] }), jsxs(z$1, { className: "oui-gap-[6px]", children: [jsx(mi, {}), jsx($$4.numeral, { dp: 2, padding: false, rm: g$6.ROUND_DOWN, rule: "price", children: e3.affiliateCommission30D ?? "--" })] })] }), e3.isTrader && jsxs(z$1, { gradient: "success", p: 4, r: "lg", width: "100%", angle: 180, justify: "between", children: [jsxs(z$1, { direction: "column", itemAlign: "start", children: [jsx($$4, { size: "xs", children: t("affiliate.trader") }), jsxs($$4, { size: "2xs", intensity: 54, children: ["(", t("affiliate.commission.30d"), ")"] })] }), jsxs(z$1, { className: "oui-gap-[6px]", children: [jsx(mi, {}), jsx($$4.numeral, { dp: 2, padding: false, rm: g$6.ROUND_DOWN, rule: "price", children: e3.traderCommission30D ?? "--" })] })] })] });
}, Qm = (e3) => {
  var _a2;
  let { t } = Z$2();
  return jsxs(z$1, { direction: "column", gap: 3, r: "lg", p: 3, className: "oui-bg-base-6", width: "100%", children: [jsx("button", { onClick: e3.onClickTradingRewards, className: "oui-cursor-pointer oui-w-full", children: jsxs(z$1, { justify: "between", width: "100%", children: [jsxs(z$1, { gap: 1, className: "oui-text-base-contrast oui-text-2xs", children: [jsx($$4, { children: t("common.tradingRewards") }), jsxs($$4, { intensity: 54, children: ["(", jsx($$4, { children: `${(_a2 = t("tradingRewards.epoch")) == null ? void 0 : _a2.toLowerCase()} ` }), jsx($$4, { intensity: 98, children: e3.curEpochId }), " )"] })] }), jsx(hn$2, { color: "white", opacity: 0.98, size: 16 })] }) }), jsxs(z$1, { p: 4, r: "lg", width: "100%", angle: 180, justify: "between", className: "oui-bg-gradient-to-t oui-from-[#2d0061] oui-to-[#bd6bed]", children: [jsx($$4, { size: "2xs", intensity: 80, children: t("tradingRewards.myEstRewards") }), jsxs(z$1, { className: "oui-gap-[6px]", children: [jsx(ea, {}), jsx($$4.numeral, { dp: 2, padding: false, rm: g$6.ROUND_DOWN, rule: "price", children: e3.estRewards })] })] })] });
};
var hi = (e3) => {
  let { t } = Z$2(), [o] = useLocalStorage("orderly_link_device", {}), { account: i, state: r3 } = useAccount(), n4 = i.accountId, a2 = i.address, { hide: s } = X$5(), m2 = useConfig(), { connectedChain: l2, disconnect: c2, namespace: u2 } = useWalletConnector(), g2 = i.chainId || (l2 == null ? void 0 : l2.id) || (o == null ? void 0 : o.chainId), d2 = useMemo(() => g2 ? (r3.status === AccountStatusEnum.EnableTrading || r3.status === AccountStatusEnum.EnableTradingWithoutConnected) && B$7(parseInt(g2)) : false, [r3.status, g2]), h2 = ud(g2), f2 = m2.get("operatorUrl"), v2 = () => {
    navigator.clipboard.writeText(a2 ?? ""), toast$2.success(t("common.copy.copied"));
  }, { affiliateCommission30D: P2, traderCommission30D: N2, isAffiliate: O2, isTrader: x2, onClickReferral: L2 } = ld(e3.onClickReferral), { curEpochId: Se3, estRewards: ie2, onClickTradingRewards: fe2 } = cd(e3.onClickTradingRewards), De2 = async () => {
    var _a2;
    localStorage.removeItem("orderly_link_device"), await c2({ label: (_a2 = r3.connectWallet) == null ? void 0 : _a2.name }), await i.disconnect(), s();
  }, [Fe2, { isMutating: Le3 }] = useMutation(`${f2}/v1/faucet/usdc`);
  return { accountId: n4, address: a2, chainId: g2, chainName: h2, onCopyAddress: v2, affiliateCommission30D: P2, onClickReferral: L2, isAffiliate: O2, isTrader: x2, traderCommission30D: N2, curEpochId: Se3, onClickTradingRewards: fe2, estRewards: ie2, onDisconnect: De2, showGetTestUSDC: d2, onGetTestUSDC: () => {
    if (r3.status < AccountStatusEnum.EnableTrading && r3.status !== AccountStatusEnum.EnableTradingWithoutConnected) return;
    let R2 = t("trading.faucet.getTestUSDC.success", { quantity: u2 === ChainNamespace.solana ? "100" : "1,000" });
    return Fe2({ chain_id: g2 == null ? void 0 : g2.toString(), user_address: r3.address, broker_id: m2.get("brokerId") }).then((E3) => {
      if (E3.success) return uo$3.alert({ title: t("trading.faucet.getTestUSDC"), message: R2, onOk: () => Promise.resolve(true) });
      E3.message && toast$2.error(E3.message);
    }, (E3) => {
      toast$2.error(E3.message);
    });
  }, gettingTestUSDC: Le3 };
}, ld = (e3) => {
  let { data: t, isAffiliate: i, isTrader: r3 } = useReferralInfo(), n4 = useMemo(() => {
    if (i) return t == null ? void 0 : t.referrer_info["30d_referrer_rebate"];
  }, [t]), a2 = useMemo(() => {
    if (r3) return t == null ? void 0 : t.referee_info["30d_referee_rebate"];
  }, [t]);
  return { onClickReferral: () => {
    e3 == null ? void 0 : e3();
  }, affiliateCommission30D: n4, traderCommission30D: a2, isAffiliate: i, isTrader: r3 };
}, cd = (e3) => {
  let [t] = useCurEpochEstimate(TWType.normal), [o, i] = useEpochInfo(TWType.normal), r3 = useMemo(() => {
    var _a2;
    return ((_a2 = i.curEpochInfo) == null ? void 0 : _a2.epoch_id) ?? "--";
  }, [i]), n4 = useMemo(() => typeof (t == null ? void 0 : t.est_r_wallet) > "u" ? "--" : t == null ? void 0 : t.est_r_wallet, [t]);
  return { curEpochId: r3, estRewards: n4, onClickTradingRewards: () => {
    e3 == null ? void 0 : e3();
  } };
};
function ud(e3) {
  let [t, { findByChainId: o }] = useChains("mainnet", { pick: "network_infos", filter: (r3) => {
    var _a2, _b2;
    return ((_a2 = r3.network_infos) == null ? void 0 : _a2.bridge_enable) || ((_b2 = r3.network_infos) == null ? void 0 : _b2.bridgeless);
  } });
  return useMemo(() => {
    let r3 = o(parseInt(e3), "network_infos");
    return r3 ? r3.name : "Unknown";
  }, [e3, o]);
}
var bi = (e3) => {
  let t = hi(e3);
  return jsx(fi, { ...t });
};
var ra = () => {
  let { t: e3 } = Z$2(), { referral: t, tradingRewards: o, bottomSheetLeading: i } = I(), { account: r3, state: n4 } = useAccount();
  return { onShowAccountSheet: () => {
    uo$3.sheet({ title: e3("common.account"), leading: i, content: jsx(bi, { ...t, ...o }) });
  }, address: r3.address, state: n4 };
};
var aa = (e3) => jsx(S$1, { buttonProps: { size: "sm" }, children: jsx(_e$5, { variant: "gradient", size: "sm", className: "oui-max-w-[83px]", onClick: (t) => {
  e3.onShowAccountSheet();
}, children: Nu(e3.address, [4, 4]) }) });
zo$2({ name: "mobile-account-menu", positions: [Et$5.MobileAccountMenu], builder: ra, __isInternal: true })((e3) => jsx(aa, { ...e3 }));
var la = () => jsx(ei$3, { position: Et$5.MobileAccountMenu });
var Si = (e3) => {
  let t = () => e3.wrongNetwork ? null : !e3.disabledConnect && e3.status === AccountStatusEnum.EnableTradingWithoutConnected ? jsx(Pd, { onDisconnect: e3.onDisconnect }) : jsx(Xo, {}), o = !e3.disabledConnect && e3.status !== AccountStatusEnum.EnableTradingWithoutConnected && e3.status < AccountStatusEnum.EnableTrading;
  return jsxs("div", { className: "oui-bg-base-9 oui-border-t oui-border-line-4", children: [jsxs(z$1, { height: 64, gap: 1, justify: "between", itemAlign: "center", className: " oui-px-[14px] oui-pt-[7px]", children: [jsx(ni, {}), jsxs(z$1, { gap: 2, children: [o && jsx(ui, {}), t(), jsx(la, {})] })] }), jsx("div", { className: "oui-h-[env(safe-area-inset-bottom)]" })] });
}, Pd = (e3) => {
  let [t, o] = useState(false), { t: i } = Z$2(), r3 = () => {
    o(true);
  }, n4 = () => {
    o(false);
  };
  return jsxs(Fragment$1, { children: [jsx(me$4, { open: t, onOpenChange: o, title: i("common.tips"), size: "xs", actions: { secondary: { label: i("common.cancel"), onClick: n4, size: "md", fullWidth: true }, primary: { label: i("connector.disconnect"), onClick: async () => {
    await e3.onDisconnect(), n4();
  }, size: "md", variant: "outlined", color: "danger" } }, children: jsx($$4, { intensity: 54, size: "sm", children: i("linkDevice.scanQRCode.connected.description") }) }), jsxs(z$1, { className: "oui-text-base-contrast oui-px-[6px]", intensity: 500, height: 28, r: "md", onClick: r3, children: [jsx(Nd, {}), jsx(ua, {}), jsx(Dd, {}), jsx(ua, {}), jsx(kd, {})] })] });
}, ua = () => jsxs(z$1, { className: "oui-gap-x-[1px] oui-px-[1px]", children: [jsx(yi, {}), jsx(yi, {}), jsx(yi, {})] }), Nd = (e3) => jsx("svg", { width: "18", height: "18", viewBox: "0 0 18 18", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...e3, children: jsx("path", { d: "M4.5 2.93a2.25 2.25 0 0 0-2.25 2.25v5.25a.75.75 0 0 0-.75.75v1.5c0 1.272.93 2.25 2.25 2.25h10.5c1.318 0 2.25-.978 2.25-2.25v-1.5a.75.75 0 0 0-.75-.75V5.18a2.25 2.25 0 0 0-2.25-2.25zm0 1.5h9a.75.75 0 0 1 .75.75v5.25H3.75V5.18a.75.75 0 0 1 .75-.75M3 11.93h12v.75c0 .46-.277.75-.75.75H3.75c-.474 0-.75-.29-.75-.75z" }) }), kd = (e3) => jsx("svg", { width: "18", height: "18", viewBox: "0 0 18 18", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...e3, children: jsx("path", { d: "M13.498 3.715a2.25 2.25 0 0 0-2.25-2.25h-4.5a2.25 2.25 0 0 0-2.25 2.25v10.5a2.25 2.25 0 0 0 2.25 2.25h4.5a2.25 2.25 0 0 0 2.25-2.25zm-1.5 0v9.75h-6v-9.75a.75.75 0 0 1 .75-.75h4.5a.75.75 0 0 1 .75.75m-2.25 11.25a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0" }) }), Dd = (e3) => jsxs("svg", { width: "12", height: "12", viewBox: "0 0 12 12", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M1.007 6a5 5 0 1 1 10 0 5 5 0 0 1-10 0m7.486-2.344A.6.6 0 0 1 8.91 3.5c.15 0 .305.048.418.156a.55.55 0 0 1 0 .798L5.254 8.337a.62.62 0 0 1-.837 0L2.67 6.673a.55.55 0 0 1 0-.798.62.62 0 0 1 .837 0l1.329 1.266z", fill: "url(#a)" }), jsx("defs", { children: jsxs("linearGradient", { id: "a", x1: "11.007", y1: "5.999", x2: "1.007", y2: "5.999", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "rgb(var(--oui-gradient-brand-end))" }), jsx("stop", { offset: "1", stopColor: "rgb(var(--oui-gradient-brand-start))" })] }) })] }), yi = (e3) => jsxs("svg", { width: "2", height: "2", viewBox: "0 0 2 2", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsx("path", { d: "M.667.334a.667.667 0 1 1 0 1.333.667.667 0 0 1 0-1.333", fill: "url(#a)" }), jsx("defs", { children: jsxs("linearGradient", { id: "a", x1: "1.333", y1: "1.001", x2: "0", y2: "1.001", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "rgb(var(--oui-gradient-brand-end))" }), jsx("stop", { offset: "1", stopColor: "rgb(var(--oui-gradient-brand-start))" })] }) })] });
var Ci = () => {
  let { wrongNetwork: e3, disabledConnect: t } = L$4(), { account: o, state: i } = useAccount(), r3 = async () => {
    localStorage.removeItem("orderly_link_device"), await o.disconnect();
  };
  return { wrongNetwork: e3, disabledConnect: t, status: i.status, onDisconnect: r3 };
};
var wi = () => {
  let e3 = Ci();
  return jsx(Si, { ...e3 });
};
var vi = () => {
  let [e3, t] = useState("chart"), { symbol: o } = I(), [i, r3] = useState(true);
  return { tab: e3, setTab: t, symbol: o, toggleContentVisible: () => {
    r3((a2) => !a2);
  }, setVisible: r3, visible: i };
};
var da = (e3) => jsx(Be2, { symbol: e3.symbol, classNames: { root: "oui-px-3 ", list: "oui-min-h-[141px] oui-max-h-[202px] oui-w-full", listHeader: "oui-text-xs oui-text-base-contrast-36", listItem: { left: "oui-text-xs", mid: "oui-text-xs", right: "oui-text-xs" } } });
var ki = (e3) => {
  var _a2, _b2, _c2, _d2;
  let { t } = Z$2();
  return jsxs(z$1, { direction: "column", gap: 2, children: [jsx(He, { title: t("common.markPrice"), value: (_a2 = e3.ticker) == null ? void 0 : _a2.mark_price, dp: e3.symbolInfo.quote_dp }), jsx(He, { title: t("common.indexPrice"), value: (_b2 = e3.ticker) == null ? void 0 : _b2.index_price, dp: e3.symbolInfo.quote_dp }), jsx(He, { title: t("markets.column.24hVolume"), value: e3.vol_24h, dp: e3.symbolInfo.quote_dp, rule: "human", showUSDC: true }), jsx(He, { title: t("trading.column.24High"), value: (_c2 = e3.ticker) == null ? void 0 : _c2["24h_high"], dp: e3.symbolInfo.quote_dp }), jsx(He, { title: t("trading.column.24Low"), value: (_d2 = e3.ticker) == null ? void 0 : _d2["24h_low"], dp: e3.symbolInfo.quote_dp }), jsx(He, { title: t("markets.openInterest"), value: e3.openInterest, dp: e3.symbolInfo.quote_dp, rule: "human", showUSDC: true })] });
}, He = (e3) => {
  let { title: t, value: o, showUSDC: i, dp: r3, rule: n4 = "price" } = e3;
  return jsxs(z$1, { justify: "between", width: "100%", className: "oui-text-xs", children: [jsx($$4, { intensity: 36, children: t }), jsxs(z$1, { gap: 1, children: [jsx($$4.numeral, { rule: n4, dp: r3, intensity: 80, children: o }), i && jsx($$4, { intensity: 36, children: "USDC" })] })] });
};
var Di = (e3) => {
  let { symbol: t } = e3, o = useTickerStream(t), { symbolInfo: i } = I(), r3 = useMemo(() => {
    let a2 = o == null ? void 0 : o["24h_close"], s = o == null ? void 0 : o["24h_volume"];
    if (a2 && s && !isNaN(a2) && !isNaN(s)) return new g$6(a2).mul(s).toFixed(i.quote_dp, g$6.ROUND_DOWN);
  }, [o]), n4 = useMemo(() => {
    let a2 = o == null ? void 0 : o.mark_price, s = o == null ? void 0 : o.open_interest;
    if (a2 && s && !isNaN(a2)) return new g$6(a2).mul(Number(s)).toFixed(i.quote_dp, g$6.ROUND_DOWN);
  }, [o]);
  return { ticker: o, symbolInfo: i, vol_24h: r3, openInterest: n4 };
};
var Fi = (e3) => {
  let t = Di(e3);
  return jsx(ki, { ...t });
};
var fa = (e3) => jsx("svg", { width: "12", height: "12", viewBox: "0 0 12 12", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...e3, children: jsx("g", { id: "Arrows-expand", children: jsx("path", { id: "Vector", d: "M5.9989 1.00708C5.8709 1.00708 5.7369 1.05008 5.6394 1.14758L3.7959 3.00708L4.4989 3.71008L5.4989 2.72607V4.50708C5.4989 4.78308 5.7229 5.00708 5.9989 5.00708C6.2749 5.00708 6.4989 4.78308 6.4989 4.50708V2.72607L7.4989 3.71008L8.2019 3.00708L6.3584 1.14758C6.2604 1.05008 6.1269 1.00708 5.9989 1.00708ZM5.9989 7.00707C5.7229 7.00707 5.4989 7.23107 5.4989 7.50707V9.28808L4.4989 8.30407L3.7959 9.00707L5.6394 10.8666C5.8349 11.0616 6.1629 11.0616 6.3584 10.8666L8.2019 9.00707L7.4989 8.30407L6.4989 9.28808V7.50707C6.4989 7.23107 6.2749 7.00707 5.9989 7.00707Z" }) }) });
function ha(e3) {
  var _a2, _b2, _c2;
  return jsxs("div", { className: "oui-pb-1 oui-flex oui-flex-col oui-gap-1", style: { height: e3.height }, ref: e3.boxRef, children: [jsx("div", { className: "oui-w-full oui-h-full", children: jsx(Si$1, { symbol: e3.symbol, libraryPath: (_a2 = e3.tradingViewConfig) == null ? void 0 : _a2.library_path, mode: 3, scriptSRC: (_b2 = e3.tradingViewConfig) == null ? void 0 : _b2.scriptSRC, customCssUrl: (_c2 = e3.tradingViewConfig) == null ? void 0 : _c2.customCssUrl }) }), jsx("div", { className: "oui-relative oui-w-full", children: jsx("div", { ref: e3.dragRef, className: cnBase("oui-h-[1px] oui-absolute oui-left-0 oui-right-0 oui-bottom-0 oui-top-0 oui-z-10 oui-mt-[7px] oui-bg-base-contrast-12", e3.dragging && "oui-bg-primary "), children: jsx(fa, { className: cnBase("oui-w-3 oui-h-3 oui-absolute oui-left-1/2 -oui-top-[5px] -oui-translate-y-[0.5px] oui-text-base-contrast-12", e3.dragging && " oui-text-primary") }) }) })] });
}
var Ed = 354, ya = 234, Wd = "TRADINGVIEW_MOBILE_HEIGHT";
function Sa(e3) {
  let [t, o] = useLocalStorage(Wd, ya), [i, r3] = useState(false), n4 = useRef(null), a2 = useRef(null), [s, m2] = useState(0), l2 = useRef(0), c2 = useCallback((d2) => {
    if (!a2.current) return;
    r3(true);
    let h2 = d2.touches[0], f2 = a2.current.getBoundingClientRect();
    d2.stopPropagation(), d2.preventDefault();
    let v2 = h2.clientY - f2.bottom;
    l2.current = f2.top, m2(v2);
  }, []), u2 = useCallback((d2) => {
    if (a2.current && i) {
      d2.stopPropagation(), d2.preventDefault();
      let f2 = d2.touches[0].clientY - l2.current - s;
      return o(Math.min(Math.max(Math.round(f2), ya), Ed)), false;
    }
  }, [i, s]), g2 = useCallback(() => {
    r3(false);
  }, []);
  return useEffect(() => {
    let d2 = n4.current;
    if (d2) return d2.addEventListener("touchstart", c2), () => {
      d2.removeEventListener("touchstart", c2);
    };
  }, [c2]), useEffect(() => (document.addEventListener("touchmove", u2, { passive: false }), document.addEventListener("touchend", g2), () => {
    document.removeEventListener("touchmove", u2), document.removeEventListener("touchend", g2);
  }), [i, u2, g2]), { ...e3, height: t, dragging: i, dragRef: n4, boxRef: a2 };
}
function Ca(e3) {
  let t = Sa(e3);
  return jsx(ha, { ...t });
}
var Ai = (e3) => {
  let { t } = Z$2(), { tradingViewConfig: o } = I();
  return jsxs(Cl, { variant: "contained", value: e3.tab, contentVisible: e3.visible, onValueChange: (i) => {
    e3.setTab(i), e3.setVisible(true);
  }, className: e3.className, classNames: { tabsList: "oui-p-2", tabsContent: "oui-min-h-[176px] oui-max-h-[396px]" }, style: { marginBottom: e3.tab === "chart" ? "8px" : 0 }, trailing: jsx("button", { className: "oui-px-5", onClick: e3.toggleContentVisible, children: jsx(Qd, { className: e3.visible ? "oui-rotate-0" : "oui-rotate-180" }) }), children: [jsx(Sl, { title: t("trading.tabs.chart"), value: "chart", children: jsx(Ca, { symbol: e3.symbol, tradingViewConfig: o }) }), jsx(Sl, { title: t("trading.tabs.trades"), value: "trades", children: jsx(da, { symbol: e3.symbol }) }), jsx(Sl, { title: t("trading.tabs.data"), value: "data", children: jsx(_$1, { px: 3, children: jsx(Fi, { symbol: e3.symbol }) }) })] });
}, Qd = (e3) => jsxs("svg", { width: "12", height: "12", viewBox: "0 0 12 12", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", className: cnBase("oui-fill-base-contrast-54 hover:oui-fill-base-contrast-80", e3.className), children: [jsx("path", { d: "M5.721 4.585 2.726 6.578a.51.51 0 0 0-.14.7.51.51 0 0 0 .702.14l2.714-1.806 2.715 1.806c.23.153.549.089.702-.14a.51.51 0 0 0-.14-.7L6.283 4.585a.51.51 0 0 0-.562 0" }), jsx("defs", {})] });
var Ii = (e3) => {
  let t = vi();
  return jsx(Ai, { className: e3.className, ...t });
};
var Mi = (e3) => {
  let [t, o] = useState(0), i = useRef(null);
  return useEffect(() => {
    let r3 = i.current;
    if (!r3) return;
    let n4 = new ResizeObserver((a2) => {
      for (let s of a2) o(s.contentRect.height);
    });
    return n4.observe(r3), () => {
      n4.unobserve(r3);
    };
  }, []), jsxs("div", { className: cnBase("oui-grid oui-grid-cols-[4fr,6fr] oui-gap-1 oui-mx-1 ", e3.className), children: [jsx("div", { className: "oui-bg-base-9 oui-rounded-xl", style: { height: `${t + 16}px` }, children: jsx(Ie, { symbol: e3.symbol, height: t ? t - 44 : void 0 }) }), jsx("div", { className: "oui-bg-base-9 oui-rounded-xl oui-p-2", children: jsx(ro$2, { symbol: e3.symbol, containerRef: i }) })] });
};
var _i = () => {
  let { symbol: e3 } = I();
  return { symbol: e3 };
};
var zi = (e3) => {
  let t = _i();
  return jsx(Mi, { className: e3.className, ...t });
};
var va = () => {
  let { appIcons: e3 } = rr$1(), { secondary: t } = e3 || {};
  return (t == null ? void 0 : t.img) ? jsx("img", { src: t == null ? void 0 : t.img, className: "oui-w-5 oui-h-5" }) : (t == null ? void 0 : t.component) ? t.component : null;
};
var Hi = (e3) => {
  let { symbol: t, sharePnLConfig: o } = e3, [i, r3] = useState("Position"), [n4, a2] = useState("Position history"), { t: s } = Z$2(), { onSymbolChange: m2 } = I(), l2 = W(), [c2, { cancelAllOrders: u2, cancelAllTPSLOrders: g2 }] = useOrderStream({}), { positionCount: d2 } = Ge(t), { pendingOrderCount: h2, tpSlOrderCount: f2 } = Ue(t);
  return { tab: i, setTab: r3, subTab: n4, setSubTab: a2, sharePnLConfig: o, symbol: t, positionCount: d2, pendingOrderCount: h2, tpSlOrderCount: f2, ...l2, onCloseAll: (P2) => {
    let N2 = P2 === Pe$2.pending ? s("orders.pending.cancelAll") : P2 === Pe$2.tp_sl ? s("orders.tpsl.cancelAll") : "", O2 = P2 === Pe$2.pending ? s("orders.pending.cancelAll.description") : P2 === Pe$2.tp_sl ? s("orders.tpsl.cancelAll.description") : "";
    uo$3.confirm({ title: N2, content: jsx($$4, { size: "2xs", children: O2 }), onOk: async () => {
      try {
        return i === "TP/SL" ? await g2() : await u2(), Promise.resolve(true);
      } catch (x2) {
        return (x2 == null ? void 0 : x2.message) !== void 0 && toast.error(x2.message), Promise.resolve(false);
      } finally {
        Promise.resolve();
      }
    } });
  }, onSymbolChange: m2 };
};
var Vi = (e3) => {
  let { t } = Z$2();
  return jsxs(Cl, { value: e3.tab, onValueChange: (o) => e3.setTab(o), size: "lg", className: e3.className, classNames: { tabsList: "oui-bg-base-9 oui-rounded-t-xl oui-p-2 oui-overflow-x-scroll oui-hide-scrollbar" }, children: [jsx(Sl, { title: `${t("common.positions")}${(e3.positionCount ?? 0) > 0 ? `(${e3.positionCount})` : ""}`, value: "Position", children: jsx(bg, { ...e3 }) }), jsx(Sl, { title: `${t("orders.status.pending")}${(e3.pendingOrderCount ?? 0) > 0 ? `(${e3.pendingOrderCount})` : ""}`, value: "Pending", children: jsx(Ei, { type: Pe$2.pending, ordersStatus: OrderStatus.INCOMPLETE, ...e3 }) }), jsx(Sl, { title: `${t("common.tpsl")}${(e3.tpSlOrderCount ?? 0) > 0 ? `(${e3.tpSlOrderCount})` : ""}`, value: "TP/SL", children: jsx(Ei, { type: Pe$2.tp_sl, ordersStatus: OrderStatus.INCOMPLETE, ...e3 }) }), jsx(Sl, { title: t("trading.history"), value: "History", children: jsx(yg, { ...e3 }) }), jsx(Sl, { title: t("positions.liquidation"), value: "Liquidation", children: jsx(ta$1, { enableLoadMore: true, symbol: e3.showAllSymbol ? void 0 : e3.symbol, classNames: { cell: "oui-p-2 oui-bg-base-9 oui-rounded-xl" } }) })] });
}, bg = (e3) => jsxs(z$1, { direction: "column", gap: 2, children: [jsx(Xe, { pnlNotionalDecimalPrecision: e3.pnlNotionalDecimalPrecision, symbol: e3.showAllSymbol ? void 0 : e3.symbol, unPnlPriceBasis: e3.unPnlPriceBasis }), jsx(Kr$1, { symbol: e3.showAllSymbol ? void 0 : e3.symbol, onSymbolChange: e3.onSymbolChange, sharePnLConfig: e3.sharePnLConfig, pnlNotionalDecimalPrecision: e3.pnlNotionalDecimalPrecision })] }), Ei = (e3) => jsxs(z$1, { direction: "column", pb: 2, width: "100%", children: [jsx(te$6, { className: "oui-w-full" }), e3.type !== Pe$2.orderHistory && jsx(xg, { ...e3 }), jsx(ks, { symbol: e3.showAllSymbol ? void 0 : e3.symbol, onSymbolChange: e3.onSymbolChange, type: e3.type, ordersStatus: e3.ordersStatus, classNames: { root: "oui-w-full oui-hide-scrollbar oui-overflow-y-hidden", content: "!oui-space-y-1", cell: "oui-py-2 oui-bg-base-9 oui-p-2 oui-rounded-xl" }, sharePnLConfig: e3.sharePnLConfig, showFilter: e3.type === Pe$2.orderHistory, filterConfig: { range: { from: void 0, to: void 0 } } })] }), xg = (e3) => {
  let { t } = Z$2();
  return jsxs(z$1, { px: 2, py: 2, width: "100%", justify: "between", gap: 2, className: "oui-rounded-b-xl oui-bg-base-9", children: [jsxs(z$1, { className: "oui-gap-[2px] oui-cursor-pointer", children: [jsx($r$1, { color: "white", checked: !e3.showAllSymbol, onCheckedChange: (o) => {
    e3.setShowAllSymbol(!o);
  } }), jsx($$4, { size: "2xs", intensity: 54, onClick: () => {
    e3.setShowAllSymbol(!e3.showAllSymbol);
  }, children: t("trading.hideOtherSymbols") })] }), jsx(_e$5, { variant: "outlined", size: "xs", color: "secondary", onClick: (o) => {
    e3.onCloseAll(e3.type);
  }, children: t("trading.orders.closeAll") })] });
}, yg = (e3) => {
  let { t } = Z$2();
  return jsx("div", { className: "oui-min-h-[300px]", children: jsxs(Cl, { value: e3.subTab, onValueChange: (o) => e3.setSubTab(o), size: "md", classNames: { tabsList: "oui-bg-base-9 oui-rounded-t-xl oui-p-2" }, children: [jsx(Sl, { title: t("positions.positionHistory"), value: "Position history", children: jsx(qs, { symbol: e3.showAllSymbol ? void 0 : e3.symbol, onSymbolChange: e3.onSymbolChange, classNames: { cell: "oui-p-2 oui-bg-base-9 oui-rounded-xl" }, sharePnLConfig: e3.sharePnLConfig }) }), jsx(Sl, { title: t("orders.orderHistory"), value: "Order history", children: jsx(Ei, { type: Pe$2.orderHistory, ...e3 }) })] }) });
};
var qi = (e3) => {
  let t = Hi(e3);
  return jsx(Vi, { ...t, className: e3.className });
};
var ka = (e3) => {
  let t = () => {
    e3.onOpenMarketsSheetChange(true);
  }, o = jsxs(_$1, { intensity: 900, px: 3, height: 54, children: [jsx(ii$1, { symbol: e3.symbol, trailing: jsxs(z$1, { gapX: 3, children: [jsx(lt$4, {}), jsx(va, {})] }), onSymbol: t }), jsx(Yo$1, { open: e3.openMarketsSheet, onOpenChange: e3.onOpenMarketsSheetChange, classNames: { body: "oui-h-full oui-pb-[env(safe-area-inset-bottom)]", content: "oui-w-[280px] !oui-p-0 oui-rounded-bl-[40px] oui-h-full " }, contentProps: { side: "left", closeable: false }, children: jsx(Jn$1, { symbol: e3.symbol, onSymbolChange: (i) => {
    var _a2;
    e3.onOpenMarketsSheetChange(false), (_a2 = e3.onSymbolChange) == null ? void 0 : _a2.call(e3, i);
  } }) })] });
  return jsxs("div", { style: { paddingBottom: "calc(64px + env(safe-area-inset-bottom))" }, className: "oui-grid oui-grid-rows-[auto,1fr,auto] oui-h-screen oui-gap-1 oui-relative oui-bg-base-10", children: [jsx("header", { children: o }), jsxs("main", { className: "oui-overflow-y-auto oui-hide-scrollbar oui-space-y-1", children: [jsx(Ii, { className: "oui-bg-base-9 oui-mx-1 oui-rounded-xl" }), jsx(zi, {}), jsx(qi, { symbol: e3.symbol, className: "oui-mx-1 oui-rounded-xl", sharePnLConfig: e3.sharePnLConfig })] }), jsx("div", { className: "oui-fixed oui-left-0 oui-right-0 oui-bottom-0", children: jsx(wi, {}) })] });
};
var We = (e3, t, o) => [useMemo(() => {
  let n4 = localStorage.getItem(e3);
  return n4 ? `${n4}%` : t;
}, [e3, t, o]), (n4) => {
  localStorage.setItem(e3, n4);
}];
var Fa = () => {
  let [e3, t] = useState(false), o = I(), { state: i } = useAccount(), { wrongNetwork: r3, disabledConnect: n4, restrictedInfo: a2 } = L$4(), { isFirstTimeDeposit: s } = So(), m2 = useMediaQuery("(max-width: 1279px)"), l2 = useMediaQuery("(min-width: 1440px)"), c2 = useMediaQuery("(max-width: 1680px)"), [u2, g2] = useLocalStorage("orderly_order_entry_side_markets_layout", "right"), d2 = useMemo(() => !r3 && !n4 && (i.status >= AccountStatusEnum.EnableTrading || i.status === AccountStatusEnum.EnableTradingWithoutConnected), [i.status, r3, n4]), h2 = useMemo(() => l2, [l2]), f2 = Rg({ canTrade: d2, isFirstTimeDeposit: s }), v2 = Og({ collapsable: l2 }), P2 = Ag(u2), N2 = Ig({ max2XL: m2 }), O2 = { layout: u2, onLayout: g2, max2XL: m2, min3XL: l2, max4XL: c2, canTrade: d2, openMarketsSheet: e3, onOpenMarketsSheetChange: t, horizontalDraggable: h2, ...v2, ...f2, ...P2, ...N2, restrictedInfo: a2 };
  return { ...o, ...O2 };
};
function Og(e3) {
  let { collapsable: t } = e3, [o, i] = useState(false), [r3, n4] = useLocalStorage("orderly_side_markets_collapsed", void 0), a2 = (m2) => {
    n4(m2), i(true);
  }, s = useMemo(() => t ? r3 : true, [t, r3]);
  return { collapsable: t, collapsed: s, onCollapse: a2, animating: o, setAnimating: i };
}
function Rg(e3) {
  let { canTrade: t, isFirstTimeDeposit: o } = e3, [i, r3] = useLocalStorage("orderly_assets_orderEntry_margin_positions", [0, 1, 2]), n4 = (m2, l2) => {
    let c2 = [...i];
    if (m2 === 0 && l2 === c2.length - 1) {
      c2[l2] = i[m2];
      for (let u2 = 0; u2 < c2.length - 1; u2++) c2[u2] = i[u2 + 1];
    } else if (m2 === c2.length - 1 && l2 === 0) {
      c2[l2] = i[m2];
      for (let u2 = 1; u2 < c2.length; u2++) c2[u2] = i[u2 - 1];
    } else [c2[m2], c2[l2]] = [c2[l2], c2[m2]];
    r3(c2);
  }, a2 = useMemo(() => t && !o, [t, o]);
  return { positions: useMemo(() => a2 ? i : [0, 1, 2], [a2, i]), showPositionIcon: a2, updatePositions: n4 };
}
function Ag(e3) {
  let [t, o] = We("orderly_main_split_size", void 0, e3), [i, r3] = We("orderly_datalist_split_size", "350px"), [n4, a2] = We("orderly_orderbook_split_size", "280px", e3), [s, m2] = We("orderly_datalist_split_height_sm", "350px"), [l2, c2] = We("orderly_orderbook_split_height_sm", "280px");
  return { orderBookSplitSize: n4, setOrderbookSplitSize: a2, dataListSplitSize: i, setDataListSplitSize: r3, mainSplitSize: t, setMainSplitSize: o, dataListSplitHeightSM: s, setDataListSplitHeightSM: m2, orderBookSplitHeightSM: l2, setOrderbookSplitHeightSM: c2 };
}
function Ig(e3) {
  let { max2XL: t } = e3, [o, i] = useState(0), r3 = useRef(null);
  return useEffect(() => {
    let n4 = r3.current;
    if (!n4 || !t) return;
    let a2 = new ResizeObserver((s) => {
      for (let m2 of s) {
        let l2 = m2.contentRect.height;
        l2 && i(l2);
      }
    });
    return a2.observe(n4), () => {
      a2.unobserve(n4);
    };
  }, [r3, t]), { orderEntryViewRef: r3, orderEntryHeight: o };
}
function La(e3) {
  return e3 ? `${100 - Math.min(Number(e3), 100)}` : "";
}
var Oa = (e3) => {
  let { t } = Z$2();
  return jsx(Gg, { ...e3, children: jsxs(z$1, { className: cnBase("oui-rounded-md", "oui-w-[69px] oui-h-[28px]", "oui-cursor-pointer oui-transition-all", "oui-bg-base-6 hover:oui-bg-base-4", "oui-text-base-contrast-54 hover:oui-text-base-contrast-80"), gapX: 1, ml: 3, justify: "center", itemAlign: "center", children: [jsx(Ug, {}), jsx($$4, { size: "2xs", weight: "semibold", children: t("trading.layout") })] }) });
}, Gg = (e3) => {
  let [t, o] = useState(false), { t: i } = Z$2(), r3 = (a2) => jsxs(z$1, { direction: "column", gapY: 2, onClick: () => {
    var _a2;
    (_a2 = e3.onLayout) == null ? void 0 : _a2.call(e3, a2), o(false);
  }, className: "oui-group", children: [jsx(z$1, { justify: a2 === "right" ? "end" : "start", className: cnBase("oui-w-[148px] oui-h-[100px]", "oui-bg-base-10 oui-rounded-[10px]", "oui-border-[4px] oui-border-base-5 group-hover:oui-border-primary-light", e3.layout === a2 && "!oui-border-primary-light"), children: jsx(_$1, { p: 1, children: jsx($g, {}) }) }), jsx($$4, { size: "2xs", intensity: 54, className: cnBase("oui-text-base-contrast-54 group-hover:oui-text-base-contrast-80", e3.layout === a2 && "oui-text-base-contrast-80"), children: i(a2 === "right" ? "trading.layout.right" : "trading.layout.left") })] }), n4 = jsxs(Fragment$1, { children: [jsxs(z$1, { itemAlign: "center", justify: "between", mt: 3, className: "oui-mb-[10px]", children: [jsx($$4, { size: "base", intensity: 98, children: i("trading.layout") }), jsx(ye$7, { size: 16, className: "oui-text-base-contrast-80 oui-cursor-pointer", opacity: 0.98, onClick: () => {
    o(false);
  } })] }), jsx(te$6, {}), jsxs(z$1, { gapX: 6, mt: 5, children: [r3("right"), r3("left")] })] });
  return jsxs(Yi, { open: t, onOpenChange: o, children: [jsx(Xi$1, { asChild: true, children: e3.children }), jsx(ji, { children: jsx(rr$2, { onCloseAutoFocus: (a2) => a2.preventDefault(), onClick: (a2) => a2.stopPropagation(), align: "end", className: cnBase("oui-bg-base-8 oui-p-5 oui-pt-0 oui-w-[360px] oui-font-semibold"), children: n4 }) })] });
}, Ug = (e3) => jsx("svg", { width: "17", height: "16", viewBox: "0 0 17 16", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...e3, children: jsx("path", { d: "M3.832 1.994c-.736 0-1.333.597-1.333 1.333v9.334c0 .737.597 1.333 1.333 1.333H6.5c.737 0 1.333-.596 1.333-1.333V3.327c0-.736-.596-1.333-1.333-1.333zm6.667 0c-.737 0-1.333.597-1.333 1.333v2.667c0 .737.596 1.333 1.333 1.333h2.667c.736 0 1.333-.596 1.333-1.333V3.327c0-.736-.597-1.333-1.333-1.333zm.437 6.679a2.7 2.7 0 0 0-1.033.607.284.284 0 0 0-.061.339c.222.411-.01.851-.512.876a.29.29 0 0 0-.26.217c-.05.207-.07.38-.07.608 0 .19.02.407.06.599a.28.28 0 0 0 .252.217c.506.044.756.429.53.92a.28.28 0 0 0 .06.321c.296.273.635.466 1.034.59a.285.285 0 0 0 .312-.104c.31-.427.757-.428 1.05 0a.28.28 0 0 0 .313.113 2.8 2.8 0 0 0 1.042-.599.28.28 0 0 0 .06-.33c-.23-.466.035-.894.513-.902a.28.28 0 0 0 .269-.209c.048-.199.06-.372.06-.616q0-.316-.069-.616a.276.276 0 0 0-.27-.217c-.469-.001-.732-.463-.502-.868a.27.27 0 0 0-.053-.339 2.8 2.8 0 0 0-1.059-.607.274.274 0 0 0-.312.112c-.268.417-.77.425-1.033.009a.284.284 0 0 0-.321-.121m.842 1.536a1.111 1.111 0 1 1 0 2.222 1.111 1.111 0 0 1 0-2.222" }) }), $g = (e3) => jsxs("svg", { width: "36", height: "84", viewBox: "0 0 36 84", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsx("rect", { width: "36", height: "17", rx: "2", fill: "#181C23" }), jsx("rect", { y: "19", width: "36", height: "54", rx: "2", fill: "#181C23" }), jsx("rect", { y: "75", width: "36", height: "9", rx: "2", fill: "#181C23" }), jsx("rect", { x: "3", y: "79", width: "30", height: "1", rx: "0.5", fill: "url(#paint0_linear_17647_26849)" }), jsx("rect", { x: "3", y: "22", width: "14", height: "6", rx: "2", fill: "#008676" }), jsx("rect", { x: "19", y: "22", width: "14", height: "6", rx: "2", fill: "#D92D6B" }), jsx("rect", { x: "3", y: "11", width: "14", height: "3", rx: "1.5", fill: "#333948" }), jsx("rect", { x: "19", y: "11", width: "14", height: "3", rx: "1.5", fill: "#335FFC" }), jsx("rect", { x: "3", y: "62", width: "30", height: "8", rx: "2", fill: "#008676" }), jsx("defs", { children: jsxs("linearGradient", { id: "paint0_linear_17647_26849", x1: "33", y1: "79.5", x2: "3", y2: "79.5", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "#59B0FE" }), jsx("stop", { offset: "1", stopColor: "#26FEFE" })] }) })] });
var Yt = (e3) => {
  let { showIndicator: t = true } = e3, [o, i] = useState(false);
  return jsxs(_$1, { intensity: 900, r: "2xl", p: 3, width: "100%", className: cnBase("oui-relative", e3.className), children: [e3.children, jsx(Xn$2, { open: o, onOpenChange: i, side: "left", align: "start", sideOffset: -4, alignOffset: -4, content: jsx(z$1, { direction: "column", gapY: 2, children: [jg, ef, tf].map((r3, n4) => jsx(r3, { className: cnBase("oui-rounded oui-cursor-pointer hover:oui-bg-base-5", e3.index === n4 && "oui-bg-base-5"), onClick: () => {
    var _a2;
    (_a2 = e3.onLayout) == null ? void 0 : _a2.call(e3, e3.index, n4), i(false);
  } }, n4)) }), delayDuration: 0, className: cnBase("oui-bg-base-9 oui-rounded", "oui-border oui-border-line-12", "oui-p-1"), arrow: { className: "oui-fill-transparent" }, children: t && jsx("div", { className: "oui-absolute oui-right-[1px] oui-top-[18px]", children: jsx(Jg, { className: cnBase("oui-text-base-contrast-20 hover:oui-text-base-contrast-80", "oui-cursor-pointer") }) }) })] });
}, Jg = (e3) => jsxs("svg", { width: "10", height: "16", viewBox: "0 0 10 16", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...e3, children: [jsx("rect", { x: "2", y: "2", width: "6", height: "2", rx: "1" }), jsx("rect", { x: "2", y: "7", width: "6", height: "2", rx: "1" }), jsx("rect", { x: "2", y: "12", width: "6", height: "2", rx: "1" })] }), jg = (e3) => jsxs("svg", { width: "16", height: "16", viewBox: "0 0 16 16", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...e3, children: [jsx("rect", { x: "1.333", y: "2.667", width: "13.333", height: "4", rx: "2", fill: "rgb(var(--oui-color-primary))" }), jsx("rect", { x: "2.667", y: "12", width: "10.667", height: "1.333", rx: ".667", fill: "#fff", fillOpacity: ".2" }), jsx("rect", { x: "2.667", y: "8.667", width: "10.667", height: "1.333", rx: ".667", fill: "#fff", fillOpacity: ".2" })] }), ef = (e3) => jsxs("svg", { width: "16", height: "16", viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...e3, children: [jsx("rect", { x: "1.333", y: "6", width: "13.333", height: "4", rx: "2", fill: "rgb(var(--oui-color-primary))" }), jsx("rect", { x: "2.667", y: "12", width: "10.667", height: "1.333", rx: ".667", fill: "#fff", fillOpacity: ".2" }), jsx("rect", { x: "2.667", y: "2.667", width: "10.667", height: "1.333", rx: ".667", fill: "#fff", fillOpacity: ".2" })] }), tf = (e3) => jsxs("svg", { width: "16", height: "16", viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...e3, children: [jsx("rect", { x: "1.333", y: "9.333", width: "13.333", height: "4", rx: "2", fill: "rgb(var(--oui-color-primary))" }), jsx("rect", { x: "2.667", y: "6", width: "10.667", height: "1.333", rx: ".667", fill: "#fff", fillOpacity: ".2" }), jsx("rect", { x: "2.667", y: "2.667", width: "10.667", height: "1.333", rx: ".667", fill: "#fff", fillOpacity: ".2" })] });
var Ra = (e3) => {
  let { collapsable: t, collapsed: o, onCollapse: i, layout: r3, onLayout: n4, orderBookSplitSize: a2, setOrderbookSplitSize: s, dataListSplitSize: m2, setDataListSplitSize: l2, mainSplitSize: c2, setMainSplitSize: u2, dataListSplitHeightSM: g2, setDataListSplitHeightSM: d2, orderBookSplitHeightSM: h2, setOrderbookSplitHeightSM: f2, max2XL: v2, max4XL: P2, animating: N2, setAnimating: O2, positions: x2, updatePositions: L2, canTrade: Se3, showPositionIcon: ie2, horizontalDraggable: fe2 } = e3, De2 = 6, Fe2 = 48, Le3 = 29, y2 = 12, R2 = 54, E3 = o ? 70 : 280, Ce2 = 280, Ve3 = 360, lt2 = 280, Ma2 = 732, pe2 = 464, ct2 = 728, qe2 = 320, ut2 = 600, mt2 = 540, dt2 = Se3 ? 379 : 277, _a2 = Fe2 + Le3 + R2 + pe2 + dt2 + y2 * 4, za2 = Fe2 + Le3 + R2 + qe2 + pe2 + dt2 + y2 * 4, Yi2 = jsx(Mn, { collapsable: t, collapsed: o, onCollapse: i, symbol: e3.symbol, onSymbolChange: e3.onSymbolChange }), Jt2 = jsx(_$1, { intensity: 900, pt: 3, r: "2xl", height: "100%", width: E3, style: { minWidth: E3 }, className: "oui-transition-all oui-duration-150", onTransitionEnd: () => {
    O2(false);
  }, children: !N2 && Yi2 }), Ha2 = useMemo(() => jsx(Oa, { layout: r3, onLayout: n4 }), [r3, n4]), Zi2 = jsx(_$1, { intensity: 900, r: "2xl", px: 3, width: "100%", style: { minHeight: R2, height: R2 }, children: jsx(yi$1, { symbol: e3.symbol, onSymbolChange: e3.onSymbolChange, trailing: Ha2 }) }), { library_path: Ea2, ...Wa } = e3.tradingViewConfig, Ji2 = jsx(Si$1, { symbol: e3.symbol, ...Wa, libraryPath: Ea2 }), ji2 = jsx(_$1, { width: "100%", height: "100%", intensity: 900, r: "2xl", style: { flex: 1, minWidth: mt2 }, className: "oui-overflow-hidden", children: Ji2 }), er2 = jsx(Uo, { symbol: e3.symbol }), Va2 = jsx(_$1, { r: "2xl", height: "100%", style: { minWidth: lt2, maxWidth: fe2 ? Ma2 : lt2, width: a2 }, className: "oui-overflow-hidden", children: er2 }), tr2 = jsx(so, { current: void 0, symbol: e3.symbol, sharePnLConfig: e3.sharePnLConfig }), qa2 = jsx(_$1, { intensity: 900, r: "2xl", p: 3, style: { height: m2, minHeight: dt2 }, className: "oui-overflow-hidden", children: tr2 }), Ga2 = [jsx(Yt, { className: "oui-border oui-border-line-12", index: x2.findIndex((re2) => re2 === 0), onLayout: L2, showIndicator: ie2, children: jsx(Co, {}) }, "assets"), jsx(Yt, { index: x2.findIndex((re2) => re2 === 1), onLayout: L2, showIndicator: ie2, children: jsx(ro$2, { symbol: e3.symbol }) }, "orderEntry"), jsx(Yt, { index: x2.findIndex((re2) => re2 === 2), onLayout: L2, showIndicator: ie2, children: jsx(Vo, {}) }, "margin")], or2 = x2.map((re2) => Ga2[re2]), ir2 = jsx(z$1, { gapY: 3, direction: "column", height: "100%", style: { minWidth: Ce2, maxWidth: fe2 ? Ve3 : Ce2, width: c2 }, children: or2 }), rr2 = jsxs(_e2, { style: { flex: 1, minHeight: pe2 }, onSizeChange: s, disable: !fe2, children: [P2 && r3 === "right" ? jsxs(z$1, { gap: 3, className: "oui-flex-1 oui-overflow-hidden", style: { minWidth: E3 + mt2 + y2 }, children: [Jt2, ji2] }) : ji2, Va2] }), Ua2 = () => P2 && r3 === "left" ? jsxs(z$1, { gapX: 3, style: { minHeight: pe2 }, height: "100%", children: [rr2, Jt2] }) : rr2, $a2 = jsxs(z$1, { direction: "column", className: "oui-flex-1 oui-overflow-hidden", gap: 3, style: { minWidth: P2 ? E3 + mt2 + lt2 + y2 * 2 : mt2 + lt2 + y2 }, children: [Zi2, jsxs(_e2, { className: "oui-w-full !oui-h-[calc(100%_-_54px_-_12px)]", mode: "vertical", onSizeChange: l2, children: [Ua2(), qa2] })] }), Qa = (re2) => u2(r3 === "left" ? La(re2) : re2);
  return v2 ? jsxs(_e2, { style: { minHeight: za2, minWidth: 1024 - De2 }, className: cnBase("oui-flex oui-flex-1 oui-overflow-hidden", "oui-min-w-[1018px] oui-h-full oui-w-full", "oui-p-3", e3.className), onSizeChange: d2, mode: "vertical", children: [jsxs(z$1, { gapX: 3, itemAlign: "stretch", className: cnBase("oui-flex-1", r3 === "left" && "oui-flex-row-reverse"), style: { minHeight: Math.max(R2 + qe2 + pe2 + y2 * 2, e3.orderEntryHeight), maxHeight: R2 + ut2 + ct2 + y2 * 2 }, children: [jsxs(z$1, { height: "100%", className: "oui-flex-1 oui-w-[calc(100%_-_280px_-_12px)]", direction: "column", gapY: 3, children: [Zi2, jsxs(z$1, { width: "100%", height: "100%", gapX: 3, itemAlign: "stretch", style: { minHeight: qe2 + pe2 + y2, maxHeight: ut2 + ct2 + y2 }, className: cnBase("oui-flex-1", r3 === "left" && "oui-flex-row-reverse"), children: [jsx(_$1, { intensity: 900, pt: 3, r: "2xl", width: E3, style: { minHeight: qe2 + pe2 + y2, maxHeight: ut2 + ct2 + y2 }, children: Yi2 }), jsxs(_e2, { mode: "vertical", style: { width: `calc(100% - ${E3}px)` }, className: "oui-flex-1", onSizeChange: f2, children: [jsx(_$1, { width: "100%", intensity: 900, r: "2xl", style: { minHeight: qe2, maxHeight: ut2 }, children: Ji2 }), jsx(_$1, { r: "2xl", height: "100%", width: "100%", style: { minHeight: pe2, maxHeight: ct2, height: h2 }, className: "oui-flex-1", children: er2 })] })] })] }), jsx(z$1, { ref: e3.orderEntryViewRef, gapY: 3, direction: "column", style: { width: Ce2, height: "max-content" }, children: or2 })] }), jsx(_$1, { intensity: 900, r: "2xl", p: 3, style: { height: g2, minHeight: dt2 }, className: "oui-overflow-hidden", children: tr2 })] }) : jsxs(z$1, { style: { minHeight: _a2, minWidth: 1440 - De2 }, className: cnBase(e3.className, r3 === "left" && "oui-flex-row-reverse"), width: "100%", p: 3, gap: 3, children: [!P2 && Jt2, jsxs(_e2, { className: "oui-flex oui-flex-1 oui-overflow-hidden", onSizeChange: Qa, disable: !fe2, children: [r3 === "left" && ir2, $a2, r3 === "right" && ir2] })] });
};
var Ki = (e3) => {
  let { isMobile: t } = Ao$6();
  return t ? jsx(ka, { ...e3 }) : jsx(Ra, { className: "oui-h-[calc(100vh_-_48px_-_29px)] oui-bg-base-10", ...e3 });
};
var Xi = () => {
  let e3 = Fa();
  return jsx(Ki, { ...e3 });
};
var uf = (e3) => jsx(ur, { symbol: e3.symbol, tradingViewConfig: e3.tradingViewConfig, onSymbolChange: e3.onSymbolChange, disableFeatures: e3.disableFeatures, overrideFeatures: e3.overrideFeatures, referral: e3.referral, tradingRewards: e3.tradingRewards, bottomSheetLeading: e3.bottomSheetLeading, sharePnLConfig: e3.sharePnLConfig, children: jsx(Xi, {}) });
const DEFAULT_SYMBOL = "PERP_ETH_USDC";
const ORDERLY_SYMBOL_KEY = "orderly-current-symbol";
function getSymbol() {
  return localStorage.getItem(ORDERLY_SYMBOL_KEY) || DEFAULT_SYMBOL;
}
function updateSymbol(symbol) {
  localStorage.setItem(ORDERLY_SYMBOL_KEY, symbol || DEFAULT_SYMBOL);
}
function generatePageTitle(title) {
  return `${title} | ${"NincoFi"}`;
}
function formatSymbol(symbol, format2 = "base-type") {
  const arr = symbol.split("_");
  const type = arr[0];
  const base = arr[1];
  const quote = arr[2];
  return format2.replace("type", type).replace("base", base).replace("quote", quote);
}
const meta$8 = () => {
  return [{ title: generatePageTitle("Positions") }];
};
function PositionsPage() {
  const local = W();
  const navigate = useNavigate();
  const [searchParams] = useSearchParams();
  const onSymbolChange = useCallback(
    (data) => {
      const symbol = data.symbol;
      updateSymbol(symbol);
      const searchParamsString = searchParams.toString();
      const queryString = searchParamsString ? `?${searchParamsString}` : "";
      navigate(`/perp/${symbol}${queryString}`);
    },
    [navigate, searchParams]
  );
  return /* @__PURE__ */ jsx(
    _$1,
    {
      p: 6,
      pb: 0,
      intensity: 900,
      r: "xl",
      width: "100%",
      style: {
        minHeight: 379,
        maxHeight: 2560,
        overflow: "hidden",
        // Make the table scroll instead of the page scroll
        height: "calc(100vh - 48px - 29px - 48px)"
      },
      children: /* @__PURE__ */ jsx(
        Co$3.PositionsPage,
        {
          sharePnLConfig: config.tradingPage.sharePnLConfig,
          pnlNotionalDecimalPrecision: local.pnlNotionalDecimalPrecision,
          calcMode: local.unPnlPriceBasis,
          onSymbolChange
        }
      )
    }
  );
}
const route1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: PositionsPage,
  meta: meta$8
}, Symbol.toStringTag, { value: "Module" }));
const meta$7 = () => {
  return [{ title: generatePageTitle("API keys") }];
};
function APIKeyPage() {
  return /* @__PURE__ */ jsx(Mo$1.APIManagerPage, {});
}
const route2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: APIKeyPage,
  meta: meta$7
}, Symbol.toStringTag, { value: "Module" }));
const meta$6 = () => {
  return [{ title: generatePageTitle("Settings") }];
};
function SettingsPage() {
  return /* @__PURE__ */ jsx($o.SettingPage, {});
}
const route3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: SettingsPage,
  meta: meta$6
}, Symbol.toStringTag, { value: "Module" }));
const meta$5 = () => {
  return [{ title: generatePageTitle("Portfolio") }];
};
function PortfolioPage() {
  return /* @__PURE__ */ jsx(so$2.OverviewPage, {});
}
const route4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: PortfolioPage,
  meta: meta$5
}, Symbol.toStringTag, { value: "Module" }));
const meta$4 = () => {
  return [{ title: generatePageTitle("Orders") }];
};
function OrdersPage() {
  return /* @__PURE__ */ jsx(
    _$1,
    {
      p: 6,
      pb: 0,
      intensity: 900,
      r: "xl",
      width: "100%",
      style: {
        minHeight: 379,
        maxHeight: 2560,
        overflow: "hidden",
        // Make the table scroll instead of the page scroll
        height: "calc(100vh - 48px - 29px - 48px)"
      },
      children: /* @__PURE__ */ jsx(vo$2.OrdersPage, {})
    }
  );
}
const route5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: OrdersPage,
  meta: meta$4
}, Symbol.toStringTag, { value: "Module" }));
const meta$3 = () => {
  return [{ title: generatePageTitle("Markets") }];
};
function MarketsPage$1() {
  return /* @__PURE__ */ jsx(Bi, {});
}
const route6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: MarketsPage$1,
  meta: meta$3
}, Symbol.toStringTag, { value: "Module" }));
const meta$2 = () => {
  return [{ title: generatePageTitle("Fee tier") }];
};
function FeeTierPage() {
  return /* @__PURE__ */ jsx(yo$2.FeeTierPage, { dataAdapter: () => ({
    columns: [],
    dataSource: []
  }) });
}
const route7 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: FeeTierPage,
  meta: meta$2
}, Symbol.toStringTag, { value: "Module" }));
const meta$1 = ({ params }) => {
  return [{ title: generatePageTitle(formatSymbol(params.symbol)) }];
};
function PerpPage$1() {
  const params = useParams();
  const [symbol, setSymbol] = useState(params.symbol);
  const navigate = useNavigate();
  const [searchParams] = useSearchParams();
  useEffect(() => {
    updateSymbol(symbol);
  }, [symbol]);
  const onSymbolChange = useCallback(
    (data) => {
      const symbol2 = data.symbol;
      setSymbol(symbol2);
      const searchParamsString = searchParams.toString();
      const queryString = searchParamsString ? `?${searchParamsString}` : "";
      navigate(`/perp/${symbol2}${queryString}`);
    },
    [navigate, searchParams]
  );
  return /* @__PURE__ */ jsx(
    uf,
    {
      symbol,
      onSymbolChange,
      tradingViewConfig: config.tradingPage.tradingViewConfig,
      sharePnLConfig: config.tradingPage.sharePnLConfig
    }
  );
}
const route8 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: PerpPage$1,
  meta: meta$1
}, Symbol.toStringTag, { value: "Module" }));
function useNav() {
  const navigate = useNavigate();
  const [searchParams] = useSearchParams();
  const onRouteChange = useCallback(
    (option) => {
      const searchParamsString = searchParams.toString();
      const queryString = searchParamsString ? `?${searchParamsString}` : "";
      if (option.target === "_blank") {
        window.open(option.href);
        return;
      }
      if (option.href === "/") {
        const symbol = getSymbol();
        navigate(`/perp/${symbol}${queryString}`);
        return;
      }
      const routeMap = {
        //   "/portfolio": "/portfolio",
        "/portfolio/feeTier": "/portfolio/fee",
        "/portfolio/apiKey": "/portfolio/api-key"
        //   "/portfolio/positions": "/portfolio/positions",
        //   "/portfolio/orders": "/portfolio/orders",
        //   "/portfolio/setting": "/portfolio/setting",
      };
      const path2 = routeMap[option.href] || option.href;
      navigate(`${path2}${queryString}`);
    },
    [navigate, searchParams]
  );
  return { onRouteChange };
}
function PortfolioLayout() {
  const location = useLocation();
  const pathname = location.pathname;
  const { onRouteChange } = useNav();
  const currentPath = useMemo(() => {
    if (pathname.endsWith("/portfolio")) return "/portfolio";
    if (pathname.endsWith("/portfolio/fee")) return "/portfolio/feeTier";
    if (pathname.endsWith("/portfolio/api-key")) return "/portfolio/apiKey";
    return pathname;
  }, [pathname]);
  return /* @__PURE__ */ jsx(
    wi$1,
    {
      footerProps: config.scaffold.footerProps,
      mainNavProps: {
        ...config.scaffold.mainNavProps,
        initialMenu: "/portfolio"
      },
      routerAdapter: {
        onRouteChange
      },
      leftSideProps: {
        current: currentPath
      },
      children: /* @__PURE__ */ jsx(Outlet, {})
    }
  );
}
const route9 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: PortfolioLayout
}, Symbol.toStringTag, { value: "Module" }));
function MarketsPage() {
  const { onRouteChange } = useNav();
  return /* @__PURE__ */ jsx(
    Va,
    {
      mainNavProps: {
        ...config.scaffold.mainNavProps,
        initialMenu: "/markets"
      },
      footerProps: config.scaffold.footerProps,
      routerAdapter: {
        onRouteChange
      },
      children: /* @__PURE__ */ jsx(Outlet, {})
    }
  );
}
const route10 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: MarketsPage
}, Symbol.toStringTag, { value: "Module" }));
const meta = () => {
  return [
    { title: "Ninco" },
    { name: "description", content: "Ninco" }
  ];
};
const loader = ({ request: request2 }) => {
  const url = new URL(request2.url);
  const searchParamsString = url.search;
  const queryString = searchParamsString || "";
  return redirect(`/perp/${DEFAULT_SYMBOL}${queryString}`);
};
const route11 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  loader,
  meta
}, Symbol.toStringTag, { value: "Module" }));
function PerpPage() {
  const { onRouteChange } = useNav();
  return /* @__PURE__ */ jsx(
    Va,
    {
      mainNavProps: config.scaffold.mainNavProps,
      footerProps: config.scaffold.footerProps,
      routerAdapter: {
        onRouteChange,
        currentPath: "/"
      },
      children: /* @__PURE__ */ jsx(Outlet, {})
    }
  );
}
const route12 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: PerpPage
}, Symbol.toStringTag, { value: "Module" }));
const serverManifest = { "entry": { "module": "/assets/entry.client-DxraL-Ou.js", "imports": ["/assets/index-_b-vxSi4.js", "/assets/client-Df-1iYcO.js", "/assets/index-Di9JU0ht.js", "/assets/components-CdH6ss3X.js"], "css": [] }, "routes": { "root": { "id": "root", "parentId": void 0, "path": "", "index": void 0, "caseSensitive": void 0, "hasAction": false, "hasLoader": false, "hasClientAction": false, "hasClientLoader": false, "hasErrorBoundary": false, "module": "/assets/root-9dT4SAXz.js", "imports": ["/assets/index-_b-vxSi4.js", "/assets/client-Df-1iYcO.js", "/assets/index-Di9JU0ht.js", "/assets/components-CdH6ss3X.js", "/assets/root-GkU6dJ0W.js", "/assets/index-hxeryC1o.js", "/assets/index-BcrQDpUm.js", "/assets/config-DaBgEe5Y.js"], "css": ["/assets/root-D8grN33t.css"] }, "routes/portfolio.positions": { "id": "routes/portfolio.positions", "parentId": "routes/portfolio", "path": "positions", "index": void 0, "caseSensitive": void 0, "hasAction": false, "hasLoader": false, "hasClientAction": false, "hasClientLoader": false, "hasErrorBoundary": false, "module": "/assets/portfolio.positions-BhdD8U_U.js", "imports": ["/assets/index-_b-vxSi4.js", "/assets/index-hxeryC1o.js", "/assets/index-BaX2kz2g.js", "/assets/index-VB9196ZG.js", "/assets/storage-CT6iC30N.js", "/assets/config-DaBgEe5Y.js", "/assets/utils-OKWQP5Dn.js", "/assets/index-Di9JU0ht.js", "/assets/index-D1SqNoN2.js", "/assets/index-BcrQDpUm.js", "/assets/Trans-DyzQVnhk.js", "/assets/index-3_wm22oA.js", "/assets/index-CfItJzCW.js"], "css": ["/assets/index-CTpUD00e.css"] }, "routes/portfolio.api-key": { "id": "routes/portfolio.api-key", "parentId": "routes/portfolio", "path": "api-key", "index": void 0, "caseSensitive": void 0, "hasAction": false, "hasLoader": false, "hasClientAction": false, "hasClientLoader": false, "hasErrorBoundary": false, "module": "/assets/portfolio.api-key-DRVKRZCp.js", "imports": ["/assets/index-_b-vxSi4.js", "/assets/index-BaX2kz2g.js", "/assets/utils-OKWQP5Dn.js", "/assets/index-hxeryC1o.js", "/assets/index-D1SqNoN2.js", "/assets/index-BcrQDpUm.js", "/assets/Trans-DyzQVnhk.js", "/assets/index-3_wm22oA.js"], "css": [] }, "routes/portfolio.setting": { "id": "routes/portfolio.setting", "parentId": "routes/portfolio", "path": "setting", "index": void 0, "caseSensitive": void 0, "hasAction": false, "hasLoader": false, "hasClientAction": false, "hasClientLoader": false, "hasErrorBoundary": false, "module": "/assets/portfolio.setting-C6RS2A6t.js", "imports": ["/assets/index-_b-vxSi4.js", "/assets/index-BaX2kz2g.js", "/assets/utils-OKWQP5Dn.js", "/assets/index-hxeryC1o.js", "/assets/index-D1SqNoN2.js", "/assets/index-BcrQDpUm.js", "/assets/Trans-DyzQVnhk.js", "/assets/index-3_wm22oA.js"], "css": [] }, "routes/portfolio._index": { "id": "routes/portfolio._index", "parentId": "routes/portfolio", "path": void 0, "index": true, "caseSensitive": void 0, "hasAction": false, "hasLoader": false, "hasClientAction": false, "hasClientLoader": false, "hasErrorBoundary": false, "module": "/assets/portfolio._index-D47JI1Ae.js", "imports": ["/assets/index-_b-vxSi4.js", "/assets/index-BaX2kz2g.js", "/assets/utils-OKWQP5Dn.js", "/assets/index-hxeryC1o.js", "/assets/index-D1SqNoN2.js", "/assets/index-BcrQDpUm.js", "/assets/Trans-DyzQVnhk.js", "/assets/index-3_wm22oA.js"], "css": [] }, "routes/portfolio.orders": { "id": "routes/portfolio.orders", "parentId": "routes/portfolio", "path": "orders", "index": void 0, "caseSensitive": void 0, "hasAction": false, "hasLoader": false, "hasClientAction": false, "hasClientLoader": false, "hasErrorBoundary": false, "module": "/assets/portfolio.orders-7STlyBiF.js", "imports": ["/assets/index-_b-vxSi4.js", "/assets/index-hxeryC1o.js", "/assets/index-BaX2kz2g.js", "/assets/utils-OKWQP5Dn.js", "/assets/index-D1SqNoN2.js", "/assets/index-BcrQDpUm.js", "/assets/Trans-DyzQVnhk.js", "/assets/index-3_wm22oA.js"], "css": [] }, "routes/markets._index": { "id": "routes/markets._index", "parentId": "routes/markets", "path": void 0, "index": true, "caseSensitive": void 0, "hasAction": false, "hasLoader": false, "hasClientAction": false, "hasClientLoader": false, "hasErrorBoundary": false, "module": "/assets/markets._index-B7aTihG7.js", "imports": ["/assets/index-_b-vxSi4.js", "/assets/index-CfItJzCW.js", "/assets/utils-OKWQP5Dn.js", "/assets/index-hxeryC1o.js", "/assets/Trans-DyzQVnhk.js"], "css": [] }, "routes/portfolio.fee": { "id": "routes/portfolio.fee", "parentId": "routes/portfolio", "path": "fee", "index": void 0, "caseSensitive": void 0, "hasAction": false, "hasLoader": false, "hasClientAction": false, "hasClientLoader": false, "hasErrorBoundary": false, "module": "/assets/portfolio.fee-1BIj6VJA.js", "imports": ["/assets/index-_b-vxSi4.js", "/assets/index-BaX2kz2g.js", "/assets/utils-OKWQP5Dn.js", "/assets/index-hxeryC1o.js", "/assets/index-D1SqNoN2.js", "/assets/index-BcrQDpUm.js", "/assets/Trans-DyzQVnhk.js", "/assets/index-3_wm22oA.js"], "css": [] }, "routes/perp.$symbol": { "id": "routes/perp.$symbol", "parentId": "routes/perp", "path": ":symbol", "index": void 0, "caseSensitive": void 0, "hasAction": false, "hasLoader": false, "hasClientAction": false, "hasClientLoader": false, "hasErrorBoundary": false, "module": "/assets/perp._symbol-B-gwJp3H.js", "imports": ["/assets/index-_b-vxSi4.js", "/assets/index-VB9196ZG.js", "/assets/config-DaBgEe5Y.js", "/assets/storage-CT6iC30N.js", "/assets/utils-OKWQP5Dn.js", "/assets/index-Di9JU0ht.js", "/assets/index-hxeryC1o.js", "/assets/index-BcrQDpUm.js", "/assets/index-3_wm22oA.js", "/assets/index-D1SqNoN2.js", "/assets/Trans-DyzQVnhk.js", "/assets/index-CfItJzCW.js"], "css": ["/assets/index-CTpUD00e.css"] }, "routes/portfolio": { "id": "routes/portfolio", "parentId": "root", "path": "portfolio", "index": void 0, "caseSensitive": void 0, "hasAction": false, "hasLoader": false, "hasClientAction": false, "hasClientLoader": false, "hasErrorBoundary": false, "module": "/assets/portfolio-CgbM224U.js", "imports": ["/assets/index-_b-vxSi4.js", "/assets/index-BaX2kz2g.js", "/assets/config-DaBgEe5Y.js", "/assets/useNav-BJbglFTv.js", "/assets/index-Di9JU0ht.js", "/assets/index-hxeryC1o.js", "/assets/index-D1SqNoN2.js", "/assets/index-BcrQDpUm.js", "/assets/Trans-DyzQVnhk.js", "/assets/index-3_wm22oA.js", "/assets/storage-CT6iC30N.js"], "css": [] }, "routes/markets": { "id": "routes/markets", "parentId": "root", "path": "markets", "index": void 0, "caseSensitive": void 0, "hasAction": false, "hasLoader": false, "hasClientAction": false, "hasClientLoader": false, "hasErrorBoundary": false, "module": "/assets/markets-CH1niqmv.js", "imports": ["/assets/index-_b-vxSi4.js", "/assets/index-D1SqNoN2.js", "/assets/config-DaBgEe5Y.js", "/assets/useNav-BJbglFTv.js", "/assets/index-Di9JU0ht.js", "/assets/index-hxeryC1o.js", "/assets/index-BcrQDpUm.js", "/assets/Trans-DyzQVnhk.js", "/assets/storage-CT6iC30N.js"], "css": [] }, "routes/_index": { "id": "routes/_index", "parentId": "root", "path": void 0, "index": true, "caseSensitive": void 0, "hasAction": false, "hasLoader": true, "hasClientAction": false, "hasClientLoader": false, "hasErrorBoundary": false, "module": "/assets/_index-Cem3OJLo.js", "imports": [], "css": [] }, "routes/perp": { "id": "routes/perp", "parentId": "root", "path": "perp", "index": void 0, "caseSensitive": void 0, "hasAction": false, "hasLoader": false, "hasClientAction": false, "hasClientLoader": false, "hasErrorBoundary": false, "module": "/assets/perp-o0w_R8ax.js", "imports": ["/assets/index-_b-vxSi4.js", "/assets/index-D1SqNoN2.js", "/assets/config-DaBgEe5Y.js", "/assets/useNav-BJbglFTv.js", "/assets/index-Di9JU0ht.js", "/assets/index-hxeryC1o.js", "/assets/index-BcrQDpUm.js", "/assets/Trans-DyzQVnhk.js", "/assets/storage-CT6iC30N.js"], "css": [] } }, "url": "/assets/manifest-917b2e30.js", "version": "917b2e30" };
const mode = "production";
const assetsBuildDirectory = "build/client";
const basename = "/";
const future = { "v3_fetcherPersist": true, "v3_relativeSplatPath": true, "v3_throwAbortReason": true, "v3_routeConfig": false, "v3_singleFetch": true, "v3_lazyRouteDiscovery": true, "unstable_optimizeDeps": false };
const isSpaMode = false;
const publicPath = "/";
const entry = { module: entryServer };
const routes = {
  "root": {
    id: "root",
    parentId: void 0,
    path: "",
    index: void 0,
    caseSensitive: void 0,
    module: route0
  },
  "routes/portfolio.positions": {
    id: "routes/portfolio.positions",
    parentId: "routes/portfolio",
    path: "positions",
    index: void 0,
    caseSensitive: void 0,
    module: route1
  },
  "routes/portfolio.api-key": {
    id: "routes/portfolio.api-key",
    parentId: "routes/portfolio",
    path: "api-key",
    index: void 0,
    caseSensitive: void 0,
    module: route2
  },
  "routes/portfolio.setting": {
    id: "routes/portfolio.setting",
    parentId: "routes/portfolio",
    path: "setting",
    index: void 0,
    caseSensitive: void 0,
    module: route3
  },
  "routes/portfolio._index": {
    id: "routes/portfolio._index",
    parentId: "routes/portfolio",
    path: void 0,
    index: true,
    caseSensitive: void 0,
    module: route4
  },
  "routes/portfolio.orders": {
    id: "routes/portfolio.orders",
    parentId: "routes/portfolio",
    path: "orders",
    index: void 0,
    caseSensitive: void 0,
    module: route5
  },
  "routes/markets._index": {
    id: "routes/markets._index",
    parentId: "routes/markets",
    path: void 0,
    index: true,
    caseSensitive: void 0,
    module: route6
  },
  "routes/portfolio.fee": {
    id: "routes/portfolio.fee",
    parentId: "routes/portfolio",
    path: "fee",
    index: void 0,
    caseSensitive: void 0,
    module: route7
  },
  "routes/perp.$symbol": {
    id: "routes/perp.$symbol",
    parentId: "routes/perp",
    path: ":symbol",
    index: void 0,
    caseSensitive: void 0,
    module: route8
  },
  "routes/portfolio": {
    id: "routes/portfolio",
    parentId: "root",
    path: "portfolio",
    index: void 0,
    caseSensitive: void 0,
    module: route9
  },
  "routes/markets": {
    id: "routes/markets",
    parentId: "root",
    path: "markets",
    index: void 0,
    caseSensitive: void 0,
    module: route10
  },
  "routes/_index": {
    id: "routes/_index",
    parentId: "root",
    path: void 0,
    index: true,
    caseSensitive: void 0,
    module: route11
  },
  "routes/perp": {
    id: "routes/perp",
    parentId: "root",
    path: "perp",
    index: void 0,
    caseSensitive: void 0,
    module: route12
  }
};
export {
  serverManifest as assets,
  assetsBuildDirectory,
  basename,
  entry,
  future,
  isSpaMode,
  mode,
  publicPath,
  routes
};
